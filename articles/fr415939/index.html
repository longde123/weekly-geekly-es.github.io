<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◀️ 🏇🏼 🥙 Traitement graphique distribué avec Spark GraphX 🐔 🌭 📈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""La simplicité est une condition préalable à la fiabilité" par Edsger Dijkstra 

 Prologue 
 Les graphiques sont une structure de données tellement cl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Traitement graphique distribué avec Spark GraphX</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415939/"><img src="https://spark.apache.org/docs/latest/img/graphx_logo.png" alt="image"><br><br>  <i>"La simplicité est une condition préalable à la fiabilité" par Edsger Dijkstra</i> <br><br><h3>  Prologue </h3><br>  Les graphiques sont une structure de données tellement claire et facile à comprendre, car depuis l'époque de Leonhard Euler, elle a forcé l'esprit de l'humanité à travers des tâches hétérogènes, telles que la façon dont vous pouvez traverser les sept ponts de Königsberg sans passer par l'un d'eux deux fois ou en tant qu'intermédiaire itinérant, trouver le plus itinéraire rentable. <br><a name="habracut"></a><br>  Beaucoup de choses ont changé depuis Euler: les transistors, les langages de programmation et l'informatique distribuée sont apparus.  C'est le dernier de cette liste qui a considérablement simplifié le stockage et le traitement des graphiques.  En fait, c'est ce qui sera discuté dans cet article. <br><br>  Si vous n'êtes pas familier avec les concepts de base d'Apache Spark tels que RDD, programme pilote, nœud de travail, etc., avant de poursuivre cet article, je vous recommande de lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> de Databricks. <br><br>  Quant à moi, la meilleure façon de gérer une technologie est d'essayer d'écrire quelque chose dessus.  Dans cet article, nous ferons une analyse de la similitude d'un «réseau social» en utilisant les concepts de base de la théorie des graphes. <br><br><h3>  Écrire un code </h3><br>  La méthode de stockage de notre «réseau social» que j'ai choisie était extrêmement simple et intuitive: les fichiers tsv sur disque, bien sûr, il pouvait s'agir de fichiers de tout autre format comme Parquet, Avro.  L'emplacement de stockage des fichiers n'a pas d'importance s'il peut s'agir de HDFS ou S3, même si nous devons changer quelque chose, alors Spark SQL fera le travail principal pour nous.  La structure du réseau sera la suivante: le premier fichier est une paire d'ID utilisateur et son nom, le deuxième fichier d'ID utilisateur et une liste de pairs.  Apache Spark prend en charge les langages de programmation Java, Scala et Python suivants en tant qu'API.  J'ai choisi le second. <br><br>  Immédiatement, je veux répondre à la question populaire de savoir s'il vaut la peine d'utiliser Spark GraphX ​​pour stocker des graphiques lorsque vous avez de nombreuses opérations d'insertion / mise à jour - la réponse est non, toutes les opérations de changement de RDD forcent à changer l'ensemble du RDD dans le cluster, ce qui n'est pas la solution optimale, des solutions spéciales conviennent à ce cas Solution NoSql comme Neo4J, Titanium ou encore Cassandra, Hbase.  Rien ne vous empêche d'utiliser Spark GraphX ​​avec eux spécifiquement pour traiter des graphiques, charger les données elles-mêmes depuis la base de données, par exemple, par sheduler ou dans un style événementiel. <br><br>  Eh bien, commençons à écrire du code.  Tout d'abord, nous devons charger le graphique en mémoire, prendre les fichiers source et extraire les sommets et bords nécessaires (voici les principaux points, un lien vers la liste complète avec le code source se trouve à la fin de l'article): <br><br><pre><code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">verts</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>)] = sc.textFile(<span class="hljs-type"><span class="hljs-type">USER_NAMES</span></span>) .flatMap(<span class="hljs-type"><span class="hljs-type">InputDataFlow</span></span>.parseNames) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">edges</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">RDD</span></span>[<span class="hljs-type"><span class="hljs-type">Edge</span></span>[<span class="hljs-type"><span class="hljs-type">PartitionID</span></span>]] = sc.textFile(<span class="hljs-type"><span class="hljs-type">USER_GRAPH</span></span>) .flatMap(<span class="hljs-type"><span class="hljs-type">InputDataFlow</span></span>.makeEdges)</code> </pre> <br><h3>  Pregel </h3><br>  Le principal mécanisme d'itération des graphes dans GraphX ​​est l'algorithme Pregel.  L'algorithme a été développé par Google, le modèle Pregel utilise le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">transfert de messages</a> entre les sommets du graphe.  Le message passant par une série d'itérations appelées supersteps est l'idée principale derrière cet algorithme.  De plus, l'idée principale peut être décrite comme suit: <i>«penser comme un sommet»</i> , c'est-à-dire que l'état du sommet actuel ne dépend que de l'état de ses voisins. <br><br>  Pregel devient extrêmement nécessaire lorsque la résolution d'un problème avec un MapReduce régulier devient un processus extrêmement difficile.  Fait intéressant, le nom Pregel vient du nom de la rivière, qui enjambait les sept ponts de Koenigsberg. <br><br>  La principale primitive pour parcourir un graphe est un triplet - il se compose des composants suivants: le sommet actuel (un sommet source), le sommet auquel nous passons (un sommet de destination) et le bord entre eux (un bord se connectant) - tout est clair: où allez où nous allons et où nous allons.  De plus, pour Pregel, vous devez spécifier la distance par défaut entre les sommets, en règle générale, c'est une fonction PositiveInfinity, UDF (fonction définie par l'utilisateur) pour chaque sommet pour traiter le message entrant et calculer le sommet suivant, et UDF pour fusionner les deux messages entrants, cette fonction doit être commutative et associatif.  Puisque Scala est un langage fonctionnel, les deux dernières fonctions seront représentées comme deux expressions lambda. <br><br>  Lorsque nous avons déjà démonté les principaux composants de Pregel, cela vaut la peine de venir pratiquer.  Le premier algorithme que nous allons implémenter est l'algorithme de Dijkstra pour trouver le chemin le plus court d'un sommet arbitraire à tous les autres. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dijkstraShortestPath</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">VT</span></span>](graph: <span class="hljs-type"><span class="hljs-type">GenericGraph</span></span>[<span class="hljs-type"><span class="hljs-type">VT</span></span>], sourceId: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> initialGraph = graph.mapVertices((id, _) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == sourceId) <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sssp = initialGraph.pregel(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>)( (_, dist, newDist) =&gt; math.min(dist, newDist), triplet =&gt; { <span class="hljs-comment"><span class="hljs-comment">//Distance accumulator if (triplet.srcAttr + triplet.attr &lt; triplet.dstAttr) { Iterator((triplet.dstId, triplet.srcAttr + triplet.attr)) } else { Iterator.empty } }, (a, b) =&gt; math.min(a, b) ) sssp.vertices.sortByKey(ascending = true).collect.mkString("\n") }</span></span></code> </pre> <br>  Tout est évident ici: on part d'un sommet donné, on utilise la fonction minimum pour déterminer la distance minimum à chaque pas.  La première fonction utilisée par Pregel conserve la distance la plus courte entre le message entrant et le sommet actuel.  La deuxième fonction distribue des messages aux voisins tout en maintenant la distance.  La dernière fonction - c'est un analogue de l'étape Réduire - sélectionne la valeur minimale dans le cas de plusieurs messages entrants.  Ensuite, nous formons simplement une sortie graphique pratique. <br><br><h3>  Degré de séparation </h3><br>  Je suis sûr que de nombreux lecteurs de cet article ont entendu parler de la théorie des six poignées de main ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Six degrés de séparation</a> ) - c'est une théorie non prouvée selon laquelle deux personnes sont séparées par pas plus de cinq niveaux de connaissances communes, c'est-à-dire, un maximum de 6 poignées de main est nécessaire pour connecter deux arbitraires homme sur terre.  En termes de théorie des graphes, cela ressemble à ceci: le diamètre du graphique de datation ne dépasse pas 6 pour deux personnes sur Terre. <br><br>  Commençons à écrire le code avec ce qui suit, nous avons besoin d'une recherche en largeur sur le graphique pour rechercher des contacts du sommet indiqué, pour cela, nous devons modifier le code de l'algorithme de Dijkstra: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBFS</span></span></span></span>(root: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> initialGraph = graph.mapVertices((id, _) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == root) <span class="hljs-number"><span class="hljs-number">0.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bfs = initialGraph.pregel(<span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>, maxIterations = <span class="hljs-number"><span class="hljs-number">10</span></span>)( (_, attr, msg) =&gt; math.min(attr, msg), triplet =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (triplet.srcAttr != <span class="hljs-type"><span class="hljs-type">Double</span></span>.<span class="hljs-type"><span class="hljs-type">PositiveInfinity</span></span>) { <span class="hljs-type"><span class="hljs-type">Iterator</span></span>((triplet.dstId, triplet.srcAttr + <span class="hljs-number"><span class="hljs-number">1</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">Iterator</span></span>.empty } }, (a, b) =&gt; math.min(a, b)).cache() bfs }</code> </pre> <br>  Tout est très similaire à ce qui était ci-dessus, mais nous indiquons déjà le nombre d'itérations - pour votre graphique, cela peut être un nombre différent - 10 pour mon graphique, j'ai obtenu empiriquement.  Ensuite, joignez-vous aux noms d'utilisateur et prenez les 100 premières valeurs pour un utilisateur arbitraire: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degreeOfSeparation</span></span></span></span>(root: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>): <span class="hljs-type"><span class="hljs-type">Array</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">DegreeOfSeparation</span></span>)] = { getBFS(root).vertices.join(verts).take(<span class="hljs-number"><span class="hljs-number">100</span></span>) }</code> </pre> <br>  Maintenant, nous recherchons le degré de séparation du sommet donné à tous les autres, vous pouvez également rechercher le degré de séparation pour deux sommets arbitraires: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">degreeOfSeparationTwoUser</span></span></span></span>(firstUser: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>, secondUser: <span class="hljs-type"><span class="hljs-type">VertexId</span></span>) = { getBFS(firstUser) .vertices .filter { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (vertexId, _) =&gt; vertexId == secondUser } .collect.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, degree) =&gt; degree } }</code> </pre> <br>  Spark GraphX ​​de la boîte vous donne la possibilité d'obtenir beaucoup d'informations sur le graphique, par exemple, pour obtenir le composant connecté du graphique (composant connecté): <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMostConnectedUsers</span></span></span></span>(amount: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Array</span></span>[(<span class="hljs-type"><span class="hljs-type">VertexId</span></span>, <span class="hljs-type"><span class="hljs-type">ConnectedUser</span></span>)] = { graph.degrees.join(verts) .sortBy({ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, (userName, _)) =&gt; userName }, ascending = <span class="hljs-literal"><span class="hljs-literal">false</span></span>) .take(amount) }</code> </pre> <br>  Ou obtenez une métrique telle que le nombre de triangles dans le graphique (nombre de triangles): <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socialGraphTriangleCount</span></span></span><span class="hljs-function"> </span></span>= graph.triangleCount()</code> </pre> <br><h3>  Classement des pages </h3><br>  L'algorithme PageRank est né grâce aux étudiants diplômés de Stanford Larry Page et Sergey Brin.  Pour chaque sommet du graphique, l'algorithme attribue une importance parmi tous les autres.  Par exemple, si un utilisateur Twitter a un grand nombre d'abonnements d'autres utilisateurs, alors il aura une note élevée, par conséquent, il peut être facilement trouvé dans le moteur de recherche. <br><br>  GraphX ​​a une version statique et dynamique de l'implémentation du PageRank.  La version statique a un nombre fixe d'itérations, tandis que la version dynamique fonctionnera jusqu'à ce que la cote commence à converger vers la valeur donnée. <br><br>  Pour notre graphique, ce sera comme suit: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dynamicRanks</span></span></span></span>(socialGraph: <span class="hljs-type"><span class="hljs-type">SocialGraph</span></span>, tolerance: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = socialGraph.graph.pageRank(tol = tolerance).vertices <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticRanks</span></span></span></span>(socialGraph: <span class="hljs-type"><span class="hljs-type">SocialGraph</span></span>, tolerance: <span class="hljs-type"><span class="hljs-type">Double</span></span>) = socialGraph.graph.staticPageRank(numIter = <span class="hljs-number"><span class="hljs-number">20</span></span>).vertices</code> </pre> <br><h3>  Conclusion </h3><br>  Un lecteur attentif a noté que le sujet de cet article est le traitement distribué des graphiques, mais lors de l'écriture de code, nous n'avons rien fait pour que le traitement soit vraiment distribué.  Et ici, nous devons rappeler la citation d'Edsger Dijkstra au tout début.  Spark simplifie considérablement nos vies en assumant le fardeau et les charges de l'informatique distribuée.  Écrire du code qui s'exécutera sur un cluster distribué n'est pas une tâche aussi difficile qu'elle aurait pu l'être au début.  Et ici, il existe même <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plusieurs options</a> pour gérer les ressources du cluster: Hadoop YARN, Apache Mesos (personnellement, mon option préférée), et plus récemment, il existe un support pour Kubernetes.  Tout le code source qui a été analysé dans cet article peut être trouvé sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415939/">https://habr.com/ru/post/fr415939/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415927/index.html">Lampe industrielle Breeze 50</a></li>
<li><a href="../fr415929/index.html">Optimisation de l'architecture de l'intelligence artificielle: la course commence</a></li>
<li><a href="../fr415933/index.html">Comment construire une architecture IIoT à faire soi-même</a></li>
<li><a href="../fr415935/index.html">Tri d'insertion</a></li>
<li><a href="../fr415937/index.html">La fusée privée japonaise MOMO-2 a explosé sur la rampe de lancement</a></li>
<li><a href="../fr415943/index.html">"Développement du jeu et théorie du divertissement": points clés du livre de Raff Coster</a></li>
<li><a href="../fr415945/index.html">Nouvel automate chinois avec Aliexpress: Wecon LX3VP / LX3VE</a></li>
<li><a href="../fr415947/index.html">Système de compensation d'erreur d'installation de fibre optique lors de son traitement par rayonnement laser lors de la rotation</a></li>
<li><a href="../fr415949/index.html">Extraction élevée: la dernière option pour protéger la blockchain PoW d'une «attaque de 51%»</a></li>
<li><a href="../fr415951/index.html">Mitap Sberbank et IBM sur HyperLedger Fabric</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>