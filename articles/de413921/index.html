<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëáüèª üçπ üò∫ So sparen Sie das Projekt vor zus√§tzlichen Pfunden üëÖ üî™ ü•å</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo allerseits! Mein Name ist Ilya, ich bin ein iOS-Entwickler bei Tinkoff.ru. In diesem Artikel m√∂chte ich dar√ºber sprechen, wie die Codeduplizieru...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So sparen Sie das Projekt vor zus√§tzlichen Pfunden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/413921/"><img src="https://habrastorage.org/webt/bh/r7/at/bhr7at_omfzwpf1mdp7rcrrb14m.jpeg"><br><br>  Hallo allerseits!  Mein Name ist Ilya, ich bin ein iOS-Entwickler bei Tinkoff.ru.  In diesem Artikel m√∂chte ich dar√ºber sprechen, wie die Codeduplizierung in der Pr√§sentationsschicht mithilfe von Protokollen reduziert werden kann. <br><a name="habracut"></a><br><h3>  Was ist das Problem? </h3><br>  Wenn das Projekt w√§chst, nimmt die Anzahl der Codeduplikationen zu.  Dies wird nicht sofort offensichtlich und es wird schwierig, die Fehler der Vergangenheit zu korrigieren.  Wir haben dieses Problem in unserem Projekt bemerkt und es mit einem Ansatz gel√∂st. Nennen wir es bedingt Merkmale. <br><br><h3>  Lebensbeispiel </h3><br>  Der Ansatz kann mit verschiedenen Architekturl√∂sungen verwendet werden, ich werde ihn jedoch am Beispiel von VIPER betrachten. <br><br>  Betrachten Sie die h√§ufigste Methode im Router - die Methode, mit der der Bildschirm geschlossen wird: <br><br><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>  Es ist in vielen Routern vorhanden, und es ist besser, es nur einmal zu schreiben. <br><br>  Vererbung w√ºrde uns dabei helfen, aber in Zukunft, wenn wir mehr und mehr Klassen mit unn√∂tigen Methoden in unserer Anwendung haben oder nicht in der Lage sind, die ben√∂tigte Klasse zu erstellen, da sich die erforderlichen Methoden in verschiedenen Basisklassen befinden, werden gro√üe Klassen angezeigt Probleme. <br>  Infolgedessen wird das Projekt mit √ºberfl√ºssigen Methoden zu vielen Basisklassen und Nachkommenklassen heranwachsen.  Vererbung wird uns nicht helfen. <br><br>  Was ist besser als Vererbung?  Nat√ºrlich die Komposition. <br><br>  Sie k√∂nnen eine separate Klasse f√ºr die Methode erstellen, mit der der Bildschirm geschlossen wird, und sie jedem Router hinzuf√ºgen, in dem sie ben√∂tigt wird: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre><br>  Wir m√ºssen diese Methode noch im Eingabeprotokoll des Routers deklarieren und im Router selbst implementieren: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouterInput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouterInput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> <span class="hljs-built_in"><span class="hljs-built_in">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closeRouter = { <span class="hljs-type"><span class="hljs-type">CloseRouter</span></span>(transitionHandler: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>. transitionHandler) }() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.closeRouter.close() } }</code> </pre><br>  Es stellte sich heraus, dass zu viel Code den Aufruf einfach an die Methode close weiterleitet.  <s>Lazy</s> Good Programmierer wird es nicht zu sch√§tzen wissen. <br><br><h3>  Protokolll√∂sung </h3><br>  Protokolle kommen zur Rettung.  Dies ist ein ziemlich leistungsf√§higes Tool, mit dem Sie Kompositionen implementieren k√∂nnen und das m√∂glicherweise Implementierungsmethoden in Erweiterung enth√§lt.  So k√∂nnen wir ein Protokoll erstellen, das die Methode close enth√§lt, und es in Erweiterung implementieren. <br><br>  So wird es aussehen: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.transitionHandler.dismiss(animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, completion: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } }</code> </pre><br>  Die Frage ist, warum das Wort Merkmal im Namen des Protokolls erscheint.  Es ist ganz einfach: Sie k√∂nnen festlegen, dass dieses Protokoll seine Methoden in Erweiterung implementiert und als Beimischung zu einem anderen Typ verwendet werden soll, um seine Funktionalit√§t zu erweitern. <br><br>  Nun wollen wir sehen, wie die Verwendung eines solchen Protokolls aussehen wird: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> }</code> </pre><br>  Ja, das ist alles.  Sieht gut aus :).  Wir haben die Komposition erhalten, indem wir das Protokoll zur Klasse des Routers hinzugef√ºgt haben, keine einzige zus√§tzliche Zeile geschrieben haben und die M√∂glichkeit hatten, den Code wiederzuverwenden. <br><br><h3>  Was ist ungew√∂hnlich an diesem Ansatz? </h3><br>  M√∂glicherweise haben Sie diese Frage bereits gestellt.  Die Verwendung von Protokollen als Merkmal ist weit verbreitet.  Der Hauptunterschied besteht darin, diesen Ansatz als architektonische L√∂sung innerhalb der Pr√§sentationsschicht zu verwenden.  Wie bei jeder architektonischen L√∂sung sollte es eigene Regeln und Empfehlungen geben. <br><br>  Hier ist meine Liste: <br><br><ul><li>  Eigenschaften sollten den Status nicht speichern und √§ndern.  Sie k√∂nnen nur Abh√§ngigkeiten in Form von Diensten usw. aufweisen, bei denen es sich nur um Get-Only-Eigenschaften handelt. </li><li>  Merkmale sollten keine Methoden haben, die nicht in Erweiterung implementiert sind, da dies gegen ihr Konzept verst√∂√üt </li><li>  Die Namen der Methoden in Merkmal sollten explizit widerspiegeln, was sie tun, ohne an den Protokollnamen gebunden zu sein.  Dies hilft, Namenskollisionen zu vermeiden und den Code klarer zu machen. </li></ul><br><h3>  Vom VIPER zum MVP </h3><br>  Wenn Sie vollst√§ndig auf diesen Ansatz mit Protokollen umsteigen, sehen die Router- und Interaktorklassen ungef√§hr so ‚Äã‚Äãaus: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherRouterTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractor</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeServiceInput!</span></span> }</code> </pre><br>  Dies gilt nicht f√ºr alle Klassen. In den meisten F√§llen verf√ºgt das Projekt lediglich √ºber leere Router und Interaktoren.  In diesem Fall k√∂nnen Sie die VIPER-Modulstruktur st√∂ren und problemlos zu MVP wechseln, indem Sie dem Pr√§sentator Verunreinigungsprotokolle hinzuf√ºgen. <br><br>  Ungef√§hr so: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomePresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloseRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherRouterTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OtherInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transitionHandler: <span class="hljs-type"><span class="hljs-type">UIViewController!</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeSericeInput!</span></span> }</code> </pre><br>  Ja, die F√§higkeit, Router und Interaktor als Abh√§ngigkeiten zu implementieren, geht verloren, aber in einigen F√§llen ist dies der Fall. <br><br>  Der einzige Nachteil ist TransitionHandler = UIViewController.  Und gem√§√ü den Regeln von VIPER Presenter sollte nichts √ºber die Ansichtsebene und deren Implementierung mit welchen Technologien bekannt sein.  Dies wird in diesem Fall einfach gel√∂st - die √úbergangsmethoden vom UIViewController werden vom Protokoll, beispielsweise TransitionHandler, "geschlossen".  Presenter interagiert also mit der Abstraktion. <br><br><h3>  Verhalten von Merkmalen √§ndern </h3><br>  Mal sehen, wie Sie das Verhalten in solchen Protokollen √§ndern k√∂nnen.  Dies ist ein Analogon zum Ersetzen einiger Teile des Moduls, beispielsweise f√ºr Tests oder einen tempor√§ren Stub. <br><br>  Nehmen Sie als Beispiel einen einfachen Interaktor mit einer Methode, die eine Netzwerkanforderung ausf√ºhrt: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someService: <span class="hljs-type"><span class="hljs-type">SomeServiceInput!</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { someService.performRequest(completion) } }</code> </pre><br>  Dies ist beispielsweise ein abstrakter Code.  Angenommen, wir m√ºssen keine Anfrage senden, sondern nur eine Art Stub zur√ºckgeben.  Hier gehen wir zum Trick - erstellen Sie ein leeres Protokoll namens Mock und gehen Sie wie folgt vor: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeInteractorTrait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(completion: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(Response)</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { completion(<span class="hljs-type"><span class="hljs-type">MockResponse</span></span>()) } }</code> </pre><br>  Hier wurde die Implementierung der performRequest-Methode f√ºr Typen ge√§ndert, die das Mock-Protokoll implementieren.  Jetzt m√ºssen Sie das Mock-Protokoll f√ºr die Klasse implementieren, die SomeInteractor implementiert: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomePresenter</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeInteractorTrait</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mock { // Implementation }</span></span></span></span></code> </pre><br>  F√ºr die SomePresenter-Klasse wird die Implementierung der performRequest-Methode aufgerufen, die sich in der Erweiterung befindet, in der Self das Mock-Protokoll erf√ºllt.  Es lohnt sich, das Mock-Protokoll zu entfernen, und die Implementierung der performRequest-Methode wird von der √ºblichen Erweiterung auf SomeInteractor √ºbernommen. <br><br>  Wenn Sie dies nur f√ºr Tests verwenden, ist es besser, den gesamten Code, der mit dem Ersetzen der Implementierung verbunden ist, im Testziel zu platzieren. <br><br><h3>  Zusammenfassend </h3><br>  Zusammenfassend ist festzuhalten, welche Vor- und Nachteile dieser Ansatz hat und in welchen F√§llen es sich meiner Meinung nach lohnt, ihn anzuwenden. <br><br>  Beginnen wir mit den Nachteilen: <br><br><ul><li>  Wenn Sie Router und Interaktor entfernen, wie im Beispiel gezeigt, geht die F√§higkeit zum Implementieren dieser Abh√§ngigkeiten verloren. </li><li>  Ein weiteres Minus ist die stark zunehmende Anzahl von Protokollen. </li><li>  Manchmal sieht der Code nicht so klar aus wie bei herk√∂mmlichen Ans√§tzen. </li></ul><br>  Die positiven Aspekte dieses Ansatzes sind wie folgt: <br><br><ul><li>  Am wichtigsten und offensichtlichsten ist, dass Doppelarbeit stark reduziert wird. </li><li>  Die statische Bindung wird auf Protokollmethoden angewendet.  Dies bedeutet, dass die Bestimmung der Implementierung der Methode in der Kompilierungsphase erfolgt.  Daher wird w√§hrend der Ausf√ºhrung des Programms keine zus√§tzliche Zeit f√ºr die Suche nach einer Implementierung aufgewendet (obwohl diese Zeit nicht besonders wichtig ist). </li><li>  Aufgrund der Tatsache, dass die Protokolle kleine ‚ÄûBausteine‚Äú sind, kann jede Zusammensetzung leicht daraus zusammengesetzt werden.  Plus im Karma f√ºr Flexibilit√§t im Gebrauch. </li><li>  Einfaches Refactoring, kein Kommentar hier. </li><li>  Sie k√∂nnen diesen Ansatz in jeder Phase des Projekts verwenden, da er nicht das gesamte Projekt betrifft. </li></ul><br>  Diese Entscheidung f√ºr gut zu halten oder nicht, ist eine private Angelegenheit f√ºr alle.  Unsere Erfahrung mit diesem Ansatz war positiv und l√∂ste Probleme. <br><br>  Das ist alles! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de413921/">https://habr.com/ru/post/de413921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de413907/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 256 (4. Juni - 12. Juni)</a></li>
<li><a href="../de413909/index.html">Dort sind deine Kindheitserinnerungen geblieben</a></li>
<li><a href="../de413913/index.html">Bekanntschaft mit den Ausstellungen von Audio- und Videoger√§ten: kurz √ºber die gr√∂√üten Ereignisse - Teil eins</a></li>
<li><a href="../de413915/index.html">Tower Defense zu einem Einheitsspiel machen - Teil 2</a></li>
<li><a href="../de413917/index.html">Inhaber von Urheberrechten glauben, dass Yandex zum Wachstum der Piraterie im Land beitr√§gt</a></li>
<li><a href="../de413923/index.html">Vielleicht kann die Atmosph√§re noch von Kohlendioxid gereinigt werden</a></li>
<li><a href="../de413925/index.html">CVT f√ºr Moskvich</a></li>
<li><a href="../de413927/index.html">Digispark on Attiny85 - Verbindung unter Windows 10 herstellen</a></li>
<li><a href="../de413929/index.html">Sotschi. Kamera: Funktionen zum Erstellen eines Projekts im Allgemeinen, vollst√§ndig, vollst√§ndig von Grund auf neu, ohne dass bereits Standards und Beispiele implementiert wurden</a></li>
<li><a href="../de413931/index.html">Linux Kernel 4.17 Release: Was Sie dar√ºber wissen m√ºssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>