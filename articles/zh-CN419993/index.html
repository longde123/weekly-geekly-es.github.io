<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛓️ 🤱🏻 🤴🏽 TypeScript面试：20个问题和答案 🍓 🦖 🌬️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TypeScript基于数百万JavaScript开发人员所熟悉的相同语法和语义。 使用TypeScript，可以使用最新且仍在不断发展的JS功能，包括ECMAScript 2015中可用的功能以及当前仅以句子形式存在的功能。 这些功能包括例如异步功能和装饰器。 所有这些旨在帮助开发人员创建可靠的现...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TypeScript面试：20个问题和答案</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419993/">  TypeScript基于数百万JavaScript开发人员所熟悉的相同语法和语义。 使用TypeScript，可以使用最新且仍在不断发展的JS功能，包括ECMAScript 2015中可用的功能以及当前仅以句子形式存在的功能。 这些功能包括例如异步功能和装饰器。 所有这些旨在帮助开发人员创建可靠的现代应用程序。 <br><br>  TypeScript程序被编译为常规JavaScript代码，可以在任何浏览器或Node.js中运行。 任何支持ECMAScript 3或更高版本标准的JS引擎都可以理解此代码。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/a0/9e/xq/a09exqcgbx58lh0etyzgbtexcnw.jpeg"></a> <br><br> 该材料（我们今天发布的翻译版）包含对二十个问题的讨论，这些问题很可能会问一个即将通过面试的人，并声称他是TypeScript程序员。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">问题1（1）。</font>  <font color="#3AC1EF">什么是TypeScript？为什么用它代替JavaScript？</font> </h2><br> 在括号中，问题编号后表示其复杂性，以五分制进行评估。 <br><br>  TypeScript（TS）是JavaScript（JS）的超集，其主要功能包括显式静态类型分配的可能性，对类和接口的支持。 与JS相比，TS的主要优点之一是能够在各种IDE中创建这样的开发环境，该环境允许在输入代码的过程中识别常见的错误。 在大型项目中使用TypeScript可以提高程序的可靠性，同时可以将其部署在常规JS应用程序可以工作的相同环境中。 <br><br> 以下是有关TypeScript的一些详细信息： <br><br><ul><li>  TypeScript支持ECMAScript标准的现代版本，使用该标准编写的代码在编译时考虑到了在支持较旧版本标准的平台上执行的可能性。 这意味着TS程序员可以使用ES2015和更高标准的功能，例如模块，箭头功能，类，散布运算符，解构，并在尚不支持这些标准的现有环境中执行其工作。 </li><li>  TypeScript是JavaScript的附加组件。 用纯JavaScript编写的代码是有效的TypeScript代码。 </li><li>  TypeScript通过静态分配类型的能力扩展了JavaScript。  TS型系统相当广泛。 即，它包括接口，枚举，混合类型，泛型类型，联合类型和交集类型，访问修饰符等。 使用TypeScript还可以通过使用类型推断使事情变得容易一些。 </li><li> 与JavaScript相比，TypeScript的使用大大改善了开发过程。 事实是IDE实时接收来自TS编译器的类型信息。 </li><li>当使用严格的<code>null</code>模式（为此使用编译器标志<code>--strictNullChecks</code> ）时，TypeScript编译器不允许向其中不允许使用这些值的那些类型的变量分配<code>null</code>和<code>undefined</code> 。 </li><li> 要使用TypeScript，您需要组织项目构建过程，其中包括在JavaScript中编译TS代码的阶段。 编译器可以将源映射嵌入到由其生成的JS文件中，或创建单独的.map文件。 这使您可以设置断点并在程序执行期间直接使用TypeScript代码检查变量的值。 </li><li>  TypeScript是在Apache 2许可下发布的Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开源</a>项目，TypeScript开发发起者是Anders Halesberg。 他参与了Turbo Pascal，Delphi和C＃的创建。 </li></ul><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题2（1）。</font>  <font color="#3AC1EF">告诉我们有关TypeScript中的泛型类型的信息。</font> </h2><br> 通用类型（泛型）使您可以创建可与不同类型一起使用的组件或功能，而不适用于任何一种。 考虑一个例子： <br><br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/**       */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class">&lt;t&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> data = []; push = (item: T) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.push(item); pop = (): T =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.shift(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Queue&lt;number&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.push(<span class="hljs-string"><span class="hljs-string">"1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  :      ,     </span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题3（2）。</font>  <font color="#3AC1EF">TypeScript是否支持所有面向对象编程的原理？</font> </h2><br> 是的，确实如此。 面向对象编程有四个基本原则： <br><br><ul><li> 封装形式 </li><li> 传承 </li><li> 抽象化 </li><li> 多态性 </li></ul><br> 使用简单明了的TypeScript工具，您可以实现所有这些原理。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题4（2）。</font>  <font color="#3AC1EF">如何在TypeScript中检查等于null和undefined的值？</font> </h2><br> 要执行此类检查，只需使用以下构造即可： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { }</code> </pre> <br> 如果不是以下列表中的内容，则括号中的表达式为<code>true</code> ： <br><br><ul><li> <code>null</code> </li> <li> <code>undefined</code> </li> <li> <code>NaN</code> </li> <li> 空行 </li><li>  0 </li><li> <code>false</code> </li> </ul><br>  TypeScript支持与JavaScript相同的类型转换规则。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题5（2）。</font>  <font color="#3AC1EF">如何实现TypeScript中常量的类属性？</font> </h2><br> 在TypeScript中，当声明类属性时，不能使用<code>const</code>关键字。 当您尝试使用此关键字时，将显示以下错误消息： <code>A class member cannot have the 'const' keyword</code> 。  TypeScript 2.0具有一个<code>readonly</code>修饰符，使您可以创建只读类属性： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyClass</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> myReadonlyProperty = <span class="hljs-number"><span class="hljs-number">1</span></span>;   myMethod() {       console.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.myReadonlyProperty);   } } <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass().myReadonlyProperty = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ,       </span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题6（2）。</font>  <font color="#3AC1EF">什么是TypeScript中的.map文件？</font> </h2><br> 带有.map扩展名的文件存储源地图，其中包含以TypeScript编写的代码与基于其创建的JavaScript代码的对应关系的数据。 许多调试器可以使用此文件（例如，Visual Studio和Chrome开发人员工具）。 这允许在调试期间使用TypeScript程序的源代码，而不使用其JS等效项。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题7（2）。</font>  <font color="#3AC1EF">TypeScript中的getter和setter是什么？</font> </h2><br>  TypeScript支持getter和setter，它们使您可以控制对对象成员的访问。 它们使开发人员可以控制对象的读写属性。 <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> _bar:<span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-function"><span class="hljs-function">get </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar; } <span class="hljs-function"><span class="hljs-function">set </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(theBar:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._bar = theBar; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myBar = myFoo.bar;  <span class="hljs-comment"><span class="hljs-comment">//    myFoo.bar = true;  //   </span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题8（2）。</font>  <font color="#3AC1EF">TypeScript可以用于服务器开发吗？如果可以，如何使用？</font> </h2><br> 用TypeScript编写的程序不仅适用于前端开发，还适用于创建服务器应用程序。 例如，在TS上，您可以为Node.js平台编写程序。 这为程序员提供了用于类型控制的其他工具，并允许您使用语言的其他功能。 要在TS上创建服务器应用程序，您只需要设置正确的代码处理过程，就可以在其输入上接收到TypeScript文件，并且输出是适合在Node.js中执行的JavaScript文件。 为了组织这样的环境，必须首先安装TypeScript编译器： <br><br><pre> <code class="hljs matlab">npm <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> -g typescript</code> </pre> <br> 使用<code>tsconfig.json</code>文件设置编译器参数，该文件除其他因素外确定了编译的目的以及应放置现成的JS文件的位置。 通常，此文件与babel或webpack配置文件非常相似： <br><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"compilerOptions"</span></span>: {   <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"es5"</span></span>,   <span class="hljs-attr"><span class="hljs-attr">"module"</span></span>: <span class="hljs-string"><span class="hljs-string">"commonjs"</span></span>,   <span class="hljs-attr"><span class="hljs-attr">"declaration"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   <span class="hljs-attr"><span class="hljs-attr">"outDir"</span></span>: <span class="hljs-string"><span class="hljs-string">"build"</span></span> } }</code> </pre> <br> 现在，假设编译器需要处理某些内容，则需要运行它： <br><br><pre> <code class="hljs">tsc</code> </pre> <br> 最后，考虑到适合在Node.js环境中执行的JS文件位于<code>build</code>文件夹中的事实，您需要在项目的根目录中运行以下命令： <br><br><pre> <code class="hljs pgsql">node build/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.js</code> </pre> <br>  →来源 <br><br><h2>  <font color="#3AC1EF">问题9（3）。</font>  <font color="#3AC1EF">告诉我们有关TypeScript的主要组件。</font> </h2><br>  TypeScript具有三个主要组件： <br><br><ul><li> 语言 从开发人员的角度来看，这是TypeScript最重要的部分。  “语言”是语法，关键字，所有这些都使您可以用TypeScript编写程序。 </li><li> 编译器  TypeScript具有一个开源编译器，它是跨平台的，开放规范的，并且是用TypeScript编写的。 编译器将TypeScript代码转换为JavaScript代码。 此外，如果程序出现问题，它会显示错误消息。 它使您可以将多个TypeScript文件合并为一个输出JS文件，并可以创建代码映射。 </li><li> 辅助工具。  TypeScript帮助器工具旨在通过在各种IDE中的使用来促进开发过程。 其中包括Visual Studio， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VS Code</a> ，Sublime，用于快速启动TS代码的各种工具等。 </li></ul><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题10（3）。</font>  <font color="#3AC1EF">您提供的TypeScript代码是否存在任何错误？</font>  <font color="#3AC1EF">解释你的答案。</font> </h2><br> 这是代码片段： <br><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{   x: number;   y: number; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point3d</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{   z: number; } let point3d: Point3d = {x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span>, z: <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> <br> 此代码没有错误。 一个类声明创建两个实体：这是用于实例化该类的数据类型，以及构造函数。 由于类创建数据类型，因此可以在可以使用接口的地方使用它们。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><img src="https://habrastorage.org/webt/qr/nn/7-/qrnn7-sznof1sueb9oqf0uhxjie.jpeg"><br>  <i><font color="#999999">真的很喜欢这部电影）</font></i> <br><br><h2>  <font color="#3AC1EF">问题11（3）。</font>  <font color="#3AC1EF">告诉我们有关在TypeScript中使用属性装饰器的信息。</font> </h2><br> 装饰器可用于更改类的行为，将它们与任何框架一起使用时，您可以从中获得更多的好处。 例如，如果您的框架具有受访问限制的方法（例如，它们仅供管理员使用），则编写<code>@admin</code>方法<code>@admin</code>将很容易，它将禁止非管理员用户访问相应的方法。 您可以创建一个<code>@owner</code>装饰器，该装饰器仅允许您将对象修改为其所有者。 使用装饰器的外观如下所示： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CRUD</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { }   post() { }   @<span class="hljs-function"><span class="hljs-function">admin   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { }   @<span class="hljs-function"><span class="hljs-function">owner   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">put</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题12（3）。</font>  <font color="#3AC1EF">TypeScript可以使用强类型函数作为参数吗？</font> </h2><br> 考虑以下示例： <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> {   save(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callback</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Function</span></span></span><span class="hljs-class">) : void {       //        var result : number = 42; //             //      -  ,        number?       callback(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">);   } } var foo = new </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class">(); var callback = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) : void =&gt; {   alert(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">result</span></span></span><span class="hljs-class">); } foo.save(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">callback</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br> 是否可以在<code>save</code>方法中使用类型化的回调组织工作？ 重写代码以演示这一点。 <br><br> 在TypeScript中，您可以声明一个回调类型，然后重写代码： <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NumberCallback = (n: number) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Foo {   //    save(callback: NumberCallback): <span class="hljs-type"><span class="hljs-type">void</span></span> {       console.log(<span class="hljs-number"><span class="hljs-number">1</span></span>)       callback(<span class="hljs-number"><span class="hljs-number">42</span></span>);   } } var numCallback: NumberCallback = (result: number) : <span class="hljs-type"><span class="hljs-type">void</span></span> =&gt; {   console.log("numCallback: ", result.toString()); } var foo = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Foo(); foo.save(numCallback)</code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题13（3）。</font>  <font color="#3AC1EF">如何使模块中声明的类可在模块外部访问？</font> </h2><br> 在模块中声明的类在此模块中可用。 在外面，无法访问它们。 <br><br><pre> <code class="hljs cs">module Vehicle {   <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Car</span></span> {       constructor (           <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> make: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>,           <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> model: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) { }   }   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> audiCar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Car(<span class="hljs-string"><span class="hljs-string">"Audi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Q7"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//     var fordCar = Vehicle.Car("Ford", "Figo");</span></span></code> </pre> <br> 在上面的代码中，尝试初始化<code>fordCar</code>变量时将发生错误。 要使在模块中声明的类可在该模块外部访问，您需要使用<code>export</code>关键字： <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Vehicle {   <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Car</span></span></span><span class="hljs-class"> {</span></span>       constructor (           <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> make: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>,           <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> model: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { }   }   var audiCar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Car(<span class="hljs-string"><span class="hljs-string">"Audi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Q7"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//       var fordCar = Vehicle.Car("Ford", "Figo");</span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题14（3）。</font>  <font color="#3AC1EF">TypeScript是否支持函数重载？</font> </h2><br>  TypeScript支持函数重载，但是此机制的实现与其他面向对象的语言不同。 即，在TS中，它们仅创建一个功能和一定数量的公告。 用JavaScript编译此类代码时，只有一个特定功能可见。 该机制之所以有效，是因为可以通过将不同数量的参数传递给JS函数来调用它们。 <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> {   myMethod(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">);   myMethod(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">);   myMethod(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">);   myMethod(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">any</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">?: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) {       alert(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toString</span></span></span><span class="hljs-class">());   } }</span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题15（4）。</font>  <font color="#3AC1EF">提供给您的代码有什么问题？</font> </h2><br> 这是有问题的代码： <br><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/* */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Fetcher</span></span> {   getObject(done: (data: any, elapsedTime?: number) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; }</code> </pre> <br> 建议仅在绝对准确地了解此步骤的后果后，才在回调中使用可选参数。 这段代码具有非常特殊的含义：可以使用1个或2个参数调用<code>done</code>回调。 该代码的作者可能打算告诉我们，回调可能不会注意<code>elapsedTime</code>参数，但是为了实现这一点，您始终可以创建一个使用较少参数的回调。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题16（4）。</font>  <font color="#3AC1EF">如何在TypeScript中重载类构造函数？</font> </h2><br>  TypeScript允许您声明方法的许多变体，但只能有一个实现，并且此实现必须具有与重载方法的所有变体兼容的签名。 要重载类构造函数，可以使用几种方法： <br><br><ul><li> 您可以使用可选参数： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> x: number;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> y: number;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> height: number;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> width: number;   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(obj: IBox);   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(obj?: any) {          <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = obj &amp;&amp; obj.x || <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = obj &amp;&amp; obj.y || <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = obj &amp;&amp; obj.height || <span class="hljs-number"><span class="hljs-number">0</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = obj &amp;&amp; obj.width || <span class="hljs-number"><span class="hljs-number">0</span></span>;   } }</code> </pre> </li><li> 您可以使用默认设置： <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> x: number;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> y: number;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> height: number;   <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> width: number;   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(obj : IBox = {x:<span class="hljs-number"><span class="hljs-number">0</span></span>,y:<span class="hljs-number"><span class="hljs-number">0</span></span>, height:<span class="hljs-number"><span class="hljs-number">0</span></span>, width:<span class="hljs-number"><span class="hljs-number">0</span></span>}) {          <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = obj.x;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = obj.y;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = obj.height;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = obj.width;   } }</code> </pre> </li><li> 您可以将其他重载用作静态工厂方法： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> {   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fromData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data: PersonData</span></span></span><span class="hljs-function">)</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { first, last, birthday, gender = <span class="hljs-string"><span class="hljs-string">'M'</span></span> } = <span class="hljs-function"><span class="hljs-function">data       return new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">           `${last}, ${first}`,           calculateAge(birthday</span></span></span><span class="hljs-function">),           gender       )   }   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">public</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fullName: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">,       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">public</span></span></span></span><span class="hljs-function"><span class="hljs-params"> age: number,       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">public</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gender: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'M'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> | </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'F'</span></span></span></span><span class="hljs-function"><span class="hljs-params">   </span></span></span><span class="hljs-function">)</span></span> {} } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">PersonData</span></span> {   first: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>   last: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>   birthday: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>   gender?: <span class="hljs-string"><span class="hljs-string">'M'</span></span> | <span class="hljs-string"><span class="hljs-string">'F'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> personA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">'Doe, John'</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-string"><span class="hljs-string">'M'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> personB = Person.fromData({   first: <span class="hljs-string"><span class="hljs-string">'John'</span></span>,   last: <span class="hljs-string"><span class="hljs-string">'Doe'</span></span>,   birthday: <span class="hljs-string"><span class="hljs-string">'10-09-1986'</span></span> })</code> </pre> </li><li> 您可以使用联合类型： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">foo</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> _name: any;   constructor(name: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> | number) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = name;   } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> foo(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> foo(<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> </li></ul><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题17（4）。</font>  <font color="#3AC1EF">TypeScript中的interface和type关键字之间有什么区别？</font> </h2><br> 以下是使用这些关键字的示例： <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">X</span></span> {   a: number   b: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } type X = {   a: number   b: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> };</code> </pre> <br> 与始终代表对象的命名类型的接口声明不同，使用<code>type</code>关键字允许您为任何类型的类型指定别名，包括基本类型，联合类型和交集类型。 <br><br> 当使用<code>type</code>关键字而不是<code>interface</code>关键字时，将失去以下可能性： <br><br><ul><li> 可以在<code>extends</code>或<code>implements</code>表达式中使用接口，但是不能为对象类型文字使用别名。 </li><li> 接口可以具有多个合并的声明，并且在使用<code>type</code>关键字时，此功能不可用。 </li></ul><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题18（5）。</font>  <font color="#3AC1EF">告诉我们有关TypeScript何时使用clarify关键字的信息。</font> </h2><br> 在TypeScript中，使用define关键字来声明变量，变量的来源可能是不是TypeScript文件的文件。 <br><br> 例如，假设我们有一个名为<code>myLibrary</code>的库。 它没有带有TypeScript类型声明的文件，它在全局命名空间中只有<code>myLibrary</code>命名空间。 如果要在TS代码中使用此库，则可以使用以下构造： <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myLibrary;</code> </pre> <br>  TypeScript将<code>myLibrary</code>变量分配给<code>any</code> 。 这里的问题是，尽管可以在代码中使用它，但是在开发时您将没有任何关于该库的智能提示。 在这种情况下，您可以使用另一种方法获得相同的结果。 我们正在谈论使用<code>any</code>类型的变量： <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myLibrary: any;</code> </pre> <br> 在这两种情况下，当使用JavaScript编译TS代码时，结果都是相同的，但是<code>declare</code>选项具有更好的可读性。 使用此关键字将导致创建变量的所谓外部声明（环境声明）。 <br><br><h2>  <font color="#3AC1EF">问题19（5）。</font>  <font color="#3AC1EF">什么是TypeScript中的外部变量声明，什么时候应使用它们？</font> </h2><br> 变量的外部声明（环境声明）是一种机制，可使TypeScript编译器知道某些源代码存在于当前文件之外。 外部广告有助于将第三方JavaScript库集成到TS程序中。 <br><br> 这些声明在类型声明文件中带有扩展名.d.ts。 外部变量或模块声明如下： <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Module_Name { }</code> </pre> <br> 包含外部代码的文件必须使用它们包含在TS文件中，如下所示： <br><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;reference path=" Sample.d.ts"&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/reference&gt;</span></span></span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">问题20（5）。</font>  <font color="#3AC1EF">我可以从JS库自动生成TypeScript广告素材吗？</font> </h2><br>  JavaScript并不总是包含足够的信息以允许TypeScript自动推断类型。 因此，几乎不可能基于JavaScript自动创建类型声明。 但是，您可以尝试使用以下工具来执行此操作： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Microsoft / dts-gen</a>是Microsoft用作创建类型声明的起点的官方工具。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dtsmake</a>是一个很有前途的开发工具，可以基于JS文件自动创建类型声明。 它取决于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tern</a>代码分析系统，某些编辑器在输入JS代码时会使用该系统来实现自动完成机制。 </li></ul><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">来源</a> <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 我们希望对本文中的问题进行讨论将有助于您更好地了解TypeScript，也许要注意以前没有关注的内容，并且如果您准备面试，将增加成功通过它的机会。 <br><br>  <b>亲爱的读者们！</b> 您会问面试官哪些问题需要TypeScript知识申请？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/zs/e2/9_/zse29_wmgd_2kkfu1c_4errn7-c.jpeg"></a> <br>  <i><font color="#999999">-此促销代码有什么折扣？！</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">-好像是7％。</font></i>  <i><font color="#999999">我会检查你是否想要...</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">“是的，你检查。”</font></i>  <i><font color="#999999">我认为折扣有点高估了！</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">...</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999">-抱歉，打折我有点误会。</font></i>  <i><font color="#999999">在所有虚拟服务器上占10％。</font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419993/">https://habr.com/ru/post/zh-CN419993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419983/index.html">上周第326期（2018年8月6日至12日）的前端世界摘要</a></li>
<li><a href="../zh-CN419985/index.html">Klats，klats：Cherry的故事，以键盘开关而闻名</a></li>
<li><a href="../zh-CN419987/index.html">血滴将告诉我们：犯罪的三角学</a></li>
<li><a href="../zh-CN419989/index.html">新西兰禁止使用塑料袋</a></li>
<li><a href="../zh-CN419991/index.html">自主无人机将从机场驱赶成群的鸟类</a></li>
<li><a href="../zh-CN419995/index.html">对新的Angular编译器Ivy的研究</a></li>
<li><a href="../zh-CN419997/index.html">解析JavaScript中的“模块”模式</a></li>
<li><a href="../zh-CN419999/index.html">Yii1 / yii2身份验证共享</a></li>
<li><a href="../zh-CN420001/index.html">推出3CX v15.5 Update 6 BETA和WebRTC浏览器软件电话</a></li>
<li><a href="../zh-CN420003/index.html">JavaFX上带有按钮的窗口：</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>