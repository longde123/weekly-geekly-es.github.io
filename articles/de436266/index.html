<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèº ‚õπÔ∏è üë©‚Äçüöí Extreme Skalierung in Alibaba JDK üéÄ üå§Ô∏è üîÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele sind misstrauisch gegen√ºber der Aussicht, selbst etwas zu forken und zu schreiben. Oft ist der Preis zu hoch. Es ist besonders seltsam, von Ihre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Extreme Skalierung in Alibaba JDK</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/436266/"><p>  Viele sind misstrauisch gegen√ºber der Aussicht, selbst etwas zu forken und zu schreiben.  Oft ist der Preis zu hoch.  Es ist besonders seltsam, von Ihren eigenen JDKs zu h√∂ren, die angeblich in jedem ziemlich gro√üen Unternehmen vorhanden sind.  Was zum Teufel tobt mit Fett?  Dieser Artikel wird eine detaillierte Geschichte √ºber das Unternehmen sein, die all dies echte wirtschaftliche Vorteile bringt und die schreckliche Arbeit geleistet hat, weil sie: </p><br><ul><li>  Entwicklung einer mandantenf√§higen virtuellen Java-Maschine; </li><li>  Sie entwickelten einen Mechanismus f√ºr den Betrieb von Objekten, die keinen Aufwand f√ºr die Speicherbereinigung verursachen. </li><li>  Sie haben so etwas wie das ReadyNow-Gegenst√ºck von Azul Zing gemacht; </li><li>  Sie haben ihre eigenen Coroutinen mit Ertr√§gen und Fortsetzungen abgewaschen (und sind sogar bereit, ihre Erfahrungen mit Loom zu teilen, √ºber die ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Herbst geschrieben habe</a> ); </li><li>  Sie haben an all diesen Wundern ihr eigenes Subsystem der Diagnose angeschraubt. </li></ul><br><p> Wie immer warten Video, Volltextentschl√ºsselung und Folien unter dem Schnitt auf Sie.  Willkommen in der H√∂lle eines der schwierigsten Bereiche der Anpassung offener Projekte! </p><br><p><img src="https://habrastorage.org/webt/dk/gg/wt/dkggwtykndi-ewrxf_6ajxec7ts.png"></p><br><p>  <strong>Herr Doktor, woher bekommen Sie solche Bilder?</strong>  O'Reilly Covers Corner: Der KDPV-Hintergrund wird von Joshua Newton zur Verf√ºgung gestellt und zeigt den <em>Sangyang Jaran</em> Sacred Dance in Ubud, Indonesien.  Dies ist eine klassische balinesische Auff√ºhrung, die aus Feuer- und Trance-Tanz besteht.  Ein Mann mit nackten Abs√§tzen bewegt sich um ein Lagerfeuer, gez√ºchtet auf Kokosnussschalen, schiebt Dinge mit den F√º√üen und tanzt in Trance unter dem Einfluss eines Pferdegeistes.  Perfekte Illustration f√ºr Ihr eigenes JDK, oder? </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/94eTZsNYYBE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Folien und eine Beschreibung des Berichts</a> (Sie brauchen sie nicht, dieser Habratopike hat alles, was Sie brauchen). </p><br><hr><br><p>  Hallo, mein Name ist Sanhong Lee, ich arbeite bei Alibaba und ich m√∂chte dar√ºber sprechen, welche √Ñnderungen wir an OpenJDK f√ºr die Anforderungen unseres Gesch√§fts vorgenommen haben.  Die Post besteht aus drei Teilen.  Im ersten werde ich dar√ºber sprechen, wie Java in Alibaba verwendet wird.  Der zweite Teil ist meiner Meinung nach der wichtigste - darin werden wir diskutieren, wie wir OpenJDK f√ºr die Anforderungen unseres Gesch√§fts konfigurieren.  Der dritte Teil befasst sich mit den Werkzeugen, die wir f√ºr die Diagnose erstellt haben. </p><br><p>  Bevor ich jedoch zum ersten Teil √ºbergehe, m√∂chte ich Ihnen kurz etwas √ºber unser Unternehmen erz√§hlen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2e2/20c/776/2e220c776112b1cf5e66b102559a39a5.jpg"></p><br><p>  Das Diagramm zeigt die interne Struktur von Alibaba.  Es besteht aus verschiedenen Unternehmen, deren Spezialisierung die Organisation des elektronischen Marktes und die Bereitstellung von Finanz- und Logistikplattformen ist.  Ich denke, die meisten Menschen in Russland kennen AliExpress.  Alibaba verf√ºgt √ºber ein engagiertes Team von Programmierern, die den gesamten verteilten Stack entwickeln und unterst√ºtzen und Aliexpress-Kunden auf der ganzen Welt Service bieten. </p><br><p>  Um einen Eindruck vom Umfang von Alibabas Arbeit zu bekommen, schauen wir uns an, was <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am Singles Day</a> in China passiert.  Es wird jedes Jahr am 11. November gefeiert und an diesem Tag kaufen die Menschen besonders viele Waren √ºber Alibaba.  Soweit ich wei√ü, ist dies von den Feiertagen auf der ganzen Welt das am meisten einkaufen. <br></p><p><img src="https://habrastorage.org/getpro/habr/post_images/e31/55e/b62/e3155eb62e307c57535b1479351f41ad.jpg"></p><br><p>  In der Abbildung oben sehen Sie ein Diagramm, das die Belastung unseres Support-Systems zeigt.  Die rote Linie zeigt die Arbeit unseres Bestellservices und die maximale Anzahl von Transaktionen pro Sekunde, im letzten Jahr waren es 325.000.  Die blaue Linie bezieht sich auf den Zahlungsdienst, und sie hat diese Zahl von 256 Tausend.  Ich m√∂chte dar√ºber sprechen, wie der Stack f√ºr so viele Transaktionen optimiert werden kann. </p><br><p>  Lassen Sie uns die wichtigsten Technologien diskutieren, die in Alibaba mit Java funktionieren.  Zun√§chst muss ich sagen, dass wir eine Reihe von Open-Source-Anwendungen als Grundlage haben.  F√ºr die Big-Data-Verarbeitung verwenden wir HBase Hadoop.  Als Container verwenden wir Tomcat und OSGi.  Java wird in gro√üem Umfang verwendet - Millionen von JVM-Instanzen werden in unserem Rechenzentrum bereitgestellt.  Ich muss auch sagen, dass unsere Architektur serviceorientiert ist, dh wir erstellen viele Services, die √ºber RPC-Aufrufe miteinander kommunizieren.  Schlie√ülich ist unsere Architektur heterogen.  Um die Leistung zu verbessern, werden viele Algorithmen mit C- und C ++ - Bibliotheken geschrieben, sodass sie √ºber JNI-Aufrufe mit Java kommunizieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f99/614/041/f99614041cb58edab73a43dea38fdda9.jpg"></p><br><p>  Die Geschichte unserer Arbeit mit OpenJDK begann 2011 w√§hrend OpenJDK 6. Es gibt drei wichtige Gr√ºnde, warum wir uns f√ºr OpenJDK entschieden haben.  Erstens k√∂nnen wir den Code direkt entsprechend den Anforderungen des Unternehmens √§ndern.  Zweitens, wenn dringende Probleme auftreten, k√∂nnen wir sie selbst schneller l√∂sen, als auf die offizielle Ver√∂ffentlichung zu warten.  Dies ist f√ºr unser Gesch√§ft von entscheidender Bedeutung.  Drittens verwenden unsere Java-Entwickler unsere eigenen Tools f√ºr schnelles und qualitativ hochwertiges Debuggen und Diagnostizieren. </p><br><p>  Bevor ich zu technischen Fragen √ºbergehe, m√∂chte ich die Hauptschwierigkeiten auflisten, die wir √ºberwinden m√ºssen.  Erstens haben wir eine gro√üe Anzahl von JVM-Instanzen gestartet. In dieser Situation ist die Frage der Reduzierung der Hardwarekosten ein akutes Problem.  Zweitens habe ich bereits gesagt, dass wir eine gro√üe Anzahl von Transaktionen abwickeln.  Dank des Garbage Collectors verspricht Java uns ‚Äûunendlichen Speicher‚Äú.  Dar√ºber hinaus gewinnt es dank des JIT-Compilers an Leistung auf niedrigem Niveau.  Dies hat aber auch eine Kehrseite: eine l√§ngere Zeit f√ºr die M√ºllabfuhr.  Dar√ºber hinaus ben√∂tigt Java zus√§tzliche CPU-Zyklen, um Java-Methoden zu kompilieren.  Dies bedeutet, dass Compiler um CPU-Zyklen konkurrieren.  Beide Probleme verschlechtern sich, wenn die Anwendung komplexer wird. </p><br><p>  Die dritte Schwierigkeit besteht darin, dass viele Anwendungen ausgef√ºhrt werden.  Ich denke, jeder hier ist mit Tools vertraut, die mit OpenJDK geliefert werden, wie JConsole oder VisualVM.  Das Problem ist, dass sie uns nicht die genauen Informationen geben, die wir zum Konfigurieren ben√∂tigen.  Wenn wir diese Tools (z. B. JConsole oder VisualVM) in der Produktion verwenden, ist ein geringer Overhead nicht nur ein Wunsch, sondern eine notwendige Anforderung.  Ich musste meine eigenen Diagnosetools schreiben. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec5/da9/bcb/ec5da9bcb1620f073d5aed05aaba76aa.jpg"></p><br><p>  Das Bild zeigt die √Ñnderungen, die wir an OpenJDK vorgenommen haben.  Schauen wir uns an, wie wir die Schwierigkeiten √ºberwunden haben, √ºber die ich oben gesprochen habe. </p><br><h1>  Multi-Tenant JVM </h1><br><p>  Eine L√∂sung nennen wir eine mandantenf√§hige JVM.  Sie k√∂nnen damit sicher mehrere Webanwendungen in einem Container ausf√ºhren.  Eine andere L√∂sung hei√üt GCIH (GC Invisible Heap).  Dies ist ein Mechanismus, mit dem Sie vollwertige Java-Objekte erhalten, f√ºr die gleichzeitig keine Kosten f√ºr die Speicherbereinigung anfallen.  Um die Kosten f√ºr Thread-Kontexte zu senken, haben wir au√üerdem Coroutinen auf unserer Java-Plattform implementiert.  Au√üerdem haben wir einen Mechanismus namens JWarmup geschrieben, dessen Funktion ReadyNow sehr √§hnlich ist.  Douglas Hawkins scheint ihn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in seinem Bericht</a> erw√§hnt zu haben.  Schlie√ülich haben wir unser eigenes Profiling-Tool, ZProfiler, entwickelt. </p><br><p>  Schauen wir uns genauer an, wie wir OpenJDK-basierte Mandantenf√§higkeit implementieren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/133/d4b/f5f/133d4bf5f82bfa3f7a7df9abb0e59afa.jpg"></p><br><p>  Schauen Sie sich das Bild oben an - ich denke, die meisten von Ihnen kennen dieses Muster.  Vergleichen Sie den traditionellen Ansatz mit dem Mandanten.  Wenn Ihre Anwendung mit Apache Tomcat ausgef√ºhrt wird, k√∂nnen Sie auch mehrere Instanzen im selben Container ausf√ºhren.  Tomcat bietet jedoch nicht f√ºr jeden einen stabilen Ressourcenverbrauch.  Angenommen, eine der laufenden Anwendungen ben√∂tigt mehr CPU-Zeit als die andere, wie steuern Sie die CPU-Zeitzuweisung?  Wie kann sichergestellt werden, dass diese Anwendung die Arbeit anderer nicht beeintr√§chtigt?  Vor allem diese Frage hat uns dazu gebracht, uns der Multitenant-Technologie zuzuwenden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e7f/77e/add/e7f77eadd29a6dbe8ea8ffc0cc1ec8ae.jpg"></p><br><p>  Das Bild zeigt schematisch, wie wir es implementieren.  Wir erstellen mehrere Container f√ºr Mieter innerhalb der JVM.  Jeder dieser Container bietet eine zuverl√§ssige Kontrolle des Ressourcenverbrauchs f√ºr jedes Java-Modul.  In einem Container k√∂nnen mehrere Module bereitgestellt werden.  Jedes Modul kann zur Laufzeit einem Thread oder einer Gruppe von Threads zugeordnet werden. </p><br><p>  Schauen wir uns an, wie die Mandantencontainer-API aussieht.  Wir haben eine Mandantenkonfigurationsklasse, die Informationen zum Ressourcenverbrauch speichert.  Als n√§chstes gibt es eine Klasse des Containers selbst. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3c/95e/27d/f3c95e27dbc40c2bb216b70f7521b270.jpg"></p><br><p>  Im dargestellten Code-Snippet erstellen wir einen Mandanten und geben dann an, wie viel Zeit die CPU und der Speicher daf√ºr bereitstellen.  Der erste Indikator ist eine Ganzzahl, dh der Anteil der CPU-Zeit, der dem Mandanten zur Verf√ºgung steht. In diesem Fall haben wir 512 angegeben. Bei cgroups verwenden wir einen sehr √§hnlichen Ansatz. Darauf werde ich n√§her eingehen.  Die zweite Metrik ist die maximale Heap-Gr√∂√üe, die Mandanten verwenden k√∂nnen. </p><br><p> √úberlegen Sie, wie ein Mandant mit einem Thread interagiert.  Die <code>TenantContainer</code> Klasse stellt die <code>.run()</code> -Methode <code>.run()</code> Wenn ein Thread in ihn eintritt, wird er automatisch an den Tenant <code>.run()</code> Wenn er ihn verl√§sst, erfolgt die umgekehrte Prozedur.  Der gesamte Code wird also innerhalb der <code>.run()</code> -Methode ausgef√ºhrt.  Dar√ºber hinaus wird jeder in der <code>.run()</code> -Methode erstellte Thread an den Mandanten des √ºbergeordneten Threads angeh√§ngt. </p><br><p>  Wir kamen zu einer sehr wichtigen Frage: Wie wird die CPU in einer mandantenf√§higen JVM verwaltet?  Unsere L√∂sung wurde gerade auf der Linux x64-Plattform implementiert.  Es gibt einen Kontrollgruppenmechanismus, cgroups.  Sie k√∂nnen einen Prozess in einer separaten Gruppe ausw√§hlen und dann Ihren Ressourcenverbrauch f√ºr jede Gruppe angeben.  Versuchen wir, diesen Ansatz auf den Kontext der Hotspot-JVM zu √ºbertragen.  Bei Hotstpot sind Java-Threads als native Threads organisiert. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fbb/093/2d4/fbb0932d4d1dbc6ef982c17dcac8bebb.jpg"></p><br><p>  Dies ist im obigen Diagramm dargestellt: Jeder Java-Thread steht in einer Eins-zu-Eins-Entsprechung mit dem nativen Thread.  In unserem Beispiel haben wir einen <code>TenantA</code> Container, in dem sich zwei native Threads befinden.  Um die Verteilung der CPU-Zeit steuern zu k√∂nnen, platzieren wir beide nativen Threads in einer Kontrollgruppe.  Aus diesem Grund k√∂nnen wir den Ressourcenverbrauch regulieren, indem wir uns ausschlie√ülich auf die Funktionalit√§t von [Kontrollgruppen] verlassen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://en.wikipedia.org/wiki/Cgroups</a> ). </p><br><p>  Schauen wir uns ein detaillierteres Beispiel an. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6ac/6c8/6bc/6ac6c86bc668c785c1dd92ee13547e2a.jpg"></p><br><p>  Kontrollgruppen unter Linux werden einem Verzeichnis zugeordnet.  In unserem Beispiel haben wir das Verzeichnis <code>/t0</code> f√ºr Tenant 0 erstellt. Dieses Verzeichnis enth√§lt das Verzeichnis <code>/t0/tasks</code> . Alle Threads f√ºr <code>t0</code> befinden sich hier.  Eine weitere wichtige Datei ist <code>/t0/cpu.shares</code> .  Es gibt an, wie viel Zeit die CPU diesem Mandanten zur Verf√ºgung stellt.  Diese gesamte Struktur wird von Kontrollgruppen geerbt - wir haben einfach eine direkte Korrespondenz zwischen dem Java-Thread, dem nativen Thread und der Kontrollgruppe sichergestellt. </p><br><p>  Ein weiteres wichtiges Thema betrifft die Verwaltung einer Gruppe jedes Mieters. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b3a/570/b4e/b3a570b4ece66bcabd3bfa9d5071e553.jpg"></p><br><p>  Im Bild sehen Sie ein Diagramm, wie es implementiert wird.  Unser Ansatz basiert auf dem G1GC.  Am unteren Rand des Bildes unterteilt G1GC den Heap in gleich gro√üe Abschnitte.  Basierend darauf erstellen wir TACs (Tenant Allocation Contexts), mit denen der Mandant seinen Heap-Bereich verwaltet.  Durch TAC begrenzen wir die Gr√∂√üe des Heap-Teils, der dem Mieter zur Verf√ºgung steht.  Hier gilt das Prinzip, wonach jeder Abschnitt des Heaps nur Objekte eines Mandanten enth√§lt.  Um es zu implementieren, mussten wir √Ñnderungen am Kopierprozess eines Objekts w√§hrend der Speicherbereinigung vornehmen. Es musste sichergestellt werden, dass das Objekt in den richtigen Abschnitt des Heaps kopiert wurde. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ae8/195/7c8/ae81957c8027d99056a66648472f9674.jpg"></p><br><p>  Schematisch ist dieser Vorgang in der obigen Abbildung dargestellt.  Wie gesagt, unsere Implementierung basiert auf G1GC.  G1GC ist ein kopierender Garbage Collector. Daher m√ºssen wir w√§hrend der Garbage Collection sicherstellen, dass das Objekt in den richtigen Abschnitt des Heaps kopiert wird.  Auf der Folie m√ºssen alle von <code>Tenant-1</code> erstellten Objekte √§hnlich wie <code>Tenant-2</code> in seinen Teil des Heapspeichers kopiert werden. </p><br><p>  Es gibt andere √úberlegungen, die sich ergeben, wenn Mieter voneinander isoliert sind.  Hier muss ich √ºber TLAB (Thread Local Allocation Buffer) sprechen - einen Mechanismus f√ºr die schnelle Zuweisung von Speicher.  Der TLAB-Speicherplatz h√§ngt vom Heap-Abschnitt ab.  Wie gesagt, verschiedene Mieter haben unterschiedliche Gruppen von Heap-Abschnitten. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0c9/0b4/1e7/0c90b41e753761f3a2e294ccef6e6591.jpg"></p><br><p>  Die Einzelheiten der Arbeit mit TLAB werden auf der Folie gezeigt. Wenn ein Thread von <code>Tenant 1</code> zu <code>Tenant 2</code> , m√ºssen Sie sicherstellen, dass der richtige Heap-Abschnitt f√ºr den TLAB-Bereich verwendet wird.  Dies kann auf zwei Arten erreicht werden.  Der erste Weg ist, wenn <code>Thread A</code> von <code>Tenant 1</code> zu <code>Tenant 2</code> , wir werden nur den alten los und erstellen einen neuen in <code>Tenant 2</code> .  Diese Methode ist relativ einfach zu implementieren, verschwendet jedoch Speicherplatz in TLAB, was unerw√ºnscht ist.  Der zweite Weg ist komplizierter - TLAB auf Mieter aufmerksam zu machen.  Dies bedeutet, dass wir mehrere TLAB-Puffer f√ºr einen Thread haben werden.  Wenn <code>Thread A</code> von <code>Tenant 1</code> zu <code>Tenant 2</code> , m√ºssen wir den Puffer √§ndern und den Puffer verwenden, der in <code>Tenant 2</code> . </p><br><p>  Ein weiterer Mechanismus, der im Zusammenhang mit der Abgrenzung von Mietern erw√§hnt werden muss, ist IHOP (Initiating Thread Occupancy Percent).  Urspr√ºnglich wurde der IHOP auf der Grundlage des gesamten Heaps berechnet, bei einem Mechanismus mit mehreren Mandanten muss er jedoch nur auf der Grundlage eines Abschnitts des Heaps berechnet werden. </p><br><p>  Schauen wir uns GCIH (GC Invisible Heap) genauer an.  Dieser Mechanismus erstellt einen Abschnitt auf dem Heap, der vor dem Garbage Collector verborgen ist und dementsprechend nicht von der Garbage Collection betroffen ist.  Diese Site wird vom GCIH-Mandanten verwaltet. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00a/fc1/843/00afc1843cc320ee600a80892f0c4940.jpg"></p><br><p>  Es ist wichtig zu sagen, dass wir unseren Java-Entwicklern eine √∂ffentliche API zur Verf√ºgung stellen.  Ein Beispiel f√ºr die Arbeit damit ist auf dem Bildschirm zu sehen.  Mit der Methode <code>moveIn()</code> Objekte von einem regul√§ren Heap in einen Teil des GCIH-Heaps verschoben werden.  Der Vorteil ist, dass Sie mit diesen Objekten weiterhin wie mit normalen Java-Objekten interagieren k√∂nnen. Ihre Struktur ist sehr √§hnlich.  Gleichzeitig ben√∂tigen sie jedoch nicht die Kosten f√ºr die Speicherbereinigung.  Meiner Meinung nach m√ºssen Sie das Verhalten des Garbage Collectors an die Anforderungen Ihrer Anwendung anpassen, wenn Sie die Speicherbereinigung beschleunigen m√∂chten. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af0/c7d/bb3/af0c7dbb3eca6dd45ecc10f52247e369.jpg"></p><br><p>  Das Bild zeigt ein hochrangiges GCIH-Schema.  Auf der rechten Seite befindet sich ein regul√§rer Java-Heap, auf der linken Seite der f√ºr GCIH zugewiesene Speicherplatz.  Links von einem regul√§ren Heap zu Objekten in GCIH sind g√ºltig, Links von GCIH zu einem regul√§ren Heap jedoch nicht.  Betrachten Sie ein Beispiel, um zu verstehen, warum dies so ist.  Wir haben das Objekt "A" in GCIH, das einen Verweis auf das Objekt "B" in einem regul√§ren Heap enth√§lt.  Das Problem ist, dass Objekt B vom Garbage Collector verschoben werden kann.  Wie bereits erw√§hnt, werden in GCIH keine Aktualisierungen vorgenommen. Nachdem der Garbage Collector funktioniert hat, enth√§lt das Objekt "A" m√∂glicherweise einen ung√ºltigen Verweis auf das Objekt "B".  Dieses Problem kann mithilfe der Pre-Write-Barriere gel√∂st werden - sie wurden in einem fr√ºheren Bericht er√∂rtert.  Angenommen, jemand muss einen Link von einem regul√§ren Java-Heap zu GCIH speichern, bevor das von uns angenommene Speichern zu einer Pr√§diktorausnahme mit einem Indikator-Flag f√ºhrt, dass die Regel verletzt wurde. </p><br><p>  F√ºr eine bestimmte Anwendung wird in unserer Taobao Personalization Platform, abgek√ºrzt TPP, eine mandantenf√§hige JVM verwendet.  Dies ist ein Empfehlungssystem f√ºr unsere E-Shopping-Anwendung.  TPP kann mehrere Microservices in einem Container bereitstellen. Mithilfe der mandantenf√§higen JVM steuern wir den Speicher und die CPU-Zeit, die f√ºr jeden Microservice bereitgestellt werden. </p><br><p>  GCIH wird in unserem anderen System, der UM-Plattform, verwendet.  Dies ist eine Online-Rabattanwendung.  Der Eigent√ºmer dieser Anwendung verwendet GCIH, um GCIH-Daten auf dem lokalen Computer vorab zwischenzuspeichern, um nicht auf Objekte auf dem Remote-Cache-Server oder der Remote-Datenbank zuzugreifen.  Infolgedessen entlasten wir das Netzwerk und f√ºhren weniger Serialisierung und Deserialisierung durch. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/36d/707/20c/36d70720cd2b4465b4b32b01467fbe51.jpg"></p><br><p>  Das Bild zeigt ein Diagramm, in dem die blaue Farbe die Last bei Verwendung eines herk√∂mmlichen JDK und die rote GCIH zeigt.  Wie Sie sehen, reduzieren wir die CPU-Auslastung um √ºber 18%. </p><br><p>  Soweit ich wei√ü, wurde ein √§hnliches Problem von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BellSoft</a> gel√∂st, und ihre L√∂sung war √§hnlich wie bei GCIH, aber sie verwendeten einen anderen Ansatz, um die Kosten f√ºr Serialisierung und Deserialisierung zu senken. </p><br><h1>  Coroutinen in Java </h1><br><p>  Kehren wir zu Alibaba zur√ºck und sehen, wie Coroutinen in Java implementiert werden k√∂nnen.  Aber lassen Sie uns zuerst √ºber die Urspr√ºnge sprechen, warum wir das tun m√ºssen.  In Java war es immer sehr einfach, Multithreading-Anwendungen zu schreiben.  Das Problem beim Erstellen solcher Anwendungen ist jedoch, dass, wie gesagt, in Hotspot Java-Threads bereits als native Threads implementiert sind.  Wenn Ihre Anwendung viele Threads enth√§lt, sind die Kosten f√ºr das √Ñndern des Thread-Kontexts daher sehr hoch. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2c5/b79/4f1/2c5b794f12c5cfcc82fa893a82c7a92e.jpg"></p><br><p>  Stellen Sie sich ein Beispiel vor, in dem wir 4 E / A-Threads und 200 Threads mit der Logik Ihrer Anwendung haben.  Die Tabelle auf dem Bildschirm zeigt die Ergebnisse des Startens dieser einfachen Demo. Sie k√∂nnen sehen, wie viel Zeit die CPU ben√∂tigt, um den Kontext zu √§ndern.  Die L√∂sung f√ºr dieses Problem kann die Implementierung von Corutin in Java sein. </p><br><p>  Um es bereitzustellen, brauchten wir zwei Dinge.  Zun√§chst musste Alibaba JDK die Unterst√ºtzung f√ºr die Fortsetzung hinzuf√ºgen.  Diese Arbeit basierte auf dem JKU-Patch, auf den wir noch n√§her eingehen werden.  Zweitens haben wir einen Sheduler im Benutzermodus hinzugef√ºgt, der f√ºr die Fortsetzung im Thread verantwortlich ist.  Drittens gibt es in Alibaba viele Anwendungen.  Daher ist unsere L√∂sung f√ºr unsere Java-Entwickler sehr wichtig, und es war notwendig, sie f√ºr sie absolut transparent zu machen.  Dies bedeutet, dass in unserer Gesch√§ftsanwendung praktisch keine √Ñnderungen am Code vorgenommen werden sollten.  Wir haben unsere L√∂sung Wisp genannt.  Unsere Implementierung von Coroutinen in Java ist in Alibaba weit verbreitet, daher kann davon ausgegangen werden, dass sie in Java funktioniert.  Lernen Sie ihn n√§her kennen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5af/7af/0c2/5af7af0c2075b299ef7152bd8cff94fe.jpg"></p><br><p>  Beginnen wir mit dem Beispiel, dessen Code oben dargestellt ist - dies ist eine ganz normale Java-Anwendung.  Zun√§chst wird ein Thread-Pool erstellt.  Anschlie√üend wird eine weitere ausf√ºhrbare Aufgabe erstellt, die den Socket akzeptiert.  Danach wird das Lesen aus dem Stream durchgef√ºhrt.  Als N√§chstes erstellen wir eine weitere ausf√ºhrbare Aufgabe, mit der wir eine Verbindung zum Server herstellen und schlie√ülich Daten in den Stream schreiben.  Wie Sie sehen k√∂nnen, sieht alles ganz normal aus.  Wenn Sie den Code in einem regul√§ren JDK ausf√ºhren, wird jede dieser ausf√ºhrbaren Aufgaben in einem separaten Thread ausgef√ºhrt.  Bei unserer Entscheidung wird die Mechanik jedoch v√∂llig anders sein. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a06/f12/716/a06f12716380d6e3447ac9de3784c37c.jpg"></p><br><p>  Wie Sie dem Dump des auf der Folie gezeigten Threads entnehmen k√∂nnen, erstellen wir zwei Coroutinen in einem Thread und nicht zwei Threads.  Jetzt m√ºssen Sie diese L√∂sung zum Laufen bringen.  Die Hauptsache hier ist, YieldTo-Ereignisse an allen m√∂glichen Blockierungspunkten zu generieren.  In unserem Beispiel sind diese Punkte <code>serverSocket.accept()</code> , <code>is.read(buf)</code> , eine Socket-Verbindung und <code>os.write(buf)</code> .  Dank der Ertragsereignisse an diesen Punkten k√∂nnen wir die Kontrolle innerhalb desselben Threads von einer Coroutine auf eine andere √ºbertragen.  Zusammenfassend ist unser Ansatz, dass wir mit Coroutine eine asynchrone Leistung erzielen, unsere Programmierer jedoch Code synchron schreiben k√∂nnen, da dieser Code viel einfacher und einfacher zu warten und zu debuggen ist. </p><br><p>  Schauen wir uns genau an, wie wir die Fortsetzung in Alibaba JDK unterst√ºtzt haben.  Wie gesagt, diese Arbeit basiert auf einem mehrsprachigen Projekt einer virtuellen Maschine, das von der Community erstellt wurde - es ist gemeinfrei.  Wir haben diesen Patch in Alibaba JDK verwendet und einige Fehler behoben, die in unserer Produktionsumgebung aufgetreten sind. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e3/580/3bd/5e35803bda5ad8ae70b35f3fd5fd4771.jpg"></p><br><p>  Wie Sie im Diagramm sehen k√∂nnen, kann es hier in einem Thread mehrere Coroutinen geben, und f√ºr jeden wird ein separater Stapel erstellt.  Dar√ºber hinaus bietet uns der Patch, √ºber den ich gesprochen habe, die wichtigste API --ieldTo, mit deren Hilfe die Kontrolle von einer Coroutine auf eine andere √ºbertragen wird. </p><br><p>  Fahren wir fort mit der Implementierung des Benutzermodus-Shedulers f√ºr Coroutine.  Wir benutzen einen Selektor und registrieren damit mehrere Kan√§le.  Wenn ein E / A-Ereignis (Socket lesen, Socket schreiben, Socket verbinden oder Socket akzeptieren) auftritt, wird es als Schl√ºssel f√ºr den Selektor geschrieben.  Daher erhalten wir am Ende dieses Ereignisses eine Benachrichtigung vom Selektor.  Daher verwenden wir einen Selektor, um Coroutinen im Falle einer E / A-Sperre zu planen.  Betrachten Sie ein Beispiel, wie dies funktionieren wird. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a32/45d/f81/a3245df8176dc1c23d810413ff1f1031.jpg"></p><br><p>  Im Bild sehen wir den Socket und den synchronen Aufruf <code>client.read(buffer)</code> .  Am unteren Rand der Folie wird Code geschrieben, der in diesem Aufruf ausgef√ºhrt wird.  Zun√§chst wird gepr√ºft, ob vom Kanal gelesen werden kann oder nicht.  Wenn ja, geben wir das Ergebnis zur√ºck.  Das Interessanteste passiert, wenn nicht gelesen werden kann.  Dann registrieren wir das Leseereignis in unserem Scheduler mit Selektor.  Dies erm√∂glicht es, die Ausf√ºhrung einer anderen Coroutine zu planen.  Schauen Sie sich an, wie das passiert.  Wir haben einen Thread, in dem ein Scheduler erstellt wird.  Der Thread und unsere Coroutine stehen in einer Eins-zu-Eins-Entsprechung miteinander.  Mit Sheduler k√∂nnen wir die Coroutinen dieses Threads verwalten.  Was passiert, wenn E / A blockiert ist?  Wenn E / A-Ereignisse auftreten, erh√§lt der Sheduler eine Warnung und verl√§sst sich in dieser Situation vollst√§ndig auf den Selektor.  Nach einem solchen Ereignis erh√§lt der Sheduler die M√∂glichkeit, die n√§chste verf√ºgbare Coroutine zu planen. </p><br><p>  Lassen Sie uns die √úbersicht √ºber unseren Sheduler zusammenfassen, den wir WispEngine genannt haben.  F√ºr jeden unserer Threads weisen wir eine separate WispEngine zu.  Wenn eine Coroutine-Sperre auftritt, protokollieren wir bestimmte Ereignisse (Socket-Lesen / Schreiben usw.) mit WispEngine.  Einige Ereignisse beziehen sich auf das Einparken von Threads, z. B. wenn Sie <code>thread.sleep()</code> mit einer Verz√∂gerung von 100 Millisekunden aufrufen.  In diesem Fall wird f√ºr Sie ein Thread-Parking-Ereignis generiert, das dann im Selektor registriert wird.  Ein weiteres wichtiges Problem ist, wenn der Sheduler die n√§chste verf√ºgbare Coroutine ernennt.  Es gibt zwei Hauptbedingungen.  Das erste ist, wenn bestimmte Ereignisse generiert werden, z. B. E / A-Ereignisse oder Timeout-Ereignisse.  Hier ist alles ziemlich einfach: Angenommen, Sie rufen <code>thread.sleep()</code> mit einer Verz√∂gerung von 200 Millisekunden auf.  Wenn sie ablaufen, hat der Sheduler die M√∂glichkeit, die n√§chste verf√ºgbare Coroutine auszuf√ºhren.  Oder wir k√∂nnen hier √ºber einige <code>object.notify()</code> sprechen, die beispielsweise durch Aufrufen von <code>object.notify()</code> oder <code>object.notifyAll()</code> Die zweite Bedingung ist, wenn der Benutzer neue Anforderungen <code>object.notifyAll()</code> und wir eine Coroutine erstellen, um diese Anforderungen zu bedienen, und der Sheduler dann zuweist seine Umsetzung. </p><br><p>  Hier m√ºssen Sie auch √ºber den von uns erstellten Service WispThreadExecutor sprechen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5a5/ddc/881/5a5ddc88194e0794593506627f420915.jpg"></p><br><p>  Auf dem Bildschirm wird ein Beispielcode angezeigt, und wir sehen, dass dies ein regul√§rer ExecutorService ist, der auf die gleiche Weise erstellt wurde.  Die Methoden <code>.execute()</code> und submit <code>submit()</code> sind f√ºr ausf√ºhrbare Aufgaben verf√ºgbar. Das Problem besteht jedoch darin, dass alle ausf√ºhrbaren Aufgaben, die die Methode submit <code>submit()</code> durchlaufen, in corutin und nicht im Thread ausgef√ºhrt werden.  Diese L√∂sung ist f√ºr diejenigen, die unsere Anwendung implementieren, vollst√§ndig transparent. Sie k√∂nnen unsere API f√ºr Coroutinen verwenden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2b5/e03/041/2b5e03041077b86eb3b4438a5d286813.jpg"></p><br><p>  Ich komme zum letzten schwierigen Teil des Beitrags - wie man das Problem der Synchronisation in Coroutinen l√∂st.  Dies ist eine komplexe Frage. Schauen wir uns diese anhand eines vereinfachten Beispiels an.  Hier haben wir Coroutine A ( <code>test::foo</code> ) und Corutin <code></code> ( <code>test::bar</code> ).  Zuerst weisen wir die Ausf√ºhrung von <code>test:foo</code> Coroutine <code></code>  Corutin <code></code> ruft <code></code> <code>wait()</code> .  Wenn nichts unternommen wird, wird der aktuelle Thread durch den Aufruf von <code>wait()</code> blockiert.  Wie aus diesem Dump des Threads ersichtlich ist, tritt ein Deadlock auf, und wir k√∂nnen die n√§chste auszuf√ºhrende Coroutine nicht planen. </p><br><p>  Wie kann man dieses Problem l√∂sen?  Hotspot bietet drei Arten von Sperren.  Das erste ist die Schnellverriegelung.  Hier wird der Besitzer der Sperre durch die Adresse auf dem Stapel bestimmt.  Wie gesagt, jede unserer Coroutinen hat einen eigenen Stapel.  Daher m√ºssen wir im Falle einer schnellen Verriegelung keine zus√§tzlichen Arbeiten ausf√ºhren.  Es gibt keine √§hnliche Unterst√ºtzung f√ºr vorgespannte Sperren in unserem System.  Wir haben es in unserer Produktion versucht und es stellte sich heraus, dass die Leistung ohne ein voreingenommenes Schloss nicht abnimmt.  F√ºr uns ist es durchaus geeignet. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1a9/051/bd1/1a9051bd163c97d904d6a4bd13afb188.jpg"></p><br><p>  Lassen Sie uns √ºber einen komplizierteren Fall sprechen - aufgeblasenes Schloss.  Schauen wir uns noch einmal das Beispiel an, das ich oben zitiert habe.  Wir haben Corutin <code></code> ( <code>.foo()</code> ) und Corutin <code>B</code> ( <code>.bar()</code> ).  Zuerst weisen wir die Ausf√ºhrung von Coroutine <code></code> und starten sie.  Dann ruft es <code>Object.wait</code> , woraufhin es in die Warteliste aufgenommen wird.  Danach machen wir einen sehr wichtigen Schritt: Wir generieren das <code>yieldTo</code> Ereignis, das die Kontrolle auf den Haupt-Thread √ºbertr√§gt.  Als n√§chstes starten wir Corutin <code>B</code>  Es ruft <code>Object.notify</code> und die entsprechenden <code>unpark</code> Ereignisse werden <code>unpark</code> .  Sie werden schlie√ülich Coroutine <code></code> wecken <code></code>  Nachdem die Ausf√ºhrung von <code>bar()</code> , kann die Kontrolle an Coroutine <code></code>  Damit ist der zuvor erw√§hnte Stillstand vollst√§ndig √ºberwunden. </p><br><p>  Lassen Sie uns jetzt die Leistung diskutieren.  Wir verwenden Coroutinen in einer unserer Carts-Online-Anwendungen.  Basierend darauf k√∂nnen wir die Arbeit von Corutin mit der Arbeit von gew√∂hnlichem JDK vergleichen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/022/52c/c95/02252cc950a2ad902d2feb29f4129249.jpg"></p><br><p>  Wie Sie sehen, k√∂nnen wir damit den Prozessorzeitverbrauch um fast 10% senken.  Ich verstehe, dass die meisten von Ihnen h√∂chstwahrscheinlich nicht in der Lage sind, solche komplexen √Ñnderungen direkt am JDK-Code vorzunehmen.  Die wichtigste Schlussfolgerung hier ist meiner Meinung nach, dass Sie versuchen k√∂nnen, die Produktivit√§t mithilfe der Corutin-Bibliothek zu verbessern, wenn Produktivit√§tsverluste Geld kosten und die daraus resultierende Menge gro√ü genug ist. </p><br><h1>  Jarmarm </h1><br><p>  Fahren wir mit unserem anderen Tool fort - JWarmup.  Es ist einem anderen Tool, ReadyNow, sehr √§hnlich.  Wie wir wissen, gibt es in Java ein Aufw√§rmproblem - der Compiler ben√∂tigt zu diesem Zeitpunkt zus√§tzliche CPU-Zyklen.  Dies verursachte uns Probleme - zum Beispiel ist ein TimeOut-Fehler aufgetreten.  Bei der Skalierung verschlimmern sich diese Probleme nur, und in unserem Fall handelt es sich um eine sehr komplexe Anwendung - mehr als 20.000 Klassen und mehr als 50.000 Methoden. </p><br><p>  Bevor wir mit der Verwendung von JWarmup begannen, verwendeten die Eigent√ºmer unserer Anwendung simulierte Daten zum Aufw√§rmen.  Auf diesen Daten wurde der JIT-Compiler vor dem Empfang von Anforderungen vorkompiliert.  Die simulierten Daten unterscheiden sich jedoch von den tats√§chlichen Daten und sind daher f√ºr den Compiler nicht repr√§sentativ.  In einigen F√§llen trat eine unerwartete Deoptimierung auf, und die Leistung litt darunter.  Die L√∂sung f√ºr dieses Problem war JWarmup.  Er hat zwei Hauptarbeitsstufen - Aufnahme und Zusammenstellung.  Alibaba hat zwei Arten von Umgebungen, Beta und Produktion.  Beide erhalten echte Anforderungen von Benutzern, wonach dieselbe Version der Anwendung in diesen beiden Umgebungen bereitgestellt wird.  In der Beta-Umgebung werden nur Profildaten gesammelt, auf deren Grundlage eine vorl√§ufige Kompilierung in der Produktion durchgef√ºhrt wird. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5e4/aec/01c/5e4aec01c9cece135daff42490463627.jpg"></p><br><p>  Lassen Sie uns genauer sehen, welche Art von Informationen wir sammeln.  Wir m√ºssen genau aufschreiben, welche Klassen initialisiert werden, welche Methoden kompiliert werden, und diese Daten werden dann in das Protokoll auf der Festplatte geschrieben, auf das der Compiler zugreifen kann.  Der schwierigste Moment ist die Initialisierung von Klassen.       .     ‚Äî   <code>Bar</code>     <code>Foo.test()</code> ,    <code>foo.count</code> .        ,      . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3f9/1fa/cfe/3f91facfe6c55e70cad3bebe147d17ff.jpg"></p><br><p>      JWarmup    (tiered compilation),     .     ,    ‚Äî  CPU.     JWarmup    ,      CPU,   JDK.  ,       ,           JDK. ,             ,     . </p><br><p>       JWarmup.     ,     , ,  groovy-,    Java-,  .     .  ,     ,  ¬´null check elimination¬ª.         . ,    JWarmup    ,       JWarmup,   . </p><br><h1>   </h1><br><p>      ,     Alibaba. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ef5/7c9/4b0/ef57c94b07c6f3335e44d9b7baa360b9.jpg"></p><br><p>    .    JVM ‚Äî  ,    ,     .       Java-, metaspace,  VM (     VM)     JIT-.        OpenJDK. -,          ,       . -,        .   HotMethodProfiling,   ,       CPU.  ,      ,    <em>Honest Profiler</em> ,     ,      ,     HotMethodProfiling.    MethodTracing.           ,    ,     .  ,       metaspace   .          Java-,        .   metaspace  ,    .       Java. </p><br><p> ,      ,   ZProfiler. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/201/324/1fc/2013241fca408ec2cea997d466327a33.jpg"></p><br><p>       .      JVMTi,     JVM (  ).  ,    ZProfiler   Apache Tomcat.      -.    ZProfiler     JVM. ,  ZProfiler  -UI,     . ZProfiler    . -,      UI        JVM. -, ZProfiler  post-mortem . ,        OutOfMemoryError,       ,         JVM   ZProfiler,       .    ,    , , Eclipse MAT. </p><br><p>  .         .   JVM, GCIH,   Alibaba JDK,   JWarmup ‚Äî ,    ReadyNow   Zing JVM. ,    ZProfiler.      ,         ,      OpenJDK.      ,  ,    JWarmup  OpenJDK.  ,      OpenJDK   Loom,     Java.     ,   . </p><br><blockquote>  . ,     ,     JPoint  2018 .    2019 ,   JPoint   , 5-6 .      ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>     Rafael Winterhalter  Sebastian Daschner.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> .        ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   YouTube</a> .   JPoint! </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436266/">https://habr.com/ru/post/de436266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436254/index.html">Ein Bot f√ºr Starcraft in Rust, C oder einer anderen Sprache</a></li>
<li><a href="../de436256/index.html">Einen Job in Deutschland zu bekommen wird einfacher sein</a></li>
<li><a href="../de436260/index.html">Fehler und Fallstricke von Startups bei der Patentierung ihres geistigen Eigentums</a></li>
<li><a href="../de436262/index.html">* Das Ethereum-Update "Konstantinopel" wird aufgrund einer potenziellen Sicherheitsl√ºcke im letzten Moment verschoben</a></li>
<li><a href="../de436264/index.html">Mono-Repositories: bitte nicht (Teil 2)</a></li>
<li><a href="../de436268/index.html">Wir sammeln ein komplettes Deck</a></li>
<li><a href="../de436270/index.html">35% der Runet-Zuschauer verwenden √ºberhaupt keinen Computer f√ºr das Internet</a></li>
<li><a href="../de436272/index.html">Visuelle Programmierung f√ºr Sonoff Basic</a></li>
<li><a href="../de436274/index.html">In Russland wird eine mobile Anwendung zur Unfallregistrierung erstellt</a></li>
<li><a href="../de436276/index.html">Dreidimensionale Visualisierung in Simulatoren von Fahrzeugen basierend auf der OpenSceneGraph-Engine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>