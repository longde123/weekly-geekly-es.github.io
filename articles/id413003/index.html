<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ‘¨â€ğŸ‘¦ ğŸš˜ ğŸ’¯ Klien Steam menghilangkan kerentanan berbahaya yang telah bersembunyi di sana selama sepuluh tahun â›±ï¸ ğŸ‘©ğŸ½â€ğŸ’¼ ğŸ‘¨ğŸ½â€ğŸ«</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Peneliti utama Tom Court of Context, sebuah perusahaan keamanan informasi, berbicara tentang bagaimana ia berhasil mendeteksi bug yang berpotensi berb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Klien Steam menghilangkan kerentanan berbahaya yang telah bersembunyi di sana selama sepuluh tahun</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413003/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b5e/654/14d/b5e65414d10ab23ed9f334c7490b5b41.jpg" alt="gambar"></div><br>  <i>Peneliti utama Tom Court of Context, sebuah perusahaan keamanan informasi, berbicara tentang bagaimana ia berhasil mendeteksi bug yang berpotensi berbahaya dalam kode klien Steam.</i> <br><br>  Pemain PC yang sadar akan keamanan telah memperhatikan bahwa Valve baru-baru ini merilis pembaruan klien Steam baru. <br><br>  Dalam posting ini, saya ingin membuat <s>alasan untuk bermain game di tempat kerja untuk</s> menceritakan kisah bug terkait yang ada di klien Steam setidaknya selama sepuluh tahun, yang hingga Juli tahun lalu dapat menyebabkan eksekusi kode jarak jauh (eksekusi kode jarak jauh, RCE) di semua 15 juta pelanggan aktif. <br><br>  Sejak Juli, ketika Valve (akhirnya) menyusun kodenya dengan perlindungan eksploitasi modern diaktifkan, itu hanya dapat menyebabkan kegagalan klien, dan RCE hanya mungkin dalam kombinasi dengan kerentanan kebocoran informasi yang terpisah. <br><br>  Kami mendeklarasikan Valve sebagai kerentanan pada 20 Februari 2018, dan, sesuai kredit perusahaan, itu diperbaiki di cabang beta kurang dari 12 jam kemudian.  Perbaikan dipindahkan ke cabang stabil pada 22 Maret 2018. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e75/1aa/558/e751aa55836f621b240641f85adbde62.jpg" alt="gambar"></div><br><h2>  Ulasan singkat </h2><br>  Dasar dari kerentanan adalah kerusakan pada tumpukan di dalam perpustakaan klien Steam, yang bisa disebut jarak jauh, di bagian kode yang terlibat dalam memulihkan datagram terfragmentasi dari beberapa paket UDP yang diterima. <br><br>  Klien Steam bertukar data melalui protokolnya sendiri (Steam protocol), yang diimplementasikan di atas UDP.  Ada dua area dalam protokol ini yang sangat menarik karena kerentanannya: <br><br><ul><li>  Panjang paket </li><li>  Total panjang datagram yang direkonstruksi </li></ul><br>  Kesalahan itu disebabkan oleh kurangnya pemeriksaan sederhana.  Kode tidak memverifikasi bahwa panjang datagram terfragmentasi pertama kurang dari atau sama dengan total panjang datagram.  Ini tampak seperti pengawasan umum yang diberikan bahwa untuk semua paket berikutnya yang mengirimkan fragmen datagram, pemeriksaan dilakukan. <br><br>  Tanpa bug data kebocoran tambahan, tumpukan kerusakan pada sistem operasi modern sangat sulit untuk dikendalikan, sehingga eksekusi kode jauh sulit untuk diimplementasikan.  Namun, dalam kasus ini, berkat pengalokasi memori Steam sendiri dan ASLR yang hilang dari file biner steamclient.dll (hingga Juli lalu), bug ini dapat digunakan sebagai dasar untuk eksploitasi yang sangat andal. <br><br>  Di bawah ini adalah deskripsi teknis tentang kerentanan dan eksploitasi terkait hingga <br>  implementasi eksekusi kode. <br><br><h2>  Detail Kerentanan </h2><br><h3>  Informasi yang diperlukan untuk pemahaman </h3><br><h4>  Protokol </h4><br>  Pihak ketiga (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://imfreedom.org/wiki/Steam_Friends</a> ), berdasarkan analisis lalu lintas yang dihasilkan oleh klien Steam, melakukan rekayasa balik dan membuat dokumentasi terperinci dari protokol Steam.  Awalnya, protokol ini didokumentasikan pada tahun 2008 dan tidak banyak berubah sejak itu. <br><br>  Protokol diimplementasikan sebagai protokol transmisi dengan pembentukan koneksi melalui aliran datagram UDP.  Paket, sesuai dengan dokumentasi pada tautan di atas, memiliki struktur sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94b/d59/e25/94bd59e25c5dfac228e3a63b62192717.jpg" alt="gambar"></div><br>  Aspek penting: <br><br><ul><li>  Semua paket dimulai dengan 4 byte " <em>VS01</em> " </li><li>  <em>package_len</em> menjelaskan panjang informasi yang berguna (untuk datagram yang tidak dibagi, nilainya sama dengan panjang data) </li><li>  <em>tipe</em> menggambarkan tipe paket, yang dapat memiliki nilai-nilai berikut: <br><ul><li>  0x2 Otentikasi Panggilan </li><li>  0x4 Terima Koneksi </li><li>  0x5 Reset Koneksi </li><li>  0x6 Paket adalah sebuah fragmen dari datagram </li><li>  Paket 0x7 adalah datagram terpisah </li></ul></li><li>  Bidang <em>sumber</em> dan <em>tujuan</em> adalah pengidentifikasi yang ditetapkan untuk merutekan paket dengan benar pada beberapa koneksi dalam klien Steam </li><li>  Dalam kasus paket adalah sebuah fragmen dari datagram: <br><ul><li>  <em>split_count</em> menunjukkan jumlah fragmen datagram dibagi </li><li>  <em>data_len</em> menunjukkan panjang total datagram yang dipulihkan </li></ul></li><li>  Pemrosesan awal paket UDP ini terjadi pada fungsi <em>CUDPConnection :: UDPRecvPkt</em> di dalam steamclient.dll </li></ul><br><h4>  Enkripsi </h4><br>  Informasi yang berguna dari paket datagram dienkripsi oleh AES-256 menggunakan kunci, yang dinegosiasikan antara klien dan server di setiap sesi.  Negosiasi kunci dilakukan sebagai berikut: <br><br><ul><li>  Klien menghasilkan kunci acak AES 32-byte, dan RSA mengenkripsi dengan kunci publik Valve sebelum mengirimnya ke server. </li><li>  Server, memiliki kunci pribadi, dapat mendekripsi nilai ini dan menerimanya sebagai kunci AES-256, yang akan digunakan dalam sesi </li><li>  Setelah kunci disepakati, semua informasi yang berguna dalam sesi saat ini dienkripsi dengan kunci ini. </li></ul><br><h3>  Kerentanan </h3><br>  Kerentanan hadir di dalam metode <em>RecvFragment</em> dari kelas <em>CUDPConnection</em> .  Tidak ada simbol dalam versi rilis dari perpustakaan steamclient, namun, ketika mencari melalui garis biner dalam fungsi yang menarik bagi kami, tautan ke " <em>CUDPConnection :: RecvFragment</em> " ditemukan.  Memasukkan fungsi ini dilakukan ketika klien menerima paket UDP yang berisi datagram Steam tipe 0x6 ("fragmen datagram"). <br><br>  1. Fungsi dimulai dengan memeriksa status koneksi untuk memastikan bahwa itu dalam keadaan " <em>Connected</em> ". <br>  2. Kemudian, bidang <em>data_len</em> di datagram Steam diperiksa untuk memastikan bahwa itu berisi kurang dari <em>0x20000060</em> byte (tampaknya nilai ini dipilih secara sewenang-wenang). <br>  3. Jika pemeriksaan dilewatkan, fungsi memeriksa apakah koneksi mengumpulkan fragmen beberapa datagram, atau apakah itu paket pertama dari aliran. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb3/19b/451/cb319b451e64f08c718a78f0f2c5995c.jpg" alt="gambar"></div><br>  4. Jika ini adalah paket pertama dalam aliran, maka bidang <em>split_count diperiksa</em> untuk melihat berapa banyak paket yang aliran ini akan diperluas <br>  5. Jika aliran dibagi menjadi beberapa paket, maka bidang <em>seq_no_of_first_pkt diperiksa</em> untuk memastikan bahwa itu cocok dengan nomor seri paket saat ini.  Ini memastikan bahwa paket tersebut adalah yang pertama dalam aliran. <br>  6. Bidang <em>data_len diperiksa</em> lagi terhadap batas <em>0x20000060</em> byte.  Selain itu, diverifikasi bahwa <em>split_count</em> kurang dari <em>0x709b</em> paket. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e6/19b/250/7e619b25083dc91558888ef6ca1b6ef4.jpg" alt="gambar"></div><br>  7. Jika kondisi ini terpenuhi, maka nilai Boolean diatur untuk menunjukkan bahwa kami sekarang mengumpulkan fragmen.  Itu juga memeriksa bahwa kita belum memiliki buffer yang dialokasikan untuk menyimpan fragmen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69a/8b2/8c4/69a8b28c40e56f3de825d6a6c8c483c0.jpg" alt="gambar"></div><br>  8. Jika pointer ke buffer kumpulan fragmen tidak nol, maka buffer koleksi fragmen saat ini dibebaskan dan buffer baru dialokasikan (lihat kotak kuning pada gambar di bawah).  Di sinilah kesalahan muncul.  Buffer kumpulan fragmen diharapkan akan dialokasikan dalam ukuran <em>data_len</em> byte.  Jika semuanya berhasil (dan kode tidak memeriksa - kesalahan kecil), maka informasi yang berguna dari datagram disalin ke buffer ini menggunakan <em>memmove</em> , percaya bahwa jumlah byte untuk disalin ditunjukkan dalam <em>package_len</em> . <br><br>  <strong>Pengawasan paling penting dari pengembang adalah bahwa pemeriksaan " <em>packet_len</em> kurang dari atau sama dengan <em>data_len</em> " tidak dilakukan.</strong>  <strong>Ini berarti bahwa dimungkinkan untuk mentransfer <em>data_len</em> kurang dari <em>packet_len</em> dan memiliki hingga 64 KB data (karena bidang <em>packet_len menjadi</em> 2 byte lebar) disalin ke buffer yang sangat kecil, yang memungkinkan untuk mengeksploitasi tumpukan korupsi.</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4c/6ae/a31/d4c6aea31e05f0479552817bbc95a1e3.jpg" alt="gambar"></div><br><h2>  Eksploitasi kerentanan </h2><br>  Bagian ini mengasumsikan bahwa ada solusi untuk ASLR.  Ini mengarah pada fakta bahwa sebelum memulai operasi, alamat awal steamclient.dll diketahui. <br><br><h3>  Paket spoofing </h3><br>  Agar paket UDP yang menyerang diterima oleh klien, ia harus memeriksa datagram keluar (klien -&gt; server), yang dikirim untuk mengetahui pengidentifikasi koneksi klien / server, serta nomor seri.  Kemudian, penyerang harus mem-spoof alamat IP dan port sumber / tujuan bersama dengan pengidentifikasi klien / server dan menambah nomor seri yang dipelajari dengan satu. <br><br><h3>  Manajemen memori </h3><br>  Untuk mengalokasikan memori lebih dari 1024 (0x400) byte, digunakan pengalokasi sistem standar.  Untuk mengalokasikan memori kurang dari atau sama dengan 1024 byte, Steam menggunakan pengalokasi sendiri yang bekerja sama pada semua platform yang didukung.  Artikel ini tidak akan membahas secara rinci distributor ini, dengan pengecualian aspek-aspek utama berikut: <br><br><ol><li>  Blok memori besar diminta dari pengalokasi sistem, yang kemudian dibagi menjadi beberapa bagian dengan ukuran tetap untuk digunakan di bawah permintaan alokasi memori klien Steam. </li><li>  Seleksi dilakukan secara berurutan, antara fragmen yang digunakan tidak ada metadata yang memisahkannya. </li><li>  Setiap blok besar menyimpan daftar memori bebasnya sendiri, diimplementasikan sebagai daftar tertaut tunggal. </li><li>  Bagian atas daftar memori bebas menunjukkan fragmen bebas pertama dalam memori, dan 4 byte pertama dari fragmen ini menunjukkan fragmen bebas berikutnya (jika ada). </li></ol><br><h4>  Alokasi memori </h4><br>  Saat mengalokasikan memori, blok bebas pertama terputus dari bagian atas daftar memori bebas, dan 4 byte pertama dari blok ini, sesuai dengan <em>next_free_block</em> , disalin ke <em>variabel</em> anggota <em>freelist_head</em> di dalam kelas <em>pengalokasi</em> . <br><br><h4>  Memori bebas </h4><br>  Ketika sebuah blok dibebaskan, bidang <em>freelist_head</em> disalin ke 4 byte pertama dari blok yang dibebaskan ( <em>next_free_block</em> ), dan alamat blok yang dibebaskan disalin ke <em>variabel</em> anggota <em>freelist_head</em> dari kelas distributor. <br><br><h3>  Cara mendapatkan rekaman primitif </h3><br>  Buffer buffer terjadi pada heap, dan tergantung pada ukuran paket yang menyebabkan korupsi, alokasi memori dapat dikontrol baik oleh pengalokasi Windows standar (ketika mengalokasikan memori lebih dari 0x400 byte) atau oleh pengalokasi Steam sendiri (ketika mengalokasikan memori kurang dari 0x400 byte).  Karena kurangnya langkah-langkah keamanan di distributor Steam saya sendiri, saya memutuskan lebih mudah menggunakannya untuk eksploitasi. <br><br>  Mari kita kembali ke bagian manajemen memori: diketahui bahwa bagian atas daftar memori bebas dari blok dengan ukuran tertentu disimpan sebagai variabel anggota kelas distributor, dan penunjuk ke blok gratis berikutnya dalam daftar disimpan sebagai 4 byte pertama dari setiap blok bebas dari daftar. <br><br>  Jika ada blok gratis di sebelah blok tempat terjadi overflow, kerusakan pada heap memungkinkan kita untuk menimpa pointer <em>next_free_block</em> .  Jika Anda menganggap bahwa banyak yang dapat disiapkan untuk ini, maka pointer <em>next_free_block</em> ditulis ulang dapat diatur ke alamat untuk ditulis, setelah itu alokasi memori selanjutnya akan ditulis ke tempat ini. <br><br><h3>  Apa yang akan digunakan: datagram atau fragmen </h3><br>  Kesalahan dengan kerusakan memori terjadi dalam kode yang bertanggung jawab untuk memproses fragmen datagrams (paket tipe 6).  Setelah terjadinya kerusakan, fungsi <em>RecvFragment ()</em> dalam keadaan di mana ia mengharapkan untuk menerima fragmen lebih lanjut.  Namun, jika mereka tiba, maka pemeriksaan dilakukan: <br><br> <code>fragment_size + num_bytes_already_received &lt; sizeof(collection_buffer)</code> <br> <br>  Tapi jelas, ini bukan kasus seperti itu, karena paket pertama kami telah melanggar aturan ini (keberadaan kesalahan dimungkinkan untuk melewati pemeriksaan ini) dan kesalahan akan terjadi.  Untuk menghindari ini, Anda harus menghindari metode <em>CUDPConnection :: RecvFragment ()</em> setelah <em>kerusakan</em> memori. <br><br>  Untungnya, <em>CUDPConnection :: RecvDatagram ()</em> masih dapat menerima dan memproses paket tipe 7 (datagram) yang dikirim hingga <em>RecvFragment ()</em> valid, dan ini dapat digunakan untuk memulai perekaman primitif. <br><br><h3>  Masalah Enkripsi </h3><br>  Paket yang diterima oleh <em>RecvDatagram ()</em> dan <em>RecvFragment ()</em> diharapkan akan dienkripsi.  Dalam kasus <em>RecvDatagram (),</em> dekripsi dilakukan segera setelah diterimanya.  Dalam kasus <em>RecvFragment (),</em> ini terjadi setelah menerima fragmen terakhir di sesi. <br><br>  Masalah mengeksploitasi kerentanan muncul karena kita tidak tahu kunci enkripsi yang dibuat di setiap sesi.  Ini berarti bahwa setiap kode OP / kode shell yang kami kirim akan "didekripsi" menggunakan AES256, yang akan mengubah data kami menjadi sampah.  Oleh karena itu, perlu untuk menemukan metode operasi, yang mungkin segera setelah menerima paket, sebelum prosedur dekripsi akan dapat memproses informasi berguna yang terkandung dalam buffer paket. <br><br><h3>  Cara mencapai eksekusi kode </h3><br>  Mengingat pembatasan dekripsi yang dijelaskan di atas, operasi harus dilakukan sebelum dekripsi data yang masuk.  Ini memberlakukan batasan tambahan, tetapi tugasnya masih layak: Anda dapat menulis ulang pointer sehingga menunjuk ke objek <em>CWorkThreadPool yang</em> disimpan di tempat yang dapat diprediksi di dalam bagian data dari file biner.  Meskipun detail dan fungsionalitas internal kelas ini tidak diketahui, dapat diasumsikan namanya mendukung kumpulan thread yang dapat Anda gunakan saat Anda perlu melakukan "pekerjaan."  Setelah mempelajari beberapa garis debug dalam file biner, Anda dapat memahami bahwa di antara karya-karya tersebut ada enkripsi dan dekripsi ( <em>CWorkItemNetFilterEncrypt</em> , <em>CWorkItemNetFilterDecrypt</em> ), jadi ketika tugas-tugas ini di-antri, kelas <em>CWorkThreadPool digunakan</em> .  Dengan menimpa pointer ini dan menulis tempat yang diinginkan di dalamnya, kita dapat mensimulasikan pointer vtable dan vtable yang terkait dengannya, yang memungkinkan kita untuk mengeksekusi kode, misalnya ketika <em>CWorkThreadPool :: AddWorkItem ()</em> dipanggil, yang harus terjadi sebelum proses dekripsi. <br><br>  Gambar di bawah ini menunjukkan keberhasilan eksploitasi kerentanan hingga tahap mendapatkan kendali atas register EIP. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/383/537/4a83835371112599ca429941e449e734.jpg" alt="gambar"></div><br>  Mulai sekarang, Anda dapat membuat rantai ROP yang mengarah ke pelaksanaan kode arbitrer.  Video di bawah ini menunjukkan bagaimana seorang penyerang dari jarak jauh memulai kalkulator Windows dalam versi Windows 10 yang sepenuhnya ditambal. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0QaozC8S0Aw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Untuk meringkas </h2><br>  Jika Anda sampai pada bagian artikel ini, terima kasih atas kegigihan Anda!  Saya harap Anda mengerti bahwa ini adalah bug yang sangat sederhana, yang cukup mudah untuk dieksploitasi karena kurangnya perlindungan modern terhadap eksploitasi.  Kode rentan mungkin sangat tua, tetapi jika tidak berfungsi dengan baik, sehingga pengembang tidak melihat perlunya memeriksanya atau memperbarui skrip pembuatannya.  Pelajaran di sini adalah bahwa penting bagi pengembang untuk secara berkala meninjau kode lama dan membangun sistem untuk memastikan bahwa mereka mematuhi standar keamanan modern, bahkan jika fungsi kode itu sendiri tetap tidak berubah.  Sungguh menakjubkan menemukan pada tahun 2018 bug yang begitu sederhana dengan konsekuensi serius pada platform perangkat lunak yang sangat populer.  Ini harus menjadi insentif untuk mencari kerentanan seperti itu untuk semua peneliti! <br><br>  Akhirnya, ada baiknya berbicara tentang proses pengungkapan informasi yang bertanggung jawab.  Kami melaporkan bug ini kepada Valve dalam sepucuk surat kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tim</a> keamanannya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">security@valvesoftware.com</a> ) sekitar pukul 16:00 GMT dan hanya 8 jam kemudian, perbaikan dibuat dan diluncurkan ke klien beta Steam.  Berkat ini, Valve sekarang berada di tempat pertama dalam tabel (imajiner) kontes kami "Siapa yang akan memperbaiki kerentanan lebih cepat" - pengecualian yang menyenangkan dibandingkan dengan mengungkapkan kesalahan kepada perusahaan lain, yang sering sering menghasilkan proses persetujuan yang panjang. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halaman yang menjelaskan detail semua pembaruan klien</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413003/">https://habr.com/ru/post/id413003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412993/index.html">Infrastruktur Kunci Publik: Utilitas Pembuatan Permintaan Sertifikat Berkualitas</a></li>
<li><a href="../id412995/index.html">SAP cepat</a></li>
<li><a href="../id412997/index.html">Sembunyikan dan cari, atau botnet pertama yang tidak takut reboot</a></li>
<li><a href="../id412999/index.html">Dari dengungan jerapah hingga suara burung mimesis - mendengarkan alam bersama</a></li>
<li><a href="../id413001/index.html">SamsPcbGuide, Bagian 5: Tracing Signal Lines. Distorsi garis dan pencocokan impedansi</a></li>
<li><a href="../id413005/index.html">Blockchain - obat untuk penyakit utama pendidikan modern</a></li>
<li><a href="../id413007/index.html">Sintesis aneh ketika bekerja dengan FPGA</a></li>
<li><a href="../id413009/index.html">Manajemen lingkungan Python dengan Pipenv</a></li>
<li><a href="../id413011/index.html">Basement kematian</a></li>
<li><a href="../id413013/index.html">Keinginan untuk transparansi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>