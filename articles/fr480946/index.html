<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❣️ 👴🏽 🥛 Journaux dans Kubernetes (et pas seulement) aujourd'hui: attentes et réalité 🧛🏿 🎃 ⛹🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C'était en 2019, et nous n'avons toujours pas de solution standard pour l'agrégation de journaux dans Kubernetes. Dans cet article, nous souhaitons, à...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Journaux dans Kubernetes (et pas seulement) aujourd'hui: attentes et réalité</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/480946/"><img src="https://habrastorage.org/webt/b1/zh/it/b1zhitohqlji21qhzypqn8k_n2s.png"><br><br>  C'était en 2019, et nous n'avons toujours pas de solution standard pour l'agrégation de journaux dans Kubernetes.  Dans cet article, nous souhaitons, à partir d'exemples tirés de la pratique, partager nos recherches, les problèmes rencontrés et leurs solutions. <br><br>  Cependant, pour commencer, je ferai une réservation pour que différents clients comprennent des choses très différentes en collectant des journaux: <br><br><ul><li>  quelqu'un veut voir les journaux de sécurité et d'audit; </li><li>  quelqu'un - enregistrement centralisé de l'ensemble de l'infrastructure; </li><li>  et pour quelqu'un, il suffit de collecter uniquement les journaux d'application, à l'exclusion, par exemple, des équilibreurs. </li></ul><br>  À propos de la façon dont nous avons mis en œuvre divers «Wishlist» et quelles difficultés nous avons rencontrées, sous la coupe. <a name="habracut"></a><br><br><h2>  Théorie: à propos des outils de journalisation </h2><br><h3>  Contexte des composants du système de journalisation </h3><br>  La journalisation a parcouru un long chemin, grâce à laquelle nous avons développé des méthodologies de collecte et d'analyse des journaux, que nous utilisons aujourd'hui.  Dans les années 1950, Fortran a introduit un analogue des flux d'E / S standard qui a aidé le programmeur à déboguer son programme.  Ce sont les premiers journaux informatiques qui ont simplifié la vie des programmeurs de l'époque.  Aujourd'hui, nous voyons en eux le premier élément du système d'exploitation forestière - la <b>source ou le «producteur» des grumes</b> . <br><br>  L'informatique ne s'est pas arrêtée: des réseaux informatiques sont apparus, les premiers clusters ... Des systèmes complexes constitués de plusieurs ordinateurs ont commencé à fonctionner.  Les administrateurs système étaient désormais contraints de collecter les journaux de plusieurs machines et, dans des cas particuliers, ils pouvaient ajouter des messages du noyau du système d'exploitation au cas où ils auraient besoin d'enquêter sur une défaillance du système.  Pour décrire les systèmes centralisés de collecte de journaux, la <a href="https://tools.ietf.org/html/rfc3164">RFC 3164</a> est sortie au début des années 2000, qui normalisait remote_syslog.  Un autre élément important est donc apparu: le <b>collecteur (collecteur) de journaux</b> et leur stockage. <br><br>  Avec l'augmentation du volume des journaux et l'adoption généralisée des technologies Web, la question s'est posée de savoir quels journaux devraient être facilement affichés aux utilisateurs.  Les outils de console simples (awk / sed / grep) ont été remplacés par des visualiseurs de <b>journaux</b> plus avancés - le troisième composant. <br><br>  Dans le cadre de l'augmentation du volume des journaux, une autre chose est devenue claire: les journaux sont nécessaires, mais pas tous.  Et différents journaux nécessitent différents niveaux de sécurité: certains peuvent être perdus tous les deux jours, tandis que d'autres doivent être stockés pendant 5 ans.  Ainsi, un composant de filtration et de routage pour les flux de données a été ajouté au système de journalisation - appelons-le un <b>filtre</b> . <br><br>  Les référentiels ont également fait un bond en avant: ils sont passés de fichiers normaux à des bases de données relationnelles, puis à des référentiels orientés documents (par exemple, Elasticsearch).  Le stockage était donc séparé du collecteur. <br><br>  En fin de compte, le concept du journal lui-même s'est étendu à un flux abstrait d'événements que nous voulons conserver pour l'histoire.  Plus précisément, dans le cas où il est nécessaire de mener une enquête ou d'établir un rapport d'analyse ... <br><br>  En conséquence, sur une période de temps relativement courte, la collecte de journaux est devenue un sous-système important, qui peut à juste titre être appelé l'une des sous-sections du Big Data. <br><br><img src="https://habrastorage.org/webt/ld/ax/r6/ldaxr6rvel45_k3jyu3d1eddcgw.png"><br>  <i>Si jadis des impressions ordinaires pouvaient suffire à un «système d'enregistrement», la situation a maintenant beaucoup changé.</i> <br><br><h3>  Kubernetes et journaux </h3><br>  Lorsque Kubernetes est entré dans l'infrastructure, le problème existant de collecte des journaux ne lui est pas passé.  Dans un sens, c'est devenu encore plus douloureux: la gestion de la plateforme d'infrastructure a été non seulement simplifiée, mais aussi compliquée.  De nombreux anciens services ont commencé à migrer vers des pistes de microservices.  Dans le contexte des journaux, cela a entraîné un nombre croissant de sources de journaux, leur cycle de vie spécial et la nécessité de suivre à travers les journaux les interconnexions de tous les composants du système ... <br><br>  Pour l'avenir, je peux dire que, malheureusement, il n'existe actuellement aucune option de journalisation standardisée pour Kubernetes qui serait avantageusement différente de tout le monde.  Les programmes les plus populaires dans la communauté sont les suivants: <br><br><ul><li>  quelqu'un déploie une pile <b>EFK</b> (Elasticsearch, Fluentd, Kibana); </li><li>  quelqu'un essaie le <a href="https://grafana.com/oss/loki/"><b>Loki</b></a> récemment sorti ou utilise l' <a href="https://banzaicloud.com/products/logging-operator/"><b>opérateur Logging</b></a> ; </li><li>  nous <i>(et peut-être pas seulement nous? ..)</i> sommes largement satisfaits de notre propre développement - <a href="https://github.com/flant/loghouse"><b>loghouse</b></a> ... </li></ul><br>  En règle générale, nous utilisons ces bundles dans les clusters K8s (pour les solutions auto-hébergées): <br><br><ul><li>  <a href="https://github.com/kiwigrid/helm-charts/tree/master/charts/fluentd-elasticsearch">Fluentd + Elasticsearch + Kibana</a> ; </li><li>  <a href="https://github.com/flant/loghouse">Fluentd + ClickHouse + loghouse</a> . </li></ul><br>  Cependant, je ne m'attarderai pas sur les instructions d'installation et de configuration.  Au lieu de cela, je me concentrerai sur leurs lacunes et sur des conclusions plus globales sur la situation des journaux en général. <br><br><h2>  Entraînez-vous avec les journaux dans les K8 </h2><br><img src="https://habrastorage.org/webt/zv/p8/lj/zvp8ljnjmqen_8c0svhhh2kezyc.jpeg" align="left"><br><h3>  "Journaux quotidiens", combien d'entre vous? .. </h3><br>  La collecte centralisée des journaux avec une infrastructure suffisamment grande nécessite des ressources considérables qui seront consacrées à la collecte, au stockage et au traitement des journaux.  Au cours de l'exploitation de divers projets, nous avons été confrontés à diverses exigences et aux problèmes opérationnels qui en ont résulté. <br><br><h4>  Essayons ClickHouse </h4><br>  Regardons un référentiel centralisé sur un projet avec une application qui génère pas mal de logs: plus de 5000 lignes par seconde.  Commençons à travailler avec ses journaux, en les ajoutant à ClickHouse. <br><br>  Dès que le temps réel maximum est requis, le serveur ClickHouse à 4 cœurs sera déjà surchargé sur le sous-système de disque: <br><br><img src="https://habrastorage.org/webt/i4/zy/i6/i4zyi6fxq4175ljs3slazm9rgxc.png"><br><br>  Ce type de téléchargement est dû au fait que nous essayons d'écrire dans ClickHouse le plus rapidement possible.  Et la base de données répond à cela avec une charge de disque accrue, ce qui peut provoquer les erreurs suivantes: <br><br> <code>DB::Exception: Too many parts (300). Merges are processing significantly slower than inserts</code> <br> <br>  Le fait est que les <a href="https://clickhouse.yandex/docs/en/operations/table_engines/mergetree/">tables MergeTree</a> dans ClickHouse (elles contiennent des données de journal) ont leurs propres difficultés lors des opérations d'écriture.  Les données qui y sont insérées génèrent une partition temporaire, qui fusionne ensuite avec la table principale.  En conséquence, l'enregistrement est très exigeant sur le disque, et la restriction s'applique à lui, dont nous avons reçu la notification ci-dessus: pas plus de 300 sous-partitions peuvent fusionner en 1 seconde (en fait, c'est 300 insert'ov par seconde). <br><br>  Pour éviter ce problème, vous devez <a href="https://github.com/ClickHouse/ClickHouse/issues/3174">écrire dans ClickHouse en</a> morceaux aussi grands que possible et pas plus d'une fois en 2 secondes.  Cependant, l'écriture en lots importants suggère que nous devrions écrire moins souvent dans ClickHouse.  Ceci, à son tour, peut entraîner des débordements de tampon et la perte de journaux.  La solution consiste à augmenter le tampon Fluentd, mais la consommation de mémoire augmentera. <br><br>  <i><b>Remarque</b> : Un autre problème avec notre solution ClickHouse était que le partitionnement dans notre cas (loghouse) était implémenté via des tables externes liées par une <a href="https://clickhouse.yandex/docs/ru/operations/table_engines/merge/">table Merge</a> .</i>  <i>Cela conduit au fait que lors de l'échantillonnage de grands intervalles de temps, une quantité excessive de RAM est requise, car le métatable traverse toutes les partitions - même celles qui ne contiennent évidemment pas les données nécessaires.</i>  <i>Cependant, cette approche peut désormais être déclarée obsolète en toute sécurité pour les versions actuelles de ClickHouse (depuis <a href="">18.16</a> ).</i> <br><br>  En conséquence, il devient clair que loin de chaque projet aura suffisamment de ressources pour collecter les journaux en temps réel dans ClickHouse (plus précisément, leur distribution ne sera pas opportune).  De plus, vous devrez utiliser une <b>batterie</b> , à laquelle nous reviendrons.  Le cas décrit ci-dessus est réel.  Et à cette époque, nous ne pouvions pas offrir une solution fiable et stable qui conviendrait au client et permettrait de collecter les journaux avec un délai minimum ... <br><br><h4>  Et Elasticsearch? </h4><br>  Elasticsearch est connu pour gérer de lourdes charges.  Essayons-le dans le même projet.  Maintenant, la charge est la suivante: <br><br><img src="https://habrastorage.org/webt/jh/we/7o/jhwe7ok8_l0alrlv5j72p5lgha0.png"><br><br>  Elasticsearch a pu digérer le flux de données, cependant, y écrire de tels volumes utilise beaucoup le CPU.  Ceci est décidé par l'organisation du cluster.  Purement techniquement, ce n'est pas un problème, mais il s'avère que seulement pour le fonctionnement du système de collecte de journaux, nous utilisons déjà environ 8 cœurs et avons un composant supplémentaire très chargé dans le système ... <br><br>  Conclusion: cette option peut être justifiée, mais uniquement si le projet est important et que sa direction est prête à consacrer des ressources importantes à un système de journalisation centralisé. <br><br>  Une question logique se pose alors: <br><br><h3>  Quels journaux sont vraiment nécessaires? </h3><br><img src="https://habrastorage.org/webt/hl/3h/ei/hl3heiig0t7nluwc_bvorqrrndk.jpeg" align="left">  Essayons de changer l'approche elle-même: les journaux doivent être informatifs en même temps et ne pas couvrir <i>tous les</i> événements du système. <br><br>  Disons que nous avons une boutique en ligne prospère.  Quels journaux sont importants?  Rassembler autant d'informations que possible, par exemple, à partir d'une passerelle de paiement est une excellente idée.  Mais tous les journaux ne sont pas critiques pour nous du service de découpage d'images dans le catalogue de produits: seules les erreurs et la surveillance avancée suffisent (par exemple, le pourcentage de 500 erreurs que ce composant génère). <br><br>  Nous sommes donc arrivés à la <b>conclusion</b> que <b>la journalisation centralisée est loin d'être toujours justifiée</b> .  Très souvent, le client souhaite collecter tous les journaux en un seul endroit, bien qu'en fait, seuls 5% des messages critiques pour l'entreprise soient requis pour l'ensemble du journal: <br><br><ul><li>  Parfois, il suffit de configurer, par exemple, uniquement la taille du journal du conteneur et du collecteur d'erreurs (par exemple, Sentry). </li><li>  Pour enquêter sur les incidents, des alertes d'erreur et un grand journal local lui-même peuvent souvent suffire. </li><li>  Nous avions des projets qui ne coûtaient que des tests fonctionnels et des systèmes de collecte d'erreurs.  Le développeur n'avait pas besoin des journaux en tant que tels - ils ont tout vu sur les traces d'erreur. </li></ul><br><h4>  Illustration de la vie </h4><br>  Un bon exemple est une autre histoire.  Nous avons reçu une demande de l'équipe de sécurité d'un des clients qui disposait déjà d'une solution commerciale développée bien avant l'implémentation de Kubernetes. <br><br>  Il a fallu «se faire des amis» un système centralisé de collecte de journaux avec un capteur d'entreprise pour détecter les problèmes - QRadar.  Ce système est capable de recevoir des journaux en utilisant le protocole syslog, pour les prendre depuis FTP.  Cependant, son intégration avec le plugin remote_syslog pour fluentd n'a pas fonctionné tout de suite <i>(il s'est avéré que <a href="https://developer.ibm.com/answers/questions/429729/using-fluentd-to-streamfilter-data-to-qradar/">nous ne sommes pas les seuls</a> )</i> .  Les problèmes de configuration de QRadar étaient du côté de l'équipe de sécurité du client. <br><br>  En conséquence, une partie des journaux critiques pour l'entreprise a été téléchargée sur FTP QRadar, et l'autre partie a été redirigée via un syslog distant directement à partir des nœuds.  Pour ce faire, nous avons même écrit un <a href="https://github.com/flant/examples/tree/master/2019/10-remote-syslog">tableau simple</a> - peut-être que cela aidera quelqu'un à résoudre un problème similaire ... Grâce au schéma résultant, le client lui-même a reçu et analysé les journaux critiques (en utilisant ses outils préférés), et nous avons pu réduire le coût du système de journalisation, en ne gardant que le dernier mois. <br><br>  Un autre exemple montre bien comment ne pas le faire.  L'un de nos clients pour gérer <i>chaque</i> événement provenant de l'utilisateur, a fait une <i>sortie d'</i> information <i>non structurée</i> multiligne dans le journal.  Comme vous pouvez le deviner, ces journaux étaient extrêmement difficiles à lire et à stocker. <br><br><h3>  Critères pour les journaux </h3><br>  De tels exemples conduisent à la conclusion que, en plus de choisir un système de collecte de journaux, vous devez également <i>concevoir les journaux eux-mêmes</i> !  Quelles sont les exigences ici? <br><br><ul><li>  Les journaux doivent être dans un format lisible par machine (par exemple JSON). </li><li>  Les journaux doivent être compacts et pouvoir changer le degré de journalisation afin de déboguer d'éventuels problèmes.  Dans le même temps, dans les environnements de production, vous devez exécuter des systèmes avec un niveau de journalisation comme <i>Avertissement</i> ou <i>Erreur</i> . </li><li>  Les journaux doivent être normalisés, c'est-à-dire que dans l'objet journal, toutes les lignes doivent avoir le même type de champ. </li></ul><br>  Les journaux non structurés peuvent entraîner des problèmes lors du chargement des journaux dans le référentiel et de l'arrêt complet de leur traitement.  Pour illustrer, voici un exemple avec une erreur 400, que beaucoup ont sûrement rencontré dans les journaux fluentd: <br><br> <code>2019-10-29 13:10:43 +0000 [warn]: dump an error event: error_class=Fluent::Plugin::ElasticsearchErrorHandler::ElasticsearchError error="400 - Rejected by Elasticsearch"</code> <br> <br>  Une erreur signifie que vous envoyez un champ dont le type est instable à l'index avec un mappage prêt.  L'exemple le plus simple est un champ dans le journal nginx avec la variable <code>$upstream_status</code> .  Il peut avoir un nombre ou une chaîne.  Par exemple: <br><br> <code>{ "ip": "1.2.3.4", "http_user": "-", "request_id": "17ee8a579e833b5ab9843a0aca10b941", "time": "29/Oct/2019:16:18:57 +0300", "method": "GET", "uri": "/staffs/265.png", "protocol": "HTTP/1.1", "status": "200", "body_size": "906", "referrer": "https://example.com/staff", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36", "request_time": "0.001", "cache_status": "-", "upstream_response_time": "0.001, 0.007", "upstream_addr": "127.0.0.1:9000", "upstream_status": "200", "upstream_response_length": "906", "location": "staff"} <br> { "ip": "1.2.3.4", "http_user": "-", "request_id": "47fe42807f2a7d8d5467511d7d553a1b", "time": "29/Oct/2019:16:18:57 +0300", "method": "GET", "uri": "/staff", "protocol": "HTTP/1.1", "status": "200", "body_size": "2984", "referrer": "-", "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.70 Safari/537.36", "request_time": "0.010", "cache_status": "-", "upstream_response_time": "0.001, 0.007", "upstream_addr": "10.100.0.10:9000, 10.100.0.11:9000", "upstream_status": "404, 200", "upstream_response_length": "0, 2984", "location": "staff"}</code> <br> <br>  Les journaux montrent que le serveur 10.100.0.10 a répondu avec l'erreur 404e et la demande est allée à un autre magasin de contenu.  En conséquence, dans les journaux, la signification est devenue la suivante: <br><br> <code>"upstream_response_time": "0.001, 0.007"</code> <br> <br>  Cette situation est si répandue qu'elle a même gagné une <a href="https://github.com/uken/fluent-plugin-elasticsearch">mention</a> distincte <a href="https://github.com/uken/fluent-plugin-elasticsearch">dans la documentation</a> . <br><br><h4>  Et la fiabilité? </h4><br>  Il y a des moments où tous les journaux sont vitaux sans exception.  Et avec cela, les schémas de collecte de journaux typiques pour les K8 proposés / discutés ci-dessus ont des problèmes. <br><br>  Par exemple, fluentd ne peut pas collecter de bûches dans des conteneurs de courte durée.  Dans l'un de nos projets, le conteneur avec la migration de la base de données a vécu moins de 4 secondes, puis a été supprimé - selon l'annotation correspondante: <br><br> <code>"helm.sh/hook-delete-policy": hook-succeeded</code> <br> <br>  Pour cette raison, le journal de migration n'est pas entré dans le référentiel.  La politique de <code>before-hook-creation</code> peut aider dans ce cas. <br><br>  Un autre exemple est la rotation des journaux Docker.  Supposons qu'il existe une application qui écrit activement dans les journaux.  Dans des conditions normales, nous parvenons à traiter tous les journaux, mais dès qu'un problème survient - par exemple, comme décrit ci-dessus avec le mauvais format - le traitement s'arrête et Docker fait pivoter le fichier.  Conclusion - les journaux critiques peuvent être perdus. <br><br>  C'est pourquoi <b>il est important de séparer le flux de journaux</b> , en intégrant l'envoi des plus précieux directement dans l'application pour assurer leur sécurité.  De plus, il ne sera pas superflu de créer une sorte de <b>«batterie» de journaux</b> qui puisse survivre à la brève indisponibilité du stockage tout en conservant les messages critiques. <br><br>  Enfin, n'oubliez pas <b>qu'il est important de surveiller tout sous-système de manière qualitative</b> .  Sinon, il est facile de rencontrer une situation dans laquelle fluentd est dans l'état <code>CrashLoopBackOff</code> et n'envoie rien, ce qui promet la perte d'informations importantes. <br><br><h2>  Conclusions </h2><br>  Dans cet article, nous ne considérons pas les solutions SaaS comme Datadog.  Bon nombre des problèmes décrits ici ont déjà été résolus d'une manière ou d'une autre par des sociétés commerciales spécialisées dans la collecte de journaux, mais tout le monde ne peut pas utiliser le SaaS pour diverses raisons <i>(les principales sont le coût et la conformité avec 152-)</i> . <br><br>  La collecte centralisée des journaux ressemble à première vue à une tâche simple, mais elle ne l'est pas du tout.  Il est important de se rappeler que: <br><br><ul><li>  La journalisation détaillée n'est que des composants critiques, et pour d'autres systèmes, vous pouvez configurer la surveillance et la collecte des erreurs. </li><li>  Les grumes en production doivent être minimisées afin de ne pas donner une charge supplémentaire. </li><li>  Les journaux doivent être lisibles par machine, normalisés, avoir un format strict. </li><li>  Les journaux vraiment critiques doivent être envoyés dans un flux distinct, qui doit être séparé des principaux. </li><li>  Il vaut la peine d'envisager une batterie de journaux, qui peut économiser des rafales de charge élevée et rendre la charge sur le stockage plus uniforme. </li></ul><br><img src="https://habrastorage.org/webt/ss/hd/9f/sshd9fqiav2abndbb_uqo0mdjke.jpeg" align="left"><br>  Ces règles simples, si elles étaient appliquées partout, permettraient aux circuits décrits ci-dessus de fonctionner - même s'ils manquent de composants importants (batterie).  Si vous n'adhérez pas à ces principes, la tâche vous mènera facilement, vous et l'infrastructure, vers un autre composant très chargé (et en même temps inefficace) du système. <br><br><h2>  PS </h2><br>  Lisez aussi dans notre blog: <br><br><ul><li>  « <a href="https://habr.com/ru/company/flant/blog/341386/">Présentation de loghouse - un système open source pour travailler avec les journaux dans Kubernetes</a> »; </li><li>  " <a href="https://m.habr.com/ru/news/t/476966/">Versions pour l'écosystème Kubernetes avec KubeCon'19: JFrog Container Registry, Kui d'IBM, Loki 1.0.0 ...</a> "; </li><li>  " <a href="https://habr.com/ru/company/flant/blog/412901/">Monitoring and Kubernetes (revue et reportage vidéo)</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480946/">https://habr.com/ru/post/fr480946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480930/index.html">Tapez tout</a></li>
<li><a href="../fr480936/index.html">IntelliJ IDEA conversion rapide UPPER_CASE en camelCase</a></li>
<li><a href="../fr480938/index.html">La crypto-monnaie à travers les yeux des juges russes</a></li>
<li><a href="../fr480940/index.html">Exécutez un test d'interface utilisateur multi-navigateur avec Cucumber et Selenoid dans Gitlab CI avec rapport Allure</a></li>
<li><a href="../fr480944/index.html">Top 5 des tendances du marketing par e-mail en 2020</a></li>
<li><a href="../fr480948/index.html">Marketing Mitap et RP à Ivanovo</a></li>
<li><a href="../fr480950/index.html">Analyse du quiz Android du stand hh.ru au Mobius 2019 Moscou</a></li>
<li><a href="../fr480954/index.html">Numéro de tâche 1. Découvrez le sexe et le degré de relation</a></li>
<li><a href="../fr480956/index.html">Comment j'ai trouvé un moyen de suivre tous les pilotes Citimobil</a></li>
<li><a href="../fr480958/index.html">Connexion satellite. Vue d'ensemble des sociétés opérateurs et un peu sur la notation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>