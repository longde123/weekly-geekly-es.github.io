<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¢ üõ´ üë®üèª‚Äçüî¨ Wie man sich nicht mit einer Zustandsmaschine ins Bein schie√üt üåõ üõ£Ô∏è ü§∑üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Zustandsmaschine wird von mobilen Entwicklern selten verwendet. Obwohl die Mehrheit die Prinzipien der Arbeit kennt und sie leicht unabh√§ngig umse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man sich nicht mit einer Zustandsmaschine ins Bein schie√üt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423293/"> Die Zustandsmaschine wird von mobilen Entwicklern selten verwendet.  Obwohl die Mehrheit die Prinzipien der Arbeit kennt und sie leicht unabh√§ngig umsetzt.  In diesem Artikel werden wir am Beispiel von iOS-Anwendungen herausfinden, welche Aufgaben von der Zustandsmaschine gel√∂st werden.  Die Geschichte wird in der Natur angewendet und widmet sich den praktischen Aspekten der Arbeit. <br><br>  Unter dem Schnitt finden Sie eine erweiterte Abschrift von Alexander Sychevs Rede ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Brain89</a> ) auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf</a> , in der er seine Optionen f√ºr die Verwendung der Zustandsmaschine bei der Entwicklung von Nicht-Spiel-Anwendungen teilte. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GKMrJe3mfwU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>√úber den Redner:</b> Alexander Sychev ist seit acht Jahren in der iOS-Entwicklung t√§tig. W√§hrend dieser Zeit war er an der Erstellung einfacher Anwendungen und komplexer Clients f√ºr soziale Netzwerke und den Finanzsektor beteiligt.  Im Moment ist ein technischer Leiter bei der Sberbank. <br><a name="habracut"></a><br>  Sie kommen aus vielen Bereichen zum Programmieren, haben unterschiedliche Hintergr√ºnde und Erfahrungen, daher erinnern wir uns zun√§chst an die grundlegende Theorie. <br><br><h2>  Erkl√§rung des Problems <br></h2><br><img src="https://habrastorage.org/webt/ow/wa/vd/owwavd51w_12g14nwehehu4yfu4.jpeg"><br><br>  Eine Zustandsmaschine ist eine mathematische Abstraktion, die aus drei Hauptelementen besteht: <br><br><ul><li>  viele interne Zust√§nde </li><li>  die Menge der Eingangssignale, die den √úbergang vom aktuellen Zustand zum n√§chsten bestimmen, </li><li>  S√§tze von Endzust√§nden, bei deren √úbergang der Automat seine Arbeit beendet ("gibt das Eingabewort x zu"). </li></ul><br><h3>  Zustand <br></h3><br>  Mit Zustand meinen wir eine Variable oder eine Gruppe von Variablen, die das Verhalten eines Objekts bestimmen.  In der Standard-iOS-Anwendung "Einstellungen <strong>"</strong> gibt es beispielsweise einen Punkt "Fett" ("Grundlegend ‚Üí Universeller Zugriff").  Mit dem Wert dieses Elements k√∂nnen Sie zwischen zwei Optionen f√ºr die Anzeige von Text auf der Ger√§teanzeige wechseln. <br><br><img src="https://habrastorage.org/webt/mx/if/68/mxif68m4rgadt4kgjqovnzswvny.jpeg"><br><br>  Durch das Senden des gleichen Signals ‚Äû√Ñndern Sie den Wert des Kippschalters <strong>‚Äú erhalten</strong> wir eine andere Reaktion des Systems: entweder den √ºblichen Schriftstil oder Fettdruck - alles ist einfach.  Wenn sich ein Objekt in verschiedenen Zust√§nden befindet und dasselbe Signal empf√§ngt, reagiert es unterschiedlich auf eine Zustands√§nderung. <br><br><h2>  Traditionelle Aufgaben <br></h2><br>  In der Praxis sto√üen Programmierer h√§ufig auf eine endliche Zustandsmaschine. <br><br><h3>  Spieleanwendungen <br></h3><br>  Dies ist das erste, was mir in den Sinn kommt - als Teil des Gameplays wird fast alles vom aktuellen Spielstatus bestimmt.  Daher geht Apple davon aus, dass Zustandsautomaten haupts√§chlich in Spieleanwendungen verwendet werden (wir werden dies sp√§ter ausf√ºhrlich er√∂rtern). <br><br>  Das Verhalten des Systems bei der Verarbeitung des gleichen Signals, jedoch mit einem anderen internen Zustand, kann anhand der folgenden Beispiele veranschaulicht werden.  Zum Beispiel: <br><br>  ‚óè Der Spielcharakter kann unterschiedliche St√§rken haben: einer in mechanischer R√ºstung und mit einer Laserpistole, der andere ist schwach gepumpt.  Abh√§ngig von diesem Zustand wird das Verhalten von Feinden bestimmt: Sie greifen entweder an oder rennen weg. <br><br><img src="https://habrastorage.org/webt/-9/ur/ci/-9urcijninqy6zo8as2i8adn46o.jpeg"><br><br>  ‚óè Das Spiel wird angehalten. Der aktuelle Frame muss nicht gezeichnet werden.  der Spieler im Men√ºmodus oder im Spielprozess - das Rendern ist v√∂llig anders. <br><br><h3>  Textanalyse <br></h3><br>  Eine der beliebtesten Textanalyse-Aufgaben im Zusammenhang mit der Verwendung einer Zustandsmaschine sind Spam-Filter.  Es gebe eine Reihe von Stoppw√∂rtern und eine Eingabesequenz.  Sie m√ºssen diese Sequenz entweder filtern oder gar nicht anzeigen. <br><br><img src="https://habrastorage.org/webt/vo/ka/c2/vokac2-lpmhmsapxqmtked5buo4.jpeg"><br><br>  Formal ist dies die Aufgabe, einen Teilstring in einem String zu finden.  Um dies zu l√∂sen, wird der Knut-Morris-Pratt-Algorithmus verwendet, dessen Softwareimplementierung eine Finite-State-Maschine ist.  Der Status ist der Versatz der Eingabesequenz und die Anzahl der Zeichen im Musterstoppwort. <br><br>  <strong>Bei der Analyse regul√§rer Ausdr√ºcke</strong> werden h√§ufig Finite-State-Maschinen verwendet. <br><br><h3>  Parallele Abfrageverarbeitung <br></h3><br>  Eine Zustandsmaschine ist eine der Optionen zum Implementieren der Anforderungsverarbeitung und zum Ausf√ºhren eines strengen Befehlssatzes. <br><br><img src="https://habrastorage.org/webt/i_/ll/n9/i_lln9kr6-tfmnr0ejx7mjn3ytk.jpeg"><br><br>  Beispielsweise werden auf dem Nginx-Webserver Eingabeanforderungen verschiedener Protokolle unter Verwendung von Zustandsautomaten verarbeitet.  Abh√§ngig vom spezifischen Protokoll wird eine spezifische Implementierung der Zustandsmaschine ausgew√§hlt und dementsprechend wird ein bekannter Satz von Anweisungen ausgef√ºhrt. <br><br>  Im Allgemeinen werden zwei Klassen von Problemen erhalten: <br><br><ul><li>  Verwalten der Logik eines komplexen Objekts mit einem komplexen internen Zustand, </li><li>  Bildung von Kontroll- und Datenfl√ºssen (Beschreibung des Algorithmus). </li></ul><br>  Offensichtlich treten solche allgemeinen Aufgaben in der Praxis eines jeden Programmierers auf.  Daher ist die Verwendung einer Zustandsmaschine m√∂glich, auch in Nicht-Gaming-Inhaltsanwendungen, an denen die meisten mobilen Entwickler beteiligt sind. <br><br>  Als N√§chstes analysieren wir, wo und wann die Zustandsmaschine zum Erstellen typischer iOS-Anwendungen verwendet werden kann. <br><br>  Die meisten mobilen Anwendungen haben eine mehrschichtige Architektur.  Es gibt drei Basisschichten. <br><br><ul><li>  Pr√§sentationsschicht. </li><li>  Gesch√§ftslogikschicht. </li><li>  Eine Reihe von Helfern, Netzwerkclients usw. (Kernschicht). </li></ul><br>  Wie oben angegeben, steuert die Zustandsmaschine Objekte mit komplexem Verhalten, d.h.  mit komplexem Zustand.  Solche Objekte befinden sich definitiv in der Pr√§sentationsschicht, da sie Entscheidungen treffen, indem Benutzereingaben oder Nachrichten vom Betriebssystem verarbeitet werden.  Schauen wir uns die verschiedenen Ans√§tze f√ºr die Ausf√ºhrung an. <br><br><img src="https://habrastorage.org/webt/ic/iq/pw/iciqpwtfuuokmoik0j5abflppg4.jpeg"><br><br>  In der klassischen Architekturmetapher von Model-View-Controller befindet sich der Status im Controller: Er entscheidet, was in der Ansicht angezeigt wird und wie auf Eingangssignale reagiert wird: Dr√ºcken einer Taste, √Ñndern des Schiebereglers usw.  Es ist logisch, dass eine der Implementierungen der Steuerung eine Zustandsmaschine ist. <br><br><img src="https://habrastorage.org/webt/xt/sv/cr/xtsvcrd3ehffxfreo8ivtwx7jy8.jpeg"><br><br>  In VIPER befindet sich der Status im Pr√§sentator: Er bestimmt den spezifischen Navigations√ºbergang vom aktuellen Bildschirm und der Anzeige von Daten in der Ansicht. <br><br><img src="https://habrastorage.org/webt/_p/ob/xb/_pobxbwjjwduuken8qiucqg5o30.jpeg"><br><br>  In Model-View-ViewModel befindet sich der Status im ViewModel.  Unabh√§ngig davon, ob wir reaktive Bindemittel haben oder nicht, wird das Verhalten des in der MVVM-Metapher definierten Moduls im ViewModel aufgezeichnet.  Offensichtlich ist seine Implementierung durch eine Zustandsmaschine eine akzeptable Option. <br><br><img src="https://habrastorage.org/webt/x0/8e/kf/x08ekfoc9zyg1s9_9jiirethpgm.jpeg"><br><br>  Komplexe Objekte mit einem nicht trivialen Satz von Zust√§nden werden auch auf der Gesch√§ftslogikschicht der Anwendung angetroffen.  Beispielsweise sendet oder blockiert ein Netzwerkclient, der abh√§ngig davon, ob eine Verbindung zum Server hergestellt wurde oder nicht, Anforderungen.  Oder ein Objekt f√ºr die Arbeit mit einer Datenbank, das Sprachfunktionen in eine SQL-Abfrage √ºbersetzen, ausf√ºhren, eine Antwort erhalten, in Objekte √ºbersetzen usw. muss. <br><br><img src="https://habrastorage.org/webt/pb/bq/yt/pbbqytlwgtmbcutdlliqv5xkwjs.jpeg"><br><br>  Bei spezifischeren Aufgaben, wie einem Zahlungsmodul, bei dem ein breiterer Satz von Zust√§nden, eine komplexe Logik, die Verwendung einer Zustandsmaschine ebenfalls korrekt ist. <br><br>  Infolgedessen stellen wir fest, dass es in mobilen Anwendungen viele Objekte gibt, deren Zustand und Verhaltenslogik komplizierter beschrieben werden als mit einem Satz.  Sie m√ºssen in der Lage sein, zu verwalten. <br><br>  Betrachten Sie ein <strong>reales Beispiel</strong> und verstehen Sie, wann eine Finite-State-Maschine wirklich ben√∂tigt wird und wo ihre Anwendung nicht gerechtfertigt ist. <br><br><img src="https://habrastorage.org/webt/96/hk/lw/96hklw8ditorh2imz2zcx36wmga.jpeg"><br><br>  Betrachten Sie den ViewController aus der Championship iOS-Anwendung, eine beliebte Sportressource.  Dieser Controller zeigt eine Reihe von Kommentaren in tabellarischer Form an.  Benutzer geben die Spielbeschreibung ein, zeigen Fotos an, lesen die Nachrichten und hinterlassen ihre Kommentare.  Der Bildschirm ist recht einfach: Die darunter liegende Ebene liefert Daten, sie werden verarbeitet und auf dem Bildschirm angezeigt. <br><img src="https://habrastorage.org/webt/m7/m1/yz/m7m1yz9--h4qttlcuxjrozagl48.jpeg"><br><br>  Es k√∂nnen entweder reale Daten oder ein Fehler an das Display √ºbertragen werden.  Es erscheint also der erste bedingte Operator, der erste Zweig, der das weitere Verhalten der Anwendung bestimmt. <br><br>  Die n√§chste Frage ist, was zu tun ist, wenn keine Daten vorhanden sind.  Ist dieser Zustand ein Fehler?  H√∂chstwahrscheinlich nicht: Nicht jede Nachricht enth√§lt Benutzerkommentare.  Zum Beispiel ist Hockey in √Ñgypten f√ºr niemanden von Interesse, in einem solchen Artikel gibt es normalerweise keine Kommentare.  Dies ist normales Verhalten und der normale Zustand des Bildschirms, den Sie anzeigen m√ºssen.  Der zweite bedingte Operator wird angezeigt. <br><br>  Es ist logisch anzunehmen, dass es auch einen Startzustand gibt, in dem der Benutzer Daten erwartet (z. B. wenn der Kommentarbildschirm nur auf dem Bildschirm angezeigt wird).  Zeigen Sie in diesem Fall die Ladeanzeige korrekt an.  Dies ist die dritte bedingte Aussage. <br><br>  Wir haben also bereits vier Zust√§nde auf einem einfachen Bildschirm, dessen Anzeigelogik durch das Konstrukt if-else-if-else beschrieben wird. <br><br><img src="https://habrastorage.org/webt/ys/yg/mq/ysygmq4fbj3mog3p6mjb0t5av9o.jpeg"><br><br>  Aber was ist, wenn es mehr solche Staaten gibt?  Die iterative Entwicklung des Bildschirms f√ºhrt zu einem komplizierten Gewirr von bedingten Konstrukten, einer Reihe von Flags oder einem umst√§ndlichen Fall mit mehreren Schaltern.  Dieser Code ist be√§ngstigend.  Stellen Sie sich vor, der Entwickler, der ihn unterst√ºtzt, wei√ü, wo Sie wohnen, und er hat eine Kettens√§ge, die er immer bei sich hat.  Und Sie m√∂chten Ihrer kleinen, aber wohlverdienten Rente wirklich gerecht werden. <br><br>  Ich denke, in diesem Fall lohnt es sich zu √ºberlegen, ob es sich lohnt, eine solche Implementierung in der Anwendung zu belassen. <br><br><h3>  Nachteile <br></h3><br>  Lassen Sie uns verstehen, was uns an diesem Code nicht gef√§llt. <br><br><img src="https://habrastorage.org/webt/2u/a-/67/2ua-67iwmlvw9zki5oxmjf4mfqe.jpeg"><br><br>  Erstens ist es <strong>schwer zu lesen</strong> . <br><br>  Da der Code schlecht gelesen wird, ist es f√ºr einen neuen Entwickler schwierig, herauszufinden, was genau an einer bestimmten Stelle im Projekt implementiert ist.  Dementsprechend wird es viel Zeit in Anspruch nehmen, die Logik des Anwendungsverhaltens zu analysieren - die <strong>Kosten f√ºr Support und Entwicklung werden steigen</strong> . <br><br>  Dieser Code ist nicht <strong>flexibel</strong> .  Wenn Sie einen neuen Status hinzuf√ºgen m√ºssen, der nicht aus der aktuellen Leiter folgt, ist dies m√∂glicherweise √ºberhaupt nicht erfolgreich!  Wenn Sie einen Durchgang ben√∂tigen - beenden Sie abrupt das Bestehen von Schecks auf dieser Leiter - wie geht das?  Fast nichts. <br><br>  Auch bei diesem Ansatz <strong>gibt es keinen Schutz vor fiktiven Staaten</strong> .  Wenn √úberg√§nge durch einen Switch-Fall beschrieben werden, wird h√∂chstwahrscheinlich das Standardverhalten implementiert.  Dieser Zustand ist logisch in Bezug auf das Programmverhalten, aber kaum logisch in Bezug auf die menschliche oder gesch√§ftliche Logik der Anwendung. <br><br>  Was kann die L√∂sung f√ºr die angegebenen M√§ngel sein?  Dies ist nat√ºrlich die Konstruktion der Logik jedes Moduls / Controllers / komplexen Objekts, die nicht auf Intuition basiert, sondern einen guten formalisierten Ansatz verwendet.  Zum Beispiel eine endliche Zustandsmaschine. <br><br><h2>  Gameplaykit <br></h2><br>  Als <strong>Beispiel</strong> nehmen wir das, was Apple anbietet.  Im Rahmen des GameplayKit-Frameworks gibt es zwei Klassen, die uns bei der Arbeit mit der Zustandsmaschine helfen. <br><br><ul><li>  GKState. </li><li>  GKStateMachine. </li></ul><br>  Der Name des Frameworks macht deutlich, dass Apple in Spielen verwendet werden wollte.  <strong>In Nicht-Gaming-Anwendungen ist</strong> dies jedoch hilfreich. <br><br><img src="https://habrastorage.org/webt/pz/ez/de/pzezdem8jc81mab3alsm3e8pqwo.png"><br><br>  Die <strong>GKState-</strong> Klasse definiert den Status.  Um es zu beschreiben, m√ºssen Sie einfache Schritte ausf√ºhren.  Wir erben von dieser Klasse, legen den Statusnamen fest und definieren drei Methoden. <br><br><ul><li>  isValidNextState - Gibt an, ob der aktuelle Status basierend auf dem vorherigen g√ºltig ist. </li><li>  didEnterFrom - Aktionen beim √úbergang in diesen Zustand. </li><li>  willExitTo - Aktionen beim Verlassen dieses Status. </li></ul><br><br><img src="https://habrastorage.org/webt/z2/q2/gj/z2q2gj0bg2-vsoejvz0crdbhmb4.png"><br><br>  <strong>GKStateMachine ist</strong> eine Zustandsmaschinenklasse.  Es ist noch einfacher.  Es reicht aus, zwei Aktionen auszuf√ºhren. <br><br><ul><li>  Wir √ºbergeben den Satz von Eingabezust√§nden √ºber den Initialisierer an das typisierte Array. </li><li>  Wir machen √úberg√§nge abh√§ngig von den Eingangssignalen mit der Enter-Methode.  Dadurch wird auch der Ausgangszustand eingestellt. </li></ul><br>  Es kann verwirrend sein, dass eine Klasse als Argument an die <strong>enter-</strong> Methode √ºbergeben wird.  Es sollte jedoch beachtet werden, dass ein Objekt einer Klasse nicht in einem Array von Zust√§nden definiert werden kann <strong>-</strong> dies verbietet eine strikte Typisierung.  Wenn Sie also eine beliebige Klasse als n√§chste Statusklasse festlegen, geschieht nichts, und die enter-Methode gibt false zur√ºck. <br><br><h3>  Zust√§nde und √úberg√§nge zwischen ihnen <br></h3><br>  Nachdem wir uns mit dem Framework von Apple vertraut gemacht haben, kehren wir zum Beispiel zur√ºck.  Es ist notwendig, die Zust√§nde und √úberg√§nge zwischen ihnen zu beschreiben.  Sie m√ºssen dies auf die verst√§ndlichste Weise tun.  Es gibt zwei g√§ngige Optionen: eine Tabelle oder ein √úbergangsdiagramm.  Das √úbergangsdiagramm ist meiner Meinung nach eine verst√§ndlichere Option.  Es ist in UML auf standardisierte Weise.  Deshalb w√§hlen wir es. <br><br>  Im √úbergangsdiagramm gibt es Zust√§nde, die durch Namen beschrieben werden, und Pfeile, die diese Zust√§nde verbinden, um √úberg√§nge zu beschreiben.  Im Beispiel gibt es einen Anfangszustand <strong>-</strong> wir erwarten Daten <strong>-</strong> und es gibt drei Zust√§nde, die vom Anfangszustand aus erreicht werden k√∂nnen: empfangene Daten, keine Daten und Fehler. <br><br><img src="https://habrastorage.org/webt/cg/dn/gs/cgdngsj7omvfgbfvkpdgtazpeva.jpeg"><br><br>  In der Implementierung erhalten wir vier kleine Klassen. <br><br><img src="https://habrastorage.org/webt/qo/tc/rq/qotcrq6wbihios-sonhj8ajfhey.png"><br><br>  Lassen Sie uns den Status "Daten ausstehend" analysieren.  Am Eingang lohnt es sich, die Download-Anzeige anzuzeigen.  Und wenn Sie diesen Zustand verlassen <strong>,</strong> verstecken Sie ihn.  Dazu ben√∂tigen Sie eine schwache Verbindung zum ViewController, der von der erstellten Zustandsmaschine gesteuert wird. <br><br><img src="https://habrastorage.org/webt/p8/41/aa/p841aapjpxsvcqirsklkcy9o4us.png"><br><br><h3>  Maschinenparameter <br></h3><br>  Der zweite Schritt, der ausgef√ºhrt werden muss, <strong>besteht</strong> darin, die Parameter der Zustandsmaschine einzustellen.  Erstellen Sie dazu Zust√§nde und √ºbertragen Sie diese auf das Automatenobjekt. <br><br><img src="https://habrastorage.org/webt/zd/ww/pm/zdwwpm8i_i6lxoxjkzh_a2deqzi.jpeg"><br><br>  Stellen Sie au√üerdem sicher, dass Sie den Ausgangszustand festlegen <br><br><img src="https://habrastorage.org/webt/mx/sg/ka/mxsgkacbkni4fjczcvsagtec8lm.png"><br><br>  Grunds√§tzlich ist die Maschine alles bereit.  Jetzt ist es notwendig, Reaktionen auf externe Ereignisse zu verarbeiten und den Zustand des Automaten zu √§ndern. <br><br><img src="https://habrastorage.org/webt/_c/jt/hf/_cjthf0r7-5d5u0fdxucgksdz2w.png"><br><br>  Erinnern Sie sich an die Erkl√§rung des Problems.  Wir haben eine Leiter von if-else bekommen, auf deren Grundlage entschieden wurde, welche Aktion durchgef√ºhrt werden soll.  Als Steuerung f√ºr einen einfachen Automaten kann eine solche Implementierungsoption sein (in der Tat ein einfacher Schalter <strong>-</strong> dies ist eine primitive Implementierung einer endlichen Zustandsmaschine), aber wir werden die zuvor erw√§hnten Nachteile praktisch nicht beseitigen. <br><br>  Es gibt einen anderen Ansatz, mit dem Sie von diesen Leitern wegkommen k√∂nnen.  Es wird von den Klassikern der Programmierung vorgeschlagen <strong>- der</strong> sogenannten "Viererbande". <br><br><img src="https://habrastorage.org/webt/qv/if/sf/qvifsfqe0iqs3rsroauy4bptayg.jpeg"><br><br>  Es gibt ein spezielles Entwurfsmuster, das als "Status" bezeichnet wird. <br><br><img src="https://habrastorage.org/webt/nd/eh/wp/ndehwptccwh7lh90dmsixkzybo0.jpeg"><br><br>  Dies ist ein Verhaltensmuster √§hnlich einer Strategie, die eine Zustandsmaschinenabstraktion beschreibt.  Es erm√∂glicht dem Objekt, sein Verhalten je nach Status zu √§ndern.  Der Hauptzweck der Anwendung <strong>besteht darin</strong> , das Verhalten und die Daten, die einem bestimmten Status zugeordnet sind, in einer separaten Klasse zusammenzufassen.  Somit sendet die Zustandsmaschine, die anf√§nglich die Entscheidung getroffen hat, welchen Zustand sie verursachen soll, nun ein Signal, √ºbersetzt es in einen Zustand und der Zustand trifft eine Entscheidung.  Entladen Sie die Leiter also teilweise, und die Verwendung des Codes wird angenehmer. <br><br>  Das Standard-Framework wei√ü nicht wie.  Er schl√§gt vor, dass <strong>GKStateMachine</strong> die Entscheidung treffen wird.  Daher erweitern wir die endliche Zustandsmaschine mit einer neuen Methode, bei der wir als Konfiguration die Beschreibung aller bedingten Variablen √ºbergeben, die den n√§chsten Zustand eindeutig bestimmen.  Innerhalb dieser Methode k√∂nnen Sie die Auswahl des n√§chsten Status an den aktuellen delegieren. <br><br><img src="https://habrastorage.org/webt/gu/sw/nr/guswnro2dw8m3fsctqqjx8_7js8.png"><br><br>  Es wird empfohlen, den Status mit einem Objekt zu beschreiben und ihn immer weiterzugeben, anstatt viele, viele Eingabeparameter zu schreiben.  Als n√§chstes delegieren wir die Auswahl des n√§chsten Zustands an den aktuellen.  Das ist das ganze Upgrade. <br><br><img src="https://habrastorage.org/webt/te/9t/5a/te9t5acirqz1o5awpxzy1tsbyia.png"><br><br>  <strong>Vorteile von GameplayKit.</strong> <br><br><ul><li>  Standardbibliothek.  Sie m√ºssen nichts herunterladen, keine Cocoapods oder Karthago verwenden. </li><li>  Die Bibliothek ist recht einfach zu erlernen. </li><li>  Es gibt zwei Implementierungen gleichzeitig: auf Objective-C und auf Swift. </li></ul><br>  <strong>Nachteile:</strong> <br><br><ul><li>  Realisierungen von Zust√§nden und √úberg√§ngen sind eng miteinander verbunden. <br>  Das Prinzip der alleinigen Verantwortung wird verletzt: Der Staat wei√ü, wohin und wie es geht. </li><li>  Doppelte Zust√§nde werden in keiner Weise kontrolliert. <br>  Ein Array wird an die Zustandsmaschine √ºbergeben, nicht viele Zust√§nde.  Wenn Sie mehrere identische Zust√§nde √ºbertragen, wird der letzte aus der Liste verwendet. </li></ul><br>  Was sind die Implementierungen der endlichen Zustandsmaschine noch?  Schauen Sie sich GitHub an. <br><br><h2>  Objective-C-Implementierungen <br></h2><br><img src="https://habrastorage.org/webt/vo/zt/zy/voztzyatty-amllrmtl8ny4ke3c.png"><br><br><h3>  TransitionKit <br></h3><br>  Dies ist seit langem die beliebteste Objective-C-Bibliothek, ohne die in GamePlayKit festgestellten M√§ngel.  Es erm√∂glicht uns, eine Zustandsmaschine und alle damit verbundenen Aktionen auf Bl√∂cken zu implementieren. <br><br>  <strong>Der Zustand ist von √úberg√§ngen getrennt</strong> . <br><br>  Innerhalb von TransitionKit gibt es 2 Klassen. <br><br><ol><li>  TKState - zum Festlegen von Status- und Eingabe- und Ausgabeaktionen. </li><li>  TKEvent ist eine Klasse zur Beschreibung des √úbergangs. <br>  TKEvent bindet einige Zust√§nde an andere.  Das Ereignis selbst wird einfach durch eine Zeichenfolge definiert. </li></ol><br>  Dar√ºber hinaus gibt es zus√§tzliche Vorteile. <br><br>  <strong>Sie k√∂nnen n√ºtzliche Daten w√§hrend des √úbergangs √ºbertragen</strong> .  Dies funktioniert genauso wie bei Verwendung von NSNotificationCenter.  Alle n√ºtzlichen Nutzdaten werden in Form eines userInfo-W√∂rterbuchs bereitgestellt, und der Benutzer analysiert die Informationen. <br><br>  <strong>Der fehlerhafte √úbergang hat eine Beschreibung</strong> .  Wenn wir versuchen, einen nicht vorhandenen - unm√∂glichen √úbergang durchzuf√ºhren - erhalten wir nicht nur den NO-Wert, wenn wir von der √úbergangsmethode zur√ºckkehren, sondern auch eine detaillierte Beschreibung des Fehlers, die beim Debuggen einer Zustandsmaschine hilfreich ist. <br><br><img src="https://habrastorage.org/webt/hi/x9/bx/hix9bx5ctgjldoay4btqajopgb0.jpeg"><br><br>  TransitionKit wird im beliebten RestKit Network Harvester verwendet.  Dies ist ein ziemlich gutes Beispiel daf√ºr, wie eine Zustandsmaschine im Anwendungskernel bei der Implementierung von Netzwerkoperationen verwendet werden kann. <br><br><img src="https://habrastorage.org/webt/ls/os/d3/lsosd3z1zbg5knnmbrggmpq2zro.jpeg"><br><br>  RestKit verf√ºgt √ºber eine spezielle Klasse - RKOperationStateMachine - zum Verwalten gleichzeitiger Vorg√§nge.  An der Eingabe akzeptiert es die zu verarbeitende Operation und die Warteschlange f√ºr ihre Ausf√ºhrung. <br><br><img src="https://habrastorage.org/webt/r2/pn/mc/r2pnmcfsl_6uzdzhsin_mrq_vkg.jpeg"><br><br>  Intern ist die Zustandsmaschine sehr einfach: drei Zust√§nde (bereit, ausgef√ºhrt, abgeschlossen) und zwei √úberg√§nge: Start und Ende der Ausf√ºhrung.  Nach dem Start der Verarbeitung (und bei allen √úberg√§ngen) beginnt die Zustandsmaschine, einen vordefinierten Benutzercodeblock in der beim Erstellen der Warteschlange angegebenen Warteschlange zu steuern. <br><br>  Eine mit ihrem Automaten verkn√ºpfte Operation √ºbertr√§gt externe Ereignisse an den Automaten und f√ºhrt √úberg√§nge zwischen Zust√§nden und allen zugeh√∂rigen Aktionen durch.  State Machine k√ºmmert sich darum <br><br><ul><li>  asynchrone Codeausf√ºhrung, </li><li>  Atomcode-Ausf√ºhrung w√§hrend √úberg√§ngen, </li><li>  √úbergangskontrolle </li><li>  Betriebsstornierung </li><li>  Die Richtigkeit der √Ñnderung der Betriebszustandsvariablen: isReady, isExecuting, isFinished. </li></ul><br><h3>  Verschiebung <br></h3><br>  Neben TransitionKit ist <strong>Shift</strong> zu erw√§hnen - eine winzige Bibliothek, die als Kategorie √ºber NSObject implementiert ist.  Mit diesem Ansatz k√∂nnen Sie jedes Objekt in eine Zustandsmaschine verwandeln und seinen Zustand in Form von Zeichenfolgenkonstanten und Aktionen in Bl√∂cken w√§hrend √úberg√§ngen beschreiben.  Dies ist nat√ºrlich eher ein Schulungsprojekt, aber sehr interessant und erm√∂glicht es Ihnen, zu minimalen Kosten zu testen, was eine Zustandsmaschine ist. <br><br><h2>  Schnelle Implementierungen <br></h2><br><img src="https://habrastorage.org/webt/_t/dx/kd/_tdxkdwt0sqzgy78o-q-_z0c_nq.png"><br><br>  Es gibt viele Implementierungen von Finite-State-Maschinen in Swift.  Ich werde eines <strong>herausgreifen</strong> ( <strong>Bemerkung</strong> : Leider hat sich das Projekt in den letzten zwei Jahren nach dem Bericht nicht weiterentwickelt, aber die darin enthaltenen Ideen sind es wert, im Artikel erw√§hnt zu werden). <br><br><h3>  SwiftyStateMachine <br></h3><br>  In SwiftyStateMachine wird die Zustandsmaschine durch eine nicht stabile Struktur dargestellt. Mit den didSet-Methoden der Eigenschaft k√∂nnen Sie Status√§nderungen leicht abfangen. <br><br>  In dieser Bibliothek wird die Zustandsmaschine durch die Entsprechungstabelle von Zust√§nden und √úberg√§ngen zwischen ihnen definiert.  Dieses Schema wird getrennt von dem Objekt beschrieben, das die Maschine steuern wird.  Dies wird durch einen verschachtelten Switch-Fall implementiert. <br><br><img src="https://habrastorage.org/webt/y5/cz/dl/y5czdlkikmxb4kyylgwgxfsdxuy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauptmerkmale, Vorteile dieser Bibliothek sind. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Notwendigkeit, das Zustands√ºbergangsschema vollst√§ndig zu beschreiben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese Weise k√∂nnen Sie in der Kompilierungsphase einen Fehler erhalten, wenn der √úbergang f√ºr einen bestimmten Status nicht verarbeitet wird.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strikte Kontrolle der Eingangssignale. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen kein Signal an eine Zustandsmaschine √ºbergeben, die nicht definiert ist oder die f√ºr eine andere Zustandsmaschine definiert ist.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch die Trennung der Schaltung und des von ihr gesteuerten Objekts k√∂nnen Sie Zeit bei der Initialisierung der Maschine sparen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisierung mit der DOT-Grafikbeschreibungssprache. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine grafische Auszeichnungssprache f√ºr die Arbeit mit Zustandsdiagrammen - DOT. </font><font style="vertical-align: inherit;">Diese Bibliothek gibt damit an, wie die Zustandsmaschine gerendert wird.</font></font></li></ul><br><img src="https://habrastorage.org/webt/wb/zg/du/wbzgduy9duy-shpt0pcjjjt0ru8.jpeg"><br><br><h2>  Fazit <br></h2><br>          . <br><br><ul><li> <strong>.</strong> <br>           ,     .    ,         . ,   . <br></li><li> <strong>  .</strong> <br>     ( ). <br></li><li> <strong> .</strong> <br>       ,    ,        . </li><li> <strong>       .</strong> , SwiftyStateMachine     ,    ,     .     . </li><li> <strong> .</strong> <br>   ,    . , ,      .       . <br></li></ul><br>        . <br><br><img src="https://habrastorage.org/webt/wb/ek/ww/wbekwwlr0a_w8wzt6z0bo12jdmm.jpeg"><br><br>       .      ,    .    , ,    switch case:  ,  ,  ‚Äî     . <br><br><img src="https://habrastorage.org/webt/hq/ay/db/hqaydbygw58xgcalwyvph1haeho.jpeg"><br><br>  .    .    ,  .  ,    ,  ,     .    . <br><br><img src="https://habrastorage.org/webt/b9/mb/ze/b9mbze-xdkufz2mbs7p61obsjqo.jpeg"><br><br>      ,      ,      .     . <br><br><img src="https://habrastorage.org/webt/bc/qp/hr/bcqphramltmjhaakirn_uo00e4i.png"><br><br>    ‚Äî  <strong> </strong> .       :      , ‚Äî    . <br><br><img src="https://habrastorage.org/webt/iw/qz/we/iwqzwefnjh4xnqexwoovxccugqo.jpeg"><br><br><img src="https://habrastorage.org/webt/i4/80/vk/i480vkfuwmhwpdd31totlvl5298.jpeg"><br><br>   ¬´-¬ª     <strong> </strong> . <br><br><img src="https://habrastorage.org/webt/s-/kf/ox/s-kfoxsckujhbrzsslebpzuqwei.jpeg"><br><br> ,    .         . <br><br><img src="https://habrastorage.org/webt/le/oo/ju/leoojuz3yycfncczpfbgftsa1tq.jpeg"><br><br>        <strong>app coordinators</strong> ‚Äî   ,     ,    : ,     .       ,       . <br><br>  , app coordinator ,  state machine.            . ,    app coordinators  state machine,         , ,  , <strong>  </strong> .      , ,   ,         .    . <br><br><img src="https://habrastorage.org/webt/mx/yu/1q/mxyu1qczcjazzunuhe7jfoolv2e.png"><br><br> , state machine  ,    ,         . <br><br>     state machine  ,     if-else.   ,         . <br><br><blockquote>     Apps Conf 2018,   8  9 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>    -     . <br><br>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YouTube-</a> .           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423293/">https://habr.com/ru/post/de423293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423279/index.html">Wie ich das russische Tablet entwickelt habe</a></li>
<li><a href="../de423281/index.html">Feedback im Team, 360 und 14. Februar</a></li>
<li><a href="../de423283/index.html">Modellierung des Sagnac-Effekts mit geometrischer Optik</a></li>
<li><a href="../de423285/index.html">Social Engineering: Der schwer fassbare Feind in der Welt der Cybersicherheit</a></li>
<li><a href="../de423291/index.html">Die Russen stellten einen Rekord auf: 110 Raubkopien pro Person</a></li>
<li><a href="../de423295/index.html">N√ºtzlichste Konferenz f√ºr mobile Entwicklung</a></li>
<li><a href="../de423297/index.html">Vom Android-Entwickler zu DevOps</a></li>
<li><a href="../de423299/index.html">Anwendungskoordinator in iOS-Apps</a></li>
<li><a href="../de423303/index.html">KI, praktischer Kurs. Emotionsbasierte Musiktransformation</a></li>
<li><a href="../de423305/index.html">Leistung ruinieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>