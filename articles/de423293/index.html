<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔢 🛫 👨🏻‍🔬 Wie man sich nicht mit einer Zustandsmaschine ins Bein schießt 🌛 🛣️ 🤷🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Zustandsmaschine wird von mobilen Entwicklern selten verwendet. Obwohl die Mehrheit die Prinzipien der Arbeit kennt und sie leicht unabhängig umse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man sich nicht mit einer Zustandsmaschine ins Bein schießt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423293/"> Die Zustandsmaschine wird von mobilen Entwicklern selten verwendet.  Obwohl die Mehrheit die Prinzipien der Arbeit kennt und sie leicht unabhängig umsetzt.  In diesem Artikel werden wir am Beispiel von iOS-Anwendungen herausfinden, welche Aufgaben von der Zustandsmaschine gelöst werden.  Die Geschichte wird in der Natur angewendet und widmet sich den praktischen Aspekten der Arbeit. <br><br>  Unter dem Schnitt finden Sie eine erweiterte Abschrift von Alexander Sychevs Rede ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Brain89</a> ) auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf</a> , in der er seine Optionen für die Verwendung der Zustandsmaschine bei der Entwicklung von Nicht-Spiel-Anwendungen teilte. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GKMrJe3mfwU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>Über den Redner:</b> Alexander Sychev ist seit acht Jahren in der iOS-Entwicklung tätig. Während dieser Zeit war er an der Erstellung einfacher Anwendungen und komplexer Clients für soziale Netzwerke und den Finanzsektor beteiligt.  Im Moment ist ein technischer Leiter bei der Sberbank. <br><a name="habracut"></a><br>  Sie kommen aus vielen Bereichen zum Programmieren, haben unterschiedliche Hintergründe und Erfahrungen, daher erinnern wir uns zunächst an die grundlegende Theorie. <br><br><h2>  Erklärung des Problems <br></h2><br><img src="https://habrastorage.org/webt/ow/wa/vd/owwavd51w_12g14nwehehu4yfu4.jpeg"><br><br>  Eine Zustandsmaschine ist eine mathematische Abstraktion, die aus drei Hauptelementen besteht: <br><br><ul><li>  viele interne Zustände </li><li>  die Menge der Eingangssignale, die den Übergang vom aktuellen Zustand zum nächsten bestimmen, </li><li>  Sätze von Endzuständen, bei deren Übergang der Automat seine Arbeit beendet ("gibt das Eingabewort x zu"). </li></ul><br><h3>  Zustand <br></h3><br>  Mit Zustand meinen wir eine Variable oder eine Gruppe von Variablen, die das Verhalten eines Objekts bestimmen.  In der Standard-iOS-Anwendung "Einstellungen <strong>"</strong> gibt es beispielsweise einen Punkt "Fett" ("Grundlegend → Universeller Zugriff").  Mit dem Wert dieses Elements können Sie zwischen zwei Optionen für die Anzeige von Text auf der Geräteanzeige wechseln. <br><br><img src="https://habrastorage.org/webt/mx/if/68/mxif68m4rgadt4kgjqovnzswvny.jpeg"><br><br>  Durch das Senden des gleichen Signals „Ändern Sie den Wert des Kippschalters <strong>“ erhalten</strong> wir eine andere Reaktion des Systems: entweder den üblichen Schriftstil oder Fettdruck - alles ist einfach.  Wenn sich ein Objekt in verschiedenen Zuständen befindet und dasselbe Signal empfängt, reagiert es unterschiedlich auf eine Zustandsänderung. <br><br><h2>  Traditionelle Aufgaben <br></h2><br>  In der Praxis stoßen Programmierer häufig auf eine endliche Zustandsmaschine. <br><br><h3>  Spieleanwendungen <br></h3><br>  Dies ist das erste, was mir in den Sinn kommt - als Teil des Gameplays wird fast alles vom aktuellen Spielstatus bestimmt.  Daher geht Apple davon aus, dass Zustandsautomaten hauptsächlich in Spieleanwendungen verwendet werden (wir werden dies später ausführlich erörtern). <br><br>  Das Verhalten des Systems bei der Verarbeitung des gleichen Signals, jedoch mit einem anderen internen Zustand, kann anhand der folgenden Beispiele veranschaulicht werden.  Zum Beispiel: <br><br>  ● Der Spielcharakter kann unterschiedliche Stärken haben: einer in mechanischer Rüstung und mit einer Laserpistole, der andere ist schwach gepumpt.  Abhängig von diesem Zustand wird das Verhalten von Feinden bestimmt: Sie greifen entweder an oder rennen weg. <br><br><img src="https://habrastorage.org/webt/-9/ur/ci/-9urcijninqy6zo8as2i8adn46o.jpeg"><br><br>  ● Das Spiel wird angehalten. Der aktuelle Frame muss nicht gezeichnet werden.  der Spieler im Menümodus oder im Spielprozess - das Rendern ist völlig anders. <br><br><h3>  Textanalyse <br></h3><br>  Eine der beliebtesten Textanalyse-Aufgaben im Zusammenhang mit der Verwendung einer Zustandsmaschine sind Spam-Filter.  Es gebe eine Reihe von Stoppwörtern und eine Eingabesequenz.  Sie müssen diese Sequenz entweder filtern oder gar nicht anzeigen. <br><br><img src="https://habrastorage.org/webt/vo/ka/c2/vokac2-lpmhmsapxqmtked5buo4.jpeg"><br><br>  Formal ist dies die Aufgabe, einen Teilstring in einem String zu finden.  Um dies zu lösen, wird der Knut-Morris-Pratt-Algorithmus verwendet, dessen Softwareimplementierung eine Finite-State-Maschine ist.  Der Status ist der Versatz der Eingabesequenz und die Anzahl der Zeichen im Musterstoppwort. <br><br>  <strong>Bei der Analyse regulärer Ausdrücke</strong> werden häufig Finite-State-Maschinen verwendet. <br><br><h3>  Parallele Abfrageverarbeitung <br></h3><br>  Eine Zustandsmaschine ist eine der Optionen zum Implementieren der Anforderungsverarbeitung und zum Ausführen eines strengen Befehlssatzes. <br><br><img src="https://habrastorage.org/webt/i_/ll/n9/i_lln9kr6-tfmnr0ejx7mjn3ytk.jpeg"><br><br>  Beispielsweise werden auf dem Nginx-Webserver Eingabeanforderungen verschiedener Protokolle unter Verwendung von Zustandsautomaten verarbeitet.  Abhängig vom spezifischen Protokoll wird eine spezifische Implementierung der Zustandsmaschine ausgewählt und dementsprechend wird ein bekannter Satz von Anweisungen ausgeführt. <br><br>  Im Allgemeinen werden zwei Klassen von Problemen erhalten: <br><br><ul><li>  Verwalten der Logik eines komplexen Objekts mit einem komplexen internen Zustand, </li><li>  Bildung von Kontroll- und Datenflüssen (Beschreibung des Algorithmus). </li></ul><br>  Offensichtlich treten solche allgemeinen Aufgaben in der Praxis eines jeden Programmierers auf.  Daher ist die Verwendung einer Zustandsmaschine möglich, auch in Nicht-Gaming-Inhaltsanwendungen, an denen die meisten mobilen Entwickler beteiligt sind. <br><br>  Als Nächstes analysieren wir, wo und wann die Zustandsmaschine zum Erstellen typischer iOS-Anwendungen verwendet werden kann. <br><br>  Die meisten mobilen Anwendungen haben eine mehrschichtige Architektur.  Es gibt drei Basisschichten. <br><br><ul><li>  Präsentationsschicht. </li><li>  Geschäftslogikschicht. </li><li>  Eine Reihe von Helfern, Netzwerkclients usw. (Kernschicht). </li></ul><br>  Wie oben angegeben, steuert die Zustandsmaschine Objekte mit komplexem Verhalten, d.h.  mit komplexem Zustand.  Solche Objekte befinden sich definitiv in der Präsentationsschicht, da sie Entscheidungen treffen, indem Benutzereingaben oder Nachrichten vom Betriebssystem verarbeitet werden.  Schauen wir uns die verschiedenen Ansätze für die Ausführung an. <br><br><img src="https://habrastorage.org/webt/ic/iq/pw/iciqpwtfuuokmoik0j5abflppg4.jpeg"><br><br>  In der klassischen Architekturmetapher von Model-View-Controller befindet sich der Status im Controller: Er entscheidet, was in der Ansicht angezeigt wird und wie auf Eingangssignale reagiert wird: Drücken einer Taste, Ändern des Schiebereglers usw.  Es ist logisch, dass eine der Implementierungen der Steuerung eine Zustandsmaschine ist. <br><br><img src="https://habrastorage.org/webt/xt/sv/cr/xtsvcrd3ehffxfreo8ivtwx7jy8.jpeg"><br><br>  In VIPER befindet sich der Status im Präsentator: Er bestimmt den spezifischen Navigationsübergang vom aktuellen Bildschirm und der Anzeige von Daten in der Ansicht. <br><br><img src="https://habrastorage.org/webt/_p/ob/xb/_pobxbwjjwduuken8qiucqg5o30.jpeg"><br><br>  In Model-View-ViewModel befindet sich der Status im ViewModel.  Unabhängig davon, ob wir reaktive Bindemittel haben oder nicht, wird das Verhalten des in der MVVM-Metapher definierten Moduls im ViewModel aufgezeichnet.  Offensichtlich ist seine Implementierung durch eine Zustandsmaschine eine akzeptable Option. <br><br><img src="https://habrastorage.org/webt/x0/8e/kf/x08ekfoc9zyg1s9_9jiirethpgm.jpeg"><br><br>  Komplexe Objekte mit einem nicht trivialen Satz von Zuständen werden auch auf der Geschäftslogikschicht der Anwendung angetroffen.  Beispielsweise sendet oder blockiert ein Netzwerkclient, der abhängig davon, ob eine Verbindung zum Server hergestellt wurde oder nicht, Anforderungen.  Oder ein Objekt für die Arbeit mit einer Datenbank, das Sprachfunktionen in eine SQL-Abfrage übersetzen, ausführen, eine Antwort erhalten, in Objekte übersetzen usw. muss. <br><br><img src="https://habrastorage.org/webt/pb/bq/yt/pbbqytlwgtmbcutdlliqv5xkwjs.jpeg"><br><br>  Bei spezifischeren Aufgaben, wie einem Zahlungsmodul, bei dem ein breiterer Satz von Zuständen, eine komplexe Logik, die Verwendung einer Zustandsmaschine ebenfalls korrekt ist. <br><br>  Infolgedessen stellen wir fest, dass es in mobilen Anwendungen viele Objekte gibt, deren Zustand und Verhaltenslogik komplizierter beschrieben werden als mit einem Satz.  Sie müssen in der Lage sein, zu verwalten. <br><br>  Betrachten Sie ein <strong>reales Beispiel</strong> und verstehen Sie, wann eine Finite-State-Maschine wirklich benötigt wird und wo ihre Anwendung nicht gerechtfertigt ist. <br><br><img src="https://habrastorage.org/webt/96/hk/lw/96hklw8ditorh2imz2zcx36wmga.jpeg"><br><br>  Betrachten Sie den ViewController aus der Championship iOS-Anwendung, eine beliebte Sportressource.  Dieser Controller zeigt eine Reihe von Kommentaren in tabellarischer Form an.  Benutzer geben die Spielbeschreibung ein, zeigen Fotos an, lesen die Nachrichten und hinterlassen ihre Kommentare.  Der Bildschirm ist recht einfach: Die darunter liegende Ebene liefert Daten, sie werden verarbeitet und auf dem Bildschirm angezeigt. <br><img src="https://habrastorage.org/webt/m7/m1/yz/m7m1yz9--h4qttlcuxjrozagl48.jpeg"><br><br>  Es können entweder reale Daten oder ein Fehler an das Display übertragen werden.  Es erscheint also der erste bedingte Operator, der erste Zweig, der das weitere Verhalten der Anwendung bestimmt. <br><br>  Die nächste Frage ist, was zu tun ist, wenn keine Daten vorhanden sind.  Ist dieser Zustand ein Fehler?  Höchstwahrscheinlich nicht: Nicht jede Nachricht enthält Benutzerkommentare.  Zum Beispiel ist Hockey in Ägypten für niemanden von Interesse, in einem solchen Artikel gibt es normalerweise keine Kommentare.  Dies ist normales Verhalten und der normale Zustand des Bildschirms, den Sie anzeigen müssen.  Der zweite bedingte Operator wird angezeigt. <br><br>  Es ist logisch anzunehmen, dass es auch einen Startzustand gibt, in dem der Benutzer Daten erwartet (z. B. wenn der Kommentarbildschirm nur auf dem Bildschirm angezeigt wird).  Zeigen Sie in diesem Fall die Ladeanzeige korrekt an.  Dies ist die dritte bedingte Aussage. <br><br>  Wir haben also bereits vier Zustände auf einem einfachen Bildschirm, dessen Anzeigelogik durch das Konstrukt if-else-if-else beschrieben wird. <br><br><img src="https://habrastorage.org/webt/ys/yg/mq/ysygmq4fbj3mog3p6mjb0t5av9o.jpeg"><br><br>  Aber was ist, wenn es mehr solche Staaten gibt?  Die iterative Entwicklung des Bildschirms führt zu einem komplizierten Gewirr von bedingten Konstrukten, einer Reihe von Flags oder einem umständlichen Fall mit mehreren Schaltern.  Dieser Code ist beängstigend.  Stellen Sie sich vor, der Entwickler, der ihn unterstützt, weiß, wo Sie wohnen, und er hat eine Kettensäge, die er immer bei sich hat.  Und Sie möchten Ihrer kleinen, aber wohlverdienten Rente wirklich gerecht werden. <br><br>  Ich denke, in diesem Fall lohnt es sich zu überlegen, ob es sich lohnt, eine solche Implementierung in der Anwendung zu belassen. <br><br><h3>  Nachteile <br></h3><br>  Lassen Sie uns verstehen, was uns an diesem Code nicht gefällt. <br><br><img src="https://habrastorage.org/webt/2u/a-/67/2ua-67iwmlvw9zki5oxmjf4mfqe.jpeg"><br><br>  Erstens ist es <strong>schwer zu lesen</strong> . <br><br>  Da der Code schlecht gelesen wird, ist es für einen neuen Entwickler schwierig, herauszufinden, was genau an einer bestimmten Stelle im Projekt implementiert ist.  Dementsprechend wird es viel Zeit in Anspruch nehmen, die Logik des Anwendungsverhaltens zu analysieren - die <strong>Kosten für Support und Entwicklung werden steigen</strong> . <br><br>  Dieser Code ist nicht <strong>flexibel</strong> .  Wenn Sie einen neuen Status hinzufügen müssen, der nicht aus der aktuellen Leiter folgt, ist dies möglicherweise überhaupt nicht erfolgreich!  Wenn Sie einen Durchgang benötigen - beenden Sie abrupt das Bestehen von Schecks auf dieser Leiter - wie geht das?  Fast nichts. <br><br>  Auch bei diesem Ansatz <strong>gibt es keinen Schutz vor fiktiven Staaten</strong> .  Wenn Übergänge durch einen Switch-Fall beschrieben werden, wird höchstwahrscheinlich das Standardverhalten implementiert.  Dieser Zustand ist logisch in Bezug auf das Programmverhalten, aber kaum logisch in Bezug auf die menschliche oder geschäftliche Logik der Anwendung. <br><br>  Was kann die Lösung für die angegebenen Mängel sein?  Dies ist natürlich die Konstruktion der Logik jedes Moduls / Controllers / komplexen Objekts, die nicht auf Intuition basiert, sondern einen guten formalisierten Ansatz verwendet.  Zum Beispiel eine endliche Zustandsmaschine. <br><br><h2>  Gameplaykit <br></h2><br>  Als <strong>Beispiel</strong> nehmen wir das, was Apple anbietet.  Im Rahmen des GameplayKit-Frameworks gibt es zwei Klassen, die uns bei der Arbeit mit der Zustandsmaschine helfen. <br><br><ul><li>  GKState. </li><li>  GKStateMachine. </li></ul><br>  Der Name des Frameworks macht deutlich, dass Apple in Spielen verwendet werden wollte.  <strong>In Nicht-Gaming-Anwendungen ist</strong> dies jedoch hilfreich. <br><br><img src="https://habrastorage.org/webt/pz/ez/de/pzezdem8jc81mab3alsm3e8pqwo.png"><br><br>  Die <strong>GKState-</strong> Klasse definiert den Status.  Um es zu beschreiben, müssen Sie einfache Schritte ausführen.  Wir erben von dieser Klasse, legen den Statusnamen fest und definieren drei Methoden. <br><br><ul><li>  isValidNextState - Gibt an, ob der aktuelle Status basierend auf dem vorherigen gültig ist. </li><li>  didEnterFrom - Aktionen beim Übergang in diesen Zustand. </li><li>  willExitTo - Aktionen beim Verlassen dieses Status. </li></ul><br><br><img src="https://habrastorage.org/webt/z2/q2/gj/z2q2gj0bg2-vsoejvz0crdbhmb4.png"><br><br>  <strong>GKStateMachine ist</strong> eine Zustandsmaschinenklasse.  Es ist noch einfacher.  Es reicht aus, zwei Aktionen auszuführen. <br><br><ul><li>  Wir übergeben den Satz von Eingabezuständen über den Initialisierer an das typisierte Array. </li><li>  Wir machen Übergänge abhängig von den Eingangssignalen mit der Enter-Methode.  Dadurch wird auch der Ausgangszustand eingestellt. </li></ul><br>  Es kann verwirrend sein, dass eine Klasse als Argument an die <strong>enter-</strong> Methode übergeben wird.  Es sollte jedoch beachtet werden, dass ein Objekt einer Klasse nicht in einem Array von Zuständen definiert werden kann <strong>-</strong> dies verbietet eine strikte Typisierung.  Wenn Sie also eine beliebige Klasse als nächste Statusklasse festlegen, geschieht nichts, und die enter-Methode gibt false zurück. <br><br><h3>  Zustände und Übergänge zwischen ihnen <br></h3><br>  Nachdem wir uns mit dem Framework von Apple vertraut gemacht haben, kehren wir zum Beispiel zurück.  Es ist notwendig, die Zustände und Übergänge zwischen ihnen zu beschreiben.  Sie müssen dies auf die verständlichste Weise tun.  Es gibt zwei gängige Optionen: eine Tabelle oder ein Übergangsdiagramm.  Das Übergangsdiagramm ist meiner Meinung nach eine verständlichere Option.  Es ist in UML auf standardisierte Weise.  Deshalb wählen wir es. <br><br>  Im Übergangsdiagramm gibt es Zustände, die durch Namen beschrieben werden, und Pfeile, die diese Zustände verbinden, um Übergänge zu beschreiben.  Im Beispiel gibt es einen Anfangszustand <strong>-</strong> wir erwarten Daten <strong>-</strong> und es gibt drei Zustände, die vom Anfangszustand aus erreicht werden können: empfangene Daten, keine Daten und Fehler. <br><br><img src="https://habrastorage.org/webt/cg/dn/gs/cgdngsj7omvfgbfvkpdgtazpeva.jpeg"><br><br>  In der Implementierung erhalten wir vier kleine Klassen. <br><br><img src="https://habrastorage.org/webt/qo/tc/rq/qotcrq6wbihios-sonhj8ajfhey.png"><br><br>  Lassen Sie uns den Status "Daten ausstehend" analysieren.  Am Eingang lohnt es sich, die Download-Anzeige anzuzeigen.  Und wenn Sie diesen Zustand verlassen <strong>,</strong> verstecken Sie ihn.  Dazu benötigen Sie eine schwache Verbindung zum ViewController, der von der erstellten Zustandsmaschine gesteuert wird. <br><br><img src="https://habrastorage.org/webt/p8/41/aa/p841aapjpxsvcqirsklkcy9o4us.png"><br><br><h3>  Maschinenparameter <br></h3><br>  Der zweite Schritt, der ausgeführt werden muss, <strong>besteht</strong> darin, die Parameter der Zustandsmaschine einzustellen.  Erstellen Sie dazu Zustände und übertragen Sie diese auf das Automatenobjekt. <br><br><img src="https://habrastorage.org/webt/zd/ww/pm/zdwwpm8i_i6lxoxjkzh_a2deqzi.jpeg"><br><br>  Stellen Sie außerdem sicher, dass Sie den Ausgangszustand festlegen <br><br><img src="https://habrastorage.org/webt/mx/sg/ka/mxsgkacbkni4fjczcvsagtec8lm.png"><br><br>  Grundsätzlich ist die Maschine alles bereit.  Jetzt ist es notwendig, Reaktionen auf externe Ereignisse zu verarbeiten und den Zustand des Automaten zu ändern. <br><br><img src="https://habrastorage.org/webt/_c/jt/hf/_cjthf0r7-5d5u0fdxucgksdz2w.png"><br><br>  Erinnern Sie sich an die Erklärung des Problems.  Wir haben eine Leiter von if-else bekommen, auf deren Grundlage entschieden wurde, welche Aktion durchgeführt werden soll.  Als Steuerung für einen einfachen Automaten kann eine solche Implementierungsoption sein (in der Tat ein einfacher Schalter <strong>-</strong> dies ist eine primitive Implementierung einer endlichen Zustandsmaschine), aber wir werden die zuvor erwähnten Nachteile praktisch nicht beseitigen. <br><br>  Es gibt einen anderen Ansatz, mit dem Sie von diesen Leitern wegkommen können.  Es wird von den Klassikern der Programmierung vorgeschlagen <strong>- der</strong> sogenannten "Viererbande". <br><br><img src="https://habrastorage.org/webt/qv/if/sf/qvifsfqe0iqs3rsroauy4bptayg.jpeg"><br><br>  Es gibt ein spezielles Entwurfsmuster, das als "Status" bezeichnet wird. <br><br><img src="https://habrastorage.org/webt/nd/eh/wp/ndehwptccwh7lh90dmsixkzybo0.jpeg"><br><br>  Dies ist ein Verhaltensmuster ähnlich einer Strategie, die eine Zustandsmaschinenabstraktion beschreibt.  Es ermöglicht dem Objekt, sein Verhalten je nach Status zu ändern.  Der Hauptzweck der Anwendung <strong>besteht darin</strong> , das Verhalten und die Daten, die einem bestimmten Status zugeordnet sind, in einer separaten Klasse zusammenzufassen.  Somit sendet die Zustandsmaschine, die anfänglich die Entscheidung getroffen hat, welchen Zustand sie verursachen soll, nun ein Signal, übersetzt es in einen Zustand und der Zustand trifft eine Entscheidung.  Entladen Sie die Leiter also teilweise, und die Verwendung des Codes wird angenehmer. <br><br>  Das Standard-Framework weiß nicht wie.  Er schlägt vor, dass <strong>GKStateMachine</strong> die Entscheidung treffen wird.  Daher erweitern wir die endliche Zustandsmaschine mit einer neuen Methode, bei der wir als Konfiguration die Beschreibung aller bedingten Variablen übergeben, die den nächsten Zustand eindeutig bestimmen.  Innerhalb dieser Methode können Sie die Auswahl des nächsten Status an den aktuellen delegieren. <br><br><img src="https://habrastorage.org/webt/gu/sw/nr/guswnro2dw8m3fsctqqjx8_7js8.png"><br><br>  Es wird empfohlen, den Status mit einem Objekt zu beschreiben und ihn immer weiterzugeben, anstatt viele, viele Eingabeparameter zu schreiben.  Als nächstes delegieren wir die Auswahl des nächsten Zustands an den aktuellen.  Das ist das ganze Upgrade. <br><br><img src="https://habrastorage.org/webt/te/9t/5a/te9t5acirqz1o5awpxzy1tsbyia.png"><br><br>  <strong>Vorteile von GameplayKit.</strong> <br><br><ul><li>  Standardbibliothek.  Sie müssen nichts herunterladen, keine Cocoapods oder Karthago verwenden. </li><li>  Die Bibliothek ist recht einfach zu erlernen. </li><li>  Es gibt zwei Implementierungen gleichzeitig: auf Objective-C und auf Swift. </li></ul><br>  <strong>Nachteile:</strong> <br><br><ul><li>  Realisierungen von Zuständen und Übergängen sind eng miteinander verbunden. <br>  Das Prinzip der alleinigen Verantwortung wird verletzt: Der Staat weiß, wohin und wie es geht. </li><li>  Doppelte Zustände werden in keiner Weise kontrolliert. <br>  Ein Array wird an die Zustandsmaschine übergeben, nicht viele Zustände.  Wenn Sie mehrere identische Zustände übertragen, wird der letzte aus der Liste verwendet. </li></ul><br>  Was sind die Implementierungen der endlichen Zustandsmaschine noch?  Schauen Sie sich GitHub an. <br><br><h2>  Objective-C-Implementierungen <br></h2><br><img src="https://habrastorage.org/webt/vo/zt/zy/voztzyatty-amllrmtl8ny4ke3c.png"><br><br><h3>  TransitionKit <br></h3><br>  Dies ist seit langem die beliebteste Objective-C-Bibliothek, ohne die in GamePlayKit festgestellten Mängel.  Es ermöglicht uns, eine Zustandsmaschine und alle damit verbundenen Aktionen auf Blöcken zu implementieren. <br><br>  <strong>Der Zustand ist von Übergängen getrennt</strong> . <br><br>  Innerhalb von TransitionKit gibt es 2 Klassen. <br><br><ol><li>  TKState - zum Festlegen von Status- und Eingabe- und Ausgabeaktionen. </li><li>  TKEvent ist eine Klasse zur Beschreibung des Übergangs. <br>  TKEvent bindet einige Zustände an andere.  Das Ereignis selbst wird einfach durch eine Zeichenfolge definiert. </li></ol><br>  Darüber hinaus gibt es zusätzliche Vorteile. <br><br>  <strong>Sie können nützliche Daten während des Übergangs übertragen</strong> .  Dies funktioniert genauso wie bei Verwendung von NSNotificationCenter.  Alle nützlichen Nutzdaten werden in Form eines userInfo-Wörterbuchs bereitgestellt, und der Benutzer analysiert die Informationen. <br><br>  <strong>Der fehlerhafte Übergang hat eine Beschreibung</strong> .  Wenn wir versuchen, einen nicht vorhandenen - unmöglichen Übergang durchzuführen - erhalten wir nicht nur den NO-Wert, wenn wir von der Übergangsmethode zurückkehren, sondern auch eine detaillierte Beschreibung des Fehlers, die beim Debuggen einer Zustandsmaschine hilfreich ist. <br><br><img src="https://habrastorage.org/webt/hi/x9/bx/hix9bx5ctgjldoay4btqajopgb0.jpeg"><br><br>  TransitionKit wird im beliebten RestKit Network Harvester verwendet.  Dies ist ein ziemlich gutes Beispiel dafür, wie eine Zustandsmaschine im Anwendungskernel bei der Implementierung von Netzwerkoperationen verwendet werden kann. <br><br><img src="https://habrastorage.org/webt/ls/os/d3/lsosd3z1zbg5knnmbrggmpq2zro.jpeg"><br><br>  RestKit verfügt über eine spezielle Klasse - RKOperationStateMachine - zum Verwalten gleichzeitiger Vorgänge.  An der Eingabe akzeptiert es die zu verarbeitende Operation und die Warteschlange für ihre Ausführung. <br><br><img src="https://habrastorage.org/webt/r2/pn/mc/r2pnmcfsl_6uzdzhsin_mrq_vkg.jpeg"><br><br>  Intern ist die Zustandsmaschine sehr einfach: drei Zustände (bereit, ausgeführt, abgeschlossen) und zwei Übergänge: Start und Ende der Ausführung.  Nach dem Start der Verarbeitung (und bei allen Übergängen) beginnt die Zustandsmaschine, einen vordefinierten Benutzercodeblock in der beim Erstellen der Warteschlange angegebenen Warteschlange zu steuern. <br><br>  Eine mit ihrem Automaten verknüpfte Operation überträgt externe Ereignisse an den Automaten und führt Übergänge zwischen Zuständen und allen zugehörigen Aktionen durch.  State Machine kümmert sich darum <br><br><ul><li>  asynchrone Codeausführung, </li><li>  Atomcode-Ausführung während Übergängen, </li><li>  Übergangskontrolle </li><li>  Betriebsstornierung </li><li>  Die Richtigkeit der Änderung der Betriebszustandsvariablen: isReady, isExecuting, isFinished. </li></ul><br><h3>  Verschiebung <br></h3><br>  Neben TransitionKit ist <strong>Shift</strong> zu erwähnen - eine winzige Bibliothek, die als Kategorie über NSObject implementiert ist.  Mit diesem Ansatz können Sie jedes Objekt in eine Zustandsmaschine verwandeln und seinen Zustand in Form von Zeichenfolgenkonstanten und Aktionen in Blöcken während Übergängen beschreiben.  Dies ist natürlich eher ein Schulungsprojekt, aber sehr interessant und ermöglicht es Ihnen, zu minimalen Kosten zu testen, was eine Zustandsmaschine ist. <br><br><h2>  Schnelle Implementierungen <br></h2><br><img src="https://habrastorage.org/webt/_t/dx/kd/_tdxkdwt0sqzgy78o-q-_z0c_nq.png"><br><br>  Es gibt viele Implementierungen von Finite-State-Maschinen in Swift.  Ich werde eines <strong>herausgreifen</strong> ( <strong>Bemerkung</strong> : Leider hat sich das Projekt in den letzten zwei Jahren nach dem Bericht nicht weiterentwickelt, aber die darin enthaltenen Ideen sind es wert, im Artikel erwähnt zu werden). <br><br><h3>  SwiftyStateMachine <br></h3><br>  In SwiftyStateMachine wird die Zustandsmaschine durch eine nicht stabile Struktur dargestellt. Mit den didSet-Methoden der Eigenschaft können Sie Statusänderungen leicht abfangen. <br><br>  In dieser Bibliothek wird die Zustandsmaschine durch die Entsprechungstabelle von Zuständen und Übergängen zwischen ihnen definiert.  Dieses Schema wird getrennt von dem Objekt beschrieben, das die Maschine steuern wird.  Dies wird durch einen verschachtelten Switch-Fall implementiert. <br><br><img src="https://habrastorage.org/webt/y5/cz/dl/y5czdlkikmxb4kyylgwgxfsdxuy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hauptmerkmale, Vorteile dieser Bibliothek sind. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Notwendigkeit, das Zustandsübergangsschema vollständig zu beschreiben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf diese Weise können Sie in der Kompilierungsphase einen Fehler erhalten, wenn der Übergang für einen bestimmten Status nicht verarbeitet wird.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strikte Kontrolle der Eingangssignale. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können kein Signal an eine Zustandsmaschine übergeben, die nicht definiert ist oder die für eine andere Zustandsmaschine definiert ist.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Durch die Trennung der Schaltung und des von ihr gesteuerten Objekts können Sie Zeit bei der Initialisierung der Maschine sparen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisierung mit der DOT-Grafikbeschreibungssprache. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt eine grafische Auszeichnungssprache für die Arbeit mit Zustandsdiagrammen - DOT. </font><font style="vertical-align: inherit;">Diese Bibliothek gibt damit an, wie die Zustandsmaschine gerendert wird.</font></font></li></ul><br><img src="https://habrastorage.org/webt/wb/zg/du/wbzgduy9duy-shpt0pcjjjt0ru8.jpeg"><br><br><h2>  Fazit <br></h2><br>          . <br><br><ul><li> <strong>.</strong> <br>           ,     .    ,         . ,   . <br></li><li> <strong>  .</strong> <br>     ( ). <br></li><li> <strong> .</strong> <br>       ,    ,        . </li><li> <strong>       .</strong> , SwiftyStateMachine     ,    ,     .     . </li><li> <strong> .</strong> <br>   ,    . , ,      .       . <br></li></ul><br>        . <br><br><img src="https://habrastorage.org/webt/wb/ek/ww/wbekwwlr0a_w8wzt6z0bo12jdmm.jpeg"><br><br>       .      ,    .    , ,    switch case:  ,  ,  —     . <br><br><img src="https://habrastorage.org/webt/hq/ay/db/hqaydbygw58xgcalwyvph1haeho.jpeg"><br><br>  .    .    ,  .  ,    ,  ,     .    . <br><br><img src="https://habrastorage.org/webt/b9/mb/ze/b9mbze-xdkufz2mbs7p61obsjqo.jpeg"><br><br>      ,      ,      .     . <br><br><img src="https://habrastorage.org/webt/bc/qp/hr/bcqphramltmjhaakirn_uo00e4i.png"><br><br>    —  <strong> </strong> .       :      , —    . <br><br><img src="https://habrastorage.org/webt/iw/qz/we/iwqzwefnjh4xnqexwoovxccugqo.jpeg"><br><br><img src="https://habrastorage.org/webt/i4/80/vk/i480vkfuwmhwpdd31totlvl5298.jpeg"><br><br>   «-»     <strong> </strong> . <br><br><img src="https://habrastorage.org/webt/s-/kf/ox/s-kfoxsckujhbrzsslebpzuqwei.jpeg"><br><br> ,    .         . <br><br><img src="https://habrastorage.org/webt/le/oo/ju/leoojuz3yycfncczpfbgftsa1tq.jpeg"><br><br>        <strong>app coordinators</strong> —   ,     ,    : ,     .       ,       . <br><br>  , app coordinator ,  state machine.            . ,    app coordinators  state machine,         , ,  , <strong>  </strong> .      , ,   ,         .    . <br><br><img src="https://habrastorage.org/webt/mx/yu/1q/mxyu1qczcjazzunuhe7jfoolv2e.png"><br><br> , state machine  ,    ,         . <br><br>     state machine  ,     if-else.   ,         . <br><br><blockquote>     Apps Conf 2018,   8  9 ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>    -     . <br><br>     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YouTube-</a> .           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423293/">https://habr.com/ru/post/de423293/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423279/index.html">Wie ich das russische Tablet entwickelt habe</a></li>
<li><a href="../de423281/index.html">Feedback im Team, 360 und 14. Februar</a></li>
<li><a href="../de423283/index.html">Modellierung des Sagnac-Effekts mit geometrischer Optik</a></li>
<li><a href="../de423285/index.html">Social Engineering: Der schwer fassbare Feind in der Welt der Cybersicherheit</a></li>
<li><a href="../de423291/index.html">Die Russen stellten einen Rekord auf: 110 Raubkopien pro Person</a></li>
<li><a href="../de423295/index.html">Nützlichste Konferenz für mobile Entwicklung</a></li>
<li><a href="../de423297/index.html">Vom Android-Entwickler zu DevOps</a></li>
<li><a href="../de423299/index.html">Anwendungskoordinator in iOS-Apps</a></li>
<li><a href="../de423303/index.html">KI, praktischer Kurs. Emotionsbasierte Musiktransformation</a></li>
<li><a href="../de423305/index.html">Leistung ruinieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>