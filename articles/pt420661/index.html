<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👅 🎅 🏟️ Infraestrutura de nuvem contínua 👼🏿 🕋 💇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Uma demonstração do uso de ferramentas de código aberto, como Packer e Terraform, para fornecer continuamente alterações na infraestrutura a um ambien...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infraestrutura de nuvem contínua</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/420661/"> Uma demonstração do uso de ferramentas de código aberto, como Packer e Terraform, para fornecer continuamente alterações na infraestrutura a um ambiente em nuvem amigável. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/FJvl13EYtBU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  O material foi baseado em uma apresentação de Paul Stack em nossa conferência de outono do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DevOops</a> 2017. Paul é um desenvolvedor de infraestrutura que trabalhava na HashiCorp e participou do desenvolvimento de ferramentas usadas por milhões de pessoas (por exemplo, Terraform).  Ele frequentemente fala em conferências e transmite a prática da vanguarda das implementações de CI / CD, os princípios da organização adequada da parte de operações, e é capaz de explicar claramente por que os administradores fazem isso.  O restante do artigo é narrado na primeira pessoa. <br><a name="habracut"></a><br>  Então, vamos começar imediatamente com algumas descobertas importantes. <br><br><h3>  Servidor de longa duração é uma porcaria </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7f5/1dc/232/7f51dc232bf87288dc7f5c1bf7140a0d.jpg"><br><br>  Anteriormente, trabalhei em uma organização em que implantamos o Windows Server 2003 em 2008 e hoje eles ainda estão em produção.  E essa empresa não está sozinha.  Usando a área de trabalho remota nesses servidores, eles instalam o software manualmente, baixando arquivos binários da Internet.  Essa é uma péssima idéia, porque os servidores não são típicos.  Você não pode garantir que o mesmo aconteça na produção e no ambiente de desenvolvimento, no ambiente intermediário, no ambiente de controle de qualidade. <br><br><h3>  Infraestrutura Imutável </h3><br>  Em 2013, apareceu um artigo no blog de Chad Foiler intitulado “Jogue seus servidores e grave seu código: infraestrutura imutável e componentes descartáveis” (Chad Foiler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">“</a> Jogue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lixo nos servidores e grave seu código: infraestrutura imutável e componentes descartáveis”</a> ).  Isso é principalmente uma conversa de que a infraestrutura imutável é o caminho a seguir.  Criamos a infraestrutura e, se precisarmos alterá-la, estamos criando uma nova infraestrutura.  Essa abordagem é muito comum na nuvem, porque aqui é rápida e barata.  Se você possui data centers físicos, isso é um pouco mais complicado.  Obviamente, se você executa a virtualização do data center, as coisas ficam mais fáceis.  No entanto, se você ainda iniciar servidores físicos a cada vez, demorará um pouco mais para inserir um novo do que para modificar um existente. <br><br><h3>  Infraestrutura descartável </h3><br>  Segundo os programadores funcionais, "imutável" é realmente o termo errado para esse fenômeno.  Como para ser realmente imutável, sua infraestrutura precisa de um sistema de arquivos somente leitura: nenhum arquivo será gravado localmente, ninguém poderá usar SSH ou RDP, etc.  Assim, parece que, de fato, a infraestrutura não é imutável. <br><br>  A terminologia foi discutida no Twitter por seis ou até oito dias por várias pessoas.  No final, eles concordaram que uma “infraestrutura única” é uma formulação mais apropriada.  Quando o ciclo de vida da “infraestrutura única” termina, ele pode ser facilmente destruído.  Você não precisa se apegar a isso. <br><br>  Eu darei uma analogia.  Vacas de fazenda geralmente não são consideradas animais de estimação. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/be9/a17/baf/be9a17baf223a45e34c63684197cc2ce.png"><br><br>  Quando você tem gado na fazenda, não lhes dá nomes individuais.  Cada indivíduo tem um número e uma etiqueta.  O mesmo acontece com os servidores.  Se você ainda criou servidores em produção manualmente em 2006, eles têm nomes significativos, por exemplo, "Banco de Dados SQL na Produção 01".  E eles têm um significado muito específico.  E se um dos servidores travar, o inferno começa. <br><br>  Se um dos animais do rebanho morre, o fazendeiro simplesmente compra um novo.  Essa é a "infraestrutura única". <br><br><h3>  Entrega contínua </h3><br>  Então, como você combina isso com a entrega contínua? <br>  Tudo o que estou falando agora já existe há algum tempo.  Estou apenas tentando combinar as idéias de desenvolvimento de infraestrutura e desenvolvimento de software. <br><br>  Os desenvolvedores de software estão comprometidos com a entrega contínua e a integração contínua.  Por exemplo, Martin Fowler escreveu sobre a integração contínua em seu blog no início dos anos 2000.  Jez Humble promove há muito tempo a entrega contínua. <br><br>  Se você der uma olhada mais de perto, não há nada criado especificamente para o código-fonte do software.  Existe uma definição padrão da Wikipedia: <i>entrega contínua é um conjunto de práticas e princípios que visam criar, testar e liberar software o mais rápido possível</i> . <br><br>  A definição não significa aplicativos da Web ou APIs, trata-se de software em geral.  Criar software de quebra-cabeça requer muitas peças de quebra-cabeça.  Dessa forma, você pode praticar a entrega contínua de código de infraestrutura da mesma maneira. <br><br>  O desenvolvimento de infraestrutura e aplicativos são orientações bastante próximas.  E as pessoas que escrevem código de aplicativo também escrevem código de infraestrutura (e vice-versa).  Esses mundos começam a se unir.  Não existe mais essa separação e as armadilhas específicas de cada um dos mundos. <br><br><h3>  Princípios e práticas de entrega contínua </h3><br>  A entrega contínua possui vários princípios: <br><br><ul><li>  O processo de liberação / implantação de software deve ser repetível e confiável. <br></li><li>  Automatize tudo! <br></li><li>  Se um procedimento for difícil ou doloroso, faça-o com mais frequência. <br></li><li>  Mantenha tudo no controle de origem. <br></li><li>  Concluído - significa "inédito". <br></li><li>  Integre trabalho com qualidade! <br></li><li>  Todos são responsáveis ​​pelo processo de liberação. <br></li><li>  Aumentar a continuidade. <br></li></ul><br>  Mais importante, porém, a entrega contínua tem quatro práticas.  Leve-os e transfira diretamente para a infraestrutura: <br><br><ul><li>  Crie arquivos binários apenas uma vez.  Crie seu servidor uma vez.  Aqui estamos falando sobre “descartabilidade” desde o início. <br></li><li>  Use o mesmo mecanismo de implantação em cada ambiente.  Não pratique implantações diferentes no desenvolvimento e produção.  Você deve usar o mesmo caminho em cada ambiente.  Isso é muito importante. <br></li><li>  Teste sua implantação.  Eu criei muitos aplicativos.  Criei muitos problemas porque não segui o mecanismo de implantação.  Você deve sempre verificar o que acontece.  E não estou dizendo que você deva gastar cinco ou seis horas em testes em larga escala.  Chega "teste de fumaça".  Você tem uma parte essencial do sistema, que, como você sabe, permite que você e sua empresa ganhem dinheiro.  Não tenha preguiça de começar o teste.  Caso contrário, pode haver interrupções que custarão dinheiro à sua empresa. <br></li><li>  E, finalmente, a coisa mais importante.  Se algo quebrar, pare e corrija-o imediatamente!  Você não pode permitir que o problema cresça e fique cada vez pior.  Você tem que consertar isso.  Isso é realmente importante. <br></li></ul><br>  Alguém já leu o livro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Entrega contínua</a> ? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cad/9eb/b6f/cad9ebb6f6c3562724d78ef5a0454e7e.png"><br><br>  Tenho certeza de que suas empresas pagarão uma cópia que você pode transferir dentro da equipe.  Não estou dizendo que você deveria se sentar e passar um dia de folga lendo.  Se você o fizer, provavelmente desejará sair da TI.  Mas eu recomendo periodicamente o domínio de pequenos pedaços do livro, digerindo-os e pensando em como transferir isso para o seu ambiente, para a sua cultura e para o seu processo.  Um pequeno pedaço de cada vez.  Porque o fornecimento contínuo é uma conversa sobre melhoria contínua.  Não é fácil sentar no escritório com colegas e o chefe e iniciar uma conversa com a pergunta: “Como implementaremos a entrega contínua?”. Depois, escreva 10 coisas no quadro e depois de 10 dias entenda que você a implementou.  Isso leva muito tempo, causa muitos protestos, porque com a introdução de mudanças na cultura. <br><br>  Hoje vamos usar duas ferramentas: Terraform e Packer (ambos são desenvolvimentos da Hashicorp).  Uma discussão adicional será sobre por que devemos usar o Terraform e como integrá-lo ao nosso ambiente.  Não é por acaso que falo sobre essas duas ferramentas.  Até recentemente, eu também trabalhava na Hashicorp.  Mas mesmo depois de deixar o Hashicorp, ainda contribuo com o código dessas ferramentas, porque as acho realmente úteis. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d0/4b0/807/5d04b08076e6d28da7cc17589d79de6d.png"><br><br>  O Terraform suporta a interação com os provedores.  Provedores são nuvens, serviços Saas, etc. <br><br>  Dentro de cada provedor de serviços em nuvem, existem vários recursos, como sub-rede, VPC, balanceador de carga, etc. Usando o DSL (idioma específico do domínio), você informa à Terraform como será sua infraestrutura. <br><br>  Terraform usa a teoria dos grafos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c7/142/7d2/1c71427d2d18431acfe78d79797f9948.png"><br><br>  Você provavelmente conhece a teoria dos grafos.  Os nós fazem parte da nossa infraestrutura, como um balanceador de carga, sub-rede ou VPC.  Costelas são as relações entre esses sistemas.  Isso é tudo o que eu pessoalmente considero necessário saber sobre a teoria dos grafos para usar o Terraform.  Deixamos o resto para os especialistas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8de/db7/fe6/8dedb7fe6a72bd36d371f3576e841cfa.png"><br><br>  O Terraform realmente usa um gráfico direcionado porque conhece não apenas os relacionamentos, mas também sua ordem: que A (suponha que A seja VPC) deve ser definido como B, que é uma sub-rede.  E B deve ser criado antes de C (instância), porque existe um procedimento prescrito para criar abstrações no Amazon ou em qualquer outra nuvem. <br>  Mais informações sobre esse tópico estão disponíveis no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YouTube por</a> Paul Hinze, que ainda é diretor de infraestrutura da Hashicorp.  Por referência - uma ótima conversa sobre infraestrutura e teoria de grafos. <br><br><h3>  Prática </h3><br>  Escrever um código é muito melhor do que discutir uma teoria. <br><br>  Eu criei anteriormente a AMI (Amazon Machine Images).  Eu uso o Packer para criá-los e vou mostrar como fazer isso. <br><br>  A AMI é uma instância de um servidor virtual na Amazon, é predefinida (em termos de configuração, aplicativos etc.) e é criada a partir de uma imagem.  Adoro poder criar novas AMIs.  Essencialmente, as AMIs são meus contêineres do Docker. <br><br>  Então, eu tenho AMI, eles têm identificação.  Indo para a interface da Amazon, vemos que temos apenas uma AMI e nada mais: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b65/563/4cbb65563af0eea258e8c5cdc936a318.png"><br><br>  Eu posso lhe mostrar o que há nesta AMI.  Tudo é muito simples. <br><br>  Eu tenho um modelo de arquivo JSON: <br><br><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"variables"</span></span>: { <span class="hljs-string"><span class="hljs-string">"source_ami"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"region"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, <span class="hljs-string"><span class="hljs-string">"builders"</span></span>: [{ <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"amazon-ebs"</span></span>, <span class="hljs-string"><span class="hljs-string">"region"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'region'}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"source_ami"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'source_ami'}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_pty"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"instance_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"t2.micro"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_username"</span></span>: <span class="hljs-string"><span class="hljs-string">"ubuntu"</span></span>, <span class="hljs-string"><span class="hljs-string">"ssh_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"5m"</span></span>, <span class="hljs-string"><span class="hljs-string">"associate_public_ip_address"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"ami_virtualization_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"hvm"</span></span>, <span class="hljs-string"><span class="hljs-string">"ami_name"</span></span>: <span class="hljs-string"><span class="hljs-string">"application_instance-{{isotime \"2006-01-02-1504\"}}"</span></span>, <span class="hljs-string"><span class="hljs-string">"tags"</span></span>: { <span class="hljs-string"><span class="hljs-string">"Version"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{user 'version'}}"</span></span> } }], <span class="hljs-string"><span class="hljs-string">"provisioners"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"shell"</span></span>, <span class="hljs-string"><span class="hljs-string">"start_retry_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"10m"</span></span>, <span class="hljs-string"><span class="hljs-string">"inline"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"sudo apt-get update -y"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo apt-get install -y ntp nginx"</span></span> ] }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"file"</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"application-files/nginx.conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"destination"</span></span>: <span class="hljs-string"><span class="hljs-string">"/tmp/nginx.conf"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"file"</span></span>, <span class="hljs-string"><span class="hljs-string">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"application-files/index.html"</span></span>, <span class="hljs-string"><span class="hljs-string">"destination"</span></span>: <span class="hljs-string"><span class="hljs-string">"/tmp/index.html"</span></span> }, { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"shell"</span></span>, <span class="hljs-string"><span class="hljs-string">"start_retry_timeout"</span></span>: <span class="hljs-string"><span class="hljs-string">"5m"</span></span>, <span class="hljs-string"><span class="hljs-string">"inline"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"sudo mkdir -p /usr/share/nginx/html"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo mv /tmp/index.html /usr/share/nginx/html/index.html"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo mv /tmp/nginx.conf /etc/nginx/nginx.conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"sudo systemctl enable nginx.service"</span></span> ] } ] }</code> </pre> <br>  Temos variáveis ​​que passamos e o Packer possui uma lista dos chamados Construtores para diferentes áreas;  existem muitos deles.  O Builder usa uma fonte AMI especial, que eu transmito em um identificador AMI.  Dou a ele o nome de usuário e a senha do SSH e também indico se ele precisa de um endereço IP público para que as pessoas possam acessá-lo de fora.  No nosso caso, isso realmente não importa, porque é uma instância da AWS para o Packer. <br>  Também definimos o nome e as tags da AMI. <br><br>  Você não precisa analisar esse código.  Ele está aqui apenas para mostrar como ele funciona.  A parte mais importante aqui é a versão.  Isso se tornará relevante mais tarde, quando entrarmos no Terraform. <br><br>  Depois que o construtor chama a instância, os agentes de fornecimento são ativados nela.  Na verdade, eu instalo o NCP e o nginx para mostrar o que posso fazer aqui.  Copio alguns arquivos e apenas faço a configuração do nginx.  Tudo é muito simples.  Em seguida, ativei o nginx para que ele inicie quando a instância for iniciada. <br><br>  Então, eu tenho um servidor de aplicativos e funciona.  Eu posso usá-lo no futuro.  No entanto, eu sempre verifico meus modelos do Packer.  Porque é uma configuração JSON onde você pode encontrar alguns problemas. <br>  Para fazer isso, eu executo o comando: <br><br> <code>make validate <br></code> <br>  Recebo a resposta de que o modelo do Packer foi verificado com sucesso: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f0/aa3/1a7/2f0aa31a768c26246877688d0c81cc9e.png"><br><br>  Este é apenas um comando, para que eu possa conectá-lo à ferramenta de IC (qualquer um).  Na verdade, será um processo: se o desenvolvedor alterar o modelo, a solicitação pull for gerada, a ferramenta de IC verificará a solicitação, executará o equivalente à verificação do modelo e publicará o modelo em caso de verificação bem-sucedida.  Tudo isso pode ser combinado no "Master". <br>  Temos um fluxo para modelos de AMI - você só precisa aumentar a versão. <br><br>  Suponha que o desenvolvedor tenha criado uma nova versão da AMI. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc9/3b9/546/dc93b95464ccf7b7e6fbe959d4a5ddf0.png"><br><br>  Vou apenas corrigir a versão nos arquivos 1.0.0 a 1.0.1 para mostrar a diferença: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tittle</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome to DevOops!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tittle</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Welcome to DevOops!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>Version: 1.0.1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Voltarei à linha de comando e começarei a criação da AMI. <br>  Não gosto de dirigir as mesmas equipes.  Eu gosto de criar AMI rapidamente, então eu uso makefiles.  Vamos dar uma olhada com o <code>cat</code> no meu makefile: <br><br> <code>cat Makefile <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/163/0e4/bea/1630e4bea410b10ffcbb5fce2a27d595.png"><br><br>  Este é o meu makefile.  Eu até forneci a Ajuda: digito <code>make</code> e clico na guia, e isso me mostra todo o destino. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74d/cbb/611/74dcbb6110c7350483735a0f96d9fe90.png"><br><br>  Então, vamos criar uma nova versão 1.0.1 da AMI. <br><br> <code>make ami <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/879/16c/482/87916c482f6410c8a2fc73c150308409.png"><br><br>  De volta ao Terraform. <br><br>  Enfatizo que este não é um código de produção.  Isto é uma demonstração.  Existem maneiras de fazer a mesma coisa melhor. <br><br>  Eu uso os módulos Terraform em todos os lugares.  Como não trabalho mais no Hashicorp, posso expressar minha opinião sobre os módulos.  Para mim, os módulos estão no nível de encapsulamento.  Por exemplo, eu gosto de encapsular tudo relacionado à VPC: redes, sub-redes, tabelas de roteamento, etc. <br><br>  O que está acontecendo lá dentro?  Os desenvolvedores que trabalham com isso podem não se importar com isso.  Eles precisam ter um entendimento básico de como a nuvem funciona, o que é a VPC.  Mas não é necessário se aprofundar nos detalhes.  Somente as pessoas que realmente precisam alterar um módulo devem entendê-lo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a8/90c/b85/1a890cb85c3fb6a6580e8b6a25492f4f.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/177/a14/a24/177a14a241d80ee6bcc2cf64f194ce4e.png"><br><br>  Aqui, vou criar um recurso da AWS e um módulo VPC.  O que está acontecendo aqui?  Pegue o <code>cidr_block</code> nível <code>cidr_block</code> e crie três sub-redes privadas e três sub-redes públicas.  A seguir, é apresentada uma lista de áreas de disponibilidade.  Mas não sabemos o que são essas zonas de acessibilidade. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26b/ec1/4ea/26bec14eab18a025c33c2a871c4d3ed4.png"><br><br>  Nós estamos indo para criar uma VPN.  Apenas não use este módulo VPN.  É o openVPN, que cria uma instância da AWS que não possui um certificado.  Ele usa apenas o endereço IP público e é mencionado aqui apenas para mostrar que podemos conectar-se à VPN.  Existem ferramentas mais convenientes para criar uma VPN.  Levei cerca de 20 minutos e duas cervejas para escrever a minha. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae3/a5f/8a6/ae3a5f8a6561b2b9f726e2e129dfcb2f.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/6a8/f0e/7b9/6a8f0e7b965f44255365d50ad64669e0.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/078/e4c/073/078e4c073df61b68e97372c7e4730f5b.png"><br><br>  Em seguida, criamos uma camada de <code>application_tier</code> , que é um grupo de dimensionamento automático - um balanceador de carga.  Algumas configurações de inicialização são baseadas no AMI-ID e combinam várias sub-redes e zonas de disponibilidade e também usam uma chave SSH. <br>  Vamos voltar a isso em um segundo. <br><br>  Eu já mencionei zonas de disponibilidade.  Eles diferem para diferentes contas da AWS.  Minha conta nos EUA no leste pode ter acesso às zonas A, B e D. Sua conta da AWS pode ter acesso a B, C e E. Portanto, ao fixar esses valores no código, encontraremos problemas.  Na Hashicorp, sugerimos que pudéssemos criar essas fontes de dados para poder perguntar à Amazon o que estava disponível para nós.  Sob o capô, solicitamos uma descrição das zonas de disponibilidade e, em seguida, retornamos uma lista de todas as zonas da sua conta.  Graças a isso, podemos usar fontes de dados para a AMI. <br><br>  Agora chegamos ao fundo da minha demonstração.  Criei um grupo de dimensionamento automático no qual três instâncias estão em execução.  Por padrão, todos eles têm a versão 1.0.0. <br><br>  Quando implantarmos a nova versão da AMI, inicio a configuração do Terraform novamente, isso mudará a configuração de inicialização e o novo serviço receberá a próxima versão do código, etc. E podemos controlá-la. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53e/030/d08/53e030d08a8820f28ce8970bdb2bcee8.png"><br><br>  Vemos que o Packer está pronto e temos uma nova AMI. <br>  Volto à Amazon, atualizo a página e vejo uma segunda AMI. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab7/966/88d/ab796688d7e117c00b12343d54547a3a.png"><br><br>  De volta ao Terraform. <br><br>  A partir da versão 0.10, o Terraform dividiu os provedores em repositórios separados.  E o comando <code>init terraform</code> obtém uma cópia do provedor necessária para executar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a71/f24/5c1/a71f245c166bffd9cce8d2da21612bb3.png"><br><br>  Fornecedores carregados.  Estamos prontos para avançar. <br>  Em seguida, temos que executar o <code>terraform get</code> - carregar os módulos necessários.  Eles estão agora na minha máquina local.  Então o Terraform obterá todos os módulos localmente.  Em geral, os módulos podem ser armazenados em seus próprios repositórios no GitHub ou em outro local.  Foi por isso que falei sobre o módulo VPC.  Você pode conceder à equipe de rede acesso para fazer alterações.  E esta é a API para a equipe de desenvolvimento trabalhar com eles.  Realmente útil. <br><br>  O próximo passo é construir um gráfico. <br><br>  Comece com <br><br> <code>terraform plan <br></code> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/854/852/ea8/854852ea82a25694dbef99af5832eb27.png"><br><br>  O Terraform pegará o estado local atual e será comparado com a conta da AWS, indicando as diferenças.  No nosso caso, ele criará 35 novos recursos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ce/d53/2cc/3ced532cc5cbe65758669980fda88f9e.png"><br><br>  Agora aplicamos as alterações: <br><br> <code>terraform apply <br></code> <br><br>  Você não precisa fazer tudo isso na máquina local.  Estes são apenas comandos, passando variáveis ​​para o Terraform.  Você pode portar esse processo para ferramentas de IC. <br>  Se você deseja mover isso para o CI, deve usar o estado remoto.  Eu gostaria que todos que usassem o Terraform trabalhassem com um estado remoto.  Por favor, não use o estado local. <br><br>  Um de meus amigos observou que, mesmo depois de todos os anos de trabalho com Terraform, ele ainda está descobrindo algo novo.  Por exemplo, se você estiver criando uma instância da AWS, precisará fornecer uma senha e ela poderá salvá-la no seu estado.  Quando trabalhei na Hashicorp, assumimos que haveria um processo colaborativo que altera essa senha.  Portanto, não tente armazenar tudo localmente.  E então você pode colocar tudo isso nas ferramentas de IC. <br><br>  Então, a infraestrutura é criada para mim. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c55/040/c1d/c55040c1d4544a4d7c53f77a494c2be7.png"><br><br>  Terraform pode criar um gráfico: <br><br> <code>terraform graph <br></code> <br><br>  Como eu disse, ele está construindo uma árvore.  De fato, oferece a oportunidade de avaliar o que está acontecendo em sua infraestrutura.  Ele mostrará a relação entre todas as partes diferentes - todos os nós e arestas.  Como as conexões têm instruções, estamos falando de um gráfico direcionado. <br><br>  O gráfico será uma lista JSON que pode ser salva em um arquivo PNG ou DOC. <br><br>  De volta ao Terraform.  Estamos realmente criando um grupo de dimensionamento automático. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9fe/253/799/9fe253799368629b6c98d7472cbc3634.png"><br><br>  O grupo de dimensionamento automático tem capacidade para 3. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0dd/2a3/e47/0dd2a3e47ef49ba119c37c6ee1118fe9.png"><br><br>  Uma pergunta interessante: podemos usar o Vault para gerenciar segredos no Terraform?  Infelizmente, não.  Não há fonte de dados do Vault para ler segredos no Terraform.  Existem outras maneiras, como variáveis ​​de ambiente.  Com a ajuda deles, você não precisa inserir segredos no código; pode lê-los como variáveis ​​de ambiente. <br><br>  Portanto, temos algumas instalações de infraestrutura: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/107/2ef/61e/1072ef61ea789635cb6e9894005734b2.png"><br><br>  Entro na minha VPN muito secreta (não quebre minhas VPNs). <br><br>  O mais importante aqui é que temos três instâncias do aplicativo.  É verdade que eu deveria ter notado qual versão do aplicativo está sendo executada neles.  Isso é muito importante. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/009/bef/b7d/009befb7dcb30e11c9454e3b27f036cf.png"><br>  Tudo realmente está por trás da VPN: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9f/5d3/e43/b9f5d3e436b981cfc21db8e42b782db5.png"><br><br>  Se eu pegar isso ( <code>application-elb-1069500747.eu-west-1.elb.amazonaws.com</code> ) e colá-lo na barra de endereços do navegador, obtive o seguinte: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/016/40e/203/01640e2034e1cd80ff454b5c6b74c386.png"><br><br>  Deixe-me lembrá-lo de que estou conectado a uma VPN.  Se eu sair, o endereço especificado estará indisponível. <br>  Vemos a versão 1.0.0.  E não importa o quanto atualizamos a página, obtemos a 1.0.0. <br>  O que acontece se eu alterar a versão de 1.0.0 para 1.0.1 no código? <br><br><pre> <code class="javascript hljs">filter { name = <span class="hljs-string"><span class="hljs-string">"tag:Version"</span></span> values = [<span class="hljs-string"><span class="hljs-string">"1.0.1"</span></span>] }</code> </pre> <br>  Obviamente, as ferramentas de IC garantirão a criação da versão correta. <br>  Não observo atualizações manuais!  Somos imperfeitos, cometemos erros e podemos colocar a versão 1.0.6 em vez da 1.0.1 ao atualizar manualmente. <br><br><pre> <code class="javascript hljs">filter { name = <span class="hljs-string"><span class="hljs-string">"tag:Version"</span></span> values = [<span class="hljs-string"><span class="hljs-string">"1.0.6"</span></span>] }</code> </pre><br>  Mas vamos para a nossa versão (1.0.1). <br><br> <code>terraform plan <br></code> <br><br>  O Terraform atualiza o estado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb8/7f5/221/fb87f522107164e64498825e1e4e0562.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c39/8ec/61b/c398ec61bfdbd060b526417c56631b14.png"><br><br>  Então, neste momento, ele me diz que vai mudar a versão na configuração de lançamento.  Devido à alteração no identificador, forçará o reinício da configuração e o grupo de dimensionamento automático será alterado (isso é necessário para ativar a nova configuração de inicialização). <br><br>  Isso não altera as instâncias em execução.  Isso é realmente importante.  Você pode seguir esse processo e testá-lo sem alterar as instâncias na produção. <br><br>  Nota: você sempre deve criar uma nova configuração de ativação antes de destruir a antiga, caso contrário, haverá um erro. <br><br>  Vamos aplicar as alterações: <br><br> <code>terraform apply <br></code> <br><br>  Agora, de volta à AWS.  Quando todas as alterações são aplicadas, vamos para o grupo de dimensionamento automático. <br>  Vamos seguir para a configuração da AWS.  Vemos que há três instâncias com uma configuração de inicialização.  Eles são iguais. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/365/ae7/49c/365ae749cd5c77ea0634247410b58da6.png"><br><br>  A Amazon garante que, se quisermos executar três instâncias do serviço, elas serão realmente lançadas.  É por isso que lhes pagamos dinheiro. <br><br>  Vamos seguir para os experimentos. <br><br>  Uma nova configuração de inicialização foi criada.  Portanto, se eu excluir uma das instâncias, o restante não será danificado.  Isso é importante.  No entanto, se você usar as instâncias diretamente, ao alterar os dados do usuário, isso destruirá as instâncias "ativas".  Por favor, não faça isso. <br><br>  Portanto, exclua uma das instâncias: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/373/05a/eb337305af7a4e537d2f5963661f909f.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/244/711/a7c/244711a7c5beb5edd4863239e2997fc1.png"><br><br>  O que acontecerá no grupo de dimensionamento automático quando ele for desligado?  Uma nova instância aparecerá em seu lugar. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86d/1dd/8f5/86d1dd8f57f1af6e56ddf9054b777e91.png"><br><br>  Aqui você se encontra em uma situação interessante.  A instância será iniciada com a nova configuração.  Ou seja, no sistema você pode ter várias imagens diferentes (com configurações diferentes).  Às vezes, é melhor não excluir imediatamente a antiga configuração de inicialização para conectar-se conforme necessário. <br><br>  Aqui tudo se torna ainda mais interessante.  Por que não fazer isso com scripts e ferramentas de IC, e não manualmente, como mostro?  Existem ferramentas que podem fazer isso, como as excelentes ferramentas ausentes da AWS no GitHub. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/948/2b7/96d/9482b796d437daa84cf7c26dc85aa08f.png"><br><br>  E o que essa ferramenta faz?  Este é um script bash que executa todas as instâncias no balanceador de carga, destruindo-as uma por vez, garantindo a criação de novas em seu lugar. <br>  Se eu perdesse uma das minhas instâncias com a versão 1.0.0 e uma nova aparecesse - 1.1.1, eu gostaria de matar todo o 1.0.0, transferindo tudo para a nova versão.  Porque eu sempre segui em frente.  Deixe-me lembrá-lo de que não gosto quando o servidor de aplicativos permanece por muito tempo. <br><br>  Em um dos projetos, a cada sete dias, eu tinha um script de controle que destruía todas as instâncias da minha conta.  Portanto, o servidor não tinha mais de sete dias.  Outra coisa (a minha favorita) é marcar os servidores como "manchados" usando SSH em uma caixa e destruí-los a cada hora usando um script - não queremos que as pessoas façam isso manualmente. <br><br>  Esses scripts de controle permitem que você sempre tenha a versão mais recente com bugs corrigidos e atualizações de segurança. <br><br>  Você pode usar o script apenas executando: <br><br> <code>aws-ha-relesae.sh -a my-scaling-group <br></code> <br><br>  <code>-a</code> é o seu grupo de dimensionamento automático.  O script passará por todas as instâncias do seu grupo de dimensionamento automático e o substituirá.  Você pode executá-lo não apenas manualmente, mas também a partir da ferramenta CI. <br>  Você pode fazer isso no controle de qualidade ou na produção.  Você pode fazer isso mesmo na sua conta local da AWS.  Você faz o que quiser, sempre usando o mesmo mecanismo. <br><br>  De volta à Amazônia.  Temos uma nova instância: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f4b/1aa/079/f4b1aa079ec971f111abce895d28c771.png"><br><br>  Depois de atualizar a página no navegador, onde vimos a versão 1.0.0, obtemos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff4/923/d78/ff4923d78d16d508c0e8bae753044c15.png"><br><br>  O interessante é que, desde que criamos o script de criação da AMI, podemos testar a criação da AMI. <br><br>  Existem ótimas ferramentas, como ServerScript ou Serverspec. <br><br>  O Serverspec permite criar especificações no estilo Ruby para testar a aparência do servidor de aplicativos.  Por exemplo, abaixo, faço um teste que verifica se o nginx está instalado no servidor. <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'spec_helper'</span></span> describe package(<span class="hljs-string"><span class="hljs-string">'nginx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { should be_installed } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe service(<span class="hljs-string"><span class="hljs-string">'nginx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { sould be_enabled } it { sould be_running } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> describe port(<span class="hljs-number"><span class="hljs-number">80</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it { should be_listening } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  O Nginx deve estar instalado e em execução no servidor e atendendo na porta 80.  Você pode dizer que o usuário X deve estar disponível no servidor.  E você pode colocar todos esses testes no lugar deles.  Portanto, quando você cria uma AMI, a ferramenta de IC pode verificar se essa AMI é adequada para uma determinada finalidade.  Você saberá que a AMI está pronta para produção. <br><br><h3>  Em vez de uma conclusão </h3><br>  Mary Poppendieck é provavelmente uma das mulheres mais incríveis que eu já ouvi falar.  Ao mesmo tempo, ela falou sobre como o desenvolvimento de software lean se desenvolveu ao longo dos anos.  E como ela estava associada à 3M nos anos 60, quando a empresa estava realmente engajada no desenvolvimento enxuto. <br><br>  E ela fez a pergunta: quanto tempo levará para sua organização implantar as alterações associadas a uma linha de código?  Você pode tornar esse processo confiável e repetível? <br><br>  Como regra, essa pergunta sempre dizia respeito ao código do software.  Quanto tempo levarei para corrigir um erro neste aplicativo ao implantar na produção?  Mas não há razão para não podermos usar a mesma pergunta para infraestrutura ou bancos de dados. <br><br>  Eu trabalhei para uma empresa chamada OpenTable.  Nele, chamamos isso de duração do ciclo.  E no OpenTable ela tinha sete semanas.  E isso é relativamente bom.  Conheço empresas que levam meses para enviar um código para produção.  No OpenTable, revisamos o processo por quatro anos.  Isso levou muito tempo, porque a organização é grande - 200 pessoas.  E reduzimos o tempo do ciclo para três minutos.  Isso foi possível graças a medidas do efeito de nossas transformações. <br><br>  Agora tudo está em script.  Temos muitas ferramentas e exemplos, existe o GitHub.  Portanto, pegue idéias de conferências como DevOops, implemente-as em sua organização.  Não tente implementar tudo.  Pegue uma coisinha e venda.  Mostre a alguém.  O impacto de uma pequena mudança pode ser medido, medido e seguir em frente! <br><blockquote>  Paul Stack chegará a São Petersburgo na conferência do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DevOops 2018</a> com um relatório <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Teste de sistema sustentável com o caos"</a> .  Paul falará sobre a metodologia Chaos Engineering e mostrará como usar essa metodologia em projetos reais. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt420661/">https://habr.com/ru/post/pt420661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt420647/index.html">Por que os personagens de videogame quase nunca se despem</a></li>
<li><a href="../pt420651/index.html">Cientistas descobrem evidências de precedentes desagradáveis ​​relacionados à mudança climática</a></li>
<li><a href="../pt420653/index.html">Cinco coisas que você precisa fazer para equipar sua casa em Marte</a></li>
<li><a href="../pt420657/index.html">Análise: de quem dinheiro Elon Musk será capaz de retirar Tesla da bolsa</a></li>
<li><a href="../pt420659/index.html">Campanha USB da HRF (Human Rights Foundation) “Flash Drives for Freedom”</a></li>
<li><a href="../pt420663/index.html">Métricas simples e uma maneira de economizar tempo ao procurar problemas na infraestrutura</a></li>
<li><a href="../pt420665/index.html">Criando um aplicativo no .NET Core e Kubernetes: Nossa experiência</a></li>
<li><a href="../pt420667/index.html">Princípios de operação do protocolo EIGRP</a></li>
<li><a href="../pt420669/index.html">Visão Geral do Mercado de Automação Corporativa: Soluções para Empresas de Construção e Gerenciamento de Habitações e Utilidades</a></li>
<li><a href="../pt420671/index.html">[Ekaterinburg, anúncio] UralJS # 9 - três relatórios sobre microsserviços, testes e registro de erros na frente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>