<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßñ ‚õàÔ∏è üàöÔ∏è Escribimos el proxy Reverse socks5 en powershell. Parte 2 üò± üò© üèÆ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La historia de la investigaci√≥n y el desarrollo en 3 partes. Parte 2 - desarrollo. 
 Hay muchas hayas, incluso m√°s beneficios. 

 En la primera parte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Escribimos el proxy Reverse socks5 en powershell. Parte 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453970/">  La historia de la investigaci√≥n y el desarrollo en 3 partes.  Parte 2 - desarrollo. <br>  Hay muchas hayas, incluso m√°s beneficios. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">En la primera parte del</a> art√≠culo, nos familiarizamos con algunas herramientas para organizar t√∫neles inversos, analizamos sus ventajas y desventajas, estudiamos el mecanismo del multiplexor Yamux y describimos los requisitos b√°sicos para el m√≥dulo PowerShell reci√©n creado.  Es hora de comenzar a desarrollar el m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PowerShell</a> del cliente para la implementaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">preparada del</a> t√∫nel inverso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RSocksTun</a> . <br><br>  En primer lugar, debemos entender en qu√© modo funcionar√° nuestro m√≥dulo.  Obviamente, para la transferencia de datos prima, tendremos que usar el mecanismo de socket de Windows y las capacidades .Net para transmitir lectura-escritura a sockets.  Pero, por otro lado, porque  Dado que nuestro m√≥dulo debe servir varias transmisiones de yamux al mismo tiempo, todas las operaciones de E / S no deber√≠an bloquear completamente la ejecuci√≥n de nuestro programa.  Esto sugiere la conclusi√≥n de que nuestro m√≥dulo debe usar software de subprocesamiento m√∫ltiple y realizar operaciones de lectura y escritura con un servidor yamux, as√≠ como operaciones de lectura y escritura en servidores de destino en diferentes flujos de programas.  Bueno, por supuesto, es necesario proporcionar un mecanismo de interacci√≥n entre nuestros flujos paralelos.  Afortunadamente, powershell ofrece amplias oportunidades para iniciar y administrar flujos de programas. <br><a name="habracut"></a><br><h3>  Algoritmo general de trabajo </h3><br>  Por lo tanto, el algoritmo general de nuestro cliente deber√≠a ser algo como esto: <br><br><ul><li>  establecer una conexi√≥n SSL al servidor; </li><li>  inicie sesi√≥n con una contrase√±a para que el servidor pueda distinguirnos de un oficial de seguridad; </li><li>  espere a que el paquete yamux instale una nueva secuencia, respondiendo peri√≥dicamente a las solicitudes de mantenimiento del servidor; </li><li>  inicie una nueva secuencia del programa socksScript (que no debe confundirse con una secuencia) tan pronto como llegue el paquete yamux para instalar una nueva secuencia.  Dentro de socksScript, implemente el trabajo del servidor socks5; </li><li>  a la llegada del paquete con datos de yamux: comprenda, a partir del encabezado de 12 bytes, a qu√© flujos est√°n destinados los datos, as√≠ como su tama√±o, lea los datos del servidor yamux y transfiera los datos recibidos al flujo con el n√∫mero de flujo correspondiente; </li><li>  supervise peri√≥dicamente la disponibilidad de datos destinados al servidor yamux en cada uno de los scripts de calcetines en ejecuci√≥n.  Si hay tales datos, agregue el encabezado de 12 bytes correspondiente y env√≠elos al servidor yamux; </li><li>  a la llegada de un paquete yamux para cerrar el flujo, transmitir la se√±al al flujo correspondiente para finalizar el flujo y desconectarse, y despu√©s de eso, completar el flujo en s√≠; </li></ul><br>  Entonces, en nuestro cliente es necesario implementar al menos 3 flujos de programa: <br><br><ol><li>  el principal, que establecer√° la conexi√≥n, iniciar√° sesi√≥n en el servidor yamux, recibir√° datos del mismo, procesar√° los encabezados de yamux y enviar√° datos sin procesar a otros flujos de programas; </li><li>  transmisiones con servidores de calcetines.  Puede haber varios, uno para cada transmisi√≥n.  Implementan la funcionalidad socks5.  Estos flujos interactuar√°n con los puntos de destino en la red interna; </li><li>  flujo inverso.  Recibe datos de secuencias de calcetines, les agrega encabezados yamux y los env√≠a al servidor yamux; </li></ol><br>  Y, por supuesto, debemos prever la interacci√≥n entre todos estos flujos. <br><br>  No solo necesitamos proporcionar dicha interacci√≥n, sino tambi√©n obtener la conveniencia de la transmisi√≥n de entrada-salida (de manera similar a los sockets).  El mecanismo m√°s apropiado ser√≠a utilizar tuber√≠as de software.  En Windows, las tuber√≠as se registran cuando cada tuber√≠a tiene su propio nombre y son an√≥nimas: cada tuber√≠a se identifica por su controlador.  En aras del secreto, por supuesto, utilizaremos tuber√≠as an√≥nimas.  (Despu√©s de todo, no queremos que nuestro m√≥dulo se calcule utilizando tuber√≠as registradas en el sistema, ¬øs√≠?).  Por lo tanto, entre los flujos principal / inverso y los flujos de calcetines, la interacci√≥n se realizar√° a trav√©s de tuber√≠as an√≥nimas, que admitir√°n E / S de flujo as√≠ncrono.  Entre los flujos principal y de retorno, la comunicaci√≥n se llevar√° a cabo a trav√©s del mecanismo de objetos compartidos (variables sincronizadas compartidas) (puede leer m√°s sobre qu√© son estas variables y c√≥mo vivir con ellas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ). <br><br>  La informaci√≥n sobre la ejecuci√≥n de secuencias de calcetines debe almacenarse en la estructura de datos correspondiente.  Al crear un hilo de calcetines en esta estructura, debemos escribir: <br><br><ul><li>  n√∫mero de sesi√≥n de yamux: $ ymxstream; </li><li>  4 variables para trabajar con tuber√≠as (canales): $ cipipe, $ copipe, $ sipipe, $ sopipe.  Dado que los canales an√≥nimos funcionan ya sea ENTRADA o SALIDA, para cada secuencia de calcetines necesitamos dos canales an√≥nimos, cada uno de los cuales debe tener dos extremos (canalizaci√≥n) (servidor y cliente); </li><li>  el resultado de la llamada a la transmisi√≥n es $ AsyncJobResult; </li><li>  controlador de flujo - $ Psobj.  A trav√©s de √©l cerraremos el flujo y liberaremos recursos; </li><li>  El resultado de la lectura as√≠ncrona de la tuber√≠a an√≥nima por la secuencia inversa ($ readjob).  Esta variable se usa en la secuencia inversa de yamuxScript para la lectura as√≠ncrona de la tuber√≠a correspondiente; </li><li>  buffer para leer datos para cada flujo de calcetines; </li></ul><br><h3>  Corriente principal </h3><br>  Entonces, desde el punto de vista del procesamiento de datos, el trabajo de nuestro programa se construye de la siguiente manera: <br><br><ul><li>  el lado del servidor (rsockstun - implementado en Golang) levanta el servidor ssl y espera conexiones del cliente; </li><li>  Al recibir una conexi√≥n del cliente, el servidor verifica la contrase√±a y, si es correcta, establece una conexi√≥n yamux, levanta el puerto de los calcetines y espera las conexiones de los clientes de los calcetines (nuestras cadenas proxy, navegador, etc.), intercambiando peri√≥dicamente paquetes keepalive. con nuestro cliente  Si la contrase√±a es incorrecta, se realiza una redirecci√≥n a la p√°gina que especificamos al instalar el servidor (esta es una p√°gina "legal" para el administrador vigilante de seguridad de la informaci√≥n); </li><li>  cuando recibe una conexi√≥n de un cliente de socks, el servidor env√≠a un paquete yamux a nuestro cliente para establecer una nueva transmisi√≥n (YMX SYN); </li></ul><br>  <b>Obtener y analizar un encabezado de Yamux</b> <br><br>  Nuestro m√≥dulo primero establece una conexi√≥n SSL con el servidor e inicia sesi√≥n con una contrase√±a: <br><br><pre><code class="plaintext hljs">$tcpConnection = New-Object System.Net.Sockets.TcpClient($server, $port) $tcpStream = New-Object System.Net.Security.SslStream($tcpConnection.GetStream(),$false,({$True} -as [Net.Security.RemoteCertificateValidationCallback])) $tcpStream.AuthenticateAsClient('127.0.0.1')</code> </pre> <br>  Luego, el script espera un encabezado yamux de 12 bytes y lo analiza. <br>  Hay un peque√±o matiz ... Como muestra la pr√°ctica, simplemente leyendo 12 bytes del socket: <br><br><pre> <code class="plaintext hljs"> $num = $tcpStream.Read($tmpbuffer,0,12)</code> </pre> <br>  no es suficiente, ya que la operaci√≥n de lectura puede completarse despu√©s de la llegada de solo una parte de los bytes necesarios.  Por lo tanto, debemos esperar los 12 bytes en el bucle: <br><br><pre> <code class="plaintext hljs"> do { try { $num = $tcpStream.Read($tmpbuffer,0,12) } catch {} $tnum += $num $ymxbuffer += $tmpbuffer[0..($num-1)] }while ($tnum -lt 12 -and $tcpConnection.Connected)</code> </pre> <br>  Una vez que se completa el ciclo, debemos analizar el encabezado de 12 bytes contenido en la variable $ ymxbuffer para su tipo y establecer banderas de acuerdo con la especificaci√≥n de Yamux. <br><br>  El encabezado de Yamux puede ser de varios tipos: <br><br><ul><li>  ymx syn: instala una nueva transmisi√≥n; </li><li>  aleta ymx: finalizaci√≥n del flujo; </li><li>  datos ymx: representa informaci√≥n sobre los datos (de qu√© tama√±o y para qu√© flujo est√°n destinados); </li><li>  ymx ping: mensaje de respuesta activa; </li><li>  ymx win update: confirmaci√≥n de la transferencia de una parte de los datos; </li></ul><br>  Cualquier cosa que no se ajuste a los tipos enumerados de encabezados yamux se considera una situaci√≥n excepcional.  Hay 10 de esas excepciones, y creemos que algo est√° mal aqu√≠ y estamos completando el trabajo de nuestro m√≥dulo.  <s>(as√≠ como borrar todos nuestros archivos, borrar el disco, cambiar el apellido, hacer un nuevo pasaporte, salir del pa√≠s, etc. de acuerdo con la lista ...)</s> <br><br>  <b>Crear un nuevo hilo de calcetines</b> <br><br>  Habiendo recibido un paquete yamux para establecer una nueva secuencia, nuestro cliente crea dos canales de servidor an√≥nimos ($ sipipe, $ sopipe), para entrada / salida, respectivamente, crea tubos de cliente ($ cipipe, $ copipe) basados ‚Äã‚Äãen ellos: <br><br><pre> <code class="plaintext hljs">$sipipe = new-object System.IO.Pipes.AnonymousPipeServerStream(1) $sopipe = new-object System.IO.Pipes.AnonymousPipeServerStream(2,1) $sipipe_clHandle = $sipipe.GetClientHandleAsString() $sopipe_clHandle = $sopipe.GetClientHandleAsString() $cipipe = new-object System.IO.Pipes.AnonymousPipeClientStream(1,$sopipe_clHandle) $copipe = new-object System.IO.Pipes.AnonymousPipeClientStream(2,$sipipe_clHandle)</code> </pre> <br>  crea un espacio de ejecuci√≥n para la secuencia de calcetines, establece variables compartidas para interactuar con esta secuencia (StopFlag) y ejecuta el bloque de script SocksScript, que implementa la funcionalidad del servidor de calcetines en una secuencia separada: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() $socksrunspace = [runspacefactory]::CreateRunspace() $socksrunspace.Open() $socksrunspace.SessionStateProxy.SetVariable("StopFlag",$StopFlag) $PS.Runspace = $socksrunspace $PS.AddScript($socksScript).AddArgument($state) | Out-Null [System.IAsyncResult]$AsyncJobResult = $null $StopFlag[$ymxstream] = 0 $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  Las variables creadas se escriben en una estructura ArrayList especial, un an√°logo de Dictionary en Python <br><br><pre> <code class="plaintext hljs">[System.Collections.ArrayList]$streams = @{}</code> </pre><br>  La adici√≥n se realiza a trav√©s del m√©todo Agregar incorporado: <br><br><pre> <code class="plaintext hljs">$streams.add(@{ymxId=$ymxstream;cinputStream=$cipipe;sinputStream=$sipipe;coutputStream=$copipe;soutputStream=$sopipe;asyncobj=$AsyncJobResult;psobj=$PS;readjob=$null;readbuffer=$readbuffer}) | out-null</code> </pre> <br>  <b>Procesamiento de datos de Yamux</b> <br><br>  Al recibir los datos destinados a cualquier flujo de calcetines del servidor yamux, debemos determinar el n√∫mero del flujo de yamux (el n√∫mero del flujo de calcetines para el cual est√°n destinados estos datos) y el n√∫mero de bytes de datos del encabezado yamux de 12 bytes: <br><br><pre> <code class="plaintext hljs">$ymxstream = [bitconverter]::ToInt32($buffer[7..4],0) $ymxcount = [bitconverter]::ToInt32($buffer[11..8],0)</code> </pre> <br>  Luego, desde la secuencia ArrayList, usando el campo ymxId, obtenemos los controladores de la salida del servidor correspondiente a esta secuencia de calcetines: <br><br><pre> <code class="plaintext hljs"> if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} $outStream = $streams[$streamind].soutputStream</code> </pre> <br>  Despu√©s de eso, leemos los datos del socket, recordando que necesitamos leer una cierta cantidad de bytes a trav√©s del bucle: <br><br><pre> <code class="plaintext hljs"> $databuffer = $null $tnum = 0 do { if ($buffer.length -le ($ymxcount-$tnum)) { $num = $tcpStream.Read($buffer,0,$buffer.Length) }else { $num = $tcpStream.Read($buffer,0,($ymxcount-$tnum)) } $tnum += $num $databuffer += $buffer[0..($num-1)] }while ($tnum -lt $ymxcount -and $tcpConnection.Connected)</code> </pre> <br>  y escriba los datos recibidos en la tuber√≠a correspondiente: <br><br><pre> <code class="plaintext hljs">$num = $tcpStream.Read($buffer,0,$ymxcount) $outStream.Write($buffer,0,$ymxcount)</code> </pre> <br><br>  <b>Procesamiento FIN de Yamux - Finalizar flujo</b> <br><br>  Cuando recibimos un paquete del servidor yamix que se√±ala el cierre de una secuencia, tambi√©n obtenemos primero el n√∫mero de la secuencia yamux del encabezado de 12 bytes: <br><br><pre> <code class="plaintext hljs"> $ymxstream = [bitconverter]::ToInt32($buffer[7..4],0)</code> </pre> <br>  luego, a trav√©s de una variable compartida (o m√°s bien, una matriz de indicadores, donde el √≠ndice es el n√∫mero de flujo de yamux), le indicamos al hilo de calcetines que complete: <br><br><pre> <code class="plaintext hljs">if ($streams.Count -gt 1){$streamind = $streams.ymxId.IndexOf($ymxstream)} else {$streamind = 0} if ($StopFlag[$ymxstream] -eq 0){ write-host "stopflag is 0. Setting to 1" $StopFlag[$ymxstream] = 1 }</code> </pre> <br>  despu√©s de configurar la bandera, antes de eliminar la secuencia de calcetines, debe esperar una cierta cantidad de tiempo para que la secuencia de calcetines procese esta bandera.  200 ms es suficiente para esto: <br><br><pre> <code class="plaintext hljs">start-sleep -milliseconds 200 #wait for thread check flag</code> </pre><br>  luego cierre todas las tuber√≠as relacionadas con esta secuencia, cierre el Runspace correspondiente y elimine el objeto Powershell para liberar recursos: <br><br><pre> <code class="plaintext hljs">$streams[$streamind].cinputStream.close() $streams[$streamind].coutputStream.close() $streams[$streamind].sinputStream.close() $streams[$streamind].soutputStream.close() $streams[$streamind].psobj.Runspace.close() $streams[$streamind].psobj.Dispose() $streams[$streamind].readbuffer.clear()</code> </pre> <br>  Despu√©s de cerrar la secuencia de calcetines, debemos eliminar el elemento correspondiente de las secuencias de ArrayList: <br><br><pre> <code class="plaintext hljs">$streams.RemoveAt($streamind)</code> </pre> <br>  Y al final, necesitamos forzar al recolector de basura .Net a liberar los recursos utilizados por el hilo.  De lo contrario, nuestro script consumir√° aproximadamente 100-200 MB de memoria, lo que puede llamar la atenci√≥n de un usuario experimentado y corrosivo, pero no necesitamos esto: <br><br><pre> <code class="plaintext hljs">[System.GC]::Collect()#clear garbage to minimize memory usage</code> </pre> <br><h3>  Script Yamux - flujo inverso </h3><br>  Como se mencion√≥ anteriormente, los datos recibidos de las secuencias de calcetines son procesados ‚Äã‚Äãpor una secuencia separada de yamuxScript, que comienza desde el principio (despu√©s de una conexi√≥n exitosa al servidor).  Su tarea es sondear peri√≥dicamente las tuber√≠as de salida de los flujos de calcetines ubicados en ArrayList $ streams: <br><pre> <code class="plaintext hljs">foreach ($stream in $state.streams){ ... }</code> </pre> <br>  y si hay datos en ellos, env√≠elos al servidor yamux, despu√©s de proporcionar el encabezado yamux de 12 bytes correspondiente con el n√∫mero de la sesi√≥n yamux y el n√∫mero de bytes de datos: <br><br><pre> <code class="plaintext hljs"> if ($stream.readjob -eq $null){ $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }elseif ( $stream.readjob.IsCompleted ){ #if read asyncjob completed - generate yamux header $outbuf = [byte[]](0x00,0x00,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [bitconverter]::getbytes([int32]$stream.readjob.Result)[3..0] $state.tcpstream.Write($outbuf,0,12) #write raw data from socks thread to yamux $state.tcpstream.Write($stream.readbuffer,0,$stream.readjob.Result) $state.tcpstream.flush() #create new readasync job $stream.readjob = $stream.sinputStream.ReadAsync($stream.readbuffer,0,1024) }else{ #write-host "Not readed" }</code> </pre> <br>  YamuxScript tambi√©n supervisa el conjunto de indicadores en la matriz compartida $ StopFlag para cada uno de los hilos de socksScript que se ejecutan.  Este indicador se puede establecer en 2 si el servidor remoto que socksScript funciona con desconexiones.  En esta situaci√≥n, la informaci√≥n debe informarse al cliente de calcetines.  La cadena es la siguiente: yamuxScript debe informar al servidor yamux acerca de la desconexi√≥n para que a su vez se lo indique al cliente de calcetines. <br><br><pre> <code class="plaintext hljs">if ($StopFlag[$stream.ymxId] -eq 2){ $stream.ymxId | out-file -Append c:\work\log.txt $outbuf = [byte[]](0x00,0x01,0x00,0x04)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ [byte[]](0x00,0x00,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $state.tcpstream.flush() }</code> </pre> <br><h3>  Actualizaci√≥n de la ventana de Yamux </h3><br>  Adem√°s, yamuxScript debe monitorear la cantidad de bytes recibidos del servidor yamux y enviar peri√≥dicamente un mensaje YMX WinUpdate.  Este mecanismo en Yamux es responsable de monitorear y cambiar el llamado tama√±o de ventana (similar al protocolo TCP): la cantidad de bytes de datos que se pueden enviar sin acuse de recibo.  Por defecto, el tama√±o de la ventana es de 256 Kbytes.  Esto significa que al enviar o recibir archivos o datos de un tama√±o superior a este, debemos enviar el paquete de actualizaci√≥n windpw al servidor yamux.  Para controlar la cantidad de datos recibidos del servidor yamux, se ha introducido una matriz compartida especial $ RcvBytes, en la cual la secuencia principal al incrementar el valor actual registra el n√∫mero de bytes recibidos del servidor para cada secuencia.  Si se supera el umbral establecido, yamuxScript deber√≠a enviar un paquete al servidor WinUpdate y restablecer el contador: <br><br><pre> <code class="plaintext hljs"> if ($RcvBytes[$stream.ymxId] -ge 256144){ #out win update ymx packet with 256K size $outbuf = [byte[]](0x00,0x01,0x00,0x00)+ [bitconverter]::getbytes([int32]$stream.ymxId)[3..0]+ (0x00,0x04,0x00,0x00) $state.tcpstream.Write($outbuf,0,12) $RcvBytes[$stream.ymxId] = 0 }</code> </pre> <br><h3>  SocksScript Streams </h3><br>  Ahora pasemos directamente a socksScript. <br>  Recuerde que socksScript se invoca de forma as√≠ncrona: <br><br><pre> <code class="plaintext hljs">$state = [PSCustomObject]@{"StreamID"=$ymxstream;"inputStream"=$cipipe;"outputStream"=$copipe} $PS = [PowerShell]::Create() .... $AsyncJobResult = $PS.BeginInvoke()</code> </pre> <br>  y en el momento de la llamada, los siguientes datos est√°n presentes en la variable $ state transferida a la secuencia: <br><br><ul><li>  $ state.streamId: n√∫mero de sesi√≥n de yamux; </li><li>  $ state.inputStream - leer canalizaci√≥n; </li><li>  $ state.oututStream - tuber√≠a de escritura; </li></ul><br>  Los datos en las tuber√≠as vienen en forma cruda sin encabezados yamux, es decir  en la forma en que provienen del cliente de calcetines. <br><br>  Dentro de socksScript, antes que nada, necesitamos determinar la versi√≥n de los calcetines y asegurarnos de que sea 5: <br><br><pre> <code class="plaintext hljs">$state.inputStream.Read($buffer,0,2) | Out-Null $socksVer=$buffer[0] if ($socksVer -eq 5){ ... }</code> </pre> <br>  Bueno, entonces hacemos exactamente lo implementado en el script Invoke-SocksProxy.  La √∫nica diferencia ser√° que en lugar de llamadas <br><br><pre> <code class="plaintext hljs">$AsyncJobResult.AsyncWaitHandle.WaitOne(); $AsyncJobResult2.AsyncWaitHandle.WaitOne();</code> </pre> <br>  Es necesario monitorear la conexi√≥n tcp y el indicador de terminaci√≥n correspondiente en la matriz $ StopFlag en un modo c√≠clico, de lo contrario no podremos reconocer la situaci√≥n del final de la conexi√≥n desde el lado del cliente de socks y el servidor ymux: <br><br><pre> <code class="plaintext hljs">while ($StopFlag[$state.StreamID] -eq 0 -and $tmpServ.Connected ){ start-sleep -Milliseconds 50 }</code> </pre> <br>  En caso de que la conexi√≥n termine en el lado tcp del servidor al que nos estamos conectando, establecemos este indicador en 2, lo que obligar√° a yamuxscript a reconocer esto y enviar√° el paquete FIN ymx correspondiente al servidor yamux: <br><br><pre> <code class="plaintext hljs">if ($tmpServ.Connected){ $tmpServ.close() }else{ $StopFlag[$state.StreamID] = 2 }</code> </pre> <br>  Tambi√©n debemos establecer este indicador si socksScript no puede conectarse al servidor de destino: <br><br><pre> <code class="plaintext hljs">if($tmpServ.Connected){ ... } else{ $buffer[1]=4 $state.outputStream.Write($buffer,0,2) $StopFlag[$state.StreamID] = 2 }</code> </pre> <br><h3>  Conclusi√≥n de la segunda parte. </h3><br>  En el curso de nuestra investigaci√≥n de codificaci√≥n, logramos crear un cliente powershell para nuestro servidor RsocksTun con la capacidad de: <br><br><ul><li>  Conexiones SSL </li><li>  autorizaci√≥n en el servidor; </li><li>  trabajar con yamux-server con soporte para pings keepalive; </li><li>  modo de operaci√≥n multihilo; </li><li>  soporte para transferir archivos grandes; </li></ul><br>  Fuera del art√≠culo, hubo una implementaci√≥n de la funcionalidad de conectarse a trav√©s de un servidor proxy y autorizar en √©l, as√≠ como convertir nuestro script en una versi√≥n en l√≠nea, que se puede ejecutar desde la l√≠nea de comandos.  Ser√° en la tercera parte. <br><br>  Eso es todo por hoy.  Como dicen: suscr√≠bete, dale me gusta, deja comentarios (especialmente con respecto a tus pensamientos sobre c√≥mo mejorar el c√≥digo y agregar funcionalidad). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/453970/">https://habr.com/ru/post/453970/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453958/index.html">Monorepositorios: por favor</a></li>
<li><a href="../453960/index.html">Global DevOps Bootcamp 2019 en Mosc√∫</a></li>
<li><a href="../453962/index.html">RxSwift y Coroutines en Kotlin: desarrollo m√≥vil opcional de AGIMA y GeekBrains</a></li>
<li><a href="../453964/index.html">OOP en el lenguaje R (parte 1): clases S3</a></li>
<li><a href="../453968/index.html">Desaprender pr√°cticas de revisi√≥n de c√≥digos t√≥xicos</a></li>
<li><a href="../453972/index.html">Los arque√≥logos recrean un pin de dos mil a√±os de antig√ºedad mediante impresi√≥n y escaneo 3D</a></li>
<li><a href="../453974/index.html">Competencia de sistemas ML en material ling√º√≠stico. ¬øC√≥mo aprendimos a llenar los espacios en blanco?</a></li>
<li><a href="../453976/index.html">Programa educativo econ√≥mico para especialistas en TI.</a></li>
<li><a href="../453978/index.html">La impresora 3D de construcci√≥n MIT imprime un edificio en 14 horas</a></li>
<li><a href="../453980/index.html">Impresi√≥n de etiquetas y etiquetas de precios para la tienda en l√≠nea .net</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>