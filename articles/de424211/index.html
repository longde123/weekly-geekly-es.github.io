<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏾 📍 👷🏻 Grundlegendes zur Container-Speicherschnittstelle (in Kubernetes und mehr) 👨🏾‍🎓 💷 💣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Wir haben in unserem Test von K8s 1.9 zum ersten Mal über die sogenannten Kubernetes-Speicher-Plug-Ins (Out-of-Tree-CSI-Volume-Plugin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zur Container-Speicherschnittstelle (in Kubernetes und mehr)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/424211/">  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Wir haben in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Test von K8s 1.9 zum</a> ersten Mal über die sogenannten Kubernetes-Speicher-Plug-Ins (Out-of-Tree-CSI-Volume-Plugins) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gesprochen</a> , bei denen diese Funktion im Alpha-Versionsstatus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">angezeigt wurde</a> .</i>  <i>Der Autor des neuen Materials, Anoop Vijayan Maniankara (führender DevOps-Ingenieur des finnischen Unternehmens Tuxera), sammelte wichtige Informationen über die Ideen und das CSI-Gerät, um sich schnell mit dem neuen Konzept vertraut zu machen, das laut einigen unserer Mitarbeiter „das nächste große Ding sein wird“.</i>  <i>Für eine detailliertere und technischere Untersuchung von CSI finden Sie am Ende des Artikels nützliche Links, unter denen ich besonders die Präsentation eines der Autoren dieser Spezifikation (Jie Yu) hervorhole.</i>  <i>Aber es lohnt sich trotzdem, mit dem "großen Bild" zu beginnen ...</i> <br><br><img src="https://habrastorage.org/webt/in/tw/ua/intwuao7mjmtewxrj4yjbg0cnme.png"><br><br>  Container Storage Interface (CSI) ist eine Initiative zur Vereinheitlichung der Schnittstelle von Speichern wie Ceph, Portworx, NetApp usw. in Container-Orchestrierungssystemen: Kubernetes, Mesos, Docker Swarm, Cloud Foundry und anderen.  Die Idee ist, dass die Implementierung eines CSI durch den Speicherhersteller garantiert mit all diesen Systemen funktioniert. <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/hz/gh/bs/hzghbsblihkymsvfqjgkbmeguyu.png"><br>  <i>Bildquelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jie Yu CSI-Bericht auf der CloudNativeCon EU 2018</a></i> <br><br>  <i><b>Bitte beachten Sie</b> : In diesem Artikel wird nur die dynamische Bereitstellung behandelt.</i>  <i>Vorkonfigurierte Volumes und Flex-Volumes gehen über den Rahmen hinaus.</i>  <i>Wenn Sie besser verstehen möchten, was besprochen wird, sollten Sie zuerst die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes-Dokumentation</a> lesen.</i>  <i>Darüber hinaus wird der Artikel nicht näher auf die Details der CSI-Implementierung eingehen.</i>  <i>Ich werde einen allgemeinen Überblick über CSI geben und den Grundstein für die Erstellung eines CSI-Volumes legen.</i>  <i>Schließlich werden Kubernetes-Informationen für Beispiele und Links zu Details verwendet.</i> <br><br>  Bevor Sie sich mit dem Thema befassen, ist es auch wichtig zu wissen, welche Beiwagencontainer sich in Kubernetes befinden.  Sie erweitern die Funktionen des Hauptcontainers ( <i>main</i> ), der im selben Herd vorhanden ist und Speicher und Netzwerk gemeinsam nutzt. <br><br>  Zum Zeitpunkt dieses Schreibens <i>(13. August 2018) hatten</i> CSI-Komponenten die folgenden Versionen: <br><br><img src="https://habrastorage.org/webt/-d/sg/i6/-dsgi60pz3eeaaeylowln9tafj0.png"><br><br><h2>  Vor CSI </h2><br>  Die erste Veröffentlichung von CSI - v0.1 - fand im Dezember 2017 statt.  Natürlich könnte die Bereitstellung für externen Speicher in Orchestrierungssystemen bereits vor dem Erscheinen erfolgen.  Im Fall von Kubernetes waren Volume-Plugins - Volume-Plugins für den Speicherbedarf verantwortlich: <br><br><img src="https://habrastorage.org/webt/ke/0b/2u/ke0b2usxs3hpmvt7x6xai53aq54.png"><br><br>  Wie Sie aus dem obigen Bild sehen können, sind solche Plugins Teil des Kerns des Orchestrierungssystems.  Aus diesem Grund sind die folgenden Probleme aufgetreten, die im <a href="">CSI-Architekturdokument erwähnt wurden</a> : <br><br><ul><li>  Die Entwicklung des Volume-Plugins ist eng mit Kubernetes-Releases verbunden und von diesen abhängig. </li><li>  Die Entwickler / Community von Kubernetes sind dafür verantwortlich, alle Plugins zu testen und zu unterstützen, anstatt nur eine stabile Plugin-API zu testen und zu warten. </li><li>  Fehler in Volume-Plugins können nicht nur das Plugin selbst, sondern auch kritische Kubernetes-Komponenten löschen. </li><li>  Plugins erhalten die vollen Berechtigungen für Kubernetes-Komponenten (kubelet und kube-controller-manager); </li><li>  Plugin-Entwickler müssen den Quellcode des Plugins veröffentlichen und können den Pfad der Binärdateien nicht auswählen. </li></ul><br><h2>  CSI verstehen </h2><br>  Mit der Einführung von CSI veröffentlichte das Kubernetes-Team externe Komponenten, die nicht Teil des Kernels sind und für die Interaktion mit anderen externen Komponenten der Hersteller ausgelegt sind.  Sie kommunizieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">miteinander</a> über Domain-Sockets <i>(UNIX-Domain-Sockets - ca. Transl.)</i> Mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gRPC</a> . <br><br><img src="https://habrastorage.org/webt/ex/pa/rb/exparbyd1gvf_mcprwn3vmrp4di.png"><br><br><h3>  Externe Komponenten von Kubernetes </h3><br>  Sie werden vom Kubernetes-Team vollständig implementiert und unterstützt und erweitern die Aktivitäten von Kubernetes außerhalb von Kubernetes.  Hersteller können sich überhaupt keine Gedanken über die Merkmale ihrer Implementierung machen.  Bestehend aus drei Teilen: <br><br><ul><li>  <i>Der</i> Treiberregistrar ist ein Sidecar-Container, der den CSI-Treiber in Kubelet registriert und den <code>NodeId</code> Treiber zur <code>NodeId</code> in der Kubernetes-API hinzufügt.  Zu diesem <code>GetNodeId</code> interagiert es mit dem <i>Identity</i> CSI-Treiberdienst <i>(weitere Details siehe unten - ca. Übersetzung)</i> und ruft <code>GetNodeId</code> über CSI auf. </li><li>  <i>Externer Provisioner</i> - ein Sidecar-Container, der <i>PersistentVolumeClaim-</i> Objekte in der Kubernetes-API <code>CreateVolume</code> und <code>DeleteVolume</code> <code>CreateVolume</code> und <code>DeleteVolume</code> für den Endpunkttreiber <code>DeleteVolume</code> . </li><li>  <i>Externer Anhang</i> ist ein Sidecar-Container, der <i>VolumeAttachment-</i> Objekte in der Kubernetes-API überwacht und die Befehle <code>ControllerPublish</code> und <code>ControllerUnpublish</code> für den Endpunkttreiber aufruft. </li></ul><br><h3>  Externe Komponente vom Speicherhersteller / Dritten </h3><br>  Herstellerspezifische Implementierung.  Jeder Hersteller implementiert die erforderlichen APIs als Teil der Funktionen des gRPC-Dienstes.  Zum Beispiel eine Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GCE PD</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ceph</a> usw.  Sie bestehen auch aus drei Komponenten: <br><br><ul><li>  <i>CSI-Identität</i> - hauptsächlich zur Identifizierung eines Plugins: Stellen Sie sicher, dass es funktioniert, und geben Sie grundlegende Informationen zum Plugin zurück. <br><br><pre> <code class="plaintext hljs">service Identity { //      rpc GetPluginInfo(GetPluginInfoRequest) returns (GetPluginInfoResponse) {} // ,       Controller rpc GetPluginCapabilities(GetPluginCapabilitiesRequest) returns (GetPluginCapabilitiesResponse) {} //   ,  ,    rpc Probe (ProbeRequest) returns (ProbeResponse) {} }</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubernetes-csi-identity.proto</a> )</i> </li><li>  <i>CSI Controller</i> ist für die Steuerung und Verwaltung von Volumes verantwortlich: Erstellen, Löschen, Anhängen / Trennen, Snapshots usw.; <br><br><pre> <code class="plaintext hljs">service Controller { //  provisioning  rpc CreateVolume (CreateVolumeRequest) returns (CreateVolumeResponse) {} //     rpc DeleteVolume (DeleteVolumeRequest) returns (DeleteVolumeResponse) {} //       rpc ControllerPublishVolume (ControllerPublishVolumeRequest) returns (ControllerPublishVolumeResponse) {} //       rpc ControllerUnpublishVolume (ControllerUnpublishVolumeRequest) returns (ControllerUnpublishVolumeResponse) {} // ,     /    rpc ValidateVolumeCapabilities (ValidateVolumeCapabilitiesRequest) returns (ValidateVolumeCapabilitiesResponse) {} //     rpc ListVolumes (ListVolumesRequest) returns (ListVolumesResponse) {} //       rpc GetCapacity (GetCapacityRequest) returns (GetCapacityResponse) {} // ,      GetCapacity  Snapshotting rpc ControllerGetCapabilities (ControllerGetCapabilitiesRequest) returns (ControllerGetCapabilitiesResponse) {} //   rpc CreateSnapshot (CreateSnapshotRequest) returns (CreateSnapshotResponse) {} //   rpc DeleteSnapshot (DeleteSnapshotRequest) returns (DeleteSnapshotResponse) {} //    rpc ListSnapshots (ListSnapshotsRequest) returns (ListSnapshotsResponse) {} }</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubernetes-csi-controller.proto</a> )</i> </li><li>  <i>Der CSI-Knoten</i> ist für die Überwachung der Volume-Aktivität auf dem Kubernetes-Host verantwortlich. <br><br><pre> <code class="plaintext hljs">service Node { //     staging- rpc NodeStageVolume (NodeStageVolumeRequest) returns (NodeStageVolumeResponse) {} //    staging- rpc NodeUnstageVolume (NodeUnstageVolumeRequest) returns (NodeUnstageVolumeResponse) {} //    staging    rpc NodePublishVolume (NodePublishVolumeRequest) returns (NodePublishVolumeResponse) {} //      rpc NodeUnpublishVolume (NodeUnpublishVolumeRequest) returns (NodeUnpublishVolumeResponse) {} //    rpc NodeGetVolumeStats (NodeGetVolumeStatsRequest) returns (NodeGetVolumeStatsResponse) {} //   ID  rpc NodeGetId (NodeGetIdRequest) returns (NodeGetIdResponse) { option deprecated = true; } //   (capabilities)  rpc NodeGetCapabilities (NodeGetCapabilitiesRequest) returns (NodeGetCapabilitiesResponse) {} //   NodeGetId rpc NodeGetInfo (NodeGetInfoRequest) returns (NodeGetInfoResponse) {} }</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kubernetes-csi-node.proto</a> )</i> </li></ul><br><h2>  Fazit </h2><br>  Das Aufkommen von CSI brachte Orchestrierungssystemen und Speicherherstellern ein offensichtliches Plus.  Darüber hinaus unterstützen gut definierte Schnittstellen die einfache Implementierung und das Testen von CSI sowohl für Entwickler als auch für zukünftige Orchestrierungssysteme.  Wenn Sie nach dem Lesen dieses Artikels mit der Implementierung Ihrer CSI beginnen möchten, ist Fatih Arslans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSI-Plugin (Container Storage Interface) ein</a> guter Ausgangspunkt. <br><br><h2>  Referenzen </h2><br><ol><li>  <a href="">CSI-Spezifikation</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beiwagencontainer bei Kubernetes</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jie Yu CSI-Bericht</a> zur KubeCon EU: CloudNativeCon EU 2018 <i>(und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ist das Video von dieser Präsentation - ca. übersetzt)</i> ; </li><li>  <a href="">CSI-Architekturdokument</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aktuelle Dokumentation zu CSI von Kubernetes</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veraltete Kubernetes CSI-Dokumentation</a> . </li></ol><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Alpha-Version von Snapshot-Volumes in Kubernetes kennenlernen</a> “; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kubernetes 1.9: Ein Überblick über wichtige Innovationen</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC bei Kubernetes verstehen</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was passiert in Kubernetes, wenn der Kubectl-Lauf startet?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie funktioniert der Kubernetes-Scheduler tatsächlich?"</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinter den Kulissen des Netzwerks bei Kubernetes</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rook ist ein Self-Service-Data-Warehouse für Kubernetes</a> “. </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> " <i>(Videobericht, der eine Einführung in das technische Gerät von Kubernetes enthält)</i> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de424211/">https://habr.com/ru/post/de424211/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de424201/index.html">Wie maschinelles Lernen mir geholfen hat, einige Aspekte der frühkindlichen Entwicklung zu verstehen</a></li>
<li><a href="../de424203/index.html">Prozedurale Gebäudeerstellung</a></li>
<li><a href="../de424205/index.html">A1: 2017 - Injektionen (Teil 2)</a></li>
<li><a href="../de424207/index.html">Lesen mit einem Bleistift in der Hand</a></li>
<li><a href="../de424209/index.html">Wireless Grace: Snom A170 Headset Bewertung</a></li>
<li><a href="../de424215/index.html">Ulme. Bequem und umständlich</a></li>
<li><a href="../de424217/index.html">Begründung für heilige Kriege sowie ein Plädoyer für Frieden</a></li>
<li><a href="../de424223/index.html">Einwegkunden. Segmentierung für Wiederholungskäufe</a></li>
<li><a href="../de424227/index.html">Verteilen Sie die Punkte in Pytorch und Tensorflow gleichmäßig über die Kugel</a></li>
<li><a href="../de424229/index.html">Kubernetes in der Produktion: Dienstleistungen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>