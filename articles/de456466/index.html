<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏿 👆🏻 👵🏻 PHP-Generika heute (na ja, fast) 📷 🙍🏽 🔖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wenn Sie PHP-Entwickler fragen, welche Möglichkeiten sie in PHP sehen möchten, nennen die meisten Generika. 


 Generische Unterstützung auf Sprachebe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHP-Generika heute (na ja, fast)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456466/"><p>  Wenn Sie PHP-Entwickler fragen, welche Möglichkeiten sie in PHP sehen möchten, nennen die meisten Generika. </p><br><p>  Generische Unterstützung auf Sprachebene wäre die beste Lösung.  Aber sie zu realisieren ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">schwierig</a> .  Wir hoffen, dass eines Tages die Unterstützung der Muttersprachler Teil der Sprache wird, aber das Warten wird wahrscheinlich mehrere Jahre dauern. </p><br><p>  Dieser Artikel zeigt, wie wir mit vorhandenen Tools, in einigen Fällen mit minimalen Änderungen, die Leistungsfähigkeit von Generika in PHP sofort nutzen können. </p><a name="habracut"></a><br><blockquote>  Von einem Übersetzer: Ich verwende bewusst Transparentpapier aus den englischen "Generika", weil  Ich habe in der Kommunikation noch nie gehört, dass jemand es "generalisierte Programmierung" nannte. </blockquote><br><h2 id="soderzhanie">  Inhalt: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was sind Generika?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie Generika ohne Sprachunterstützung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Werkzeugunterstützung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code-Unterstützung von Drittanbietern</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weitere Schritte</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einschränkungen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum fügen Sie der Zunge nicht einfach Generika hinzu?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist, wenn ich keine Generika benötige?</a> </li></ul><br><h2 id="anchorwhat-are-genericsanchorchto-takoe-dzheneriki"><a name="what-are-generics"></a>  Was sind Generika? </h2><br><p>  Dieser Abschnitt enthält eine kurze Einführung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Generika</a> . </p><br><p>  Links lesen: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">RFC</a> zum Hinzufügen von PHP-Generika </li><li>  Generische Unterstützung in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Phan</a> </li><li>  Psalm Generika und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Vorlagen</a> </li></ul><br><h3 id="prosteyshiy-primer">  Einfachstes Beispiel </h3><br><p>  Da es derzeit nicht möglich ist, Generika auf Sprachebene zu definieren, müssen wir eine weitere großartige Gelegenheit nutzen - sie in den Dockblöcken zu definieren. </p><br><p>  Wir verwenden diese Option bereits in vielen Projekten.  Schauen Sie sich dieses Beispiel an: </p><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> string[] $names * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(iterable $names)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Im obigen Code tun wir, was auf Sprachebene möglich ist.  Wir haben den Parameter <code>$names</code> als etwas definiert, das aufgelistet werden könnte.  Wir haben auch angegeben, dass die Funktion ein Array zurückgibt.  PHP <code>TypeError</code> einen <code>TypeError</code> wenn die Parametertypen und der Rückgabewert nicht übereinstimmen. </p><br><p>  Docblock verbessert das Verständnis des Codes.  <code>$names</code> müssen Zeichenfolgen sein und die Funktion muss ein Array von <code>User</code> .  PHP selbst führt solche Überprüfungen nicht durch.  IDEs wie PhpStorm verstehen diese Notation und warnen den Entwickler, dass der zusätzliche Vertrag nicht eingehalten wurde.  Darüber hinaus können statische Analysewerkzeuge wie Psalm, PHPStan und Phan die Richtigkeit der von und zu der Funktion übertragenen Daten überprüfen. </p><br><h3 id="dzheneriki-dlya-opredeleniya-klyuchey-i-znacheniy-perechislyaemyh-tipov">  Generika zum Bestimmen von Schlüsseln und Werten von Aufzählungstypen </h3><br><p>  Oben ist das einfachste Beispiel eines Generikums.  Komplexere Methoden umfassen die Möglichkeit, den Typ der Schlüssel sowie den Wertetyp anzugeben.  Nachfolgend finden Sie eine Möglichkeit, dies zu beschreiben: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Hier heißt es, dass das von <code>getUsers</code> Array Zeichenfolgenschlüssel und Werte vom Typ <code>User</code> . </p><br><p>  Statische Analysegeräte wie Psalm, PHPStan und Phan verstehen diese Anmerkung und berücksichtigen sie bei der Überprüfung. </p><br><p>  Betrachten Sie den folgenden Code: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showAge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(int $age)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(getUsers() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $user) { showAge($name); }</code> </pre> <br><p>  Statische Analysatoren geben <code>showAge</code> Aufruf <code>Argument 1 of showAge expects int, string provided</code> eine Warnung mit folgendem Fehler aus: <code>Argument 1 of showAge expects int, string provided</code> . </p><br><p>  Leider weiß PhpStorm zum Zeitpunkt des Schreibens nicht, wie. </p><br><h3 id="bolee-slozhnye-dzheneriki">  Anspruchsvollere Generika </h3><br><p>  Wir beschäftigen uns weiterhin mit dem Thema Generika.  Stellen Sie sich ein Objekt vor, das ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Stapel ist</a> : </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br><p>  Der Stapel kann jeden Objekttyp akzeptieren.  Was aber, wenn wir den Stapel nur auf Objekte vom Typ <code>User</code> beschränken möchten? </p><br><p>  Psalm und Phan unterstützen die folgenden Anmerkungen: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> T $item */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Der docblock wird verwendet, um zusätzliche Typinformationen zu übermitteln, zum Beispiel: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Stack&lt;User&gt; $userStack */</span></span> $stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack(); Means that $userStack must only contain Users.</code> </pre> <br><p>  Psalm bei der Analyse des folgenden Codes: </p><br><pre> <code class="php hljs">$userStack-&gt;push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User()); $userStack-&gt;push(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>);</code> </pre> <br><p>  Beschwert sich über Zeile 2 mit dem Fehler <code>Argument 1 of Stack::push expects User, string(hello) provided.</code> </p><br><p>  PhpStorm unterstützt diese Anmerkung derzeit nicht. </p><br><p>  Tatsächlich haben wir nur einen Teil der Informationen über Generika behandelt, aber im Moment ist dies genug. </p><br><h2 id="anchorhow-to-implement-generics-without-language-level-supportanchorkak-vnedrit-dzheneriki-bez-podderzhki-yazyka"><a name="how-to-implement-generics-without-language-level-support"></a>  So implementieren Sie Generika ohne Sprachunterstützung </h2><br><p>  Sie müssen die folgenden Schritte ausführen: </p><br><ul><li>  Definieren Sie auf Community-Ebene generische Standards in Dockblöcken (z. B. neue PSR oder kehren Sie zu PSR-5 zurück). </li><li>  Fügen Sie Ihrem Code Dockblock-Anmerkungen hinzu </li><li>  Verwenden Sie IDEs, die diese Konventionen verstehen, um statische Echtzeitanalysen durchzuführen und Inkonsistenzen zu ermitteln. </li><li>  Verwenden Sie statische Analysewerkzeuge (z. B. Psalm) als einen der CI-Schritte, um Fehler zu erkennen. </li><li>  Definieren Sie eine Methode zum Übergeben von Typinformationen an Bibliotheken von Drittanbietern. </li></ul><br><h2 id="anchoragreeing-on-a-standardanchorstandartizaciya"><a name="agreeing-on-a-standard"></a>  Standardisierung </h2><br><p>  Im Moment hat die PHP-Community dieses generische Format inoffiziell übernommen (sie werden von den meisten Tools unterstützt und ihre Bedeutung ist den meisten klar): </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Wir haben jedoch Probleme mit einfachen Beispielen wie diesem: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Psalm versteht es und weiß, welchen Typ der Schlüssel hat und welche Werte das zurückgegebene Array hat. </p><br><p>  Zum Zeitpunkt des Schreibens versteht PhpStorm dies nicht.  Mit diesem Eintrag vermisse ich die Leistungsfähigkeit der statischen Echtzeitanalyse von PhpStorm. </p><br><p>  Betrachten Sie den folgenden Code.  PhpStorm versteht nicht, dass <code>$user</code> vom Typ <code>User</code> und <code>$name</code> vom Typ string ist: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(getUsers() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $name =&gt; $user) { ... }</code> </pre> <br><p>  Wenn ich Psalm als statisches Analysewerkzeug wählen würde, könnte ich Folgendes schreiben: </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> User[] * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@psalm</span></span></span><span class="hljs-comment">-return array&lt;string, User&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUsers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">array</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre> <br><p>  Psalm versteht das alles. </p><br><p>  PhpStorm weiß, dass die Variable <code>$user</code> vom Typ <code>User</code> .  Er versteht jedoch immer noch nicht, dass sich der Array-Schlüssel auf eine Zeichenfolge bezieht.  Phan und PHPStan verstehen die spezifischen Psalmanmerkungen nicht.  Das Maximum, das sie in diesem Code verstehen, ist das gleiche wie in PhpStorm: der Typ von <code>$user</code> </p><br><p>  Sie könnten argumentieren, dass PhpStorm nur das Übereinstimmungsarray <code>array&lt;keyType, valueType&gt;</code> akzeptieren sollte.  Ich stimme dir nicht zu, weil  Ich glaube, dass dieses Diktat von Standards die Aufgabe der Sprache und der Gemeinschaft ist und die Werkzeuge nur diesen folgen sollten. </p><br><p>  Ich gehe davon aus, dass die oben beschriebene Vereinbarung von den meisten PHP-Mitgliedern sehr positiv aufgenommen wird.  Eine, die sich für Generika interessiert.  Bei Mustern wird es jedoch viel komplizierter.  Weder PHPStan noch PhpStorm unterstützen derzeit Vorlagen.  Im Gegensatz zu Psalm und Phan.  Ihr Zweck ist ähnlich, aber wenn Sie tiefer graben, werden Sie feststellen, dass die Implementierungen etwas anders sind. </p><br><p>  Jede der vorgestellten Optionen ist eine Art Kompromiss. </p><br><p>  Einfach ausgedrückt, es besteht Bedarf an einer Einigung über das generische Datensatzformat: </p><br><ul><li>  Sie verbessern das Leben von Entwicklern.  Entwickler können ihrem Code Generika hinzufügen und davon profitieren. </li><li>  Entwickler können die Tools verwenden, die ihnen am besten gefallen, und bei Bedarf zwischen ihnen (Tools) wechseln. </li><li>  Werkzeugentwickler können genau diese Werkzeuge erstellen, die Vorteile für die Community verstehen und nicht befürchten, dass sich etwas ändert oder dass ihnen ein "falscher Ansatz" vorgeworfen wird. </li></ul><br><h2 id="anchortool-supportanchorpodderzhka-instrumentami"><a name="tool-support"></a>  Werkzeugunterstützung </h2><br><p>  Psalm verfügt über alle notwendigen Funktionen zur Überprüfung von Generika.  Phan auch so. </p><br><p>  Ich bin sicher, dass PhpStorm Generika einführen wird, sobald die Community eine Vereinbarung über ein einziges Format vorlegt. </p><br><h2 id="anchorthird-party-code-supportanchorpodderzhka-storonnego-koda"><a name="third-party-code-support"></a>  Code-Unterstützung von Drittanbietern </h2><br><p>  Der letzte Teil des allgemeinen Puzzles besteht darin, Unterstützung für Bibliotheken von Drittanbietern hinzuzufügen. </p><br><p>  Hoffentlich werden die meisten Bibliotheken den generischen Definitionsstandard implementieren, sobald er erscheint.  Dies wird jedoch nicht sofort geschehen.  Einige Bibliotheken werden verwendet, haben jedoch keine aktive Unterstützung.  Bei der Verwendung statischer Analysatoren zur Validierung von Typen in Generika ist es wichtig, dass alle Funktionen definiert sind, die diese Generika akzeptieren oder zurückgeben. </p><br><p>  Was passiert, wenn Ihr Projekt auf Bibliotheken von Drittanbietern basiert, die keine generische Unterstützung bieten? </p><br><p>  Glücklicherweise wurde dieses Problem bereits gelöst und die Stub-Funktionen sind die Lösung.  Psalm, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Phan</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">PhpStorm</a> unterstützen Stubs. </p><br><p>  Stubs sind normale Dateien, die Signaturen von Funktionen und Methoden enthalten, diese jedoch nicht implementieren.  Durch Hinzufügen von Dockblöcken zu Stubs erhalten statische Analysetools die zusätzlichen Informationen, die sie benötigen.  Zum Beispiel, wenn Sie eine Stapelklasse ohne Typhinweise und Generika wie diese haben. </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* some implementation */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* some implementation */</span></span> } }</code> </pre> <br><p>  Sie können eine Stub-Datei mit identischen Methoden erstellen, jedoch mit zusätzlichen Dockblöcken und ohne Implementierung von Funktionen. </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@template</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stack</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> T $item * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> void */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">push</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> T */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Wenn der statische Analysator die Stapelklasse sieht, nimmt er Typinformationen vom Stub und nicht vom tatsächlichen Code. </p><br><p>  Die Möglichkeit, den Code von Stubs einfach zu teilen (z. B. über Composer), wäre äußerst nützlich, weil  würde es ermöglichen, die geleistete Arbeit zu teilen. </p><br><h2 id="anchornext-stepsanchordalneyshie-shagi"><a name="next-steps"></a>  Weitere Schritte </h2><br><p>  Die Gemeinde muss sich von Vereinbarungen entfernen und Standards setzen. </p><br><p>  Vielleicht wäre die beste Option eine generische PSR? </p><br><p>  Oder vielleicht könnten die Entwickler der wichtigsten statischen Analysegeräte, PhpStorm, andere IDEs und alle an der Entwicklung von PHP (zur Steuerung) beteiligten Personen einen Standard entwickeln, den jeder verwenden würde. </p><br><p>  Sobald der Standard angezeigt wird, kann jeder beim Hinzufügen von Generika zu vorhandenen Bibliotheken und Projekten helfen und Pull-Anforderungen erstellen.  Und wo dies nicht möglich ist, können Entwickler Stubs schreiben und teilen. </p><br><p>  Wenn alles erledigt ist, können wir Tools wie PhpStorm verwenden, um die Generika in Echtzeit zu überprüfen, während wir den Code schreiben.  Wir können statische Analysetools als Teil unseres CI als Sicherheitsgarantie verwenden. </p><br><p>  Generika können auch in PHP implementiert werden (na ja, fast). </p><br><h2 id="anchorlimitationsanchorogranicheniya"><a name="limitations"></a>  Einschränkungen </h2><br><p>  Es gibt eine Reihe von Einschränkungen.  PHP ist eine dynamische Sprache, mit der Sie viele "magische" Dinge wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">diese</a> tun können.  Wenn Sie zu viel PHP-Magie verwenden, kann es vorkommen, dass statische Analysatoren nicht alle Typen im System genau extrahieren können.  Wenn irgendwelche Typen unbekannt sind, können die Tools Generika nicht in allen Fällen korrekt verwenden. </p><br><p>  Die Hauptanwendung dieser Analyse ist jedoch die Validierung Ihrer Geschäftslogik.  Wenn Sie sauberen Code schreiben, sollten Sie nicht zu viel Magie verwenden. </p><br><h2 id="anchorwhy-dont-you-just-add-generics-to-the-languageanchorpochemu-by-vam-prosto-ne-dobavit-dzheneriki-v-yazyk"><a name="why-dont-you-just-add-generics-to-the-language"></a>  Warum fügen Sie der Zunge nicht einfach Generika hinzu? </h2><br><p>  Das wäre die beste Option.  PHP hat Open Source Code und niemand stört Sie, die Quellen zu klonen und Generika zu implementieren! </p><br><h2 id="anchorwhat-if-i-dont-want-genericsanchorchto-esli-mne-ne-nuzhny-dzheneriki"><a name="what-if-i-dont-want-generics"></a>  Was ist, wenn ich keine Generika benötige? </h2><br><p>  Ignorieren Sie einfach alle oben genannten Punkte.  Einer der Hauptvorteile von PHP besteht darin, dass es flexibel bei der Auswahl der geeigneten Komplexität der Implementierung ist, je nachdem, was Sie erstellen.  Mit einem einmaligen Code müssen Sie nicht über Dinge wie das Tippen nachdenken.  Bei großen Projekten lohnt es sich jedoch, solche Möglichkeiten zu nutzen. </p><br><blockquote>  Vielen Dank an alle, die diesen Ort gelesen haben.  Ich freue mich über Ihre Kommentare in der PM. <br><br>  <strong>UPD</strong> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">ghost404</a> in den Kommentaren stellte fest, dass <em>PHPStan ab Version 0.12.x Psalmanmerkungen versteht und Generika unterstützt</em> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de456466/">https://habr.com/ru/post/de456466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de456446/index.html">Ceph - von "auf dem Knie" bis "Produktion"</a></li>
<li><a href="../de456448/index.html">Regeln für die Auswahl eines JS-Frameworks</a></li>
<li><a href="../de456450/index.html">DO-RA.Avia zur Überwachung der kosmischen Strahlung in der Luftfahrt</a></li>
<li><a href="../de456452/index.html">C ++ - Codebeispiele vor und nach Bereichen</a></li>
<li><a href="../de456462/index.html">Zusammenstellen einer Bibliothek von Winkelkomponenten als Webkomponenten</a></li>
<li><a href="../de456470/index.html">Fallstricke des WSUS Package Publisher</a></li>
<li><a href="../de456472/index.html">Einführung in Go und das Mggo Framework</a></li>
<li><a href="../de456474/index.html">Tic Tac Toe Teil 0: Vergleich von Svelte und React</a></li>
<li><a href="../de456476/index.html">Änderungen am Bluetooth-Stack zur Verbesserung der Audioqualität von Kopfhörern ohne AAC-, aptX- oder LDAC-Codecs</a></li>
<li><a href="../de456482/index.html">Fang mich, wenn du kannst. König Version</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>