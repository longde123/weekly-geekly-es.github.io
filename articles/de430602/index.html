<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍⚖️ 🎠 🔀 Sicherheitslücken in Etherium Smart-Verträgen. Codebeispiele 🍃 🍁 📒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit diesem Beitrag beginne ich eine Reihe von Artikeln zur Sicherheit von Ethereum-Smart-Verträgen. Ich denke, dieses Thema ist sehr relevant, da die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sicherheitslücken in Etherium Smart-Verträgen. Codebeispiele</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430602/">  Mit diesem Beitrag beginne ich eine Reihe von Artikeln zur Sicherheit von Ethereum-Smart-Verträgen.  Ich denke, dieses Thema ist sehr relevant, da die Anzahl der Entwickler wie eine Lawine wächst und es niemanden gibt, der vor dem "Rechen" gerettet werden kann.  Tschüss - Übersetzungen ... <br><br><h3>  1. Scannen von Live Ethereum-Verträgen auf nicht aktivierte Sendefehler </h3><br><p>  Original - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scannen von Live Ethereum-Verträgen für "Unchecked-Send ..."</a> </p><br>  Autoren: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zikai Alex Wen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andrew Miller</a> <br><br><p> Die intelligente Vertragsprogrammierung von Ethereum ist bekanntermaßen fehleranfällig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[1]</a> .  Vor kurzem haben wir das mehrere gesehen <br>  High-End-Smart-Verträge wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">King of the Ether</a> und <a href="">The DAO-1.0</a> enthielten Schwachstellen, die durch Programmierfehler verursacht wurden. <br><br>  Seit März 2015 werden intelligente Vertragsprogrammierer vor spezifischen Programmiergefahren gewarnt, die auftreten können, wenn Verträge Nachrichten aneinander senden <a href="">[6]</a> . <br><br>  In mehreren Programmierhandbüchern wird empfohlen, häufige Fehler zu vermeiden (in White Papers Ethereum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[3]</a> und in einem unabhängigen Handbuch von UMD <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[2]</a> ).  Obwohl diese Gefahren verständlich genug sind, um sie zu vermeiden, sind die Folgen eines solchen Fehlers schrecklich: Geld kann blockiert, verloren oder gestohlen werden. <br><br>  Wie häufig treten Fehler aufgrund dieser Gefahren auf?  Gibt es verletzlichere, aber lebende Ethereum-Blockchain-Verträge?  In diesem Artikel beantworten wir diese Frage, indem wir Verträge in der Live-Blockchain von Ethereum mit dem von uns entwickelten neuen Analysetool analysieren. <br></p><br><a name="habracut"></a><h3>  Was ist der nicht aktivierte Sendefehler? <br></h3><br><p>  Um einen Sendezeitvertrag an eine andere Adresse zu senden, verwenden Sie am einfachsten das Schlüsselwort <strong>send</strong> .  Dies fungiert als für jedes Objekt definierte Methode.  Das folgende Codefragment befindet sich beispielsweise in einem intelligenten Vertrag, der ein Brettspiel implementiert. <br></p><br><p></p><pre><code class="plaintext hljs">/*** Listing 1 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { winner.send(1000); //    prizePaidOut = True; }</code> </pre> <br><p>  Das Problem hierbei ist, dass die <strong>Sendemethode</strong> möglicherweise fehlschlägt.  Wenn es nicht funktioniert, erhält der Gewinner das Geld nicht, die Variable pricePaidOut wird jedoch auf True gesetzt. <br><br>  Es gibt zwei verschiedene Fälle, in denen die Funktion <strong>won.send ()</strong> möglicherweise fehlschlägt.  Wir werden den Unterschied zwischen ihnen später analysieren.  Der erste Fall ist, dass die <strong>Gewinneradresse</strong> ein Vertrag ist (kein Benutzerkonto) und der Code für diesen Vertrag eine Ausnahme auslöst (z. B. wenn zu viel „Gas“ verwendet wird).  Wenn ja, dann ist es in diesem Fall vielleicht ein "Fehler des Gewinners".  Der zweite Fall ist weniger offensichtlich.  Die virtuelle Ethereum-Maschine verfügt über eine begrenzte Ressource namens " <strong>Callstack</strong> " (Call-Stack-Tiefe). Diese Ressource kann von einem anderen Vertragscode verwendet werden, der zuvor in einer Transaktion ausgeführt wurde.  Wenn der <strong>Callstack</strong> zum Zeitpunkt der Ausführung des <strong>Sendebefehls</strong> bereits <strong>aufgebraucht</strong> war, <strong>schlägt</strong> der Befehl fehl, unabhängig davon, wie der <strong>Gewinner</strong> ermittelt wird.  Der Preis des Gewinners wird unverschuldet vernichtet! </p><br><br>  Wie kann dieser Fehler vermieden werden? <br><br>  Die Ethereum-Dokumentation enthält eine kurze Warnung zu dieser potenziellen Gefahr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[3]</a> : "Bei Verwendung von <strong>send</strong> besteht eine gewisse Gefahr <strong>- die</strong> Übertragung schlägt fehl, wenn die Tiefe des Aufrufstapels 1024 beträgt (dies kann immer vom Anrufer verursacht werden), und schlägt auch fehl, wenn der Empfänger "Gas" endet. Um eine sichere Übertragung zu gewährleisten, überprüfen Sie daher immer den Rückgabewert von " <strong>Senden"</strong> oder besser: Verwenden Sie eine Vorlage, in der der Empfänger Geld abhebt. " <br><p>  Zwei Sätze.  Der erste besteht darin, den Rückgabewert von <strong>send</strong> zu überprüfen, um <strong>festzustellen</strong> , ob er erfolgreich abgeschlossen wurde.  Wenn dies nicht der Fall ist, lösen Sie eine Ausnahme aus, um den Status zurückzusetzen. </p><br><p></p><pre> <code class="plaintext hljs"> /*** Listing 2 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { if (winner.send(1000)) prizePaidOut = True; else throw; }</code> </pre> <br><p>  Dies ist eine angemessene Lösung für das aktuelle Beispiel, aber nicht immer die richtige Entscheidung.  Angenommen, wir ändern unser Beispiel so, dass der Gewinner und der Verlierer nach dem Spiel ihr Vermögen zurückdrehen.  Eine offensichtliche Anwendung einer „formalen“ Lösung wäre die folgende: <br></p><br><p></p><pre> <code class="plaintext hljs">/*** Listing 3 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { if (winner.send(1000) &amp;&amp; loser.send(10)) prizePaidOut = True; else throw; }</code> </pre> <br><p>  Dies ist jedoch ein Fehler, da dadurch eine zusätzliche Sicherheitsanfälligkeit entsteht.  Während dieser Code den <strong>Gewinner</strong> vor einem <strong>Callstack-</strong> Angriff schützt, macht er <strong>Gewinner</strong> und <strong>Verlierer auch</strong> für einander anfällig.  In diesem Fall möchten wir einen <strong>Callstack-</strong> Angriff verhindern, aber die Ausführung fortsetzen, wenn der <strong>Sendebefehl</strong> aus irgendeinem Grund fehlschlägt. <br><br>  Daher ist es selbst die beste bewährte Methode (empfohlen in unserem Ethereum and Serpent Programmer's Guide, obwohl dies auch für Solidity gilt), nach einer <strong>Callstack-</strong> Ressource zu <strong>suchen</strong> .  Wir können ein Makro <strong>callStackIsEmpty () definieren</strong> , das genau dann einen Fehler <strong>zurückgibt,</strong> wenn <strong>callstack</strong> leer ist. </p><br><p></p><pre> <code class="plaintext hljs">/*** Listing 4 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { if (callStackIsEmpty()) throw; winner.send(1000) loser.send(10) prizePaidOut = True; }</code> </pre> <br><p>  Noch besser ist, dass die Empfehlung aus der Ethereum-Dokumentation - „Verwenden Sie eine Vorlage, in der der Empfänger das Geld nimmt“ - etwas kryptisch ist, aber eine Erklärung enthält.  Der Vorschlag besteht darin, Ihren Code so zu reorganisieren, dass die Auswirkung des <strong>Sendefehlers</strong> isoliert ist und jeweils nur einen Empfänger betrifft.  Das Folgende ist ein Beispiel für diesen Ansatz.  Dieser Tipp ist jedoch auch ein Anti-Muster.  Er übernimmt die Verantwortung für die Überprüfung des <strong>Callstacks gegenüber</strong> den Empfängern selbst, wodurch es möglich wird, in dieselbe Falle zu tappen. <br></p><br><p></p><pre> <code class="plaintext hljs">/*** Listing 5 ***/ if (gameHasEnded &amp;&amp; !( prizePaidOut ) ) { accounts[winner] += 1000 accounts[loser] += 10 prizePaidOut = True; } ... function withdraw(amount) { if (accounts[msg.sender] &gt;= amount) { msg.sender.send(amount); accounts[msg.sender] -= amount; } }</code> </pre> <br><p>  Viele hochentwickelte intelligente Verträge sind anfällig.  Die Lotterie "König der Luft des Throns" ist der bekannteste Fall dieses Fehlers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">[4]</a> .  Dieser Fehler wurde erst bemerkt, als die Menge von 200 Ethern (im Wert von mehr als 2000 US-Dollar zum heutigen Preis) nicht den legitimen Gewinner der Lotterie erhalten konnte.  Der entsprechende Code in King of the Ether ähnelt dem Code in Listing 2. Glücklicherweise konnte der Vertragsentwickler in diesem Fall die nicht verwandte Funktion im Vertrag als „manuelle Überschreibung“ verwenden, um die festgefahrenen Gelder freizugeben.  Ein weniger gewissenhafter Administrator könnte dieselbe Funktion verwenden, um die Sendung zu stehlen! <br></p><cut></cut><br>  Fortsetzung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scannens von Live Ethereum-Verträgen auf nicht aktivierte Sendefehler.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430602/">https://habr.com/ru/post/de430602/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430580/index.html">Top-Bücher zum Django-Framework</a></li>
<li><a href="../de430590/index.html">In Deutschland entwickelten sich die Anforderungen für Heimrouter</a></li>
<li><a href="../de430592/index.html">Client-Internet in einer QEMU-isolierten virtuellen Maschine mithilfe von Port-Tunneling über einen SPICE-Kanal</a></li>
<li><a href="../de430596/index.html">Wie bereite ich eine Produktstrategie vor? Produktmanager-Handbuch</a></li>
<li><a href="../de430600/index.html">Mars - von Schokolade zu Robotern</a></li>
<li><a href="../de430604/index.html">Technologien, die im PVS-Studio Code Analyzer verwendet werden, um nach Fehlern und potenziellen Schwachstellen zu suchen</a></li>
<li><a href="../de430606/index.html">Group-IB-Webinar: „Forensische Untersuchung von RDP-Artefakten unter Windows“</a></li>
<li><a href="../de430610/index.html">So entfernen Sie Ihre elektronischen Geräte sicher</a></li>
<li><a href="../de430612/index.html">Wie in den 1980er Jahren Menschen Spiele aus dem Radio heruntergeladen haben</a></li>
<li><a href="../de430614/index.html">Schwarzer Freitag 2018 bei Madrobots.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>