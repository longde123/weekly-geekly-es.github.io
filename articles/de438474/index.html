<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏻 🤽🏽 📺 Kurier: Dropbox-Migration zu gRPC 🔎 👩🏿‍🎤 ☹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anmerkung des Übersetzers 
 Die meisten modernen Softwareprodukte sind nicht monolithisch, sondern bestehen aus vielen Teilen, die miteinander interag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kurier: Dropbox-Migration zu gRPC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/438474/"><img src="https://habrastorage.org/webt/eu/p8/y-/eup8y-m8hpxc9w2qhvo1qofrmog.jpeg"><br><br><h1>  Anmerkung des Übersetzers </h1><br>  Die meisten modernen Softwareprodukte sind nicht monolithisch, sondern bestehen aus vielen Teilen, die miteinander interagieren.  In dieser Situation ist es erforderlich, dass die Kommunikation der interagierenden Teile des Systems in einer Sprache erfolgt (obwohl diese Teile selbst in verschiedenen Programmiersprachen geschrieben und auf verschiedenen Maschinen ausgeführt werden können).  Um die Lösung dieses Problems zu vereinfachen, hilft gRPC - Open-Source-Framework von Google, das 2015 veröffentlicht wurde.  Er löst sofort eine Reihe von Problemen und erlaubt: <br><br><ul><li>  Verwenden Sie die Sprache Protokollpuffer, um die Interaktion von Diensten zu beschreiben. <br></li><li>  Generieren von Programmcode basierend auf dem beschriebenen Protokoll für 11 verschiedene Sprachen sowohl für den Client-Teil als auch für den Server-Teil; <br></li><li>  Autorisierung zwischen interagierenden Komponenten implementieren; <br></li><li>  Verwenden Sie sowohl synchrone als auch asynchrone Interaktion. <br></li></ul><br>  gRPC schien mir ein ziemlich interessantes Framework zu sein, und ich war daran interessiert, die tatsächlichen Erfahrungen von Dropbox beim Aufbau eines darauf basierenden Systems kennenzulernen.  Der Artikel enthält viele Details zur Verwendung der Verschlüsselung, zum Aufbau eines zuverlässigen, beobachtbaren und produktiven Systems sowie zum Migrationsprozess von der alten RPC-Lösung zur neuen. <br><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss</b> <div class="spoiler_text">  Der Originalartikel enthält keine Beschreibung von gRPC, und einige Punkte scheinen Ihnen möglicherweise nicht klar zu sein.  Wenn Sie mit gRPC oder anderen ähnlichen Frameworks (z. B. Apache Thrift) nicht vertraut sind, empfehle ich Ihnen, sich zunächst mit den Hauptideen vertraut zu machen (es reicht aus, zwei kleine Artikel von der offiziellen Website zu lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Was ist gRPC?“</a> Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„gRPC-Konzepte“</a> ). <br><br>  Vielen Dank an Aleksey Ivanov aka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SaveTheRbtz</a> für das Schreiben des Originalartikels und die Hilfe bei der Übersetzung schwieriger Orte. <br></div></div><a name="habracut"></a><br>  Dropbox verwaltet viele Dienste, die in verschiedenen Sprachen geschrieben sind und Millionen von Anfragen pro Sekunde bearbeiten.  Im Zentrum unserer serviceorientierten Architektur steht Courier, ein gPC-basiertes RPC-Framework.  Während der Entwicklung haben wir viel über die Erweiterbarkeit von gRPC, die Leistungsoptimierung und den Übergang vom vorherigen RPC-System gelernt. <br><br>  <i>Hinweis: Der Beitrag enthält Codefragmente für Python und Go.</i>  <i>Wir verwenden auch Rust und Java.</i> <br><br><h1>  Straße nach gRPC </h1><br>  Courier ist nicht das erste Dropbox-RPC-Framework.  Noch bevor wir begannen, das monolithische Python-System in separate Dienste aufzuteilen, brauchten wir eine zuverlässige Basis für den Datenaustausch zwischen Diensten - insbesondere, da die Auswahl eines Frameworks langfristige Konsequenzen hätte. <br><br>  Zuvor experimentierte Dropbox mit verschiedenen RPC-Frameworks.  Zunächst hatten wir ein individuelles Protokoll für die manuelle Serialisierung und Deserialisierung.  Einige Dienste, wie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scribe-basierte Protokollierung</a> , verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Thrift</a> .  Gleichzeitig war unser Haupt-RPC-Framework ein HTTP / 1.1-Protokoll mit Nachrichten, die mit Protobuf serialisiert wurden. <br><br>  Bei der Erstellung eines Frameworks haben wir aus mehreren Optionen ausgewählt.  Wir könnten Swagger (jetzt als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI bekannt</a> ) in das alte RPC-Framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einführen, einen neuen Standard einführen</a> oder ein auf Thrift oder gRPC basierendes Framework erstellen.  Das Hauptargument für gRPC war die Möglichkeit, bereits vorhandene Protobufs zu verwenden.  Auch Multiplex-HTTP / 2 und bidirektionale Datenübertragung waren für unsere Aufgaben nützlich. <br><br>  <i>Hinweis: Wenn zu diesem Zeitpunkt fbthrift vorhanden wäre, würden wir uns Thrift-Lösungen wahrscheinlich genauer ansehen.</i> <br><br><h1>  Was Kurier zu gRPC bringt </h1><br>  Courier ist kein RPC-Protokoll.  Es ist ein Mittel zur Integration von gRPC in eine vorhandene Infrastruktur.  Das Framework sollte mit unseren Authentifizierungs-, Autorisierungs- und Serviceerkennungstools sowie mit der Erfassung, Protokollierung und Nachverfolgung von Statistiken kompatibel sein.  Also haben wir Courier erstellt. <br><br>  <i>Obwohl wir in einigen Fällen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bandaid</a> als gRPC-Proxy verwenden, kommunizieren die meisten unserer Dienste direkt miteinander, um die Auswirkungen von RPC auf die Latenz zu minimieren.</i> <br><br>  Für uns war es wichtig, die Menge an Routinecode zu reduzieren, die geschrieben werden muss.  Da Courier als allgemeiner Rahmen für die Entwicklung von Diensten dient, enthält es Funktionen, die jeder benötigt.  Die meisten von ihnen sind standardmäßig aktiviert und können über Befehlszeilenargumente gesteuert werden. Einige werden mit einem Kontrollkästchen aktiviert. <br><br><h2>  Sicherheit: Dienstidentität und gegenseitige TLS-Authentifizierung </h2><br>  Courier implementiert unseren Standardmechanismus zur Identifizierung von Diensten.  Jedem Server und Client wird ein individuelles TLS-Zertifikat zugewiesen, das von unserer eigenen Zertifizierungsstelle ausgestellt wird.  Die zertifikatcodierte persönliche Kennung, die für die gegenseitige Authentifizierung verwendet wird - der Server überprüft den Client, der Client überprüft den Server. <br><br>  In TLS, wo wir beide Seiten der Verbindung steuern, haben wir strenge Einschränkungen eingeführt.  Alle internen RPCs erfordern eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PFS-</a> Verschlüsselung.  Die erforderliche Version von TLS ist 1.2 und höher.  Wir haben auch die Anzahl der symmetrischen und asymmetrischen Algorithmen begrenzt und <i>ECDHE-ECDSA-AES128-GCM-SHA256</i> bevorzugt. <br><br>  Nach Durchlaufen der Identifizierung und Entschlüsselung der Anforderung prüft der Server, ob der Client über die erforderlichen Berechtigungen verfügt.  Zugriffssteuerungslisten (ACLs) und Geschwindigkeitsbegrenzungen können sowohl für Dienste im Allgemeinen als auch für einzelne Methoden konfiguriert werden.  Ihre Parameter können auch über unser Distributed File System (AFS) geändert werden.  Dank dessen können Servicebesitzer die Last in Sekundenschnelle fallen lassen, ohne die Prozesse neu zu starten.  Courier kümmert sich um das Abonnieren von Benachrichtigungen und das Aktualisieren der Konfiguration. <br><br>  <i>Der Identitätsdienst ist eine globale Kennung für ACLs, Geschwindigkeitsbegrenzungen, Statistiken usw. Außerdem ist er kryptografisch sicher.</i> <br><br>  Hier ist ein Beispiel für die ACL-Konfiguration und die Geschwindigkeitsbegrenzung, die in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optischen Mustererkennungsdienst verwendet werden</a> : <br><br><pre><code class="plaintext hljs">limits:  dropbox_engine_ocr:    # All RPC methods.    default:      max_concurrency: 32      queue_timeout_ms: 1000      rate_acls:        # OCR clients are unlimited.        ocr: -1        # Nobody else gets to talk to us.        authenticated: 0        unauthenticated: 0</code> </pre> <br><img src="https://habrastorage.org/webt/ll/as/l_/llasl_0osxrxbboxrbjqaalb8ti.png"><br><br>  <i>Wir erwägen die Möglichkeit, auf das SVID-Format (kryptografisch verifiziertes Dokument <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPIFFE</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umzusteigen</a> , um unser Framework mit vielen Open-Source-Projekten zu kombinieren.</i> <br><br><h2>  Beobachtbarkeit: Statistik und Tracking </h2><br>  Mit nur einer Kennung können Sie problemlos Protokolle, Statistiken, Tracedateien und andere Daten zu Courier finden. <br><br><img src="https://habrastorage.org/webt/t_/25/3o/t_253ogfq1bizretdswvdrb_7g0.png"><br><br>  Während der Codegenerierung wird die Statistiksammlung für jeden Dienst und jede Methode sowohl auf der Clientseite als auch auf der Serverseite hinzugefügt.  Serverseitige Statistiken werden durch die Client-ID unterteilt.  In der Standardkonfiguration erhalten Sie detaillierte Daten zu Last, Fehlern und Verzögerungszeit für jeden Dienst mit Courier. <br><br><img src="https://habrastorage.org/webt/g1/6g/_1/g16g_1z72oxaxwwvasrjhznfltk.png"><br><br>  Die Kurierstatistik enthält Daten zur Verfügbarkeit und Latenz auf der Clientseite sowie zur Anzahl der Anforderungen und zur Warteschlangengröße auf der Serverseite.  Es gibt andere nützliche Diagramme, insbesondere Histogramme der Antwortzeit für jede Methode und der Zeit der TLS-Handshakes für jeden Client. <br><br>  <i>Einer der Vorteile unserer Codegenerierung ist die Möglichkeit der statischen Initialisierung von Datenstrukturen wie Histogrammen und Trace-Diagrammen.</i>  <i>Dies minimiert die Auswirkungen auf die Leistung.</i> <br><br><img src="https://habrastorage.org/webt/p7/6-/fv/p76-fvobtszsgtu2g2tlmwfwlyk.png"><br><br>  Das alte RPC-System hat nur <i>request_id</i> über die API verteilt.  Dies ermöglichte es, Daten aus den Protokollen verschiedener Dienste zu kombinieren.  Bei Courier haben wir eine API eingeführt, die auf einer Teilmenge der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenTracing-</a> Spezifikationen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">basiert</a> .  Wir haben unsere eigenen Bibliotheken auf der Client-Seite geschrieben und auf der Server-Seite eine Lösung implementiert, die auf Cassandra und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jaeger</a> basiert. <br><br><img src="https://habrastorage.org/webt/dk/hv/iq/dkhviqgdiem3itipi7x87tri_i8.png"><br><br>  Durch die Ablaufverfolgung können wir zur Laufzeit Abhängigkeitsdiagramme eines Dienstes erstellen.  Auf diese Weise können Ingenieure alle transitiven Abhängigkeiten eines bestimmten Dienstes erkennen.  Darüber hinaus ist die Funktion nützlich, um unerwünschte Abhängigkeiten nach der Bereitstellung zu verfolgen. <br><br><h2>  Zuverlässigkeit: Fristen und Unterbrechung </h2><br>  Courier bietet einen zentralen Ort, um gemeinsame Clientfunktionen (z. B. Zeitüberschreitungen) in verschiedenen Sprachen zu implementieren.  Wir haben nach und nach verschiedene Funktionen hinzugefügt, die häufig auf den Ergebnissen einer „posthumen“ Analyse aufkommender Probleme basieren. <br><br><h3>  Fristen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jede gRPC-Anfrage hat eine Frist</a> , die das Client-Timeout angibt.  Da Courier-Stubs bekannte Metadaten automatisch verteilen, wird die Anforderungsfrist sogar außerhalb der API übertragen.  Innerhalb des Prozesses erhalten Fristen eine native Anzeige.  In Go werden sie beispielsweise durch das Ergebnis von <i>context.Context</i> aus der <i>WithDeadline-</i> Methode dargestellt. <br><br>  Tatsächlich konnten wir ganze Klassen von Zuverlässigkeitsproblemen beheben, indem wir die Ingenieure dazu zwangen, Fristen für die Definition der geeigneten Services festzulegen. <br><br>  Dieser Ansatz geht sogar über RPC hinaus.  Zum Beispiel serialisiert unser ORM MySQL einen RPC-Kontext zusammen mit einer Frist in einem SQL-Abfragekommentar.  Unser SQL-Proxy kann Kommentare analysieren und Abfragen "töten", wenn die Frist abgelaufen ist.  Als Bonus beim Debuggen von Datenbankaufrufen haben wir eine SQL-Abfrage, die an eine bestimmte RPC-Abfrage gebunden ist. <br><br><h3>  Trennen </h3><br>  Ein weiteres häufiges Problem, mit dem Clients des vorherigen RPC-Systems konfrontiert waren, war die Implementierung des Algorithmus für individuelle exponentielle Verzögerungen und Schwankungen bei wiederholter Anforderung. <br><br>  Wir haben versucht, eine intelligente Lösung für das Problem der Trennung in Courier zu finden, beginnend mit der Implementierung des LIFO-Puffers (last in, first out) zwischen dem Dienst und dem Aufgabenpool. <br><br><img src="https://habrastorage.org/webt/th/sr/t0/thsrt0kbgxgnexrr9figp9ymg_a.png"><br><br>  Im Falle einer Überlastung wird LIFO automatisch getrennt.  Die Warteschlange, die wichtig ist, ist nicht nur durch die Größe, sondern auch <b>durch die Zeit begrenzt</b> (die Anforderung kann nur eine bestimmte Zeit in der Warteschlange verbringen). <br><br>  <i>Minus LIFO - Änderung der Reihenfolge der Bearbeitung von Anfragen.</i>  <i>Wenn Sie die ursprüngliche Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beibehalten</a> möchten, verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoDel</a> .</i>  <i>Auch dort besteht die Möglichkeit der Trennung, und die Reihenfolge der Verarbeitungsanforderungen bleibt gleich.</i> <br><br><img src="https://habrastorage.org/webt/7g/w_/ud/7gw_udkbrsesseak2xrxaucw7fi.png"><br><br><h2>  Selbstbeobachtung: Debuggen von Endpunkten </h2><br>  Obwohl Debugging-Endpunkte nicht direkt Teil von Courier sind, werden sie in Dropbox häufig verwendet und sind zu nützlich, um nicht erwähnt zu werden. <br><br>  <i>Aus Sicherheitsgründen können Sie sie an einem separaten Port oder an einem Unix-Socket öffnen (um den Zugriff mithilfe von Dateiberechtigungen zu steuern).</i>  <i>Sie sollten auch die gegenseitige TLS-Authentifizierung in Betracht ziehen, mit der Entwickler ihre Zertifikate für den Zugriff auf Endpunkte bereitstellen müssen (hauptsächlich nicht nur schreibgeschützt).</i> <br><br><h3>  Ausführung </h3><br>  Die Möglichkeit, den Status eines Dienstes während seines Betriebs zu analysieren, ist für das Debuggen sehr nützlich.  Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">dynamische Speicher- und CPU-Profile kann beispielsweise über HTTP- oder gRPC-Endpunkte zugegriffen werden</a> . <br><br>  <i>Wir planen, diese Möglichkeit bei der kanarischen Überprüfung zu nutzen, um die Suche nach dem Unterschied zwischen der alten und der neuen Version des Codes zu automatisieren.</i> <br><br>  Endpunkte ermöglichen es, den Status eines Dienstes zur Laufzeit zu ändern.  Insbesondere Golang-basierte Dienste können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GCPercent</a> dynamisch konfigurieren. <br><br><h3>  Die Bibliothek </h3><br>  Der automatische Export bibliotheksspezifischer Daten als RPC-Endpunkt kann für Bibliotheksentwickler hilfreich sein.  Beispielsweise kann die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Malloc-</a> Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interne Statistiken in einen Speicherauszug sichern</a> .  Ein weiteres Beispiel: Ein Debugging-Endpunkt kann den Grad der Dienstprotokollierung im laufenden Betrieb ändern. <br><br><h3>  Rpc </h3><br>  Natürlich ist die Fehlerbehebung in verschlüsselten und verschlüsselten Protokollen nicht einfach.  Daher ist es eine gute Idee, so viele Tools wie möglich auf RPC-Ebene einzuführen.  Ein Beispiel für eine solche introspektive API <a href="">ist die Channelz-Lösung</a> . <br><br><h3>  Anwendungsebene </h3><br>  Es kann auch nützlich sein, Optionen auf Anwendungsebene zu lernen.  Ein gutes Beispiel ist ein Endpunkt mit allgemeinen Informationen zur Anwendung (mit einem Hash von Quell- oder Assemblydateien, einer Befehlszeile usw.).  Es kann von einem Orchestrierungssystem verwendet werden, um die Integrität bei der Bereitstellung eines Dienstes zu überprüfen. <br><br><h1>  Leistungsoptimierung </h1><br>  Durch die Erweiterung unseres gRPC-Frameworks auf den erforderlichen Maßstab haben wir einige Engpässe festgestellt, die für Dropbox spezifisch sind. <br><br><h3>  Ressourcenverbrauch von TLS-Handshakes </h3><br>  In Diensten, die aufgrund von TLS-Handshakes viele Beziehungen bedienen, kann die kombinierte CPU-Auslastung sehr schwerwiegend sein (insbesondere beim Neustart eines beliebten Dienstes). <br><br>  Um die Leistung beim Signieren zu verbessern, haben wir die Schlüsselpaare RSA-2048 durch die ECDSA P-256 ersetzt.  Hier sind Beispiele für ihre Leistung (Hinweis: Mit RSA ist die Signaturüberprüfung schneller). <br><br>  <b>RSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'RSA 2048' Did ... RSA 2048 signing operations in ..............  (1527.9 ops/sec) Did ... RSA 2048 verify (same key) operations in .... (37066.4 ops/sec) Did ... RSA 2048 verify (fresh key) operations in ... (25887.6 ops/sec)</code> </pre> <br>  <b>ECDSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'ECDSA P-256' Did ... ECDSA P-256 signing operations in ... (40410.9 ops/sec) Did ... ECDSA P-256 verify operations in .... (17037.5 ops/sec)</code> </pre><br>  Da die Überprüfung mit RSA-2048 etwa dreimal schneller ist als mit ECDSA P-256, können Sie RSA für Root- und Endzertifikate auswählen, um die Betriebsgeschwindigkeit zu erhöhen.  Unter dem Gesichtspunkt der Sicherheit ist jedoch nicht alles so einfach: Sie erstellen Ketten aus verschiedenen kryptografischen Grundelementen, und daher ist die Ebene der resultierenden Sicherheitsparameter am niedrigsten.  Wenn Sie die Leistung verbessern möchten, empfehlen wir, keine Zertifikate der Version RSA-4096 (und höher) als Root- und Endzertifikate zu verwenden. <br><br>  Wir haben auch festgestellt, dass die Auswahl einer TLS-Bibliothek (und von Kompilierungsflags) erhebliche Auswirkungen auf die Leistung und die Sicherheit hat.  Vergleichen Sie beispielsweise den auf macOS X Mojave aufgebauten LibreSSL mit dem selbstgeschriebenen OpenSSL auf derselben Hardware. <br><br>  <b>LibreSSL 2.6.4:</b> <br><br><pre> <code class="plaintext hljs">~ openssl speed rsa2048 LibreSSL 2.6.4 ...                 sign verify sign/s verify/s rsa 2048 bits 0.032491s 0.001505s     30.8 664.3</code> </pre> <br>  <b>OpenSSL 1.1.1a:</b> <br><br><pre> <code class="plaintext hljs"> ~ openssl speed rsa2048 OpenSSL 1.1.1a  20 Nov 2018 ...                 sign verify sign/s verify/s rsa 2048 bits 0.000992s 0.000029s   1208.0 34454.8</code> </pre> <br>  Der schnellste Weg, einen TLS-Handshake zu erstellen, besteht darin, ihn überhaupt nicht zu erstellen!  Wir haben die Unterstützung für die Wiederaufnahme der Sitzung in gRPC-Core und gRPC-Python aufgenommen, wodurch die Belastung der CPU während der Bereitstellung verringert wird. <br><br><h3>  Die Verschlüsselung ist kostengünstig </h3><br>  Viele glauben fälschlicherweise, dass Verschlüsselung teuer ist.  Selbst die einfachsten modernen Computer führen fast sofort eine symmetrische Verschlüsselung durch.  Ein Standardprozessor kann Daten mit einer Geschwindigkeit von 40 Gbit / s pro Kern verschlüsseln und authentifizieren: <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'AES' Did ... AES-128-GCM (8192 bytes) seal operations in ... 4534.4 MB/s</code> </pre> <br>  Trotzdem mussten wir gRPC für unsere Speicherblöcke konfigurieren, die mit einer Geschwindigkeit von 50 Gbit / s betrieben wurden.  Wir haben festgestellt, dass es wichtig ist, die Anzahl der <i>Speichervorgänge</i> zu minimieren, wenn die Verschlüsselungsgeschwindigkeit ungefähr der <i>Kopiergeschwindigkeit entspricht.</i>  Darüber hinaus haben wir einige Änderungen an gRPC selbst vorgenommen. <br><br>  <i>Durch authentifizierte und verschlüsselte Protokolle wurden viele unangenehme Probleme vermieden (z. B. Datenbeschädigung durch den Prozessor, DMA oder das Netzwerk).</i>  <i>Auch wenn Sie gRPC nicht verwenden, empfehlen wir die Verwendung von TLS für interne Kontakte.</i> <br><br><h2>  Datenkanäle mit hoher Latenz (BDP) </h2><br>  Anmerkung des Übersetzers: Der ursprüngliche Untertitel verwendete den Begriff <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bandbreitenverzögerungsprodukt</a> , für das keine etablierte Übersetzung ins Russische vorliegt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Dropbox-Backbone-Netzwerk umfasst viele Rechenzentren</a> .  Manchmal müssen Knoten in verschiedenen Regionen über RPC kommunizieren, beispielsweise zur Replikation.  Bei Verwendung von TCP ist der Systemkern für die Begrenzung der Datenmenge verantwortlich, die in einer bestimmten Verbindung übertragen wird (innerhalb von / <i>proc / sys / net / ipv4 / tcp_ {r, w} mem</i> ), obwohl gRPC auf Basis von HTTP / 2 über ein eigenes Tool verfügt Flusskontrolle.  Die Obergrenze von BDP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in grpc-go ist streng auf 16 MB begrenzt</a> , was einen Engpass auslösen kann. <br><br><h2>  net.Server Golang oder grpc.Server </h2><br>  Zunächst haben wir in unserem Go-Code HTTP / 1.1 und gRPC mit einem einzigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">net.Server unterstützt</a> .  Die Lösung war im Hinblick auf die Pflege des Programmcodes sinnvoll, funktionierte jedoch überhaupt nicht einwandfrei.  Durch die Verteilung von HTTP / 1.1 und gRPC auf Server und die Migration von gRPC auf grpc.Server wurden die Kurierbandbreite und die Speichernutzung erheblich verbessert. <br><br><h2>  Golang / Protobuf oder Gogo / Protobuf </h2><br>  Der Wechsel zu gRPC kann die Kosten für das Marshalling und das Unmarshaling erhöhen.  Bei Go-Code konnten wir die CPU-Auslastung von Courier-Servern durch den Wechsel zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gogo / protobuf</a> erheblich reduzieren. <br><br>  <i>Wie immer war der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Übergang zu Gogo / Protobuf mit einigen Bedenken verbunden</a> , aber wenn Sie die Funktionalität angemessen einschränken, sollte es keine Probleme geben.</i> <br><br><h1>  Implementierungsdetails </h1><br>  In diesem Abschnitt werden wir tiefer in das Courier-Gerät eindringen, Protobuf-Schemata und Beispiele für Stubs aus verschiedenen Sprachen betrachten.  Alle Beispiele stammen aus dem Testdienst, den wir beim Testen der Courier-Integration verwendet haben. <br><br><h2>  Servicebeschreibung </h2><br>  Schauen Sie sich einen Auszug aus der Testdienstdefinition an: <br><br><pre> <code class="plaintext hljs">service Test {   option (rpc_core.service_default_deadline_ms) = 1000;   rpc UnaryUnary(TestRequest) returns (TestResponse) {       option (rpc_core.method_default_deadline_ms) = 5000;   }   rpc UnaryStream(TestRequest) returns (stream TestResponse) {       option (rpc_core.method_no_deadline) = true;   }   ... }</code> </pre> <br>  Wie oben angegeben, ist für alle Kuriermethoden eine Frist erforderlich.  Mit der folgenden Option können Sie die Frist für den gesamten Service festlegen: <br><br><pre> <code class="plaintext hljs">option (rpc_core.service_default_deadline_ms) = 1000;</code> </pre> <br>  Gleichzeitig kann jede Methode auf ihre eigene Frist eingestellt werden, wodurch die Frist für den gesamten Dienst (falls vorhanden) aufgehoben wird: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_default_deadline_ms) = 5000;</code> </pre> <br>  In seltenen Fällen, in denen die Frist nicht sinnvoll ist (z. B. beim Verfolgen einer Ressource), kann der Entwickler sie deaktivieren: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_no_deadline) = true;</code> </pre> <br>  Darüber hinaus sollte die Servicebeschreibung eine detaillierte API-Dokumentation enthalten, möglicherweise mit Verwendungsbeispielen. <br><br><h2>  Stub Generation </h2><br>  Um mehr Flexibilität zu bieten, generiert Courier seine eigenen Stubs, ohne sich auf die von gRPC bereitgestellte Interceptor-Funktionalität zu verlassen (mit Ausnahme von Java, in dem die Interceptor-API über ausreichende Leistung verfügt).  Vergleichen wir unsere Stubs mit den Standard-Golang-Stubs. <br><br>  So sehen die Standard-gRPC-Server-Stubs aus: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, ctx context.Context, dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {       in := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(TestRequest)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := dec(in); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interceptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, in)       }       info := &amp;grpc.UnaryServerInfo{               Server: srv,               FullMethod: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,       }       handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, req.(*TestRequest))       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor(ctx, in, info, handler) }</code> </pre> <br>  Die gesamte Verarbeitung erfolgt im Inneren: Dekodieren von Protobuf, Starten von Interceptors (siehe die <code>interceptor</code> Variable im Code), Starten des UnaryUnary-Handlers. <br><br>  Schauen Sie sich jetzt die Kurierstubs an: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_dbxHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       ctx context.Context,       dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()       impl := srv.(*dbxTestServerImpl)       metadata := impl.testUnaryUnaryMetadata       ctx = metadata.SetupContext(ctx)       clientId = client_info.ClientId(ctx)       stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)       stats.TotalCount.Inc()       req := &amp;processor.UnaryUnaryRequest{               Srv: srv,               Ctx: ctx,               Dec: dec,               Interceptor: interceptor,               RpcStats: stats,               Metadata: metadata,               FullMethodPath: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,               Req: &amp;test.TestRequest{},               Handler: impl._UnaryUnary_internalHandler,               ClientId: clientId,               EnqueueTime: time.Now(),       }       metadata.WorkPool.Process(req).Wait()       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.Resp, req.Err }</code> </pre> <br>  Hier gibt es ziemlich viel Code, also analysieren wir ihn. <br><br>  Zunächst verschieben wir den Aufruf an den Panic Handler, der für die automatische Erfassung von Fehlern verantwortlich ist.  Auf diese Weise können wir alle nicht erfassten Ausnahmen im zentralen Repository für die spätere Aggregation und Berichterstellung erfassen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()</code> </pre><br>  Ein weiterer Grund, warum wir unseren eigenen Panik-Handler ausführen, besteht darin, sicherzustellen, dass die Anwendung abstürzt, wenn ein Fehler auftritt.  Der Standard-Golang / Net-HTTP-Handler ignoriert in diesem Fall das Problem und bedient weiterhin neue Anforderungen (auch beschädigt und inkonsistent). <br><br>  Dann geben wir den Kontext weiter und definieren die Werte basierend auf den Metadaten der eingehenden Anforderung neu: <br><br><pre> <code class="go hljs">ctx = metadata.SetupContext(ctx) clientId = client_info.ClientId(ctx)</code> </pre> <br>  Außerdem erstellen wir serverseitige Client-Statistiken für eine detailliertere Aggregation (und speichern sie zur Steigerung der Effizienz). <br><br><pre> <code class="go hljs">stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)</code> </pre><br>  Diese Zeile erstellt während der Ausführung Statistiken für jeden Client (dh eine TLS-Kennung).  Wir haben auch Statistiken zu allen Methoden für jeden Service.  Da der Stub-Generator während der Codegenerierung auf alle Methoden zugreifen kann, können wir sie vorher statisch erstellen, um eine Verlangsamung des Programms zu vermeiden. <br><br>  Danach erstellen wir eine Anforderungsstruktur, übertragen sie in den Aufgabenpool und warten auf die Ausführung: <br><br><pre> <code class="go hljs">req := &amp;processor.UnaryUnaryRequest{       Srv:        srv,       Ctx:        ctx,       Dec:        dec,       Interceptor:    interceptor,       RpcStats:       stats,       Metadata:       metadata,       ... } metadata.WorkPool.Process(req).Wait()</code> </pre> <br>  Bitte beachten Sie, dass wir zu diesem Zeitpunkt weder Protobuf dekodiert noch den Interceptor gestartet haben.  Zuvor müssen der Zugriffspool, die Priorisierung und die Begrenzung der Anzahl der ausgeführten Anforderungen den Aufgabenpool durchlaufen. <br><br>  <i>Beachten Sie, dass die gRPC-Bibliothek die TAP-Schnittstelle unterstützt, mit der Sie Anforderungen mit einer enormen Geschwindigkeit abfangen können.</i>  <i>Die Schnittstelle bietet die Infrastruktur für den Aufbau effektiver Geschwindigkeitsbegrenzer bei minimalem Ressourcenverbrauch.</i> <br><br><h2>  Spezifische Fehlercodes für verschiedene Anwendungen </h2><br>  Mit unserem Stub-Generator können Entwickler mithilfe spezieller Optionen auch anwendungsspezifische Fehlercodes zuweisen: <br><br><pre> <code class="plaintext hljs">enum ErrorCode { option (rpc_core.rpc_error) = true; UNKNOWN = 0; NOT_FOUND = 1 [(rpc_core.grpc_code)="NOT_FOUND"]; ALREADY_EXISTS = 2 [(rpc_core.grpc_code)="ALREADY_EXISTS"]; ... STALE_READ = 7 [(rpc_core.grpc_code)="UNAVAILABLE"]; SHUTTING_DOWN = 8 [(rpc_core.grpc_code)="CANCELLED"]; }</code> </pre> <br>  Sowohl gRPC- als auch Anwendungsfehler breiten sich innerhalb des Dienstes aus, und an der API-Grenze werden alle Fehler durch UNBEKANNT ersetzt.  Auf diese Weise können wir vermeiden, das Problem auf andere Dienste zu übertragen, was zu einer Änderung ihrer Semantik führen kann. <br><br><h2>  Python-Änderungen </h2><br>  Python-Stubs fügen allen Courier-Handlern einen expliziten Kontextparameter hinzu: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.context <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.proto.test.service_pb2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (       TestRequest,       TestResponse, ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCourierClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(           self,           ctx, # type: Context           request, # type: TestRequest           )</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># type: (...) -&gt; TestResponse       ...</span></span></code> </pre> <br>  Anfangs sah es seltsam aus, aber im Laufe der Zeit gewöhnten sich die Entwickler daran, <i>ctx</i> genau wie früher <i>selbst</i> zu explizieren. <br><br>  Bitte beachten Sie, dass unsere Stubs vollständig für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mypy</a> typisiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind</a> , was bei größeren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umgestaltungen</a> ausgeglichen wird.  Darüber hinaus wird die Integration mit einigen IDEs (z. B. PyCharm) vereinfacht. <br><br>  Wir folgen weiterhin dem Trend zur statischen Typisierung und fügen den Protokollen selbst mypy-Anmerkungen hinzu: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestMessage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Message)</span></span></span><span class="hljs-class">:</span></span>   field: int   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,       field : Optional[int] = ...,       )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ...   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: bytes)</span></span></span><span class="hljs-function"> -&gt; TestMessage:</span></span> ...</code> </pre> <br>  Durch diese Anmerkungen werden viele häufig auftretende Fehler vermieden, z. B. das Zuweisen des Werts " <i>Keine" zu einem</i> Feld vom Typ " <i>Zeichenfolge"</i> <i>.</i> <br><br>  Dieser Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist hier verfügbar</a> . <br><br><h1>  Migrationsprozess </h1><br>  Das Erstellen eines neuen RPC-Stacks ist keine leichte Aufgabe, steht jedoch nicht einmal neben dem Prozess eines vollständigen Übergangs, wenn Sie die Komplexität des Betriebs betrachten.  Aus diesem Grund haben wir versucht, Entwicklern den Wechsel vom alten RPC zu Courier so einfach wie möglich zu gestalten.  Da die Migration häufig mit Fehlern einhergeht, haben wir uns entschlossen, sie schrittweise umzusetzen. <br><br><h2>  Schritt 0: Frieren Sie den alten RPC ein </h2><br>  Zunächst haben wir den alten RPC eingefroren, um nicht auf ein sich bewegendes Ziel zu schießen.  Es veranlasste die Benutzer auch, zu Courier zu wechseln, da alle neuen Funktionen wie die Ablaufverfolgung nur in Courier-Diensten verfügbar waren. <br><br><h2>  Schritt 1: Gemeinsame Schnittstelle für alte RPC und Courier </h2><br>  Wir haben zunächst eine gemeinsame Schnittstelle für den alten RPC und Courier definiert.  Unsere Codegenerierung sollte sicherstellen, dass beide Versionen der Stubs dieser Schnittstelle entsprechen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TestServer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {  UnaryUnary(     ctx context.Context,     req *test.TestRequest) (     *test.TestResponse,     error)  ... }</code> </pre><br><h2>  Schritt 2: Migrieren Sie zur neuen Schnittstelle </h2><br>  Danach haben wir begonnen, jeden Dienst auf eine neue Schnittstelle umzustellen, während wir weiterhin den alten RPC verwendeten.  Oft waren Codeänderungen ein großer Unterschied, der alle Methoden des Dienstes und seiner Clients betraf.  Da diese Phase am problematischsten ist, wollten wir das Risiko vollständig beseitigen, indem wir jeweils nur eine Sache ändern. <br><br>  <i>Einfache Dienste mit einer geringen Anzahl von Methoden und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Recht, Fehler zu machen,</a> können gleichzeitig migriert werden, ohne unsere Warnungen zu beachten.</i> <br><br><h2>  Schritt 3: Migrieren Sie Kunden zum RPC Courier </h2><br>  Während des Migrationsprozesses haben wir begonnen, gleichzeitig alte und neue Server an verschiedenen Ports desselben Computers zu starten.  Das Wechseln der clientseitigen RPC-Implementierung erfolgte durch Ändern einer Zeile: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> -   self.client = LegacyRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>) +   self.client = CourierRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>)</code> </pre> <br>  Bitte beachten Sie, dass Sie mit diesem Modell jeweils einen Client übertragen können, beginnend mit denen mit einem niedrigeren SLA-Level. <br><br><h2>  Schritt 4: Reinigung </h2><br>       ,   ,   RPC    (               ).       —   . <br><br><h1>  Schlussfolgerungen </h1><br> , Courier —  RPC-,   ,      Dropbox. <br><br>     ,    Courier: <br><br><ol><li>  —  .           . <br></li><li>      —    ,     . <br></li><li>     ,  .     Codegen. <br></li><li>    . ,    ,   .  , :       . <br></li><li>  RPC-       —  ,     . .           . <br></li></ol><br><h1>   </h1><br> Courier,   gRPC  ,    ,      ,      . <br><br>         gRPC  Python   ,     C++  Python  Rust          .         ALTS   TLS-    (,     ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438474/">https://habr.com/ru/post/de438474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438464/index.html">SciPy, Graph-Algorithmen</a></li>
<li><a href="../de438466/index.html">Krücke für einen chinesischen Laser</a></li>
<li><a href="../de438468/index.html">Kolonie. Kapitel 23: Probefahrt</a></li>
<li><a href="../de438470/index.html">Weltweiter Umsatz im Dezember und 2018: 2 Millionen verkaufte Plug-in-Elektrofahrzeuge</a></li>
<li><a href="../de438472/index.html">Anspruchsvolle modulare Architekturumgebung in UE4</a></li>
<li><a href="../de438476/index.html">Zur Frage der Puffer (Ring)</a></li>
<li><a href="../de438478/index.html">GitLab 11.7 wurde mit Releases, mehrstufigen verschachtelten Epen und der Registrierung von NPM-Paketen veröffentlicht</a></li>
<li><a href="../de438480/index.html">Platzieren Sie es richtig: 7 ideale Orte zum Platzieren von Videoinhalten</a></li>
<li><a href="../de438482/index.html">Reputation, Arbeit und Auswanderung: Verwendung von Tools zur Unternehmensförderung zur Lösung persönlicher Probleme</a></li>
<li><a href="../de438486/index.html">Undurchdringliche Speicherkarte - Kingston microSD High Endurance ertrinken, einfrieren und in Brand setzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>