<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçü§ù‚Äçüë®üèª ü§ΩüèΩ üì∫ Kurier: Dropbox-Migration zu gRPC üîé üë©üèø‚Äçüé§ ‚òπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anmerkung des √úbersetzers 
 Die meisten modernen Softwareprodukte sind nicht monolithisch, sondern bestehen aus vielen Teilen, die miteinander interag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kurier: Dropbox-Migration zu gRPC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/438474/"><img src="https://habrastorage.org/webt/eu/p8/y-/eup8y-m8hpxc9w2qhvo1qofrmog.jpeg"><br><br><h1>  Anmerkung des √úbersetzers </h1><br>  Die meisten modernen Softwareprodukte sind nicht monolithisch, sondern bestehen aus vielen Teilen, die miteinander interagieren.  In dieser Situation ist es erforderlich, dass die Kommunikation der interagierenden Teile des Systems in einer Sprache erfolgt (obwohl diese Teile selbst in verschiedenen Programmiersprachen geschrieben und auf verschiedenen Maschinen ausgef√ºhrt werden k√∂nnen).  Um die L√∂sung dieses Problems zu vereinfachen, hilft gRPC - Open-Source-Framework von Google, das 2015 ver√∂ffentlicht wurde.  Er l√∂st sofort eine Reihe von Problemen und erlaubt: <br><br><ul><li>  Verwenden Sie die Sprache Protokollpuffer, um die Interaktion von Diensten zu beschreiben. <br></li><li>  Generieren von Programmcode basierend auf dem beschriebenen Protokoll f√ºr 11 verschiedene Sprachen sowohl f√ºr den Client-Teil als auch f√ºr den Server-Teil; <br></li><li>  Autorisierung zwischen interagierenden Komponenten implementieren; <br></li><li>  Verwenden Sie sowohl synchrone als auch asynchrone Interaktion. <br></li></ul><br>  gRPC schien mir ein ziemlich interessantes Framework zu sein, und ich war daran interessiert, die tats√§chlichen Erfahrungen von Dropbox beim Aufbau eines darauf basierenden Systems kennenzulernen.  Der Artikel enth√§lt viele Details zur Verwendung der Verschl√ºsselung, zum Aufbau eines zuverl√§ssigen, beobachtbaren und produktiven Systems sowie zum Migrationsprozess von der alten RPC-L√∂sung zur neuen. <br><br><div class="spoiler">  <b class="spoiler_title">Haftungsausschluss</b> <div class="spoiler_text">  Der Originalartikel enth√§lt keine Beschreibung von gRPC, und einige Punkte scheinen Ihnen m√∂glicherweise nicht klar zu sein.  Wenn Sie mit gRPC oder anderen √§hnlichen Frameworks (z. B. Apache Thrift) nicht vertraut sind, empfehle ich Ihnen, sich zun√§chst mit den Hauptideen vertraut zu machen (es reicht aus, zwei kleine Artikel von der offiziellen Website zu lesen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûWas ist gRPC?‚Äú</a> Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûgRPC-Konzepte‚Äú</a> ). <br><br>  Vielen Dank an Aleksey Ivanov aka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SaveTheRbtz</a> f√ºr das Schreiben des Originalartikels und die Hilfe bei der √úbersetzung schwieriger Orte. <br></div></div><a name="habracut"></a><br>  Dropbox verwaltet viele Dienste, die in verschiedenen Sprachen geschrieben sind und Millionen von Anfragen pro Sekunde bearbeiten.  Im Zentrum unserer serviceorientierten Architektur steht Courier, ein gPC-basiertes RPC-Framework.  W√§hrend der Entwicklung haben wir viel √ºber die Erweiterbarkeit von gRPC, die Leistungsoptimierung und den √úbergang vom vorherigen RPC-System gelernt. <br><br>  <i>Hinweis: Der Beitrag enth√§lt Codefragmente f√ºr Python und Go.</i>  <i>Wir verwenden auch Rust und Java.</i> <br><br><h1>  Stra√üe nach gRPC </h1><br>  Courier ist nicht das erste Dropbox-RPC-Framework.  Noch bevor wir begannen, das monolithische Python-System in separate Dienste aufzuteilen, brauchten wir eine zuverl√§ssige Basis f√ºr den Datenaustausch zwischen Diensten - insbesondere, da die Auswahl eines Frameworks langfristige Konsequenzen h√§tte. <br><br>  Zuvor experimentierte Dropbox mit verschiedenen RPC-Frameworks.  Zun√§chst hatten wir ein individuelles Protokoll f√ºr die manuelle Serialisierung und Deserialisierung.  Einige Dienste, wie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scribe-basierte Protokollierung</a> , verwendeten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Thrift</a> .  Gleichzeitig war unser Haupt-RPC-Framework ein HTTP / 1.1-Protokoll mit Nachrichten, die mit Protobuf serialisiert wurden. <br><br>  Bei der Erstellung eines Frameworks haben wir aus mehreren Optionen ausgew√§hlt.  Wir k√∂nnten Swagger (jetzt als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI bekannt</a> ) in das alte RPC-Framework <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einf√ºhren, einen neuen Standard einf√ºhren</a> oder ein auf Thrift oder gRPC basierendes Framework erstellen.  Das Hauptargument f√ºr gRPC war die M√∂glichkeit, bereits vorhandene Protobufs zu verwenden.  Auch Multiplex-HTTP / 2 und bidirektionale Daten√ºbertragung waren f√ºr unsere Aufgaben n√ºtzlich. <br><br>  <i>Hinweis: Wenn zu diesem Zeitpunkt fbthrift vorhanden w√§re, w√ºrden wir uns Thrift-L√∂sungen wahrscheinlich genauer ansehen.</i> <br><br><h1>  Was Kurier zu gRPC bringt </h1><br>  Courier ist kein RPC-Protokoll.  Es ist ein Mittel zur Integration von gRPC in eine vorhandene Infrastruktur.  Das Framework sollte mit unseren Authentifizierungs-, Autorisierungs- und Serviceerkennungstools sowie mit der Erfassung, Protokollierung und Nachverfolgung von Statistiken kompatibel sein.  Also haben wir Courier erstellt. <br><br>  <i>Obwohl wir in einigen F√§llen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bandaid</a> als gRPC-Proxy verwenden, kommunizieren die meisten unserer Dienste direkt miteinander, um die Auswirkungen von RPC auf die Latenz zu minimieren.</i> <br><br>  F√ºr uns war es wichtig, die Menge an Routinecode zu reduzieren, die geschrieben werden muss.  Da Courier als allgemeiner Rahmen f√ºr die Entwicklung von Diensten dient, enth√§lt es Funktionen, die jeder ben√∂tigt.  Die meisten von ihnen sind standardm√§√üig aktiviert und k√∂nnen √ºber Befehlszeilenargumente gesteuert werden. Einige werden mit einem Kontrollk√§stchen aktiviert. <br><br><h2>  Sicherheit: Dienstidentit√§t und gegenseitige TLS-Authentifizierung </h2><br>  Courier implementiert unseren Standardmechanismus zur Identifizierung von Diensten.  Jedem Server und Client wird ein individuelles TLS-Zertifikat zugewiesen, das von unserer eigenen Zertifizierungsstelle ausgestellt wird.  Die zertifikatcodierte pers√∂nliche Kennung, die f√ºr die gegenseitige Authentifizierung verwendet wird - der Server √ºberpr√ºft den Client, der Client √ºberpr√ºft den Server. <br><br>  In TLS, wo wir beide Seiten der Verbindung steuern, haben wir strenge Einschr√§nkungen eingef√ºhrt.  Alle internen RPCs erfordern eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PFS-</a> Verschl√ºsselung.  Die erforderliche Version von TLS ist 1.2 und h√∂her.  Wir haben auch die Anzahl der symmetrischen und asymmetrischen Algorithmen begrenzt und <i>ECDHE-ECDSA-AES128-GCM-SHA256</i> bevorzugt. <br><br>  Nach Durchlaufen der Identifizierung und Entschl√ºsselung der Anforderung pr√ºft der Server, ob der Client √ºber die erforderlichen Berechtigungen verf√ºgt.  Zugriffssteuerungslisten (ACLs) und Geschwindigkeitsbegrenzungen k√∂nnen sowohl f√ºr Dienste im Allgemeinen als auch f√ºr einzelne Methoden konfiguriert werden.  Ihre Parameter k√∂nnen auch √ºber unser Distributed File System (AFS) ge√§ndert werden.  Dank dessen k√∂nnen Servicebesitzer die Last in Sekundenschnelle fallen lassen, ohne die Prozesse neu zu starten.  Courier k√ºmmert sich um das Abonnieren von Benachrichtigungen und das Aktualisieren der Konfiguration. <br><br>  <i>Der Identit√§tsdienst ist eine globale Kennung f√ºr ACLs, Geschwindigkeitsbegrenzungen, Statistiken usw. Au√üerdem ist er kryptografisch sicher.</i> <br><br>  Hier ist ein Beispiel f√ºr die ACL-Konfiguration und die Geschwindigkeitsbegrenzung, die in unserem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">optischen Mustererkennungsdienst verwendet werden</a> : <br><br><pre><code class="plaintext hljs">limits:  dropbox_engine_ocr:    # All RPC methods.    default:      max_concurrency: 32      queue_timeout_ms: 1000      rate_acls:        # OCR clients are unlimited.        ocr: -1        # Nobody else gets to talk to us.        authenticated: 0        unauthenticated: 0</code> </pre> <br><img src="https://habrastorage.org/webt/ll/as/l_/llasl_0osxrxbboxrbjqaalb8ti.png"><br><br>  <i>Wir erw√§gen die M√∂glichkeit, auf das SVID-Format (kryptografisch verifiziertes Dokument <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SPIFFE</a> ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umzusteigen</a> , um unser Framework mit vielen Open-Source-Projekten zu kombinieren.</i> <br><br><h2>  Beobachtbarkeit: Statistik und Tracking </h2><br>  Mit nur einer Kennung k√∂nnen Sie problemlos Protokolle, Statistiken, Tracedateien und andere Daten zu Courier finden. <br><br><img src="https://habrastorage.org/webt/t_/25/3o/t_253ogfq1bizretdswvdrb_7g0.png"><br><br>  W√§hrend der Codegenerierung wird die Statistiksammlung f√ºr jeden Dienst und jede Methode sowohl auf der Clientseite als auch auf der Serverseite hinzugef√ºgt.  Serverseitige Statistiken werden durch die Client-ID unterteilt.  In der Standardkonfiguration erhalten Sie detaillierte Daten zu Last, Fehlern und Verz√∂gerungszeit f√ºr jeden Dienst mit Courier. <br><br><img src="https://habrastorage.org/webt/g1/6g/_1/g16g_1z72oxaxwwvasrjhznfltk.png"><br><br>  Die Kurierstatistik enth√§lt Daten zur Verf√ºgbarkeit und Latenz auf der Clientseite sowie zur Anzahl der Anforderungen und zur Warteschlangengr√∂√üe auf der Serverseite.  Es gibt andere n√ºtzliche Diagramme, insbesondere Histogramme der Antwortzeit f√ºr jede Methode und der Zeit der TLS-Handshakes f√ºr jeden Client. <br><br>  <i>Einer der Vorteile unserer Codegenerierung ist die M√∂glichkeit der statischen Initialisierung von Datenstrukturen wie Histogrammen und Trace-Diagrammen.</i>  <i>Dies minimiert die Auswirkungen auf die Leistung.</i> <br><br><img src="https://habrastorage.org/webt/p7/6-/fv/p76-fvobtszsgtu2g2tlmwfwlyk.png"><br><br>  Das alte RPC-System hat nur <i>request_id</i> √ºber die API verteilt.  Dies erm√∂glichte es, Daten aus den Protokollen verschiedener Dienste zu kombinieren.  Bei Courier haben wir eine API eingef√ºhrt, die auf einer Teilmenge der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenTracing-</a> Spezifikationen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">basiert</a> .  Wir haben unsere eigenen Bibliotheken auf der Client-Seite geschrieben und auf der Server-Seite eine L√∂sung implementiert, die auf Cassandra und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jaeger</a> basiert. <br><br><img src="https://habrastorage.org/webt/dk/hv/iq/dkhviqgdiem3itipi7x87tri_i8.png"><br><br>  Durch die Ablaufverfolgung k√∂nnen wir zur Laufzeit Abh√§ngigkeitsdiagramme eines Dienstes erstellen.  Auf diese Weise k√∂nnen Ingenieure alle transitiven Abh√§ngigkeiten eines bestimmten Dienstes erkennen.  Dar√ºber hinaus ist die Funktion n√ºtzlich, um unerw√ºnschte Abh√§ngigkeiten nach der Bereitstellung zu verfolgen. <br><br><h2>  Zuverl√§ssigkeit: Fristen und Unterbrechung </h2><br>  Courier bietet einen zentralen Ort, um gemeinsame Clientfunktionen (z. B. Zeit√ºberschreitungen) in verschiedenen Sprachen zu implementieren.  Wir haben nach und nach verschiedene Funktionen hinzugef√ºgt, die h√§ufig auf den Ergebnissen einer ‚Äûposthumen‚Äú Analyse aufkommender Probleme basieren. <br><br><h3>  Fristen </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jede gRPC-Anfrage hat eine Frist</a> , die das Client-Timeout angibt.  Da Courier-Stubs bekannte Metadaten automatisch verteilen, wird die Anforderungsfrist sogar au√üerhalb der API √ºbertragen.  Innerhalb des Prozesses erhalten Fristen eine native Anzeige.  In Go werden sie beispielsweise durch das Ergebnis von <i>context.Context</i> aus der <i>WithDeadline-</i> Methode dargestellt. <br><br>  Tats√§chlich konnten wir ganze Klassen von Zuverl√§ssigkeitsproblemen beheben, indem wir die Ingenieure dazu zwangen, Fristen f√ºr die Definition der geeigneten Services festzulegen. <br><br>  Dieser Ansatz geht sogar √ºber RPC hinaus.  Zum Beispiel serialisiert unser ORM MySQL einen RPC-Kontext zusammen mit einer Frist in einem SQL-Abfragekommentar.  Unser SQL-Proxy kann Kommentare analysieren und Abfragen "t√∂ten", wenn die Frist abgelaufen ist.  Als Bonus beim Debuggen von Datenbankaufrufen haben wir eine SQL-Abfrage, die an eine bestimmte RPC-Abfrage gebunden ist. <br><br><h3>  Trennen </h3><br>  Ein weiteres h√§ufiges Problem, mit dem Clients des vorherigen RPC-Systems konfrontiert waren, war die Implementierung des Algorithmus f√ºr individuelle exponentielle Verz√∂gerungen und Schwankungen bei wiederholter Anforderung. <br><br>  Wir haben versucht, eine intelligente L√∂sung f√ºr das Problem der Trennung in Courier zu finden, beginnend mit der Implementierung des LIFO-Puffers (last in, first out) zwischen dem Dienst und dem Aufgabenpool. <br><br><img src="https://habrastorage.org/webt/th/sr/t0/thsrt0kbgxgnexrr9figp9ymg_a.png"><br><br>  Im Falle einer √úberlastung wird LIFO automatisch getrennt.  Die Warteschlange, die wichtig ist, ist nicht nur durch die Gr√∂√üe, sondern auch <b>durch die Zeit begrenzt</b> (die Anforderung kann nur eine bestimmte Zeit in der Warteschlange verbringen). <br><br>  <i>Minus LIFO - √Ñnderung der Reihenfolge der Bearbeitung von Anfragen.</i>  <i>Wenn Sie die urspr√ºngliche Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beibehalten</a> m√∂chten, verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CoDel</a> .</i>  <i>Auch dort besteht die M√∂glichkeit der Trennung, und die Reihenfolge der Verarbeitungsanforderungen bleibt gleich.</i> <br><br><img src="https://habrastorage.org/webt/7g/w_/ud/7gw_udkbrsesseak2xrxaucw7fi.png"><br><br><h2>  Selbstbeobachtung: Debuggen von Endpunkten </h2><br>  Obwohl Debugging-Endpunkte nicht direkt Teil von Courier sind, werden sie in Dropbox h√§ufig verwendet und sind zu n√ºtzlich, um nicht erw√§hnt zu werden. <br><br>  <i>Aus Sicherheitsgr√ºnden k√∂nnen Sie sie an einem separaten Port oder an einem Unix-Socket √∂ffnen (um den Zugriff mithilfe von Dateiberechtigungen zu steuern).</i>  <i>Sie sollten auch die gegenseitige TLS-Authentifizierung in Betracht ziehen, mit der Entwickler ihre Zertifikate f√ºr den Zugriff auf Endpunkte bereitstellen m√ºssen (haupts√§chlich nicht nur schreibgesch√ºtzt).</i> <br><br><h3>  Ausf√ºhrung </h3><br>  Die M√∂glichkeit, den Status eines Dienstes w√§hrend seines Betriebs zu analysieren, ist f√ºr das Debuggen sehr n√ºtzlich.  Auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">dynamische Speicher- und CPU-Profile kann beispielsweise √ºber HTTP- oder gRPC-Endpunkte zugegriffen werden</a> . <br><br>  <i>Wir planen, diese M√∂glichkeit bei der kanarischen √úberpr√ºfung zu nutzen, um die Suche nach dem Unterschied zwischen der alten und der neuen Version des Codes zu automatisieren.</i> <br><br>  Endpunkte erm√∂glichen es, den Status eines Dienstes zur Laufzeit zu √§ndern.  Insbesondere Golang-basierte Dienste k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GCPercent</a> dynamisch konfigurieren. <br><br><h3>  Die Bibliothek </h3><br>  Der automatische Export bibliotheksspezifischer Daten als RPC-Endpunkt kann f√ºr Bibliotheksentwickler hilfreich sein.  Beispielsweise kann die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Malloc-</a> Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">interne Statistiken in einen Speicherauszug sichern</a> .  Ein weiteres Beispiel: Ein Debugging-Endpunkt kann den Grad der Dienstprotokollierung im laufenden Betrieb √§ndern. <br><br><h3>  Rpc </h3><br>  Nat√ºrlich ist die Fehlerbehebung in verschl√ºsselten und verschl√ºsselten Protokollen nicht einfach.  Daher ist es eine gute Idee, so viele Tools wie m√∂glich auf RPC-Ebene einzuf√ºhren.  Ein Beispiel f√ºr eine solche introspektive API <a href="">ist die Channelz-L√∂sung</a> . <br><br><h3>  Anwendungsebene </h3><br>  Es kann auch n√ºtzlich sein, Optionen auf Anwendungsebene zu lernen.  Ein gutes Beispiel ist ein Endpunkt mit allgemeinen Informationen zur Anwendung (mit einem Hash von Quell- oder Assemblydateien, einer Befehlszeile usw.).  Es kann von einem Orchestrierungssystem verwendet werden, um die Integrit√§t bei der Bereitstellung eines Dienstes zu √ºberpr√ºfen. <br><br><h1>  Leistungsoptimierung </h1><br>  Durch die Erweiterung unseres gRPC-Frameworks auf den erforderlichen Ma√üstab haben wir einige Engp√§sse festgestellt, die f√ºr Dropbox spezifisch sind. <br><br><h3>  Ressourcenverbrauch von TLS-Handshakes </h3><br>  In Diensten, die aufgrund von TLS-Handshakes viele Beziehungen bedienen, kann die kombinierte CPU-Auslastung sehr schwerwiegend sein (insbesondere beim Neustart eines beliebten Dienstes). <br><br>  Um die Leistung beim Signieren zu verbessern, haben wir die Schl√ºsselpaare RSA-2048 durch die ECDSA P-256 ersetzt.  Hier sind Beispiele f√ºr ihre Leistung (Hinweis: Mit RSA ist die Signatur√ºberpr√ºfung schneller). <br><br>  <b>RSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'RSA 2048' Did ... RSA 2048 signing operations in ..............  (1527.9 ops/sec) Did ... RSA 2048 verify (same key) operations in .... (37066.4 ops/sec) Did ... RSA 2048 verify (fresh key) operations in ... (25887.6 ops/sec)</code> </pre> <br>  <b>ECDSA:</b> <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'ECDSA P-256' Did ... ECDSA P-256 signing operations in ... (40410.9 ops/sec) Did ... ECDSA P-256 verify operations in .... (17037.5 ops/sec)</code> </pre><br>  Da die √úberpr√ºfung mit RSA-2048 etwa dreimal schneller ist als mit ECDSA P-256, k√∂nnen Sie RSA f√ºr Root- und Endzertifikate ausw√§hlen, um die Betriebsgeschwindigkeit zu erh√∂hen.  Unter dem Gesichtspunkt der Sicherheit ist jedoch nicht alles so einfach: Sie erstellen Ketten aus verschiedenen kryptografischen Grundelementen, und daher ist die Ebene der resultierenden Sicherheitsparameter am niedrigsten.  Wenn Sie die Leistung verbessern m√∂chten, empfehlen wir, keine Zertifikate der Version RSA-4096 (und h√∂her) als Root- und Endzertifikate zu verwenden. <br><br>  Wir haben auch festgestellt, dass die Auswahl einer TLS-Bibliothek (und von Kompilierungsflags) erhebliche Auswirkungen auf die Leistung und die Sicherheit hat.  Vergleichen Sie beispielsweise den auf macOS X Mojave aufgebauten LibreSSL mit dem selbstgeschriebenen OpenSSL auf derselben Hardware. <br><br>  <b>LibreSSL 2.6.4:</b> <br><br><pre> <code class="plaintext hljs">~ openssl speed rsa2048 LibreSSL 2.6.4 ...                 sign verify sign/s verify/s rsa 2048 bits 0.032491s 0.001505s     30.8 664.3</code> </pre> <br>  <b>OpenSSL 1.1.1a:</b> <br><br><pre> <code class="plaintext hljs"> ~ openssl speed rsa2048 OpenSSL 1.1.1a  20 Nov 2018 ...                 sign verify sign/s verify/s rsa 2048 bits 0.000992s 0.000029s   1208.0 34454.8</code> </pre> <br>  Der schnellste Weg, einen TLS-Handshake zu erstellen, besteht darin, ihn √ºberhaupt nicht zu erstellen!  Wir haben die Unterst√ºtzung f√ºr die Wiederaufnahme der Sitzung in gRPC-Core und gRPC-Python aufgenommen, wodurch die Belastung der CPU w√§hrend der Bereitstellung verringert wird. <br><br><h3>  Die Verschl√ºsselung ist kosteng√ºnstig </h3><br>  Viele glauben f√§lschlicherweise, dass Verschl√ºsselung teuer ist.  Selbst die einfachsten modernen Computer f√ºhren fast sofort eine symmetrische Verschl√ºsselung durch.  Ein Standardprozessor kann Daten mit einer Geschwindigkeit von 40 Gbit / s pro Kern verschl√ºsseln und authentifizieren: <br><br><pre> <code class="plaintext hljs">~/c0d3/boringssl bazel run -- //:bssl speed -filter 'AES' Did ... AES-128-GCM (8192 bytes) seal operations in ... 4534.4 MB/s</code> </pre> <br>  Trotzdem mussten wir gRPC f√ºr unsere Speicherbl√∂cke konfigurieren, die mit einer Geschwindigkeit von 50 Gbit / s betrieben wurden.  Wir haben festgestellt, dass es wichtig ist, die Anzahl der <i>Speichervorg√§nge</i> zu minimieren, wenn die Verschl√ºsselungsgeschwindigkeit ungef√§hr der <i>Kopiergeschwindigkeit entspricht.</i>  Dar√ºber hinaus haben wir einige √Ñnderungen an gRPC selbst vorgenommen. <br><br>  <i>Durch authentifizierte und verschl√ºsselte Protokolle wurden viele unangenehme Probleme vermieden (z. B. Datenbesch√§digung durch den Prozessor, DMA oder das Netzwerk).</i>  <i>Auch wenn Sie gRPC nicht verwenden, empfehlen wir die Verwendung von TLS f√ºr interne Kontakte.</i> <br><br><h2>  Datenkan√§le mit hoher Latenz (BDP) </h2><br>  Anmerkung des √úbersetzers: Der urspr√ºngliche Untertitel verwendete den Begriff <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bandbreitenverz√∂gerungsprodukt</a> , f√ºr das keine etablierte √úbersetzung ins Russische vorliegt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Dropbox-Backbone-Netzwerk umfasst viele Rechenzentren</a> .  Manchmal m√ºssen Knoten in verschiedenen Regionen √ºber RPC kommunizieren, beispielsweise zur Replikation.  Bei Verwendung von TCP ist der Systemkern f√ºr die Begrenzung der Datenmenge verantwortlich, die in einer bestimmten Verbindung √ºbertragen wird (innerhalb von / <i>proc / sys / net / ipv4 / tcp_ {r, w} mem</i> ), obwohl gRPC auf Basis von HTTP / 2 √ºber ein eigenes Tool verf√ºgt Flusskontrolle.  Die Obergrenze von BDP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in grpc-go ist streng auf 16 MB begrenzt</a> , was einen Engpass ausl√∂sen kann. <br><br><h2>  net.Server Golang oder grpc.Server </h2><br>  Zun√§chst haben wir in unserem Go-Code HTTP / 1.1 und gRPC mit einem einzigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/">net.Server unterst√ºtzt</a> .  Die L√∂sung war im Hinblick auf die Pflege des Programmcodes sinnvoll, funktionierte jedoch √ºberhaupt nicht einwandfrei.  Durch die Verteilung von HTTP / 1.1 und gRPC auf Server und die Migration von gRPC auf grpc.Server wurden die Kurierbandbreite und die Speichernutzung erheblich verbessert. <br><br><h2>  Golang / Protobuf oder Gogo / Protobuf </h2><br>  Der Wechsel zu gRPC kann die Kosten f√ºr das Marshalling und das Unmarshaling erh√∂hen.  Bei Go-Code konnten wir die CPU-Auslastung von Courier-Servern durch den Wechsel zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gogo / protobuf</a> erheblich reduzieren. <br><br>  <i>Wie immer war der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbergang zu Gogo / Protobuf mit einigen Bedenken verbunden</a> , aber wenn Sie die Funktionalit√§t angemessen einschr√§nken, sollte es keine Probleme geben.</i> <br><br><h1>  Implementierungsdetails </h1><br>  In diesem Abschnitt werden wir tiefer in das Courier-Ger√§t eindringen, Protobuf-Schemata und Beispiele f√ºr Stubs aus verschiedenen Sprachen betrachten.  Alle Beispiele stammen aus dem Testdienst, den wir beim Testen der Courier-Integration verwendet haben. <br><br><h2>  Servicebeschreibung </h2><br>  Schauen Sie sich einen Auszug aus der Testdienstdefinition an: <br><br><pre> <code class="plaintext hljs">service Test {   option (rpc_core.service_default_deadline_ms) = 1000;   rpc UnaryUnary(TestRequest) returns (TestResponse) {       option (rpc_core.method_default_deadline_ms) = 5000;   }   rpc UnaryStream(TestRequest) returns (stream TestResponse) {       option (rpc_core.method_no_deadline) = true;   }   ... }</code> </pre> <br>  Wie oben angegeben, ist f√ºr alle Kuriermethoden eine Frist erforderlich.  Mit der folgenden Option k√∂nnen Sie die Frist f√ºr den gesamten Service festlegen: <br><br><pre> <code class="plaintext hljs">option (rpc_core.service_default_deadline_ms) = 1000;</code> </pre> <br>  Gleichzeitig kann jede Methode auf ihre eigene Frist eingestellt werden, wodurch die Frist f√ºr den gesamten Dienst (falls vorhanden) aufgehoben wird: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_default_deadline_ms) = 5000;</code> </pre> <br>  In seltenen F√§llen, in denen die Frist nicht sinnvoll ist (z. B. beim Verfolgen einer Ressource), kann der Entwickler sie deaktivieren: <br><br><pre> <code class="plaintext hljs">option (rpc_core.method_no_deadline) = true;</code> </pre> <br>  Dar√ºber hinaus sollte die Servicebeschreibung eine detaillierte API-Dokumentation enthalten, m√∂glicherweise mit Verwendungsbeispielen. <br><br><h2>  Stub Generation </h2><br>  Um mehr Flexibilit√§t zu bieten, generiert Courier seine eigenen Stubs, ohne sich auf die von gRPC bereitgestellte Interceptor-Funktionalit√§t zu verlassen (mit Ausnahme von Java, in dem die Interceptor-API √ºber ausreichende Leistung verf√ºgt).  Vergleichen wir unsere Stubs mit den Standard-Golang-Stubs. <br><br>  So sehen die Standard-gRPC-Server-Stubs aus: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_Handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, ctx context.Context, dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {       in := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(TestRequest)       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := dec(in); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err       }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> interceptor == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, in)       }       info := &amp;grpc.UnaryServerInfo{               Server: srv,               FullMethod: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,       }       handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> {               <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> srv.(TestServer).UnaryUnary(ctx, req.(*TestRequest))       }       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interceptor(ctx, in, info, handler) }</code> </pre> <br>  Die gesamte Verarbeitung erfolgt im Inneren: Dekodieren von Protobuf, Starten von Interceptors (siehe die <code>interceptor</code> Variable im Code), Starten des UnaryUnary-Handlers. <br><br>  Schauen Sie sich jetzt die Kurierstubs an: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> _</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_UnaryUnary_dbxHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       srv </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       ctx context.Context,       dec </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function">,       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interceptor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grpc</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryServerInterceptor</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(       </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{},       error)</span></span></span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()       impl := srv.(*dbxTestServerImpl)       metadata := impl.testUnaryUnaryMetadata       ctx = metadata.SetupContext(ctx)       clientId = client_info.ClientId(ctx)       stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)       stats.TotalCount.Inc()       req := &amp;processor.UnaryUnaryRequest{               Srv: srv,               Ctx: ctx,               Dec: dec,               Interceptor: interceptor,               RpcStats: stats,               Metadata: metadata,               FullMethodPath: <span class="hljs-string"><span class="hljs-string">"/test.Test/UnaryUnary"</span></span>,               Req: &amp;test.TestRequest{},               Handler: impl._UnaryUnary_internalHandler,               ClientId: clientId,               EnqueueTime: time.Now(),       }       metadata.WorkPool.Process(req).Wait()       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> req.Resp, req.Err }</code> </pre> <br>  Hier gibt es ziemlich viel Code, also analysieren wir ihn. <br><br>  Zun√§chst verschieben wir den Aufruf an den Panic Handler, der f√ºr die automatische Erfassung von Fehlern verantwortlich ist.  Auf diese Weise k√∂nnen wir alle nicht erfassten Ausnahmen im zentralen Repository f√ºr die sp√§tere Aggregation und Berichterstellung erfassen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> processor.PanicHandler()</code> </pre><br>  Ein weiterer Grund, warum wir unseren eigenen Panik-Handler ausf√ºhren, besteht darin, sicherzustellen, dass die Anwendung abst√ºrzt, wenn ein Fehler auftritt.  Der Standard-Golang / Net-HTTP-Handler ignoriert in diesem Fall das Problem und bedient weiterhin neue Anforderungen (auch besch√§digt und inkonsistent). <br><br>  Dann geben wir den Kontext weiter und definieren die Werte basierend auf den Metadaten der eingehenden Anforderung neu: <br><br><pre> <code class="go hljs">ctx = metadata.SetupContext(ctx) clientId = client_info.ClientId(ctx)</code> </pre> <br>  Au√üerdem erstellen wir serverseitige Client-Statistiken f√ºr eine detailliertere Aggregation (und speichern sie zur Steigerung der Effizienz). <br><br><pre> <code class="go hljs">stats := metadata.StatsMap.GetOrCreatePerClientStats(clientId)</code> </pre><br>  Diese Zeile erstellt w√§hrend der Ausf√ºhrung Statistiken f√ºr jeden Client (dh eine TLS-Kennung).  Wir haben auch Statistiken zu allen Methoden f√ºr jeden Service.  Da der Stub-Generator w√§hrend der Codegenerierung auf alle Methoden zugreifen kann, k√∂nnen wir sie vorher statisch erstellen, um eine Verlangsamung des Programms zu vermeiden. <br><br>  Danach erstellen wir eine Anforderungsstruktur, √ºbertragen sie in den Aufgabenpool und warten auf die Ausf√ºhrung: <br><br><pre> <code class="go hljs">req := &amp;processor.UnaryUnaryRequest{       Srv:        srv,       Ctx:        ctx,       Dec:        dec,       Interceptor:    interceptor,       RpcStats:       stats,       Metadata:       metadata,       ... } metadata.WorkPool.Process(req).Wait()</code> </pre> <br>  Bitte beachten Sie, dass wir zu diesem Zeitpunkt weder Protobuf dekodiert noch den Interceptor gestartet haben.  Zuvor m√ºssen der Zugriffspool, die Priorisierung und die Begrenzung der Anzahl der ausgef√ºhrten Anforderungen den Aufgabenpool durchlaufen. <br><br>  <i>Beachten Sie, dass die gRPC-Bibliothek die TAP-Schnittstelle unterst√ºtzt, mit der Sie Anforderungen mit einer enormen Geschwindigkeit abfangen k√∂nnen.</i>  <i>Die Schnittstelle bietet die Infrastruktur f√ºr den Aufbau effektiver Geschwindigkeitsbegrenzer bei minimalem Ressourcenverbrauch.</i> <br><br><h2>  Spezifische Fehlercodes f√ºr verschiedene Anwendungen </h2><br>  Mit unserem Stub-Generator k√∂nnen Entwickler mithilfe spezieller Optionen auch anwendungsspezifische Fehlercodes zuweisen: <br><br><pre> <code class="plaintext hljs">enum ErrorCode { option (rpc_core.rpc_error) = true; UNKNOWN = 0; NOT_FOUND = 1 [(rpc_core.grpc_code)="NOT_FOUND"]; ALREADY_EXISTS = 2 [(rpc_core.grpc_code)="ALREADY_EXISTS"]; ... STALE_READ = 7 [(rpc_core.grpc_code)="UNAVAILABLE"]; SHUTTING_DOWN = 8 [(rpc_core.grpc_code)="CANCELLED"]; }</code> </pre> <br>  Sowohl gRPC- als auch Anwendungsfehler breiten sich innerhalb des Dienstes aus, und an der API-Grenze werden alle Fehler durch UNBEKANNT ersetzt.  Auf diese Weise k√∂nnen wir vermeiden, das Problem auf andere Dienste zu √ºbertragen, was zu einer √Ñnderung ihrer Semantik f√ºhren kann. <br><br><h2>  Python-√Ñnderungen </h2><br>  Python-Stubs f√ºgen allen Courier-Handlern einen expliziten Kontextparameter hinzu: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.context <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Context <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dropbox.proto.test.service_pb2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> (       TestRequest,       TestResponse, ) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Protocol <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCourierClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Protocol)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnaryUnary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(           self,           ctx, # type: Context           request, # type: TestRequest           )</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># type: (...) -&gt; TestResponse       ...</span></span></code> </pre> <br>  Anfangs sah es seltsam aus, aber im Laufe der Zeit gew√∂hnten sich die Entwickler daran, <i>ctx</i> genau wie fr√ºher <i>selbst</i> zu explizieren. <br><br>  Bitte beachten Sie, dass unsere Stubs vollst√§ndig f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mypy</a> typisiert <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sind</a> , was bei gr√∂√üeren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Umgestaltungen</a> ausgeglichen wird.  Dar√ºber hinaus wird die Integration mit einigen IDEs (z. B. PyCharm) vereinfacht. <br><br>  Wir folgen weiterhin dem Trend zur statischen Typisierung und f√ºgen den Protokollen selbst mypy-Anmerkungen hinzu: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestMessage</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Message)</span></span></span><span class="hljs-class">:</span></span>   field: int   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,       field : Optional[int] = ...,       )</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">None</span></span></span><span class="hljs-function">:</span></span> ...   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FromString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: bytes)</span></span></span><span class="hljs-function"> -&gt; TestMessage:</span></span> ...</code> </pre> <br>  Durch diese Anmerkungen werden viele h√§ufig auftretende Fehler vermieden, z. B. das Zuweisen des Werts " <i>Keine" zu einem</i> Feld vom Typ " <i>Zeichenfolge"</i> <i>.</i> <br><br>  Dieser Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist hier verf√ºgbar</a> . <br><br><h1>  Migrationsprozess </h1><br>  Das Erstellen eines neuen RPC-Stacks ist keine leichte Aufgabe, steht jedoch nicht einmal neben dem Prozess eines vollst√§ndigen √úbergangs, wenn Sie die Komplexit√§t des Betriebs betrachten.  Aus diesem Grund haben wir versucht, Entwicklern den Wechsel vom alten RPC zu Courier so einfach wie m√∂glich zu gestalten.  Da die Migration h√§ufig mit Fehlern einhergeht, haben wir uns entschlossen, sie schrittweise umzusetzen. <br><br><h2>  Schritt 0: Frieren Sie den alten RPC ein </h2><br>  Zun√§chst haben wir den alten RPC eingefroren, um nicht auf ein sich bewegendes Ziel zu schie√üen.  Es veranlasste die Benutzer auch, zu Courier zu wechseln, da alle neuen Funktionen wie die Ablaufverfolgung nur in Courier-Diensten verf√ºgbar waren. <br><br><h2>  Schritt 1: Gemeinsame Schnittstelle f√ºr alte RPC und Courier </h2><br>  Wir haben zun√§chst eine gemeinsame Schnittstelle f√ºr den alten RPC und Courier definiert.  Unsere Codegenerierung sollte sicherstellen, dass beide Versionen der Stubs dieser Schnittstelle entsprechen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TestServer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> {  UnaryUnary(     ctx context.Context,     req *test.TestRequest) (     *test.TestResponse,     error)  ... }</code> </pre><br><h2>  Schritt 2: Migrieren Sie zur neuen Schnittstelle </h2><br>  Danach haben wir begonnen, jeden Dienst auf eine neue Schnittstelle umzustellen, w√§hrend wir weiterhin den alten RPC verwendeten.  Oft waren Code√§nderungen ein gro√üer Unterschied, der alle Methoden des Dienstes und seiner Clients betraf.  Da diese Phase am problematischsten ist, wollten wir das Risiko vollst√§ndig beseitigen, indem wir jeweils nur eine Sache √§ndern. <br><br>  <i>Einfache Dienste mit einer geringen Anzahl von Methoden und dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Recht, Fehler zu machen,</a> k√∂nnen gleichzeitig migriert werden, ohne unsere Warnungen zu beachten.</i> <br><br><h2>  Schritt 3: Migrieren Sie Kunden zum RPC Courier </h2><br>  W√§hrend des Migrationsprozesses haben wir begonnen, gleichzeitig alte und neue Server an verschiedenen Ports desselben Computers zu starten.  Das Wechseln der clientseitigen RPC-Implementierung erfolgte durch √Ñndern einer Zeile: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClient</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> -   self.client = LegacyRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>) +   self.client = CourierRPCClient(<span class="hljs-string"><span class="hljs-string">'myservice'</span></span>)</code> </pre> <br>  Bitte beachten Sie, dass Sie mit diesem Modell jeweils einen Client √ºbertragen k√∂nnen, beginnend mit denen mit einem niedrigeren SLA-Level. <br><br><h2>  Schritt 4: Reinigung </h2><br>       ,   ,   RPC    (               ).       ‚Äî   . <br><br><h1>  Schlussfolgerungen </h1><br> , Courier ‚Äî  RPC-,   ,      Dropbox. <br><br>     ,    Courier: <br><br><ol><li>  ‚Äî  .           . <br></li><li>      ‚Äî    ,     . <br></li><li>     ,  .     Codegen. <br></li><li>    . ,    ,   .  , :       . <br></li><li>  RPC-       ‚Äî  ,     . .           . <br></li></ol><br><h1>   </h1><br> Courier,   gRPC  ,    ,      ,      . <br><br>         gRPC  Python   ,     C++  Python  Rust          .         ALTS   TLS-    (,     ). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438474/">https://habr.com/ru/post/de438474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438464/index.html">SciPy, Graph-Algorithmen</a></li>
<li><a href="../de438466/index.html">Kr√ºcke f√ºr einen chinesischen Laser</a></li>
<li><a href="../de438468/index.html">Kolonie. Kapitel 23: Probefahrt</a></li>
<li><a href="../de438470/index.html">Weltweiter Umsatz im Dezember und 2018: 2 Millionen verkaufte Plug-in-Elektrofahrzeuge</a></li>
<li><a href="../de438472/index.html">Anspruchsvolle modulare Architekturumgebung in UE4</a></li>
<li><a href="../de438476/index.html">Zur Frage der Puffer (Ring)</a></li>
<li><a href="../de438478/index.html">GitLab 11.7 wurde mit Releases, mehrstufigen verschachtelten Epen und der Registrierung von NPM-Paketen ver√∂ffentlicht</a></li>
<li><a href="../de438480/index.html">Platzieren Sie es richtig: 7 ideale Orte zum Platzieren von Videoinhalten</a></li>
<li><a href="../de438482/index.html">Reputation, Arbeit und Auswanderung: Verwendung von Tools zur Unternehmensf√∂rderung zur L√∂sung pers√∂nlicher Probleme</a></li>
<li><a href="../de438486/index.html">Undurchdringliche Speicherkarte - Kingston microSD High Endurance ertrinken, einfrieren und in Brand setzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>