<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèø üë®‚Äçüî¨ üë®üèº‚Äçüç≥ Faltungsschicht: Techniken zur Optimierung der Matrixmultiplikation üö£üèº üë®üèª‚Äç‚öïÔ∏è ‚úãüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Dieser Artikel ist eine Fortsetzung einer Reihe von Artikeln , die die zugrunde liegenden Algorithmen beschreiben. 
 Synet ist ein Framew...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Faltungsschicht: Techniken zur Optimierung der Matrixmultiplikation</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448436/"><h2>  Einf√ºhrung </h2><br>  Dieser Artikel ist eine Fortsetzung einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Artikeln</a> , die die zugrunde liegenden Algorithmen beschreiben. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Synet</a> ist ein Framework zum Starten von vorab trainierten neuronalen Netzwerken auf der CPU. <br><br>  Wenn Sie sich die Verteilung der Prozessorzeit ansehen, die f√ºr die direkte Signalausbreitung in neuronalen Netzen aufgewendet wird, stellt sich heraus, dass h√§ufig mehr als 90% aller Zeit in Faltungsschichten verbracht wird.  Wenn wir also einen schnellen Algorithmus f√ºr ein neuronales Netzwerk erhalten wollen, brauchen wir zun√§chst einen schnellen Algorithmus f√ºr eine Faltungsschicht.  In diesem Artikel m√∂chte ich Methoden zur Optimierung der direkten Signalausbreitung in einer Faltungsschicht beschreiben.  Und ich m√∂chte mit den am weitesten verbreiteten Methoden beginnen, die auf der Matrixmultiplikation basieren.  Ich werde versuchen, die Pr√§sentation in der zug√§nglichsten Form zu halten, damit der Artikel nicht nur f√ºr Fachleute (sie wissen bereits alles dar√ºber) interessant ist, sondern auch f√ºr einen gr√∂√üeren Leserkreis.  Ich gebe nicht vor, eine vollst√§ndige Bewertung zu sein, daher sind Kommentare und Erg√§nzungen nur willkommen. <br><a name="habracut"></a><br><h2>  Faltungsschichtoptionen </h2><br>  Ich m√∂chte die Beschreibung mit einer Beschreibung der Parameter beginnen, die sich in der Faltungsschicht befinden.  Experten k√∂nnen diesen Abschnitt sicher √ºberspringen. <br><br><h4>  Eingabe- und Ausgabebildgr√∂√üen </h4><br>  Zun√§chst wird eine Faltungsschicht durch ein Eingabe- und ein Ausgabebild charakterisiert, die durch die folgenden Parameter gekennzeichnet sind: <br><br><img src="https://habrastorage.org/webt/tg/-_/c1/tg-_c1xgj4vbobu3_7l8rcp5u_0.png" alt="Bild"><br><br><ul><li>  <b>srcC / dstC</b> - Die Anzahl der Kan√§le im Eingabe- und Ausgabebild.  Alternative Notation: <b>C / D.</b> </li><li>  <b>srcH / dstH</b> - H√∂he des Eingabe- und Ausgabebildes.  Alternative Bezeichnung: <b>H.</b> </li><li>  <b>srcW / dstW</b> - Breite des Eingabe- und Ausgabebildes.  Alternative Bezeichnung: <b>W.</b> </li><li>  <b>Stapel</b> - die Anzahl der Eingabe- (Ausgabe-) Bilder - Die Ebene kann einen ganzen Stapel von Bildern gleichzeitig verarbeiten.  Alternative Bezeichnung: <b>N.</b> </li></ul><br><h4>  Faltungskerngr√∂√üen </h4><br>  Die Faltungsoperation ist von Natur aus eine gewichtete Summe einer bestimmten Nachbarschaft eines bestimmten Punktes im Bild.  Die Gr√∂√üe des Faltungskerns - charakterisiert die Gr√∂√üe dieser Nachbarschaft und wird durch zwei Parameter beschrieben: <br><br><img src="https://habrastorage.org/webt/2y/kj/z5/2ykjz5xeebrq6p2dmhrqxxk1pqu.png" alt="Bild"><br><br><ul><li>  <b>kernelY</b> ist die H√∂he des Faltungskerns.  Alternative Bezeichnung: <b>Y.</b> </li><li>  <b>kernelX</b> ist die Breite des Faltungskerns.  Alternative Bezeichnung: <b>X.</b> </li></ul><br>  Die h√§ufigsten Windungen mit einer Kernelgr√∂√üe von <b>1x1</b> und <b>3x3</b> .  Gr√∂√üen <b>5x5</b> und <b>7x7</b> sind viel seltener.  Manchmal werden auch gro√üe Faltungsgr√∂√üen sowie Faltungen mit einem anderen Kern als Quadrat gefunden, aber dies ist exotischer. <br><br><h4>  Faltungsschritt </h4><br>  Ein weiterer wichtiger Parameter ist der Faltungsschritt: <br><br><img src="https://habrastorage.org/webt/ya/wn/qb/yawnqbziijnefknaqbjalqkzzgu.png" alt="Bild"><br><br><ul><li>  Schritt <b>Y</b> ist der vertikale Faltungsschritt. </li><li>  <b>strideX</b> - horizontaler Faltungsschritt. </li></ul><br>  Wenn sich der Schritt von <b>1x1 unterscheidet</b> , z. B. - <b>2x2</b> , ist das Ausgabebild halb so gro√ü (die Faltung wird nur in der N√§he von geraden Punkten berechnet). <br><br><h4>  Dehnung der Faltung </h4><br>  Der Faltungskern kann mithilfe der folgenden Parameter gedehnt werden (die effektive Fenstergr√∂√üe erh√∂hen, w√§hrend die Anzahl der Operationen beibehalten wird): <br><br><img src="https://habrastorage.org/webt/vb/sv/ev/vbsvevdr2qioxy8htvhxwzx2e4k.png" alt="Bild"><br><br><ul><li>  <b>dilationY</b> - vertikale Dehnung der Faltung. </li><li>  <b>dilationX</b> - horizontale Dehnung der Faltung. </li></ul><br>  Es ist erw√§hnenswert, dass F√§lle mit einer anderen Dehnung als <b>1x1</b> eher selten auftreten (so etwas habe ich in meiner Karriere noch nie erlebt). <br><br><h4>  Eingabebild auff√ºllen </h4><br>  Wenn Sie eine Faltung mit einem Fenster anwenden, das sich von einem einzelnen auf das Bild unterscheidet, ist das Ausgabebild um den <b>Kernel-1-</b> Betrag kleiner.  Das B√ºndel ‚Äûfrisst‚Äú sozusagen die R√§nder.  Um die Bildgr√∂√üe beizubehalten, wird das Eingabebild h√§ufig mit Nullen an den R√§ndern aufgef√ºllt.  Daf√ºr sind vier weitere Parameter verantwortlich: <br><br><img src="https://habrastorage.org/webt/p7/px/n0/p7pxn0rfwa2zhinvydqg7gu0-si.png" alt="Bild"><br><br><ul><li>  <b>padY / padX</b> - vertikale und horizontale Polsterung vorne. </li><li>  <b>padH / padW</b> - hintere vertikale und horizontale Polsterung. </li></ul><br><h4>  Kanalgruppen </h4><br>  Typischerweise ist jeder Ausgangskanal die Summe der Windungen √ºber alle Eingangskan√§le.  Dies ist jedoch nicht immer der Fall.  Es ist m√∂glich, die Eingangs- und Ausgangskan√§le in Gruppen zu unterteilen, die Summierung erfolgt nur innerhalb der Gruppen: <br><br><img src="https://habrastorage.org/webt/pz/uu/xp/pzuuxpq0grj9zxpmz_oft_eacnm.png" alt="Bild"><br><br><ul><li>  <b>Gruppe</b> - Die Anzahl der Gruppen. </li></ul><br>  In der Praxis treten am h√§ufigsten Situationen mit <b>group = 1</b> und <b>group = srcC = dstC auf</b> , der sogenannten <b>Tiefenfaltung</b> . <br><br><h4>  Verschiebungs- und Aktivierungsfunktion </h4><br>  Obwohl formale Verschiebungs- und Aktivierungsfunktionen nicht in der Faltung enthalten sind, folgen diese beiden Operationen sehr oft der Faltungsschicht, weshalb sie normalerweise auch darin enthalten sind.  In Anbetracht der Vielzahl m√∂glicher Aktivierungsfunktionen und ihrer Parameter werde ich sie hier nicht im Detail beschreiben. <br><br><h2>  Grundlegende Implementierung des Algorithmus </h2><br>  Zun√§chst m√∂chte ich eine grundlegende Implementierung des Algorithmus geben: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">relu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value : <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convolution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> batch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * weight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bias, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; b &lt; batch; ++b) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; group; ++g) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dc = <span class="hljs-number"><span class="hljs-number">0</span></span>; dc &lt; dstC / group; ++dc) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy = <span class="hljs-number"><span class="hljs-number">0</span></span>; dy &lt; dstH; ++dy) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = <span class="hljs-number"><span class="hljs-number">0</span></span>; dx &lt; dstW; ++dx) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sc = <span class="hljs-number"><span class="hljs-number">0</span></span>; sc &lt; srcC / group; ++sc) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ky = <span class="hljs-number"><span class="hljs-number">0</span></span>; ky &lt; kernelY; ky++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kx = <span class="hljs-number"><span class="hljs-number">0</span></span>; kx &lt; kernelX; kx++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sy = dy * strideY + ky * dilationY - padY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sx = dx * strideX + kx * dilationX - padX; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sy &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sy &lt; srcH &amp;&amp; sx &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sx &lt; srcW) sum += src[((b * srcC + sc)*srcH + sy)*srcW + sx] * weight[((dc * srcC / group + sc)*kernelY + ky)*kernelX + kx]; } } } dst[((b * dstC + dc)*dstH + dy)*dstW + dx] = relu(sum + bias[dc]); } } } } } }</code> </pre> <br>  In dieser Implementierung habe ich angenommen, dass das Eingabe- und Ausgabebild im <b>NCHW-</b> Format <b>vorliegt</b> : <br><br><img src="https://habrastorage.org/webt/rv/qn/4u/rvqn4uc1mdjt_ltl0wlrzyf8ows.png" alt="Bild"><br><br>  Faltungsgewichte werden im <b>DCYX-</b> Format gespeichert, und unsere Aktivierungsfunktion ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">ReLU</a> .  Im allgemeinen Fall ist dies nicht der Fall, aber f√ºr die grundlegende Implementierung sind solche Annahmen durchaus angemessen - Sie m√ºssen von etwas ausgehen. <br><br>  Wir haben 8 verschachtelte Zyklen und die Gesamtzahl der Operationen: <br><br><pre> <code class="cpp hljs">batch * kernelY * kernelX * srcC * dstH * dstW * dstC / group * <span class="hljs-number"><span class="hljs-number">2</span></span>,</code> </pre><br>  w√§hrend die Datenmenge in der Eingabe: <br><br><pre> <code class="cpp hljs">batch * srcC * srcH * srcW,</code> </pre><br>  und Ausgabebild: <br><br><pre> <code class="cpp hljs">batch * dstC * dstH * dstW,</code> </pre><br>  und die Anzahl der Gewichte: <br><br><pre> <code class="cpp hljs">kernelY * kernelX * srcC * dstC / group.</code> </pre><br>  Wenn <b>Gruppe &lt;&lt; srcC</b> (die Anzahl der Gruppen ist viel kleiner als die Anzahl der Kan√§le) sowie mit ausreichend gro√üen Parametern <b>srcC</b> , <b>srcH</b> , <b>srcW</b> und <b>dstC</b> , erhalten wir ein klassisches Rechenproblem, wenn die Anzahl der Berechnungen die Menge der Eingabe- und Ausgabedaten erheblich √ºberschreitet.  Das hei√üt,  Der Faltungsbetrieb mit ordnungsgem√§√üer Implementierung sollte auf den Rechenressourcen des Prozessors und nicht auf der Speicherbandbreite beruhen.  Es bleibt nur diese Implementierung zu finden. <br><br><h2>  Reduktion des Problems auf Matrixmultiplikation </h2><br>  Die Hauptoperation bei der Faltung besteht darin, eine gewichtete Summe zu erhalten, und die Gewichte sind f√ºr alle Punkte des Ausgabebildes gleich.  Wenn Sie das Eingabebild wie folgt neu anordnen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">im2col</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sc = <span class="hljs-number"><span class="hljs-number">0</span></span>; sc &lt; srcC; ++sc) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ky = <span class="hljs-number"><span class="hljs-number">0</span></span>; ky &lt; kernelY; ky++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kx = <span class="hljs-number"><span class="hljs-number">0</span></span>; kx &lt; kernelX; kx++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy = <span class="hljs-number"><span class="hljs-number">0</span></span>; dy &lt; dstH; ++dy) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = <span class="hljs-number"><span class="hljs-number">0</span></span>; dx &lt; dstW; ++dx) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sy = dy * strideY + ky * dilationY - padY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sx = dx * strideX + kx * dilationX - padX; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sy &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sy &lt; srcH &amp;&amp; sx &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sx &lt; srcW) *buf++ = src[((b * srcC + sc)*srcH + sy)*srcW + sx]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> *buf++ = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } } } }</code> </pre><br>  Dann wechseln wir vom Format <b>srcC - srcH - srcW</b> zum Format <b>srcC - kernelY - kernelX - dstH - dstW</b> .  Die folgende Abbildung zeigt, wie das Bild mit Padding <b>1</b> und <b>3x3</b> Core konvertiert wird: <br><br><img src="https://habrastorage.org/webt/mn/lz/rw/mnlzrw76nnibv73tcjn2yuzsfhk.png" alt="Bild"><br><br>  In diesem Fall werden alle Punkte der Bildumgebung, die f√ºr die Faltungsoperation erforderlich sind, entlang der Spalten der resultierenden Matrix ausgerichtet (daher der Name - Bild <b>in</b> Spalten). <br><br>  Die neue Darstellung des Eingabebildes ist insofern interessant, als nun die Faltungsoperation in uns auf die Matrixmultiplikation reduziert wird: <br><br><img src="https://habrastorage.org/webt/2l/cm/lp/2lcmlpitdsgjyztxnyylyqi62jo.png" alt="Bild"><br><br>  Jetzt sieht der Faltungscode folgenderma√üen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gemm_nn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> M, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> N, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * A, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lda, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ldb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * C, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ldc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; M; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; N; ++j) { C[i*ldc + j] = beta; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; K; ++k) C[i*ldc + j] += alpha * A[i*lda + k] * B[k*ldb + j]; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convolution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> batch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * weight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bias, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> M = dstC / group; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = dstH * dstW; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> K = srcC * kernelY * kernelX / group; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; b &lt; batch; ++b) { im2col(src, srcC, srcH, srcW, kernelY, kernelX, dilationY, dilationY, strideY, strideX, padY, padX, padH, padW, buf); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; group; ++g) gemm_nn(M, N, K, <span class="hljs-number"><span class="hljs-number">1</span></span>, weight + M * K * g, K, <span class="hljs-number"><span class="hljs-number">0</span></span>, buf + N * K * g, N, dst + M * N * g, N)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; M; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; N; ++j) dst[i*N+ j] = relu(dst[i*N + j] + bias[i]); src += srcC*srcH*srcW; dst += dstC*dstH*dstW; } }</code> </pre><br>  Hier wird die triviale Implementierung der Matrixmultiplikation nur als Beispiel gegeben.  Wir k√∂nnen es durch jede andere Implementierung ersetzen.  Gl√ºcklicherweise ist die Matrixmultiplikation eine seit langem etablierte Operation, die bereits in vielen Bibliotheken mit sehr hoher Effizienz implementiert wurde (bis zu 90% der theoretisch m√∂glichen CPU-Leistung).  Zum Thema, wie diese Effizienz erreicht wird, habe ich sogar einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separaten Artikel</a> . <br><br><h2>  Verwenden der Matrixmultiplikation f√ºr das NHWC-Format </h2><br>  Neben dem <b>NCHW-</b> Format wird <b>NHWC</b> h√§ufig beim maschinellen Lernen verwendet: <br><br><img src="https://habrastorage.org/webt/9x/rk/j6/9xrkj6vqbrmdiamgfpmkmkxsaoo.png" alt="Bild"><br><br>  Beachten <b>Sie</b> beispielsweise, dass <b>NHWC</b> das native <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Tensorflow-</a> Format ist. <br><br>  Es ist bemerkenswert, dass f√ºr dieses Format die Faltungsoperation auch zu einer Matrixmultiplikation f√ºhren kann.  Dazu √ºbersetzen <b>wir</b> aus dem Format <b>srcH - srcW - srcC</b> das Originalbild mit der Funktion <b>im2row</b> in das Format <b>dstH - dstW - kernelY - kernelX - srcC</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">im2row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; group; ++g) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy = <span class="hljs-number"><span class="hljs-number">0</span></span>; dy &lt; dstH; ++dy) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = <span class="hljs-number"><span class="hljs-number">0</span></span>; dx &lt; dstW; ++dx) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ky = <span class="hljs-number"><span class="hljs-number">0</span></span>; ky &lt; kernelY; ky++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> kx = <span class="hljs-number"><span class="hljs-number">0</span></span>; kx &lt; kernelX; kx++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sy = dy * strideY + ky * dilationY - padY; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sx = dx * strideX + kx * dilationX - padX; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sc = <span class="hljs-number"><span class="hljs-number">0</span></span>; sc &lt; srcC; ++sc) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sy &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sy &lt; srcH &amp;&amp; sx &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sx &lt; srcW) *buf++ = src[(sy * srcW + sx)*srcC + sc]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> *buf++ = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } } } } src += srcC / group; } }</code> </pre><br>  Dar√ºber hinaus sind alle Punkte der Bildumgebung, die f√ºr die Faltungsoperation erforderlich sind, entlang der Zeilen der resultierenden Matrix ausgerichtet (daher ihr Name - Bild <b>zu</b> <b>Zeile</b> s).  Wir sollten auch das Speicherformat von Faltungsskalen vom <b>DCYX-</b> Format in das <b>YXCD-</b> Format <b>√§ndern</b> .  Jetzt k√∂nnen wir die Matrixmultiplikation anwenden: <br><br><img src="https://habrastorage.org/webt/6p/k-/q-/6pk-q-wqfe060sq1y_vrstkw3ea.png" alt="Bild"><br><br>  Im Gegensatz zum <b>NCHW-</b> Format multiplizieren wir die <b>Bildmatrix</b> mit der Gewichtsmatrix und nicht umgekehrt.  Das Folgende ist ein Faltungsfunktionscode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convolution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> batch, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> srcW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernelX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dilationX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> strideX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padY, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padX, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> padW, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * weight, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * bias, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dstC, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buf)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstH = (srcH + padY + padH - (dilationY * (kernelY - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideY + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dstW = (srcW + padX + padW - (dilationX * (kernelX - <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>)) / strideX + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> M = dstH * dstW; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = dstC / group; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> K = srcC * kernelY * kernelX / group; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; b &lt; batch; ++b) { im2row(src, srcC, srcH, srcW, kernelY, kernelX, dilationY, dilationY, strideY, strideX, padY, padX, padH, padW, group, buf); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; g &lt; group; ++g) gemm_nn(M, N, K, <span class="hljs-number"><span class="hljs-number">1</span></span>, buf + M * K * g, K * group, <span class="hljs-number"><span class="hljs-number">0</span></span>, weight + N * g, dstC, dst + N * g, dstC)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; M; ++i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; N; ++j) dst[i*N+ j] = relu(dst[i*N + j] + bias[i]); src += srcC*srcH*srcW; dst += dstC*dstH*dstW; } }</code> </pre><br><h2>  Vor- und Nachteile der Methode </h2><br>  Von Anfang an m√∂chte ich die Vorteile dieses Ansatzes auflisten: <br><br><ul><li>  Diese Methode hat eine sehr einfache Implementierung.  Nicht umsonst wird es in fast allen mir bekannten Bibliotheken verwendet. </li><li>  Die Wirksamkeit der Methode ist in vielen F√§llen sehr hoch: Aus Prozenteinheiten in der Basisversion erreichen wir mehr als 80% des theoretischen Maximums. </li><li>  Der Ansatz ist universell - wir haben einen Code f√ºr alle m√∂glichen Parameter der Faltungsschicht (und es gibt viele davon!).  Daher funktioniert diese Methode h√§ufig in F√§llen, in denen effektivere (und daher spezialisiertere) Ans√§tze Einschr√§nkungen aufweisen. </li><li>  Der Ansatz funktioniert f√ºr die Hauptformate von <b>Bildtensoren</b> - <b>NCHW</b> und <b>NHWC</b> . </li></ul><br>  Nun zu den Nachteilen: <br><br><ul><li>  Leider ist die Standardmatrixmultiplikation effektiv, vorausgesetzt, die Werte der Parameter <b>M, N, K</b> sind gro√ü genug und au√üerdem ungef√§hr gleich gro√ü (die Effizienz basiert auf der Tatsache, dass die erforderliche Anzahl von Berechnungen <b>~ O (N ^ 3) ist</b> , und dem erforderlichen Durchsatz Ged√§chtnisf√§higkeit <b>~ O (N ^ 2)</b> ).  Wenn daher einer der Parameter <b>M, N, K</b> klein ist, f√§llt die Effizienz des Verfahrens stark ab. </li><li>  Die Methode erfordert die Konvertierung von Eingabedaten.  Und das ist alles andere als eine freie Operation.  Sie kann nur vernachl√§ssigt werden, wenn <b>K</b> gro√ü genug ist.  Und wenn wir ber√ºcksichtigen, dass es innerhalb der Standardmatrixmultiplikation immer noch eine interne Transformation der Eingabedaten gibt, wird die Situation noch trauriger. </li><li>  Basierend auf der Tatsache, dass <b>K = srcC * kernelY * kernelX / Gruppe ist</b> , ist die Effizienz des Verfahrens f√ºr Eingangsfaltungsschichten besonders gering.  Und f√ºr die <b>Tiefenfaltung</b> verliert <b>die</b> Matrixmethode im Allgemeinen an der trivialen Implementierung. </li><li>  Das Verfahren erfordert eine zus√§tzliche Verarbeitung der Ausgangsdaten f√ºr den Schaltvorgang und die Berechnung der Aktivierungsfunktion. </li><li>  Es gibt effizientere mathematische Methoden zur Berechnung der Faltung, die weniger Operationen erfordern. </li></ul><br><h2>  Schlussfolgerungen </h2><br>  Das Verfahren zur Berechnung der Faltung basierend auf der Matrixmultiplikation ist einfach zu implementieren und weist eine hohe Effizienz auf.  Leider ist es nicht universell.  F√ºr eine Reihe von Sonderf√§llen gibt es schnellere Ans√§tze, deren Beschreibung ich auf die n√§chsten Artikel dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe</a> verschieben m√∂chte.  Warten auf Feedback und Kommentare von Lesern.  Ich hoffe du warst interessiert! <br><br>  <b>PS</b> Dieser und andere Ans√§tze werden von mir im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Convolution Framework</a> als Teil der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Simd-</a> Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">implementiert</a> . <br>  Dieses Framework liegt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">Synet</a> zugrunde, einem Framework zum Ausf√ºhren vorab trainierter neuronaler Netze auf der CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448436/">https://habr.com/ru/post/de448436/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448422/index.html">E-Dobavki ist ein Suchdienst f√ºr Nahrungserg√§nzungsmittel in Java und Spring Boot, der von meinen Sch√ºlern geschrieben wurde</a></li>
<li><a href="../de448424/index.html">55 Jahre sp√§ter: Kult-IBM System / 360-Mainframe-Kultkonsolen</a></li>
<li><a href="../de448430/index.html">Pro Content 2019: drei harte Berichte und ein Liedchen</a></li>
<li><a href="../de448432/index.html">Klebstrahlung: induzierte Radioaktivit√§t, radioaktive Kontamination, Dekontamination ...</a></li>
<li><a href="../de448434/index.html">Top-Unternehmen f√ºr die Entwicklung mobiler Apps</a></li>
<li><a href="../de448438/index.html">Begrenzen der Geschwindigkeit der Verarbeitung von Anforderungen oder wie Sie keinen DDoS-Angriff auf Ihren Client arrangieren</a></li>
<li><a href="../de448440/index.html">Hunderttausende von Zahlungen von B√ºrgern an die STSI und die FSSP waren gemeinfrei</a></li>
<li><a href="../de448442/index.html">SSD GIGABYTE Aorus RGB M.2: kleine, gleichm√§√üige Fernbedienung f√ºr RGB-LEDs (1 Teil)</a></li>
<li><a href="../de448444/index.html">Die Angst vor der ersten Besch√§ftigung loswerden</a></li>
<li><a href="../de448448/index.html">SWIFT-Bericht: Das Volumen von Geldern, die von Hackern von Banken gestohlen wurden, hat sich drei Jahre nach dem Hack um 100 Millionen US-Dollar verzehnfacht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>