<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüåæ üåö üå∂Ô∏è M√©todos simples para optimizar los programas Go ‚¨ÖÔ∏è ü§ôüèæ üëô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Siempre me importa el rendimiento. No s√© exactamente por qu√©. Pero me molestan los servicios y programas lentos. Parece que no estoy solo . 

 En las ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©todos simples para optimizar los programas Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457004/">  Siempre me importa el rendimiento.  No s√© exactamente por qu√©.  Pero me molestan los servicios y programas lentos.  Parece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">que no estoy solo</a> . <br><br><blockquote>  <i>En las pruebas A / B, intentamos ralentizar la producci√≥n de p√°ginas en incrementos de 100 milisegundos y descubrimos que incluso retrasos muy peque√±os conducen a una ca√≠da significativa en los ingresos.</i>  - Greg Linden, Amazon.com </blockquote><br>  Por experiencia, la baja productividad se manifiesta de una de dos maneras: <br><br><ul><li>  Las operaciones que funcionan bien a peque√±a escala se vuelven inviables con un n√∫mero creciente de usuarios.  Por lo general, estas son operaciones O (N) u O (N¬≤).  Cuando la base de usuarios es peque√±a, todo funciona bien.  El producto tiene prisa por llevarlo al mercado.  A medida que la base crece, surgen situaciones patol√≥gicas cada vez m√°s inesperadas, y el servicio se detiene. <br></li><li> Muchas fuentes individuales de trabajo sub√≥ptimo, "muerte por mil cortes". </li></ul><a name="habracut"></a><br>  Durante la mayor parte de mi carrera, estudi√© ciencia de datos con Python o cre√© servicios en Go.  En el segundo caso, tengo mucha m√°s experiencia en optimizaci√≥n.  Go generalmente no es un cuello de botella en los servicios que escribo: los programas de bases de datos a menudo est√°n limitados por E / S.  Sin embargo, en las canalizaciones por lotes de aprendizaje autom√°tico que desarroll√©, el programa a menudo est√° limitado por la CPU.  Si Go usa demasiado el procesador, hay varias estrategias. <br><br>  Este art√≠culo explica algunos m√©todos que pueden usarse para aumentar significativamente la productividad sin mucho esfuerzo.  Ignoro deliberadamente los m√©todos que requieren un esfuerzo significativo o grandes cambios en la estructura del programa. <br><br><h1>  Antes de empezar </h1><br>  Antes de realizar cualquier cambio en el programa, t√≥mese el tiempo para crear una l√≠nea base adecuada para la comparaci√≥n.  Si no lo hace, entonces vagar√° en la oscuridad, pregunt√°ndose si hay alg√∫n beneficio de los cambios realizados.  Primero, escriba puntos de referencia y tome <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">perfiles</a> para usar en pprof.  Es mejor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">escribir el punto de referencia tambi√©n en Go</a> : esto hace que sea m√°s f√°cil usar pprof y perfiles de memoria.  Utilice tambi√©n benchcmp: una herramienta √∫til para comparar diferencias de rendimiento entre pruebas. <br><br>  Si el c√≥digo no es muy compatible con los puntos de referencia, simplemente comience con algo que se pueda medir.  Puede perfilar el c√≥digo manualmente con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">runtime / pprof</a> . <br><br>  ¬°Entonces comencemos! <br><br><h3>  Use sync.Pool para reutilizar objetos previamente seleccionados </h3><br>  sync.Pool implementa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una lista de lanzamiento</a> .  Esto le permite reutilizar estructuras previamente asignadas y amortiza la distribuci√≥n del objeto en muchos usos, reduciendo el trabajo del recolector de basura.  La API es muy simple.  Implemente una funci√≥n que asigne una nueva instancia de un objeto.  La API devolver√° el tipo de puntero. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bufpool = sync.Pool{ New: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;buf }}</code> </pre> <br>  Despu√©s de eso, puede hacer <code>Get()</code> objetos del grupo y volver a colocarlos <code>Put()</code> cuando haya terminado. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sync.Pool returns a interface{}: you must cast it to the underlying type // before you use it. b := *bufpool.Get().(*[]byte) defer bufpool.Put(&amp;b) // Now, go do interesting things with your byte buffer. buf := bytes.NewBuffer(b)</span></span></code> </pre> <br>  Hay matices  Antes de Go 1.13, el grupo se borraba con cada recolecci√≥n de basura.  Esto puede afectar negativamente el rendimiento de los programas que asignan mucha memoria.  A partir de 1.13, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parece que m√°s objetos sobreviven despu√©s del GC</a> . <br><br>  <b>!!!</b>  <b>Antes de devolver un objeto al grupo, aseg√∫rese de restablecer los campos de estructura.</b> <br><br>  Si no lo hace, puede obtener un objeto sucio del grupo que contiene datos del uso anterior.  ¬°Este es un grave riesgo de seguridad! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AuthenticationResponse { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserID <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } rsp := authPool.Get().(*AuthenticationResponse) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> authPool.Put(rsp) <span class="hljs-comment"><span class="hljs-comment">// If we don't hit this if statement, we might return data from other users! if blah { rsp.UserID = "user-1" rsp.Token = "super-secret" } return rsp</span></span></code> </pre> <br>  Una forma segura de garantizar siempre cero memoria es hacer esto expl√≠citamente: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// reset resets all fields of the AuthenticationResponse before pooling it. func (a* AuthenticationResponse) reset() { a.Token = "" a.UserID = "" } rsp := authPool.Get().(*AuthenticationResponse) defer func() { rsp.reset() authPool.Put(rsp) }()</span></span></code> </pre> <br>  El √∫nico caso cuando esto no es un problema es cuando usa la memoria exacta en la que escribi√≥.  Por ejemplo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( r io.Reader w io.Writer ) <span class="hljs-comment"><span class="hljs-comment">// Obtain a buffer from the pool. buf := *bufPool.Get().(*[]byte) defer bufPool.Put(&amp;buf) // We only write to w exactly what we read from r, and no more. nr, er := r.Read(buf) if nr &gt; 0 { nw, ew := w.Write(buf[0:nr]) }</span></span></code> </pre> <br><h3>  Evite usar estructuras que contengan punteros como claves para un mapa grande </h3><br>  Fuh, yo era demasiado prolijo.  Lo siento  A menudo hablaban (incluido mi antiguo colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Phil Pearl</a> ) sobre el rendimiento de Go con un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">gran tama√±o de almacenamiento din√°mico</a> .  Durante la recolecci√≥n de basura, el tiempo de ejecuci√≥n escanea objetos con punteros y los rastrea.  Si tiene un mapa muy grande map <code>map[string]int</code> , entonces GC deber√≠a verificar cada l√≠nea.  Esto sucede con cada recolecci√≥n de basura, porque las l√≠neas contienen punteros. <br><br>  En este ejemplo, escribimos 10 millones de elementos para <code>map[string]int</code> y medir la duraci√≥n de la recolecci√≥n de basura.  Asignamos nuestro mapa en el √°rea del paquete para garantizar la asignaci√≥n de memoria desde el mont√≥n. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[strconv.Itoa(i)] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Al ejecutar el programa, veremos lo siguiente: <br><br><pre>  inthash ‚Üí vaya a instalar &amp;&amp; inthash
 gc tom√≥: 98.726321 ms
 gc tom√≥: 105.524633 ms
 gc tom√≥: 102.829451ms
 gc tom√≥: 102.71908ms
 gc tom√≥: 103.084104ms
 gc tom√≥: 104.821989ms </pre><br>  ¬°Esto es bastante tiempo en un pa√≠s de computadoras! <br><br>  ¬øQu√© se puede hacer para optimizar?  Eliminar punteros en todas partes es una buena idea, para no cargar el recolector de basura.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hay punteros en las l√≠neas</a> ;  as√≠ que implementemos esto como <code>map[int]int</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[i] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Ejecutando el programa nuevamente, vemos: <br><br><pre>  inthash ‚Üí vaya a instalar &amp;&amp; inthash
 gc tom√≥: 3.608993ms
 gc tom√≥: 3.926913ms
 gc tom√≥: 3.955706ms
 gc tom√≥: 4.063795ms
 gc tom√≥: 3.91519ms
 gc tom√≥: 3.75226ms </pre><br>  Mucho mejor  Hemos acelerado la recolecci√≥n de basura en 35 veces.  Cuando se usa en producci√≥n, ser√° necesario dividir las cadenas en enteros antes de insertarlas en la tarjeta. <br><br>  Por cierto, hay muchas m√°s formas de evitar la GC.  Si asigna matrices gigantescas de estructuras, ints o bytes sin sentido, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GC no escanear√° esto</a> : es decir, ahorrar√° tiempo en el GC.  Tales m√©todos generalmente requieren una revisi√≥n sustancial del programa, por lo que hoy no profundizaremos en este tema. <br><br>  Como con cualquier optimizaci√≥n, el efecto puede variar.  Vea el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hilo de tweets de Damian Gryski</a> para ver un ejemplo interesante de c√≥mo eliminar l√≠neas de un mapa grande en favor de una estructura de datos m√°s inteligente realmente <i>aument√≥ el</i> consumo de memoria.  En general, lee todo lo que publica. <br><br><h3>  Generaci√≥n de c√≥digo de clasificaci√≥n para evitar la reflexi√≥n en tiempo de ejecuci√≥n </h3><br>  Organizar y desarmar su estructura en varios formatos de serializaci√≥n, como JSON, es una operaci√≥n t√≠pica, especialmente al crear microservicios.  Para muchos microservicios, este es generalmente el √∫nico trabajo.  Funciones como <code>json.Marshal</code> y <code>json.Unmarshal</code> basan en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reflexi√≥n en tiempo</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecuci√≥n</a> para serializar los campos de estructura en bytes y viceversa.  Esto puede funcionar lentamente: la reflexi√≥n no es tan eficiente como el c√≥digo expl√≠cito. <br><br>  Sin embargo, hay opciones de optimizaci√≥n.  La mec√°nica de c√°lculo de referencias de JSON se parece a esto: <br><br><pre> <code class="json hljs">package json // Marshal take an object and returns its representation in JSON. func Marshal(obj interface{}) ([]byte, error) { // Check if this object knows how to marshal itself to JSON // by satisfying the Marshaller interface. if m, is := obj.(json.Marshaller); is { return m.MarshalJSON() } // It doesn't know how to marshal itself. Do default reflection based marshallling. return marshal(obj) }</code> </pre> <br>  Si conocemos el proceso de clasificaci√≥n en JSON, tenemos una pista para evitar la reflexi√≥n en tiempo de ejecuci√≥n.  Pero no queremos escribir manualmente todo el c√≥digo de clasificaci√≥n, entonces, ¬øqu√© debemos hacer?  ¬°Deje que la computadora genere este c√≥digo!  Los generadores de c√≥digo como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">easyjson</a> observan la estructura y generan c√≥digo altamente optimizado que es totalmente compatible con las interfaces de <code>json.Marshaller</code> existentes como <code>json.Marshaller</code> . <br><br>  Descargue el paquete y escriba el siguiente comando en <code>$file.go</code> , que contiene las estructuras para las que desea generar c√≥digo. <br><br><pre>  easyjson -todos $ file.go </pre><br>  Se debe generar el archivo <code>$file_easyjson.go</code> .  Como <code>easyjson</code> implementado la interfaz <code>json.Marshaller</code> para usted, estas funciones se <code>json.Marshaller</code> de forma predeterminada en lugar de reflexionar.  Felicitaciones: acabas de acelerar tu c√≥digo JSON tres veces.  Hay muchos trucos para aumentar a√∫n m√°s la productividad. <br><br>  Recomiendo este paquete porque lo he usado antes y con √©xito.  Pero ten cuidado.  No tome esto como una invitaci√≥n para iniciar debates agresivos conmigo sobre los paquetes JSON m√°s r√°pidos. <br><br>  Aseg√∫rese de volver a generar el c√≥digo de clasificaci√≥n cuando cambie la estructura.  Si olvida hacer esto, los campos reci√©n agregados no se serializar√°n, ¬°lo que generar√° confusi√≥n!  Puede usar <code>go generate</code> para estas tareas.  Para mantener la sincronizaci√≥n con las estructuras, prefiero colocar <code>generate.go</code> en la ra√≠z del paquete, lo que provoca que <code>go generate</code> todos los archivos del paquete: esto puede ayudar cuando tiene muchos archivos que necesitan generar dicho c√≥digo.  El consejo principal: para asegurarse de que las estructuras se actualicen, llame a <code>go generate</code> en el CI y verifique que no haya diferencia con el c√≥digo registrado. <br><br><h3>  Use strings.Builder para construir cadenas </h3><br>  En Go, las cadenas son inmutables: consid√©relas como bytes de solo lectura.  Esto significa que cada vez que crea una cadena, asigna memoria y potencialmente crea m√°s trabajo para el recolector de basura. <br><br>  Ir 1.10 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cadenas</a> implementadas. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Constructor</a> como una forma eficiente de crear cadenas.  Internamente, escribe en un b√∫fer de bytes.  Solo cuando se llama a <code>String()</code> en el generador, se crea una cadena.  Se basa en algunos trucos inseguros para devolver los bytes base como una cadena con una asignaci√≥n cero: consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este blog</a> para obtener m√°s informaci√≥n sobre c√≥mo funciona. <br><br>  Compare el rendimiento de los dos enfoques: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import "strings" var strs = []string{ "here's", "a", "some", "long", "list", "of", "strings", "for", "you", } func buildStrNaive() string { var s string for _, v := range strs { s += v } return s } func buildStrBuilder() string { b := strings.Builder{} // Grow the buffer to a decent length, so we don't have to continually // re-allocate. b.Grow(60) for _, v := range strs { b.WriteString(v) } return b.String() }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var str string func BenchmarkStringBuildNaive(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrNaive() } } func BenchmarkStringBuildBuilder(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrBuilder() }</span></span></code> </pre> <br>  Aqu√≠ est√°n los resultados en mi Macbook Pro: <br><br><pre>  strbuild -&gt; go test -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 paquete: github.com/sjwhitworth/perfblog/strbuild
 BenchmarkStringBuildNaive-8 5,000,000 255 ns / op 216 B / op 8 allocs / op
 BenchmarkStringBuildBuilder-8 20,000,000 54.9 ns / op 64 B / op 1 allocs / op </pre><br>  Como puede ver, <code>strings.Builder</code> es 4.7 veces m√°s r√°pido, causa ocho veces menos asignaciones y ocupa cuatro veces menos memoria. <br><br>  Cuando el rendimiento es importante, use <code>strings.Builder</code> .  En general, recomiendo usarlo en todas partes, excepto en los casos m√°s triviales de construir cadenas. <br><br><h3>  Use strconv en lugar de fmt </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fmt</a> es uno de los paquetes m√°s famosos de Go.  Probablemente lo us√≥ en su primer programa para mostrar "hola, mundo".  Pero cuando se trata de convertir enteros y flotadores en cadenas, no es tan eficiente como su hermano menor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">strconv</a> .  Este paquete muestra un rendimiento decente con muy pocos cambios en la API. <br><br>  <code>fmt</code> b√°sicamente toma la <code>interface{}</code> como argumentos de funci√≥n.  Hay dos inconvenientes: <br><br><ul><li>  Est√°s perdiendo seguridad tipo.  Para mi es muy importante. <br></li><li>  Esto puede aumentar la cantidad de secreciones necesarias.  Pasar un tipo sin puntero como <code>interface{}</code> generalmente resulta en una asignaci√≥n de mont√≥n.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Esta publicaci√≥n de blog</a> explica por qu√© esto es as√≠. </li><li>  El siguiente programa muestra la diferencia en el rendimiento: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import ( "fmt" "strconv" ) func strconvFmt(a string, b int) string { return a + ":" + strconv.Itoa(b) } func fmtFmt(a string, b int) string { return fmt.Sprintf("%s:%d", a, b) } func main() {}</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var ( a = "boo" blah = 42 box = "" ) func BenchmarkStrconv(b *testing.B) { for i := 0; i &lt; bN; i++ { box = strconvFmt(a, blah) } a = box } func BenchmarkFmt(b *testing.B) { for i := 0; i &lt; bN; i++ { box = fmtFmt(a, blah) } a = box }</span></span></code> </pre> <br>  Puntos de referencia en Macbook Pro: <br><br><pre>  strfmt ‚Üí ir prueba -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 paquete: github.com/sjwhitworth/perfblog/strfmt
 BenchmarkStrconv-8 30,000,000 39.5 ns / op 32 B / op 1 allocs / op
 Benchmark Fmt-8 10,000,000 143 ns / op 72 B / op 3 allocs / op </pre><br>  Como puede ver, la opci√≥n strconv es 3.5 veces m√°s r√°pida, causa tres veces menos asignaciones y ocupa la mitad de la memoria. <br><br><h3>  Asigne el tanque de corte con marca para evitar la redistribuci√≥n </h3><br>  Antes de pasar a mejorar el rendimiento, actualice r√°pidamente la informaci√≥n cortada en la memoria.  Una rebanada es una construcci√≥n muy √∫til en Go.  Proporciona una matriz escalable con la capacidad de aceptar diferentes vistas en la misma memoria base sin reasignaci√≥n.  Si miras debajo del cap√≥, la rebanada consta de tres elementos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> slice <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// pointer to underlying data in the slice. data uintptr // the number of elements in the slice. len int // the number of elements that the slice can // grow to before a new underlying array // is allocated. cap int }</span></span></code> </pre> <br>  ¬øQu√© son estos campos? <br><br><ul><li>  <code>data</code> : puntero a los datos subyacentes en el segmento <br></li><li>  <code>len</code> : n√∫mero actual de elementos en el segmento <br></li><li>  <code>cap</code> : n√∫mero de elementos a los que puede crecer un segmento antes de redistribuir </li></ul><br>  Las secciones debajo del cap√≥ son conjuntos de longitud fija.  Cuando se alcanza el valor m√°ximo ( <code>cap</code> ), se asigna una nueva matriz con un valor doble, la memoria se copia de la divisi√≥n anterior a la nueva y la matriz anterior se descarta. <br><br>  A menudo veo algo como este c√≥digo donde se asigna un segmento con una capacidad l√≠mite cero si la capacidad del segmento se conoce de antemano: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userIDs []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  En este caso, el segmento comienza con el tama√±o cero <code>len</code> y el l√≠mite de capacidad l√≠mite cero.  Una vez recibida la respuesta, agregamos los elementos al segmento, al mismo tiempo que alcanzamos la capacidad l√≠mite: se selecciona una nueva matriz base, donde <code>cap</code> duplica el <code>cap</code> y se copian los datos.  Si obtenemos 8 elementos en la respuesta, esto lleva a 5 redistribuciones. <br><br>  El siguiente m√©todo es mucho m√°s eficiente: <br><br><pre> <code class="go hljs">userIDs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(rsp.Users)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Aqu√≠ asignamos expl√≠citamente la capacidad para el segmento usando make.  Ahora podemos agregar datos de manera segura all√≠, sin redistribuci√≥n y copia adicionales. <br><br>  Si no sabe cu√°nta memoria asignar, debido a que la capacidad es din√°mica o se calcula m√°s tarde en el programa, mida la distribuci√≥n final del tama√±o de segmento despu√©s de que se ejecute el programa.  Por lo general, tomo el percentil 90 o 99 y codifico el valor en el programa.  En los casos en que la CPU sea m√°s costosa que la RAM para usted, configure este valor m√°s alto de lo que cree que es necesario. <br><br>  La sugerencia tambi√©n se aplica a los mapas: <code>make(map[string]string, len(foo))</code> asignar√° suficiente memoria para evitar la redistribuci√≥n. <br><br>  Vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo</a> sobre c√≥mo funcionan realmente las rebanadas. <br><br><h3>  Use m√©todos para transferir segmentos de bytes </h3><br>  Cuando use paquetes, use m√©todos que permitan la transmisi√≥n de un segmento de bytes: estos m√©todos generalmente dan m√°s control sobre la distribuci√≥n. <br><br>  Un buen ejemplo es comparar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">time.Format</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">time.AppendFormat</a> .  El primero devuelve una cadena.  Debajo del cap√≥, esto selecciona un nuevo segmento de byte y llama al tiempo.  El segundo toma un b√∫fer de bytes, escribe una representaci√≥n de tiempo formateada y devuelve un segmento de bytes extendido.  Esto a menudo se encuentra en otros paquetes en la biblioteca est√°ndar: vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">strconv.AppendFloat</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bytes.NewBuffer</a> . <br><br>  ¬øPor qu√© esto aumenta la productividad?  Bueno, ahora puede pasar las porciones de bytes que recibi√≥ de <code>sync.Pool</code> , en lugar de asignar un nuevo b√∫fer cada vez.  O puede aumentar el tama√±o inicial del b√∫fer a un valor que sea m√°s adecuado para su programa a fin de reducir el n√∫mero de copias repetidas de la porci√≥n. <br><br><h1>  Resumen </h1><br>  Puede aplicar todos estos m√©todos a su base de c√≥digo.  Con el tiempo, crear√° un modelo mental para razonar sobre el rendimiento en los programas Go.  Esto ser√° de gran ayuda en su dise√±o. <br><br>  Pero √∫salos dependiendo de la situaci√≥n.  Estos son consejos, no el evangelio.  Mida y verifique todo con puntos de referencia. <br><br>  Y saber cu√°ndo parar.  El aumento de la productividad es un buen ejercicio: la tarea es interesante y los resultados son visibles de inmediato.  Sin embargo, la utilidad de aumentar la productividad depende en gran medida de la situaci√≥n.  Si su servicio da una respuesta en 10 ms, y el retraso de la red es de 90 ms, probablemente no deber√≠a intentar reducir estos 10 ms a 5 ms: todav√≠a tiene 95 ms.  Incluso si optimiza el servicio al m√°ximo hasta 1 ms, el retraso total seguir√° siendo de 91 ms.  Probablemente coma pescado m√°s grande. <br><br>  ¬°Optimice sabiamente! <br><br><h3>  Referencias </h3><br>  Si desea m√°s informaci√≥n, aqu√≠ hay excelentes fuentes de inspiraci√≥n: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros peligros de grandes montones en Go</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eficiencia de distribuci√≥n en servicios Go de alto rendimiento</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo dej√© de preocuparme y me enamor√© de un mont√≥n</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bytes.Buffer, pens√© que eras mi amigo</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gc es malo pero no deber√≠as sentirte mal</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Perfilado y optimizaci√≥n en Go</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Uso de memoria en CockroachDB</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Eliminando retrasos de GC en grandes montones</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Siete pasos para acelerar cien veces</a> </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457004/">https://habr.com/ru/post/457004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456984/index.html">Reduzca el consumo de energ√≠a en el centro de datos: un nuevo chip de fotones ayudar√°</a></li>
<li><a href="../456986/index.html">Durov no tiene nada que ver con TON</a></li>
<li><a href="../456988/index.html">Historias de un abogado de TI. Negocio de outsourcing de vida. Parte 3</a></li>
<li><a href="../456992/index.html">Algunos consejos √∫tiles para aquellos que deciden aprender ingl√©s por su cuenta.</a></li>
<li><a href="../456996/index.html">Tres caballos blancos</a></li>
<li><a href="../457008/index.html">Antig√ºedades: tres historias de palma</a></li>
<li><a href="../457010/index.html">Por qu√© no uso componentes web</a></li>
<li><a href="../457018/index.html">Sobre complejidad</a></li>
<li><a href="../457020/index.html">Una selecci√≥n de fuentes acad√©micas y de ciencia pop</a></li>
<li><a href="../457022/index.html">Reubicaci√≥n de TI. De Bangkok a Sydney</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>