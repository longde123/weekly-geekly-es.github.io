<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍💼 🔘 👩‍👧‍👧 如何在JavaScript中实现编程语言。 第2部分：翻译 ☎️ 🤷🏼 🎅🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 我向您介绍了实现JavaScript编程语言的指南翻译的第二部分-PL教程 。 
 来自翻译 


 我们将创建自己的编程语言-λ语言 （原始语言 -λanguage）。 在创建过程中，我们将使用许多有趣的技术，例如递归下降，控件传递样式和基本的优化技术。 将创建两个版本的解释器-常规和CPS...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何在JavaScript中实现编程语言。 第2部分：翻译</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443812/"><p> 你好 我向您介绍了实现JavaScript编程语言的指南翻译的第二部分<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-PL教程</a> 。 </p><br><h1 id="ot-perevodchika"> 来自翻译 </h1><br><p> 我们将创建自己的编程语言<strong>-λ语言</strong> （原始<strong>语言</strong> -λanguage）。 在创建过程中，我们将使用许多有趣的技术，例如递归下降，控件传递样式和基本的优化技术。 将创建两个版本的解释器-常规和CPS解释器，即JavaScript中的反编译器。 </p><br><p> 原著的作者是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Mihai Bazon</a> ，著名的UglifyJS库（一种用于最小化和格式化JS代码的工具）的作者。 </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">目录内容</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何在JavaScript中实现编程语言。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：解析器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何在JavaScript中实现编程语言。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：翻译</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何在JavaScript中实现编程语言。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：CPS解释器</a> </li><li> 如何在JavaScript中实现编程语言。 第4部分：JS中的反编译 </li></ol></div></div><br><p> PS解释器和编译器中有一个错误：在<code>a() &amp;&amp; b()</code>或<code>a() || b()</code>类<code>a() &amp;&amp; b()</code>表达式中  <code>a() || b()</code>这两个部分始终执行。 当然，这是错误的，因为<code>a()</code>对于<code>&amp;&amp;</code>运算符<code>a()</code> false，或者对于<code>||</code>为false。  ，则<code>b()</code>的值不起作用。 这并不难解决。 </p><br><h1 id="prostoy-interpretator"> 简单的口译员 </h1><br><p> 在上一部分中，我们编写了3个函数： <code>InputStream</code> ， <code>TokenStream</code>和<code>parse</code> 。 为了从代码中获取AST，我们使用以下代码： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code)));</code> </pre> <br><p> 编写解释器比解析器容易：我们只是递归地遍历树并以其正常顺序执行表达式。 </p><br><h2 id="kontekst-environment"> 上下文（ <code>Environment</code> ） </h2><br><p> 为了正确执行代码，我们需要一个上下文-一个在给定位置包含所有变量的对象。 它将作为参数传递给<code>evaluate</code>函数。 </p><br><p> 每次我们进入<code>lambda</code>节点时，都必须向上下文中添加新变量-函数参数。 如果参数与外部块中的变量重叠，则必须在退出函数后恢复变量的旧值。 </p><br><p> 最简单的方法是使用原型JavaScript继承。 输入新函数时，我们将创建一个新上下文，将外部上下文设置为其原型，然后在新上下文中调用该函数。 因此，我们一无所有-在外部环境中，其所有变量都将保留。 </p><br><p> 这是<code>Environment</code>对象的实现： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Environment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">parent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(parent ? parent.vars : <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent = parent; } Environment.prototype = { <span class="hljs-attr"><span class="hljs-attr">extend</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">lookup</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (scope) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.hasOwnProperty.call(scope.vars, name)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> scope; scope = scope.parent; } }, <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.vars[name]; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Undefined variable "</span></span> + name); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lookup(name); <span class="hljs-comment"><span class="hljs-comment">//          if (!scope &amp;&amp; this.parent) throw new Error("Undefined variable " + name); return (scope || this).vars[name] = value; }, def: function(name, value) { return this.vars[name] = value; } };</span></span></code> </pre> <br><p>  <code>Environment</code>对象有一个指向外部上下文的<code>parent</code>字段。 对于全局上下文，它将为<code>null</code> 。 它有一个<code>vars</code>字段，其中所有变量都属于此上下文。 对于全局上下文，它立即等于一个空对象（ <code>Object.create(null)</code> ）和一个非全局对象的父上下文变量的副本（ <code>Object.create(parent.vars)</code> ）。 </p><br><p> 它有几种方法： </p><br><ul><li>  <code>extend()</code> -复制当前上下文。 </li><li>  <code>lookup(name)</code> -查找定义<code>name</code>变量的上下文。 </li><li>  <code>get(name)</code> -获取名为<code>name</code>的变量的值。 如果尚未定义变量，则引发异常。 </li><li>  <code>set(name, value)</code> -设置变量的值。 此方法在定义变量的上下文中查找。 如果未定义，并且我们不在全局环境中，则将引发异常。 </li><li>  <code>def(name, value)</code> -在当前上下文中创建（或重叠或覆盖）变量。 </li></ul><br><h2 id="funkciya-evaluate">  <code>evaluate</code>功能 </h2><br><p> 现在我们有了<code>Environment</code>对象，我们可以继续解决主要问题了。 此功能将是一个很大的<code>switch</code>块，它将根据传输的节点的类型执行某些操作： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p> 对于文字，我们只返回其值： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.value;</code> </pre> <br><p> 变量是从上下文中获取的（变量的名称包含在<code>value</code>字段中）： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.get(exp.value);</code> </pre> <br><p> 要进行分配，我们必须确保在左侧具有变量的名称（node <code>var</code> ）。 如果不是，那么我们只抛出一个异常（除了变量之外，我们不支持赋值）。 接下来，我们使用<code>env.set</code>设置变量的值。 请注意，表达式的右侧必须使用递归调用来<code>evaluate</code> ： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> env.set(exp.left.value, evaluate(exp.right, env));</code> </pre> <br><p> 对于<code>binary</code>类型的节点<code>binary</code>必须对两个操作数都应用运算符。 稍后我们将编写<code>apply_op</code>函数。 另外，我们调用表达式的两个部分的<code>evaluate</code> ： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply_op(exp.operator, evaluate(exp.left, env), evaluate(exp.right, env));</code> </pre> <br><p>  <code>lambda</code>类型的节点将返回普通的JavaScript闭包，因此即使从JavaScript中也可以像常规函数一样调用它。 我添加了<code>make_lambda</code>函数，稍后将显示它： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_lambda(env, exp);</code> </pre> <br><p>  <code>if</code>节点的执行非常简单：首先我们找到条件的值。 如果不是false，则返回<code>then</code>分支的值。 否则，如果存在<code>else</code>分支，则其值为<code>false</code> ： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cond = evaluate(exp.cond, env); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.then, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exp.else ? evaluate(exp.else, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br><p>  <code>prog</code>节点是一个表达式序列。 我们只需按顺序执行所有表达式并获取后者的值（空序列的值为<code>false</code> ）： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; exp.prog.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp</span></span></span><span class="hljs-function">)</span></span>{ val = evaluate(exp, env) }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val;</code> </pre> <br><p> 对于<code>call</code>类型的节点<code>call</code>我们需要调用一个函数。 在此之前，我们将找到函数本身的值，找到所有参数的值，然后使用<code>apply</code>调用函数： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = evaluate(exp.func, env); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, exp.args.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(arg, env); }));</code> </pre> <br><p> 我们永远不会到达这里，但是如果我们将新的节点类型添加到解析器中，而忘记将其添加到解释器中： </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p> 这是口译员的主要部分。 上面，我们使用了尚未实现的两个功能，因此让我们开始吧： </p><br><h4 id="apply_op">  <code>apply_op</code> ： </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply_op</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">op, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> x != <span class="hljs-string"><span class="hljs-string">"number"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Expected number but got "</span></span> + x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">div</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (num(x) == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"+"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) + num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) - num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"*"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) * num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) / div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"%"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) % div(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&amp;&amp;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> &amp;&amp; b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"||"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== <span class="hljs-literal"><span class="hljs-literal">false</span></span> ? a : b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt; num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &lt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num(a) &gt;= num(b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"=="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a === b; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"!="</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a !== b; } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Can't apply operator "</span></span> + op); }</code> </pre> <br><p> 它接收运算符类型和参数。 简单直观的<code>switch</code> 。 与JavaScript不同，JavaScript可以采用任何值，例如变量，甚至是没有意义的变量。 我们要求算术运算符的操作数为数字，并且不允许除以零。 对于字符串，我们稍后会提出一些建议。 </p><br><h4 id="make_lambda">  <code>make_lambda</code> ： </h4><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, scope); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p> 如您在上面看到的，它返回一个常规的JavaScript函数，该函数使用传递的上下文和AST函数。 仅当调用函数本身时，才执行所有工作：创建上下文，设置参数（如果不够，则变为<code>false</code> ）。 然后，仅在新的上下文中执行函数主体。 </p><br><h4 id="nativnye-funkcii"> 本机功能 </h4><br><p> 如您所见，我们无法通过我们的语言与JavaScript进行交互。 我曾经使用过<code>print</code>和<code>println</code>函数，但是没有在任何地方定义它们。 我们需要用JavaScript编写它们，然后将它们添加到全局上下文中。 </p><br><p> 这是这样的代码的示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  -   var code = "sum = lambda(x, y) x + y; print(sum(2, 3));"; // ,  parse  TokenStream,      InputStream var ast = parse(TokenStream(InputStream(code))); //    var globalEnv = new Environment(); //  ""  "print" globalEnv.def("print", function(txt){ console.log(txt); }); //  evaluate(ast, globalEnv); //  5</span></span></code> </pre> <br><h4 id="ves-kod"> 整个代码 </h4><br><p> 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>我们这段时间编写的所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">代码</a> 。 可以使用NodeJS启动它。 只需将代码传递到标准流即可： </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'sum = lambda(x, y) x + y; println(sum(2, 3));'</span></span> | node lambda-eval1.js</code> </pre> <br><h1 id="primery-koda"> 代码示例 </h1><br><p> 我们的编程语言虽然简单，但是（理论上）可以解决计算机可以完全解决的任何问题。 这是因为Alonzo Church和Alan Turing比我以前更聪明，他们曾经证明λ微积分（lambda calculus）等效于Turing机器，并且我们的λ语言实现了λ微积分。 </p><br><p> 这意味着即使我们的语言没有任何机会，我们也可以利用我们已经拥有的机会同样地实现它们。 或者，如果很难做到这一点，我们可以为此编写另一种语言的解释器。 </p><br><h4 id="cikly"> 周期数 </h4><br><p> 如果我们有递归，循环就不是问题。 我已经展示了在递归顶部实现循环的示例。 让我们再试一次。 </p><br><pre> <code class="python hljs">print_range = λ(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b { print(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= b { print(<span class="hljs-string"><span class="hljs-string">", "</span></span>); print_range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">""</span></span>); }; print_range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br><p> 但是，这里存在一个问题：如果将迭代次数增加到1000，例如，在600之后，出现错误“超出最大调用堆栈大小”。这是因为解释器是递归的，并且递归达到了最大深度。 </p><br><p> 这是一个严重的问题，但是有解决方案。 我想为迭代添加新的构造（ <code>for</code>或<code>while</code> ），但让我们尝试不使用它们。 递归看起来很漂亮，所以让我们离开它。 稍后我们将看到如何解决此限制。 </p><br><h4 id="struktury-dannyh-ih-otsutstvie"> 数据结构（缺少） </h4><br><p> 在我们的λ语言中，数据有三种类型：数字，字符串和布尔类型。 似乎您无法创建复杂的类型，例如数组或对象。 但这不是一个问题，我们还有一个类型：函数。 事实证明，如果遵循λ演算，那么即使具有继承性，我们也可以创建任何数据结构，包括对象。 </p><br><p> 我将在列表示例中显示它。 假设我们有一个<code>cons</code>函数，该函数创建一个包含两个值的对象。 我们将此对象称为“单元”或“对”。 我们将名称之一命名为“ car”，另一个命名为“ cdr”。 仅因为它们在Lisp中被称为。 现在，如果我们有一个对象“ cell”，则可以使用<code>car</code>和<code>cdr</code>函数获取其值： </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>); print(car(x)); <span class="hljs-comment"><span class="hljs-comment">#  10 print(cdr(x)); #  20</span></span></code> </pre> <br><p> 现在我们可以轻松定义一个列表： </p><br><blockquote> 列表是一对，包含“ car”中的第一个元素和“ cdr”中的其余元素。 但是`cdr`只能包含一个值！ 该值将是一个列表。 列表是一对，包含“ car”中的第一个元素和“ cdr”中的其余元素。 但是`cdr`只能包含一个值！ 该值将是一个列表。  [...] <br></blockquote><p> 这是一种递归数据类型。 但是仍然存在一个问题：何时需要停止？ 逻辑上，当<code>cdr</code>为空列表时，我们应该停止。 但是什么是空清单？ 为此，我们添加一个名为“ NIL”的新对象。 它可以作为一对使用（我们可以在上面使用<code>car</code>和<code>cdr</code> ，但它们的结果将是<code>NIL</code>本身）。 现在让我们创建项目1、2、3、4、5的列表： </p><br><pre> <code class="python hljs">x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); print(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 print(car(cdr(x))); # 2  Lisp  . cadr print(car(cdr(cdr(x)))); # 3 caddr print(car(cdr(cdr(cdr(x))))); # 4 cadddr print(car(cdr(cdr(cdr(cdr(x)))))); # 5     .</span></span></code> </pre> <br><p> 当没有特殊语法时，它看起来很糟糕。 但是我只是想表明可以使用现有的λ语言功能来完成此操作。 这是实现： </p><br><pre> <code class="python hljs">cons = λ(a, b) λ(f) f(a, b); car = λ(cell) cell(λ(a, b) a); cdr = λ(cell) cell(λ(a, b) b); NIL = λ(f) f(NIL, NIL);</code> </pre> <br><p> 当我第一次看到<code>cons</code> / <code>car</code> / <code>cdr</code>以这种方式制作时，我很惊讶他们不需要一个<code>if</code> （但是，由于它不在原始的λ微积分中，所以这很奇怪）。 当然，没有编程语言会这样做，因为它效率极低，但不会使λ计算的美观度降低。 用一种清晰的语言，此代码执行以下操作： </p><br><ul><li>  <code>cons</code>函数采用两个值（ <code>a</code>和<code>b</code> ）并返回保存它们的函数。 该功能正是该功能对的目标。 她接受一个参数，并为该对的两个值调用该参数。 </li><li>  <code>car</code>函数调用传递的参数，并传递返回第一个参数的函数。 </li><li>  <code>cdr</code>函数与<code>car</code>函数的功能相同，但唯一的区别是传递的函数返回第二个参数。 </li><li>  <code>NIL</code>函数的工作原理与<code>cons</code>相同，但返回的一对值等于NIL的两个值。 </li></ul><br><pre> <code class="python hljs">cons = λ(a, b) λ(f) f(a, b); car = λ(cell) cell(λ(a, b) a); cdr = λ(cell) cell(λ(a, b) b); NIL = λ(f) f(NIL, NIL); x = cons(<span class="hljs-number"><span class="hljs-number">1</span></span>, cons(<span class="hljs-number"><span class="hljs-number">2</span></span>, cons(<span class="hljs-number"><span class="hljs-number">3</span></span>, cons(<span class="hljs-number"><span class="hljs-number">4</span></span>, cons(<span class="hljs-number"><span class="hljs-number">5</span></span>, NIL))))); println(car(x)); <span class="hljs-comment"><span class="hljs-comment"># 1 println(car(cdr(x))); # 2 println(car(cdr(cdr(x)))); # 3 println(car(cdr(cdr(cdr(x))))); # 4 println(car(cdr(cdr(cdr(cdr(x)))))); # 5</span></span></code> </pre> <br><p> 列表上有很多算法可以递归实现，看起来很合逻辑。 例如，以下函数为每个列表项调用传递的函数： </p><br><pre> <code class="python hljs">foreach = λ(list, f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> list != NIL { f(car(list)); foreach(cdr(list), f); }; foreach(x, println);</code> </pre> <br><p> 这是另一个为一系列数字创建列表的列表： </p><br><pre> <code class="python hljs">range = λ(a, b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &lt;= b then cons(a, range(a + <span class="hljs-number"><span class="hljs-number">1</span></span>, b)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> NIL; <span class="hljs-comment"><span class="hljs-comment">#     1  8 foreach(range(1, 8), λ(x) println(x * x));</span></span></code> </pre> <br><p> 上面实现的列表是不可变的（创建列表后，我们无法更改<code>car</code>或<code>cdr</code> ）。 大多数Lisp具有更改对的功能。 在Scheme中，它们称为<code>set-car!</code>  / <code>set-cdr!</code>  。 在Common Lisp中， <code>rplaca</code> / <code>rplacd</code> 。 这次我们使用Scheme中的名称： </p><br><pre> <code class="python hljs">cons = λ(x, y) λ(a, i, v) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-string"><span class="hljs-string">"get"</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i == <span class="hljs-number"><span class="hljs-number">0</span></span> then x = v <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> y = v; car = λ(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); cdr = λ(cell) cell(<span class="hljs-string"><span class="hljs-string">"get"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); set-car! = λ(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, val); set-cdr! = λ(cell, val) cell(<span class="hljs-string"><span class="hljs-string">"set"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, val); <span class="hljs-comment"><span class="hljs-comment">#  NIL     NIL = cons(0, 0); set-car!(NIL, NIL); set-cdr!(NIL, NIL); ## : x = cons(1, 2); println(car(x)); # 1 println(cdr(x)); # 2 set-car!(x, 10); set-cdr!(x, 20); println(car(x)); # 10 println(cdr(x)); # 20</span></span></code> </pre> <br><p> 这表明我们可以实现可变数据结构。 从代码可以明显看出，我不会深入研究它是如何工作的。 </p><br><p> 我们可以进一步实现对象，但是如果不更改语法，将很难做到。 另一种方法是在令牌生成器/解析器中实现新语法，并将其处理添加到解释器中。 所有主要的编程语言都这样做，因此有必要实现正常的性能。 我们将在本文的下一部分中添加新的语法。 </p><br><p>  [摘自译者：如果您对lambda演算感兴趣，那么有一篇关于Habré的很酷的文章专门针对这个主题： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JavaScript中的Lambda演算</a> 。 </p><br><h1 id="novye-sintaksicheskie-konstrukcii"> 新的语法构造 </h1><br><p> 我们的λ语言具有很多语法结构。 例如，没有直接添加新变量的方法。 如前所述，我们必须使用IIFE，所以它看起来像这样： </p><br><pre> <code class="python hljs">(λ(x, y){ (λ(z){ <span class="hljs-comment"><span class="hljs-comment">## it gets worse when one of the vars depends on another print(x + y + z); })(x + y); })(2, 3);</span></span></code> </pre> <br><p> 我们将添加<code>let</code>关键字。 这将允许我们编写如下内容： </p><br><pre> <code class="python hljs">let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = <span class="hljs-number"><span class="hljs-number">3</span></span>, z = x + y) print(x + y + z);</code> </pre> <br><p> 对于<code>let</code>块中的每个变量，即使在同一块中，先前的变量也应该可用。 因此，上面的代码将等效于以下代码： </p><br><pre> <code class="python hljs">(λ(x){ (λ(y){ (λ(z){ print(x + y + z); })(x + y); })(<span class="hljs-number"><span class="hljs-number">3</span></span>); })(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><p> 这些更改可以直接在解析器中进行，然后不需要解释器中的更改。 无需添加新的<code>let</code>节点，我们可以将其变成<code>call</code>和<code>lambda</code>节点。 这意味着我们没有对语言进行任何语义更改-这被称为“语法糖”，而将其转换为之前存在的AST节点的操作被称为“无糖”（原始：“ desugaring”）。 </p><br><p> 但是，无论如何我们都必须更改解析器。 让我们添加一个新的“ let”节点，因为它可以更有效地进行解释（无需创建闭包并立即调用它们，我们只需要复制和更改上下文）。 </p><br><p> 另外，我们还将添加对Scheme中“ let named”的支持。 它使创建循环更加容易： </p><br><pre> <code class="python hljs">print(let loop (n = <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p> 这是一个“递归”循环，它计算10 + 9 + ... + 0的总和。以前，我们必须这样做： </p><br><pre> <code class="python hljs">print((λ(loop){ loop = λ(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; loop(<span class="hljs-number"><span class="hljs-number">10</span></span>); })());</code> </pre> <br><p> 另外，为简化此操作，我们将添加“带有名称的功能”的语法。 它看起来像这样： </p><br><pre> <code class="python hljs">print((λ loop (n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">10</span></span>));</code> </pre> <br><p> 为此需要进行的修改： </p><br><ul><li> 支持<code>lambda</code>关键字后的可选名称。 如果存在，那么我们必须在当前上下文中添加一个变量，该变量将指向函数本身。 这与JavaScript中带有名称的函数完全相同。 </li><li> 支持新的<code>let</code>关键字。 接下来是一个可选名称和以下形式的变量定义列表（可能为空）： <code>foo = EXPRESSION</code> ，用逗号分隔。  <code>let</code>表达式的主体是单个表达式（当然，它可以是一系列表达式）。 </li></ul><br><h4 id="izmeneniya-v-parsere"> 解析器更改 </h4><br><p> 首先，对标记生成器进行一些小的更改，将<code>let</code>关键字添加到关键字列表中： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keywords = <span class="hljs-string"><span class="hljs-string">" let if then else lambda λ true false "</span></span>;</code> </pre> <br><p> 更改<code>parse_lambda</code>函数，使其读取可选名称： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span> ? input.next().value : <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-comment"><span class="hljs-comment">//   vars: delimited("(", ")", ",", parse_varname), body: parse_expression() }; }</span></span></code> </pre> <br><p> 现在添加一个解析<code>let</code>表达式的函数： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_let</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ skip_kw(<span class="hljs-string"><span class="hljs-string">"let"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input.peek().type == <span class="hljs-string"><span class="hljs-string">"var"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = input.next().value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defs = delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"call"</span></span>, <span class="hljs-attr"><span class="hljs-attr">func</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.name }), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: defs.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">def</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> def.def || FALSE }) }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"let"</span></span>, <span class="hljs-attr"><span class="hljs-attr">vars</span></span>: delimited(<span class="hljs-string"><span class="hljs-string">"("</span></span>, <span class="hljs-string"><span class="hljs-string">")"</span></span>, <span class="hljs-string"><span class="hljs-string">","</span></span>, parse_vardef), <span class="hljs-attr"><span class="hljs-attr">body</span></span>: parse_expression(), }; }</code> </pre> <br><p> 这处理两种情况。 如果在<code>let</code>之后有一个类型为<code>var</code>的令牌，则以名称命名。 此外，我们使用定<code>delimited</code>函数读取定义列表，因为它们位于方括号中并以逗号分隔，并且我们使用<code>parse_vardef</code>函数，如下所示。 接下来，我们返回类型为<code>call</code>的节点，该节点立即调用名为（IIFE）的函数。 该函数的参数是<code>let</code>定义的变量，并且<code>call</code>节点会将值作为参数传递。 而且，当然，可以使用<code>parse_expression()</code>读取函数的主体。 </p><br><p> 如果它是简单的<code>let</code> ，那么我们将返回一个类型为<code>let</code>的节点，其中包含<code>vars</code>和<code>body</code>字段。  <code>vars</code>字段包含以下格式的变量数组： <code>{ name: VARIABLE, def: AST }</code> ，这些<code>{ name: VARIABLE, def: AST }</code>由以下函数解析： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_vardef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = parse_varname(), def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_op(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) { input.next(); def = parse_expression(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: name, <span class="hljs-attr"><span class="hljs-attr">def</span></span>: def }; }</code> </pre> <br><p> 另外，您需要在<code>parse_atom</code>函数中添加对新型表达式的<code>parse_atom</code> ： </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      parse_if if (is_kw("let")) return parse_let();</span></span></code> </pre> <br><h4 id="izmeneniya-v-interpretatore"> 口译员变更 </h4><br><p> 由于我们决定更改AST的结构，而不是将其“破解”到旧的节点类型中，因此我们必须将新逻辑的处理添加到解释器中。 </p><br><p> 为了增加对可选函数名称的支持，我们修改了<code>make_lambda</code>函数： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { <span class="hljs-comment"><span class="hljs-comment">//  env = env.extend(); //  env.def(exp.name, lambda); //  } //  function lambda() { var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i &lt; arguments.length ? arguments[i] : false); return evaluate(exp.body, scope); } return lambda; }</span></span></code> </pre> <br><p> 如果函数具有名称，那么在创建闭包时，我们将复制上下文，并将函数添加到上下文中。 其余的保持不变。 </p><br><p> 最后，要处理<code>let</code>类型的节点，我们将以下情况添加到解释器中： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: exp.vars.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, v.def ? evaluate(v.def, env) : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); env = scope; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluate(exp.body, env);</code> </pre> <br><p> 注意，对于每个变量，都会创建一个新上下文，并在其中添加新变量。 之后，我们仅在最后一个上下文中执行主体。 </p><br><h4 id="primery"> 例子 </h4><br><pre> <code class="python hljs">println(let loop (n = <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> then n + loop(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>); let (x = <span class="hljs-number"><span class="hljs-number">2</span></span>, y = x + <span class="hljs-number"><span class="hljs-number">1</span></span>, z = x + y) println(x + y + z); <span class="hljs-comment"><span class="hljs-comment">#   ..     let # print(x + y + z); let (x = 10) { let (x = x * 2, y = x * x) { println(x); ## 20 println(y); ## 400 }; println(x); ## 10 };</span></span></code> </pre> <br><h4 id="proizvoditelnost-interpretatora">   </h4><br><p>   —  . </p><br><p>   .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> , ,           ,     .        JavaScript    λ. </p><br><p>    : </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"fibJS"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibJS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fibJS(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fibJS(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"time"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ret = fn(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); println(<span class="hljs-string"><span class="hljs-string">"Time: "</span></span> + (t2 - t1) + <span class="hljs-string"><span class="hljs-string">"ms"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; });</code> </pre> <br><p>  <code>time</code>  ,       ,  ,    . </p><br><pre> <code class="python hljs">fib = λ(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); print(<span class="hljs-string"><span class="hljs-string">"fib(10): "</span></span>); time( λ() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); print(<span class="hljs-string"><span class="hljs-string">"fibJS(10): "</span></span>); time( λ() println(fibJS(<span class="hljs-number"><span class="hljs-number">10</span></span>)) ); println(<span class="hljs-string"><span class="hljs-string">"---"</span></span>);</code> </pre> <br><p>   ,   Google Chrome,   n (27),  λ  ,  ,   JS   4 . , ,  . </p><br><p>       λ  JavaScript.    ,      <code>for</code> / <code>while</code> ;          JS.        ?  JS   ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a>  . </p><br><p> ,         ,          <em> </em> JavaScript,    ,    JavaScript. </p><br><p>    ,  ,  .   ,     . </p><br><h4 id="zaklyuchenie"> 结论 </h4><br><p>       ,       .  ,       - ;  ,       ,            ?   — JavaScript. ,         JavaScript —     ? ,       ,    JavaScript,        , ,    .  JavaScript    ( ,       ). </p><br><p>  ,    ,  Lisp —   :            //.    ,  ,        ..  Lisp  .    Lisp        <code>let</code> ,        ,                Lisp. </p><br><p>  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：CPS解释器</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443812/">https://habr.com/ru/post/zh-CN443812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443794/index.html">房地产销售领域中IT初创公司的主要方向</a></li>
<li><a href="../zh-CN443798/index.html">Zotero hacks：无限的同步存储及其与rmarkdown的平滑使用</a></li>
<li><a href="../zh-CN443804/index.html">C＃是低级语言吗？</a></li>
<li><a href="../zh-CN443808/index.html">对社会责任感低的女孩进行分析（由Power BI，Qlik Sense，Tableau收费）</a></li>
<li><a href="../zh-CN443810/index.html">2018年，具有不同资格的开发人员能赚多少钱</a></li>
<li><a href="../zh-CN443814/index.html">奉献是我的“老生意”</a></li>
<li><a href="../zh-CN443816/index.html">通信部坚持只有一个5G运营商</a></li>
<li><a href="../zh-CN443818/index.html">三月IT事件摘要（第二部分）</a></li>
<li><a href="../zh-CN443820/index.html">福冈机场如何发现哪些措施可以有效减少排队</a></li>
<li><a href="../zh-CN443822/index.html">表演乐团</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>