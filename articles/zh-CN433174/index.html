<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 🎨 🎩 并非所有补丁都同样有用。 🥨 💆 👈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这篇文章继续讨论性能改进的问题，如果不是针对不同的情况，则可能会实现。 关于StringBuilder的上一部分在这里 。 


 在这里，我们来看一些由于对语言规范的精妙之处，不明显的极端情况和其他原因缺乏理解而被拒绝的“改进”。 走吧 
 当没有预兆的时候 


 我认为我们每个人都使用了Col...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>并非所有补丁都同样有用。</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433174/"><p>这篇文章继续讨论性能改进的问题，如果不是针对不同的情况，则可能会实现。 关于<code>StringBuilder</code>的上一部分<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 </p><br><p> 在这里，我们来看一些由于对语言规范的精妙之处，不明显的极端情况和其他原因缺乏理解而被拒绝的“改进”。 走吧 </p><a name="habracut"></a><br><h4 id="kogda-nichto-ne-predveschaet-bedy"> 当没有预兆的时候 </h4><br><p> 我认为我们每个人都使用了<code>Collections.emptySet()</code> / <code>Collections.emptyList()</code> 。 这些非常有用的方法使您无需创建新对象即可返回空的不可变集合。 在<code>EmptyList</code>类中<code>EmptyList</code>我们将看到以下内容： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EmptyList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Iterator&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">iterator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> emptyIterator(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] toArray() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } }</code> </pre> <br><p> 看到强大的改进潜力吗？  <code>EmptyList.iterator()</code>方法从存在时返回一个空的迭代器，为什么不对<code>toArray()</code>方法返回的数组进行相同的<code>EmptyList.iterator()</code>呢？ </p><br><div class="spoiler">  <b class="spoiler_title">但是有一个叫做文档</b> <div class="spoiler_text"><blockquote> 返回的数组将是“安全的”，因为此列表不保留对其的引用。  （换句话说，即使此列表由数组支持，此方法也必须分配一个新数组）。 因此，调用者可以自由修改返回的数组。 </blockquote><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2017-September/049170.html</a> <br>  <a href="" rel="nofollow">http://hg.openjdk.java.net/jdk/jdk12/file/ffac5eabbf28/src/java.base/share/classes/java/util/List.java#l185</a> </p></div></div><br><p> 换句话说，该方法应始终返回一个<strong>新</strong>数组。 </p><br><p> 您会说：“他是一成不变的！怎么可能出问题了？？” </p><br><p> 只有经验丰富的专家才能回答以下问题： </p><br><blockquote>  -谁负责？ <br>  -负责专家Paul Sandoz和Tagir Valeev </blockquote><br><div class="spoiler">  <b class="spoiler_title">专家的答案</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2017-September/049171.html</a> </p><br><blockquote> 另请注意，这会更改可见行为。 例如 有人可能会同步toArray调用返回的数组对象，因此此更改可能会导致不必要的<strong>锁共享</strong> 。 <br><br> 我曾经提出过类似的改进：提供的数组长度为零时，从Arrays.asList（）返回EMPTY_LIST。 出于同样的原因它被拒绝了[1]。 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-September/035197.html</a> <br><br> 顺便说一句，然后Arrays.asList检查数组长度可能是合理的，例如： <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T... a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.emptyList(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(a); }</code> </pre> <br><br> 听起来合理吧？ 如果可以免费获取现成的数组，为什么还要为空数组创建一个新列表？ <br> 有理由不这样做。 目前，Arrays.asList对返回的List的身份没有指定任何约束。 添加微优化将改变这种情况。 这也是一个极端的案例，也是一个可疑的用例，但是考虑到我会保守地保持现状。 </blockquote></div></div><br><p> 这句话可能会使您感到困惑： </p><br><blockquote> 例如 有人可能会对toArray调用返回的数组对象进行同步，因此此更改可能会导致不必要的锁共享。 </blockquote><p> 您会说：“谁将在他们的正确思维中同步数组（！）从集合中返回（!!!）！！” </p><br><p> 听起来不太可信，但是这种语言提供了这样的机会，这意味着某个用户有可能这样做（甚至已经做到了）。 然后，建议的更改最多将更改代码的行为，而最坏的情况将导致同步崩溃（以后再捕获）。 风险是如此不合理，预期收益是如此微不足道，以至于最好还是保留一切。 </p><br><p> 通常，对任何对象kmk进行同步的能力是语言开发人员的错误。 首先，每个对象的标头都包含负责同步的结构，其次，我们发现自己处于上述情况，因为看似不可变的对象可以在其上同步，因此无法多次返回。 </p><br><p> 这个寓言的寓意是：规范和向后兼容性是Java的神圣代表。 甚至不要试图侵犯他们：警卫在没有警告的情况下开枪射击。 </p><br><h4 id="staraeshsya-staraeshsya"> 尝试，尝试... </h4><br><p>  JDK中一次有几个基于数组的类，它们全部实现<code>List.indexOf()</code>和<code>List.lastIndexOf()</code> ： </p><br><ul><li>  java.util.ArrayList </li><li>  java.util.Arrays $ ArrayList </li><li>  java.util.Vector </li><li>  java.util.concurrent.CopyOnWriteArrayList </li></ul><br><p> 这些类中这些方法的代码几乎一对一重复。 许多应用程序和框架还提供针对相同问题的解决方案： </p><br><ul><li>  <a href="" rel="nofollow">org.hibernate.bytecode.enhance.internal.tracker.SimpleFieldTracker</a> </li><li>  <a href="" rel="nofollow">com.intellij.util.ArrayUtil</a> </li><li>  <a href="" rel="nofollow">com.intellij.util.ArrayUtilRt</a> </li><li>  <a href="" rel="nofollow">org.springframework.oxm.jibx.JibxMarshaller</a> </li></ul><br><p> 结果，我们需要编译一些杂散的代码（有时有时需要几次），这些代码发生在ReserverCodeCache中，需要对其进行测试，并且在各个类之间徘徊几乎没有任何变化。 </p><br><p> 反过来，开发人员非常喜欢编写类似 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = Arrays.asList(array).indexOf(obj); <span class="hljs-comment"><span class="hljs-comment">//  boolean contains = Arrays.asList(array).contains(obj); //    boolean contains = Arrays.stream(names).anyMatch(nm -&gt; nm.equals(name));</span></span></code> </pre> <br><p> 我想在JDK中引入通用实用程序方法，并根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">建议</a>在各处使用它们。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">补丁</a>仅需两个便士： </p><br><p>  1） <code>List.indexOf()</code>和<code>List.lastIndexOf()</code>移至<code>java.util.Arrays</code> <br>  2）相反，分别调用<code>Arrays.indexOf()</code>和<code>Arrays.lastIndexOf()</code> </p><br><p> 看来可能出什么问题了？ 这种方法的好处显而易见。 但是本文是关于失败的，所以请考虑可能出了什么问题。 </p><br><blockquote>  -谁负责？ <br>  -负责专家Martin Buchholz和Paul Sandoz </blockquote><br><div class="spoiler">  <b class="spoiler_title">恕我直言，有点绷紧，但是</b> <div class="spoiler_text"><p> 马丁·布赫霍尔兹（Martin Buchholz）： </p><br><blockquote>  Sergey，我正在维护所有这些收集类，有时我还想在Array.java中使用indexOf方法。 但是： <br><br> 通常不建议使用数组。 数组上的任何新静态方法（或者，在我实际需要它们的地方，数组对象本身！需要更改Java语言！）都会遇到阻力。 <br><br> 我们很遗憾在集合中支持空值，因此较新的集合类（如ArrayDeque）不支持它们。 <br><br> 用户可能想要的另一个变体是要使用哪种相等比较。 <br><br> 我们感到遗憾的是，ArrayList具有从零开始的索引。从第一天开始，最好具有ArrayDeque的循环数组行​​为。 <br><br> 搜索数组切片的代码非常小，因此您不会节省太多。 容易出错，这很容易，但是对于Arrays API也是如此。 </blockquote><p> 保罗·桑多兹（Paul Sandoz）： </p><br><blockquote> 我不会说不鼓励使用数组，我会积极地将其旋转为“谨慎使用”，因为它们比较刺眼，例如总是可变的。它们肯定会得到改进。我很高兴看到数组实现了一个通用数组在“ ish”界面上，价值类型沉淀后，我们也许可以取得一些进展。 <br><br> 但是，至少对我来说，对Arrays的任何新添加都会遇到一定的阻力：-)它永远不会只添加一种或两种方法，许多其他方法也需要使用（所有原语和范围变体）。 因此，任何新功能都必须具有足够的优势，在这种情况下，我认为优势不足（例如可能减少代码缓存压力）。 </blockquote><p> 保罗 </p></div></div><br><p> 对应： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">http</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">//mail.openjdk.java.net/pipermail/core-libs-dev/2018-March/051968.html</a> </p><br><p> 这个寓言的寓意是这样的：仅仅因为他们看不到任何特殊的价值，就可以宰杀您的巧妙补丁以进行审查。 好吧，是的，有重复的代码，但是它不会打扰任何人，所以让它活下去。 </p><br><h4 id="uluchsheniya-dlya-arraylist-a-ih-est-u-menya">  ArrayList的改进？ 我有他们 </h4><br><p><del> 助力车 </del> 该补丁不是我的，我将其发布，供您思考。 提案本身已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在这里</a>表达出来，并且看起来非常有吸引力。 自己看看： </p><br><div class="spoiler">  <b class="spoiler_title">拟议的变更</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">友情链接</a> </p></div></div><br><p> 用肉眼看，这个提议是非常非常合乎逻辑的。 您可以使用简单的<a href="" rel="nofollow">基准</a>来衡量性能： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Benchmark) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayListBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Benchmark) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>, <span class="hljs-string"><span class="hljs-string">"10000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; ArrayList&lt;Integer&gt; arrayRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(size); <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span>(Level.Invocation) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initArrayList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Random rand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); rand.setSeed(System.currentTimeMillis()); <span class="hljs-comment"><span class="hljs-comment">// Populate the ArrayList with size-5 elements for (int i = 0; i &lt; size - 5; i++) { Integer r = rand.nextInt() % 256; arrayRandom.add(r); } } } @Benchmark public ArrayList construct_new_array_list(Data d) { ArrayList al = new ArrayList(d.arrayRandom); // once a new ArrayList is created add a new element al.add(new Integer(900)); return al; } }</span></span></code> </pre> <br><p> 总结： </p><br><pre> <code class="plaintext hljs">Benchmark (size) Mode Cnt Score Error Units  construct_new_array_list 10 thrpt 25 388.212 ± 23.110 ops/s construct_new_array_list 100 thrpt 25 90.208 ± 7.995 ops/s construct_new_array_list 1000 thrpt 25 23.289 ± 1.687 ops/s construct_new_array_list 10000 thrpt 25 7.659 ± 0.560 ops/s  construct_new_array_list 10 thrpt 25 562.678 ± 37.370 ops/s construct_new_array_list 100 thrpt 25 119.791 ± 13.232 ops/s construct_new_array_list 1000 thrpt 25 33.811 ± 3.812 ops/s construct_new_array_list 10000 thrpt 25 10.889 ± 0.564 ops/s</code> </pre> <br><p> 如此简单的更改一点也不差。 最主要的是，似乎没有收获。 诚实地创建一个数组，诚实地复制数据，不要忘记大小。 现在，他们一定要接受补丁！ </p><br><div class="spoiler">  <b class="spoiler_title">但是那是</b> <div class="spoiler_text"><p> 马丁·布赫霍尔兹（Martin Buchholz）： </p><br><blockquote> 毫无疑问，我们可以优化ArrayList-&gt; ArrayList的大小写，但是其他所有Collection实现又如何呢？ 我想到了ArrayDeque和CopyOnWriteArrayList。 <br>  ArrayList是一个流行的类，用于制作Collection的副本。 你在哪里停下来？ <br><br>  ArrayList的病理性子类可能会决定不将元素存储在后备数组中，从而导致损坏。 <br><br> 列表复制问题的最佳解决方案可能是List.copyOf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/List.html#copyOf(java .util.Collection</a> ）可能会进行您希望的优化。 </blockquote><p> 艾伦·贝特曼 </p><br><blockquote>  ArrayList不是最终的，因此可能有人将其扩展为使用除elementData之外的其他内容。 使用类标识而不是instanceof可能更安全。 </blockquote></div></div><br><p> 没有什么可以禁止我从<code>ArrayList</code>取消关联并将数据存储在链接列表中的。 然后， <code>c instanceof ArrayList</code>将返回真相，我们将到达复制区域并安全下落。 </p><br><p> 这个寓言的寓意是：行为的<em>可能</em>改变可能是失败的原因。 换句话说，如果语言手段允许的话，即使是最荒谬的变化，也必须牢记。 是的，如果<code>ArrayList</code>从一开始就声明为<code>final</code> ，则可以解决问题。 </p><br><h4 id="snova-specifikaciya"> 再次规格 </h4><br><p> 在调试我的应用程序时，我不小心陷入了Spring的胆量，发现以下<a href="" rel="nofollow">代码</a> ： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      paramTypes for (Constructor&lt;?&gt; candidate : candidates) { Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes(); if (constructorToUse != null &amp;&amp; argsToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) { // Already found greedy constructor that can be satisfied -&gt; // do not look any further, there are only less greedy constructors left. break; } if (paramTypes.length &lt; minNrOfArgs) { continue; }</span></span></code> </pre> <br><p> 幸运的是，通过进入<code>java.lang.reflect.Constructor.getParameterTypes()</code>我将代码向下滚动一点，找到了一个漂亮的代码： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;?&gt;[] getParameterTypes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parameterTypes.clone(); } <span class="hljs-comment"><span class="hljs-comment">/** * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@inheritDoc</span></span></span><span class="hljs-comment">} * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.8 */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parameterTypes.length; }</code> </pre> <br><p> 你看，是吗？ 如果我们需要找出构造函数/方法参数的数量，则只需调用<code>java.lang.reflect.Method.getParameterCount()</code> ，而无需复制数组。 在最简单的情况下（该方法没有参数），检查游戏是否值得尝试： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodToStringBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Method method; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ method = getClass().getMethod(<span class="hljs-string"><span class="hljs-string">"toString"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method.getParameterCount(); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParameterTypes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method.getParameterTypes().length; } }</code> </pre> <br><p> 在我的机器上以及JDK 11上，结果如下： </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units getParameterCount avgt 25 2,528 ± 0,085 ns/op getParameterCount:·gc.alloc.rate avgt 25 ≈ 10⁻⁴ MB/sec getParameterCount:·gc.alloc.rate.norm avgt 25 ≈ 10⁻⁷ B/op getParameterCount:·gc.count avgt 25 ≈ 0 counts getParameterTypes avgt 25 7,299 ± 0,410 ns/op getParameterTypes:·gc.alloc.rate avgt 25 1999,454 ± 89,929 MB/sec getParameterTypes:·gc.alloc.rate.norm avgt 25 16,000 ± 0,001 B/op getParameterTypes:·gc.churn.G1_Eden_Space avgt 25 2003,360 ± 91,537 MB/sec getParameterTypes:·gc.churn.G1_Eden_Space.norm avgt 25 16,030 ± 0,045 B/op getParameterTypes:·gc.churn.G1_Old_Gen avgt 25 0,004 ± 0,001 MB/sec getParameterTypes:·gc.churn.G1_Old_Gen.norm avgt 25 ≈ 10⁻⁵ B/op getParameterTypes:·gc.count avgt 25 2380,000 counts getParameterTypes:·gc.time avgt 25 1325,000 ms</code> </pre> <br><p> 我们该怎么办？ 我们可以在JDK中搜索反模式<code>Method.getParameterTypes().length</code> （至少在<code>java.base</code> ），并在有意义的地方将其替换： </p><br><p> <code>java.lang.invoke.MethodHandleProxies</code> </p> <br><p><img src="https://habrastorage.org/webt/l_/3j/h1/l_3jh1hu3swdedxqktlxboz0tu0.png"></p><br><p> <code>java.util.concurrent.ForkJoinTask</code> </p> <br><p><img src="https://habrastorage.org/webt/0o/rt/q7/0ortq71mnf3-bwsa4wyi-jmzf5y.png"></p><br><p> <code>java.lang.reflect.Executable</code> </p> <br><p><img src="https://habrastorage.org/webt/sm/_h/pm/sm_hpm8eahlmqavobjqg9gejvse.png"></p><br><p> <code>sun.reflect.annotation.AnnotationType</code> </p> <br><p><img src="https://habrastorage.org/webt/yw/bv/il/ywbvil_doi3fzy6uzkpcm42g6zu.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">补丁</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">求职信</a>一起发送。 </p><br><p> 突然之间，事实证明，几年来一直存在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">类似的任务，</a>甚至为此也作了准备。 评论指出，通过这种简单的更改，性能有了相当不错的提高。 但是，到目前为止，它们和我的贴片都已被清洁并且静止不动。 怎么了 可能是因为开发人员忙于处理更多必要的事情，而他们却愚蠢地没有去做。 </p><br><p> 这个寓言的寓意是这样的：仅仅由于缺乏工人，您的巧妙改变就会冻结。 </p><br><p> 但这还没有结束！ 在讨论其他项目中所述替换的合理性时，更有经验的同志提出了一个反建议：也许您不应该<code>Method.getParameterTypes().length -&gt; Method.getParameterCount()</code>替换<code>Method.getParameterTypes().length -&gt; Method.getParameterCount()</code> ，而是将其委托给编译器？ 这可能吗，并且会“合法”吗？ </p><br><p> 让我们尝试使用测试进行检查： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arrayClone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object[] objects = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[<span class="hljs-number"><span class="hljs-number">3</span></span>]; objects[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"azaza"</span></span>; objects[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">365</span></span>; objects[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">9876L</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object[] clone = objects.clone(); assertEquals(objects.length, clone.length); assertSame(objects[<span class="hljs-number"><span class="hljs-number">0</span></span>], clone[<span class="hljs-number"><span class="hljs-number">0</span></span>]); assertSame(objects[<span class="hljs-number"><span class="hljs-number">1</span></span>], clone[<span class="hljs-number"><span class="hljs-number">1</span></span>]); assertSame(objects[<span class="hljs-number"><span class="hljs-number">2</span></span>], clone[<span class="hljs-number"><span class="hljs-number">2</span></span>]); }</code> </pre> <br><p> 这将通过，并且表明如果克隆的数组没有离开范围，则可以删除它，因为可以从原始单元中访问其单元格或<code>length</code>字段中的任何元素。 </p><br><p>  JDK可以这样做吗？ 我们检查： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayAllocationEliminationBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baseline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[length].length; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baselineClone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[length].clone().length; } }</code> </pre> <br><p>  JDK 13的输出： </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units baseline avgt 50 6,135 ± 0,140 ns/op baseline:·gc.alloc.rate.norm avgt 50 56,000 ± 0,001 B/op clone avgt 50 18,359 ± 0,619 ns/op clone:·gc.alloc.rate.norm avgt 50 112,000 ± 0,001 B/op</code> </pre> <br><p> 事实证明，与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Grail</a>不同，openjdk不知道如何抛出<code>new int[length]</code> ，呵呵： </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units baseline avgt 25 2,470 ± 0,156 ns/op baseline:·gc.alloc.rate.norm avgt 25 0,005 ± 0,008 B/op lone avgt 25 13,086 ± 1,059 ns/op lone:·gc.alloc.rate.norm avgt 25 112,113 ± 0,115 B/op</code> </pre> <br><p> 事实证明，您可以对openjdk优化编译器进行一些调整，使其可以完成Grail可以执行的操作。 由于不仅每个人都可以在VM代码中打入正面广告并提交有意义的内容，所以我将自己限于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">一封</a>陈述我的观点的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">信</a>中。 </p><br><p> 事实证明，其中有一些微妙之处。 弗拉基米尔·伊万诺夫<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">表示</a> ： </p><br><blockquote> 考虑到没有办法增加/缩小Java数组， <br>  “ cloned_array.length =&gt; original_array.length”转换正确 <br> 不管克隆的变种是否逃脱。 <br><br> 而且，转换已经存在： <br><br>  <a href="" rel="nofollow">http://hg.openjdk.java.net/jdk/jdk/file/tip/src/hotspot/share/opto/memnode.cpp#l2388</a> <br><br> 我没有研究您提到的基准，但是看起来 <br>  cloned_array.length访问不是克隆数组仍然存在的原因 <br> 在那里。 <br><br> 关于您的其他想法，请将访问从克隆实例重定向到 <br> 由于编译器必须证明原始数据是有问题的（通常情况下） <br> 两个版本都没有变化，索引访问甚至使 <br> 更难。 安全点也会引起问题（用于重新实现）。 <br><br> 但是我同意覆盖（至少）一些简单的案例会很好 <br> 防御性复制。 </blockquote><p> 也就是说，敲打一个克隆似乎是可能的，而且并不是特别困难。 但是随着转换 </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[arrayLength].length;</code> </pre> <br><p>  -&gt; </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = arrayLength;</code> </pre> <br><p> 出现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">困难</a> ： </p><br><blockquote> 我们不会消除长度未知的数组分配 <br> 因为它们可能会导致NegativeArraySize异常。 在这种情况下，我们 <br> 应该能够证明长度为正。 <br><br> 无论如何-我的补丁即将完成，可以替换未使用的阵列 <br> 在适当的保护下进行分配。 </blockquote><p> 换句话说，您不能只是取消并丢弃数组的创建，因为根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">规范，</a>执行<em>必须</em>抛出<code>NegativeArraySizeException</code>而我们对此无能为力： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arrayWithNwgativeSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newLen = -<span class="hljs-number"><span class="hljs-number">3</span></span>; length = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[newLen].length; <span class="hljs-comment"><span class="hljs-comment">//  new Object[newLen]  fail(); } catch (NegativeArraySizeException e) { assert length == 0; } }</span></span></code> </pre> <br><p> 为什么圣杯能干？ 我认为原因是上述基准中的<code>length</code>字段的值恒定且始终等于10，这使探查器得出结论认为不需要检查负值，这意味着可以在创建数组本身的同时将其删除。 如果我输入有误，请在评论中更正。 </p><br><p> 今天就这些了：)我们将理解在注释中添加您的示例。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433174/">https://habr.com/ru/post/zh-CN433174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433164/index.html">速度与激情：《 Forza Horizo​​n 4》借助窗着色器加速</a></li>
<li><a href="../zh-CN433166/index.html">使用机器学习预测票务解决时间</a></li>
<li><a href="../zh-CN433168/index.html">为何程序员要在厨房实习-与Dodo Pizza讨论有关gemba，.NET和开放性的问题</a></li>
<li><a href="../zh-CN433170/index.html">我们如何无法重做公司的架构</a></li>
<li><a href="../zh-CN433172/index.html">我们将多人游戏固定在以C ++编写的iOS和Android手机游戏“用词做词”中</a></li>
<li><a href="../zh-CN433176/index.html">证书身份验证Docker远程API带有吊销验证</a></li>
<li><a href="../zh-CN433178/index.html">我们如何还原损坏的.wav文件</a></li>
<li><a href="../zh-CN433180/index.html">解决Ruby中的数据类型问题或使数据再次可靠</a></li>
<li><a href="../zh-CN433182/index.html">是否可以培训具有增强能力的股票交易代理商？ R语言实现</a></li>
<li><a href="../zh-CN433184/index.html">ASP.NET Core 2.2发布。 最新消息 （3之2）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>