<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîΩ üåî üçú Bagaimana cara menambahkan codec ke FFmpeg üíñ ‚ÅâÔ∏è üó≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FFmpeg adalah proyek Open Source besar, semacam ensiklopedia multimedia. Dengan FFmpeg Anda dapat menyelesaikan banyak tugas multimedia komputer. Namu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana cara menambahkan codec ke FFmpeg</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480714/"><hr><p>  FFmpeg adalah proyek Open Source besar, semacam ensiklopedia multimedia.  Dengan FFmpeg Anda dapat menyelesaikan banyak tugas multimedia komputer.  Namun tetap saja, terkadang ada kebutuhan untuk memperluas FFmpeg.  Cara standar adalah membuat perubahan pada kode proyek dan kemudian mengkompilasi versi baru.  Artikel ini menjelaskan cara menambahkan codec baru.  Beberapa fitur untuk menghubungkan fungsi eksternal ke FFmpeg juga dipertimbangkan.  Jika tidak perlu menambahkan codec, maka artikel tersebut mungkin berguna untuk pemahaman yang lebih baik tentang arsitektur codec FFmpeg dan pengaturannya.  Diasumsikan bahwa pembaca akrab dengan arsitektur FFmpeg, proses kompilasi FFmpeg, dan juga memiliki pengalaman pemrograman menggunakan FFmpeg API.  Deskripsi ini berlaku untuk FFmpeg 4.2 "Ada", Agustus 2019. <br></p><hr><a name="habracut"></a><br><h1>  Daftar isi </h1><br><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text"><p> <a href="https://habr.com/ru/post/480714/">Pendahuluan</a> <br>  <a href="https://habr.com/ru/post/480714/">1. Identifikasi codec</a> <br>  <a href="https://habr.com/ru/post/480714/">1.1.</a>  <a href="https://habr.com/ru/post/480714/">ID codec</a> <br>  <a href="https://habr.com/ru/post/480714/">1.2.</a>  <a href="https://habr.com/ru/post/480714/">Codec</a> <br>  <a href="https://habr.com/ru/post/480714/">2. Menambahkan codec baru ke FFmpeg</a> <br>  <a href="https://habr.com/ru/post/480714/">3. Deskripsi terperinci dari konteks dan fungsi yang diperlukan</a> <br>  <a href="https://habr.com/ru/post/480714/">3.1.</a>  <a href="https://habr.com/ru/post/480714/">Konteks codec</a> <br>  <a href="https://habr.com/ru/post/480714/">3.2.</a>  <a href="https://habr.com/ru/post/480714/">Fungsi</a> <br>  <a href="https://habr.com/ru/post/480714/">3.3.</a>  <a href="https://habr.com/ru/post/480714/">Prangko waktu</a> <br>  <a href="https://habr.com/ru/post/480714/">3.4.</a>  <a href="https://habr.com/ru/post/480714/">Fungsi lain yang digunakan oleh codec</a> <br>  <a href="https://habr.com/ru/post/480714/">4. Implementasi eksternal dari codec</a> <br>  <a href="https://habr.com/ru/post/480714/">4.1.</a>  <a href="https://habr.com/ru/post/480714/">Koneksi fungsi eksternal</a> <br>  <a href="https://habr.com/ru/post/480714/">4.2.</a>  <a href="https://habr.com/ru/post/480714/">Dekoder eksternal</a> <br>  <a href="https://habr.com/ru/post/480714/">Kesimpulan</a> <br>  <a href="https://habr.com/ru/post/480714/">Sumber daya</a> <br></p><br></div></div><br><a name="id-introdaction"></a><h1>  Pendahuluan </h1><br><p>  Codec (codec, berasal dari kombinasi istilah COder dan DECoder) adalah istilah yang sangat umum dan, seperti yang sering terjadi dalam kasus seperti itu, maknanya sedikit bervariasi tergantung pada konteksnya.  Arti utama adalah perangkat lunak atau perangkat keras untuk mengompresi / mendekompresi data media.  Alih-alih istilah kompresi / dekompresi, istilah pengkodean / decoding sering digunakan.  Tetapi dalam beberapa kasus, codec biasanya dipahami hanya berarti format kompresi (mereka juga mengatakan format codec), terlepas dari cara yang digunakan untuk kompresi / dekompresi.  Mari kita lihat bagaimana istilah codec digunakan dalam FFmpeg. <br></p><br><a name="id-1"></a><br><h1>  1. Identifikasi codec </h1><br><p>  Codec FFmpeg dikompilasi di perpustakaan <b>libavcodec</b> . <br></p><br><a name="id-1-1"></a><br><h2>  1.1.  ID codec </h2><br><p> <code>enum AVCodecID</code> didefinisikan dalam file <code>libavcodec/avcodec.h</code> .  Setiap elemen enumerasi ini mengidentifikasi format kompresi.  Elemen enumerasi ini harus dalam bentuk <code>AV_CODEC_ID_XXX</code> , di mana <code>XXX</code> nama pengenal codec unik dalam huruf besar.  Berikut adalah contoh pengidentifikasi codec: <code>AV_CODEC_ID_H264</code> , <code>AV_CODEC_ID_AAC</code> .  Untuk deskripsi yang lebih rinci tentang pengenal codec, gunakan struktur <code>AVCodecDescriptor</code> (dideklarasikan dalam <code>libavcodec/avcodec.h</code> , diberikan dalam bentuk singkatan): <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodecDescriptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVCodecID id; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVMediaType type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *long_name; <span class="hljs-comment"><span class="hljs-comment">// ... } AVCodecDescriptor;</span></span></code> </pre> <br><p>  Anggota kunci dari struktur ini adalah <code>id</code> , anggota lainnya memberikan informasi tambahan tentang pengenal codec.  Setiap pengenal codec secara unik dikaitkan dengan jenis media ( <code>type</code> anggota) dan memiliki nama unik ( <code>name</code> anggota), ditulis dalam huruf kecil.  Array tipe <code>AVCodecDescriptor</code> didefinisikan dalam file <code>libavcodec/codec_desc.c</code> <code>AVCodecDescriptor</code> .  Untuk setiap pengenal codec, ada elemen array yang sesuai.  Elemen array ini harus dipesan oleh nilai <code>id</code> , karena pencarian biner digunakan untuk mencari elemen.  Untuk mendapatkan informasi tentang pengenal codec, Anda dapat menggunakan fungsi: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVCodecDescriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_descriptor_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVCodecDescriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_descriptor_get_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">enum</span></span></span><span class="hljs-function"> AVMediaType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_get_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID codec_id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>;</code> </pre> <br><a name="id-1-2"></a><br><h2>  1.2.  Codec </h2><br><p>  Codec itu sendiri - seperangkat alat yang diperlukan untuk melakukan encoding / decoding data media, menggabungkan struktur <code>AVCodec</code> (dideklarasikan dalam <code>libavcodec/avcodec.h</code> ).  Ini versi singkatnya, lebih lengkap akan dibahas di bawah. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *long_name; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVMediaType type; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVCodecID id; <span class="hljs-comment"><span class="hljs-comment">// ... } AVCodec;</span></span></code> </pre> <br><p>  Anggota terpenting dari struktur ini adalah <code>id</code> , pengenal codec, ada juga anggota yang mendefinisikan jenis media ( <code>type</code> ), tetapi nilainya harus sesuai dengan nilai anggota yang sama dari <code>AVCodecDescriptor</code> .  Codec dibagi menjadi dua kategori: encoders, yang memampatkan atau menyandikan media, dan decoder, yang melakukan operasi yang berlawanan - dekompresi atau dekode.  (Kadang-kadang dalam teks Rusia, alih-alih istilah, encoder menggunakan kertas kalkir dari bahasa Inggris - encoder.) Tidak ada anggota khusus dalam <code>AVCodec</code> yang mendefinisikan kategori codec (meskipun kategori dapat ditentukan secara tidak langsung menggunakan fungsi <code>av_codec_is_decoder()</code> , kategori ini ditentukan saat pendaftaran. Bagaimana ini akan dilakukan akan ditunjukkan di bawah ini: Beberapa codec dapat memiliki pengidentifikasi codec yang sama. Jika mereka memiliki kategori yang sama, mereka harus berbeda dengan nama ( <code>name</code> anggota). Sebuah encoder dan decoder yang memiliki pengidentifikasi codec yang sama dapat untuk memilikinya  nama yang sama, yang mungkin juga bertepatan dengan nama pengenal codec (tetapi kecocokan ini opsional). Situasi seperti itu dapat menyebabkan beberapa kebingungan, tetapi tidak ada yang harus dilakukan, Anda harus dengan jelas memahami entitas apa nama itu dimiliki. Dalam satu kategori, nama Codec harus unik. Untuk mencari codec terdaftar, ada fungsi: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_encoder_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_decoder_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_encoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_decoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>;</code> </pre> <br><p>  Karena beberapa codec dapat memiliki pengidentifikasi yang sama, dua fungsi terakhir mengembalikan salah satunya, yang dapat dianggap sebagai codec default untuk pengenal codec yang diberikan. <br></p><br><p>  Daftar semua codec terdaftar dapat diminta dengan perintah <br></p><br><p> <code>ffmpeg -codecs &gt;codecs.txt</code> <br> </p><br><p>  Setelah menjalankan perintah, file <code>codecs.txt</code> akan berisi daftar ini.  Setiap pengenal codec akan diwakili oleh catatan (baris) terpisah.  Di sini, misalnya, entri untuk pengenal codec <code>AV_CODEC_ID_H264</code> : <br></p><br><p> <code>DEV.LS <br> h264 <br> H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 <br> (decoders: h264 h264_qsv h264_cuvid) <br> (encoders: libx264 libx264rgb h264_amf h264_nvenc h264_qsv nvenc nvenc_h264) <br></code> <br></p><br><p>  Pada awal rekaman, ada karakter khusus yang menentukan fitur umum yang tersedia untuk pengenal codec ini: <code>D</code> - decoder terdaftar, <code>E</code> - encoders terdaftar, <code>V</code> - digunakan untuk video, <code>L</code> - ada kemungkinan kompresi lossy, <code>S</code> - ada kemungkinan kompresi lossless.  Berikutnya adalah nama pengenal kodek ( <code>h264</code> ), diikuti oleh nama pengenal kodek yang panjang ( <code>H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10</code> ), dan kemudian daftar nama decoder dan enkoder terdaftar. <br></p><br><a name="id-2"></a><br><h1>  2. Menambahkan codec baru ke FFmpeg </h1><br><p>  Kami akan mempertimbangkan prosedur untuk menambahkan codec baru ke FFmpeg menggunakan contoh codec audio, yang akan kita sebut <code>FROX</code> . <br></p><br><p>  <b>Langkah 1. Tambahkan elemen baru ke <code>enum AVCodecID</code> .</b> <br></p><br><p>  Daftar ini ada di file <code>libavcodec/avcodec.h</code> .  Saat menambahkan, Anda harus mengikuti aturan: <br></p><br><ol><li>  Nilai suatu elemen tidak harus bertepatan dengan nilai-nilai elemen enumerasi yang ada; </li><li>  Jangan mengubah nilai elemen enumerasi yang ada; </li><li>  Posting nilai baru dalam kelompok codec yang sama. </li></ol><br><p>  Menurut templat, pengidentifikasi elemen ini harus <code>AV_CODEC_ID_FROX</code> .  Tempatkan sebelum <code>AV_CODEC_ID_PCM_S64LE</code> dan berikan nilai <code>0x10700</code> . <br></p><br><p>  <b>Langkah 2. Tambahkan item ke array <code>codec_descriptors</code> (file <code>libavcodec/codec_desc.c</code> ).</b> <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodecDescriptor codec_descriptors[] = { <span class="hljs-comment"><span class="hljs-comment">// ... { .id = AV_CODEC_ID_FROX, .type = AVMEDIA_TYPE_AUDIO, .name = "frox", .long_name = NULL_IF_CONFIG_SMALL("FROX audio"), .props = AV_CODEC_PROP_LOSSLESS, }, // ... };</span></span></code> </pre> <br><p>  Anda perlu menambahkan elemen ke tempat "kanan", monotonitas elemen array dengan nilai <code>id</code> tidak boleh dilanggar. <br></p><br><p>  <b>Langkah 3. Tetapkan instance <code>AVCodec</code> secara terpisah untuk encoder dan decoder.</b> <br></p><br><p>  Untuk melakukan ini, pertama-tama Anda perlu menentukan struktur untuk konteks codec dan beberapa fungsi yang akan melakukan pengkodean / decoding aktual dan beberapa operasi lain yang diperlukan.  Pada bagian ini, definisi-definisi ini akan dibuat secara sangat skematis, deskripsi yang lebih rinci akan dibuat nanti.  Kami akan menempatkan kode di file <code>libavcodec/frox.c</code> <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"avcodec.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// context typedef struct FroxContext { // ... } FroxContext; // decoder static int frox_decode_init(AVCodecContext *codec_ctx) { return -1; } static int frox_decode_close(AVCodecContext *codec_ctx) { return -1; } static int frox_decode(AVCodecContext *codec_ctx, void* outdata, int *outdata_size, AVPacket *pkt) { return -1; } AVCodec ff_frox_decoder = { .name = "frox_dec", .long_name = NULL_IF_CONFIG_SMALL("FROX audio decoder"), .type = AVMEDIA_TYPE_AUDIO, .id = AV_CODEC_ID_FROX, .priv_data_size = sizeof(FroxContext), .init = frox_decode_init, .close = frox_decode_close, .decode = frox_decode, .capabilities = AV_CODEC_CAP_LOSSLESS, .sample_fmts = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_FLT, AV_SAMPLE_FMT_NONE}, .channel_layouts = (const int64_t[]) {AV_CH_LAYOUT_MONO, 0 }, }; // encoder static int frox_encode_init(AVCodecContext *codec_ctx) { return -1; } static int frox_encode_close(AVCodecContext *codec_ctx) { return -1; } static int frox_encode(AVCodecContext *codec_ctx, AVPacket *pkt, const AVFrame *frame, int *got_pkt_ptr) { return -1; } AVCodec ff_frox_encoder = { .name = "frox_enc", .long_name = NULL_IF_CONFIG_SMALL("FROX audio encoder"), .type = AVMEDIA_TYPE_AUDIO, .id = AV_CODEC_ID_FROX, .priv_data_size = sizeof(FroxContext), .init = frox_encode_init, .close = frox_encode_close, .encode2 = frox_encode, .sample_fmts = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE}, .channel_layouts = (const int64_t[]) {AV_CH_LAYOUT_MONO, 0 }, };</span></span></span></span></code> </pre> <br><p>  Untuk kesederhanaan, dalam contoh ini, encoder dan decoder memiliki konteks yang sama - <code>FroxContext</code> , tetapi paling sering encoder dan decoder memiliki konteks yang berbeda.  Perhatikan juga bahwa <code>AVCodec</code> instance <code>AVCodec</code> harus mengikuti pola khusus. <br></p><br><p>  <b>Langkah 4. Tambahkan instance <code>AVCodec</code> ke daftar registrasi.</b> <br></p><br><p>  Pergi ke file <code>libavcodec/allcodecs.c</code> .  Pada awal file ini adalah daftar deklarasi semua codec terdaftar.  Tambahkan codec kami ke daftar ini: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> AVCodec ff_frox_decoder; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> AVCodec ff_frox_encoder;</code> </pre> <br><p>  Selama eksekusi, skrip <code>configure</code> menemukan semua deklarasi tersebut dan menghasilkan file <code>libavcodec/codec_list.c</code> , yang berisi array pointer ke codec yang dideklarasikan di <code>libavcodec/allcodecs.c</code> .  Setelah menjalankan skrip di file <code>libavcodec/codec_list.c</code> kita akan melihat: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodec * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> codec_list[] = { <span class="hljs-comment"><span class="hljs-comment">// ... &amp;ff_frox_encoder, // ... &amp;ff_frox_decoder, // ... NULL };</span></span></code> </pre> <br><p>  Juga, selama eksekusi skrip <code>configure</code> , file <code>config.h</code> , di mana kita menemukan deklarasi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONFIG_FROX_DECODER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONFIG_FROX_ENCODER 1</span></span></code> </pre> <br><p>  <b>Langkah 5. Edit <code>libavcodec/Makefile</code></b> <br></p><br><p>  Buka <code>libavcodec/Makefile</code> .  Kami menemukan bagian <code># decoders/encoders</code> , dan tambahkan di sana <br></p><br><pre> <code class="cpp hljs">OBJS-$(CONFIG_FROX_DECODER) += frox.o OBJS-$(CONFIG_FROX_ENCODER) += frox.o</code> </pre> <br><p>  <b>Langkah 6. Edit kode multiplexer dan demultiplexer.</b> <br></p><br><p>  Multiplexer (muxer) dan demultiplexer (demuxer) harus "mengetahui" codec baru.  Saat merekam, perlu untuk mencatat informasi pengidentifikasian codec ini, saat membaca, menentukan pengenal codec dari informasi pengidentifikasi.  Inilah yang perlu Anda lakukan untuk format <code>matroska</code> ( <code>*.mkv</code> ). <br></p><br><p>  1. Dalam file <code>libavformat/matroska.c</code> , tambahkan elemen untuk codec baru ke array <code>libavformat/matroska.c</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CodecTags ff_mkv_codec_tags[] = { <span class="hljs-comment"><span class="hljs-comment">// ... {"A_FROX", AV_CODEC_ID_FROX}, // ... };</span></span></code> </pre> <br><p>  String <code>"A_FROX"</code> dan akan ditulis oleh multiplexer ke file sebagai informasi pengenal.  Dalam array ini, ia dikaitkan dengan pengenal codec, oleh karena itu, ketika membaca, demultiplexer dapat dengan mudah menentukannya.  Demultiplexer menulis pengenal codec ke anggota <code>codec_id</code> dari struktur <code>codec_id</code> .  Pointer ke struktur ini adalah anggota struktur <code>AVStream</code> . <br></p><br><p>  2. Dalam file <code>libavformat/matroskaenc.c</code> , tambahkan elemen ke array <code>additional_audio_tags</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodecTag additional_audio_tags[] = { <span class="hljs-comment"><span class="hljs-comment">// ... { AV_CODEC_ID_FROX, 0XFFFFFFFF }, // ... };</span></span></code> </pre> <br><p>  Jadi semuanya sudah siap.  Pertama, jalankan skrip <code>configure</code> .  Setelah itu, Anda perlu memastikan bahwa perubahan yang dijelaskan di atas dalam file <code>libavcodec/codec_list.c</code> dan <code>config.h</code> dilakukan.  Kemudian Anda dapat menjalankan kompilasi: <br></p><br><p> <code>make clean <br> make <br></code> <br></p><br><p>  Jika kompilasi berjalan <code>ffmpeg.exe</code> , <code>ffmpeg</code> dieksekusi (atau <code>ffmpeg.exe</code> , jika OS targetnya adalah Windows) muncul.  Jalankan perintah <br></p><br><p> <code>./ffmpeg -codecs &gt;codecs.txt <br></code> <br></p><br><p>  dan pastikan FFmpeg "melihat" codec baru kami, kami menemukan entri dalam file <code>codecs.txt</code> <br></p><br><p> <code>DEA..S frox FROX audio (decoders: frox_dec) (encoders: frox_enc) <br></code> <br></p><br><a name="id-3"></a><br><h1>  3. Deskripsi terperinci dari konteks dan fungsi yang diperlukan </h1><br><p>  Pada bagian ini, kami menjelaskan secara lebih rinci seperti apa struktur konteks codec dan fungsi yang diperlukan. <br></p><br><a name="id-3-1"></a><br><h2>  3.1.  Konteks codec </h2><br><p>  Konteks codec dapat mendukung pemasangan opsi.  Untuk pembuat enkode, dukungan ini cukup sering digunakan, untuk decoder lebih jarang.  Struktur yang mendukung instalasi opsi harus memiliki pointer ke struktur <code>AVClass</code> sebagai anggota pertama dan kemudian opsi itu sendiri. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libavutil/opt.h"</span></span></span><span class="hljs-meta"> typedef struct FroxContext { const AVClass *av_class; int frox_int; char *frox_str; uint8_t *frox_bin; int bin_size; } FroxContext;</span></span></code> </pre> <br><p>  Selanjutnya, Anda perlu menentukan larik tipe <code>AVOption</code> , yang masing-masing elemen menjelaskan opsi tertentu. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVOption frox_options[] = { { <span class="hljs-string"><span class="hljs-string">"frox_int"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of int type."</span></span>, offsetof(FroxContext, frox_int), AV_OPT_TYPE_INT, { .i64 = <span class="hljs-number"><span class="hljs-number">-1</span></span> }, <span class="hljs-number"><span class="hljs-number">1</span></span>, SHRT_MAX }, { <span class="hljs-string"><span class="hljs-string">"frox_str"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of string type."</span></span>, offsetof(FroxContext, frox_str), AV_OPT_TYPE_STRING }, { <span class="hljs-string"><span class="hljs-string">"frox_bin"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of binary type."</span></span>, offsetof(FroxContext, frox_bin), AV_OPT_TYPE_BINARY }, { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }, };</code> </pre> <br><p>  Untuk setiap opsi, Anda harus menentukan nama, deskripsi, offset dalam struktur, ketik.  Anda juga dapat menentukan nilai default dan untuk opsi integer kisaran nilai yang valid. <br></p><br><p>  Selanjutnya, Anda perlu mendefinisikan instance dari jenis <code>AVClass</code> . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVClass frox_class = { .class_name = <span class="hljs-string"><span class="hljs-string">"FroxContext"</span></span>, .item_name = av_default_item_name, .option = frox_options, .version = LIBAVUTIL_VERSION_INT, };</code> </pre> <br><p>  Pointer ke instance ini harus digunakan untuk menginisialisasi anggota <code>AVCodec</code> sesuai. <br></p><br><pre> <code class="cpp hljs">AVCodec ff_frox_decoder = { <span class="hljs-comment"><span class="hljs-comment">// ... .priv_data_size = sizeof(FroxContext), .priv_class = &amp;frox_class, // ... }; AVCodec ff_frox_encoder = { // ... .priv_data_size = sizeof(FroxContext), .priv_class = &amp;frox_class, // ... };</span></span></code> </pre> <br><p>  Sekarang ketika menjalankan fungsi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AVCodecContext *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_alloc_context3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodec *codec)</span></span></span></span>;</code> </pre> <br><p>  sebuah instance dari struktur <code>AVCodecContext</code> dan anggota <code>codec</code> diinisialisasi.  Selanjutnya, berdasarkan nilai <code>codec-&gt;priv_data_size</code> , memori yang diperlukan akan dialokasikan untuk instance <code>FroxContext</code> , menggunakan nilai <code>codec-&gt;priv_class</code> anggota pertama dari instance ini akan diinisialisasi dan kemudian fungsi <code>av_opt_set_defaults()</code> akan dipanggil, yang akan mengatur nilai default untuk opsi.  Sebuah penunjuk ke instance <code>FroxContext</code> akan tersedia melalui anggota <code>priv_data</code> dari struktur <code>priv_data</code> . <br></p><br><p>  Saat bekerja dengan FFmpeg API, nilai untuk opsi dapat diatur secara langsung. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodec *codec; <span class="hljs-comment"><span class="hljs-comment">// ... AVCodecContext *codec_ctx = avcodec_alloc_context3(codec); // ... av_opt_set(codec_ctx-&gt;priv_data, "frox_str", "meow", 0); av_opt_set_int(codec_ctx-&gt;priv_data, "frox_int", 42, 0);</span></span></code> </pre> <br><p>  Cara lain adalah dengan menggunakan kamus opsi, yang akan diteruskan sebagai argumen ketiga saat memanggil <code>avcodec_open2()</code> (lihat di bawah). <br></p><br><p>  Menggunakan fungsi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVOption* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_opt_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVOption* prev)</span></span></span></span>;</code> </pre> <br><p>  Anda bisa mendapatkan daftar semua opsi yang didukung oleh konteks codec.  Ini berguna saat memeriksa codec.  Tetapi sebelum itu, Anda harus memastikan bahwa <code>codec_ctx-&gt;codec-&gt;priv_class</code> diatur ke nilai yang tidak nol, jika konteksnya tidak mendukung opsi dan operasi apa pun dengan opsi akan merusak program. <br></p><br><a name="id-3-2"></a><br><h2>  3.2.  Fungsi </h2><br><p>  Mari kita periksa lebih detail bagaimana fungsi yang digunakan dalam inisialisasi codec dan encoding / decoding yang sebenarnya diatur.  Mereka biasanya selalu perlu mendapatkan pointer ke <code>FroxContext</code> . <br></p><br><pre> <code class="cpp hljs">AVCodecContext *codec_ctx; <span class="hljs-comment"><span class="hljs-comment">// ... FroxContext* frox_ctx = codec_ctx-&gt;priv_data;</span></span></code> </pre> <br><p>  Fungsi <code>frox_decode_init()</code> dan <code>frox_encode_init()</code> akan dipanggil ketika fungsi dieksekusi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_open2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodec *codec, AVDictionary **options)</span></span></span></span>;</code> </pre> <br><p>  Mereka perlu mengalokasikan sumber daya yang diperlukan agar codec berfungsi, dan jika perlu, menginisialisasi beberapa anggota struktur <code>AVCodecContext</code> , misalnya <code>frame_size</code> untuk <code>frame_size</code> audio. <br></p><br><p>  Fungsi <code>frox_decode_close()</code> dan <code>frox_encode_close()</code> akan dipanggil ketika dieksekusi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span></span>;</code> </pre> <br><p>  Mereka perlu membebaskan sumber daya yang dialokasikan. <br></p><br><p>  Pertimbangkan fungsi untuk mengimplementasikan decoding <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata_size, AVPacket *pkt)</span></span></span></span>;</code> </pre> <br><p>  Dia harus mengimplementasikan operasi berikut: <br></p><br><ol><li>  Decoding aktual; </li><li>  Alokasi buffer yang diperlukan untuk kerangka output; </li><li>  Salin data yang diterjemahkan ke buffer bingkai. </li></ol><br><p>  Pertimbangkan cara mengalokasikan buffer yang diperlukan untuk kerangka output.  Parameter <code>outdata</code> sebenarnya menunjuk ke <code>AVFrame</code> , jadi Anda harus terlebih dahulu melakukan konversi jenis: <br></p><br><pre> <code class="cpp hljs">AVFrame* frm = outdata;</code> </pre> <br><p>  Selanjutnya, Anda perlu mengalokasikan buffer untuk menyimpan data frame.  Untuk melakukan ini, inisialisasi anggota <code>AVFrame</code> yang menentukan ukuran buffer bingkai.  Untuk audio, ini adalah <code>nb_samples</code> , <code>channel_layout</code> , <code>format</code> (untuk <code>width</code> , <code>height</code> , <code>format</code> video). <br></p><br><p>  Setelah itu, Anda perlu memanggil fungsi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_frame_get_buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVFrame* frm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alignment)</span></span></span></span>;</code> </pre> <br><p>  Pointer ke frame, yang merupakan parameter <code>outdata</code> dikonversi, digunakan sebagai argumen pertama, disarankan untuk meneruskan nol sebagai argumen kedua.  Setelah menggunakan frame (ini sudah terjadi di luar codec), buffer yang dialokasikan oleh fungsi ini dibebaskan oleh fungsi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_frame_unref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVFrame* frm)</span></span></span></span>;</code> </pre> <br><p>  Fungsi <code>frox_decode()</code> harus mengembalikan jumlah byte yang digunakan untuk decoding dari paket yang ditunjuk oleh <code>pkt</code> .  Jika pembentukan frame selesai, maka variabel yang ditunjuk oleh <code>outdata_size</code> diberi nilai bukan nol, jika variabel ini mendapat nilai <code>0</code> . <br></p><br><p>  Pertimbangkan fungsi untuk mengimplementasikan pengkodean <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, AVPacket *pkt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVFrame *frame, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *got_pkt_ptr)</span></span></span></span>;</code> </pre> <br><p>  Dia harus mengimplementasikan operasi berikut: <br></p><br><ol><li>  Pengodean aktual; </li><li>  Alokasi buffer yang diperlukan untuk paket output; </li><li>  Salin data yang disandikan ke buffer paket. </li></ol><br><p>  Untuk memilih buffer yang diperlukan, gunakan fungsinya <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_new_packet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVPacket *pkt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pack_size)</span></span></span></span>;</code> </pre> <br><p>  Parameter <code>pkt</code> digunakan sebagai argumen pertama, dan ukuran data yang disandikan adalah yang kedua.  Setelah menggunakan paket (ini sudah terjadi di luar codec), buffer yang dialokasikan oleh fungsi ini dibebaskan oleh fungsi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_packet_unref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVPacket *pkt)</span></span></span></span>;</code> </pre> <br><p>  Jika paket selesai, maka variabel yang ditunjuk oleh <code>got_pkt_ptr</code> diberi nilai bukan nol, jika variabel ini mendapat nilai <code>0</code> .  Jika tidak ada kesalahan, fungsi mengembalikan nol, jika tidak kode kesalahan. <br></p><br><p>  Saat mengimplementasikan codec, logging biasanya digunakan (untuk kesalahan ini dapat dianggap sebagai persyaratan wajib).  Berikut ini sebuah contoh: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span><span class="hljs-function"> </span></span>{ av_log(codec_ctx, AV_LOG_INFO, <span class="hljs-string"><span class="hljs-string">"FROX decode close\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Dalam hal ini, saat mengeluarkan ke log, nama codec akan digunakan sebagai nama konteks. <br></p><br><a name="id-3-3"></a><br><h2>  3.3.  Prangko waktu </h2><br><p>  Untuk mengatur waktu dalam FFmpeg, basis waktu digunakan, ditentukan dalam detik menggunakan nomor rasional yang diwakili oleh jenis <code>AVRational</code> .  (Pendekatan serupa digunakan dalam C ++ 11. Misalnya, 1/1000 menetapkan milidetik.) Frame dan paket memiliki cap waktu tipe <code>int64_t</code> , nilainya berisi waktu dalam unit waktu yang sesuai.  Bingkai, yaitu, struktur <code>AVFrame</code> , memiliki <code>pts</code> anggota (cap waktu presentasi), nilai yang menentukan waktu relatif adegan yang diambil dalam bingkai.  Paket, yaitu struktur <code>AVPacket</code> , memiliki anggota <code>pts</code> (cap waktu presentasi) dan <code>dts</code> (cap waktu dekompresi).  Nilai <code>dts</code> menentukan waktu relatif pengiriman paket untuk decoding.  Untuk codec sederhana, itu sama dengan <code>pts</code> , tetapi untuk codec kompleks bisa berbeda (misalnya, untuk <code>h264</code> ketika menggunakan B-frame), yaitu, paket dapat didekodekan dalam urutan yang salah di mana frame harus digunakan. <br></p><br><p>  Unit waktu didefinisikan untuk aliran dan codec, struktur <code>AVStream</code> memiliki anggota yang sesuai - <code>time_base</code> , anggota yang sama memiliki struktur <code>AVCodecContext</code> . <br></p><br><p>  Stempel waktu paket yang diekstrak dari aliran menggunakan <code>av_read_frame()</code> akan ditentukan dalam satuan waktu aliran ini.  Saat decoding, satuan waktu codec tidak digunakan.  Untuk video decoder, biasanya tidak disetel, untuk audio decoder memiliki nilai standar - kebalikan dari frekuensi pengambilan sampel.  Decoder harus menetapkan cap waktu untuk kerangka output berdasarkan cap waktu paket.  FFmpeg secara independen mendefinisikan label seperti itu dan menulisnya ke anggota <code>best_effort_timestamp</code> dari struktur <code>best_effort_timestamp</code> .  Semua cap waktu ini akan menggunakan satuan waktu aliran dari mana paket diekstraksi. <br></p><br><p>  Untuk pembuat enkode, Anda harus menentukan satuan waktu.  Dalam kode klien yang mengatur penguraian kode, Anda harus menetapkan nilai untuk anggota <code>time_base</code> dari struktur <code>time_base</code> sebelum memanggil <code>avcodec_open2()</code> .  Biasanya mengambil satuan waktu yang digunakan untuk prangko waktu dari frame yang dikodekan.  Jika ini tidak dilakukan, maka video encoders biasanya memberikan kesalahan, audio encoders menetapkan nilai default - kebalikan dari frekuensi sampling.  Apakah codec dapat mengubah satuan waktu tertentu tidak sepenuhnya jelas.  Untuk berjaga-jaga, lebih baik untuk selalu memeriksa nilai <code>time_base</code> setelah memanggil <code>avcodec_open2()</code> dan, jika sudah berubah, <code>avcodec_open2()</code> ulang cap waktu frame input per unit waktu codec.  Dalam proses pengkodean, Anda harus menginstal <code>pts</code> dan <code>dts</code> paket.  Setelah pengkodean, sebelum menulis paket ke aliran output, perlu untuk menghitung ulang cap waktu paket dari unit waktu codec ke unit waktu aliran.  Untuk melakukan ini, gunakan fungsinya <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_packet_rescale_ts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVPacket *pkt, AVRational tb_src, AVRational tb_dst)</span></span></span></span>;</code> </pre> <br><p>  Saat menulis paket ke stream, perlu untuk memastikan bahwa nilai <code>dts</code> benar-benar meningkat, jika tidak maka multiplexer akan melempar kesalahan.  (Untuk informasi lebih lanjut, lihat dokumentasi untuk fungsi <code>av_interleaved_write_frame()</code> .) <br></p><br><a name="id-3-4"></a><br><h2>  3.4.  Fungsi lain yang digunakan oleh codec </h2><br><p>  Saat Anda menginisialisasi instance <code>AVCodec</code> , dua fungsi lagi dapat didaftarkan.  Berikut adalah anggota <code>AVCodec</code> relevan: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... void (*init_static_data)(AVCodec *codec); void (*flush)(AVCodecContext *codec_ctx); // ... } AVCodec;</span></span></code> </pre> <br><p>  Yang pertama dari mereka dipanggil sekali pada saat pendaftaran codec. <br></p><br><p>  Yang kedua me-reset keadaan internal codec, itu akan dipanggil selama eksekusi fungsi <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_flush_buffers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span></span>;</code> </pre> <br><p>  Panggilan ini diperlukan, misalnya, ketika secara paksa mengubah posisi pemutaran saat ini. <br></p><br><a name="id-4"></a><br><h1>  4. Implementasi eksternal dari codec </h1><br><a name="id-4-1"></a><br><h2>  4.1.  Koneksi fungsi eksternal </h2><br><p>  Pertimbangkan organisasi codec berikut: codec yang terdaftar di FFmpeg memainkan peran kerangka kerja, dan mendelegasikan prosedur pengodean / dekode aktual ke fungsi eksternal (semacam plugin) yang diterapkan di luar FFmpeg. <br></p><br><p>        .  Inilah beberapa di antaranya: <br></p><br><ol><li>       ,   FFmpeg    ; </li><li>     C,    ,   C++; </li><li>     framework,     FFmpeg. </li></ol><br><p>    ,   FFmpeg       ¬´¬ª,         FFmpeg API.             ¬´¬ª FFmpeg       (  ,     ),     .    ‚Äî     .         . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dec_extern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext* codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata_size, AVPacket* pkt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* out_buff; <span class="hljs-comment"><span class="hljs-comment">//      out_buff FroxContext *fc = codec_ctx-&gt;priv_data; if (fc-&gt;bin_size &gt; 0) { if (fc-&gt;bin_size == sizeof(dec_extern_t)) { dec_extern_t edec; memcpy(&amp;edec, fc-&gt;frox_bin, fc-&gt;bin_size); ret = (*edec)(pkt-&gt;data, pkt-&gt;size, out_buff); if (ret &gt;= 0) { //     out_buff   } } else { /*  */ } } else { /*    */ } // ... return ret; }</span></span></code> </pre> <br><p>    FFmpeg API (     C++)    . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeFroxData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outBuff)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dec_extern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt; #include &lt;libavutil/opt.h&gt; } // ... AVCodecContext* ctx; // ... dec_extern_t dec = DecodeFroxData; void* pv = &amp;dec; auto pb = static_cast&lt;const uint8_t*&gt;(pv); auto sz = sizeof(dec); av_opt_set_bin(ctx-&gt;priv_data, "frox_bin", pb, sz, 0);</span></span></span></span></code> </pre> <br><a name="id-4-2"></a><br><h2> 4.2.   </h2><br><p>       ‚Äî     .        ,   . ,      .  ,   ,  FFmpeg     ,   ¬´¬ª ,        .         .     ,   .   FFmpeg API  -       ,   ,      .     .        ,        .     PC (Windows)      DirectShow  AVI .  PC             -   DirectShow.     32- FourCC. (   <code>biCompression</code>  <code>BITMAPINFOHEADER</code> .)  ,      DirectShow   ,   PC    -.        FFmpeg  , ,   ,   <code>codec_tag</code>  <code>AVCodecParameters</code>   FourCC,     .       FFmpeg API    ,    .             FFmpeg   FFmpeg API. <br></p><br><p>          ,   <code>*.mkv</code>  FFmpeg     ( <code>ENCODER</code> ). <br></p><br><a name="id-concl"></a><br><h1>  Kesimpulan </h1><br><p>        ,   ,       FFmpeg: , changelog,     ..     ¬´¬ª  FFmpeg,     ,     . <br></p><br><a name="id-refs"></a><br><h1>  Sumber daya </h1><br><p> <b>   FFmpeg</b> </p><br><p> [1] <a href="https://ffmpeg.org/" rel="nofollow">FFmpeg ‚Äî  </a> <br> [2] <a href="https://ffmpeg.org/documentation.html" rel="nofollow">FFmpeg ‚Äî </a> <br> [3] <a href="https://ru.wikipedia.org/wiki/FFmpeg" rel="nofollow">FFmpeg ‚Äî </a> <br> [4] <a href="https://help.ubuntu.ru/wiki/ffmpeg" rel="nofollow">FFmpeg ‚Äî    Ubuntu</a> <br></p><br><p> <b></b> </p><br><p> [5] <a href="https://trac.ffmpeg.org/wiki/CompilationGuide" rel="nofollow">FFmpeg Compilation Guide</a> <br> [6] Compilation of FFmpeg 4.0 in Windows 10 <br></p><br><p> <b>   FFmpeg API</b> </p><br><p> [7] <a href="https://habr.com/ru/post/137793/">   ffmpeg</a> <br></p><br><p> <b> </b> </p><br><p> [8] <a href="https://wiki.multimedia.cx/index.php/FFmpeg_codec_HOWTO" rel="nofollow">FFmpeg codec HOWTO</a> <br> [9] <a href="http://ogorkis.net/ffmpeg" rel="nofollow">FFmpeg video codec tutorial</a> <br></p><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480714/">https://habr.com/ru/post/id480714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480702/index.html">SDM dan talenta, pakar dan kreatif: bagaimana Habraseminar yang kedelapan</a></li>
<li><a href="../id480704/index.html">Membuat konten responsif dimuat di situs</a></li>
<li><a href="../id480708/index.html">Dekade akan segera berakhir. Aplikasi apa di Google Play yang paling banyak diunduh dalam 10 tahun terakhir?</a></li>
<li><a href="../id480710/index.html">Refactoring game SFML</a></li>
<li><a href="../id480712/index.html">Penerbangan dengan Dosimeter di Saku</a></li>
<li><a href="../id480716/index.html">Matlab vs. Julia vs. Python</a></li>
<li><a href="../id480718/index.html">6 Tips untuk Tinjauan Kode yang Sukses</a></li>
<li><a href="../id480724/index.html">Bahasa yang ditranskompilasi: proyek konversi kode-ke-kode</a></li>
<li><a href="../id480730/index.html">Pengembangan Auto-Moto dan Nginx</a></li>
<li><a href="../id480734/index.html">Daripada TestMace lebih baik dari Postman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>