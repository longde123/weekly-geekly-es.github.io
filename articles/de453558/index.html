<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôãÔ∏è üë®üèæ‚Äçüíª üêæ Einf√ºhrung in das maschinelle Lernen üôà üòÑ ‚ôäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Den vollst√§ndigen Kurs in Russisch finden Sie unter diesem Link . 
 Der urspr√ºngliche Englischkurs ist unter diesem Link verf√ºgbar. 



 Alle 2-3 Tage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in das maschinelle Lernen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453558/">  Den vollst√§ndigen Kurs in Russisch finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link</a> . <br>  Der urspr√ºngliche Englischkurs ist unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link</a> verf√ºgbar. <br><br><img src="https://habrastorage.org/webt/f-/6y/ml/f-6ymlhmfceofcmhbv2qsfv2hfu.jpeg"><br><a name="habracut"></a><br>  <i>Alle 2-3 Tage sind neue Vortr√§ge geplant.</i> <br><br><h2>  Interview mit Sebastian Trun, CEO Udacity </h2><br>  "Hallo nochmal, ich bin Paige und du bist heute mein Gast, Sebastian." <br>  - Hallo, ich bin Sebastian! <br>  - ... ein Mann, der eine unglaubliche Karriere hat, der es geschafft hat, viele erstaunliche Dinge zu tun!  Sie sind Mitbegr√ºnder von Udacity, haben Google X gegr√ºndet und sind Professor an der Stanford University.  Sie haben w√§hrend Ihrer gesamten Karriere unglaubliche Forschung betrieben und tiefgreifend gelernt.  Was hat Sie am meisten befriedigt und in welchem ‚Äã‚ÄãBereich haben Sie die meisten Belohnungen f√ºr die geleistete Arbeit erhalten? <br>  - Ehrlich gesagt, ich liebe es wirklich, im Silicon Valley zu sein!  Ich mag es, in der N√§he von Menschen zu sein, die viel schlauer sind als ich, und ich habe Technologie immer als ein Werkzeug angesehen, das die Spielregeln auf verschiedene Weise √§ndert - von Bildung √ºber Logistik bis hin zu Gesundheitswesen usw.  All dies √§ndert sich so schnell und es besteht ein unglaublicher Wunsch, an diesen Ver√§nderungen teilzunehmen und sie zu beobachten.  Sie schauen auf Ihre Umgebung und verstehen, dass das meiste, was Sie um sich herum sehen, nicht so funktioniert, wie es sollte - Sie k√∂nnen immer etwas Neues erfinden! <br>  - Nun, das ist eine sehr optimistische Sicht der Technologie!  Was war die gr√∂√üte Eureka w√§hrend Ihrer Karriere? <br>  - Herr, es gab so viele!  Ich erinnere mich an einen Tag, an dem Larry Page mich anrief und vorschlug, Autopilot-Autos zu bauen, die durch alle Stra√üen Kaliforniens fahren k√∂nnten.  Zu dieser Zeit galt ich als Experte, ich wurde zu diesen gez√§hlt und ich war genau die Person, die sagte: "Nein, das geht nicht."  Danach hat Larry mich √ºberzeugt, dass es im Prinzip m√∂glich ist, dies zu tun, man muss nur anfangen und es versuchen.  Und wir haben es geschafft!  Dies war der Moment, in dem mir klar wurde, dass selbst Experten falsch liegen und ‚ÄûNein‚Äú sagen, wir sind 100% pessimistisch.  Ich denke, wir sollten offener f√ºr das Neue sein. <br>  - Oder wenn Larry Page Sie anruft und sagt: "Hey, mach eine coole Sache wie Google X" und du bekommst etwas ziemlich Cooles! <br>  - Ja, das ist sicher, Sie m√ºssen sich nicht beschweren!  Ich meine, all dies ist ein Prozess, der auf dem Weg zur Implementierung viel diskutiert wird.  Ich habe gro√ües Gl√ºck zu arbeiten und bin stolz darauf, bei Google X und bei anderen Projekten. <br>  - Super!  In diesem Kurs geht es also nur um die Arbeit mit TensorFlow.  Haben Sie Erfahrung mit TensorFlow oder sind Sie damit vertraut (geh√∂rt)? <br>  - Ja!  Ich liebe TensorFlow buchst√§blich!  In meinem eigenen Labor verwenden wir es oft und h√§ufig. Eines der bedeutendsten Werke, das auf TensorFlow basiert, wurde vor etwa zwei Jahren ver√∂ffentlicht.  Wir haben gelernt, dass iPhone und Android Hautkrebs wirksamer erkennen k√∂nnen als die besten Dermatologen der Welt.  Wir haben unsere Forschungen in Nature ver√∂ffentlicht und dies hat zu einer Art Aufregung in der Medizin gef√ºhrt. <br>  - Das klingt gro√üartig!  Sie kennen und lieben TensorFlow, das an sich gro√üartig ist!  Haben Sie bereits mit TensorFlow 2.0 gearbeitet? <br>  - Nein, leider hatte ich noch keine Zeit. <br>  - Er wird einfach unglaublich sein!  Alle Teilnehmer dieses Kurses arbeiten mit dieser Version. <br>  - Ich beneide sie!  Ich werde es auf jeden Fall versuchen! <br>  - Gro√üartig!  In unserem Kurs gibt es viele Studenten, die sich in ihrem Leben noch nie mit maschinellem Lernen besch√§ftigt haben, vom Wort "vollst√§ndig".  F√ºr sie kann das Feld neu sein, vielleicht ist es f√ºr jemanden, der selbst programmiert, neu.  Welchen Rat hast du f√ºr sie? <br>  - Ich m√∂chte, dass sie offen bleiben - f√ºr neue Ideen, Techniken, L√∂sungen, Positionen.  Maschinelles Lernen ist eigentlich einfacher als Programmieren.  Bei der Programmierung m√ºssen Sie jeden Fall in den Quelldaten ber√ºcksichtigen, die Programmlogik und die Regeln daf√ºr anpassen.  Zu diesem Zeitpunkt trainieren Sie den Computer mithilfe von TensorFlow und maschinellem Lernen im Wesentlichen anhand von Beispielen, sodass der Computer die Regeln selbst finden kann. <br>  - Das ist unglaublich interessant!  Ich kann es kaum erwarten, den Studenten in diesem Kurs etwas mehr √ºber maschinelles Lernen zu erz√§hlen!  Sebastian, danke, dass du dir die Zeit genommen hast, heute zu uns zu kommen! <br>  - Danke!  Bleib in Kontakt! <br><br><h2>  Was ist maschinelles Lernen? </h2><br>  Beginnen wir also mit der folgenden Aufgabe - gegebenen Eingabe- und Ausgabewerten. <br><br><img src="https://habrastorage.org/webt/a2/ec/84/a2ec84ej7mnna9degt489lkhgxs.jpeg"><br><br>  Wenn Sie den Wert 0 als Eingabewert haben, dann 32 als Ausgabewert. Wenn Sie 8 als Eingabewert haben, dann 46,4 als Ausgabewert.  Wenn Sie 15 als Eingabewert haben, dann 59 als Ausgabewert und so weiter. <br><br>  Schauen Sie sich diese Werte genauer an und lassen Sie mich eine Frage stellen.  K√∂nnen Sie bestimmen, wie die Ausgabe aussehen wird, wenn wir am Eingang 38 erhalten? <br><br><img src="https://habrastorage.org/webt/p6/dj/5o/p6dj5o7yrrekj2vxzexnq6hqpi0.jpeg"><br><br>  Wenn Sie mit 100.4 geantwortet haben, hatten Sie Recht! <br><br><img src="https://habrastorage.org/webt/bv/z9/-k/bvz9-kkmmvjurwja9ltuupq-lje.jpeg"><br><br>  Wie k√∂nnen wir dieses Problem l√∂sen?  Wenn Sie sich die Werte genau ansehen, k√∂nnen Sie sehen, dass sie durch den Ausdruck zusammenh√§ngen: <br><br><img src="https://habrastorage.org/webt/bm/ql/pq/bmqlpqb79ptaf8q_gsikh9wg3pg.jpeg"><br><br>  Wobei C - Grad Celsius (Eingabewerte), F - Fahrenheit (Ausgabewerte). <br><br>  Was Ihr Gehirn gerade getan hat - Eingabewerte und Ausgabewerte verglichen und ein gemeinsames Modell (Verbindung, Abh√§ngigkeit) zwischen ihnen gefunden - ist das, was maschinelles Lernen tut. <br><br>  Basierend auf den Eingabe- und Ausgabewerten finden Algorithmen f√ºr maschinelles Lernen einen geeigneten Algorithmus zum Konvertieren von Eingabewerten in Ausgabewerte.  Dies kann wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/_m/c8/zq/_mc8zq1ochmxaq78aqd39ktngqm.jpeg"><br><br>  Schauen wir uns ein Beispiel an.  Stellen Sie sich vor, wir m√∂chten ein Programm entwickeln, das Grad Celsius in Grad Fahrenheit mit der Formel <code>F = C * 1.8 + 32</code> umwandelt. <br><br><img src="https://habrastorage.org/webt/me/0w/t6/me0wt6lyjkzoqbgdwb3-tvtv2s0.jpeg"><br><br>  Die L√∂sung kann aus Sicht der traditionellen Softwareentwicklung in jeder Programmiersprache mit der folgenden Funktion implementiert werden: <br><br><img src="https://habrastorage.org/webt/e3/oi/zk/e3oizkl4oob_fnd2yq-i1fxifwk.jpeg"><br><br>  Was haben wir also?  Die Funktion nimmt einen Eingabewert von C an, berechnet dann den Ausgabewert von F unter Verwendung eines expliziten Algorithmus und gibt dann den berechneten Wert zur√ºck. <br><br><img src="https://habrastorage.org/webt/d7/vn/yh/d7vnyhgewv7pknnv0bmepxybtg8.jpeg"><br><br>  Andererseits haben wir beim Ansatz des maschinellen Lernens nur Eingabe- und Ausgabewerte, nicht aber den Algorithmus selbst: <br><br><img src="https://habrastorage.org/webt/m1/3s/wy/m13swy6p2a4z_wuboqdawda7m-8.jpeg"><br><br>  Der Ansatz des maschinellen Lernens beruht auf der Verwendung neuronaler Netze, um die Beziehung zwischen Eingabe- und Ausgabewerten zu finden. <br><br><img src="https://habrastorage.org/webt/sd/_u/cb/sd_ucbyegwsntvcufqhgzqgqefs.jpeg"><br><br>  Sie k√∂nnen sich neuronale Netze als einen Stapel von Schichten vorstellen, von denen jede aus zuvor bekannten mathematischen (Formeln) und internen Variablen besteht.  Der Eingabewert tritt in das neuronale Netzwerk ein und durchl√§uft einen Stapel von Schichten von Neuronen.  Beim Durchlaufen der Ebenen wird der Eingabewert gem√§√ü der Mathematik (vorgegebene Formeln) und den Werten der internen Variablen der Ebenen konvertiert, wodurch ein Ausgabewert erzeugt wird. <br><br>  Damit das neuronale Netzwerk die richtige Beziehung zwischen den Eingabe- und Ausgabewerten lernen und bestimmen kann, m√ºssen wir es trainieren - trainieren. <br><br>  Wir trainieren das neuronale Netzwerk durch wiederholte Versuche, Eingabewerte mit Ausgabewerten abzugleichen. <br><br><img src="https://habrastorage.org/webt/a7/8r/k5/a78rk54x-g6lpgjm67cvmuas43c.jpeg"><br><br>  W√§hrend des Trainings erfolgt die ‚ÄûAnpassung‚Äú (Auswahl) der Werte interner Variablen in den Schichten des neuronalen Netzwerks, bis das Netzwerk lernt, die entsprechenden Ausgabewerte zu den entsprechenden Eingabewerten zu generieren. <br><br>  Wie wir sp√§ter sehen werden, werden Tausende oder Zehntausende von Iterationen (Trainings) durchgef√ºhrt, um ein neuronales Netzwerk zu trainieren und es in die Lage zu versetzen, die am besten geeigneten Werte f√ºr interne Variablen auszuw√§hlen. <br><br><img src="https://habrastorage.org/webt/kv/h5/xa/kvh5xahns3dammp0e1-guhsjwmg.jpeg"><br><br>  Als vereinfachte Version des Verst√§ndnisses des maschinellen Lernens k√∂nnen Sie sich Algorithmen f√ºr maschinelles Lernen als Funktionen vorstellen, die die Werte interner Variablen so ausw√§hlen, dass die richtigen Eingabewerte den korrekten Ausgabewerten entsprechen. <br><br>  Es gibt viele Arten von neuronalen Netzwerkarchitekturen.  Unabh√§ngig davon, f√ºr welche Architektur Sie sich entscheiden, bleibt die Mathematik im Inneren (welche Berechnungen werden in welcher Reihenfolge durchgef√ºhrt) w√§hrend des Trainings unver√§ndert.  Anstatt die Mathematik zu √§ndern, √§ndern sich die internen Variablen (Gewichte und Offsets) w√§hrend des Trainings. <br><br>  Bei der Umrechnung von Grad Celsius in Fahrenheit beginnt das Modell beispielsweise damit, den Eingabewert mit einer bestimmten Zahl (Gewicht) zu multiplizieren und einen weiteren Wert (Offset) hinzuzuf√ºgen.  Das Modelltraining besteht darin, geeignete Werte f√ºr diese Variablen zu finden, ohne die durchgef√ºhrten Multiplikations- und Additionsoperationen zu √§ndern. <br><br>  Aber eine coole Sache zum Nachdenken!  Wenn Sie das Problem der Umrechnung von Grad Celsius in Fahrenheit gel√∂st haben, das im Video und im folgenden Text angegeben ist, haben Sie es wahrscheinlich gel√∂st, weil Sie bereits Erfahrung oder Kenntnisse dar√ºber hatten, wie diese Art der Umrechnung von Grad Celsius in Fahrenheit durchgef√ºhrt wird.  Zum Beispiel wissen Sie vielleicht nur, dass 0 Grad Celsius 32 Grad Fahrenheit entsprechen.  Auf der anderen Seite verf√ºgen Systeme, die auf maschinellem Lernen basieren, nicht √ºber unterst√ºtzende Vorkenntnisse, um das Problem zu l√∂sen.  Sie lernen, solche Probleme nicht auf der Grundlage von Vorkenntnissen und in ihrer v√∂lligen Abwesenheit zu l√∂sen. <br><br>  Genug geredet - fahren Sie mit dem praktischen Teil der Vorlesung fort! <br><br><h2>  CoLab: Konvertieren Sie Grad Celsius in Grad Fahrenheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die russische Version des CoLab-Quellcodes</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">englische Version des CoLab-Quellcodes</a> . <br><br><h2>  Die Grundlagen: das erste Modell lernen </h2><br>  Willkommen bei CoLab, wo wir unser erstes Modell f√ºr maschinelles Lernen trainieren werden! <br><br>  Wir werden versuchen, die Einfachheit des vorgestellten Materials beizubehalten und nur die f√ºr die Arbeit erforderlichen Grundkonzepte einzuf√ºhren.  Nachfolgende CoLabs enthalten fortgeschrittenere Techniken. <br><br>  Die Aufgabe, die wir l√∂sen werden, ist die Umrechnung von Grad Celsius in Grad Fahrenheit.  Die Umrechnungsformel lautet wie folgt: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.452ex" height="2.419ex" viewBox="0 -780.1 7944.7 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-3D" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-63" x="1884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-6D" x="2568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-61" x="3446" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-6C" x="3976" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-31" x="4274" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-2C" x="4775" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-38" x="5220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-2B" x="5942" y="0"></use><g transform="translate(6943,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f = c \ mal 1,8 + 32 </script></p><br><br>  Nat√ºrlich w√§re es einfacher, einfach eine Konvertierungsfunktion in Python oder einer anderen Programmiersprache zu schreiben, die direkte Berechnungen durchf√ºhren w√ºrde, aber in diesem Fall w√§re es kein maschinelles Lernen :) <br><br>  Stattdessen geben wir in die TensorFlow-Eingabe die Eingabegrade von Celsius (0, 8, 15, 22, 38) und die entsprechenden Fahrenheit-Grade (32, 46, 59, 72, 100) ein.  Dann werden wir das Modell so trainieren, dass es ungef√§hr der obigen Formel entspricht. <br><br><h3>  Abh√§ngigkeiten importieren </h3><br>  Das erste, was wir importieren, ist <code>TensorFlow</code> .  Hier und im Folgenden nennen wir es kurz <code>tf</code> .  Wir konfigurieren auch die Protokollierungsstufe - nur Fehler. <br><br>  Als n√§chstes importieren Sie <code>NumPy</code> als <code>np</code> .  <code>Numpy</code> hilft uns, unsere Daten als Hochleistungslisten <code>Numpy</code> . <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf tf.logging.set_verbosity(tf.logging.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre><br><h3>  Vorbereitung der Trainingsdaten </h3><br>  Wie wir bereits gesehen haben, basiert die maschinelle Lerntechnik mit dem Lehrer auf der Suche nach einem Algorithmus zum Konvertieren von Eingabedaten in Ausgaben.  Da die Aufgabe dieses CoLab darin besteht, ein Modell zu erstellen, das das Ergebnis der Umrechnung von Grad Celsius in Grad Fahrenheit erzeugen kann, erstellen wir zwei Listen - <code>celsius_q</code> und <code>fahrenheit_a</code> , die wir beim Training unseres Modells verwenden. <br><br><pre> <code class="python hljs">celsius_q = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>], dtype=float) fahrenheit_a = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>], dtype=float) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(celsius_q): print(<span class="hljs-string"><span class="hljs-string">"{}   = {}  "</span></span>.format(c, fahrenheit_a[i]))</code> </pre><br> <code>-40.0   = -40.0   <br> -10.0   = 14.0   <br> 0.0   = 32.0   <br> 8.0   = 46.0   <br> 15.0   = 59.0   <br> 22.0   = 72.0   <br> 38.0   = 100.0   <br></code> <br>  Einige Terminologie f√ºr maschinelles Lernen: <br><br><ul><li>  <b>Eigenschaft</b> ist der Eingabewert (die Eingabewerte) unseres Modells.  In diesem Fall betr√§gt der Einheitswert Grad Celsius. </li><li>  <b>Beschriftungen</b> sind die Ausgabewerte, die unser Modell vorhersagt.  In diesem Fall betr√§gt der Einheitswert Grad Fahrenheit. </li><li>  <b>Ein Beispiel</b> ist ein Paar von Eingabe-Ausgabe-Werten, die f√ºr das Training verwendet werden.  In diesem Fall ist dies ein Wertepaar aus <code>celsius_q</code> und <code>fahrenheit_a</code> unter einem bestimmten Index, z. B. (22,72). </li></ul><br><h2>  Erstellen Sie ein Modell </h2><br>  Als n√§chstes erstellen wir ein Modell.  Wir werden das einfachste Modell verwenden - das Modell eines vollst√§ndig verbundenen Netzwerks ( <code>Dense</code> Netzwerk).  Da die Aufgabe ziemlich trivial ist, besteht das Netzwerk auch aus einer einzelnen Schicht mit einem einzelnen Neuron. <br><br><h4>  Aufbau eines Netzwerks </h4><br>  Wir werden die Ebene <code>l0</code> ( <b>l</b> ayer und zero) <code>tf.keras.layers.Dense</code> und sie erstellen, indem <code>tf.keras.layers.Dense</code> mit den folgenden Parametern initialisieren: <br><br><ul><li>  <code>input_shape=[1]</code> - Dieser Parameter bestimmt die Dimension des Eingabeparameters - ein einzelner Wert.  1 √ó 1 Matrix mit einem einzelnen Wert.  Da dies die erste (und einzige) Schicht ist, entspricht die Dimension der Eingabedaten der Dimension des gesamten Modells.  Der einzige Wert ist ein Gleitkommawert, der Grad Celsius darstellt. </li><li>  <code>units=1</code> - Dieser Parameter bestimmt die Anzahl der Neuronen in der Schicht.  Die Anzahl der Neuronen bestimmt, wie viele interne Schichtvariablen f√ºr das Training verwendet werden, um eine L√∂sung f√ºr das Problem zu finden.  Da dies die letzte Ebene ist, entspricht ihre Dimension der Dimension des Ergebnisses - dem Ausgabewert des Modells - einer einzelnen Gleitkommazahl, die Grad Fahrenheit darstellt.  (In einem mehrschichtigen Netzwerk m√ºssen Gr√∂√üe und Form der <code>input_shape</code> mit der Gr√∂√üe und Form der n√§chsten Ebene √ºbereinstimmen.) </li></ul><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><h4>  Ebenen in Modell konvertieren </h4><br>  Sobald Ebenen definiert sind, m√ºssen sie in ein Modell konvertiert werden.  <code>Sequential</code> Modell verwendet als Argumente die Liste der Ebenen in der Reihenfolge, in der sie angewendet werden m√ºssen - vom Eingabewert bis zum Ausgabewert. <br><br>  Unser Modell hat nur eine Schicht - <code>l0</code> . <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([l0])</code> </pre><br>  <b>Hinweis</b> <br>  Sehr oft werden Sie auf die Definition von Ebenen direkt in der Modellfunktion sto√üen und nicht auf deren vorl√§ufige Beschreibung und anschlie√üende Verwendung: <br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ])</code> </pre><br><h3>  Wir kompilieren ein Modell mit einer Verlust- und Optimierungsfunktion </h3><br>  Vor dem Training muss das Modell zusammengestellt (zusammengebaut) werden.  Wenn Sie f√ºr das Training kompilieren, ben√∂tigen Sie: <br><br><ul><li>  <b>Verlustfunktion</b> - eine Methode zum Messen, wie weit der vorhergesagte Wert vom gew√ºnschten Ausgabewert entfernt ist (eine messbare Differenz wird als ‚ÄûVerlust‚Äú bezeichnet). </li><li>  <b>Optimierungsfunktion</b> - eine M√∂glichkeit, interne Variablen anzupassen, um Verluste zu reduzieren. </li></ul><br><br><pre> <code class="python hljs">model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>))</code> </pre><br>  Die Verlustfunktion und die Optimierungsfunktion werden w√§hrend des Modelltrainings ( <code>model.fit(...)</code> unten erw√§hnt) verwendet, um an jedem Punkt erste Berechnungen durchzuf√ºhren und dann die Werte zu optimieren. <br><br>  Die Berechnung der aktuellen Verluste und die anschlie√üende Verbesserung dieser Werte im Modell ist genau das, was Training ist (eine Iteration). <br><br>  W√§hrend des Trainings werden mit der Optimierungsfunktion Anpassungen der Werte interner Variablen berechnet.  Ziel ist es, die Werte interner Variablen im Modell so anzupassen (und dies ist in der Tat eine mathematische Funktion), dass sie den vorhandenen Ausdruck f√ºr die Umrechnung von Grad Celsius in Grad Fahrenheit so genau wie m√∂glich widerspiegeln. <br><br>  TensorFlow verwendet numerische Analysen, um diese Art von Optimierungsvorg√§ngen durchzuf√ºhren, und all diese Komplexit√§t ist unseren Augen verborgen, sodass wir in diesem Kurs nicht auf Details eingehen werden. <br><br>  Was ist n√ºtzlich, um √ºber diese Optionen zu wissen: <br><br>  Die in diesem Beispiel verwendete Verlustfunktion (Standardfehler) und Optimierungsfunktion (Adam) sind Standard f√ºr solche einfachen Modelle, aber viele andere sind neben ihnen verf√ºgbar.  Derzeit ist es uns egal, wie diese Funktionen funktionieren. <br><br>  Was Sie beachten sollten, ist die Optimierungsfunktion und der Parameter ist der <code>learning rate</code> , der in unserem Beispiel <code>0.1</code> betr√§gt.  Dies ist die verwendete Schrittgr√∂√üe beim Anpassen der internen Werte von Variablen.  Wenn der Wert zu klein ist, sind zu viele Trainingsiterationen erforderlich, um das Modell zu trainieren.  Zu viel - Genauigkeit sinkt.  Das Finden eines guten Wertes f√ºr den Lernratenkoeffizienten erfordert einige Versuche und Irrt√ºmer, der normalerweise im Bereich von <code>0.01</code> (standardm√§√üig) bis <code>0.1</code> . <br><br><h4>  Wir trainieren das Modell </h4><br>  Das Training des Modells erfolgt nach der <code>fit</code> Methode. <br><br>  W√§hrend des Trainings empf√§ngt das Modell am Eingang Grad Celsius, f√ºhrt Transformationen unter Verwendung der Werte interner Variablen (als ‚ÄûGewichte‚Äú bezeichnet) durch und gibt Werte zur√ºck, die Grad Fahrenheit entsprechen m√ºssen.  Da die Anfangswerte der Gewichte willk√ºrlich festgelegt werden, sind die resultierenden Werte weit von den korrekten Werten entfernt.  Die Differenz zwischen dem gew√ºnschten und dem tats√§chlichen Ergebnis wird mithilfe der Verlustfunktion berechnet, und die Optimierungsfunktion bestimmt, wie die Gewichte angepasst werden sollen. <br><br>  Dieser Zyklus von Berechnungen, Vergleichen und Anpassungen wird innerhalb der Anpassungsmethode gesteuert.  Das erste Argument ist der Eingabewert, das zweite Argument ist der gew√ºnschte Ausgabewert.  Das Argument der <code>epochs</code> bestimmt, wie oft dieser Trainingszyklus abgeschlossen werden soll.  Das <code>verbose</code> Argument steuert die Protokollierungsstufe. <br><br><pre> <code class="python hljs">history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)</code> </pre><br>  In den folgenden Videos werden wir uns mit den Details befassen, wie dies alles funktioniert und wie genau die vollst√§ndig verbundenen Schichten ( <code>Dense</code> Schichten) "unter der Haube" sind. <br><br><h4>  Trainingsstatistik anzeigen </h4><br>  Die <code>fit</code> gibt ein Objekt zur√ºck, das Informationen zu √Ñnderungen der Verluste bei jeder nachfolgenden Iteration enth√§lt.  Mit diesem Objekt k√∂nnen wir einen geeigneten Verlustplan erstellen.  Hoher Verlust bedeutet, dass die vom Modell vorhergesagten Fahrenheit-Grad weit von den wahren Werten im Array Fahrenheit_a entfernt sind. <br><br>  Zur Visualisierung verwenden wir <code>Matplotlib</code> .  Wie Sie sehen, verbessert sich unser Modell zu Beginn sehr schnell und verbessert sich dann stabil und langsam, bis die Ergebnisse am Ende des Trainings nahezu perfekt sind. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Epoch'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Loss'</span></span>) plt.plot(history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/5t/qg/ds/5tqgdsya8uiphpuehc5c2xxdrak.png"><br><br><h4>  Wir verwenden das Modell f√ºr Vorhersagen. </h4><br>  Jetzt haben wir ein Modell, das auf die Eingabewerte <code>celsius_q</code> und die Ausgabewerte <code>fahrenheit_a</code> , um die Beziehung zwischen ihnen zu bestimmen.  Wir k√∂nnen die Vorhersagemethode verwenden, um die Fahrenheit-Grad zu berechnen, um die wir zuvor die entsprechenden Grad Celsius nicht kannten. <br><br>  Wie viel sind zum Beispiel 100,0 Grad Celsius Fahrenheit?  Versuchen Sie zu erraten, bevor Sie den folgenden Code ausf√ºhren. <br><br><pre> <code class="python hljs">print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))</code> </pre><br>  Fazit: <br><br> <code>[[211.29639]] <br></code> <br><br>  Die richtige Antwort lautet 100 √ó 1,8 + 32 = 212, also hat unser Modell ziemlich gut abgeschnitten! <br><br>  <b>R√ºckblick</b> <br><br><ul><li>  Wir haben ein Modell mit der Ebene " <code>Dense</code> . </li><li>  Wir haben sie mit 3.500 Beispielen trainiert (7 Wertepaare, 500 Trainingsiterationen). </li></ul><br>  Unser Modell hat die Werte der internen Variablen (Gewichte) in der <code>Dense</code> Ebene so angepasst, dass die korrekten Werte von Fahrenheit Grad auf einen beliebigen Eingabewert von Grad Celsius zur√ºckgesetzt werden. <br><br><h3>  Wir schauen uns die Gewichte an </h3><br>  Lassen Sie uns die Werte der internen Variablen der <code>Dense</code> Ebene anzeigen. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>.format(l0.get_weights()))</code> </pre><br>  Fazit: <br><br><pre> <code class="plaintext hljs">   : [array([[1.8261501]], dtype=float32), array([28.681389], dtype=float32)]</code> </pre><br>  Der Wert der ersten Variablen liegt nahe bei ~ 1,8 und der zweite bei ~ 32.  Diese Werte (1,8 und 32) sind direkte Werte in der Formel zur Umrechnung von Grad Celsius in Grad Fahrenheit. <br><br>  Dies kommt den tats√§chlichen Werten in der Formel wirklich sehr nahe!  Wir werden diesen Punkt in den folgenden Videos genauer betrachten, in denen wir zeigen, wie die <code>Dense</code> Ebene funktioniert. Im <code>Dense</code> m√ºssen Sie jedoch nur wissen, dass ein Neuron mit einer einzelnen Eingabe und Ausgabe einfache Mathematik enth√§lt - <code>y = mx + b</code> (als Gleichung) direkt), was nichts anderes ist als unsere Formel zur Umrechnung von Grad Celsius in Grad Fahrenheit, <code>f = 1.8c + 32</code> . <br><br>  Da die Darstellungen gleich sind, sollten die Werte der internen Variablen des Modells zu denen konvergieren, die in der tats√§chlichen Formel dargestellt sind, was am Ende passiert ist. <br><br>  Mit dem Vorhandensein zus√§tzlicher Neuronen, zus√§tzlicher Eingabewerte und Ausgabewerte wird die Formel etwas komplizierter, aber die Essenz bleibt dieselbe. <br><br><h4>  Ein bisschen experimentieren </h4><br>  Zum Spa√ü!  Was passiert, wenn wir mehr <code>Dense</code> Schichten mit mehr Neuronen erstellen, die wiederum mehr interne Variablen enthalten? <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) l1 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>) l2 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([l0, l1, l2]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])) print(<span class="hljs-string"><span class="hljs-string">" ,  100    {}  "</span></span>.format(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))) print(<span class="hljs-string"><span class="hljs-string">"    l0: {}"</span></span>.format(l0.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l1: {}"</span></span>.format(l1.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l2: {}"</span></span>.format(l2.get_weights()))</code> </pre><br>  Fazit: <br><br><pre> <code class="plaintext hljs">   [[211.74748]]  ,  100    [[211.74748]]       l0: [array([[-0.5972079 , -0.05531882, -0.00833384, -0.10636603]], dtype=float32), array([-3.0981746, -1.8776944, 2.4708805, -2.9092448], dtype=float32)]     l1: [array([[ 0.09127654, 1.1659832 , -0.61909443, 0.3422218 ], [-0.7377194 , 0.20082018, -0.47870865, 0.30302727], [-0.1370897 , -0.0667181 , -0.39285263, -1.1399261 ], [-0.1576551 , 1.1161333 , -0.15552482, 0.39256814]], dtype=float32), array([-0.94946504, -2.9903848 , 2.9848468 , -2.9061244 ], dtype=float32)]     l2: [array([[-0.13567649], [-1.4634581 ], [ 0.68370366], [-1.2069695 ]], dtype=float32), array([2.9170544], dtype=float32)]</code> </pre><br>  Wie Sie vielleicht bemerkt haben, kann das aktuelle Modell auch die entsprechenden Grad Fahrenheit recht gut vorhersagen.  Wenn wir jedoch die Werte der internen Variablen (Gewichte) von Neuronen nach Schichten betrachten, werden wir keine Werte √§hnlich 1,8 und 32 sehen.  Die zus√§tzliche Komplexit√§t des Modells verbirgt die ‚Äûeinfache‚Äú Form der Umrechnung von Grad Celsius in Grad Fahrenheit. <br><br>  Bleiben Sie in Verbindung und im n√§chsten Teil werden wir uns ansehen, wie dichte Schichten ‚Äûunter der Haube‚Äú funktionieren. <br><br><h3>  Kurze Zusammenfassung </h3><br>  Gl√ºckwunsch!  Sie haben gerade Ihr erstes Modell trainiert.  In der Praxis haben wir gesehen, wie das Modell durch Eingabe- und Ausgabewerte gelernt hat, den Eingabewert mit 1,8 zu multiplizieren und 32 zu addieren, um das richtige Ergebnis zu erhalten. <br><br><img src="https://habrastorage.org/webt/g7/c9/ho/g7c9horz6n3sokt6htkcie4ydsq.jpeg"><br><br>  Das war wirklich beeindruckend, wenn man bedenkt, wie viele Codezeilen wir schreiben mussten: <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) model = tf.keras.Sequential([l0]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])</code> </pre><br>  Das obige Beispiel ist ein allgemeiner Plan f√ºr alle maschinellen Lernprogramme.  Sie werden √§hnliche Konstruktionen verwenden, um neuronale Netze zu erstellen und zu trainieren und nachfolgende Probleme zu l√∂sen. <br><br><h3>  Trainingsprozess </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Trainingsprozess (der in der Methode stattfindet </font></font><code>model.fit(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) besteht aus einer sehr einfachen Abfolge von Aktionen, deren Ergebnis die Werte interner Variablen sein sollten, um die Ergebnisse so nah wie m√∂glich am Original zu erhalten. </font><font style="vertical-align: inherit;">Der Optimierungsprozess, durch den solche Ergebnisse erzielt werden, der als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradientenabstieg bezeichnet wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verwendet eine numerische Analyse, um die am besten geeigneten Werte f√ºr die internen Variablen des Modells zu finden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um maschinelles Lernen zu betreiben, m√ºssen Sie diese Details grunds√§tzlich nicht verstehen. Aber f√ºr diejenigen, die noch mehr lernen m√∂chten: Der Gradientenabstieg durch Iterationen √§ndert die Parameterwerte ein wenig und ‚Äûzieht‚Äú sie in die richtige Richtung, bis die besten Ergebnisse erzielt werden. In diesem Fall bedeuten ‚Äûbeste Ergebnisse‚Äú (beste Werte), dass jede nachfolgende √Ñnderung des Parameters nur das Ergebnis des Modells verschlechtert. Eine Funktion, die misst, wie gut oder schlecht ein Modell bei jeder Iteration ist, wird als "Verlustfunktion" bezeichnet, und das Ziel jedes "Ziehens" (Anpassung interner Werte) besteht darin, den Wert der Verlustfunktion zu verringern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Trainingsprozess beginnt mit dem Block ‚ÄûDirektverteilung‚Äú, in dem die Eingabeparameter zum Eingang des neuronalen Netzwerks gehen, den verborgenen Neuronen folgen und dann zum Wochenende gehen. Das Modell wendet dann interne Transformationen auf die Eingabewerte und internen Variablen an, um die Antwort vorherzusagen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Beispiel ist der Eingabewert die Temperatur in Grad Celsius und das Modell hat den entsprechenden Wert in Grad Fahrenheit vorhergesagt. </font></font><br><br><img src="https://habrastorage.org/webt/vo/vs/sx/vovssxwlsojtbl89vts6llkqfgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald der Wert vorhergesagt ist, wird die Differenz zwischen dem vorhergesagten und dem richtigen Wert berechnet. Der Unterschied wird als ‚ÄûVerlust‚Äú bezeichnet und ist eine Form der Messung der Funktionsweise des Modells. Der Verlustwert wird durch die Verlustfunktion berechnet, die wir beim Aufruf der Methode durch eines der Argumente ermittelt haben </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Berechnung des Verlustwerts werden die internen Variablen (Gewichte und Verschiebungen) aller Schichten des neuronalen Netzwerks angepasst, um den Verlustwert zu minimieren und den Ausgabewert an den korrekten anf√§nglichen Referenzwert anzun√§hern. </font></font><br><br><img src="https://habrastorage.org/webt/wd/sf/qb/wdsfqbnpgcoudq5h7xtoik7omxa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Optimierungsprozess wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradientenabstieg bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ein spezifischer Optimierungsalgorithmus wird verwendet, um einen neuen Wert f√ºr jede interne Variable zu berechnen, wenn die Methode aufgerufen wird </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Im obigen Beispiel haben wir einen Optimierungsalgorithmus verwendet </font></font><code>Adam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verst√§ndnis der Prinzipien des Trainingsprozesses ist f√ºr diesen Kurs nicht erforderlich. Wenn Sie jedoch neugierig genug sind, finden Sie weitere Informationen zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Crash-Kurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Die √úbersetzung und der praktische Teil des gesamten Kurses sind in den Ver√∂ffentlichungspl√§nen des Autors festgelegt.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt sollten Sie bereits mit den folgenden Begriffen vertraut sein:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Eingabewert unseres Modells;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Eingabe + Ausgabe-Paare;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Modellausgabewerte;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schichten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : eine Sammlung von Knoten, die innerhalb eines neuronalen Netzwerks miteinander verbunden sind;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modell</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Darstellung Ihres neuronalen Netzwerks;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dicht und vollst√§ndig verbunden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Jeder Knoten in einer Schicht ist mit jedem Knoten aus der vorherigen Schicht verbunden.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewichte und Offsets</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Modellinterne Variablen;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verlust</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : die Differenz zwischen dem gew√ºnschten Ausgabewert und dem tats√§chlichen Ausgabewert des Modells;</font></font></li><li> <b>MSE</b> :  ,   ,        ,    . </li><li> <b> </b> : ,     -         ; </li><li> <b></b> :     ; </li><li> <b>  </b> :  ¬´¬ª       ; </li><li> <b></b> :      ; </li><li> <b></b> :       ; </li><li> <b> </b> :      ; </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckausbreitung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Berechnung der Werte interner Variablen gem√§√ü einem Optimierungsalgorithmus ausgehend von der Ausgabeschicht und in Richtung der Eingabeschicht durch alle Zwischenschichten.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ebenen sp√ºren </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir ein Modell erstellt, das Grad Celsius in Grad Fahrenheit umwandelt. Dabei wurde ein einfaches neuronales Netzwerk verwendet, um die Beziehung zwischen Grad Celsius und Grad Fahrenheit zu ermitteln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Netzwerk besteht aus einer einzigen vollst√§ndig verbundenen Schicht. </font><font style="vertical-align: inherit;">Aber was ist eine vollst√§ndig verbundene Schicht? </font><font style="vertical-align: inherit;">Um dies herauszufinden, erstellen wir ein komplexeres neuronales Netzwerk mit 3 Eingabeparametern, einer verborgenen Schicht mit zwei Neuronen und einer Ausgangsschicht mit einem einzelnen Neuron.</font></font><br><br><img src="https://habrastorage.org/webt/qo/_p/rk/qo_prk3p2aclbp8xdyzgk8trkme.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denken Sie daran, dass ein neuronales Netzwerk als eine Reihe von Schichten vorgestellt werden kann, von denen jede aus Knoten besteht, die als Neuronen bezeichnet werden. Neuronen auf jeder Ebene k√∂nnen mit den Neuronen jeder nachfolgenden Schicht verbunden werden. Die Art der Schichten, in denen jedes Neuron einer Schicht mit dem anderen Neuron der n√§chsten Schicht verbunden ist, wird als vollst√§ndig verbundene (vollst√§ndig verbundene) oder dichte Schicht ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-schicht) bezeichnet. </font></font><br><br><img src="https://habrastorage.org/webt/yk/dl/wb/ykdlwbtzt8rbjusmtndstttg_em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir also vollst√§ndig verbundene Schichten verwenden </font></font><code>keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, informieren wir Sie dar√ºber, dass die Neuronen dieser Schicht mit allen Neuronen der vorherigen Schicht verbunden sein sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das obige neuronale Netzwerk zu erstellen, reichen uns folgende Ausdr√ºcke:</font></font><br><br><pre> <code class="python hljs">hidden = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">3</span></span>]) output = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([hidden, output])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir herausgefunden, was Neuronen sind und wie sie zusammenh√§ngen. Aber wie funktionieren vollst√§ndig verbundene Schichten tats√§chlich? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu verstehen, was dort wirklich passiert und was sie tun, m√ºssen wir ‚Äûunter die Haube‚Äú schauen und die interne Mathematik der Neuronen auseinander nehmen. </font></font><br><br><img src="https://habrastorage.org/webt/io/xa/yf/ioxayfceecf7saxdaxnzw3hjyw4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor, unser Modell empf√§ngt drei Parameter - </font></font><code>1, 2, 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>1, 2  3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Neuronen unseres Netzwerks. Denken Sie daran, wir haben gesagt, dass ein Neuron interne Variablen hat? So, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von w *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind die internen Variablen Neuron, auch bekannt als das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewicht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdr√§ngung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es sind die Werte dieser Variablen, die im Lernprozess angepasst werden, um die genauesten Ergebnisse beim Vergleich der Eingabewerte mit der Ausgabe zu erhalten. </font></font><br><br><img src="https://habrastorage.org/webt/gz/ff/pf/gzffpftu7hqtdvesq6g9jmcjj10.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was Sie auf jeden Fall beachten sollten, ist, dass die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interne Mathematik des Neurons unver√§ndert bleibt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mit anderen Worten, w√§hrend des Trainingsprozesses √§ndern sich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gewichte und Verschiebungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie anfangen, maschinelles Lernen zu lernen, mag es seltsam erscheinen - die Tatsache, dass es wirklich funktioniert, aber so funktioniert maschinelles Lernen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir zu unserem Beispiel f√ºr die Umrechnung von Grad Celsius in Grad Fahrenheit zur√ºck.</font></font><br><br><img src="https://habrastorage.org/webt/qv/vf/hz/qvvfhzkmdgzktu-yi8i64_cqo4q.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit einem einzelnen Neuron haben wir nur ein Gewicht und eine Verschiebung. Wei√üt du was? Genau so sieht die Formel zur Umrechnung von Grad Celsius in Grad Fahrenheit aus. Wenn wir den </font></font><code>w11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">ersetzen </font></font><code>1.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und statt </font></font><code>b1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- erhalten </font></font><code>32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir das endg√ºltige Transformationsmodell! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir aus dem praktischen Teil auf die Ergebnisse unseres Modells zur√ºckkommen, werden wir darauf achten, dass die Indikatoren f√ºr Gewicht und Verschiebung so ‚Äûkalibriert‚Äú wurden, dass sie ungef√§hr den Werten aus der Formel entsprechen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben absichtlich ein solches praktisches Beispiel erstellt, um den genauen Vergleich zwischen Gewichten und Offsets klar darzustellen. Wenn wir maschinelles Lernen in die Praxis umsetzen, k√∂nnen wir die Werte von Variablen niemals auf diese Weise mit dem Zielalgorithmus vergleichen, wie im obigen Beispiel. Wie k√∂nnen wir das machen? Auf keinen Fall, da wir den Zielalgorithmus nicht einmal kennen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Probleme des maschinellen Lernens zu l√∂sen, testen wir verschiedene Architekturen neuronaler Netze mit unterschiedlicher Anzahl von Neuronen. Durch Versuch und Irrtum finden wir die genauesten Architekturen und Modelle und hoffen, dass sie das Problem im Lernprozess l√∂sen. Im n√§chsten praktischen Teil k√∂nnen wir spezifische Beispiele f√ºr diesen Ansatz untersuchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bleiben Sie in Kontakt, denn jetzt beginnt der Spa√ü!</font></font><br><br><h3>  Zusammenfassung </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Lektion lernten wir grundlegende Ans√§tze des maschinellen Lernens und lernten, wie vollst√§ndig verbundene Ebenen ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ebenen) funktionieren. </font><font style="vertical-align: inherit;">Sie haben Ihr erstes Modell darauf trainiert, Grad Celsius in Grad Fahrenheit umzurechnen. </font><font style="vertical-align: inherit;">Sie haben auch die grundlegenden Begriffe des maschinellen Lernens gelernt, z. B. Eigenschaften, Beispiele und Beschriftungen. </font><font style="vertical-align: inherit;">Sie haben unter anderem die wichtigsten Codezeilen in Python geschrieben, die das R√ºckgrat jedes Algorithmus f√ºr maschinelles Lernen bilden. </font><font style="vertical-align: inherit;">Sie haben gesehen, dass Sie in wenigen Codezeilen mithilfe von </font></font><code>TensorFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">eine Vorhersage von einem neuronalen Netzwerk erstellen, trainieren und anfordern k√∂nnen </font></font><code>Keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  ... und Standard-Handlungsaufforderung - anmelden, ein Plus setzen und teilen :) <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videoversion des Artikels</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXoH4UQovBs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://youtube.com/channel/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Telegramm: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://t.me/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VK: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vk.com/ashmig</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453558/">https://habr.com/ru/post/de453558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453542/index.html">Der vierbeinige Roboter konnte ein 3,3 Tonnen schweres Flugzeug ziehen</a></li>
<li><a href="../de453544/index.html">Sieben-Segment-Decoder, der sowohl direkte als auch inverse Ausg√§nge eines BCD-Z√§hlers verwendet</a></li>
<li><a href="../de453546/index.html">Ben√∂tigen Sie eine kleine Tastatur - machen Sie es selbst</a></li>
<li><a href="../de453548/index.html">Wir beleben das bremsende Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../de453554/index.html">Wie sich Starlink von SpaceX ge√§ndert hat</a></li>
<li><a href="../de453562/index.html">Digitale Veranstaltungen in Moskau vom 27. Mai bis 2. Juni</a></li>
<li><a href="../de453564/index.html">Machen Sie es wahr - Entwickeln Sie ein Logikspiel f√ºr Unity</a></li>
<li><a href="../de453566/index.html">Stellen Sie die Legende wieder her: ein Aufruf zum Austausch offener Daten, die bei der Wiederherstellung von Notre Dame helfen k√∂nnen</a></li>
<li><a href="../de453568/index.html">Neuerstellung eines Symbols: Aufruf zur Freigabe offener Daten zur Wiederherstellung von Notre-Dame</a></li>
<li><a href="../de453570/index.html">Microsoft Edge f√ºr MacOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>