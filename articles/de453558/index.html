<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♋️ 👨🏾‍💻 🐾 Einführung in das maschinelle Lernen 🙈 😄 ♊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Den vollständigen Kurs in Russisch finden Sie unter diesem Link . 
 Der ursprüngliche Englischkurs ist unter diesem Link verfügbar. 



 Alle 2-3 Tage...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in das maschinelle Lernen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453558/">  Den vollständigen Kurs in Russisch finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link</a> . <br>  Der ursprüngliche Englischkurs ist unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Link</a> verfügbar. <br><br><img src="https://habrastorage.org/webt/f-/6y/ml/f-6ymlhmfceofcmhbv2qsfv2hfu.jpeg"><br><a name="habracut"></a><br>  <i>Alle 2-3 Tage sind neue Vorträge geplant.</i> <br><br><h2>  Interview mit Sebastian Trun, CEO Udacity </h2><br>  "Hallo nochmal, ich bin Paige und du bist heute mein Gast, Sebastian." <br>  - Hallo, ich bin Sebastian! <br>  - ... ein Mann, der eine unglaubliche Karriere hat, der es geschafft hat, viele erstaunliche Dinge zu tun!  Sie sind Mitbegründer von Udacity, haben Google X gegründet und sind Professor an der Stanford University.  Sie haben während Ihrer gesamten Karriere unglaubliche Forschung betrieben und tiefgreifend gelernt.  Was hat Sie am meisten befriedigt und in welchem ​​Bereich haben Sie die meisten Belohnungen für die geleistete Arbeit erhalten? <br>  - Ehrlich gesagt, ich liebe es wirklich, im Silicon Valley zu sein!  Ich mag es, in der Nähe von Menschen zu sein, die viel schlauer sind als ich, und ich habe Technologie immer als ein Werkzeug angesehen, das die Spielregeln auf verschiedene Weise ändert - von Bildung über Logistik bis hin zu Gesundheitswesen usw.  All dies ändert sich so schnell und es besteht ein unglaublicher Wunsch, an diesen Veränderungen teilzunehmen und sie zu beobachten.  Sie schauen auf Ihre Umgebung und verstehen, dass das meiste, was Sie um sich herum sehen, nicht so funktioniert, wie es sollte - Sie können immer etwas Neues erfinden! <br>  - Nun, das ist eine sehr optimistische Sicht der Technologie!  Was war die größte Eureka während Ihrer Karriere? <br>  - Herr, es gab so viele!  Ich erinnere mich an einen Tag, an dem Larry Page mich anrief und vorschlug, Autopilot-Autos zu bauen, die durch alle Straßen Kaliforniens fahren könnten.  Zu dieser Zeit galt ich als Experte, ich wurde zu diesen gezählt und ich war genau die Person, die sagte: "Nein, das geht nicht."  Danach hat Larry mich überzeugt, dass es im Prinzip möglich ist, dies zu tun, man muss nur anfangen und es versuchen.  Und wir haben es geschafft!  Dies war der Moment, in dem mir klar wurde, dass selbst Experten falsch liegen und „Nein“ sagen, wir sind 100% pessimistisch.  Ich denke, wir sollten offener für das Neue sein. <br>  - Oder wenn Larry Page Sie anruft und sagt: "Hey, mach eine coole Sache wie Google X" und du bekommst etwas ziemlich Cooles! <br>  - Ja, das ist sicher, Sie müssen sich nicht beschweren!  Ich meine, all dies ist ein Prozess, der auf dem Weg zur Implementierung viel diskutiert wird.  Ich habe großes Glück zu arbeiten und bin stolz darauf, bei Google X und bei anderen Projekten. <br>  - Super!  In diesem Kurs geht es also nur um die Arbeit mit TensorFlow.  Haben Sie Erfahrung mit TensorFlow oder sind Sie damit vertraut (gehört)? <br>  - Ja!  Ich liebe TensorFlow buchstäblich!  In meinem eigenen Labor verwenden wir es oft und häufig. Eines der bedeutendsten Werke, das auf TensorFlow basiert, wurde vor etwa zwei Jahren veröffentlicht.  Wir haben gelernt, dass iPhone und Android Hautkrebs wirksamer erkennen können als die besten Dermatologen der Welt.  Wir haben unsere Forschungen in Nature veröffentlicht und dies hat zu einer Art Aufregung in der Medizin geführt. <br>  - Das klingt großartig!  Sie kennen und lieben TensorFlow, das an sich großartig ist!  Haben Sie bereits mit TensorFlow 2.0 gearbeitet? <br>  - Nein, leider hatte ich noch keine Zeit. <br>  - Er wird einfach unglaublich sein!  Alle Teilnehmer dieses Kurses arbeiten mit dieser Version. <br>  - Ich beneide sie!  Ich werde es auf jeden Fall versuchen! <br>  - Großartig!  In unserem Kurs gibt es viele Studenten, die sich in ihrem Leben noch nie mit maschinellem Lernen beschäftigt haben, vom Wort "vollständig".  Für sie kann das Feld neu sein, vielleicht ist es für jemanden, der selbst programmiert, neu.  Welchen Rat hast du für sie? <br>  - Ich möchte, dass sie offen bleiben - für neue Ideen, Techniken, Lösungen, Positionen.  Maschinelles Lernen ist eigentlich einfacher als Programmieren.  Bei der Programmierung müssen Sie jeden Fall in den Quelldaten berücksichtigen, die Programmlogik und die Regeln dafür anpassen.  Zu diesem Zeitpunkt trainieren Sie den Computer mithilfe von TensorFlow und maschinellem Lernen im Wesentlichen anhand von Beispielen, sodass der Computer die Regeln selbst finden kann. <br>  - Das ist unglaublich interessant!  Ich kann es kaum erwarten, den Studenten in diesem Kurs etwas mehr über maschinelles Lernen zu erzählen!  Sebastian, danke, dass du dir die Zeit genommen hast, heute zu uns zu kommen! <br>  - Danke!  Bleib in Kontakt! <br><br><h2>  Was ist maschinelles Lernen? </h2><br>  Beginnen wir also mit der folgenden Aufgabe - gegebenen Eingabe- und Ausgabewerten. <br><br><img src="https://habrastorage.org/webt/a2/ec/84/a2ec84ej7mnna9degt489lkhgxs.jpeg"><br><br>  Wenn Sie den Wert 0 als Eingabewert haben, dann 32 als Ausgabewert. Wenn Sie 8 als Eingabewert haben, dann 46,4 als Ausgabewert.  Wenn Sie 15 als Eingabewert haben, dann 59 als Ausgabewert und so weiter. <br><br>  Schauen Sie sich diese Werte genauer an und lassen Sie mich eine Frage stellen.  Können Sie bestimmen, wie die Ausgabe aussehen wird, wenn wir am Eingang 38 erhalten? <br><br><img src="https://habrastorage.org/webt/p6/dj/5o/p6dj5o7yrrekj2vxzexnq6hqpi0.jpeg"><br><br>  Wenn Sie mit 100.4 geantwortet haben, hatten Sie Recht! <br><br><img src="https://habrastorage.org/webt/bv/z9/-k/bvz9-kkmmvjurwja9ltuupq-lje.jpeg"><br><br>  Wie können wir dieses Problem lösen?  Wenn Sie sich die Werte genau ansehen, können Sie sehen, dass sie durch den Ausdruck zusammenhängen: <br><br><img src="https://habrastorage.org/webt/bm/ql/pq/bmqlpqb79ptaf8q_gsikh9wg3pg.jpeg"><br><br>  Wobei C - Grad Celsius (Eingabewerte), F - Fahrenheit (Ausgabewerte). <br><br>  Was Ihr Gehirn gerade getan hat - Eingabewerte und Ausgabewerte verglichen und ein gemeinsames Modell (Verbindung, Abhängigkeit) zwischen ihnen gefunden - ist das, was maschinelles Lernen tut. <br><br>  Basierend auf den Eingabe- und Ausgabewerten finden Algorithmen für maschinelles Lernen einen geeigneten Algorithmus zum Konvertieren von Eingabewerten in Ausgabewerte.  Dies kann wie folgt dargestellt werden: <br><br><img src="https://habrastorage.org/webt/_m/c8/zq/_mc8zq1ochmxaq78aqd39ktngqm.jpeg"><br><br>  Schauen wir uns ein Beispiel an.  Stellen Sie sich vor, wir möchten ein Programm entwickeln, das Grad Celsius in Grad Fahrenheit mit der Formel <code>F = C * 1.8 + 32</code> umwandelt. <br><br><img src="https://habrastorage.org/webt/me/0w/t6/me0wt6lyjkzoqbgdwb3-tvtv2s0.jpeg"><br><br>  Die Lösung kann aus Sicht der traditionellen Softwareentwicklung in jeder Programmiersprache mit der folgenden Funktion implementiert werden: <br><br><img src="https://habrastorage.org/webt/e3/oi/zk/e3oizkl4oob_fnd2yq-i1fxifwk.jpeg"><br><br>  Was haben wir also?  Die Funktion nimmt einen Eingabewert von C an, berechnet dann den Ausgabewert von F unter Verwendung eines expliziten Algorithmus und gibt dann den berechneten Wert zurück. <br><br><img src="https://habrastorage.org/webt/d7/vn/yh/d7vnyhgewv7pknnv0bmepxybtg8.jpeg"><br><br>  Andererseits haben wir beim Ansatz des maschinellen Lernens nur Eingabe- und Ausgabewerte, nicht aber den Algorithmus selbst: <br><br><img src="https://habrastorage.org/webt/m1/3s/wy/m13swy6p2a4z_wuboqdawda7m-8.jpeg"><br><br>  Der Ansatz des maschinellen Lernens beruht auf der Verwendung neuronaler Netze, um die Beziehung zwischen Eingabe- und Ausgabewerten zu finden. <br><br><img src="https://habrastorage.org/webt/sd/_u/cb/sd_ucbyegwsntvcufqhgzqgqefs.jpeg"><br><br>  Sie können sich neuronale Netze als einen Stapel von Schichten vorstellen, von denen jede aus zuvor bekannten mathematischen (Formeln) und internen Variablen besteht.  Der Eingabewert tritt in das neuronale Netzwerk ein und durchläuft einen Stapel von Schichten von Neuronen.  Beim Durchlaufen der Ebenen wird der Eingabewert gemäß der Mathematik (vorgegebene Formeln) und den Werten der internen Variablen der Ebenen konvertiert, wodurch ein Ausgabewert erzeugt wird. <br><br>  Damit das neuronale Netzwerk die richtige Beziehung zwischen den Eingabe- und Ausgabewerten lernen und bestimmen kann, müssen wir es trainieren - trainieren. <br><br>  Wir trainieren das neuronale Netzwerk durch wiederholte Versuche, Eingabewerte mit Ausgabewerten abzugleichen. <br><br><img src="https://habrastorage.org/webt/a7/8r/k5/a78rk54x-g6lpgjm67cvmuas43c.jpeg"><br><br>  Während des Trainings erfolgt die „Anpassung“ (Auswahl) der Werte interner Variablen in den Schichten des neuronalen Netzwerks, bis das Netzwerk lernt, die entsprechenden Ausgabewerte zu den entsprechenden Eingabewerten zu generieren. <br><br>  Wie wir später sehen werden, werden Tausende oder Zehntausende von Iterationen (Trainings) durchgeführt, um ein neuronales Netzwerk zu trainieren und es in die Lage zu versetzen, die am besten geeigneten Werte für interne Variablen auszuwählen. <br><br><img src="https://habrastorage.org/webt/kv/h5/xa/kvh5xahns3dammp0e1-guhsjwmg.jpeg"><br><br>  Als vereinfachte Version des Verständnisses des maschinellen Lernens können Sie sich Algorithmen für maschinelles Lernen als Funktionen vorstellen, die die Werte interner Variablen so auswählen, dass die richtigen Eingabewerte den korrekten Ausgabewerten entsprechen. <br><br>  Es gibt viele Arten von neuronalen Netzwerkarchitekturen.  Unabhängig davon, für welche Architektur Sie sich entscheiden, bleibt die Mathematik im Inneren (welche Berechnungen werden in welcher Reihenfolge durchgeführt) während des Trainings unverändert.  Anstatt die Mathematik zu ändern, ändern sich die internen Variablen (Gewichte und Offsets) während des Trainings. <br><br>  Bei der Umrechnung von Grad Celsius in Fahrenheit beginnt das Modell beispielsweise damit, den Eingabewert mit einer bestimmten Zahl (Gewicht) zu multiplizieren und einen weiteren Wert (Offset) hinzuzufügen.  Das Modelltraining besteht darin, geeignete Werte für diese Variablen zu finden, ohne die durchgeführten Multiplikations- und Additionsoperationen zu ändern. <br><br>  Aber eine coole Sache zum Nachdenken!  Wenn Sie das Problem der Umrechnung von Grad Celsius in Fahrenheit gelöst haben, das im Video und im folgenden Text angegeben ist, haben Sie es wahrscheinlich gelöst, weil Sie bereits Erfahrung oder Kenntnisse darüber hatten, wie diese Art der Umrechnung von Grad Celsius in Fahrenheit durchgeführt wird.  Zum Beispiel wissen Sie vielleicht nur, dass 0 Grad Celsius 32 Grad Fahrenheit entsprechen.  Auf der anderen Seite verfügen Systeme, die auf maschinellem Lernen basieren, nicht über unterstützende Vorkenntnisse, um das Problem zu lösen.  Sie lernen, solche Probleme nicht auf der Grundlage von Vorkenntnissen und in ihrer völligen Abwesenheit zu lösen. <br><br>  Genug geredet - fahren Sie mit dem praktischen Teil der Vorlesung fort! <br><br><h2>  CoLab: Konvertieren Sie Grad Celsius in Grad Fahrenheit </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die russische Version des CoLab-Quellcodes</a> und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">englische Version des CoLab-Quellcodes</a> . <br><br><h2>  Die Grundlagen: das erste Modell lernen </h2><br>  Willkommen bei CoLab, wo wir unser erstes Modell für maschinelles Lernen trainieren werden! <br><br>  Wir werden versuchen, die Einfachheit des vorgestellten Materials beizubehalten und nur die für die Arbeit erforderlichen Grundkonzepte einzuführen.  Nachfolgende CoLabs enthalten fortgeschrittenere Techniken. <br><br>  Die Aufgabe, die wir lösen werden, ist die Umrechnung von Grad Celsius in Grad Fahrenheit.  Die Umrechnungsformel lautet wie folgt: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&amp;#xA0;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.452ex" height="2.419ex" viewBox="0 -780.1 7944.7 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-3D" x="828" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-63" x="1884" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-6D" x="2568" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-61" x="3446" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMATHI-6C" x="3976" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-31" x="4274" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-2C" x="4775" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-38" x="5220" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-2B" x="5942" y="0"></use><g transform="translate(6943,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/453558/&amp;usg=ALkJrhhXj1IOYKy1WvEt-1-2EjpOWkLyBQ#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>f</mi><mo>=</mo><mi>c</mi><mtext>&nbsp;</mtext><mi>m</mi><mi>a</mi><mi>l</mi><mn>1</mn><mo>,</mo><mn>8</mn><mo>+</mo><mn>32</mn></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> f = c \ mal 1,8 + 32 </script></p><br><br>  Natürlich wäre es einfacher, einfach eine Konvertierungsfunktion in Python oder einer anderen Programmiersprache zu schreiben, die direkte Berechnungen durchführen würde, aber in diesem Fall wäre es kein maschinelles Lernen :) <br><br>  Stattdessen geben wir in die TensorFlow-Eingabe die Eingabegrade von Celsius (0, 8, 15, 22, 38) und die entsprechenden Fahrenheit-Grade (32, 46, 59, 72, 100) ein.  Dann werden wir das Modell so trainieren, dass es ungefähr der obigen Formel entspricht. <br><br><h3>  Abhängigkeiten importieren </h3><br>  Das erste, was wir importieren, ist <code>TensorFlow</code> .  Hier und im Folgenden nennen wir es kurz <code>tf</code> .  Wir konfigurieren auch die Protokollierungsstufe - nur Fehler. <br><br>  Als nächstes importieren Sie <code>NumPy</code> als <code>np</code> .  <code>Numpy</code> hilft uns, unsere Daten als Hochleistungslisten <code>Numpy</code> . <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> absolute_import, division, print_function, unicode_literals <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tf tf.logging.set_verbosity(tf.logging.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np</code> </pre><br><h3>  Vorbereitung der Trainingsdaten </h3><br>  Wie wir bereits gesehen haben, basiert die maschinelle Lerntechnik mit dem Lehrer auf der Suche nach einem Algorithmus zum Konvertieren von Eingabedaten in Ausgaben.  Da die Aufgabe dieses CoLab darin besteht, ein Modell zu erstellen, das das Ergebnis der Umrechnung von Grad Celsius in Grad Fahrenheit erzeugen kann, erstellen wir zwei Listen - <code>celsius_q</code> und <code>fahrenheit_a</code> , die wir beim Training unseres Modells verwenden. <br><br><pre> <code class="python hljs">celsius_q = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">-10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>], dtype=float) fahrenheit_a = np.array([<span class="hljs-number"><span class="hljs-number">-40</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">59</span></span>, <span class="hljs-number"><span class="hljs-number">72</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>], dtype=float) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i,c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(celsius_q): print(<span class="hljs-string"><span class="hljs-string">"{}   = {}  "</span></span>.format(c, fahrenheit_a[i]))</code> </pre><br> <code>-40.0   = -40.0   <br> -10.0   = 14.0   <br> 0.0   = 32.0   <br> 8.0   = 46.0   <br> 15.0   = 59.0   <br> 22.0   = 72.0   <br> 38.0   = 100.0   <br></code> <br>  Einige Terminologie für maschinelles Lernen: <br><br><ul><li>  <b>Eigenschaft</b> ist der Eingabewert (die Eingabewerte) unseres Modells.  In diesem Fall beträgt der Einheitswert Grad Celsius. </li><li>  <b>Beschriftungen</b> sind die Ausgabewerte, die unser Modell vorhersagt.  In diesem Fall beträgt der Einheitswert Grad Fahrenheit. </li><li>  <b>Ein Beispiel</b> ist ein Paar von Eingabe-Ausgabe-Werten, die für das Training verwendet werden.  In diesem Fall ist dies ein Wertepaar aus <code>celsius_q</code> und <code>fahrenheit_a</code> unter einem bestimmten Index, z. B. (22,72). </li></ul><br><h2>  Erstellen Sie ein Modell </h2><br>  Als nächstes erstellen wir ein Modell.  Wir werden das einfachste Modell verwenden - das Modell eines vollständig verbundenen Netzwerks ( <code>Dense</code> Netzwerk).  Da die Aufgabe ziemlich trivial ist, besteht das Netzwerk auch aus einer einzelnen Schicht mit einem einzelnen Neuron. <br><br><h4>  Aufbau eines Netzwerks </h4><br>  Wir werden die Ebene <code>l0</code> ( <b>l</b> ayer und zero) <code>tf.keras.layers.Dense</code> und sie erstellen, indem <code>tf.keras.layers.Dense</code> mit den folgenden Parametern initialisieren: <br><br><ul><li>  <code>input_shape=[1]</code> - Dieser Parameter bestimmt die Dimension des Eingabeparameters - ein einzelner Wert.  1 × 1 Matrix mit einem einzelnen Wert.  Da dies die erste (und einzige) Schicht ist, entspricht die Dimension der Eingabedaten der Dimension des gesamten Modells.  Der einzige Wert ist ein Gleitkommawert, der Grad Celsius darstellt. </li><li>  <code>units=1</code> - Dieser Parameter bestimmt die Anzahl der Neuronen in der Schicht.  Die Anzahl der Neuronen bestimmt, wie viele interne Schichtvariablen für das Training verwendet werden, um eine Lösung für das Problem zu finden.  Da dies die letzte Ebene ist, entspricht ihre Dimension der Dimension des Ergebnisses - dem Ausgabewert des Modells - einer einzelnen Gleitkommazahl, die Grad Fahrenheit darstellt.  (In einem mehrschichtigen Netzwerk müssen Größe und Form der <code>input_shape</code> mit der Größe und Form der nächsten Ebene übereinstimmen.) </li></ul><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br><h4>  Ebenen in Modell konvertieren </h4><br>  Sobald Ebenen definiert sind, müssen sie in ein Modell konvertiert werden.  <code>Sequential</code> Modell verwendet als Argumente die Liste der Ebenen in der Reihenfolge, in der sie angewendet werden müssen - vom Eingabewert bis zum Ausgabewert. <br><br>  Unser Modell hat nur eine Schicht - <code>l0</code> . <br><br><pre> <code class="python hljs">model = tf.keras.Sequential([l0])</code> </pre><br>  <b>Hinweis</b> <br>  Sehr oft werden Sie auf die Definition von Ebenen direkt in der Modellfunktion stoßen und nicht auf deren vorläufige Beschreibung und anschließende Verwendung: <br><pre> <code class="python hljs">model = tf.keras.Sequential([ tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) ])</code> </pre><br><h3>  Wir kompilieren ein Modell mit einer Verlust- und Optimierungsfunktion </h3><br>  Vor dem Training muss das Modell zusammengestellt (zusammengebaut) werden.  Wenn Sie für das Training kompilieren, benötigen Sie: <br><br><ul><li>  <b>Verlustfunktion</b> - eine Methode zum Messen, wie weit der vorhergesagte Wert vom gewünschten Ausgabewert entfernt ist (eine messbare Differenz wird als „Verlust“ bezeichnet). </li><li>  <b>Optimierungsfunktion</b> - eine Möglichkeit, interne Variablen anzupassen, um Verluste zu reduzieren. </li></ul><br><br><pre> <code class="python hljs">model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>))</code> </pre><br>  Die Verlustfunktion und die Optimierungsfunktion werden während des Modelltrainings ( <code>model.fit(...)</code> unten erwähnt) verwendet, um an jedem Punkt erste Berechnungen durchzuführen und dann die Werte zu optimieren. <br><br>  Die Berechnung der aktuellen Verluste und die anschließende Verbesserung dieser Werte im Modell ist genau das, was Training ist (eine Iteration). <br><br>  Während des Trainings werden mit der Optimierungsfunktion Anpassungen der Werte interner Variablen berechnet.  Ziel ist es, die Werte interner Variablen im Modell so anzupassen (und dies ist in der Tat eine mathematische Funktion), dass sie den vorhandenen Ausdruck für die Umrechnung von Grad Celsius in Grad Fahrenheit so genau wie möglich widerspiegeln. <br><br>  TensorFlow verwendet numerische Analysen, um diese Art von Optimierungsvorgängen durchzuführen, und all diese Komplexität ist unseren Augen verborgen, sodass wir in diesem Kurs nicht auf Details eingehen werden. <br><br>  Was ist nützlich, um über diese Optionen zu wissen: <br><br>  Die in diesem Beispiel verwendete Verlustfunktion (Standardfehler) und Optimierungsfunktion (Adam) sind Standard für solche einfachen Modelle, aber viele andere sind neben ihnen verfügbar.  Derzeit ist es uns egal, wie diese Funktionen funktionieren. <br><br>  Was Sie beachten sollten, ist die Optimierungsfunktion und der Parameter ist der <code>learning rate</code> , der in unserem Beispiel <code>0.1</code> beträgt.  Dies ist die verwendete Schrittgröße beim Anpassen der internen Werte von Variablen.  Wenn der Wert zu klein ist, sind zu viele Trainingsiterationen erforderlich, um das Modell zu trainieren.  Zu viel - Genauigkeit sinkt.  Das Finden eines guten Wertes für den Lernratenkoeffizienten erfordert einige Versuche und Irrtümer, der normalerweise im Bereich von <code>0.01</code> (standardmäßig) bis <code>0.1</code> . <br><br><h4>  Wir trainieren das Modell </h4><br>  Das Training des Modells erfolgt nach der <code>fit</code> Methode. <br><br>  Während des Trainings empfängt das Modell am Eingang Grad Celsius, führt Transformationen unter Verwendung der Werte interner Variablen (als „Gewichte“ bezeichnet) durch und gibt Werte zurück, die Grad Fahrenheit entsprechen müssen.  Da die Anfangswerte der Gewichte willkürlich festgelegt werden, sind die resultierenden Werte weit von den korrekten Werten entfernt.  Die Differenz zwischen dem gewünschten und dem tatsächlichen Ergebnis wird mithilfe der Verlustfunktion berechnet, und die Optimierungsfunktion bestimmt, wie die Gewichte angepasst werden sollen. <br><br>  Dieser Zyklus von Berechnungen, Vergleichen und Anpassungen wird innerhalb der Anpassungsmethode gesteuert.  Das erste Argument ist der Eingabewert, das zweite Argument ist der gewünschte Ausgabewert.  Das Argument der <code>epochs</code> bestimmt, wie oft dieser Trainingszyklus abgeschlossen werden soll.  Das <code>verbose</code> Argument steuert die Protokollierungsstufe. <br><br><pre> <code class="python hljs">history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>)</code> </pre><br>  In den folgenden Videos werden wir uns mit den Details befassen, wie dies alles funktioniert und wie genau die vollständig verbundenen Schichten ( <code>Dense</code> Schichten) "unter der Haube" sind. <br><br><h4>  Trainingsstatistik anzeigen </h4><br>  Die <code>fit</code> gibt ein Objekt zurück, das Informationen zu Änderungen der Verluste bei jeder nachfolgenden Iteration enthält.  Mit diesem Objekt können wir einen geeigneten Verlustplan erstellen.  Hoher Verlust bedeutet, dass die vom Modell vorhergesagten Fahrenheit-Grad weit von den wahren Werten im Array Fahrenheit_a entfernt sind. <br><br>  Zur Visualisierung verwenden wir <code>Matplotlib</code> .  Wie Sie sehen, verbessert sich unser Modell zu Beginn sehr schnell und verbessert sich dann stabil und langsam, bis die Ergebnisse am Ende des Trainings nahezu perfekt sind. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt plt.xlabel(<span class="hljs-string"><span class="hljs-string">'Epoch'</span></span>) plt.ylabel(<span class="hljs-string"><span class="hljs-string">'Loss'</span></span>) plt.plot(history.history[<span class="hljs-string"><span class="hljs-string">'loss'</span></span>])</code> </pre><br><img src="https://habrastorage.org/webt/5t/qg/ds/5tqgdsya8uiphpuehc5c2xxdrak.png"><br><br><h4>  Wir verwenden das Modell für Vorhersagen. </h4><br>  Jetzt haben wir ein Modell, das auf die Eingabewerte <code>celsius_q</code> und die Ausgabewerte <code>fahrenheit_a</code> , um die Beziehung zwischen ihnen zu bestimmen.  Wir können die Vorhersagemethode verwenden, um die Fahrenheit-Grad zu berechnen, um die wir zuvor die entsprechenden Grad Celsius nicht kannten. <br><br>  Wie viel sind zum Beispiel 100,0 Grad Celsius Fahrenheit?  Versuchen Sie zu erraten, bevor Sie den folgenden Code ausführen. <br><br><pre> <code class="python hljs">print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))</code> </pre><br>  Fazit: <br><br> <code>[[211.29639]] <br></code> <br><br>  Die richtige Antwort lautet 100 × 1,8 + 32 = 212, also hat unser Modell ziemlich gut abgeschnitten! <br><br>  <b>Rückblick</b> <br><br><ul><li>  Wir haben ein Modell mit der Ebene " <code>Dense</code> . </li><li>  Wir haben sie mit 3.500 Beispielen trainiert (7 Wertepaare, 500 Trainingsiterationen). </li></ul><br>  Unser Modell hat die Werte der internen Variablen (Gewichte) in der <code>Dense</code> Ebene so angepasst, dass die korrekten Werte von Fahrenheit Grad auf einen beliebigen Eingabewert von Grad Celsius zurückgesetzt werden. <br><br><h3>  Wir schauen uns die Gewichte an </h3><br>  Lassen Sie uns die Werte der internen Variablen der <code>Dense</code> Ebene anzeigen. <br><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"   : {}"</span></span>.format(l0.get_weights()))</code> </pre><br>  Fazit: <br><br><pre> <code class="plaintext hljs">   : [array([[1.8261501]], dtype=float32), array([28.681389], dtype=float32)]</code> </pre><br>  Der Wert der ersten Variablen liegt nahe bei ~ 1,8 und der zweite bei ~ 32.  Diese Werte (1,8 und 32) sind direkte Werte in der Formel zur Umrechnung von Grad Celsius in Grad Fahrenheit. <br><br>  Dies kommt den tatsächlichen Werten in der Formel wirklich sehr nahe!  Wir werden diesen Punkt in den folgenden Videos genauer betrachten, in denen wir zeigen, wie die <code>Dense</code> Ebene funktioniert. Im <code>Dense</code> müssen Sie jedoch nur wissen, dass ein Neuron mit einer einzelnen Eingabe und Ausgabe einfache Mathematik enthält - <code>y = mx + b</code> (als Gleichung) direkt), was nichts anderes ist als unsere Formel zur Umrechnung von Grad Celsius in Grad Fahrenheit, <code>f = 1.8c + 32</code> . <br><br>  Da die Darstellungen gleich sind, sollten die Werte der internen Variablen des Modells zu denen konvergieren, die in der tatsächlichen Formel dargestellt sind, was am Ende passiert ist. <br><br>  Mit dem Vorhandensein zusätzlicher Neuronen, zusätzlicher Eingabewerte und Ausgabewerte wird die Formel etwas komplizierter, aber die Essenz bleibt dieselbe. <br><br><h4>  Ein bisschen experimentieren </h4><br>  Zum Spaß!  Was passiert, wenn wir mehr <code>Dense</code> Schichten mit mehr Neuronen erstellen, die wiederum mehr interne Variablen enthalten? <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) l1 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">4</span></span>) l2 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([l0, l1, l2]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) print(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) print(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])) print(<span class="hljs-string"><span class="hljs-string">" ,  100    {}  "</span></span>.format(model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>]))) print(<span class="hljs-string"><span class="hljs-string">"    l0: {}"</span></span>.format(l0.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l1: {}"</span></span>.format(l1.get_weights())) print(<span class="hljs-string"><span class="hljs-string">"    l2: {}"</span></span>.format(l2.get_weights()))</code> </pre><br>  Fazit: <br><br><pre> <code class="plaintext hljs">   [[211.74748]]  ,  100    [[211.74748]]       l0: [array([[-0.5972079 , -0.05531882, -0.00833384, -0.10636603]], dtype=float32), array([-3.0981746, -1.8776944, 2.4708805, -2.9092448], dtype=float32)]     l1: [array([[ 0.09127654, 1.1659832 , -0.61909443, 0.3422218 ], [-0.7377194 , 0.20082018, -0.47870865, 0.30302727], [-0.1370897 , -0.0667181 , -0.39285263, -1.1399261 ], [-0.1576551 , 1.1161333 , -0.15552482, 0.39256814]], dtype=float32), array([-0.94946504, -2.9903848 , 2.9848468 , -2.9061244 ], dtype=float32)]     l2: [array([[-0.13567649], [-1.4634581 ], [ 0.68370366], [-1.2069695 ]], dtype=float32), array([2.9170544], dtype=float32)]</code> </pre><br>  Wie Sie vielleicht bemerkt haben, kann das aktuelle Modell auch die entsprechenden Grad Fahrenheit recht gut vorhersagen.  Wenn wir jedoch die Werte der internen Variablen (Gewichte) von Neuronen nach Schichten betrachten, werden wir keine Werte ähnlich 1,8 und 32 sehen.  Die zusätzliche Komplexität des Modells verbirgt die „einfache“ Form der Umrechnung von Grad Celsius in Grad Fahrenheit. <br><br>  Bleiben Sie in Verbindung und im nächsten Teil werden wir uns ansehen, wie dichte Schichten „unter der Haube“ funktionieren. <br><br><h3>  Kurze Zusammenfassung </h3><br>  Glückwunsch!  Sie haben gerade Ihr erstes Modell trainiert.  In der Praxis haben wir gesehen, wie das Modell durch Eingabe- und Ausgabewerte gelernt hat, den Eingabewert mit 1,8 zu multiplizieren und 32 zu addieren, um das richtige Ergebnis zu erhalten. <br><br><img src="https://habrastorage.org/webt/g7/c9/ho/g7c9horz6n3sokt6htkcie4ydsq.jpeg"><br><br>  Das war wirklich beeindruckend, wenn man bedenkt, wie viele Codezeilen wir schreiben mussten: <br><br><pre> <code class="python hljs">l0 = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">1</span></span>]) model = tf.keras.Sequential([l0]) model.compile(loss=<span class="hljs-string"><span class="hljs-string">'mean_squared_error'</span></span>, optimizer=tf.keras.optimizers.Adam(<span class="hljs-number"><span class="hljs-number">0.1</span></span>)) history = model.fit(celsius_q, fahrenheit_a, epochs=<span class="hljs-number"><span class="hljs-number">500</span></span>, verbose=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) model.predict([<span class="hljs-number"><span class="hljs-number">100.0</span></span>])</code> </pre><br>  Das obige Beispiel ist ein allgemeiner Plan für alle maschinellen Lernprogramme.  Sie werden ähnliche Konstruktionen verwenden, um neuronale Netze zu erstellen und zu trainieren und nachfolgende Probleme zu lösen. <br><br><h3>  Trainingsprozess </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Trainingsprozess (der in der Methode stattfindet </font></font><code>model.fit(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) besteht aus einer sehr einfachen Abfolge von Aktionen, deren Ergebnis die Werte interner Variablen sein sollten, um die Ergebnisse so nah wie möglich am Original zu erhalten. </font><font style="vertical-align: inherit;">Der Optimierungsprozess, durch den solche Ergebnisse erzielt werden, der als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradientenabstieg bezeichnet wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , verwendet eine numerische Analyse, um die am besten geeigneten Werte für die internen Variablen des Modells zu finden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um maschinelles Lernen zu betreiben, müssen Sie diese Details grundsätzlich nicht verstehen. Aber für diejenigen, die noch mehr lernen möchten: Der Gradientenabstieg durch Iterationen ändert die Parameterwerte ein wenig und „zieht“ sie in die richtige Richtung, bis die besten Ergebnisse erzielt werden. In diesem Fall bedeuten „beste Ergebnisse“ (beste Werte), dass jede nachfolgende Änderung des Parameters nur das Ergebnis des Modells verschlechtert. Eine Funktion, die misst, wie gut oder schlecht ein Modell bei jeder Iteration ist, wird als "Verlustfunktion" bezeichnet, und das Ziel jedes "Ziehens" (Anpassung interner Werte) besteht darin, den Wert der Verlustfunktion zu verringern.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Trainingsprozess beginnt mit dem Block „Direktverteilung“, in dem die Eingabeparameter zum Eingang des neuronalen Netzwerks gehen, den verborgenen Neuronen folgen und dann zum Wochenende gehen. Das Modell wendet dann interne Transformationen auf die Eingabewerte und internen Variablen an, um die Antwort vorherzusagen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Beispiel ist der Eingabewert die Temperatur in Grad Celsius und das Modell hat den entsprechenden Wert in Grad Fahrenheit vorhergesagt. </font></font><br><br><img src="https://habrastorage.org/webt/vo/vs/sx/vovssxwlsojtbl89vts6llkqfgk.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald der Wert vorhergesagt ist, wird die Differenz zwischen dem vorhergesagten und dem richtigen Wert berechnet. Der Unterschied wird als „Verlust“ bezeichnet und ist eine Form der Messung der Funktionsweise des Modells. Der Verlustwert wird durch die Verlustfunktion berechnet, die wir beim Aufruf der Methode durch eines der Argumente ermittelt haben </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach der Berechnung des Verlustwerts werden die internen Variablen (Gewichte und Verschiebungen) aller Schichten des neuronalen Netzwerks angepasst, um den Verlustwert zu minimieren und den Ausgabewert an den korrekten anfänglichen Referenzwert anzunähern. </font></font><br><br><img src="https://habrastorage.org/webt/wd/sf/qb/wdsfqbnpgcoudq5h7xtoik7omxa.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieser Optimierungsprozess wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gradientenabstieg bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ein spezifischer Optimierungsalgorithmus wird verwendet, um einen neuen Wert für jede interne Variable zu berechnen, wenn die Methode aufgerufen wird </font></font><code>model.compile(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Im obigen Beispiel haben wir einen Optimierungsalgorithmus verwendet </font></font><code>Adam</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Verständnis der Prinzipien des Trainingsprozesses ist für diesen Kurs nicht erforderlich. Wenn Sie jedoch neugierig genug sind, finden Sie weitere Informationen zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Crash-Kurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Die Übersetzung und der praktische Teil des gesamten Kurses sind in den Veröffentlichungsplänen des Autors festgelegt.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt sollten Sie bereits mit den folgenden Begriffen vertraut sein:</font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigenschaft</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Eingabewert unseres Modells;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiele</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Eingabe + Ausgabe-Paare;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Modellausgabewerte;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schichten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : eine Sammlung von Knoten, die innerhalb eines neuronalen Netzwerks miteinander verbunden sind;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modell</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Darstellung Ihres neuronalen Netzwerks;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dicht und vollständig verbunden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Jeder Knoten in einer Schicht ist mit jedem Knoten aus der vorherigen Schicht verbunden.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewichte und Offsets</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Modellinterne Variablen;</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verlust</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : die Differenz zwischen dem gewünschten Ausgabewert und dem tatsächlichen Ausgabewert des Modells;</font></font></li><li> <b>MSE</b> :  ,   ,        ,    . </li><li> <b> </b> : ,     -         ; </li><li> <b></b> :     ; </li><li> <b>  </b> :  «»       ; </li><li> <b></b> :      ; </li><li> <b></b> :       ; </li><li> <b> </b> :      ; </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückausbreitung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Berechnung der Werte interner Variablen gemäß einem Optimierungsalgorithmus ausgehend von der Ausgabeschicht und in Richtung der Eingabeschicht durch alle Zwischenschichten.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ebenen spüren </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorherigen Teil haben wir ein Modell erstellt, das Grad Celsius in Grad Fahrenheit umwandelt. Dabei wurde ein einfaches neuronales Netzwerk verwendet, um die Beziehung zwischen Grad Celsius und Grad Fahrenheit zu ermitteln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Netzwerk besteht aus einer einzigen vollständig verbundenen Schicht. </font><font style="vertical-align: inherit;">Aber was ist eine vollständig verbundene Schicht? </font><font style="vertical-align: inherit;">Um dies herauszufinden, erstellen wir ein komplexeres neuronales Netzwerk mit 3 Eingabeparametern, einer verborgenen Schicht mit zwei Neuronen und einer Ausgangsschicht mit einem einzelnen Neuron.</font></font><br><br><img src="https://habrastorage.org/webt/qo/_p/rk/qo_prk3p2aclbp8xdyzgk8trkme.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denken Sie daran, dass ein neuronales Netzwerk als eine Reihe von Schichten vorgestellt werden kann, von denen jede aus Knoten besteht, die als Neuronen bezeichnet werden. Neuronen auf jeder Ebene können mit den Neuronen jeder nachfolgenden Schicht verbunden werden. Die Art der Schichten, in denen jedes Neuron einer Schicht mit dem anderen Neuron der nächsten Schicht verbunden ist, wird als vollständig verbundene (vollständig verbundene) oder dichte Schicht ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-schicht) bezeichnet. </font></font><br><br><img src="https://habrastorage.org/webt/yk/dl/wb/ykdlwbtzt8rbjusmtndstttg_em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir also vollständig verbundene Schichten verwenden </font></font><code>keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, informieren wir Sie darüber, dass die Neuronen dieser Schicht mit allen Neuronen der vorherigen Schicht verbunden sein sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das obige neuronale Netzwerk zu erstellen, reichen uns folgende Ausdrücke:</font></font><br><br><pre> <code class="python hljs">hidden = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">2</span></span>, input_shape=[<span class="hljs-number"><span class="hljs-number">3</span></span>]) output = tf.keras.layers.Dense(units=<span class="hljs-number"><span class="hljs-number">1</span></span>) model = tf.keras.Sequential([hidden, output])</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also haben wir herausgefunden, was Neuronen sind und wie sie zusammenhängen. Aber wie funktionieren vollständig verbundene Schichten tatsächlich? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu verstehen, was dort wirklich passiert und was sie tun, müssen wir „unter die Haube“ schauen und die interne Mathematik der Neuronen auseinander nehmen. </font></font><br><br><img src="https://habrastorage.org/webt/io/xa/yf/ioxayfceecf7saxdaxnzw3hjyw4.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor, unser Modell empfängt drei Parameter - </font></font><code>1, 2, 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>1, 2  3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- die Neuronen unseres Netzwerks. Denken Sie daran, wir haben gesagt, dass ein Neuron interne Variablen hat? So, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von w *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind die internen Variablen Neuron, auch bekannt als das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewicht</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verdrängung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es sind die Werte dieser Variablen, die im Lernprozess angepasst werden, um die genauesten Ergebnisse beim Vergleich der Eingabewerte mit der Ausgabe zu erhalten. </font></font><br><br><img src="https://habrastorage.org/webt/gz/ff/pf/gzffpftu7hqtdvesq6g9jmcjj10.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was Sie auf jeden Fall beachten sollten, ist, dass die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interne Mathematik des Neurons unverändert bleibt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mit anderen Worten, während des Trainingsprozesses ändern sich </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gewichte und Verschiebungen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie anfangen, maschinelles Lernen zu lernen, mag es seltsam erscheinen - die Tatsache, dass es wirklich funktioniert, aber so funktioniert maschinelles Lernen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir zu unserem Beispiel für die Umrechnung von Grad Celsius in Grad Fahrenheit zurück.</font></font><br><br><img src="https://habrastorage.org/webt/qv/vf/hz/qvvfhzkmdgzktu-yi8i64_cqo4q.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit einem einzelnen Neuron haben wir nur ein Gewicht und eine Verschiebung. Weißt du was? Genau so sieht die Formel zur Umrechnung von Grad Celsius in Grad Fahrenheit aus. Wenn wir den </font></font><code>w11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">ersetzen </font></font><code>1.8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und statt </font></font><code>b1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- erhalten </font></font><code>32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir das endgültige Transformationsmodell! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir aus dem praktischen Teil auf die Ergebnisse unseres Modells zurückkommen, werden wir darauf achten, dass die Indikatoren für Gewicht und Verschiebung so „kalibriert“ wurden, dass sie ungefähr den Werten aus der Formel entsprechen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben absichtlich ein solches praktisches Beispiel erstellt, um den genauen Vergleich zwischen Gewichten und Offsets klar darzustellen. Wenn wir maschinelles Lernen in die Praxis umsetzen, können wir die Werte von Variablen niemals auf diese Weise mit dem Zielalgorithmus vergleichen, wie im obigen Beispiel. Wie können wir das machen? Auf keinen Fall, da wir den Zielalgorithmus nicht einmal kennen! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Probleme des maschinellen Lernens zu lösen, testen wir verschiedene Architekturen neuronaler Netze mit unterschiedlicher Anzahl von Neuronen. Durch Versuch und Irrtum finden wir die genauesten Architekturen und Modelle und hoffen, dass sie das Problem im Lernprozess lösen. Im nächsten praktischen Teil können wir spezifische Beispiele für diesen Ansatz untersuchen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bleiben Sie in Kontakt, denn jetzt beginnt der Spaß!</font></font><br><br><h3>  Zusammenfassung </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Lektion lernten wir grundlegende Ansätze des maschinellen Lernens und lernten, wie vollständig verbundene Ebenen ( </font></font><code>Dense</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ebenen) funktionieren. </font><font style="vertical-align: inherit;">Sie haben Ihr erstes Modell darauf trainiert, Grad Celsius in Grad Fahrenheit umzurechnen. </font><font style="vertical-align: inherit;">Sie haben auch die grundlegenden Begriffe des maschinellen Lernens gelernt, z. B. Eigenschaften, Beispiele und Beschriftungen. </font><font style="vertical-align: inherit;">Sie haben unter anderem die wichtigsten Codezeilen in Python geschrieben, die das Rückgrat jedes Algorithmus für maschinelles Lernen bilden. </font><font style="vertical-align: inherit;">Sie haben gesehen, dass Sie in wenigen Codezeilen mithilfe von </font></font><code>TensorFlow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">eine Vorhersage von einem neuronalen Netzwerk erstellen, trainieren und anfordern können </font></font><code>Keras</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  ... und Standard-Handlungsaufforderung - anmelden, ein Plus setzen und teilen :) <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Videoversion des Artikels</font></font></b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/yXoH4UQovBs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YouTube: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://youtube.com/channel/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Telegramm: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://t.me/ashmig</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VK: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://vk.com/ashmig</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453558/">https://habr.com/ru/post/de453558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453542/index.html">Der vierbeinige Roboter konnte ein 3,3 Tonnen schweres Flugzeug ziehen</a></li>
<li><a href="../de453544/index.html">Sieben-Segment-Decoder, der sowohl direkte als auch inverse Ausgänge eines BCD-Zählers verwendet</a></li>
<li><a href="../de453546/index.html">Benötigen Sie eine kleine Tastatur - machen Sie es selbst</a></li>
<li><a href="../de453548/index.html">Wir beleben das bremsende Samsung Galaxy TAB 2 WiFi</a></li>
<li><a href="../de453554/index.html">Wie sich Starlink von SpaceX geändert hat</a></li>
<li><a href="../de453562/index.html">Digitale Veranstaltungen in Moskau vom 27. Mai bis 2. Juni</a></li>
<li><a href="../de453564/index.html">Machen Sie es wahr - Entwickeln Sie ein Logikspiel für Unity</a></li>
<li><a href="../de453566/index.html">Stellen Sie die Legende wieder her: ein Aufruf zum Austausch offener Daten, die bei der Wiederherstellung von Notre Dame helfen können</a></li>
<li><a href="../de453568/index.html">Neuerstellung eines Symbols: Aufruf zur Freigabe offener Daten zur Wiederherstellung von Notre-Dame</a></li>
<li><a href="../de453570/index.html">Microsoft Edge für MacOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>