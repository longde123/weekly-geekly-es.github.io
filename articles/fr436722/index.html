<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèΩ üôáüèΩ ‚òùüèº Syst√®me expert m√©dical de diagnostic sur Prolog üíâ ‚è±Ô∏è üëå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Entr√©e 
 D'une certaine mani√®re, j'ai eu la chance de choisir le sujet de la th√®se en g√©nie logiciel, et j'ai choisi d'√©crire un syst√®me expert, en pl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Syst√®me expert m√©dical de diagnostic sur Prolog</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436722/"><h2>  Entr√©e </h2><br>  D'une certaine mani√®re, j'ai eu la chance de choisir le sujet de la th√®se en g√©nie logiciel, et j'ai choisi d'√©crire un syst√®me expert, en plus, en langage Prolog.  Bien qu'il ne soit presque jamais utilis√© en programmation industrielle, il est th√©oriquement int√©ressant et permet de toucher les syst√®mes intelligents (IP) de la mani√®re la plus rapide.  De plus, le langage lui-m√™me est int√©ressant en termes de sport, car il vous fait penser d'une mani√®re inhabituelle, diff√©rente de la pens√©e de la programmation proc√©durale et de la POO, qui est un bon entra√Ænement pour le cerveau. <br><br>  Nous avons utilis√© l'impl√©mentation de Prolog - Visual Prolog, avec des biblioth√®ques GUI int√©gr√©es.  Mais si <br>  Si vous souhaitez √©crire une interface graphique dans Qt / C ++, la documentation contient des instructions sur la fa√ßon d'importer un programme dans une DLL et de le compiler avec un projet C / C ++.  Il s'ensuit qu'il peut √™tre combin√© avec d'autres langues. <br><br>  En g√©n√©ral, lorsque j'ai travaill√© sur ce projet, je n'ai pas trouv√© d'exemples qui n'√©taient pas assez primitifs, mais en m√™me temps pas aussi gros que des exemples scientifiques sophistiqu√©s.  Par cons√©quent, cet article peut √™tre tr√®s utile pour les d√©butants et les personnes qui souhaitent √©crire au moins un peu comme IP. <br><br>  Description de l'objectif du syst√®me: il existe un ensemble de param√®tres auxquels un cardiosignal (ECG) doit correspondre, en fonction desquels vous pouvez d√©terminer la maladie.  Une personne r√©pond aux questions du syst√®me (en mode dialogue) et le syst√®me, agissant en tant qu'expert des maladies cardiaques, tire des conclusions sur une maladie humaine potentielle. <br><br>  C'est-√†-dire  Ce code peut √™tre consid√©r√© comme un framework (prolog-framework) pour cr√©er des syst√®mes experts √† partir d'autres domaines, simplement en substituant vos propres r√®gles, vos donn√©es.  Les r√®gles selon lesquelles l'insertion est effectu√©e seront d√©crites ci-dessous. <br><br><h2>  Calcul des pr√©dicats de premier ordre et langage Prolog </h2><br>  Le langage Prolog met en ≈ìuvre le paradigme de programmation logique, dont l'id√©e est l'utilisation de la technologie informatique pour la conclusion logique de la description d√©clarative du domaine.  Cela le distingue des langages de programmation proc√©duraux qui d√©crivent des actions s√©quentielles bien d√©finies.  Par cons√©quent, les langages proc√©duraux ne conviennent pas √† l'√©criture d'ES, et s'ils sont utilis√©s, alors uniquement comme modules auxiliaires.  Une autre caract√©ristique distinctive du langage Prolog est l'utilisation d'un sous-ensemble du langage logique de premier ordre pour d√©crire un programme, ce qui est pratique et plus simple que pour les autres; il passe d'un langage naturel √† la description du monde par une personne.  Lors de la cr√©ation d'un ES, c'est l'un des probl√®mes importants - comment traduire les connaissances du domaine dans un langage formel limit√©, tout en pr√©servant le contenu informationnel investi par une personne.  Il existe √©galement une occasion simple de retransf√©rer les connaissances de la forme formelle √† la forme naturelle, en raison de la compr√©hensibilit√© et de la simplicit√© intuitives, par rapport √† la logique du second ordre ou √† d'autres calculs math√©matiques. <br><br>  Les constructions linguistiques du Prolog peuvent √™tre repr√©sent√©es sous la forme d'implications de la forme: <br><br> <code>A1, A2, ‚Ä¶, An &lt;= B1, B2, ‚Ä¶,Bm (n&gt;=0, m&gt;=0) (1)</code> <br> <br>  o√π Ai et Bi sont des formules atomiques Fi (t1, t2, ..., tk) ou la n√©gation Fi (t1, t2, ..., tk), o√π tk sont des termes (constante individuelle, variable ou r√©sultat de l'application de la fonction) <br><br>  Dans Prolog, toutes les relations sont √©crites sous forme de faits et de r√®gles, o√π n = 1 dans la formule (1), pour augmenter l'efficacit√© de l'inf√©rence logique.  Les r√®gles correspondent √† une formule appel√©e formule Horn: <br><br> <code>A&lt;=B1, B2, ‚Ä¶, Bm , m&gt;0 (2)</code> <br> <br>  Les faits correspondent √† la formule (2) avec m = 0: <br><br> <code>A&lt;= (3)</code> <br> <br>  La formule qui doit √™tre prouv√©e dans le processus du m√©canisme d'inf√©rence est la formule (1) pour n = 0, m&gt; 0, appel√©e objectif ou demande: <br><br> <code>&lt;= B1, B2, ‚Ä¶Bm (4)</code> <br> <br>  Ces constructions de langage comprennent l'ensemble du programme Prolog. <br>  Par exemple, les connaissances suivantes, sous la forme d'une phrase en langage naturel - ¬´Son Ani aime Masha¬ª peuvent √™tre √©crites comme un fait: <br><br><pre> <code class="plaintext hljs">((), )</code> </pre> <br>  et la phrase ¬´Anya aime tous ceux que Olga aime¬ª sous la forme: <br><br><pre> <code class="plaintext hljs">((,X)&lt;=(,X))</code> </pre> <br>  Ou le raisonnement ¬´Chaque personne est mortelle.  Confucius est un homme ¬ª: <br><br><pre> <code class="plaintext hljs">(()&amp; ((X)&lt;=(X)) &lt;= ()</code> </pre> <br>  Le Prolog fournit √©galement des outils pour d√©finir des structures de donn√©es r√©cursives, telles que des arbres et des listes, ce qui apporte des capacit√©s suppl√©mentaires pour une description pratique des connaissances pertinentes. <br><br>  Ainsi, on peut voir que le Prolog fournit un langage flexible, simple et intuitif pour d√©crire les connaissances. <br><br>  Mais alors la question se pose de choisir l'impl√©mentation de ce langage, et il a √©t√© d√©cid√© de d√©velopper ES sur l'extension du langage Prolog - Visual Prolog. <br><br><h2>  Prologue visuel </h2><br>  Visual Prolog est un dialecte du langage Prolog avec une extension orient√©e objet et un environnement de d√©veloppement int√©gr√©.  Cet environnement prend en charge la cr√©ation d'interfaces graphiques et de nombreuses autres biblioth√®ques.  Le langage Prolog est assez populaire pour cr√©er des ES, avec une syntaxe simple qui a une signification similaire aux relations et aux faits de domaine.  En g√©n√©ral, l'interpr√®te de langage Prolog lui-m√™me peut √™tre consid√©r√© comme un ES en termes de logique de pr√©dicat de premier ordre, dans laquelle l'utilisateur pose une question sous la forme d'un objectif dont la v√©rit√© doit √™tre prouv√©e.  Il s'agit d'un langage d√©claratif, il d√©crit ce qui doit √™tre obtenu, au lieu d'un algorithme s√©quentiel, est parfait pour d√©crire la connaissance d'un petit ES.  Par rapport aux environnements alternatifs, AMZI Prolog et SWI-Prolog fournissent une interface tr√®s efficace pour interagir avec d'autres langues, soit en liant des fichiers objets soit en chargeant dynamiquement des DLL d'autres langues ou en tant que module DLL autonome.  Visual Prolog est √©galement bien document√© et contient de nombreux exemples.  Il existe √©galement une opinion selon laquelle le choix d'un langage de mise en ≈ìuvre, une mani√®re de pr√©senter les connaissances et une m√©thode de formation du raisonnement sont secondaires, par rapport aux connaissances d'un expert, et n'affectent que le m√©canisme de leur utilisation r√©ussie.  N√©anmoins, la pr√©sence d'une litt√©rature utilisant le prologue comme moyen de cr√©er des ES indique la pertinence de son utilisation, au moins dans les petits syst√®mes. <br><br><h2>  Conception ES </h2><br>  Dans la litt√©rature, il est habituel de diviser les ES en plusieurs composants de base peu d√©pendants les uns des autres: la base de connaissances, le m√©canisme de sortie et l'interface utilisateur. <br><br>  Il existe 2 types d'organisation des syst√®mes experts: sur les r√®gles et sur les faits. <br><br>  La connaissance d'ES sur les r√®gles est enregistr√©e sous forme de r√®gles de production.  La partie gauche de chaque r√®gle contient une alternative √† la r√©solution du probl√®me, et les parties droites (pr√©misses) sont sp√©cifi√©es par d'autres r√®gles.  La seule exception est lorsqu'une r√®gle recherche des informations dans la base de donn√©es, comme une r√©ponse √† une question.  L'algorithme du m√©canisme de sortie est r√©duit √† la comparaison, puis avec de nombreuses options, celle qui est n√©cessaire est s√©lectionn√©e conform√©ment au principe de r√©solution des conflits et √† la fin la r√®gle s√©lectionn√©e est appliqu√©e et tout recommence.  Les avantages d'une telle organisation sont qu'il est tr√®s facile d'ajouter des r√®gles au syst√®me sans affecter d'autres r√®gles, et il est facile de compl√©ter et de modifier, car le programmeur n'a qu'√† ins√©rer la r√®gle souhait√©e dans le bloc de r√®gles appropri√©.  Une telle organisation a √©galement des limites, √† savoir, il sera n√©cessaire d'organiser un algorithme non naturel pour enregistrer la trace ou d'utiliser une variable pour celle-ci dans les r√®gles, mais cela violera la commodit√© de modifier les r√®gles, car pour chaque pr√©dicat de r√®gle, il est n√©cessaire d'organiser l'enregistrement de la trace.  En outre, cela violera la lisibilit√© du programme et la possibilit√© de modifier le m√©canisme de sortie en g√©n√©ral, car avec les informations sur les r√®gles, la travers√©e par l'action du m√©canisme de sortie sera conserv√©e.  En outre, le prologue ne vous permet pas d'enregistrer les r√®gles dans le fichier de base de donn√©es et de lire les r√®gles de la base de donn√©es, ce qui ne permettrait pas de mettre √† jour la base de connaissances pendant l'ex√©cution du programme.  Le listing 1 donne un exemple d'une telle organisation de base de connaissances. <br><br>  Listing 1 <br><br><pre> <code class="plaintext hljs">diag("SIRS"):- diag2("SIRS"). diag("Sepsis"):- diag("SIRS"), have("Sepsis character"). diag("Hard sepsis"):- diag("Sepsis"), have("Hard sepsis character"). diag("Shock sepsis"):- diag("Hard sepsis"), have("Shock sepsis character"). diag("MOF"):- diag("Hard sepsis"), have("MOF sepsis character"). diag("MOF"):- diag("Shock sepsis"), have("MOF sepsis character").</code> </pre> <br>  Comme le montre le Listing 1, le m√©canisme de sortie doit √™tre compl√®tement contr√¥l√© par le m√©canisme de sortie standard Prolog int√©gr√©. <br><br>  Les ES organis√©s sur la logique (sur les faits) sont plus flexibles, car, contrairement √† la connexion directe des r√®gles, ils sont organis√©s sur une m√©thode de r√©f√©rence (indirecte) pour d√©crire la relation des r√®gles.  Les relations sont √©crites en termes, tels que des num√©ros de r√®gles, et non des r√®gles imbriqu√©es.  Un tel enregistrement est plus coh√©rent avec un enregistrement strict sous la forme de phrases de logique de pr√©dicat, ce qui rend le m√©canisme pour d√©river de telles r√®gles plus flexible.  Contrairement √† l'organisation bas√©e sur les r√®gles, la recherche de la solution Prolog d√©pend moins du processus d'inf√©rence logique de la r√®gle suivante, car il devient possible d'effectuer d'autres actions en plus de la sortie, par exemple, passer par un autre arbre de d√©cision ou m√™me changer le flux de sortie et revenir √† la position de d√©part tout en maintenant toutes les donn√©es √† ce sujet. <br><br>  Comme dans l'organisation, un cycle op√®re sur les r√®gles ici: correspondance - r√©solution des conflits - transition vers la r√®gle suivante, mais comme le m√©canisme de sortie est contr√¥l√© indirectement, il est pratique d'afficher des informations sur la recherche d'une solution dans le processus et de changer ce format sans changer la base de connaissances.  Le principal avantage d'une organisation sur la logique est qu'il est possible de rendre les variables mapp√©es pendant le processus de sortie automatiquement disponibles dans le m√©canisme de sortie, et qu'elles peuvent √™tre affich√©es avec une cha√Æne des derni√®res r√®gles qui sont sorties vers la cible actuelle.  Mais pour cela, il est n√©cessaire de pr√©voir en plus un m√©canisme pour les types fant√¥mes pour diff√©rents types de r√®gles.  De plus, la base de connaissances est stock√©e sous forme de faits, elle peut donc √™tre enregistr√©e ou lue √† partir d'un fichier sur le support.  Il est plus difficile de modifier et de d√©boguer le syst√®me sur des faits que sur des r√®gles, car le m√©canisme de sortie est contr√¥l√© par les valeurs des variables et des termes, par exemple sous la forme d'un num√©ro de r√®gle, ce qui introduit des possibilit√©s suppl√©mentaires d'erreurs. <br><br>  Dans le m√©canisme de sortie, il y a √©galement plus de variables qui influencent ce processus, parfois de type r√©cursif et plut√¥t interconnect√©es, ce qui complique le d√©veloppement et les erreurs de capture, mais c'est le prix de la flexibilit√© qu'il offre.  Le syst√®me fonctionne √©galement plus efficacement et plus rapidement sur les faits que sur les r√®gles, ce qui est particuli√®rement important pour les ES en temps r√©el volumineux, ou m√™me pour les ES en temps r√©el distribu√©s. <br><br>  Un ES important pour le diagnostic m√©dical en cas d'admission de patients dans un √©tat critique, en particulier s'il est utilis√© simultan√©ment par de nombreux m√©decins, doit √©galement s'inscrire dans un d√©lai strict. <br><br>  Il est encore plus difficile de tester un syst√®me sur des faits en raison de sa d√©pendance √† l'√©gard des faits, car dans un syst√®me sur des r√®gles, seule une erreur affecterait le m√©canisme de sortie, et cela deviendrait imm√©diatement visible, mais tr√®s probablement, il continuerait de fonctionner sur des faits. <br><br>  En cons√©quence, √©tant donn√© que le syst√®me d√©velopp√© doit √™tre informatif pour l'utilisateur, √† savoir, une r√©ponse raisonn√©e √† la question doit √™tre affich√©e dans le processus d'inf√©rence logique - pourquoi le syst√®me a-t-il besoin des informations demand√©es pour que l'utilisateur sache √† quel stade de la recherche de solutions il se trouve, ce qui ne peut √™tre r√©alis√© sans enregistrer la trace recherche.  Toujours √† la fin, apr√®s avoir r√©pondu √† la question, l'utilisateur devrait pouvoir voir l'arborescence des preuves des solutions trouv√©es.  Compte tenu de tous les param√®tres du syst√®me, le syst√®me le plus rationnel m'a sembl√© les r√®gles, car il peut √™tre enregistr√© sur disque et son m√©canisme de sortie sera plus facile √† organiser.  De plus, les connaissances sur le diagnostic des maladies cardiovasculaires se sont r√©v√©l√©es assez difficiles √† formaliser en raison de leur interconnexion s√©mantique, en particulier dans les endroits o√π la signification des conclusions des r√®gles impliquait de prendre en compte des informations suppl√©mentaires, pour chacune la sienne.  Par cons√©quent, lors du choix d'un m√©canisme d'√©change de donn√©es h√©t√©rog√®nes entre pr√©dicats, un calcul a √©t√© effectu√© sur la mani√®re logique d'organiser. <br><br>  Il existe √©galement 2 types d'inf√©rence: l'inf√©rence inverse et l'inf√©rence directe.  Dans les syst√®mes de consultation m√©dicale complexes, une combinaison de ces types est toujours utilis√©e: une certaine quantit√© de connaissances est d√©duite par un type, et un autre est d√©j√† utilis√© sur sa base. <br><br>  Une conclusion directe est de trouver un effet bas√© sur une multitude de faits, puis de tirer d'autres conclusions des nouvelles cons√©quences.  Il est efficace lorsqu'il existe de nombreuses hypoth√®ses li√©es √† diff√©rents niveaux qui doivent √™tre prouv√©es, ou lorsque de nombreux axiomes permettent de d√©river de nombreuses autres hypoth√®ses. <br><br>  La conclusion inverse est l'inverse, d'abord une hypoth√®se est s√©lectionn√©e qui doit √™tre prouv√©e, puis une tentative est faite pour prouver la pr√©misse de cette hypoth√®se, jusqu'√† ce que la pr√©misse suivante soit trouv√©e comme un axiome. <br><br>  Dans ES, le raisonnement sur les r√®gles est impl√©ment√© par la m√©thode d'inf√©rence logique inverse, qui utilise Prolog.  Cette option a √©t√© choisie, car, contrairement √† l'inf√©rence directe, elle fonctionne plus efficacement avec cette connaissance, car le nombre de sommets cibles est beaucoup plus que les faits et il n'y a pas d'hypoth√®ses concurrentes (elles sont ind√©pendantes). <br><br><h2>  Impl√©mentation </h2><br>  Dans Prolog, les r√®gles sont impl√©ment√©es en tant que pr√©dicat de r√®gle.  Chaque r√®gle a son propre num√©ro et nom, ce qui est une hypoth√®se (conclusion) qui doit √™tre prouv√©e.  La condition de la r√®gle correspond √† un √©nonc√© implicite, qui d√©termine compl√®tement la v√©rit√© de l'hypoth√®se. <br><br>  Condition de la r√®gle: <br><br><pre> <code class="plaintext hljs">Colclusion(K)=C1(K) and (C2(K) or C3(K)) and C4(K)</code> </pre> <br>  C1 (K) = Toutes les conclusions des r√®gles avec des nombres enregistr√©s dans la premi√®re liste pour la K√®me r√®gle sont vraies <br><br>  C2 (K) = Vrai, au moins une r√®gle de la deuxi√®me liste pour la K√®me r√®gle <br>  C3 (K) = Vraiment exactement N (K) Conclusions des r√®gles de la deuxi√®me liste pour la K√®me r√®gle <br><br>  C4 (K) = Pr√©dicat de la r√®gle Kth (doc pr√©dicat (K)), qui est d√©crit par l'utilisateur. <br>  Si une liste est vide, la d√©claration correspondante est vraie. <br><br>  En m√™me temps, tout autre pr√©dicat peut √™tre entr√© dans le pr√©dicat pour C4, mais en m√™me temps, il ne doit pas violer le sens logique de la conclusion.  Pour soutenir le refus, certaines conclusions existantes dans la base de connaissances peuvent √©galement √™tre saisies ici. <br><br>  Le m√©canisme de sortie garantit que les r√®gles sont appliqu√©es dans le bon ordre et enregistre la trace. <br><br>  Le principe principal de la conclusion est de prouver la v√©rit√© de la conclusion, de prouver syst√©matiquement toutes ses conclusions dans la premi√®re liste, puis de prouver les conclusions de la deuxi√®me liste et au final de v√©rifier la v√©rit√© du pr√©dicat correspondant au num√©ro de la r√®gle courante.  Pour v√©rifier la deuxi√®me liste, si au moins une vraie r√®gle est trouv√©e, toutes les autres r√®gles en cours √† la fin de la liste seront v√©rifi√©es. <br><br><h2>  Description du pr√©dicat </h2><br>  En g√©n√©ral, le principe du codage des connaissances est impl√©ment√© sur le Prolog √† l'aide de deux pr√©dicats sous la forme suivante: <br><br>  r√®gle (K, "Le texte de conclusion est le nom de la r√®gle", Id, List1, List2, N) <br>  doc (K) <br>  K - num√©ro de r√®gle <br>  Id - ID de donn√©es pour cette r√®gle <br>  List1 - la premi√®re liste de num√©ros de r√®gle <br>  List2 - deuxi√®me liste de num√©ros de r√®gle <br>  N est le nombre de vraies conclusions <br><br>  De plus, la r√®gle est toujours √©crite comme un fait, sans variables, et sa v√©rit√©, comme on l'a dit, d√©termine, en plus des listes, le doc pr√©dicat correspondant. <br><br>  Voici quelques exemples de connaissances en √©criture: <br><br>  r√®gle (93, ¬´TASH - TASH-score 43%¬ª, tashSc10, [47], [], 0) <br>  r√®gle (33, ¬´TASH - Excess of motifs - is the sum of points¬ª, none, [], [29,30,31,32], 1). <br><br>  Dans le doc pr√©dicat, tout autre pr√©dicat peut √™tre utilis√©, ce qui permet de mapper le texte de l'√©nonc√© de la r√®gle √† l'ensemble des situations qui peuvent √™tre d√©crites √† l'aide du Prolog. <br><br>  De cette fa√ßon, toutes les connaissances sont enregistr√©es √† l'aide de ces deux pr√©dicats. <br><br>  Dans les pr√©dicats doc, les fonctions de l'interface utilisateur sont principalement appel√©es, car certaines r√®gles sont intrins√®quement inextricablement li√©es √† la r√©ponse de l'utilisateur ou v√©rifient les valeurs valides. <br><br>  Par exemple, le doc pr√©dicte les r√®gles dont la v√©rit√© d√©pend de l'intervalle dans lequel se situe le score total, effectuez les v√©rifications appropri√©es. <br><br>  Le pr√©dicat doc pour le diagnostic des maladies septiques utilise le pr√©dicat docc suppl√©mentaire, qui permet de ne pas poser de questions inutiles √† l'utilisateur.  Par exemple, si un signe n√©cessite au moins deux signes, si la r√©ponse est non √† deux signes, le syst√®me ne devrait pas poser plus de questions, car il est √©vident que le signe ne peut pas √™tre vrai.  Pour ce faire, le pr√©dicat docc v√©rifie plus de deux r√©ponses n√©gatives dans la base de donn√©es.  Il est √©galement insens√© de poser la troisi√®me question s'il existe d√©j√† une r√©ponse √† deux questions suffisantes pour √©tablir la v√©rit√© de la caract√©ristique r√©sultante. <br><br>  Le pr√©dicat kolNeg (Quantity) recherche le nombre de r√©ponses n√©gatives dans la base de donn√©es pour un groupe d'attributs donn√©.  Pour ce faire, il recherche d'abord toutes sortes de signes de ce groupe de signes afin de ne pas les confondre avec d'autres groupes, puis les consid√®re dans l'ensemble de la base de donn√©es en utilisant le pr√©dicat kol_neg_list_in_db travaillant avec la liste des signes de ce groupe. <br><br><h2>  Exemples de code </h2><br>  Le projet est vaste, je vais donc donner les passages les plus importants. <br><br>  Listing 2 - Liste des r√®gles <br><br><pre> <code class="plaintext hljs">rule(11,"Sepsises - SIRS . 1: t&gt;38C  t&lt;36",sirsPr1,[],[],0). rule(12,"Sepsises -   &gt;90",sirsPr2,[],[],0). rule(13,"Sepsises -  &gt;20  PaCO2&lt;32mmHg",sirsPr3,[],[],0).</code> </pre> <br>  Listing 3 - Liste des faits <br><br><pre> <code class="plaintext hljs">fact1(sirsPr1,"SIRS","SIRS . 1: t&gt;38C  t&lt;36"). fact1(sirsPr2,"SIRS","  &gt;90"). fact1(sirsPr3,"SIRS"," &gt;20  PaCO2&lt;32mmHg"). fact1(sirsPr4,"SIRS","- &gt;12.000/mm&gt;3, &lt;4.000/mm&gt;3  &gt;10% band").</code> </pre> <br>  - Liste des cons√©quences logiques <br><br><pre> <code class="plaintext hljs">tash_score(1,tashSc1,0,8,"  &lt;5%"). tash_score(2,tashSc2,9,9,"  6%"). tash_score(3,tashSc3,10,10,"  8%").</code> </pre> <br>  Listing 4 - Machine de sortie <br><br><pre> <code class="1c hljs">sizeList([],<span class="hljs-number"><span class="hljs-number">0</span></span>):-!. sizeList([_<span class="hljs-string"><span class="hljs-string">|T],Size):- sizeList(T,SizeTail), Size=SizeTail+1. append_der_list([],List,List). append_der_list([H|L1],List2,[H|L3]):- append_der_list(L1,List2,L3). any2(NeedSize,NeedSize,_,[],[],_):-!. any2(_,_,[],[],[],_):-!. any2(NeedSize,Size,[H|T1],[H|T2],[FirstDer|OtherDer],Why):- Nomer=[H], go(Nomer,UnderFirstDer,Why), rule(H,Text,_,_,_,_), FirstDer=tree(Text,unmarked,UnderFirstDer,0),%der(H,UnderFirstDer), Size1=Size+1,!, any2(NeedSize,Size1,T1,T2,OtherDer,Why). any2(NeedSize,Size,[_|T1],List,OrDer,Why):- !,any2(NeedSize,Size,T1,List,OrDer,Why). go([],[],_):-!. go([H|T],[FirstDer|OtherDer],Why):- rule(H,Name,_,ListAnd,ListOr,KolOr), NewWhy=[Name|Why], go(ListAnd,UnderFirstDer,NewWhy), goOr(ListOr,KolOr,_,OrDer,NewWhy), append_der_list(UnderFirstDer,OrDer,TwoDers), FirstDer=tree(Name,unmarked,TwoDers,0), asserta(why_trace(NewWhy)), doc(H,NewWhy), go(T,OtherDer,Why). goOr([],_,[],[],_):-!. goOr(ListOr,KolOr,ListYes,OrDer,Why):- KolOr&lt;&gt;0, any2(KolOr,0,ListOr,ListYes,OrDer,Why), sizeList(ListYes,KolOr). goOr(ListOr,0,ListYes,OrDer,Why):- any2(100000,0,ListOr,ListYes,OrDer,Why), sizeList(ListYes,KolListYes), KolListYes&gt;0.</span></span></code> </pre> <br>  Listing 5 - Conclusion des cons√©quences finales <br><br><pre> <code class="plaintext hljs">tashQuestion(Id):- fact2(Id,_,Prisnak,_), pos(Prisnak),!. tashQuestion(Id):- fact2(Id,_,Prisnak,_), neg(Prisnak),fail,!. tashQuestion(Id):- fact2(Id,_,Prisnak,Ball), not(neg(Prisnak)), not(pos(Prisnak)), dialog_ynw(Prisnak,Ans), tash_in_data_base(Ans,Prisnak,Ball),!. tash_in_data_base("y",Prisnak,Ball):- asserta(pos(Prisnak)),sum_tash(Sum1),Sum2=Sum1+Ball,asserta(sum_tash(Sum2)),!. tash_in_data_base("n",Prisnak,_):- asserta(neg(Prisnak)),!,fail. tash_in_data_base(_,_,_):- write("\nTASH-not correct answer"),!,fail. oneQuestion(Id):- fact1(Id,_,Prisnak), pos(Prisnak),!. oneQuestion(Id):- fact1(Id,_,Prisnak), not(neg(Prisnak)), question_sepsis(Prisnak),!.</code> </pre> <br><h2>  Conclusions </h2><br>  J'esp√®re que cet article aide les d√©butants √† construire leur propre syst√®me expert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436722/">https://habr.com/ru/post/fr436722/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436712/index.html">Comment promouvoir un jeu incr√©mental? Gratuit, rapide et efficace *</a></li>
<li><a href="../fr436714/index.html">Le travail commence par les tests.</a></li>
<li><a href="../fr436716/index.html">Fake Door dans le cadre du d√©veloppement client</a></li>
<li><a href="../fr436718/index.html">Exp√©rience personnelle: cinq d√©fis lors du d√©marrage d'une entreprise aux √âtats-Unis</a></li>
<li><a href="../fr436720/index.html">Il y a une opinion: IPv6 a √©chou√© - qui le pense et pourquoi</a></li>
<li><a href="../fr436742/index.html">Android Robotics jusqu'en 2019: la vraie histoire; en 5 parties; partie 1</a></li>
<li><a href="../fr436744/index.html">Lancez votre d√©tecteur de r√©seau neuronal sur le Raspberry Pi √† l'aide du Neural Compute Stick et d'OpenVINO</a></li>
<li><a href="../fr436746/index.html">Comment d√©grader les performances en les am√©liorant</a></li>
<li><a href="../fr436748/index.html">D√©velopper un hexapode √† partir de z√©ro (partie 3) - cin√©matique</a></li>
<li><a href="../fr436750/index.html">Analyse des tendances de YouTube russe pour 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>