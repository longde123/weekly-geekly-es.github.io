<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游녧游 游빁游 游 Nueva interfaz de Odnoklassniki: lanzamiento de React en Java. Parte 1 拘勇 游땙 九뒲잺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchos han escuchado el nombre GraalVM, pero hasta ahora no todos han tenido la oportunidad de probar esta tecnolog칤a en producci칩n. Para Odnoklassnik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nueva interfaz de Odnoklassniki: lanzamiento de React en Java. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/480808/"><img src="https://habrastorage.org/webt/-r/o9/iz/-ro9izrzg1xlvkkewuua1wqu3dg.png"><br><br>  Muchos han escuchado el nombre GraalVM, pero hasta ahora no todos han tenido la oportunidad de probar esta tecnolog칤a en producci칩n.  Para Odnoklassniki, esta tecnolog칤a ya se ha convertido en el front-end cambiante del "Santo Grial". <br><br>  En este art칤culo quiero hablar sobre c칩mo logramos hacer amigos con Java y JavaScript, y comenzar a migrar a un gran sistema con mucho c칩digo heredado, y c칩mo GraalVM ayuda en el camino. <br><br>  Al momento de escribir el art칤culo, result칩 que todo el volumen del material no se ajusta al tama침o tradicional de la HABR y si publica la publicaci칩n completa, tomar치 varias horas leerlo.  Por lo tanto, decidimos dividir el art칤culo en 2 partes. <br><br>  Desde la primera parte aprender치 sobre la historia del front-end en Odnoklassniki y se familiarizar치 con sus caracter칤sticas hist칩ricas, seguir치 el camino para encontrar una soluci칩n a los problemas que se han acumulado en nosotros durante los 11 a침os del proyecto, y al final se sumergir치 en las caracter칤sticas t칠cnicas de la implementaci칩n del servidor de la decisi칩n que tomamos. <br><a name="habracut"></a><br><h2>  Antecedentes </h2><br>  La primera versi칩n de Odnoklassniki apareci칩 hace 13 a침os, en 2006.  El sitio se hizo en .NET, luego no hab칤a JavaScript en el sitio, todo estaba en la representaci칩n del servidor. <br><br><img src="https://habrastorage.org/webt/dl/zv/ik/dlzvikklims5fo3osgeyr-4pbik.jpeg"><br><br>  Un a침o despu칠s, Odnoklassniki ten칤a m치s de un mill칩n de usuarios.  En 2007, estos fueron n칰meros incre칤bles, y el sitio, incapaz de soportar la carga, comenz칩 a caer.  Los desarrolladores resolvieron el problema con la ayuda del proyecto One.lv, creado por la compa침칤a letona Forticom, cuyas competencias centrales estaban en el desarrollo de Java.  Por lo tanto, Odnoklassniki, se decidi칩 reescribir de .NET a Java. <br><br>  Con el tiempo, el proyecto se desarroll칩 y surgi칩 la necesidad de nuevas soluciones para el cliente.  Por ejemplo, cuando se navega por un sitio, no se actualiza por completo, sino solo ciertas partes.  O para que, al enviar, solo se actualice el formulario y no toda la p치gina.  Al mismo tiempo, el sitio funcionaba solo en Java. <br><br>  Para hacer esto, se les ocurri칩 un sistema en el que el sitio estaba marcado con bloques con nombre.  Al navegar, se realiz칩 una solicitud al servidor, que tom칩 una decisi칩n sobre lo que deber칤a cambiarse usando este enlace, y el cliente recibi칩 las piezas necesarias.  El motor del cliente simplemente reemplaz칩 las partes necesarias, por lo que se implement칩 la din치mica del cliente.  Muy conveniente, porque toda la l칩gica de negocios est치 en el servidor.  El peque침o motor permiti칩 a la compa침칤a seguir escribiendo c칩digo Java para administrar el cliente. <br><br>  Por supuesto, sin JavaScript m칤nimo no era suficiente.  Para hacer una ventana emergente, se necesitan manipulaciones: por ejemplo, al pasar el cursor sobre una pantalla div: el bloque se colg칩 o se ocult칩 con la pantalla: ninguno. <br><br>  Pero al mismo tiempo, el contenido de la ventana emergente se solicit칩 al servidor, toda la l칩gica de negocios estaba all칤 y estaba en Java. <br><br><img src="https://habrastorage.org/webt/aj/0h/9i/aj0h9iklirl7jtnjfib1jwaowxo.jpeg"><br><br><h2>  2018 </h2><br>  Despu칠s de 12 a침os, Odnoklassniki se convirti칩 en un servicio gigante con m치s de 70 millones de usuarios.  Tenemos m치s de 7,000 m치quinas en 4 centros de datos, y solo 600 mil solicitudes por segundo llegan al frente de OK.RU. <br><br>  El servidor frontal de Odnoklassniki contin칰a funcionando en Java, y la base de c칩digo de los frentes solo supera los dos millones de l칤neas. <br><br><img src="https://habrastorage.org/webt/ew/dg/zh/ewdgzh7z3n7pf40yqgaluttxkyk.jpeg"><br><br>  Las tecnolog칤as implementadas en el lado del cliente tampoco se detuvieron: aparecieron muchas soluciones usando diferentes bibliotecas: GWT, jQuery, DotJs, RequireJS y muchas otras. <br><br>  En ese momento, est치ndares como React, Angular y Vue no eran comunes, cada desarrollador trat칩 de encontrar la soluci칩n 칩ptima utilizando todas las herramientas disponibles. <br><br>  Qued칩 claro que vivir con esto es muy dif칤cil, porque se ha acumulado una gran cantidad de problemas: <br><br><ul><li>  Muchas bibliotecas antiguas </li><li>  No hay un marco 칰nico </li><li>  Sin isomorfismo (ya que el backend est치 en Java, el cliente est치 en JS) </li><li>  No hay una sola aplicaci칩n estructurada en el cliente </li><li>  Mala capacidad de respuesta </li><li>  Herramientas insuficientes </li><li>  Umbral de entrada alto </li></ul><br>  El mundo ya estaba en 2018 y era necesario cambiar. <br><br>  Usando todo el poder del pensamiento t칠cnico, pensamos y formulamos cuatro requisitos b치sicos para resolver problemas: <br><br><ol><li>  Los compa침eros de clase deben tener un c칩digo isomorfo para la interfaz de usuario.  Debido a que es imposible escribir constantemente el servidor en Java, y luego, si necesita agregar alg칰n tipo de din치mica, juegue lo mismo en el cliente. </li><li>  Se necesita una transici칩n suave.  Porque es imposible hacer r치pidamente la segunda versi칩n de Odnoklassniki y cambiar </li><li>  Necesariamente se necesita la representaci칩n del servidor (m치s sobre eso a continuaci칩n) </li><li>  La nueva soluci칩n, que funciona con la misma cantidad de hierro, no deber칤a afectar el rendimiento y la tolerancia a fallas bajo nuestras cargas. </li></ol><br><h2>  쯇or qu칠 la representaci칩n del lado del servidor? </h2><br>  Odnoklassniki tiene muchos usuarios que viven lejos de Mosc칰 y no siempre tienen una buena conexi칩n a Internet. <br><br><img src="https://habrastorage.org/webt/55/k3/a-/55k3a-kmkkvhtrpyjsmbvtrg1j8.jpeg"><br><br>  La representaci칩n del servidor ayudar치 a estos usuarios a obtener contenido m치s r치pido.  Mientras se cargan las im치genes, podr치n comenzar a leer algo: <br><br><img src="https://habrastorage.org/webt/ig/ga/ww/iggawwqkjpsknbpzdtddoj3lu3c.jpeg"><br><br>  Llevamos a cabo una serie de experimentos, tratando de entender qu칠 suceder칤a si algunos datos (por ejemplo, cinta) ya fueran entregados al cliente, con una expectativa.  Como resultado, result칩 que esto afect칩 negativamente la actividad del usuario. <br><br><h2>  C칩mo funciona el servidor ahora </h2><br>  El navegador realiza una solicitud al sitio OK y accede a la aplicaci칩n OK-WEB, que est치 completamente escrita en Java.  La aplicaci칩n sigue los datos en la API.  Entre WEB y API, se implementa el transporte binario r치pido one-nio desarrollado en Odnoklassniki.  Las solicitudes se completan en menos de un milisegundo.  Puedes ver qu칠 es por <a href="https://github.com/odnoklassniki/one-nio">separado</a> .  One-nio le permite hacer muchas consultas a bajo costo sin preocuparse por demoras. <br><br>  La API extrae los datos y los entrega a la web.  La web genera p치ginas HTML con un motor Java y se lo entrega al navegador. <br><br>  Todo esto lleva ahora menos de 200 ms. <br><br><img src="https://habrastorage.org/webt/px/lt/tw/pxlttwxxg5fddebl4lumank7w2e.jpeg"><br><br><h2>  Busca una soluci칩n </h2><br>  Al principio, se desarroll칩 el concepto de migraci칩n basado en widgets. <br><br>  Las solicitudes ser치n entregadas al sitio en peque침os trozos.  En el interior se escribir치n en una nueva pila.  Y para el resto del sitio ser치 solo un elemento DOM con alg칰n tipo de comportamiento personalizado. <br><br><img src="https://habrastorage.org/webt/0a/7b/9j/0a7b9jtqv4vm1zsfpwdb93jlzpm.jpeg"><br><br>  Esto ser치 similar a la etiqueta &lt;video&gt;: un elemento DOM personalizado con atributos, m칠todos y eventos.  Como resultado, la API DOM se encuentra fuera, mientras que la funcionalidad del widget se implementa dentro de la nueva pila. <br><br><h2>  쯈u칠 pila elegir? </h2><br>  Ahora que era necesario implementar el concepto, comenzaron a clasificar las opciones. <br><br><h3>  Kotlin </h3><br>  El primer prototipo se hizo en Kotlin.  La idea era la siguiente: para nuevos componentes, escribir l칩gica en Kotlin y describir el marcado de componentes en XML.  Todo se puede ejecutar en el servidor en la JVM utilizando el motor de plantillas existente, y para el cliente se puede transponer en JavaScript. <br><br><img src="https://habrastorage.org/webt/al/il/q6/alilq6rigfkuh5jz4yuerp8kvgk.jpeg"><br><br>  Adem치s de introducir un nuevo lenguaje con un umbral de entrada alto, Kotlin result칩 tener herramientas insuficientemente desarrolladas para trabajar con JavaScript, y mucho m치s tendr칤a que desarrollarse de forma independiente. <br><br>  Por lo tanto, desafortunadamente, este concepto tuvo que ser abandonado. <br><br><h3>  Node.js </h3><br>  Otra opci칩n es poner Node.js u otro tiempo de ejecuci칩n, por ejemplo, Dart.  Pero que pasa? <br><br>  Hay dos formas de usar Node.js. <br>  La primera forma es delegar la representaci칩n del componente al servidor en Node.js que se ejecuta en el mismo servidor que la aplicaci칩n Java.  Por lo tanto, guardamos la aplicaci칩n en Java y solo en el proceso de renderizar HTML hacemos una llamada al servicio que se ejecuta localmente en Node.js. <br><br>  Sin embargo, hay varios problemas con este enfoque: <br><br><ol><li>  Una llamada remota a Node.js implica serializar / deserializar la entrada.  Estos datos pueden ser muy voluminosos, por ejemplo, en el caso de que un nuevo componente en JS sea un contenedor alrededor de un componente antiguo implementado en Java. </li><li>  Una llamada remota, incluso en una m치quina local, est치 lejos de ser gratuita y tambi칠n presenta un retraso adicional.  Si hay docenas o cientos de tales componentes en la p치gina, incluso los m치s simples, aumentaremos significativamente la sobrecarga y el retraso en el procesamiento de la solicitud del usuario. </li><li>  Adem치s, la operaci칩n de dicho sistema es significativamente complicada, ya que en lugar de un solo proceso necesitar칤amos tener un proceso en Java y varios procesos en Node.js.  En consecuencia, todas las operaciones se vuelven mucho m치s complicadas, por ejemplo: implementaci칩n, recopilaci칩n de indicadores operativos, an치lisis de registros, monitoreo de errores, etc. </li></ol><br>  La segunda forma de usar Node.js es colocarlo frente al servidor web en Java y usarlo para el procesamiento posterior de HTML.  En otras palabras, es un proxy que analiza HTML, encuentra componentes en JS, los dibuja y devuelve el HTML terminado al usuario.  Una opci칩n interesante, parece ser universal y bastante funcional.  Las desventajas de este enfoque son que requiere un cambio completo en toda la infraestructura, aumenta significativamente los costos generales y conlleva graves riesgos: cualquier solicitud debe pasar por Node.js, es decir, comenzaremos a depender completamente de ella.  Parece una soluci칩n demasiado cara para resolver nuestro problema. <br><br><br><br><img src="https://habrastorage.org/webt/t_/yx/s4/t_yxs4aycowstwwyyhpptcv711y.jpeg"><br><br>  Resulta que Node.js no se puede usar por los siguientes motivos: <br><br><ul><li>  La serializaci칩n / deserializaci칩n es una carga de trabajo adicional y demoras </li><li>  Node.js es otro componente en el enorme sistema distribuido de Odnoklassniki </li></ul><br>  Ya tenemos muchos especialistas que saben c칩mo "cocinar" Java, y ahora tendremos que contratar a un personal que operar치 Node.js y crear치 otra infraestructura adem치s de la existente. <br><br><h3>  JavaScript en la JVM </h3><br>  Pero, 쯤u칠 pasa si intentas ejecutar JavaScript dentro de la JVM?  Resulta que el c칩digo Java y JavaScript se ejecutar치 en un proceso e interactuar치 con un m칤nimo de sobrecarga. <br><br>  Esto reemplazar치 sin problemas las piezas de Java con JavaScript dentro de la WEB actual. <br>  Los componentes JS recibir치n datos de Java y generar치n HTML.  Podr치n trabajar isom칩rficamente en el cliente y el servidor. <br><br>  <b>Pero, 쯖칩mo ejecutar JS en la JVM?</b> <br>  Puede usar el V8 <a href="https://www.infoq.com/presentations/cloudflare-v8/">como lo hace Cloudflare</a> .  Pero este es un c칩digo binario de terceros para Java.  Por lo tanto, en la JVM no ser치 posible detectar errores dentro del V8.  Cualquier ca칤da de V8 destruir치 todo el proceso.  Como resultado, el uso de V8 aumentar치 los riesgos operativos, y esto no deber칤a permitirse. <br><br>  Hay varios tiempos de ejecuci칩n JS para la JVM: dos rinocerontes, Nashorn y Rhino (uno de Oracle, el otro de Mozilla) y GraalVM fresco. <br><br><img src="https://habrastorage.org/webt/lh/q0/pz/lhq0pzsjpcd-d8c18ebae99flcu.jpeg"><br><br>  Ventajas de JS Runtimes para JVM: <br><br><ul><li>  Todo funciona en la JVM, y tenemos mucha experiencia en esto. </li><li>  Interacci칩n gratuita de Java y JavaScript </li><li>  Tiempo de ejecuci칩n seguro </li><li>  Compilador de Java en caso de GraalVM </li></ul><br>  Adem치s, fue suficiente para comparar estos tiempos de ejecuci칩n en velocidad.  Result칩 que GraalVM est치 por delante de todos por un amplio margen: <br><br><img src="https://habrastorage.org/webt/rw/tn/fa/rwtnfafh52ttkgbukp2fbfjdess.jpeg"><br><br><h2>  쯈u칠 es GraalVM? </h2><br>  <a href="https://www.graalvm.org/">GraalVM</a> es un tiempo de ejecuci칩n de alto rendimiento que admite programas en diferentes idiomas.  Tiene un marco para escribir compiladores de lenguaje para la JVM.  Gracias a esto, se admite la ejecuci칩n de programas en Java, Kotlin, JS, Python y otros lenguajes dentro de la misma JVM. <br><br>  Puede obtener m치s informaci칩n sobre las caracter칤sticas de GraalVM en un <a href="https://www.youtube.com/watch%3Fv%3DsKS4A9I8xb8">informe de Oleg Shelaev</a> , que trabaja en Oracle Labs, donde se est치 desarrollando GraalVM.  Recomendado para ver back-end y front-end. <br><br>  GraalVM nos permite ejecutar JS para representar la interfaz de usuario en el servidor.  Como biblioteca usamos <a href="https://ru.reactjs.org/">React</a> . <br><br>  Las ventajas de tal paquete: <br><br><ul><li>  No se agregaron nuevos idiomas: todav칤a Java y JavaScript </li><li>  Gran comunidad: todos saben Reaccionar </li><li>  Umbral de entrada bajo </li><li>  Busque f치cilmente colegas en un equipo </li><li>  La operaci칩n no es complicada. </li></ul><br><h2>  Ejecutando React en GraalVM </h2><br>  Dentro de GraalVM, puede crear un Contexto, un contenedor aislado en el que el programa se ejecutar치 en el idioma invitado.  En nuestro caso, el idioma del invitado es JS: <br><br><pre><code class="java hljs">Context context = Context.create(<span class="hljs-string"><span class="hljs-string">"js"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  global   Value js = context.getBindings("js");</span></span></code> </pre> <br>  Para interactuar con el contexto, se utiliza su objeto global: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    global js.putMember("serverProxy", serverProxy); //    global Value app = js.getMember("app");</span></span></code> </pre><br>  Puede cargar el c칩digo del m칩dulo en el contexto: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Value load = js.getMember("load"); //     load.execute(pathToModule);</span></span></code> </pre><br>  O "zap-eval-it" es cualquier c칩digo all칤: <br><br><pre> <code class="java hljs">context.eval(<span class="hljs-string"><span class="hljs-string">"js"</span></span>, someCode);</code> </pre><br><img src="https://habrastorage.org/webt/nl/ku/w6/nlkuw6ihae8x0gjy2ciz3_rbbnw.jpeg"><br><br><h2>  Representaci칩n del servidor JS: concepto </h2><br>  Cree un contexto de JavaScript en la JVM y cargue el c칩digo del m칩dulo de aplicaci칩n React en 칠l.  Lanzamos de Java a JS las funciones y m칠todos necesarios.  Luego, desde este contexto, extraemos el enlace a la funci칩n JS render () de este m칩dulo, para que luego podamos llamarlo desde Java. <br><br><img src="https://habrastorage.org/webt/vx/_5/yx/vx_5yxc9yqy_4yzzuobsdo06cua.jpeg"><br><br>  Cuando el usuario solicita la p치gina, se inicia el motor de plantilla del servidor, llama a la funci칩n render () de los componentes necesarios con los datos necesarios, recibe el c칩digo HTML de ellos y se lo entrega junto con el HTML de toda la p치gina al usuario. <br><br><img src="https://habrastorage.org/webt/bn/51/-l/bn51-lrlqnt2zl53ssv3h3rusgq.jpeg"><br><br><h2>  Representaci칩n del servidor JS: implementaci칩n </h2><br>  En el motor de plantillas de servidor de Odnoklassniki, el dise침o se escribe en forma de marcado HTML.  Para distinguir las aplicaciones JS del marcado habitual, utilizamos etiquetas personalizadas. <br>  Cuando el motor de plantillas encuentra una etiqueta personalizada, se crea una tarea para representar el m칩dulo correspondiente.  Se env칤a al grupo de subprocesos, cada uno de los cuales tiene su propio contexto JS, se ejecuta en un subproceso libre, representa el componente en 칠l y se lo entrega al cliente. <br><br><img src="https://habrastorage.org/webt/mf/yg/mc/mfygmcckcz8qga5fbr9stygigjw.png"><br><br><h3>  쯇or qu칠 necesito un grupo de contexto? </h3><br>  El componente se representa sincr칩nicamente en un hilo.  En este momento, el contexto de representaci칩n JS est치 ocupado.  Por lo tanto, al crear varios contextos independientes, puede paralelizar la representaci칩n de componentes utilizando capacidades de subprocesamiento m칰ltiple de Java. <br><br><img src="https://habrastorage.org/webt/uq/oe/x6/uqoex6amlj9qbhrbjwx4pm1mpe4.jpeg"><br><br>  Las funciones de adquisici칩n de datos Java se pasan por referencia a cada contexto.  El resultado es un excelente JavaScript multiproceso en un solo proceso. <br><br>  En el pr칩ximo art칤culo describiremos c칩mo la implementaci칩n de la parte del cliente de la nueva interfaz se basa en este concepto. <br><br>  Para continuar </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480808/">https://habr.com/ru/post/480808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480798/index.html">Revisi칩n de informes de C ++ Russia Piter 2019</a></li>
<li><a href="../480800/index.html">Buscando un probador de trabajo? Prep치rese para demostrar habilidades de desarrollador</a></li>
<li><a href="../480802/index.html">Ingenier칤a del Caos, Parte 3: M칠todos y herramientas</a></li>
<li><a href="../480804/index.html">Elegir el sistema de dise침o 3D perfecto</a></li>
<li><a href="../480806/index.html">Las 5 razones principales por las que me gustan las propiedades CSS personalizadas</a></li>
<li><a href="../480810/index.html">쮺칩mo prepararse para la transformaci칩n digital? Destruye tu negocio por adelantado</a></li>
<li><a href="../480812/index.html">Nvidia RTX: la tecnolog칤a de trazado de rayos en tiempo real finalmente aparece en SOLIDWORKS Visualize</a></li>
<li><a href="../480816/index.html">Dynamics 365 y Power Platform Meetup en Lamoda - Anuncio</a></li>
<li><a href="../480822/index.html">C칩mo comenzar con Bug Bounty</a></li>
<li><a href="../480824/index.html">GHIDRA vs. IDA Pro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>