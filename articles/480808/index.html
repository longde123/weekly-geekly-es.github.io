<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏿 🧛🏿 🈲 Nueva interfaz de Odnoklassniki: lanzamiento de React en Java. Parte 1 ⬛️ 😎 ✖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Muchos han escuchado el nombre GraalVM, pero hasta ahora no todos han tenido la oportunidad de probar esta tecnología en producción. Para Odnoklassnik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nueva interfaz de Odnoklassniki: lanzamiento de React en Java. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/480808/"><img src="https://habrastorage.org/webt/-r/o9/iz/-ro9izrzg1xlvkkewuua1wqu3dg.png"><br><br>  Muchos han escuchado el nombre GraalVM, pero hasta ahora no todos han tenido la oportunidad de probar esta tecnología en producción.  Para Odnoklassniki, esta tecnología ya se ha convertido en el front-end cambiante del "Santo Grial". <br><br>  En este artículo quiero hablar sobre cómo logramos hacer amigos con Java y JavaScript, y comenzar a migrar a un gran sistema con mucho código heredado, y cómo GraalVM ayuda en el camino. <br><br>  Al momento de escribir el artículo, resultó que todo el volumen del material no se ajusta al tamaño tradicional de la HABR y si publica la publicación completa, tomará varias horas leerlo.  Por lo tanto, decidimos dividir el artículo en 2 partes. <br><br>  Desde la primera parte aprenderá sobre la historia del front-end en Odnoklassniki y se familiarizará con sus características históricas, seguirá el camino para encontrar una solución a los problemas que se han acumulado en nosotros durante los 11 años del proyecto, y al final se sumergirá en las características técnicas de la implementación del servidor de la decisión que tomamos. <br><a name="habracut"></a><br><h2>  Antecedentes </h2><br>  La primera versión de Odnoklassniki apareció hace 13 años, en 2006.  El sitio se hizo en .NET, luego no había JavaScript en el sitio, todo estaba en la representación del servidor. <br><br><img src="https://habrastorage.org/webt/dl/zv/ik/dlzvikklims5fo3osgeyr-4pbik.jpeg"><br><br>  Un año después, Odnoklassniki tenía más de un millón de usuarios.  En 2007, estos fueron números increíbles, y el sitio, incapaz de soportar la carga, comenzó a caer.  Los desarrolladores resolvieron el problema con la ayuda del proyecto One.lv, creado por la compañía letona Forticom, cuyas competencias centrales estaban en el desarrollo de Java.  Por lo tanto, Odnoklassniki, se decidió reescribir de .NET a Java. <br><br>  Con el tiempo, el proyecto se desarrolló y surgió la necesidad de nuevas soluciones para el cliente.  Por ejemplo, cuando se navega por un sitio, no se actualiza por completo, sino solo ciertas partes.  O para que, al enviar, solo se actualice el formulario y no toda la página.  Al mismo tiempo, el sitio funcionaba solo en Java. <br><br>  Para hacer esto, se les ocurrió un sistema en el que el sitio estaba marcado con bloques con nombre.  Al navegar, se realizó una solicitud al servidor, que tomó una decisión sobre lo que debería cambiarse usando este enlace, y el cliente recibió las piezas necesarias.  El motor del cliente simplemente reemplazó las partes necesarias, por lo que se implementó la dinámica del cliente.  Muy conveniente, porque toda la lógica de negocios está en el servidor.  El pequeño motor permitió a la compañía seguir escribiendo código Java para administrar el cliente. <br><br>  Por supuesto, sin JavaScript mínimo no era suficiente.  Para hacer una ventana emergente, se necesitan manipulaciones: por ejemplo, al pasar el cursor sobre una pantalla div: el bloque se colgó o se ocultó con la pantalla: ninguno. <br><br>  Pero al mismo tiempo, el contenido de la ventana emergente se solicitó al servidor, toda la lógica de negocios estaba allí y estaba en Java. <br><br><img src="https://habrastorage.org/webt/aj/0h/9i/aj0h9iklirl7jtnjfib1jwaowxo.jpeg"><br><br><h2>  2018 </h2><br>  Después de 12 años, Odnoklassniki se convirtió en un servicio gigante con más de 70 millones de usuarios.  Tenemos más de 7,000 máquinas en 4 centros de datos, y solo 600 mil solicitudes por segundo llegan al frente de OK.RU. <br><br>  El servidor frontal de Odnoklassniki continúa funcionando en Java, y la base de código de los frentes solo supera los dos millones de líneas. <br><br><img src="https://habrastorage.org/webt/ew/dg/zh/ewdgzh7z3n7pf40yqgaluttxkyk.jpeg"><br><br>  Las tecnologías implementadas en el lado del cliente tampoco se detuvieron: aparecieron muchas soluciones usando diferentes bibliotecas: GWT, jQuery, DotJs, RequireJS y muchas otras. <br><br>  En ese momento, estándares como React, Angular y Vue no eran comunes, cada desarrollador trató de encontrar la solución óptima utilizando todas las herramientas disponibles. <br><br>  Quedó claro que vivir con esto es muy difícil, porque se ha acumulado una gran cantidad de problemas: <br><br><ul><li>  Muchas bibliotecas antiguas </li><li>  No hay un marco único </li><li>  Sin isomorfismo (ya que el backend está en Java, el cliente está en JS) </li><li>  No hay una sola aplicación estructurada en el cliente </li><li>  Mala capacidad de respuesta </li><li>  Herramientas insuficientes </li><li>  Umbral de entrada alto </li></ul><br>  El mundo ya estaba en 2018 y era necesario cambiar. <br><br>  Usando todo el poder del pensamiento técnico, pensamos y formulamos cuatro requisitos básicos para resolver problemas: <br><br><ol><li>  Los compañeros de clase deben tener un código isomorfo para la interfaz de usuario.  Debido a que es imposible escribir constantemente el servidor en Java, y luego, si necesita agregar algún tipo de dinámica, juegue lo mismo en el cliente. </li><li>  Se necesita una transición suave.  Porque es imposible hacer rápidamente la segunda versión de Odnoklassniki y cambiar </li><li>  Necesariamente se necesita la representación del servidor (más sobre eso a continuación) </li><li>  La nueva solución, que funciona con la misma cantidad de hierro, no debería afectar el rendimiento y la tolerancia a fallas bajo nuestras cargas. </li></ol><br><h2>  ¿Por qué la representación del lado del servidor? </h2><br>  Odnoklassniki tiene muchos usuarios que viven lejos de Moscú y no siempre tienen una buena conexión a Internet. <br><br><img src="https://habrastorage.org/webt/55/k3/a-/55k3a-kmkkvhtrpyjsmbvtrg1j8.jpeg"><br><br>  La representación del servidor ayudará a estos usuarios a obtener contenido más rápido.  Mientras se cargan las imágenes, podrán comenzar a leer algo: <br><br><img src="https://habrastorage.org/webt/ig/ga/ww/iggawwqkjpsknbpzdtddoj3lu3c.jpeg"><br><br>  Llevamos a cabo una serie de experimentos, tratando de entender qué sucedería si algunos datos (por ejemplo, cinta) ya fueran entregados al cliente, con una expectativa.  Como resultado, resultó que esto afectó negativamente la actividad del usuario. <br><br><h2>  Cómo funciona el servidor ahora </h2><br>  El navegador realiza una solicitud al sitio OK y accede a la aplicación OK-WEB, que está completamente escrita en Java.  La aplicación sigue los datos en la API.  Entre WEB y API, se implementa el transporte binario rápido one-nio desarrollado en Odnoklassniki.  Las solicitudes se completan en menos de un milisegundo.  Puedes ver qué es por <a href="https://github.com/odnoklassniki/one-nio">separado</a> .  One-nio le permite hacer muchas consultas a bajo costo sin preocuparse por demoras. <br><br>  La API extrae los datos y los entrega a la web.  La web genera páginas HTML con un motor Java y se lo entrega al navegador. <br><br>  Todo esto lleva ahora menos de 200 ms. <br><br><img src="https://habrastorage.org/webt/px/lt/tw/pxlttwxxg5fddebl4lumank7w2e.jpeg"><br><br><h2>  Busca una solución </h2><br>  Al principio, se desarrolló el concepto de migración basado en widgets. <br><br>  Las solicitudes serán entregadas al sitio en pequeños trozos.  En el interior se escribirán en una nueva pila.  Y para el resto del sitio será solo un elemento DOM con algún tipo de comportamiento personalizado. <br><br><img src="https://habrastorage.org/webt/0a/7b/9j/0a7b9jtqv4vm1zsfpwdb93jlzpm.jpeg"><br><br>  Esto será similar a la etiqueta &lt;video&gt;: un elemento DOM personalizado con atributos, métodos y eventos.  Como resultado, la API DOM se encuentra fuera, mientras que la funcionalidad del widget se implementa dentro de la nueva pila. <br><br><h2>  ¿Qué pila elegir? </h2><br>  Ahora que era necesario implementar el concepto, comenzaron a clasificar las opciones. <br><br><h3>  Kotlin </h3><br>  El primer prototipo se hizo en Kotlin.  La idea era la siguiente: para nuevos componentes, escribir lógica en Kotlin y describir el marcado de componentes en XML.  Todo se puede ejecutar en el servidor en la JVM utilizando el motor de plantillas existente, y para el cliente se puede transponer en JavaScript. <br><br><img src="https://habrastorage.org/webt/al/il/q6/alilq6rigfkuh5jz4yuerp8kvgk.jpeg"><br><br>  Además de introducir un nuevo lenguaje con un umbral de entrada alto, Kotlin resultó tener herramientas insuficientemente desarrolladas para trabajar con JavaScript, y mucho más tendría que desarrollarse de forma independiente. <br><br>  Por lo tanto, desafortunadamente, este concepto tuvo que ser abandonado. <br><br><h3>  Node.js </h3><br>  Otra opción es poner Node.js u otro tiempo de ejecución, por ejemplo, Dart.  Pero que pasa? <br><br>  Hay dos formas de usar Node.js. <br>  La primera forma es delegar la representación del componente al servidor en Node.js que se ejecuta en el mismo servidor que la aplicación Java.  Por lo tanto, guardamos la aplicación en Java y solo en el proceso de renderizar HTML hacemos una llamada al servicio que se ejecuta localmente en Node.js. <br><br>  Sin embargo, hay varios problemas con este enfoque: <br><br><ol><li>  Una llamada remota a Node.js implica serializar / deserializar la entrada.  Estos datos pueden ser muy voluminosos, por ejemplo, en el caso de que un nuevo componente en JS sea un contenedor alrededor de un componente antiguo implementado en Java. </li><li>  Una llamada remota, incluso en una máquina local, está lejos de ser gratuita y también presenta un retraso adicional.  Si hay docenas o cientos de tales componentes en la página, incluso los más simples, aumentaremos significativamente la sobrecarga y el retraso en el procesamiento de la solicitud del usuario. </li><li>  Además, la operación de dicho sistema es significativamente complicada, ya que en lugar de un solo proceso necesitaríamos tener un proceso en Java y varios procesos en Node.js.  En consecuencia, todas las operaciones se vuelven mucho más complicadas, por ejemplo: implementación, recopilación de indicadores operativos, análisis de registros, monitoreo de errores, etc. </li></ol><br>  La segunda forma de usar Node.js es colocarlo frente al servidor web en Java y usarlo para el procesamiento posterior de HTML.  En otras palabras, es un proxy que analiza HTML, encuentra componentes en JS, los dibuja y devuelve el HTML terminado al usuario.  Una opción interesante, parece ser universal y bastante funcional.  Las desventajas de este enfoque son que requiere un cambio completo en toda la infraestructura, aumenta significativamente los costos generales y conlleva graves riesgos: cualquier solicitud debe pasar por Node.js, es decir, comenzaremos a depender completamente de ella.  Parece una solución demasiado cara para resolver nuestro problema. <br><br><br><br><img src="https://habrastorage.org/webt/t_/yx/s4/t_yxs4aycowstwwyyhpptcv711y.jpeg"><br><br>  Resulta que Node.js no se puede usar por los siguientes motivos: <br><br><ul><li>  La serialización / deserialización es una carga de trabajo adicional y demoras </li><li>  Node.js es otro componente en el enorme sistema distribuido de Odnoklassniki </li></ul><br>  Ya tenemos muchos especialistas que saben cómo "cocinar" Java, y ahora tendremos que contratar a un personal que operará Node.js y creará otra infraestructura además de la existente. <br><br><h3>  JavaScript en la JVM </h3><br>  Pero, ¿qué pasa si intentas ejecutar JavaScript dentro de la JVM?  Resulta que el código Java y JavaScript se ejecutará en un proceso e interactuará con un mínimo de sobrecarga. <br><br>  Esto reemplazará sin problemas las piezas de Java con JavaScript dentro de la WEB actual. <br>  Los componentes JS recibirán datos de Java y generarán HTML.  Podrán trabajar isomórficamente en el cliente y el servidor. <br><br>  <b>Pero, ¿cómo ejecutar JS en la JVM?</b> <br>  Puede usar el V8 <a href="https://www.infoq.com/presentations/cloudflare-v8/">como lo hace Cloudflare</a> .  Pero este es un código binario de terceros para Java.  Por lo tanto, en la JVM no será posible detectar errores dentro del V8.  Cualquier caída de V8 destruirá todo el proceso.  Como resultado, el uso de V8 aumentará los riesgos operativos, y esto no debería permitirse. <br><br>  Hay varios tiempos de ejecución JS para la JVM: dos rinocerontes, Nashorn y Rhino (uno de Oracle, el otro de Mozilla) y GraalVM fresco. <br><br><img src="https://habrastorage.org/webt/lh/q0/pz/lhq0pzsjpcd-d8c18ebae99flcu.jpeg"><br><br>  Ventajas de JS Runtimes para JVM: <br><br><ul><li>  Todo funciona en la JVM, y tenemos mucha experiencia en esto. </li><li>  Interacción gratuita de Java y JavaScript </li><li>  Tiempo de ejecución seguro </li><li>  Compilador de Java en caso de GraalVM </li></ul><br>  Además, fue suficiente para comparar estos tiempos de ejecución en velocidad.  Resultó que GraalVM está por delante de todos por un amplio margen: <br><br><img src="https://habrastorage.org/webt/rw/tn/fa/rwtnfafh52ttkgbukp2fbfjdess.jpeg"><br><br><h2>  ¿Qué es GraalVM? </h2><br>  <a href="https://www.graalvm.org/">GraalVM</a> es un tiempo de ejecución de alto rendimiento que admite programas en diferentes idiomas.  Tiene un marco para escribir compiladores de lenguaje para la JVM.  Gracias a esto, se admite la ejecución de programas en Java, Kotlin, JS, Python y otros lenguajes dentro de la misma JVM. <br><br>  Puede obtener más información sobre las características de GraalVM en un <a href="https://www.youtube.com/watch%3Fv%3DsKS4A9I8xb8">informe de Oleg Shelaev</a> , que trabaja en Oracle Labs, donde se está desarrollando GraalVM.  Recomendado para ver back-end y front-end. <br><br>  GraalVM nos permite ejecutar JS para representar la interfaz de usuario en el servidor.  Como biblioteca usamos <a href="https://ru.reactjs.org/">React</a> . <br><br>  Las ventajas de tal paquete: <br><br><ul><li>  No se agregaron nuevos idiomas: todavía Java y JavaScript </li><li>  Gran comunidad: todos saben Reaccionar </li><li>  Umbral de entrada bajo </li><li>  Busque fácilmente colegas en un equipo </li><li>  La operación no es complicada. </li></ul><br><h2>  Ejecutando React en GraalVM </h2><br>  Dentro de GraalVM, puede crear un Contexto, un contenedor aislado en el que el programa se ejecutará en el idioma invitado.  En nuestro caso, el idioma del invitado es JS: <br><br><pre><code class="java hljs">Context context = Context.create(<span class="hljs-string"><span class="hljs-string">"js"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  global   Value js = context.getBindings("js");</span></span></code> </pre> <br>  Para interactuar con el contexto, se utiliza su objeto global: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    global js.putMember("serverProxy", serverProxy); //    global Value app = js.getMember("app");</span></span></code> </pre><br>  Puede cargar el código del módulo en el contexto: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     Value load = js.getMember("load"); //     load.execute(pathToModule);</span></span></code> </pre><br>  O "zap-eval-it" es cualquier código allí: <br><br><pre> <code class="java hljs">context.eval(<span class="hljs-string"><span class="hljs-string">"js"</span></span>, someCode);</code> </pre><br><img src="https://habrastorage.org/webt/nl/ku/w6/nlkuw6ihae8x0gjy2ciz3_rbbnw.jpeg"><br><br><h2>  Representación del servidor JS: concepto </h2><br>  Cree un contexto de JavaScript en la JVM y cargue el código del módulo de aplicación React en él.  Lanzamos de Java a JS las funciones y métodos necesarios.  Luego, desde este contexto, extraemos el enlace a la función JS render () de este módulo, para que luego podamos llamarlo desde Java. <br><br><img src="https://habrastorage.org/webt/vx/_5/yx/vx_5yxc9yqy_4yzzuobsdo06cua.jpeg"><br><br>  Cuando el usuario solicita la página, se inicia el motor de plantilla del servidor, llama a la función render () de los componentes necesarios con los datos necesarios, recibe el código HTML de ellos y se lo entrega junto con el HTML de toda la página al usuario. <br><br><img src="https://habrastorage.org/webt/bn/51/-l/bn51-lrlqnt2zl53ssv3h3rusgq.jpeg"><br><br><h2>  Representación del servidor JS: implementación </h2><br>  En el motor de plantillas de servidor de Odnoklassniki, el diseño se escribe en forma de marcado HTML.  Para distinguir las aplicaciones JS del marcado habitual, utilizamos etiquetas personalizadas. <br>  Cuando el motor de plantillas encuentra una etiqueta personalizada, se crea una tarea para representar el módulo correspondiente.  Se envía al grupo de subprocesos, cada uno de los cuales tiene su propio contexto JS, se ejecuta en un subproceso libre, representa el componente en él y se lo entrega al cliente. <br><br><img src="https://habrastorage.org/webt/mf/yg/mc/mfygmcckcz8qga5fbr9stygigjw.png"><br><br><h3>  ¿Por qué necesito un grupo de contexto? </h3><br>  El componente se representa sincrónicamente en un hilo.  En este momento, el contexto de representación JS está ocupado.  Por lo tanto, al crear varios contextos independientes, puede paralelizar la representación de componentes utilizando capacidades de subprocesamiento múltiple de Java. <br><br><img src="https://habrastorage.org/webt/uq/oe/x6/uqoex6amlj9qbhrbjwx4pm1mpe4.jpeg"><br><br>  Las funciones de adquisición de datos Java se pasan por referencia a cada contexto.  El resultado es un excelente JavaScript multiproceso en un solo proceso. <br><br>  En el próximo artículo describiremos cómo la implementación de la parte del cliente de la nueva interfaz se basa en este concepto. <br><br>  Para continuar </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/480808/">https://habr.com/ru/post/480808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../480798/index.html">Revisión de informes de C ++ Russia Piter 2019</a></li>
<li><a href="../480800/index.html">Buscando un probador de trabajo? Prepárese para demostrar habilidades de desarrollador</a></li>
<li><a href="../480802/index.html">Ingeniería del Caos, Parte 3: Métodos y herramientas</a></li>
<li><a href="../480804/index.html">Elegir el sistema de diseño 3D perfecto</a></li>
<li><a href="../480806/index.html">Las 5 razones principales por las que me gustan las propiedades CSS personalizadas</a></li>
<li><a href="../480810/index.html">¿Cómo prepararse para la transformación digital? Destruye tu negocio por adelantado</a></li>
<li><a href="../480812/index.html">Nvidia RTX: la tecnología de trazado de rayos en tiempo real finalmente aparece en SOLIDWORKS Visualize</a></li>
<li><a href="../480816/index.html">Dynamics 365 y Power Platform Meetup en Lamoda - Anuncio</a></li>
<li><a href="../480822/index.html">Cómo comenzar con Bug Bounty</a></li>
<li><a href="../480824/index.html">GHIDRA vs. IDA Pro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>