<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏻 😶 ⬜️ Cara masuk NodeJS agar anak laki-laki di halaman menghormati 🌳 🐦 🤜🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang paling membuat Anda marah ketika Anda mencoba mengatur log yang dapat dibaca di aplikasi NodeJS Anda? Secara pribadi, saya sangat kesal denga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara masuk NodeJS agar anak laki-laki di halaman menghormati</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442452/"><p><img src="https://habrastorage.org/webt/5a/em/fo/5aemfoyk841-ll_xjint9es2kao.jpeg"></p><br><p>  Apa yang paling membuat Anda marah ketika Anda mencoba mengatur log yang dapat dibaca di aplikasi NodeJS Anda?  Secara pribadi, saya sangat kesal dengan kurangnya standar matang waras untuk membuat jejak ID.  Dalam artikel ini, kita akan berbicara tentang opsi untuk membuat ID jejak, mari kita lihat bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyimpanan lokal-kelanjutan atau CLS</a> bekerja pada jari kita dan memanggil kekuatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proxy</a> untuk mendapatkan semuanya dengan logger apa pun. </p><a name="habracut"></a><br><h2 id="pochemu-v-nodejs-voobsche-est-problema-s-sozdaniem-trace-id-dlya-kazhdogo-zaprosa">  Mengapa ada masalah di NodeJS dengan membuat ID jejak untuk setiap permintaan? </h2><br><p>  Di masa lalu, dulu, dulu, ketika mammoth masih hidup di bumi, semua-semua-server semuanya multi-threaded dan membuat utas baru untuk permintaan.  Dalam kerangka paradigma ini, membuat jejak ID adalah sepele, karena  ada yang namanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyimpanan thread-local atau TLS</a> , yang memungkinkan Anda untuk memasukkan ke dalam memori beberapa data yang tersedia untuk fungsi apa pun dalam aliran ini.  Pada awal memproses permintaan, Anda dapat menebus ID jejak acak, memasukkannya ke TLS dan kemudian membacanya di layanan apa pun dan melakukan sesuatu dengannya.  Masalahnya adalah ini tidak akan berfungsi di NodeJS. </p><br><p>  NodeJS adalah single-threaded (tidak cukup, mengingat penampilan pekerja, tetapi dalam kerangka masalah dengan jejak ID, pekerja tidak memainkan peran apa pun), sehingga Anda dapat melupakan TLS.  Di sini paradigma berbeda - untuk menyulap sekelompok panggilan balik yang berbeda dalam utas yang sama, dan segera setelah fungsi ingin melakukan sesuatu yang tidak sinkron, kirim permintaan asinkron ini, dan berikan waktu prosesor ke fungsi lain dalam antrian (jika Anda tertarik pada bagaimana hal ini, dengan bangga disebut Perulangan Acara bekerja) di bawah tenda, saya sarankan membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seri artikel ini</a> ).  Jika Anda berpikir tentang bagaimana NodeJS memahami panggilan balik yang akan dipanggil saat itu, Anda dapat berasumsi bahwa masing-masing dari mereka harus sesuai dengan beberapa ID.  Selain itu, NodeJS bahkan memiliki API yang menyediakan akses ke ID ini.  Kami akan menggunakannya. </p><br><p>  Pada zaman kuno, ketika mamut menjadi punah, tetapi orang-orang masih tidak tahu manfaat dari pembuangan limbah pusat, (NodeJS v0.11.11) kami memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">addAsyncListener</a> .  Berdasarkan itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Forrest Norvell</a> menciptakan implementasi pertama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyimpanan lokal-berkelanjutan atau CLS</a> .  Tapi kami tidak akan berbicara tentang cara kerjanya, karena API ini (saya sedang berbicara tentang addAsyncLustener) memesan umur yang panjang.  Dia sudah mati di NodeJS v0.12. </p><br><p>  Sebelum NodeJS 8, tidak ada cara resmi untuk melacak antrian acara asinkron.  Dan akhirnya, di versi 8, pengembang NodeJS memulihkan keadilan dan memberi kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">async_hooks API</a> .  Jika Anda ingin mempelajari lebih lanjut tentang async_hooks, saya sarankan Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> .  Berdasarkan async_hooks, refactoring dari implementasi CLS sebelumnya telah dilakukan.  Perpustakaan disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cls-doyan</a> . </p><br><h2 id="cls-pod-kapotom">  CLS di bawah tenda </h2><br><p>  Secara umum, skema operasi CLS dapat direpresentasikan sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/ix/xe/wj/ixxewjdn0xn7r5feuvgdl1vnjow.jpeg" alt="Ikhtisar CLS"></p><br><p>  Mari kita sedikit lebih detail: </p><br><ol><li>  Misalkan kita memiliki server web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Express yang</a> khas.  Pertama, buat namespace CLS baru.  Sekali dan untuk seumur hidup aplikasi. </li><li>  Kedua, kami akan membuat middleware, yang akan membuat konteks CLS kami sendiri untuk setiap permintaan. </li><li>  Ketika permintaan baru tiba, middleware ini (Fungsi # 1) dipanggil. </li><li>  Dalam fungsi ini, buat konteks CLS baru (sebagai satu opsi, Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Namespace.run</a> ).  Di Namespace.run kita melewati fungsi yang akan dieksekusi dalam lingkup konteks kita. </li><li>  CLS menambahkan konteks yang baru dibuat ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta</a> dengan konteks dengan kunci <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ID eksekusi saat ini</a> . </li><li> Setiap namespace CLS memiliki properti <code>active</code> .  CLS memberikan properti ini referensi untuk konteks kami. </li><li>  Dalam lingkup konteks, kami membuat beberapa jenis permintaan asinkron, misalnya, ke database.  Kami meneruskan panggilan balik ke driver database, yang akan dipanggil ketika permintaan selesai. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Init</a> hook asinkron <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyala</a> .  Ini menambahkan konteks saat ini ke Peta dengan konteks oleh ID async (ID dari operasi asinkron baru). </li><li>  Karena  fungsi kami tidak lagi memiliki instruksi tambahan, ia menyelesaikan eksekusi. </li><li>  Asinkron <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setelah</a> kait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berfungsi</a> untuknya.  Ini memberikan properti <code>active</code> ke namespace <code>undefined</code> (pada kenyataannya, tidak selalu, karena kita dapat memiliki beberapa konteks bersarang, tetapi untuk kasus yang paling sederhana). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghancurkan</a> kait asinkron yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyala</a> untuk operasi asinkron pertama kami.  Ini menghapus konteks dari Peta dengan konteks dengan ID async dari operasi ini (sama dengan ID eksekusi saat ini dari panggilan balik pertama). </li><li>  Permintaan dalam database selesai dan panggilan balik kedua disebut. </li><li>  Kait asinkron <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> .  ID eksekusi saat ini sama dengan ID async dari operasi kedua (permintaan basis data).  Properti <code>active</code> namespace diberikan konteks yang ditemukan di Peta dengan konteks dengan ID eksekusi saat ini.  Ini adalah konteks yang kami buat sebelumnya. </li><li>  Sekarang panggilan balik kedua dijalankan.  Semacam logika bisnis berhasil, setan menari, vodka mengalir.  Di dalam ini, kita bisa mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nilai apa pun dari konteks dengan kunci</a> .  CLS akan mencoba menemukan kunci yang diberikan dalam konteks saat ini atau mengembalikan yang <code>undefined</code> . </li><li>  Hook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">setelah</a> asinkron untuk panggilan balik ini dipicu saat selesai.  Ini mengatur properti <code>active</code> namespace menjadi <code>undefined</code> . </li><li>  Hancurkan kait asinkron yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyala</a> untuk operasi ini.  Ini menghapus konteks dari Peta dengan konteks dengan ID async dari operasi ini (sama dengan ID eksekusi saat ini dari callback kedua). </li><li>  Pengumpul sampah (GC) membebaskan memori yang terkait dengan objek konteks, karena  dalam aplikasi kami tidak ada lagi tautan ke sana. </li></ol><br><p>  Ini adalah pandangan yang disederhanakan dari apa yang terjadi di bawah tenda, tetapi mencakup fase dan langkah utama.  Jika Anda memiliki keinginan untuk menggali lebih dalam, saya sarankan Anda membiasakan diri dengan <a href="">jenis</a> - <a href="">jenis itu</a> .  Hanya ada 500 baris kode. </p><br><h2 id="sozdanie-trace-id">  Buat jejak ID </h2><br><p>  Jadi, setelah berurusan dengan CLS, kami akan mencoba menggunakan hal ini untuk kepentingan kemanusiaan.  Mari kita membuat middleware, yang untuk setiap permintaan membuat konteks CLS sendiri, membuat ID jejak acak dan menambahkannya ke konteks menggunakan <code>traceID</code> kunci.  Kemudian di dalam ofigilliard pengendali dan layanan kami, kami mendapatkan ID jejak ini. </p><br><p>  Untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekspres,</a> middleware serupa mungkin terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cls-hooked'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uuidv4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsNamespace = cls.createNamespace(<span class="hljs-string"><span class="hljs-string">'app'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsMiddleware = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// req  res -  event emitters.      CLS     clsNamespace.bind(req) clsNamespace.bind(res) const traceID = uuidv4() clsNamespace.run(() =&gt; { clsNamespace.set('traceID', traceID) next() }) }</span></span></code> </pre> <br><p>  Dan di pengontrol atau layanan kami, kami bisa mendapatkan traceID ini hanya dalam satu baris kode: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traceID = clsNamespace.get(<span class="hljs-string"><span class="hljs-string">'traceID'</span></span>) }</code> </pre> <br><p>  Benar, tanpa menambahkan jejak ID ini ke log, itu manfaat dari itu, seperti dari peniup salju di musim panas. </p><br><p>  Mari kita menulis formatter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">winston</a> sederhana yang akan menambahkan jejak ID secara otomatis. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { createLogger, format, transports } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'winston'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addTraceId = printf(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">info</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = info.message <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> traceID = clsNamespace.get(<span class="hljs-string"><span class="hljs-string">'taceID'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (traceID) { message = <span class="hljs-string"><span class="hljs-string">`[TraceID: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${traceID}</span></span></span><span class="hljs-string">]: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> message }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = createLogger({ <span class="hljs-attr"><span class="hljs-attr">format</span></span>: addTraceId, <span class="hljs-attr"><span class="hljs-attr">transports</span></span>: [<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> transports.Console()], })</code> </pre> <br><p>  Dan jika semua penebang mendukung formatter kustom dalam bentuk fungsi (banyak dari mereka memiliki alasan untuk tidak melakukan ini), maka artikel ini mungkin tidak akan terjadi.  Jadi bagaimana Anda bisa menambahkan jejak jejak ke log dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pino yang</a> dipuja? </p><br><h2 id="vzyvaem-k-proxyhttpsdevelopermozillaorgen-usdocswebjavascriptreferenceglobal_objectsproxy-daby-podruzhit-lyuboy-loger-i-cls">  Kami memanggil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proxy</a> untuk mendapatkan teman logger dan CLS APAPUN </h2><br><p>  Beberapa kata tentang Proxy sendiri: ini adalah sesuatu yang membungkus objek asli kita dan memungkinkan kita untuk mendefinisikan kembali perilakunya dalam situasi tertentu.  Dalam daftar terbatas situasi yang didefinisikan secara ketat (dalam sains mereka disebut <code>traps</code> ).  Anda dapat menemukan daftar lengkapnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , kami hanya tertarik pada jebakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">get</a> .  Ini memberi kita kesempatan untuk mengganti nilai kembali saat mengakses properti objek, mis.  jika kita mengambil objek <code>const a = { prop: 1 }</code> dan membungkusnya dalam Proxy, maka dengan bantuan trap kita dapat mengembalikan semua yang kita suka ketika mengakses <code>a.prop</code> . </p><br><p>  Dalam kasus <code>pino</code> idenya adalah ini: kita membuat ID jejak acak untuk setiap permintaan, membuat <a href="">instance anak pino di</a> mana kita melewati ID jejak ini, dan menempatkan instance anak ini di CLS.  Kemudian kami membungkus logger sumber kami di Proxy, yang akan menggunakan turunan turunan yang sama ini untuk mencatat jika ada konteks aktif dan ada logger turunan di dalamnya, atau menggunakan logger asli. </p><br><p>  Untuk kasus seperti itu, proksi akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pino = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'pino'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = pino() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> loggerCls = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(logger, { get(target, property, receiver) { <span class="hljs-comment"><span class="hljs-comment">//    CLS  ,   target = clsNamespace.get('loggerCls') || target return Reflect.get(target, property, receiver) }, })</span></span></code> </pre> <br><p>  Middleware kami akan terlihat seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cls = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'cls-hooked'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uuidv4 = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'uuid/v4'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> clsMiddleware = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// req  res -  event emitters.      CLS     clsNamespace.bind(req) clsNamespace.bind(res) const traceID = uuidv4() const loggerWithTraceId = logger.child({ traceID }) clsNamespace.run(() =&gt; { clsNamespace.set('loggerCls', loggerWithTraceId) next() }) }</span></span></code> </pre> <br><p>  Dan kita bisa menggunakan logger seperti ini: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> controller = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res, next</span></span></span><span class="hljs-function">) =&gt;</span></span> { loggerCls.info(<span class="hljs-string"><span class="hljs-string">'Long live rocknroll!'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  // {"level":30,"time":1551385666046,"msg":"Long live rocknroll!","pid":25,"hostname":"eb6a6c70f5c4","traceID":"9ba393f0-ec8c-4396-8092-b7e4b6f375b5","v":1} }</span></span></code> </pre> <br><h2 id="cls-proxifyhttpsgithubcomkeenondrumscls-proxify">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cls-proxify</a> </h2><br><p>  Berdasarkan ide di atas, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan kecil cls-proxify</a> telah dibuat.  Dia bekerja di luar kotak dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">express</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">koa</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fastify</a> .  Selain membuat jebakan untuk <code>get</code> , itu membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jebakan lain</a> untuk memberi pengembang lebih banyak kebebasan.  Karena itu, kita dapat menggunakan Proxy untuk membungkus fungsi, kelas, dan banyak lagi.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ada demo langsung tentang cara mengintegrasikan pino dan fastify, pino dan express</a> . </p><br><p>  Saya harap Anda tidak membuang waktu dengan sia-sia, dan artikel itu setidaknya sedikit bermanfaat bagi Anda.  Tolong tendang dan kritik.  Kami akan belajar kode lebih baik bersama. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id442452/">https://habr.com/ru/post/id442452/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id442442/index.html">Insinyur Senior dalam mencari pekerjaan. Tentang tugas di wawancara teknis dan pertanyaan teoritis</a></li>
<li><a href="../id442444/index.html">Mitos fisika populer modern</a></li>
<li><a href="../id442446/index.html">Transformasi digital pada contoh Call center bisnis apa pun</a></li>
<li><a href="../id442448/index.html">Pola konkurensi dan kesalahan disembunyikan dalam kode: Deadlock</a></li>
<li><a href="../id442450/index.html">Blockchain dan data medis: cara kerjanya</a></li>
<li><a href="../id442454/index.html">Magic Leap berencana untuk melengkapi dunia nyata dengan lapisan digital</a></li>
<li><a href="../id442456/index.html">Bagaimana cara menyimpan sumber daya di browser dan tidak merusak web. Laporan Yandex</a></li>
<li><a href="../id442458/index.html">Jurang atau jalur buatan manusia dari pilot RPA ke implementasi di seluruh perusahaan</a></li>
<li><a href="../id442460/index.html">Membantu Penyedia Queryable memilah string interpolasi</a></li>
<li><a href="../id442462/index.html">Kesalahan umum ketika bekerja dengan PostgreSQL. Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>