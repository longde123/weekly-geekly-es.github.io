<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›ŒğŸ¼ ğŸ‘ƒğŸ» ğŸ¤³ğŸ¿ Menggunakan partisi di MySQL untuk Zabbix dengan sejumlah besar objek pemantauan ğŸ‘½ â˜ï¸ ğŸ’ªğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk memantau server dan layanan, kami telah lama, dan masih berhasil, menggunakan solusi gabungan berdasarkan Nagios dan Munin. Namun, banyak ini me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan partisi di MySQL untuk Zabbix dengan sejumlah besar objek pemantauan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lenvendo/blog/480082/">  Untuk memantau server dan layanan, kami telah lama, dan masih berhasil, menggunakan solusi gabungan berdasarkan Nagios dan Munin.  Namun, banyak ini memiliki sejumlah kelemahan, jadi kami, seperti banyak orang, secara aktif mengeksploitasi <a href="https://www.zabbix.com/">Zabbix</a> .  Pada artikel ini, kita akan berbicara tentang bagaimana Anda dapat memecahkan masalah kinerja dengan upaya minimal ketika meningkatkan jumlah metrik yang dilepas dan meningkatkan volume basis data MySQL <br><a name="habracut"></a><br><h3>  Masalah menggunakan database MySQL dengan Zabbix </h3><br>  Meskipun basis datanya kecil dan jumlah metrik yang tersimpan di dalamnya kecil, semuanya indah.  Proses pembantu rumah tangga biasa yang memulai Zabbix Server sendiri berhasil menghapus catatan usang dari basis data, mencegahnya berkembang.  Namun, segera setelah jumlah metrik yang ditangkap meningkat dan ukuran basis data mencapai ukuran tertentu, semuanya menjadi lebih buruk.  Houserkeeper berhenti mengelola untuk menghapus data untuk interval waktu yang ditentukan, data lama mulai tetap berada di database.  Selama operasi pengurus rumah tangga ada peningkatan beban pada Server Zabbix, yang bisa bertahan lama.  Menjadi jelas bahwa itu perlu untuk entah bagaimana menyelesaikan situasi saat ini. <br><br>  Ini adalah masalah yang diketahui, hampir semua orang yang bekerja dengan pemantauan Zabbix dalam jumlah besar menghadapi hal yang sama.  Ada beberapa solusi juga: misalnya, mengganti MySQL dengan PostgreSQL atau bahkan Elasticsearch, tetapi solusi paling sederhana dan paling terbukti adalah beralih ke tabel partisi yang menyimpan data metrik dalam database MySQL.  Kami memutuskan untuk pergi dengan cara ini. <br><br><h3>  Bermigrasi dari tabel MySQL biasa ke yang dipartisi </h3><br>  Zabbix didokumentasikan dengan baik dan tabel tempat menyimpan metrik diketahui.  Ini adalah tabel: <code>history</code> , tempat nilai float disimpan, <code>history_str</code> , tempat nilai string pendek disimpan, <code>history_text</code> , tempat nilai teks yang panjang disimpan, dan <code>history_uint</code> , tempat nilai integer disimpan.  Ada juga tabel <code>trends</code> yang menyimpan dinamika perubahan, tetapi kami memutuskan untuk tidak menyentuhnya, karena ukurannya kecil dan sedikit kemudian kami akan kembali ke sana. <br><br>  Secara umum, tabel apa yang perlu diproses jelas.  Kami memutuskan untuk membuat partisi untuk setiap minggu, dengan pengecualian yang terakhir, berdasarkan pada jumlah bulan, mis.  empat partisi per bulan: dari 1 ke 7, dari 8 ke 14, dari 15 ke 21 dan dari 22 ke 1 (bulan berikutnya).  Kesulitannya adalah bahwa kami harus mengubah tabel yang kami butuhkan menjadi dipartisi "on the fly," tanpa mengganggu Zabbix Server dan mengumpulkan metrik. <br><br>  Anehnya, struktur tabel-tabel ini sangat membantu kami dalam hal ini.  Misalnya, tabel <code>history</code> memiliki struktur berikut: <br><br><pre> <code class="sql hljs">`itemid` bigint(20) unsigned NOT NULL, `clock` int(11) NOT NULL DEFAULT '0', `value` double(16,4) NOT NULL DEFAULT '0.0000', `ns` int(11) NOT NULL DEFAULT '0',</code> </pre> <br>  sementara <br><br><pre> <code class="sql hljs">KEY `history_1` (`itemid`,`clock`)</code> </pre> <br>  Seperti yang Anda lihat, setiap metrik akhirnya dimasukkan ke dalam tabel dengan dua bidang yang sangat penting dan nyaman bagi kami <b>itemid</b> dan <b>jam</b> .  Dengan demikian, kita bisa membuat tabel sementara, misalnya, dengan nama <code>history_tmp</code> , mengatur <code>history_tmp</code> untuk itu dan kemudian mentransfer semua data dari tabel <code>history</code> sana, dan kemudian mengganti nama tabel <code>history</code> ke <code>history_old</code> , dan tabel <code>history_tmp</code> ke <code>history</code> , kemudian menambahkan data yang kami kurang isi dari <code>history_old</code> ke <code>history</code> dan hapus <code>history_old</code> .  Anda dapat melakukan ini sepenuhnya dengan aman, kami tidak akan kehilangan apa-apa, karena bidang <b>itemid</b> dan <b>jam yang</b> ditunjukkan di atas memberikan metrik tautan ke waktu tertentu, dan bukan ke semacam nomor seri. <br><br><h3>  Prosedur transisi itu sendiri </h3><br><blockquote>  Perhatian!  Sebelum memulai tindakan apa pun, sangat diinginkan untuk membuat cadangan lengkap dari basis data.  Kita semua adalah orang yang hidup dan dapat membuat kesalahan dalam serangkaian perintah, yang dapat menyebabkan hilangnya data.  Ya  salinan cadangan tidak akan memberikan relevansi maksimum, tetapi lebih baik memilikinya daripada tidak sama sekali. </blockquote>  Jadi, jangan mematikan atau menghentikan apa pun.  Yang utama adalah bahwa pada server MySQL itu sendiri harus ada ruang disk kosong yang cukup, mis.  sehingga untuk masing-masing tabel di atas <code>history</code> , <code>history_text</code> , <code>history_str</code> , <code>history_uint</code> , setidaknya, ada cukup ruang untuk membuat tabel dengan akhiran "_tmp", mengingat bahwa itu akan menjadi jumlah yang sama dengan tabel asli. <br><br>  Kami tidak akan menjelaskan semuanya beberapa kali untuk masing-masing tabel di atas dan mempertimbangkan semuanya dengan contoh hanya satu di antaranya - tabel <code>history</code> . <br><br>  Jadi, buat tabel <code>history_tmp</code> kosong berdasarkan pada struktur tabel <code>history</code> . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span>;</code> </pre> <br>  Kami membuat partisi yang kami butuhkan.  Sebagai contoh, mari kita lakukan selama sebulan.  Setiap partisi dibuat berdasarkan aturan partisi, berdasarkan nilai bidang <b>jam</b> , yang kami bandingkan dengan cap waktu: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RANGE</span></span>( clock ) ( <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190201 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-01 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190207 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-07 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190214 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-14 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190221 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-02-21 00:00:00"</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190301 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-03-01 00:00:00"</span></span>)) );</code> </pre> <br>  Operator ini menambahkan pemartisian ke tabel <code>history_tmp</code> kami buat.  Mari kita perjelas bahwa data yang nilai bidang <b>jamnya</b> kurang dari "2019-02-01 00:00:00" akan jatuh ke dalam partisi <i>p20190201</i> , maka data yang nilai bidang bidang <b>jamnya</b> lebih besar dari "2019-02-01 00:00:00" tetapi kurang "2019-02-07 00:00:00" akan jatuh ke <i>p20190207</i> pihak dan sebagainya. <br><blockquote>  <b>Catatan penting:</b> Dan apa yang terjadi jika kita memiliki data di tabel dipartisi di mana nilai bidang jam lebih besar atau sama dengan "2019-03-01 00:00:00"?  Karena tidak ada partisi yang cocok untuk data ini, mereka tidak akan jatuh ke dalam tabel dan akan hilang.  Oleh karena itu, Anda tidak boleh lupa untuk membuat partisi tambahan secara tepat waktu, untuk menghindari kehilangan data seperti itu (tentang yang di bawah ini). </blockquote>  Jadi, meja sementara disiapkan.  Isi data.  Prosesnya bisa memakan waktu yang cukup lama, tetapi untungnya itu tidak memblokir permintaan lain, jadi Anda hanya harus bersabar: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history;</code> </pre> <br>  Kata kunci IGNORE tidak diperlukan selama pengisian awal, karena masih belum ada data dalam tabel, namun, Anda akan membutuhkannya saat menambahkan data.  Selain itu, mungkin berguna jika Anda harus menghentikan proses ini dan mulai lagi saat mengisi data. <br><br>  Jadi, setelah beberapa waktu (mungkin bahkan beberapa jam), unggahan data pertama telah berlalu.  Seperti yang Anda pahami, sekarang tabel <code>history_tmp</code> tidak berisi semua data dari tabel <code>history</code> , tetapi hanya data yang ada di dalamnya pada saat kueri dimulai.  Di sini, pada kenyataannya, Anda punya pilihan: apakah kami membuat satu pass lagi (jika proses pengisian berlangsung lama), atau kami segera melanjutkan untuk mengubah nama tabel yang disebutkan di atas.  Pertama, mari kita ambil lintasan kedua.  Pertama, kita perlu memahami waktu dari catatan yang dimasukkan terakhir di <code>history_tmp</code> : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(clock) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_tmp;</code> </pre> <br>  Misalkan Anda menerima: <b>1551045645</b> .  Sekarang kita menggunakan nilai yang diperoleh di pass kedua dari pengisian data: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history_tmp`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> clock&gt;=<span class="hljs-number"><span class="hljs-number">1551045645</span></span>;</code> </pre> <br>  Perikop ini seharusnya berakhir lebih cepat.  Tetapi jika oper pertama dilakukan berjam-jam, dan yang kedua juga dilakukan untuk waktu yang lama, mungkin benar untuk membuat oper ketiga, yang dilakukan benar-benar mirip dengan yang kedua. <br><br>  Pada akhirnya, kami kembali melakukan operasi untuk mendapatkan waktu penyisipan terakhir catatan di <code>history_tmp</code> dengan melakukan: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(clock) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_tmp;</code> </pre> <br>  Katakanlah Anda mendapat <b>1551085645</b> .  Simpan nilai ini - kita akan membutuhkannya untuk diisi ulang. <br><br>  Dan sekarang, sebenarnya, ketika data primer yang mengisi <code>history_tmp</code> selesai, kami melanjutkan untuk mengubah nama tabel: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> history_old; <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history_tmp <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> history; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br>  Kami merancang blok ini sebagai satu transaksi untuk menghindari momen memasukkan data ke dalam tabel yang tidak ada, karena setelah RENAME pertama hingga RENAME kedua dijalankan, tabel <code>history</code> tidak akan ada.  Tetapi bahkan jika beberapa data tiba antara operasi RENAME di tabel <code>history</code> dan tabel itu sendiri belum ada (karena penggantian nama), kami akan mendapatkan sejumlah kecil kesalahan penyisipan yang dapat diabaikan (kami memiliki pemantauan, bukan bank). <br><br>  Sekarang kita memiliki tabel <code>history</code> baru dengan partisi, tetapi tidak memiliki cukup data yang diterima selama pass terakhir memasukkan data ke dalam tabel <code>history_tmp</code> .  Tetapi kami memiliki data ini di tabel <code>history_old</code> dan sekarang kami membagikannya dari sana.  Untuk ini, kita akan membutuhkan nilai yang disimpan sebelumnya 1551085645. Mengapa kita menyimpan nilai ini dan tidak menggunakan waktu pengisian maksimum sudah dari tabel <code>history</code> saat ini?  Karena data baru sudah masuk ke dalamnya dan kami akan mendapatkan waktu yang salah.  Jadi, kami mengukur data: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IGNORE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> history_old <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> clock&gt;=<span class="hljs-number"><span class="hljs-number">1551045645</span></span>;</code> </pre> <br>  Setelah akhir operasi ini, kita memiliki di tabel <code>history</code> baru yang dipartisi semua data yang lama, ditambah data yang datang setelah tabel diganti nama.  Tabel <code>history_old</code> tidak lagi diperlukan.  Anda dapat segera menghapusnya, atau membuat salinan cadangannya (jika Anda menderita paranoia) sebelum menghapusnya. <br><br>  Seluruh proses yang dijelaskan di atas perlu diulang untuk <code>history_uint</code> <code>history_str</code> , <code>history_text</code> dan <code>history_uint</code> . <br><br><h3>  Apa yang perlu diperbaiki dalam pengaturan Server Zabbix </h3><br>  Sekarang pemeliharaan database tentang sejarah data berada di pundak kami.  Ini berarti bahwa Zabbix tidak boleh lagi menghapus data lama - kami akan melakukannya sendiri.  Agar Server Zabbix tidak mencoba untuk membersihkan data itu sendiri, Anda harus pergi ke antarmuka web Zabbix, pilih "Administrasi" di menu, lalu submenu "Umum", lalu pilih "Hapus riwayat" pada daftar drop-down di sebelah kanan.  Pada halaman yang muncul, hapus centang semua kotak centang untuk grup "Riwayat" dan klik tombol "Perbarui".  Ini akan mencegah meja-meja <code>history*</code> tidak dibersihkan oleh kami melalui pembantu rumah tangga. <br><br>  Perhatikan halaman yang sama dengan grup â€œDinamika perubahanâ€.  Ini hanya tabel <code>trends</code> , yang kami janjikan untuk kembali.  Jika itu juga menjadi terlalu besar untuk Anda dan perlu dipartisi, hapus centang grup ini juga dan kemudian proses tabel ini persis seperti yang dilakukan untuk tabel <code>history*</code> . <br><br><h3>  Pemeliharaan basis data lebih lanjut </h3><br>  Seperti yang telah ditulis sebelumnya, untuk operasi normal pada tabel dipartisi, perlu membuat partisi dalam waktu.  Anda dapat melakukan ini seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`history`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190307 <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LESS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THAN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">UNIX_TIMESTAMP</span></span>(<span class="hljs-string"><span class="hljs-string">"2019-03-07 00:00:00"</span></span>)));</code> </pre> <br>  Selain itu, karena kami membuat tabel dipartisi dan melarang Zabbix Server untuk membersihkannya, menghapus data lama sekarang menjadi perhatian kami.  Untungnya, tidak ada masalah sama sekali.  Ini dilakukan hanya dengan menghapus partisi yang datanya tidak lagi kita perlukan. <br><br>  Sebagai contoh: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> history <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> p20190201;</code> </pre> <br>  Tidak seperti pernyataan DELETE FROM dengan rentang tanggal, DROP PARTITION dilakukan dalam beberapa detik, tidak memuat server sama sekali dan berfungsi dengan lancar saat menggunakan replikasi di MySQL. <br><br><h3>  Kesimpulan </h3><br>  Solusi yang dijelaskan sudah teruji oleh waktu.  Volume data tumbuh, tetapi tidak ada penurunan kinerja yang nyata. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480082/">https://habr.com/ru/post/id480082/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480070/index.html">Bereaksi manfaat: Sebuah berkah untuk Bisnis?</a></li>
<li><a href="../id480072/index.html">Kubernetes: mengapa begitu penting untuk mengatur manajemen sumber daya sistem?</a></li>
<li><a href="../id480076/index.html">Proses ganda dan rekonsiliasi data dari berbagai sumber</a></li>
<li><a href="../id480078/index.html">Perpustakaan front-end baru di React peripherals</a></li>
<li><a href="../id480080/index.html">Apa yang Anda butuhkan dalam mencatat aplikasi?</a></li>
<li><a href="../id480086/index.html">Cara mematuhi persyaratan 152-FZ, melindungi data pribadi pelanggan kami dan tidak menginjak kami</a></li>
<li><a href="../id480088/index.html">DevOps - OK, tapi apa yang harus dilakukan? Cara mengurangi tenaga kerja manual dan mencapai hasil yang diinginkan</a></li>
<li><a href="../id480090/index.html">Sumber terbuka adalah segalanya</a></li>
<li><a href="../id480092/index.html">Cara mengatasi masalah pengenalan audio di GO</a></li>
<li><a href="../id480096/index.html">Akhir masa kanak-kanak: hak cipta atas karya yang dibuat oleh kecerdasan buatan (AI)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>