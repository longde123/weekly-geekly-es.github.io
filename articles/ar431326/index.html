<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐎 🕠 💽 كشف الحواف في الوقت الحقيقي باستخدام FPGA 👨🏾‍🎨 ☝🏼 🧑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مقدمة 


 يطبق مشروعنا نظامًا للكشف عن الحواف في الوقت الفعلي استنادًا إلى التقاط إطارات الصور من كاميرا OV7670 وتدفقها إلى شاشة VGA بعد تطبيق مرشح در...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>كشف الحواف في الوقت الحقيقي باستخدام FPGA</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431326/" style=";text-align:right;direction:rtl"><h2 id="introduction" style=";text-align:right;direction:rtl">  مقدمة </h2><br><p style=";text-align:right;direction:rtl">  يطبق مشروعنا نظامًا للكشف عن الحواف في الوقت الفعلي استنادًا إلى التقاط إطارات الصور من كاميرا OV7670 وتدفقها إلى شاشة VGA بعد تطبيق مرشح درجات الرمادي ومشغل Sobel.  تم تصميمنا على لوحة Cyclone IV FPGA التي تمكننا من تحسين الأداء باستخدام الميزات القوية للأجهزة ذات المستوى المنخفض والحسابات المتوازية ، وهو أمر مهم لتلبية متطلبات النظام في الوقت الفعلي. </p><br><p style=";text-align:right;direction:rtl">  استخدمنا لوحة تطوير ZEOWAA FPGA التي تستند إلى Cyclone IV (EP4CE6E22C8N).  أيضًا ، استخدمنا Quartus Prime Lite Edition كبيئة تطوير و Verilog HDL كلغة برمجة.  بالإضافة إلى ذلك ، استخدمنا واجهة VGA المدمجة لتشغيل شاشة VGA ، و GPIO (دبابيس عامة للإدخال والإخراج) لتوصيل الأجهزة الخارجية بلوحنا. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/j4/0g/l0/j40gl0a_funpi7k3om89bkjy2xc.png" alt="ZEOWAA FPGA مجلس التنمية"></p><a name="habracut"></a><br><h2 id="architecture" style=";text-align:right;direction:rtl">  العمارة </h2><br><p style=";text-align:right;direction:rtl">  ينقسم تصميمنا إلى 3 أجزاء رئيسية: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  قراءة وحدات بكسل البيانات من الكاميرا. </li><li style=";text-align:right;direction:rtl">  تنفيذ خوارزمية الكشف عن الحواف (محول درجات الرمادي ومشغل سوبل). </li><li style=";text-align:right;direction:rtl">  عرض الصورة النهائية من خلال التواصل مع شاشة VGA. </li></ol><br><p style=";text-align:right;direction:rtl">  أيضا ، هناك تخزين متوسط ​​للذاكرة بين قراءة / كتابة البيانات والعمل على هذه البيانات.  لهذا الغرض ، قمنا بتنفيذ اثنين من المخازن المؤقتة التي تعمل كمساحة مؤقتة للبكسل قبل استخدامها. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/-m/ra/4n/-mra4ni51g8heajqfmzauskcbtu.jpeg" alt="العمارة المنفذة"></p><br><p style=";text-align:right;direction:rtl">  لاحظ أننا بعد أن أخذنا البكسل من الكاميرا ، لم نخزنها مباشرة في ذاكرة التخزين المؤقت المتوسطة.  بدلاً من ذلك ، قمنا بتحويله إلى التدرج الرمادي ثم قمنا بتخزينه في المخزن المؤقت.  وذلك لأن تخزين وحدات البكسل الرمادية 8 بت يستغرق ذاكرة أقل من تخزين وحدات البكسل الملونة التي تبلغ 16 بت.  أيضا ، لدينا مخزن مؤقت آخر يقوم بتخزين البيانات بعد تطبيق مشغل Sobel لجعلها جاهزة للعرض على الشاشة. </p><br><p style=";text-align:right;direction:rtl">  فيما يلي تفاصيل حول تنفيذ بنيتنا: </p><cut></cut><br><h5 id="camera" style=";text-align:right;direction:rtl">  الكاميرا </h5><br><p style=";text-align:right;direction:rtl">  استخدمنا كاميرا OV7670 وهي واحدة من أرخص وحدات الكاميرا التي وجدناها.  أيضًا ، يمكن أن تعمل هذه الكاميرا على 3.3V ولا تحتاج إلى بروتوكولات اتصال صعبة مثل I2c أو SPI لاستخراج بيانات الصورة.  يتطلب فقط واجهة SCCB التي تشبه واجهة I2c لتعيين تكوين الكاميرا من حيث تنسيق الألوان (RGB565 ، RGB555 ، YUV ، YCbCr 4: 2: 2) ، الدقة (VGA ، QVGA ، QQVGA ، CIF ، QCIF) والعديد من الإعدادات الأخرى. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/hj/47/uk/hj47ukzo4cqixn0tyzwegoerumg.jpeg" alt="وحدة الكاميرا OV7670"></p><br><p style=";text-align:right;direction:rtl">  يتكون الفيديو من إطارات يتم تغييرها بمعدل معين.  إطار واحد هو صورة تتكون من صفوف وأعمدة بكسل حيث يتم تمثيل كل بكسل بقيم اللون.  في هذا المشروع ، استخدمنا التكوين الافتراضي للكاميرا حيث حجم الإطار هو دقة VGA 640 × 480 (0.3 ميجابكسل) ، وتنسيق ألوان البكسل هو RGB565 (5 بت للأحمر ، 6 بت للأزرق ، 5 بت للأخضر ) ومعدل تغيير الإطارات هو 30 إطارًا في الثانية. </p><br><p style=";text-align:right;direction:rtl">  في الأسفل ، توصيلات الكاميرا بـ FPGA باستخدام GPIO الموجود في لوحة التطوير: </p><br><table style=";text-align:right;direction:rtl"><thead><tr><th>  ثبّت الكاميرا </th><th>  دبوس في FPGA </th><th>  الوصف </th><th>  ثبّت الكاميرا </th><th>  دبوس في FPGA </th><th>  الوصف </th></tr></thead><tbody><tr><td>  3.3 فولت </td><td>  3.3 فولت </td><td>  التيار الكهربائي (+) </td><td>  GND </td><td>  GND </td><td>  مستوى الإمداد الأرضي (-) </td></tr><tr><td>  Sdioc </td><td>  GND </td><td>  ساعة SCCB </td><td>  SDIOD </td><td>  GND </td><td>  بيانات SCCB </td></tr><tr><td>  VSYNC </td><td>  ص 31 </td><td>  التزامن العمودي </td><td>  Href </td><td>  ص 55 </td><td>  التزامن الأفقي </td></tr><tr><td>  PCLK </td><td>  ص 23 </td><td>  ساعة بكسل </td><td>  Xclk </td><td>  ص 54 </td><td>  ساعة نظام الإدخال (25 ميجا هرتز) </td></tr><tr><td>  د 7 </td><td>  ص 46 </td><td>  8 بت البيانات </td><td>  د 6 </td><td>  ص 44 </td><td>  الجزء السابع من البيانات </td></tr><tr><td>  د 5 </td><td>  ص 43 </td><td>  الجزء السادس من البيانات </td><td>  د 4 </td><td>  ص 42 </td><td>  الجزء الخامس من البيانات </td></tr><tr><td>  د 3 </td><td>  ص 39 </td><td>  4 بت البيانات </td><td>  د 2 </td><td>  ص 38 </td><td>  3 بت من البيانات </td></tr><tr><td>  د 1 </td><td>  ص 34 </td><td>  الجزء الثاني من البيانات </td><td>  د 0 </td><td>  ص 33 </td><td>  الجزء الأول من البيانات </td></tr><tr><td>  RESET (نشط منخفض) </td><td>  3.3 فولت </td><td>  إعادة تعيين دبوس </td><td>  PWDN </td><td>  GND </td><td>  دبوس الطاقة لأسفل </td></tr></tbody></table><br><p style=";text-align:right;direction:rtl">  لاحظ أننا لم نستخدم واجهة SCCB للتكوين.  لذا ، نضع الأسلاك المقابلة على الأرض لمنع أي إشارات عائمة يمكن أن تؤثر على البيانات. </p><br><p style=";text-align:right;direction:rtl">  لتوفير ساعة 25 ميجاهرتز للكاميرا ، استخدمنا حلقة قفل الطور (PLL) وهو نظام التحكم في التردد ذي الحلقة المغلقة لتوفير الساعة المطلوبة من 50 ميجاهرتز المقدمة من اللوحة.  لتنفيذ PLL ، استخدمنا أداة كتالوج IP الداخلية داخل برنامج Quartus. </p><cut></cut><br><p style=";text-align:right;direction:rtl">  تستخدم هذه الكاميرا إشارة التزامن العمودي (VSYNC) للتحكم في عملية إرسال الإطار وإشارة التزامن الأفقي (HREF) للتحكم في إرسال كل صف من الإطار.  تستخدم هذه الكاميرا 8 أسطر فقط من البيانات (D0-D7) لنقل البتات التي تمثل قيم ألوان البكسل حيث تقوم الكاميرا بتقسيم قيمة RGB 16 بت إلى جزأين (8 بت) وإرسال كل واحد على حدة. </p><br><p style=";text-align:right;direction:rtl">  توضح الأشكال التالية من ورقة البيانات لوحدة الكاميرا OV7670 إشارات التزامن الرأسي والأفقي. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/vu/9-/nr/vu9-nr2blv5dnrfezs1dsuja8ns.png" alt="توقيت إطار VGA"></p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/q8/bb/nj/q8bbnji2ajbs3nxklpstw55mip8.png" alt="توقيت أفقي"></p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/sr/qt/5n/srqt5n3eoriiopfeq0icnpnf4z0.png" alt="رسم تخطيطي لتوقيت إخراج RGB565"></p><br><h5 id="grayscale-converter" style=";text-align:right;direction:rtl">  محول درجات الرمادي </h5><br><p style=";text-align:right;direction:rtl">  لإنتاج صورة رمادية من صورتها الملونة الأصلية ، يجب مراعاة العديد من العوامل ، لأن الصورة قد تفقد التباين والحدة والظل والهيكل.  علاوة على ذلك ، يجب أن تحتفظ الصورة بالإضاءة النسبية لمساحة اللون.  يتم استخدام العديد من التقنيات الخطية وغير الخطية لتحويل الصورة الملونة إلى درجات رمادية.  وفقًا لذلك ، لتحقيق هدفنا ، استخدمنا التحويل اللوني (الحفاظ على النصوع الإدراكي) إلى التدرج الرمادي في المعادلة التالية: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/xo/na/bk/xonabkl8jpwg5zixxk9yl6hr8lw.png"></p><br><p style=";text-align:right;direction:rtl">  لتحسين الأداء من حيث الحسابات ، من الأسرع استخدام عامل النقل.  وبالتالي ، يمكن تخفيض المعادلة أعلاه إلى ما يلي: </p><cut></cut><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/sm/6s/nr/sm6snrzc5z7nem3fsgamwy81xis.png"></p><br><p style=";text-align:right;direction:rtl">  ونتيجة لذلك ، بعد التقاط قيمة بكسل (565 RGB) من الكاميرا ، يمكن تحويلها على الفور إلى قيمة بكسل بتدرج الرمادي 8 بت تطبق صيغة التحويل.  من السهل تخزين الصورة ذات التدرج الرمادي في الذاكرة وبسرعة كافية لخدمة وظائف نظامنا في الوقت الفعلي نظرًا لتعقيدها اللوغاريتمي تقريبًا ويمكن لـ FPGA جعلها أسرع من خلال الوصول إلى الذاكرة بالتوازي.  بعد ذلك ، تكون الصورة المخزنة جاهزة لتنفيذ خوارزمية اكتشاف الحواف. </p><br><h5 id="intermediate-memory-the-buffer" style=";text-align:right;direction:rtl">  الذاكرة الوسيطة (المخزن المؤقت) </h5><br><p style=";text-align:right;direction:rtl">  لدينا 2 مخزن مؤقت ، الأول يستخدم لتخزين البيكسلات بعد تحويلها إلى درجات الرمادي وحجمها (8 بت × 150 × 150) والثاني يستخدم لتخزين البيكسل بعد تطبيق عامل سوبل والعتبة قيمة الإخراج وحجمه (1 بت × 150 × 150).  لسوء الحظ ، لا تخزن 150 × 150 مخزنًا مؤقتًا الصورة بالكامل من الكاميرا ولكنها تخزن جزءًا منها فقط. </p><br><p style=";text-align:right;direction:rtl">  لقد اخترنا حجم المخازن المؤقتة لدينا ليكون 150 × 150 بسبب محدودية ذاكرة الإعصار الرابع لأنه يحتوي فقط على 276.480 كيلوبايت بينما يأخذ المخزنان المؤقتان 202.500 كيلوبايت (150 × 150 × 9) وهو ما يعادل 73.24٪ من الذاكرة الأصلية لـ يستخدم الإعصار الرابع وبقية الذاكرة لتخزين الخوارزمية والهندسة المعمارية.  علاوة على ذلك ، جربنا (170 × 170) كحجم لمخازننا المؤقتة التي تأخذ 94.07٪ من الذاكرة التي لا تترك مساحة كافية لتنفيذ الخوارزمية. </p><cut></cut><br><p style=";text-align:right;direction:rtl">  المخازن المؤقتة الخاصة بنا هي ذاكرة وصول عشوائي ثنائية المنفذ يمكنها القراءة والكتابة في دورات ساعة مختلفة في نفس الوقت.  هنا ، أنشأنا تطبيقنا بدلاً من استخدام أداة كتالوج IP داخل برنامج Quartus للحصول على المزيد من المرونة في التنفيذ.  أيضا ، قمنا بدمج كل من المخازن المؤقتة في وحدة واحدة فقط بدلاً من وجود وحدات مختلفة. </p><br><h5 id="sobel-operator" style=";text-align:right;direction:rtl">  مشغل سوبل </h5><br><p style=";text-align:right;direction:rtl">  استخدمنا أول عامل للكشف عن الحافة المشتقة وهو عامل التدرج في منطقة المصفوفة والذي يحدد تغيير النصوع بين وحدات البكسل المختلفة.  لكي نكون أكثر دقة ، نظرًا لأنها طريقة مباشرة وفعالة من حيث استخدام الذاكرة وتعقيد الوقت ، استخدمنا عامل التدرج Sobel الذي يستخدم نواة 3x3 تتمحور حول بكسل تم اختياره لتمثيل قوة الحافة.  عامل سوبل هو حجم التدرج المحسوب بواسطة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/1e/-8/aj/1e-8ajvp7o58vzzhc6d5euzljfa.png" alt="معادلة G"></p><br><p style=";text-align:right;direction:rtl">  حيث يمكن تمثيل Gx و Gy باستخدام أقنعة الالتفاف: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/gq/3e/tb/gq3etbpr2ioaxrpzgmtbk8p0ppg.png" alt="مصفوفات الالتفاف Gx و Gy"></p><cut></cut><br><p style=";text-align:right;direction:rtl">  لاحظ أن وحدات البكسل الأقرب إلى مركز القناع تُعطى وزنًا أكبر.  كما يمكن حساب G <sub>x</sub> و G <sub>y</sub> على النحو التالي: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/ji/wt/us/jiwtusibcq8rngnqe3hvy3kbzgu.png" alt="معادلات Gx و gy"></p><br><p style=";text-align:right;direction:rtl">  حيث p <sub>i</sub> هي البكسل المقابل في الصفيف التالي ، وقيمة p <sub>i</sub> هي قيمة درجات الرمادي 8 بت: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/-0/cd/4s/-0cd4stky-xqnhkaeulsuvujbam.png" alt="مصفوفة بكسل"></p><br><p style=";text-align:right;direction:rtl">  إنها ممارسة شائعة لتقريب حجم التدرج لعامل Sobel بالقيم المطلقة: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/jq/ga/tr/jqgatrro-agy4-hdyu_92umzdgi.png" alt="المعادلة"></p><br><p style=";text-align:right;direction:rtl">  هذا التقريب أسهل في التنفيذ وأسرع في الحساب والذي يخدم وظائفنا مرة أخرى من حيث الوقت والذاكرة. </p><br><p style=";text-align:right;direction:rtl">  فيما يلي رسم تخطيطي لمشغل Sobel يأخذ 9 بكسل (8 بت) كمدخلات وينتج قيمة بكسل (8 بت): </p><cut></cut><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/l4/eg/9w/l4eg9warlvign4ibbjq3ptcuvg4.jpeg" alt="جوهر سوبل"></p><br><p style=";text-align:right;direction:rtl">  وهنا الرسم التخطيطي المفصل لتنفيذ مشغل سوبل. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/tg/0o/pg/tg0opgzckrosd2eaanar-jisy14.jpeg" alt="مفصل الأساسية سوبل"></p><br><h5 id="vga-monitor" style=";text-align:right;direction:rtl">  شاشة VGA </h5><br><p style=";text-align:right;direction:rtl">  تحتوي لوحة التطوير الخاصة بنا على واجهة VGA مدمجة لديها القدرة على عرض 8 ألوان فقط على شاشة VGA حيث تحتوي على 3 بت فقط للتحكم في الألوان من خلال بت واحد للأحمر ، وواحد للأخضر والآخر للأزرق.  وقد جعل هذا من تصحيح الأخطاء لدينا أكثر صعوبة لأنه يمنعنا من عرض الصورة من الكاميرا مباشرة إلى الشاشة.  لذلك ، استخدمنا عتبة لتحويل وحدات البكسل إلى قيمة 1 بت بحيث يمكن عرض الصورة. </p><br><p style=";text-align:right;direction:rtl">  تعمل واجهة VGA مثل الكاميرا حيث تعمل بكسلًا من بكسل من الزاوية العلوية اليسرى إلى الزاوية السفلية اليمنى.  باستخدام المزامنة الرأسية والأفقية ، يمكننا مزامنة الإشارات التي تتحكم في تدفق البكسل. </p><br><p style=";text-align:right;direction:rtl">  تستخدم إشارة التزامن العمودي لتمثيل فهرس الصف بينما تستخدم إشارة التزامن الأفقي لتمثيل فهرس العمود.  أيضًا ، تستخدم كلتا الإشارات الشرفة الأمامية والنبضة المتزامنة والشرفة الخلفية كإشارات مزامنة لفصل الصف القديم عن الصف الجديد في إشارة التزامن الأفقي والإطار القديم من الإطار الجديد في إشارة التزامن الرأسي. </p><cut></cut><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/uv/3f/gv/uv3fgvrj_y9yuabjdhuxhvek0ak.png" alt="مخطط توقيت إشارة VGA"></p><br><p style=";text-align:right;direction:rtl">  استخدمنا واجهة إشارة VGA القياسية (640 × 480 عند 60 ميجاهرتز).  جميع المواصفات القياسية للإشارة موصوفة <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هنا</a> . </p><br><h2 id="testing" style=";text-align:right;direction:rtl">  الاختبار </h2><br><p style=";text-align:right;direction:rtl">  قبل وضع كل شيء معًا واختبار نظام الوقت الفعلي.  كان علينا أولاً اختبار كل جزء على حدة.  في البداية ، قمنا بفحص القيم والإشارات التي تأتي من الكاميرا من خلال عرض قيم بكسل معينة.  بعد ذلك ، بمساعدة OpenCV باستخدام لغة برمجة Python ، تمكنا من تطبيق مرشح Sobel على عدة صور لمقارنة النتائج مع الخوارزمية الخاصة بنا والتحقق من صحة منطقنا.  علاوة على ذلك ، قمنا باختبار المخازن المؤقتة ومحرك VGA الخاص بنا من خلال عرض العديد من الصور الثابتة على شاشة VGA بعد تطبيق مشغل Sobel والعتبة.  علاوة على ذلك ، من خلال تغيير قيمة العتبة ، تتأثر دقة الصورة. </p><cut></cut><br><p style=";text-align:right;direction:rtl">  كود الثعبان الذي استخدمناه: </p><br><pre style=";text-align:right;direction:rtl"><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># This code is made to test the accuracy of our algorithm on FPGA import cv2 #import opencv library f = open("sample.txt",'w') # Open file to write on it the static image initialization lines img = cv2.imread('us.jpg') # Read the image which has our faces and its size 150x150 gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) #convert to grayscale sobelx = cv2.Sobel(gray,cv2.CV_64F,1,0,ksize=3) #x-axis sobel operator sobely = cv2.Sobel(gray,cv2.CV_64F,0,1,ksize=3) #y-axis sobel operator abs_grad_x = cv2.convertScaleAbs(sobelx) abs_grad_y = cv2.convertScaleAbs(sobely) grad = abs_grad_x + abs_grad_y for i in range(0,150): for x in range(0,150): #read the pixels of the grayscaled image and Store them into file with specific format to initialize the buffer in FPGA code f.write("data_a[{:d}]&lt;=8'd{:d};\n".format(i*150+x,gray[i][x])) #apply threshold to be exactly like the code on FPGA if(grad[i][x] &lt; 100): grad[i][x] = 255 else: grad[i][x] = 0 cv2.imshow("rgb", img) #Show the real img cv2.imshow("gray",gray) #Show the grayscale img cv2.imshow("sobel",grad)#Show the result img cv2.waitKey(0) #Stop the img to see it</span></span></code> </pre> <cut></cut><br><h2 id="results" style=";text-align:right;direction:rtl">  النتائج </h2><br><p style=";text-align:right;direction:rtl">  نتيجة لتطبيقنا ، حصلنا على نظام للكشف عن الحواف في الوقت الفعلي ينتج صورة 150x150 بعد تطبيق مرشح درجات الرمادي ومشغل Sobel.  يوفر النظام المطبق 30 إطارًا في الثانية.  تعمل الكاميرا على مدار الساعة بسرعة 25 ميجاهرتز ويفي النظام بشكل عام بالمواعيد النهائية في الوقت الفعلي دون تأخر ملحوظ.  علاوة على ذلك ، يمكن أن تؤثر قيمة العتبة على مقدار التفاصيل والضوضاء في الصورة النهائية. </p><br><p style=";text-align:right;direction:rtl">  فيما يلي مقارنة بين مشغل Sobel على FPGA وعامل OpenCV: </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/pg/sl/rc/pgslrcclisueu2qpfghaav-yju8.png" alt="مقارنة"></p><br><p style=";text-align:right;direction:rtl">  يوجد أدناه فيديو توضيحي للنتائج: </p><br><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/3a5/ea2/d49/3a5ea2d49eeb6e23f9ca4a64921d287a.jpg" alt="فيديو المشروع"></a> </p><br><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">هذا</a> هو رابط المستودع على Github الذي يحتوي على جميع رموز المصدر. </p><br><h2 id="future-improvements" style=";text-align:right;direction:rtl">  التحسينات المستقبلية </h2><br><p style=";text-align:right;direction:rtl">  نظرًا لأننا نستخدم FPGA Cyclone IV ، فنحن نقتصر على سعة الذاكرة وعدد البوابات المنطقية.  وبالتالي ، كتحسين مستقبلي ، يمكننا استخدام مصدر ذاكرة خارجي أو يمكننا تنفيذ عملنا على لوحة أخرى حتى نتمكن من عرض جميع وحدات البكسل من الصورة المستلمة من الكاميرا. </p><br><p style=";text-align:right;direction:rtl">  علاوة على ذلك ، على الرغم من أن مشغل Sobel سريع وبسيط في التنفيذ ، إلا أنه حساس بشكل ملحوظ للضوضاء.  للتخلص من الضوضاء الناتجة ، يمكننا استخدام مرشح ضوضاء مثل مرشح متوسط ​​غير خطي يعمل بشكل جيد تمامًا مع نظامنا إذا كان لدينا ذاكرة كافية لتنفيذ مخزن مؤقت ثالث.  سيؤدي ذلك إلى إنتاج صورة أكثر سلاسة مع إزالة الميزات الحادة. </p><br><p style=";text-align:right;direction:rtl">  وفقًا لذلك ، استخدمنا واجهة VGA المضمنة لـ FPGA التي يمكنها فقط إنتاج صورة 3 بت.  وبالتالي ، لم نتمكن من عرض الصورة ذات التدرج الرمادي لأنها تحتاج إلى عرض 8 بت.  ونتيجة لذلك ، سيؤدي تنفيذ واجهة أخرى أو استخدام لوحة أكثر قوة إلى تعزيز مرونة عرض الصورة. </p><cut></cut><br><h2 id="conclusion" style=";text-align:right;direction:rtl">  الخلاصة </h2><br><p style=";text-align:right;direction:rtl">  تمكنا من استخدام معرفتنا وفهمنا للمفاهيم الأساسية في الأنظمة المضمنة مثل آلات الحالة ، والتوازي الحسابي ، وواجهات الأجهزة والبرامج لإنشاء تطبيق فعال لكشف الحواف يلبي أهدافنا. </p><br><h2 id="acknowledgment" style=";text-align:right;direction:rtl">  شكر وتقدير </h2><br><p style=";text-align:right;direction:rtl">  تم بناء هذا المشروع من قبل فريق يتكون من طالبين: <strong>حسين يونس</strong> <strong>وهاني حامد</strong> في السنة الأولى بكالوريوس علوم الكمبيوتر في <strong>جامعة إنوبوليس</strong> في روسيا. </p><br><p style=";text-align:right;direction:rtl">  هذا المشروع جزء من دورة <strong>هندسة الكمبيوتر</strong> لخريف 2018 في <strong>جامعة إنوبوليس</strong> . </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">المراجع</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://eu.mouser.com/ProductDetail/Intel-Altera/EP4CE6E22C8N؟qs=jblrfmjbeiF2FLmcokX٪252bDw٪3D٪3D</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://www.voti.nl/docs/OV7670.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">http://embeddedprogrammer.blogspot.com/2012/07/hacking-ov7670-camera-module-sccb-cheat.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://www.intel.com/content/www/us/en/programmable/support/support-resources/operation-and-testing/pll-and-clock-management/pll-basics.html</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://knowledge.ni.com/KnowledgeArticleDetails؟id=kA00Z000000P9T3SAK</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_megafunction_overview.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://www.intel.com/content/dam/www/programmable/us/en/pdfs/literature/ug/ug_ram_rom.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">http://www.cse.usf.edu/~r1k/MachineVisionBook/MachineVision.files/MachineVision_Chapter5.pdf</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">https://www.digikey.com/eewiki/pages/viewpage.action؟pageId=15925278</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">http://tinyvga.com/vga-timing/640x480@60Hz</a> </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar431326/">https://habr.com/ru/post/ar431326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar431316/index.html">التصويت على الإصدار التجريبي الثاني من التقرير المنقح السابع حول نظام اللغة الخوارزمية (لغة كبيرة)</a></li>
<li><a href="../ar431318/index.html">Python transpiler chain → 11l → C ++ [لتسريع كود Python والمزيد]</a></li>
<li><a href="../ar431320/index.html">دراسة IFR: لا يزال عدد الروبوتات الصناعية في روسيا ضئيلاً</a></li>
<li><a href="../ar431322/index.html">تكرارات الدورة: كيف سار مؤتمر HolyJS ، وماذا عن التالي</a></li>
<li><a href="../ar431324/index.html">تقدم Microsoft بديلاً للأحرف المخصصة</a></li>
<li><a href="../ar431328/index.html">Kotlin وتكنولوجيا المعلومات في إستونيا و (فجأة) النفق بين تالين وهلسنكي: مقابلة مع أنطون كيكس</a></li>
<li><a href="../ar431330/index.html">عطلة نهاية الأسبوع للجوال: Mobius Free Broadcast</a></li>
<li><a href="../ar431332/index.html">نظرة عامة على تقارير DotNext 2018 الأكثر إثارة: إصدار EastBanc Technologies</a></li>
<li><a href="../ar431334/index.html">هواوي: التحكم في حماية الطائرة</a></li>
<li><a href="../ar431338/index.html">كتاب "DNA. تاريخ الثورة الجينية "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>