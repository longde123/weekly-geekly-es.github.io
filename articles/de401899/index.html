<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐄 👍🏾 👩🏾‍🎓 Multifunktionaler DIY Logger. Teil 1 📥 👨🏻‍🎨 🚲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich bin der Besitzer eines wunderbaren Geräts - GPS-Logger Holux M-241. Das Ding ist sehr praktisch und nützlich auf Reisen. Mit Hilfe eines Loggers s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Multifunktionaler DIY Logger. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/401899/"><img src="https://habrastorage.org/getpro/geektimes/post_images/65a/f4c/1c8/65af4c1c8bd4dd394b6a6d2939c6d211.jpg" alt="Bild"><br><br>  Ich bin der Besitzer eines wunderbaren Geräts - GPS-Logger Holux M-241.  Das Ding ist sehr praktisch und nützlich auf Reisen.  Mit Hilfe eines Loggers schreibe ich einen GPS-Track einer Reise, auf dem Sie sich dann detailliert zurechtfinden und die aufgenommenen Fotos an GPS-Koordinaten anhängen können.  Er hat auch einen kleinen Bildschirm, auf dem zusätzliche Informationen angezeigt werden - Stunden, aktuelle Geschwindigkeit, Höhe und Richtung, Kilometerzähler und vieles mehr.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier habe</a> ich mal eine kurze Rezension geschrieben. <br><br>  Mit all den Vorteilen eines Stücks Eisen begann ich daraus zu wachsen.  Ich vermisse ein paar kleine, aber nützliche Extras: ein paar Kilometerzähler, die die vertikale Geschwindigkeit anzeigen und die Parameter eines Streckenabschnitts messen.  Es scheint wie kleine Dinge, aber die Firma Holux fand dies nicht nützlich genug für die Implementierung in die Firmware.  Außerdem mag ich einige Parameter der Hardware nicht und einige Dinge sind in 10 Jahren veraltet ... <br><br>  Irgendwann wurde mir klar, dass ich selbst einen Logger mit den Funktionen erstellen kann, die ich benötige.  Glücklicherweise sind alle notwendigen Komponenten recht billig und erschwinglich.  Ich begann meine Implementierung basierend auf Arduino zu machen.  Unter dem Schnitt ein Bautagebuch, in dem ich versuchte, meine technischen Lösungen zu malen. <br><a name="habracut"></a><br><h1>  Funktionen definieren </h1><br>  Viele werden sich fragen, warum ich meinen eigenen Logger bauen muss, wenn sicher etwas für namhafte Hersteller bereit ist.  Möglicherweise.  Um ehrlich zu sein, habe ich nicht wirklich danach gesucht.  Aber sicher wird etwas fehlen.  In jedem Fall ist dieses Projekt ein Fan für mich.  Warum bauen wir nicht unser Traumgerät? <br><br>  Also, für das, was ich an meinem Holux M-241 schätze. <br><br><ul><li>  <b>Der Bildschirm</b> bildet eine „Black Box“, deren Ergebnisse erst nach der Reise verfügbar sind. Dies ist ein sehr praktisches Tool, dessen Messwerte hier und jetzt verfügbar sind.  Ein Bildschirm ermöglicht fast alle Funktionen dieser Liste. </li><li>  <b>Eine Uhr</b> ist an sich nützlich.  Auf GPS-Reisen ist der Logger, der an einer Schnur um den Hals baumelt, oft näher als ein Handy in der Tasche oder im Rucksack.  Die Uhr unterstützt alle Zeitzonen (allerdings mit manueller Umschaltung) </li><li>  <b>Mit der POI-Schaltfläche</b> können Sie die aktuelle Koordinate auf der Spur markieren.  Zum Beispiel, um eine Landmarke zu notieren, die aus dem Fenster des Busses gerutscht ist und über die ich später googeln möchte. </li><li>  Mit dem <b>Kilometerzähler können</b> Sie die zurückgelegte Strecke von einem bestimmten Punkt aus messen.  Zum Beispiel die pro Tag zurückgelegte Strecke oder die Länge einer Strecke. </li><li>  <b>Aktuelle Geschwindigkeit, Höhe und Richtung</b> helfen Ihnen, sich im Weltraum zu befinden </li><li>  <b>Die Überlebensfähigkeit von 12 bis 14 Stunden mit</b> einer AA-Batterie ermöglicht es Ihnen in den meisten Fällen, nicht über Probleme bei der Stromversorgung nachzudenken.  Das heißt,  Fast immer genug Gebühr für einen ganzen Reisetag. </li><li>  <b>Kompakt und einfach zu bedienen</b> - die Dinge in der modernen Welt sind sehr schön </li></ul><br>  Einige Dinge könnten jedoch etwas besser gemacht werden: <br><br><ul><li>  Das Stromversorgungssystem für <b>AA-Batterien wird</b> von vielen als eindeutiges Plus bezeichnet - eine Batterie hält lange und Sie können die Versorgung in jeder Wildnis wieder auffüllen.  Sie können sich für mindestens einen Monat autonomes Campen eindecken. <br><br>  Aber für mich ist die Akkulaufzeit reine Hämorrhoiden.  Sie müssen eine Handvoll Batterien mit sich führen und wer weiß, wie hochwertig sie sind (plötzlich lagen sie 5 Jahre lang auf einem Regal und waren bereits selbstentladen).  Mit Batterien ist die Blutung noch größer.  Mein Ladegerät kann nur paarweise aufgeladen werden.  Wir müssen die Batterien entladen, damit sie den gleichen Entladungsgrad haben.  Infolgedessen erinnern Sie sich nie daran, wo bereits entladen wurde und wo noch nicht. <br><br>  Während 6 Jahren mit dem Logger bin ich nur mitten im Nirgendwo ohne Strom gelandet.  In der Regel bekomme ich mindestens einmal am Tag Zugang zur Steckdose.  In diesem Fall wäre die eingebaute Lithiumbatterie viel praktischer.  In extremen Fällen habe ich eine Paverbank. <br><br></li><li>  <b>Die Anzeige des Entladungsgrades</b> erfolgt sehr dumm - die Anzeige beginnt zu blinken, wenn der Akku entladen wird.  Darüber hinaus kann es in 5 Minuten sterben und vielleicht eine weitere Stunde arbeiten.  Es ist sehr leicht, diesen Moment zu verpassen und einen Teil des Protokolls zu verlieren. <br><br></li><li>  Als Luftfahrtinteressierte wäre es für mich sehr interessant, die <b>aktuelle Vertikalgeschwindigkeit</b> zu beobachten. <br><br></li><li>  <b>Ein paar Kilometerzähler</b> - es ist oft interessant, mehr als eine Strecke zu messen.  Zum Beispiel die pro Tag und für die gesamte Reise zurückgelegte Strecke. <br><br></li><li>  Der Kilometerzähler wird zurückgesetzt, wenn Sie das Gerät ausschalten oder den Akku austauschen.  Das ist furchtbar unangenehm.  Wenn Sie in einem Café eine Mahlzeit eingenommen haben, kann der GPS-Logger nicht ausgeschaltet werden, da der Wert zurückgesetzt wird.  Er muss es eingeschaltet lassen und fährt weiter Kilometer und frisst die Batterie.  Es wäre viel bequemer, den Kilometerzähler <b>anzuhalten</b> und <b>die Werte</b> zwischen den Einschlüssen zu <b>speichern</b> . <br><br></li><li>  <b>Messung von Standortparametern</b> .  Beim Skifahren interessiert mich zum Beispiel die Länge der Abfahrt, die Höhe, die Durchschnitts- und Höchstgeschwindigkeit auf der Baustelle und die aufgewendete Zeit.  Was Sie wissen möchten, ist sofort und nicht zu Hause, wenn Sie den Titel herunterladen. <br><br></li><li>  <b>Die Genauigkeit</b> ist schlecht.  Wenn Sie sich schnell bewegen - sonst nichts.  Wenn die Geschwindigkeit auf der Strecke jedoch gering ist, sind „Geräusche“ + - 50 m deutlich sichtbar.  Und für eine Stunde Stehen können Sie fast einen Kilometer „bestehen“.  Der Nutzen der Technologie seit 10 Jahren ist weit fortgeschritten und moderne Empfänger bieten eine viel größere Genauigkeit. <br><br></li><li>  <b>Die Geschwindigkeit beim Zusammenführen von</b> Tracks beträgt nur 38.400. Nein, es ist 2017 nicht ernst, den COM-Port zum Übertragen großer Datenmengen zu verwenden.  Das Zusammenführen von 2 Megabyte internem Flash dauert mehr als 20 Minuten. <br><br>  Darüber hinaus kann nicht jedes Programm das Format zusammengeführter Spuren verarbeiten.  Das native Dienstprogramm ist sehr elend.  Glücklicherweise gibt es BT747, mit dem der Track angemessen zusammengeführt und in ein verdauliches Format konvertiert werden kann. <br><br></li><li>  <b>Die Größe des Flash-Laufwerks beträgt</b> nur 2 MB.  Einerseits reicht dies für eine zweiwöchige Reise mit Sparpunkten alle 5 Sekunden.  Aber zuerst das interne Paketformat <br>  erfordert Konvertierung und erlaubt zweitens nicht, die Lautstärke zu erhöhen </li><li>  <b>Massenspeichergerät ist</b> aus irgendeinem Grund jetzt nicht in Mode.  Moderne Schnittstellen versuchen, das Vorhandensein von Dateien zu verbergen.  Ich bin seit 25 Jahren mit Computern beschäftigt und die direkte Arbeit mit Dateien ist für mich viel bequemer als auf jede andere Weise. </li></ul><br>  Hier gibt es nichts, was ohne nennenswerten Aufwand nicht realisiert werden könnte. <br><br>  Alles andere.  Ich benutze es nicht selbst, aber plötzlich ist jemand nützlich: <br><br><ul><li>  Zeigt die aktuellen Koordinaten (Breite, Länge) an. </li><li>  Auf der linken Seite des Bildschirms sind verschiedene Symbole gezeichnet, an deren Essenz ich mich ohne Handbuch nicht erinnern kann. </li><li>  Es gibt Schaltmeter / km - Fuß / Meilen. </li><li>  Der Bluetooth-Logger kann ohne GPS mit Mobiltelefonen verbunden werden. </li><li>  Der absolute Abstand zum Punkt. </li><li>  Protokollierung nach Zeit (alle N Sekunden) oder nach Entfernung (alle X Meter). </li><li>  Unterstützung für verschiedene Sprachen. </li></ul><br><h1>  Wähle Eisen </h1><br>  Die Anforderungen sind mehr oder weniger definiert.  Es ist Zeit zu verstehen, wie all dies umgesetzt werden kann.  Die Hauptkomponenten, die ich haben werde, sind: <br><br><ul><li>  <b>Mikrocontroller</b> - Ich habe keine Pläne für ausgefeilte Rechenalgorithmen, daher ist die Verarbeitungsleistung des Kernels nicht besonders wichtig.  Ich habe auch keine besonderen Anforderungen an die Befüllung - ein Satz Standardperipheriegeräte reicht aus. <br><br>  Zur Hand war nur eine Streuung verschiedener Arduinoes sowie ein paar stm32f103c8t6.  Ich habe mich für AVR entschieden, das ich auf der Ebene der Controller / Register / Peripheriegeräte gut kenne.  Wenn ich auf Einschränkungen stoße, gibt es einen Grund, den STM32 zu spüren. <br><br></li><li>  <b>Der GPS-Empfänger wurde</b> aus den Modulen NEO6MV2, Beitan BN-800 und Beitan BN-880 ausgewählt.  Seit einiger Zeit gegoogelte Foren.  Erfahrene Leute sagten, dass der erste Empfänger das letzte Jahrhundert ist.  Die beiden anderen unterscheiden sich nur in der Position der Antenne - beim BN-800 hängt sie am Draht und beim BN-880 wird sie mit einem Sandwich auf das Hauptmodul geklebt.  Nahm einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BN-880</a> . <br><br></li><li>  <b>Bildschirm</b> - Das Original verwendet ein 128 x 32 LCD mit Hintergrundbeleuchtung.  Ich habe nicht genau das gleiche gefunden.  Ich habe eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OLED 0,91 Zoll auf dem SSD1306-Controller</a> und einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1,2-Zoll-LCD-Bildschirm auf dem ST7565R-Controller gekauft</a> .  Ich habe mich entschlossen, von vorne zu beginnen, weil  Es ist einfacher, eine Verbindung mit einem Standardkamm gemäß I2C oder SPI herzustellen.  Es ist jedoch im Vergleich zum Original etwas kleiner und funktioniert auch aus Gründen der Kraftstoffeffizienz nicht, um das Bild ständig anzuzeigen.  Das zweite Display sollte weniger gefräßig sein, aber Sie müssen einen kniffligen Stecker dafür löten und herausfinden, wie die Hintergrundbeleuchtung mit Strom versorgt wird. </li></ul><br>  Von den kleinen Dingen: <br><br><ul><li>  Knöpfe kauften einmal eine ganze Tasche; </li><li>  Schild mit für SD-Karte - auch zur Hand herumliegen; </li><li>  Ich habe ein Paar verschiedene Laderegler für Lithiumbatterien gekauft, aber ich habe es immer noch nicht verstanden. </li></ul><br>  Ich habe beschlossen, das Board ganz am Ende zu entwerfen, wenn die Firmware fertig ist.  Zu diesem Zeitpunkt werde ich endlich über die Hauptkomponenten und das Schema für ihre Aufnahme entscheiden.  In der ersten Phase entschied ich mich für das Debuggen auf dem Steckbrett, indem ich die Komponenten mit Patchkabeln verband. <br><br>  Aber zuerst müssen Sie sich für ein sehr wichtiges Thema entscheiden - die Ernährung der Komponenten.  Es schien mir vernünftig, alles von 3,3 V: GPS und dem Bildschirm nur darauf zu betreiben und zu wissen, wie man arbeitet.  Dies ist auch die native Spannung für USB und SD.  Zusätzlich kann die Schaltung mit einer Lithiumdose betrieben werden. <br><br>  Die Wahl fiel auf den Arduino Pro Mini, der in der 8MHz / 3.3V-Version zu finden ist.  Aber sie hatte kein USB an Bord - ich musste einen USB-UART-Adapter verwenden. <br><br><h1>  Erste Schritte </h1><br>  Ursprünglich wurde das Projekt in Arduino IDE erstellt.  Aber um ehrlich zu sein, meine Sprache traut sich nicht, es als IDE zu bezeichnen - wie ein Texteditor mit einem Compiler.  Auf jeden Fall kann ich nach Visual Studio, in dem ich seit 13 Jahren arbeite, in der Arduino IDE nichts Ernstes ohne Tränen und Matyuk tun. <br><br>  Zum Glück gibt es ein kostenloses Atmel Studio, in das sogar Visual Assist sofort integriert ist !!!  Das Programm weiß alles, was benötigt wird, alles ist vertraut und an seinem Platz.  Nun, fast alles (ich habe nicht gefunden, wie man nur eine Datei kompiliert, um beispielsweise die Syntax zu überprüfen) <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/bfc/b08/98f/bfcb0898f136628896be3b6769eda34f.png" alt="Bild"><br><br>  Vom Bildschirm aus gestartet - Dies ist erforderlich, um das Skelett der Firmware zu debuggen und es dann mit Funktionen zu füllen.  Er blieb bei der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten verfügbaren Bibliothek für Adafruit SSD1306 stehen</a> .  Sie weiß alles, was benötigt wird und bietet eine sehr einfache Oberfläche. <br><br>  Spielte mit Schriftarten.  Es stellte sich heraus, dass eine Schriftart bis zu 8 KB groß sein kann (die Größe der Buchstaben beträgt 24pt) - in einem 32-KB-Controller kann man nicht besonders herumlaufen.  Zum Anzeigen der Zeit werden beispielsweise große Schriftarten benötigt. <br><br><div class="spoiler">  <b class="spoiler_title">Beispielcode für Schriftarten</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Adafruit_GFX.h&gt; #include &lt;Adafruit_SSD1306.h&gt; #include &lt;gfxfont.h&gt; #include &lt;fonts/FreeMono12pt7b.h&gt; #include &lt;fonts/FreeMono18pt7b.h&gt; ... #include &lt;fonts/FreeSerifItalic24pt7b.h&gt; #include &lt;fonts/FreeSerifItalic9pt7b.h&gt; #include &lt;fonts/TomThumb.h&gt; struct font_and_name { const char * PROGMEM name; GFXfont * font; }; #define FONT(name) {#name, &amp;name} const font_and_name fonts[] = { // FONT(FreeMono12pt7b), FONT(FreeMono18pt7b), /* FONT(FreeMono24pt7b), FONT(FreeMono9pt7b), FONT(FreeMonoBold12pt7b), ... FONT(FreeSerifItalic9pt7b), FONT(TomThumb)*/ }; const unsigned int fonts_count = sizeof(fonts) / sizeof(font_and_name); unsigned int current_font = 0; extern Adafruit_SSD1306 display; void RunFontTest() { display.clearDisplay(); display.setCursor(0,30); display.setFont(fonts[current_font].font); display.print("12:34:56"); display.setCursor(0,6); display.setFont(&amp;TomThumb); display.print(fonts[current_font].name); display.display(); } void SwitchToNextFont() { current_font = ++current_font % fonts_count; }</span></span></span></span></code> </pre> <br></div></div><br>  Schriftarten mit der Bibliothek sind sehr ungeschickt.  Die Monospace-Schrift stellte sich als sehr breit heraus - die Zeile „12:34:56“ passt nicht, Serif - alle Zahlen haben unterschiedliche Gewichte.  Es sei denn, die Standardschriftart 5x7 in der Bibliothek sieht essbar aus. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/b7a/67f/676/b7a67f676d061bdb4920985b0c46692a.jpg" alt="Bild"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/9de/e19/69f/9dee1969f16ad50138756b9dab906d4d.jpg" alt="Bild"><br><br>  Es stellte sich heraus, dass diese Schriftarten von einigen Open-Source-ttf-Schriftarten konvertiert wurden, die einfach nicht für kleine Auflösungen optimiert sind. <br><br>  Ich musste meine Schriften zeichnen.  Genauer gesagt, graben Sie zuerst einzelne Symbole aus den fertigen aus.  Das Symbol ':' in der ASCII-Tabelle ist direkt nach den Zahlen sehr nützlich und kann in einem Block gekauft werden.  Es ist auch praktisch, dass Sie eine Schriftart nicht für alle Zeichen erstellen können, sondern nur für einen Bereich, z. B. von 0x30 ('0') bis 0x3a (':').  T.O.  Bei FreeSans18pt7b stellte sich heraus, dass nur für die erforderlichen Zeichen eine sehr kompakte Schriftart erstellt wurde.  Richtig, ich musste die Breite leicht anpassen, damit der Text in die Breite des Bildschirms passte. <br><br><div class="spoiler">  <b class="spoiler_title">Unterschrift FreeSans18pt7b</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// This font consists only of digits and ':' to display current time. // The font is very based on FreeSans18pt7b.h //</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> 25 pixel height is too much for displaying time. Create another 22px font const uint8_t TimeFontBitmaps[] PROGMEM = { /* 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE9, 0x20, 0x3F, 0xFC, 0xE3, 0xF1, 0xF8, 0xFC, 0x7E, 0x3F, 0x1F, 0x8E, 0x82, 0x41, 0x00, 0x01, 0xC3, 0x80, ... 0x03, 0x00, 0xC0, 0x60, 0x18, 0x06, 0x03, 0x00, 0xC0, 0x30, 0x18, 0x06, 0x01, 0x80, 0xC0, 0x30, 0x00, */0x07, 0xE0, 0x0F, 0xF8, 0x1F, 0xFC, 0x3C, 0x3C, 0x78, 0x1E, 0x70, 0x0E, 0x70, 0x0E, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x0F, 0x70, 0x0E, 0x70, 0x0E, 0x78, 0x1E, 0x3C, 0x3C, 0x1F, 0xF8, 0x1F, 0xF0, 0x07, 0xE0, 0x03, 0x03, 0x07, 0x0F, 0x3F, 0xFF, 0xFF, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7C, 0x3E, 0x70, 0x0F, 0xF0, 0x0F, 0xE0, 0x07, 0xE0, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x1E, 0x00, 0x3C, 0x00, 0xF8, 0x03, 0xF0, 0x07, 0xC0, 0x1F, 0x00, 0x3C, 0x00, 0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xF0, 0x07, 0xFE, 0x07, 0xFF, 0x87, 0x83, 0xC3, 0x80, 0xF3, 0x80, 0x39, 0xC0, 0x1C, 0xE0, 0x0E, 0x00, 0x07, 0x00, 0x0F, 0x00, 0x7F, 0x00, 0x3F, 0x00, 0x1F, 0xE0, 0x00, 0x78, 0x00, 0x1E, 0x00, 0x07, 0x00, 0x03, 0xF0, 0x01, 0xF8, 0x00, 0xFE, 0x00, 0x77, 0x00, 0x73, 0xE0, 0xF8, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xF0, 0x00, 0x00, 0x38, 0x00, 0x38, 0x00, 0x78, 0x00, 0xF8, 0x00, 0xF8, 0x01, 0xF8, 0x03, 0xB8, 0x03, 0x38, 0x07, 0x38, 0x0E, 0x38, 0x1C, 0x38, 0x18, 0x38, 0x38, 0x38, 0x70, 0x38, 0x60, 0x38, 0xE0, 0x38, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x1F, 0xFF, 0x0F, 0xFF, 0x8F, 0xFF, 0xC7, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0xE0, 0x00, 0x70, 0x00, 0x39, 0xF0, 0x3F, 0xFE, 0x1F, 0xFF, 0x8F, 0x83, 0xE7, 0x00, 0xF0, 0x00, 0x3C, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0xFC, 0x00, 0xEF, 0x00, 0x73, 0xC0, 0xF0, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xE0, 0x00, 0x03, 0xE0, 0x0F, 0xF8, 0x1F, 0xFC, 0x3C, 0x1E, 0x38, 0x0E, 0x70, 0x0E, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xE3, 0xE0, 0xEF, 0xF8, 0xFF, 0xFC, 0xFC, 0x3E, 0xF0, 0x0E, 0xF0, 0x0F, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0x60, 0x07, 0x70, 0x0F, 0x70, 0x0E, 0x3C, 0x3E, 0x3F, 0xFC, 0x1F, 0xF8, 0x07, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x18, 0x00, 0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0xE0, 0x00, 0xC0, 0x01, 0xC0, 0x01, 0x80, 0x03, 0x80, 0x03, 0x80, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x07, 0xF0, 0x0F, 0xFE, 0x0F, 0xFF, 0x87, 0x83, 0xC7, 0x80, 0xF3, 0x80, 0x39, 0xC0, 0x1C, 0xE0, 0x0E, 0x78, 0x0F, 0x1E, 0x0F, 0x07, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xE3, 0xE0, 0xF9, 0xC0, 0x1D, 0xC0, 0x0F, 0xE0, 0x03, 0xF0, 0x01, 0xF8, 0x00, 0xFC, 0x00, 0xF7, 0x00, 0x73, 0xE0, 0xF8, 0xFF, 0xF8, 0x3F, 0xF8, 0x07, 0xF0, 0x00, 0x07, 0xE0, 0x1F, 0xF8, 0x3F, 0xFC, 0x7C, 0x3C, 0x70, 0x0E, 0xF0, 0x0E, 0xE0, 0x06, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x07, 0xE0, 0x0F, 0x70, 0x0F, 0x78, 0x3F, 0x3F, 0xFF, 0x1F, 0xF7, 0x07, 0xC7, 0x00, 0x07, 0x00, 0x06, 0x00, 0x0E, 0x70, 0x0E, 0x70, 0x1C, 0x78, 0x3C, 0x3F, 0xF8, 0x1F, 0xF0, 0x07, 0xC0, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0x80 /*, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xB6, 0xD6, 0x00, 0x00, 0x80, 0x03, 0xC0, 0x07, 0xE0, 0x0F, 0xC0, 0x3F, 0x80, 0x7E, 0x00, 0xFC, 0x01, 0xF0, 0x00, 0xE0, 0x00, ... 0x38, 0x38, 0xF8, 0xF0, 0xE0, 0x38, 0x00, 0xFC, 0x03, 0xFC, 0x1F, 0x3E, 0x3C, 0x1F, 0xE0, 0x1F, 0x80, 0x1E, 0x00 */ }; //TODO Recalc offset numbers const GFXglyph TimeFontGlyphs[] PROGMEM = { { 449-449, 16, 25, 19, 2, -24 }, // 0x30 '0' { 499-449, 8, 25, 19, 4, -24 }, // 0x31 '1' { 524-449, 16, 25, 19, 2, -24 }, // 0x32 '2' { 574-449, 17, 25, 19, 1, -24 }, // 0x33 '3' { 628-449, 16, 25, 19, 1, -24 }, // 0x34 '4' { 678-449, 17, 25, 19, 1, -24 }, // 0x35 '5' { 732-449, 16, 25, 19, 2, -24 }, // 0x36 '6' { 782-449, 16, 25, 19, 2, -24 }, // 0x37 '7' { 832-449, 17, 25, 19, 1, -24 }, // 0x38 '8' { 886-449, 16, 25, 19, 1, -24 }, // 0x39 '9' { 936-449, 3, 19, 7, 2, -20 }, // 0x3A ':' }; const GFXfont TimeFont PROGMEM = { (uint8_t *)TimeFontBitmaps, (GFXglyph *)TimeFontGlyphs, 0x30, 0x3A, 20 };</span></span></code> </pre> </div></div><br>  Es stellte sich heraus, dass die 18pt-Schrift tatsächlich 25 Pixel hoch ist.  Aus diesem Grund passt er leicht auf eine andere Inschrift <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/543/aee/2e5/543aee2e5c6515307a4c969a3bfff374.jpg" alt="Bild"><br><br>  Die invertierte Anzeige hilft übrigens zu verstehen, wo sich die Grenzen des Zeichenbereichs tatsächlich befinden und wie die Linie relativ zu diesem Rand liegt - die Anzeige hat sehr große Rahmen. <br><br>  Googelte lange Zeit fertige Schriftarten, aber sie passten weder in Größe, Form noch Inhalt.  Zum Beispiel im Internet eine 8x12-Schriftwelle (Speicherauszüge von VGA-Kartenzeichengeneratoren).  Tatsächlich sind diese Schriftarten jedoch 6 x 8, d. H.  Viele Weltraumspaziergänge - bei einer so geringen Auflösung und Größe wie meiner ist dies von entscheidender Bedeutung. <br><br>  Ich musste meine eigenen Schriftarten zeichnen, da das Schriftformat der Adafruit-Bibliothek sehr einfach ist.  Ich habe das Bild in Paint.net vorbereitet - ich habe einfach die Buchstaben in der richtigen Schrift gezeichnet und sie dann mit einem Bleistift ein wenig korrigiert.  Ich habe das Bild als PNG gespeichert und es dann schnell an das Python-Skript gesendet, das auf meinem Knie geschrieben ist.  Dieses Skript hat einen halbfertigen Code generiert, der bereits punktweise in der IDE direkt in den Hex-Codes regiert. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/618/78f/f7e/61878ff7eff21be033fdbc56183a4f5e.png" alt="Bild"><br><br>  So sieht beispielsweise der Prozess zum Erstellen einer monospaced Schriftart 8x12 mit kleinem Buchstaben- und Zeilenabstand aus.  Jedes Zeichen am Ende war ungefähr 7x10 groß und belegte standardmäßig 10 Bytes.  Es wäre möglich, jedes Zeichen in 8-9 Bytes zu packen (die Bibliothek erlaubt dies), aber ich habe mich nicht darum gekümmert.  Darüber hinaus können Sie in diesem Formular einzelne Pixel direkt im Code bearbeiten. <br><br><div class="spoiler">  <b class="spoiler_title">Schriftart 8x12</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// A simple 8x12 font (slightly modifier Courier New) const uint8_t Monospace8x12Bitmaps[] PROGMEM = { 0x1e, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1e, //0 0x18, 0x68, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x7f, //1 0x3e, 0x41, 0x41, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x41, 0x7f, //2 0x3e, 0x41, 0x01, 0x01, 0x0e, 0x02, 0x01, 0x01, 0x41, 0x3e, //3 0x02, 0x06, 0x0a, 0x12, 0x12, 0x22, 0x3f, 0x02, 0x02, 0x0f, //4 0x7f, 0x41, 0x40, 0x40, 0x7e, 0x01, 0x01, 0x01, 0x41, 0x3e, //5 0x1e, 0x21, 0x40, 0x40, 0x5e, 0x61, 0x41, 0x41, 0x41, 0x3e, //6 0x7f, 0x41, 0x01, 0x02, 0x02, 0x04, 0x04, 0x04, 0x08, 0x08, //7 0x1e, 0x21, 0x21, 0x21, 0x1e, 0x21, 0x21, 0x21, 0x21, 0x1e, //8 0x1e, 0x21, 0x21, 0x21, 0x23, 0x1d, 0x01, 0x01, 0x22, 0x1c, //9 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, //: }; const GFXglyph Monospace8x12Glyphs[] PROGMEM = { { 0, 8, 10, 8, 0, -11 }, // 0x30 '0' { 10, 8, 10, 8, 0, -11 }, // 0x31 '1' { 20, 8, 10, 8, 0, -11 }, // 0x32 '2' { 30, 8, 10, 8, 0, -11 }, // 0x33 '3' { 40, 8, 10, 8, 0, -11 }, // 0x34 '4' { 50, 8, 10, 8, 0, -11 }, // 0x35 '5' { 60, 8, 10, 8, 0, -11 }, // 0x36 '6' { 70, 8, 10, 8, 0, -11 }, // 0x37 '7' { 80, 8, 10, 8, 0, -11 }, // 0x38 '8' { 90, 8, 10, 8, 0, -11 }, // 0x39 '9' { 100, 8, 10, 8, 0, -11 }, // 0x3A ':' }; const GFXfont Monospace8x12Font PROGMEM = { (uint8_t *)Monospace8x12Bitmaps, (GFXglyph *)Monospace8x12Glyphs, 0x30, 0x3A, 12 };</span></span></code> </pre><br></div></div><br><h1>  Rahmen </h1><br>  Das Originalgerät bietet eine sehr einfache und bequeme Oberfläche.  Informationen werden in Kategorien gruppiert, die auf einzelnen Seiten (Bildschirmen) angezeigt werden.  Mit der Schaltfläche können Sie durch die Seiten blättern und mit der zweiten Schaltfläche das aktuelle Element auswählen oder die in der Signatur unter der Schaltfläche angegebene Aktion ausführen.  Dieser Ansatz erscheint mir sehr praktisch und es besteht keine Notwendigkeit, etwas zu ändern. <br><br>  Ich mag die Schönheit von OOP, weil ich sofort eine kleine Benutzeroberfläche geblendet habe. Jede Seite implementiert die Benutzeroberfläche nach Bedarf.  Die Seite kann sich selbst zeichnen und implementiert die Reaktion auf die Schaltflächen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> {</span></span> Screen * nextScreen; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Screen(); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Screen() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSelButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onOkButton</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> PROGMEM </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSelButtonText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> PROGMEM </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOkButtonText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span></span>; };</code> </pre> <br>  Schaltflächen können je nach aktuellem Bildschirm verschiedene Aktionen ausführen.  Daher habe ich den oberen Rand des Bildschirms mit einer Höhe von 8 Pixel den Beschriftungen für die Schaltflächen zugewiesen.  Der Text für die Signaturen hängt vom aktuellen Bildschirm ab und wird von den virtuellen Funktionen getSelButtonText () und getOkButtonText () zurückgegeben.  Auch im Header werden weiterhin Serviceelemente wie GPS-Signalstärke und Batterieladung angezeigt.  Die verbleibenden ¾ Bildschirme stehen für nützliche Informationen zur Verfügung. <br><br>  Wie gesagt, die Bildschirme können umgedreht werden, was bedeutet, dass irgendwo eine Liste von Objekten für verschiedene Seiten vorhanden sein sollte.  An welchen mehr als einem Bildschirm können Sie wie in einem Untermenü verschachteln.  Ich habe sogar die ScreenManager-Klasse gestartet, die diese Listen verwalten sollte, aber dann fand ich die Lösung einfacher. <br><br>  Jeder Bildschirm hat also einfach einen Zeiger auf den nächsten.  Wenn Sie auf dem Bildschirm das Untermenü aufrufen können, wird dem Bildschirm dieses Untermenüs ein weiterer Zeiger hinzugefügt <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> {</span></span> Screen * nextScreen; … }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParentScreen</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Screen { Screen * childScreen; … };</code> </pre> <br>  Standardmäßig ruft der Schaltflächenhandler einfach die Bildschirmänderungsfunktion auf und übergibt ihr den gewünschten Zeiger.  Die Funktion erwies sich als trivial - sie schaltete nur den Zeiger auf den aktuellen Bildschirm.  Um die Verschachtelung der Bildschirme sicherzustellen, habe ich einen kleinen Stapel erstellt.  Der gesamte Bildschirmmanager passt also in 25 Zeilen und 4 kleine Funktionen. <br><br><pre> <code class="cpp hljs">Screen * screenStack[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> screenIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCurrentScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span><span class="hljs-function"> </span></span>{ screenStack[screenIdx] = screen; } <span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> screenStack[screenIdx]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enterChildScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Screen * screen)</span></span></span><span class="hljs-function"> </span></span>{ screenIdx++; <span class="hljs-comment"><span class="hljs-comment">//TODO limit this screenStack[screenIdx] = screen; } void backToParentScreen() { if(screenIdx) screenIdx--; }</span></span></code> </pre> <br>  Der Code zum Füllen dieser Strukturen sieht zwar nicht besonders gut aus, wurde aber bisher nicht besser erfunden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Screen * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createCurrentTimeScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TimeZoneScreen * tzScreen = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>); tzScreen = tzScreen-&gt;addScreen(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>)); tzScreen = tzScreen-&gt;addScreen(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimeZoneScreen(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// TODO Add real timezones here CurrentTimeScreen * screen = new CurrentTimeScreen(); screen-&gt;addChildScreen(tzScreen); return screen; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Der Gedanke</b> <div class="spoiler_text">  Die Strukturierung hat sich natürlich als schön herausgestellt, aber ich fürchte, sie frisst viel Gedächtnis.  Sie müssen gegen sich selbst gehen und eine große statische Tabelle mit Zeigern zafigachit. <br></div></div><br>  Mach weiter.  Bei der Implementierung der Schnittstelle wollte ich so etwas wie ein Meldungsfeld erstellen, eine kurze Nachricht, die ein oder zwei Sekunden lang angezeigt und dann ausgeblendet wird.  Wenn Sie beispielsweise die POI-Taste (Point of Interest) auf dem Bildschirm mit den aktuellen Koordinaten drücken, ist es hilfreich, dem Benutzer zusätzlich zum Schreiben des Punkts auf die Spur die Meldung „Wegpunkt gespeichert“ anzuzeigen (im Originalgerät wird nur für eine Sekunde ein zusätzliches Symbol angezeigt).  Wenn der Akku fast leer ist, können Sie den Benutzer mit einer Meldung „aufmuntern“. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/aa5/dec/17b/aa5dec17b1b4b298b764fce33b8441db.jpg" alt="Bild"><br><br>  Da die Daten von GPS ständig eingehen, kann von keinen Sperrfunktionen gesprochen werden.  Daher musste ich eine einfache Zustandsmaschine (Zustandsmaschine) erfinden, die in der Funktion loop () auswählt, was zu tun ist - den aktuellen Bildschirm oder das aktuelle Meldungsfeld anzeigen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> State { IDLE_DISPLAY_OFF, IDLE, MESSAGE_BOX, BUTTON_PRESSED, };</code> </pre> <br>  Es ist auch bequem, Tastendrücke mit der Zustandsmaschine zu handhaben.  Vielleicht wäre es durch Interrupts richtig, aber es hat sich auch als gut herausgestellt.  Das funktioniert so: Wenn eine Taste im IDLE-Status gedrückt wurde, merken Sie sich die Zeit, zu der sie gedrückt wurde, und wechseln Sie in den Status BUTTON_PRESSED.  In diesem Zustand warten wir, bis der Benutzer die Schaltfläche loslässt.  Hier können wir die Dauer berechnen, zu der die Taste gedrückt wurde.  Kurze Antworten (&lt;30 ms) werden einfach ignoriert - höchstwahrscheinlich handelt es sich um einen Kontaktsprung.  Lange Fahrten können bereits als Tastendruck interpretiert werden. <br><br>  Ich plane, sowohl kurzes Drücken von Tasten für normale Aktionen als auch langes (&gt; 1c) für spezielle Funktionen zu verwenden.  Zum Beispiel startet / pausiert ein kurzes Drücken den Kilometerzähler, ein langes Drücken setzt den Zähler auf 0 zurück. <br><br>  Vielleicht werden andere Staaten hinzugefügt.  So ändern sich beispielsweise im ursprünglichen Logger nach dem Umschalten auf die nächste Seite die Werte auf dem Bildschirm häufig und nach einigen Sekunden seltener - einmal pro Sekunde.  Dies kann durch Hinzufügen eines weiteren Status erfolgen. <br><br>  Als der Rahmen fertig war, begann ich bereits, GPS anzuschließen.  Aber hier gab es Nuancen, die mich veranlassten, diese Aufgabe zu verschieben. <br><br><h1>  Firmware-Optimierung </h1><br>  Bevor ich weitermache, muss ich mich von einigen technischen Details ablenken lassen.  Tatsache ist, dass ich ungefähr an diesem Ort anfing, mit zunehmendem Speicherverbrauch zu stoßen.  Es stellte sich heraus, dass die Zeile, die zu Beginn der Firmware ohne den Modifikator PROGMEM rücksichtslos deklariert wurde, in den Arbeitsspeicher kopiert wird und dort während der gesamten Laufzeit Speicherplatz beansprucht. <br><br><div class="spoiler">  <b class="spoiler_title">Verschiedene Architekturen</b> <div class="spoiler_text">  Kurzgesagt.  Auf großen Computern wird die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von Neumann-Architektur verwendet,</a> bei der sich Code und Daten im selben Adressraum befinden.  Das heißt,  Daten aus RAM und ROM werden auf die gleiche Weise gelesen. <br><br>  Mikrocontroller verwenden normalerweise die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Harvard-Architektur</a> , bei der Code und Daten getrennt sind.  T.O.  Sie müssen verschiedene Funktionen verwenden, um Speicher und Flash zu lesen.  Aus Sicht der C / C ++ - Sprache sehen Zeiger gleich aus, aber beim Schreiben eines Programms müssen wir genau wissen, auf welchen Speicher unser Zeiger genau zeigt, und die entsprechenden Funktionen aufrufen. </div></div><br>  Glücklicherweise haben sich Bibliotheksentwickler bereits teilweise darum gekümmert.  Die Hauptklasse der Anzeigebibliothek - Adafruit_SSD1306 - wird von der Print-Klasse der Arduino-Standardbibliothek geerbt. <br><br>  Dies bietet uns eine ganze Reihe verschiedener Modifikationen der Druckmethode - zum Drucken von Zeichenfolgen, einzelnen Zeichen, Zahlen und etwas anderem.  Es hat also 2 separate Funktionen zum Drucken von Zeilen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __FlashStringHelper *); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> print(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[]);</code> </pre><br>  Der erste weiß, dass Sie eine Zeile von einem Flash-Laufwerk drucken müssen, und lädt sie Zeichen für Zeichen.  Der zweite druckt Zeichen aus dem RAM.  Tatsächlich nehmen beide Funktionen einen Zeiger auf eine Zeichenfolge nur aus unterschiedlichen Adressräumen. <br><br>  Lange habe ich im Arduino-Code nach diesem __FlashStringHelper gesucht, um zu lernen, wie man die gewünschte print () -Funktion aufruft.  Es stellte sich heraus, dass die Jungs den Trick gemacht hatten: Sie deklarierten diesen Typ einfach mit der Vorwärtsdeklaration (ohne den Typ selbst zu deklarieren) und schrieben ein Makro, das blitzschnell Zeiger auf Zeilen in den Typ __FlashStringHelper umwandelte.  Nur damit der Compiler die erforderliche überladene Funktion auswählt <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlashStringHelper</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F(string_literal) (reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const __FlashStringHelper *&gt;(PSTR(string_literal)))</span></span></span></span></code> </pre><br>  So können Sie wie folgt schreiben: <br><br><pre> <code class="cpp hljs">display.print(F(“String in flash memory”));</code> </pre> <br><br>  Aber du kannst nicht so schreiben <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> text[] PROGMEM = <span class="hljs-string"><span class="hljs-string">"String in flash memory"</span></span>; display.print(F(text));</code> </pre> <br>  Und anscheinend bietet die Bibliothek nichts, was auf diese Weise getan werden könnte.  Ich weiß, dass es nicht gut ist, private Bibliotheksstücke in meinem Code zu verwenden, aber was soll ich tun?  Ich zeichnete mein Makro, das tat, was ich brauchte. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USE_PGM_STRING(x) reinterpret_cast</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;const __FlashStringHelper *&gt;(x)</span></span></span></span></code> </pre><br>  Die Hutzeichnungsfunktion sah also folgendermaßen aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Screen::drawHeader() { display.setFont(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); display.setCursor(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); display.print(<span class="hljs-string"><span class="hljs-string">'\x1e'</span></span>); display.print(USE_PGM_STRING(getSelButtonText())); display.setCursor(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); display.print(<span class="hljs-string"><span class="hljs-string">'\x1e'</span></span>); display.print(USE_PGM_STRING(getOkButtonText())); }</code> </pre> <br>  Nun, da ich mich mit den Low-Level-Teilen der Firmware befasst habe, habe ich mich entschlossen, genauer zu untersuchen, wie das alles im Inneren funktioniert. <br><br>  Im Allgemeinen müssen die Leute, die sich Arduino ausgedacht haben, ein Denkmal errichten.  Sie bildeten eine einfache und bequeme Plattform für Prototyping und Handwerk.  Eine große Anzahl von Menschen mit minimalen Kenntnissen in Elektronik und Programmierung konnte in die Welt von Arduino eintreten.  Aber all dies ist glatt und schön, wenn Sie Müll wie Blinker mit LEDs oder das Ablesen des Thermometers machen.  Sobald Sie etwas Ernstes anschwingen, müssen Sie sofort tiefer verstehen, als Sie von Anfang an wollten. <br><br>  Nach jeder hinzugefügten Bibliothek oder Klasse habe ich festgestellt, wie schnell der Speicherverbrauch wächst.  Zu diesem Zeitpunkt war ich mit mehr als 14 KB 32 KB Flash und 1300 Byte RAM (von 2 KB) beschäftigt.  Jede unachtsame Bewegung erhöhte die bereits verwendete um weitere 10 Prozent.  Aber ich habe GPS- und SD / FAT32-Bibliotheken immer noch nicht wirklich verbunden, und die Katze selbst hat geweint.  Ich musste den Disassembler- <s>Checker</s> in die <s>Hand nehmen</s> und untersuchen, was der Compiler tat. <br><br>  Ich habe insgeheim gehofft, dass der Linker nicht verwendete Funktionen auslöst.  Es stellte sich jedoch heraus, dass einige von ihnen der Linker fast vollständig einfügt.  In der Firmware habe ich die Strichzeichnungsfunktionen und einige andere aus der Bibliothek für die Arbeit mit dem Bildschirm gefunden, obwohl ich sie im Code zu diesem Zeitpunkt offensichtlich nicht aufgerufen habe.  Implizit sollten sie auch nicht aufgerufen werden - warum brauche ich eine Strichzeichnungsfunktion, wenn ich nur Buchstaben aus Bitmaps zeichne?  Mehr als 5,2 KB aus heiterem Himmel (und das zählt keine Schriftarten). <br><br>  Neben der Anzeigesteuerungsbibliothek fand ich auch: <br><br><ul><li>  2,6 kb - auf SoftwareSerial (ich habe es irgendwann in das Projekt gezogen) </li><li>  1,6 kb - I2C </li><li>  1,3 kb - HardwareSerial </li><li>  2 kb - TinyGPS </li><li>  2,5 kb auf dem eigentlichen Arduino (Initialisierung, Pins, alle Arten von Tabellen, der Haupttimer für die Funktionen millis () und delay ()), </li></ul><br>  Die Zahlen sind sehr bezeichnend, wie  Der Optimierer mischt ernsthaft Code.  Einige Funktionen können an einer Stelle beginnen, und dann kann eine andere aus einer anderen Bibliothek, die von der ersten aufgerufen wird, unmittelbar darauf folgen.  Darüber hinaus können sich am anderen Ende des Blitzes separate Zweige dieser Funktionen befinden. <br><br>  Auch im Code habe ich gefunden: <br><br><ul><li>  Bildschirmsteuerung durch SPI (obwohl ich es über I2C verbunden habe) </li><li>  Methoden von Basisklassen, die selbst nicht aufgerufen werden, weil  in den Erben neu definiert </li><li>  Destruktoren, die niemals vom Design her aufgerufen werden </li><li>  Zeichenfunktionen (und nicht alle - Teil der Funktionen, die der Linker noch ausgeführt hat) </li><li>  malloc / free während in meinem Code alle Objekte im Wesentlichen statisch sind </li></ul><br>  Aber nicht nur der Verbrauch von Flash-Speicher, sondern auch SRAM wächst sprunghaft: <br><br><ul><li>  130 Bytes - I2C </li><li>  100 Bytes - SoftwareSerial </li><li>  157 Bytes - Seriell </li><li>  558 Bytes - Anzeige (von denen 512 der Bildspeicher ist) </li></ul><br>  Nicht weniger unterhaltsam war der Abschnitt .data.  Es gibt ungefähr 700 Bytes und dieses Ding wird zu Beginn von einem Flash in den RAM geladen.  Es stellte sich heraus, dass im Speicher und zusammen mit den Initialisierungswerten Plätze für Variablen reserviert sind.  Hier leben die Variablen und Konstanten, die Sie vergessen haben, als const PROGMEM zu deklarieren. <br><br>  Darunter befand sich ein kräftiges Array mit einem „Begrüßungsbildschirm“ des Bildschirms - den Anfangswerten des Bildpuffers.  Theoretisch können Sie, wenn Sie den Bildschirm display () unmittelbar nach dem Start erstellen, die Blume und die Adafruit-Inschrift sehen, aber in meinem Fall ist es sinnlos, Flash-Speicher dafür zu verwenden. <br><br>  Der Abschnitt .data enthält auch vtables.  Sie werden von einem Flash-Laufwerk in den Speicher kopiert, anscheinend aus Gründen der Laufzeiteffizienz.  Aber Sie müssen ein ziemlich großes Stück RAM opfern - über ein Dutzend Klassen mit mehr als 150 Bytes.  Darüber hinaus scheint es keinen Compiler-Schlüssel zu geben, der unter Leistungseinbußen virtuelle Tabellen im Flash-Speicher belässt. <br><br>  Was tun?  Ich weiß es noch nicht.  Es wird davon abhängen, wie der Verbrauch weiter wachsen wird.  Für gut gefundene Pfosten müssen gnadenlos repariert werden.  Höchstwahrscheinlich muss ich alle Bibliotheken explizit in mein Projekt einbeziehen und sie dann gründlich behandeln.  Möglicherweise müssen Sie einige der Teile anders umschreiben, um das Gedächtnis zu optimieren.  Oder wechseln Sie zu leistungsfähigerer Hardware.  Auf jeden Fall weiß ich jetzt über das Problem Bescheid und es gibt eine Strategie, wie man es behebt. <br><br>  <b>UPDATE:</b> <br>  Geringe Fortschritte bei der Ressourceneffizienz.  Ich mache ein Update für diesen Teil, weil  im nächsten möchte ich mich auf ganz andere dinge konzentrieren. <br><br>  In Kommentaren gibt es einige Verwirrung über die Verwendung von C ++.  Insbesondere, warum ist er so schlecht und hält vtable in wertvollem RAM?  Im Allgemeinen sind virtuelle Funktionen, Konstruktoren und Destruktoren Overhead.  Warum?  Lass es uns herausfinden! <br><br>  Hier finden Sie Statistiken zum Speicher zu einem bestimmten Zeitpunkt des Projekts <br>  Programmgröße: 15 458 Byte (verwendet 50% eines Maximums von 30 720 Byte) (2,45 Sekunden) <br>  Minimale Speichernutzung: 1258 Byte (61% eines Maximums von 2048 Byte) <br><br>  Experiment Nr. 1 - Umschreiben auf C. <br><br>  Ich warf Klassen, schrieb alles auf Tabellen mit Zeigern auf Funktionen um.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da Bildschirme tatsächlich immer dieselbe Struktur haben, sind alle Datenelemente zu normalen globalen Variablen geworden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Statistik nach dem Refactoring </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmgröße: 14 568 Byte (verwendet 47% eines Maximums von 30 720 Byte) (2,35 Sekunden) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimale Speichernutzung: 1176 Byte (57% eines Maximums von 2048 Byte) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamt. Gewann 900 Bytes Flash und 80 Bytes RAM. Was genau den Blitz übrig ließ, grub nicht. 80 Byte RAM sind nur so groß wie die von vtable. Alle anderen Daten (Klassenmitglieder) blieben irgendwie erhalten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich muss sagen, dass ich nicht alles verdorben habe - ich wollte nur das große Ganze sehen, ohne viel Zeit damit zu verbringen. Nach dem Refactoring habe ich verschachtelte Screenshots "verloren". Mit ihnen wäre der Verbrauch etwas höher.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wichtigste bei diesem Experiment ist jedoch, dass sich die Qualität des Codes erheblich verschlechtert hat. Der Code einer Funktion ist auf mehrere Dateien verteilt. Für einige Daten gab es "einen Eigentümer" nicht mehr, einige Module begannen, in die Erinnerung anderer zu klettern. Der Code ist pauschal und hässlich geworden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experiment Nr. 2 - Bytes aus C ++ quetschen </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe mein Experiment zurückgesetzt und beschlossen, alles als Klassen zu belassen. Nur dieses Mal werden die Bildschirme für statisch verteilte Objekte ausgeführt. Die Struktur der Seiten auf meinen Bildschirmen ist festgelegt. Sie können es bei der Kompilierung angeben, ohne new / delete zu verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmgröße: 15 408 Byte (verwendet 50% eines Maximums von 30 720 Byte) (2,60 Sekunden) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimale Speichernutzung: 1273 Byte (62% eines Maximums von 2048 Byte)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der RAM-Verbrauch hat leicht zugenommen. </font><font style="vertical-align: inherit;">Aber das ist in der Tat zum Besseren. </font><font style="vertical-align: inherit;">Der Anstieg des RAM-Verbrauchs erklärt sich aus der Bewegung von Objekten vom Heap in einen statisch verteilten Speicherbereich.</font></font> Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich wurden Objekte zuvor erstellt, dies ging jedoch nicht in die Statistik. </font><font style="vertical-align: inherit;">Und jetzt werden diese Objekte explizit berücksichtigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber den Blitzverbrauch deutlich zu reduzieren, hat nicht funktioniert. </font><font style="vertical-align: inherit;">Der Code enthält weiterhin die Konstruktoren selbst, die beim Start noch aufgerufen werden.</font></font> Das heißt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Compiler konnte sie nicht im Voraus ausführen und alle Werte in vorab zugewiesene Bereiche einfügen. Und es gab immer noch Destruktoren im Code, obwohl dem Igel klar ist, dass Objekte niemals gelöscht werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zumindest ein wenig zu sparen, habe ich alle Destruktoren in der Hierarchie und insbesondere den virtuellen Destruktor in der Basisklasse gelöscht. Die Idee war, ein paar Bytes in jeder vtable freizugeben. Und dann erwartete mich eine Überraschung: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmgröße: 14 704 Bytes (verwendet 48% eines Maximums von 30 720 Bytes) (2,94 Sekunden) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimale Speichernutzung: 1211 Bytes (59% eines Maximums von 2048 Bytes)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es stellte sich heraus, dass die vtable nicht um einen Zeiger ging, sondern bereits um 2. Außerdem hatten beide mit dem Destruktor zu tun. </font><font style="vertical-align: inherit;">Nur ein Destruktor ist leer (anscheinend für Objekte auf dem Stapel) und der andere mit einem freien Aufruf, der für Objekte auf dem Heap sichtbar ist (-12 Byte RAM). </font><font style="vertical-align: inherit;">Außerdem sind die mit der Hüfte verknüpften Variablen (8 Byte) und die Beschriftungen von Objekten, die nie erstellt wurden (Bildschirm, ParentScreen - 40 Byte), weg. Der </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash-Verbrauch ist erheblich gesunken - um 700 Byte. </font><font style="vertical-align: inherit;">Nicht nur die Destruktoren selbst, sondern auch die Implementierungen malloc / free / new / delete sind verschwunden. </font><font style="vertical-align: inherit;">700 Bytes für einen leeren virtuellen Destruktor! </font><font style="vertical-align: inherit;">700 Bytes, Carl! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das würde nicht hin und her gehen, hier sind alle Zahlen an einem Ort</font></font><br><br><div class="scrollable-table"><table><tbody><tr><th></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> War </font></font></th><th>  C. </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++ </font></font></th></tr><tr><td>  Flash </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15 458 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.568 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.704 </font></font></td></tr><tr><td>  RAM </td><td>  1258 </td><td>  1176 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1211 </font></font></td></tr></tbody></table></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit: Der Verbrauch in C ++ war fast der gleiche wie in C. Gleichzeitig sind Kapselung, Vererbung und Polymorphismus Macht. </font><font style="vertical-align: inherit;">Ich bin bereit, dies mit einem gewissen Anstieg des Verbrauchs zu überbezahlen. </font><font style="vertical-align: inherit;">Vielleicht kann ich einfach nicht schön in C schreiben, aber warum, wenn ich schön in C ++ schreiben kann?</font></font><br><br><h1>  Nachwort </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfangs wollte ich am Ende des Projekts einen Artikel schreiben. </font><font style="vertical-align: inherit;">Da sich die Notizen jedoch im Verlauf der Arbeit mit hoher Geschwindigkeit ansammeln, droht der Artikel sehr groß zu sein. </font><font style="vertical-align: inherit;">Also habe ich beschlossen, es in mehrere Teile zu teilen. </font><font style="vertical-align: inherit;">In diesem Teil habe ich über die Vorbereitungsphasen gesprochen: Verstehen, was ich wirklich will, Auswahl einer Plattform, Implementierung eines Anwendungsframeworks. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im nächsten Teil möchte ich mit der Implementierung der Grundfunktionalität fortfahren - mit GPS arbeiten. </font><font style="vertical-align: inherit;">Ich habe bereits einige interessante Rechen gesehen, von denen ich erzählen möchte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seit mehr als 10 Jahren habe ich nicht ernsthaft für Mikrocontroller programmiert. </font><font style="vertical-align: inherit;">Es stellte sich heraus, dass ich durch die Fülle an Ressourcen großer Computer etwas verwöhnt wurde und es in den Realitäten von ATMega32 eng ist. </font><font style="vertical-align: inherit;">Daher musste ich über verschiedene Sicherungsoptionen nachdenken, z. B. das Trimmen der Funktionalität von Bibliotheken oder das Neugestalten der Anwendung im Namen einer effizienten Speichernutzung. </font><font style="vertical-align: inherit;">Ich schließe auch die Möglichkeit nicht aus, auf leistungsstärkere Controller umzusteigen - ATMega64 oder etwas aus der STM32-Reihe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Artikel entpuppt sich stilistisch als Bauzeitschrift. </font><font style="vertical-align: inherit;">Und ich freue mich über konstruktive Kommentare - es ist noch nicht zu spät, etwas zu ändern. </font><font style="vertical-align: inherit;">Wer möchte, kann sich meinem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt auf dem Github anschließen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ende des ersten Teils. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweiter Teil</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de401899/">https://habr.com/ru/post/de401899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de401889/index.html">Legendäre Verstärker der 80er - 90er Jahre: Lamm-Paradoxe, Johnsons Monster, integraler Killer für "warme Lampen"</a></li>
<li><a href="../de401891/index.html">3D-Scannen und 3D-Druck in Aktion (für Motorradfahrer)</a></li>
<li><a href="../de401893/index.html">Woher kommen Wasser und Sauerstoff auf der ISS?</a></li>
<li><a href="../de401895/index.html">Angreifer werden erfinderischer bei der Erstellung von Skimmern</a></li>
<li><a href="../de401897/index.html">News Pack für SLS und Orion</a></li>
<li><a href="../de401901/index.html">Mondscheinfenster zum Universum</a></li>
<li><a href="../de401903/index.html">Wie Klänge unseren Schlaf und unsere Produktivität beeinflussen</a></li>
<li><a href="../de401905/index.html">Apple Power Mac G4 Cube und seine Zeitgenossen in einer kleinen Fotobewertung</a></li>
<li><a href="../de401907/index.html">Roboterautos müssen lernen, Menschen zu verstehen.</a></li>
<li><a href="../de401909/index.html">Selbstgemachtes Sicherheitssystem basierend auf Produkten für ein Smart Home von Nootekhnika</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>