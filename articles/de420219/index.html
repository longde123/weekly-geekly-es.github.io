<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèæ üà∫ üçπ √úbersicht √ºber die Implementierungstechniken f√ºr Spiel-KI üëá üë©üèæ‚Äçüíº üìÖ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Dieser Artikel f√ºhrt Sie in eine Vielzahl von Konzepten der k√ºnstlichen Intelligenz in Spielen ein (‚ÄûGaming-KI‚Äú), damit Sie verstehen, mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√úbersicht √ºber die Implementierungstechniken f√ºr Spiel-KI</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420219/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/4db/e7b/7264dbe7b1834f3602b36deddc723163.png" alt="Bild"></div><br><h1>  Einf√ºhrung </h1><br>  Dieser Artikel f√ºhrt Sie in eine Vielzahl von Konzepten der k√ºnstlichen Intelligenz in Spielen ein (‚ÄûGaming-KI‚Äú), damit Sie verstehen, mit welchen Tools KI-Probleme gel√∂st werden k√∂nnen, wie sie zusammenarbeiten und wie Sie sie in der ausgew√§hlten Engine implementieren k√∂nnen. <br><br>  Ich gehe davon aus, dass Sie mit Videospielen vertraut sind, die sich mit mathematischen Konzepten wie Geometrie, Trigonometrie usw. auskennen.  Die meisten Codebeispiele werden in Pseudocode geschrieben, sodass Sie keine bestimmte Sprache kennen m√ºssen. <br><br><h1>  Was ist <i>eine</i> "Gaming-KI"? </h1><br>  Die Spiel-KI befasst sich haupts√§chlich mit der Auswahl von Aktionen einer Entit√§t in Abh√§ngigkeit von den aktuellen Bedingungen.  In der traditionellen KI-Literatur wird es als Management von " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">intelligenten Agenten</a> " bezeichnet.  Der Agent ist normalerweise ein Charakter im Spiel, aber es kann eine Maschine, ein Roboter oder sogar etwas Abstrakteres sein - eine ganze Gruppe von Wesenheiten, ein Land oder eine Zivilisation.  In jedem Fall ist es ein Objekt, das seine Umgebung √ºberwacht, darauf basierende Entscheidungen trifft und in √úbereinstimmung mit diesen Entscheidungen handelt.  Dies wird manchmal als Wahrnehmungs-Denk-Handlungszyklus (Sinn / Denken / Handeln) bezeichnet: <br><br><ul><li>  Wahrnehmung: Der Agent erkennt Informationen √ºber die Umgebung, die sein Verhalten beeinflussen k√∂nnen, oder wird dar√ºber informiert (z. B. Gefahren in der N√§he, gesammelte Gegenst√§nde, wichtige Punkte usw.). </li><li>  Denken: Der Agent entscheidet, wie er reagiert (z. B. entscheidet er, ob es sicher ist, Gegenst√§nde zu sammeln, ob er k√§mpfen oder sich zuerst verstecken soll). </li><li>  Aktion: Der Agent f√ºhrt Aktionen aus, um seine Entscheidungen umzusetzen (z. B. beginnt er sich auf dem Weg zum Feind oder zum Subjekt zu bewegen usw.). </li><li>  ... dann √§ndert sich aufgrund der Aktionen der Charaktere die Situation, sodass der Zyklus mit neuen Daten wiederholt werden sollte. </li></ul><a name="habracut"></a><br>  Reale KI-Aufgaben, insbesondere solche, die heute relevant sind, konzentrieren sich normalerweise auf die ‚ÄûWahrnehmung‚Äú.  Zum Beispiel sollten unbemannte Fahrzeuge Bilder der Stra√üe vor sich erhalten, diese mit anderen Daten (Radar und Lidar) kombinieren und versuchen, das zu interpretieren, was sie sehen.  Normalerweise wird diese Aufgabe durch maschinelles Lernen gel√∂st, das besonders gut mit gro√üen Arrays von verrauschten Daten aus der realen Welt (z. B. mit Fotos der Stra√üe vor dem Auto oder einigen Videobildern) funktioniert und ihnen eine Bedeutung gibt, indem sie semantische Informationen extrahieren, z. B. ‚Äû20 Meter vor mir ein anderes Auto. "  Solche Aufgaben werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Klassifizierungsprobleme genannt</a> . <br><br>  Spiele sind insofern ungew√∂hnlich, als sie kein komplexes System ben√∂tigen, um diese Informationen zu extrahieren, da sie ein wesentlicher Bestandteil der Simulation sind.  Es ist nicht erforderlich, Bilderkennungsalgorithmen auszuf√ºhren, um den Feind vor Ihnen zu erkennen.  Das Spiel <i>wei√ü,</i> dass es einen Feind gibt und kann diese Informationen direkt an den Entscheidungsprozess √ºbertragen.  Daher wird die ‚ÄûWahrnehmung‚Äú in diesem Zyklus normalerweise stark vereinfacht, und die gesamte Komplexit√§t entsteht bei der Implementierung von ‚ÄûDenken‚Äú und ‚ÄûHandeln‚Äú. <br><br><h1>  Einschr√§nkungen bei der Entwicklung der Spiel-KI </h1><br>  Die Spiel-KI ber√ºcksichtigt normalerweise die folgenden Einschr√§nkungen: <br><br><ul><li>  Im Gegensatz zum Algorithmus f√ºr maschinelles Lernen trainiert er normalerweise nicht im Voraus.  Bei der Entwicklung eines Spiels ist es unpraktisch, ein neuronales Netzwerk zu schreiben, um Zehntausende von Spielern zu √ºberwachen, um den besten Weg zu finden, gegen sie zu spielen, da das Spiel noch nicht ver√∂ffentlicht wurde und keine Spieler hat! </li><li>  Es wird normalerweise davon ausgegangen, dass das Spiel den Spieler unterhalten und herausfordern sollte und nicht ‚Äûoptimal‚Äú ist. Selbst wenn Sie Agenten trainieren k√∂nnen, um den Spielern bestm√∂glich zu widerstehen, ben√∂tigen Designer meistens etwas anderes als sie. </li><li>  Oft m√ºssen Agenten ein ‚Äûrealistisches‚Äú Verhalten haben, damit die Spieler das Gef√ºhl haben, mit menschen√§hnlichen Gegnern zu konkurrieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Das AlphaGo-Programm</a> erwies sich als viel besser als Menschen, aber die Bewegungen, die es w√§hlt, sind so weit vom traditionellen Verst√§ndnis des Spiels entfernt, dass erfahrene Gegner von einem Spiel gegen einen Au√üerirdischen sprachen.  Wenn das Spiel vorgibt, ein menschlicher Gegner zu sein, ist dies normalerweise unerw√ºnscht. Daher muss der Algorithmus so eingerichtet werden, dass er <i>plausible</i> und keine <i>idealen</i> Entscheidungen trifft. </li><li>  AI muss in Echtzeit ausgef√ºhrt werden.  In diesem Zusammenhang bedeutet dies, dass der Algorithmus f√ºr eine Entscheidung Prozessorressourcen f√ºr eine lange Zeit nicht monopolisieren kann.  Selbst 10 Millisekunden, um eine Entscheidung zu treffen, sind zu viel, da die meisten Spiele nur 16 bis 33 Millisekunden haben, um alle Vorg√§nge f√ºr den n√§chsten Frame der Grafik abzuschlie√üen. </li><li>  Im Idealfall sollte zumindest ein Teil des Systems von den Daten abh√§ngen und nicht fest codiert sein, damit Nicht-Programmierer √Ñnderungen schneller vornehmen k√∂nnen. </li></ul><br>  Nachdem wir all dies gelernt haben, k√∂nnen wir beginnen, √§u√üerst einfache Ans√§tze zur Schaffung von KI zu betrachten, die den gesamten Zyklus von "Wahrnehmung-Denken-Handeln" auf eine Weise implementieren, die Effizienz gew√§hrleistet und es Spieledesignern erm√∂glicht, komplexe Verhaltensweisen zu w√§hlen, die menschlichen Handlungen √§hnlich sind. <br><br><h1>  Einfache Entscheidungsfindung </h1><br>  Beginnen wir mit einem sehr einfachen Spiel wie Pong.  Die Aufgabe des Spielers ist es, den "Schl√§ger" so zu bewegen, dass der Ball von ihm abprallt, anstatt vorbei zu fliegen.  Die Regeln sind √§hnlich wie beim Tennis - Sie verlieren, wenn Sie den Ball verpassen.  AI hat eine relativ einfache Aufgabe, Entscheidungen √ºber die Wahl der Bewegungsrichtung des Schl√§gers zu treffen. <br><br><h2>  Hartcodierte bedingte Konstruktionen </h2><br>  Wenn wir KI schreiben wollten, um den Schl√§ger zu steuern, gibt es eine intuitive und einfache L√∂sung - bewegen Sie den Schl√§ger einfach st√§ndig so, dass er unter dem Ball liegt.  Wenn der Ball den Schl√§ger erreicht, ist er bereits in perfekter Position und kann ihn treffen. <br><br>  Ein einfacher Algorithmus hierf√ºr, ausgedr√ºckt in Pseudocode, k√∂nnte sein: <br><br><pre>  in jedem Frame / Update, w√§hrend das Spiel l√§uft:<font></font>
<font></font>
 Wenn sich der Ball links vom Schl√§ger befindet:<font></font>
<font></font>
	 Bewegen Sie den Schl√§ger nach links<font></font>
<font></font>
 Andernfalls, wenn sich der Ball rechts vom Schl√§ger befindet:<font></font>
<font></font>
	 Bewegen Sie den Schl√§ger nach rechts </pre><br>  Wenn wir davon ausgehen, dass sich der Schl√§ger mit nicht weniger Geschwindigkeit als der Ball bewegen kann, ist dies der perfekte Algorithmus f√ºr den KI-Spieler in Pong.  In F√§llen, in denen nicht so viele Wahrnehmungsdaten f√ºr die Verarbeitung vorhanden sind und nur wenige Aktionen vom Agenten ausgef√ºhrt werden k√∂nnen, ben√∂tigen wir nichts Komplizierteres. <br><br>  Dieser Ansatz ist so einfach, dass er kaum den gesamten Zyklus von "Wahrnehmung-Denken-Handeln" zeigt.  Aber er <i>ist es</i> . <br><br><ul><li>  Wahrnehmungen sind zwei if-Aussagen.  Das Spiel wei√ü, wo sich Ball und Schl√§ger befinden.  Daher fragt die KI das Spiel nach ihrer Position und ‚Äûf√ºhlt‚Äú, ob sich der Ball links oder rechts befindet. </li><li>  Das Denken besteht auch aus zwei if-Anweisungen.  Sie enthalten zwei L√∂sungen, die sich in diesem Fall gegenseitig ausschlie√üen und zur Auswahl einer von drei Aktionen f√ºhren: Bewegen Sie den Schl√§ger nach links, bewegen Sie ihn nach rechts oder tun Sie nichts, wenn der Schl√§ger bereits richtig positioniert ist. </li><li>  Eine "Aktion" besteht darin, "den Schl√§ger nach links zu bewegen" oder "den Schl√§ger nach rechts zu bewegen".  Abh√§ngig davon, wie das Spiel implementiert ist, kann dies die Form haben, die Position des Schl√§gers sofort zu verschieben oder die Geschwindigkeit und Richtung des Schl√§gers so einzustellen, dass er in einem anderen Spielcode richtig verschoben werden kann. </li></ul><br>  Solche Ans√§tze werden oft als "reaktiv" bezeichnet, da es ein einfaches Regelwerk gibt (in unserem Fall sind dies "if" -Anweisungen im Code), die auf den Zustand der Welt reagieren und sofort entscheiden, wie vorzugehen ist. <br><br><h2>  Entscheidungsb√§ume </h2><br>  Dieses Pong-Beispiel √§hnelt dem formalen KI-Konzept, das als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entscheidungsbaum bezeichnet wird</a> .  Dies ist ein System, in dem Entscheidungen in Form eines Baums angeordnet sind und der Algorithmus ihn umgehen muss, um ein ‚ÄûBlatt‚Äú zu erhalten, das die endg√ºltige Entscheidung √ºber die ausgew√§hlte Aktion enth√§lt.  Zeichnen wir anhand eines Flussdiagramms eine grafische Darstellung des Entscheidungsbaums f√ºr den Pong-Schl√§geralgorithmus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/4a2/17e/34e4a217e703a6af9b51b5cfbec7370f.png"></div><br>  Es ist zu sehen, dass es einem Baum √§hnelt, nur verkehrt herum! <br><br>  Jeder Teil des Entscheidungsbaums wird normalerweise als "Knoten" bezeichnet, da in der KI die Graphentheorie verwendet wird, um solche Strukturen zu beschreiben.  Jeder Knoten kann einer von zwei Typen sein: <br><br><ol><li>  L√∂sungsknoten: Auswahl von zwei Alternativen basierend auf der √úberpr√ºfung einer Bedingung.  Jede Alternative wird als eigener Knoten dargestellt. </li><li>  Endknoten: Eine ausgef√ºhrte Aktion, die die endg√ºltige Entscheidung des Baums darstellt. </li></ol><br>  Der Algorithmus beginnt mit dem ersten Knoten, der von der ‚ÄûWurzel‚Äú des Baums zugewiesen wurde. Danach entscheidet er entweder anhand der Bedingung, zu welchem ‚Äã‚Äãuntergeordneten Knoten er wechseln soll, oder f√ºhrt die im Knoten gespeicherte Aktion aus und funktioniert dann nicht mehr. <br><br>  Auf den ersten Blick ist der Vorteil des Entscheidungsbaums nicht offensichtlich, da er genau die gleiche Aufgabe erf√ºllt wie die if-Anweisungen aus dem vorherigen Abschnitt.  Es gibt jedoch ein sehr allgemeines System, in dem jede L√∂sung genau 1 Bedingung und 2 m√∂gliche Ergebnisse aufweist, wodurch der Entwickler AI aus den Daten erstellen kann, die die L√∂sungen im Baum darstellen, und es vermeiden muss, sie hart in den Code zu schreiben.  Es ist leicht, sich ein einfaches Datenformat zur Beschreibung eines solchen Baums vorzustellen: <br><br><table><tbody><tr><td>  <b>Knotennummer</b> </td><td>  <b>Entscheidung (oder "Ende")</b> </td><td>  <b>Aktion</b> </td><td>  <b>Aktion</b> </td></tr><tr><td>  1 </td><td>  Der Ball links vom Schl√§ger? </td><td>  Huh?  √úberpr√ºfen Sie Knoten 2 </td><td>  Nein?  √úberpr√ºfen Sie Knoten 3 </td></tr><tr><td>  2 </td><td>  <i>Das Ende</i> </td><td colspan="2">  Bewegen Sie den Schl√§ger nach links </td></tr><tr><td>  3 </td><td>  Der Ball rechts vom Schl√§ger? </td><td>  Huh?  Gehen Sie zu Knoten 4 </td><td>  Nein?  Gehen Sie zu Knoten 5 </td></tr><tr><td>  4 </td><td>  <i>Das Ende</i> </td><td colspan="2">  Bewegen Sie den Schl√§ger nach rechts </td></tr><tr><td>  5 </td><td>  <i>Das Ende</i> </td><td colspan="2">  Nichts tun </td></tr></tbody></table><br>  Aus Sicht des Codes m√ºssen wir das System zwingen, jede dieser Zeilen zu lesen, f√ºr jeden Knoten zu erstellen, die Entscheidungslogik basierend auf der zweiten Spalte anzuh√§ngen und untergeordnete Knoten basierend auf der dritten und vierten Spalte anzuh√§ngen.  Wir m√ºssen die Bedingungen und Aktionen noch manuell definieren, aber jetzt k√∂nnen wir uns ein komplexeres Spiel vorstellen, in dem Sie neue L√∂sungen und Aktionen hinzuf√ºgen und die gesamte KI konfigurieren k√∂nnen, indem Sie die einzige Textdatei √§ndern, die die Baumdefinition enth√§lt.  Wir k√∂nnen die Datei an den Spieledesigner √ºbertragen, der das Verhalten anpassen kann, ohne das Spiel neu kompilieren und den Code √§ndern zu m√ºssen - vorausgesetzt, der Code verf√ºgt bereits √ºber n√ºtzliche Bedingungen und Aktionen. <br><br>  Entscheidungsb√§ume k√∂nnen sehr leistungsf√§hig sein, wenn sie automatisch anhand einer Vielzahl von Beispielen erstellt werden (z. B. mithilfe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">des ID3-Algorithmus</a> ).  Es macht sie zu einem effektiven und leistungsstarken Tool zur Klassifizierung der Situation auf der Grundlage eingehender Daten. Dieses Thema liegt jedoch au√üerhalb des Bereichs der Designer, einfache Systeme zur Auswahl von Aktionen f√ºr Agenten zu erstellen. <br><br><h2>  Skripting </h2><br>  Oben haben wir ein Entscheidungsbaumsystem untersucht, das vorab erstellte Bedingungen und Aktionen verwendet.  Der KI-Entwickler kann den Baum nach Belieben neu erstellen, sollte sich jedoch darauf verlassen, dass der Programmierer bereits alle erforderlichen Bedingungen und Aktionen f√ºr ihn erstellt hat.  Aber was ist, wenn wir dem Designer leistungsf√§higere Werkzeuge geben, mit denen er seine eigenen Bedingungen und m√∂glicherweise seine Handlungen erstellen kann? <br><br>  Zum Beispiel, anstatt den Encoder zu zwingen, die Bedingungen "Ball links vom Schl√§ger?" Zu schreiben.  und ‚ÄûDer Ball rechts vom Schl√§ger?‚Äú ‚Äã‚Äãkann er einfach ein System erstellen, in das der Designer die Bedingungen f√ºr die √úberpr√ºfung dieser Werte unabh√§ngig schreibt.  Infolgedessen k√∂nnen die Entscheidungsbaumdaten folgenderma√üen aussehen: <br><br><table><tbody><tr><td>  <b>Knotennummer</b> </td><td>  <b>Entscheidung (oder "Ende")</b> </td><td>  <b>L√∂sung</b> </td><td>  <b>Aktion</b> </td></tr><tr><td>  1 </td><td>  <b>ball.position.x &lt;paddle.position.x</b> </td><td>  Huh?  √úberpr√ºfen Sie Knoten 2 </td><td>  Nein?  √úberpr√ºfen Sie Knoten 3 </td></tr><tr><td>  2 </td><td>  <i>Das Ende</i> </td><td colspan="2">  Bewegen Sie den Schl√§ger nach links </td></tr><tr><td>  3 </td><td>  <b>ball.position.x&gt; paddle.position.x</b> </td><td>  Huh?  √úberpr√ºfen Sie Knoten 4 </td><td>  Nein?  √úberpr√ºfen Sie Knoten 5 </td></tr><tr><td>  4 </td><td>  <i>Das Ende</i> </td><td colspan="2">  Bewegen Sie den Schl√§ger nach rechts </td></tr><tr><td>  5 </td><td>  <i>Das Ende</i> </td><td colspan="2">  Nichts tun </td></tr></tbody></table><br>  Das gleiche wie zuvor, aber jetzt haben die L√∂sungen ihren eigenen Code, √§hnlich dem bedingten Teil der if-Anweisung.  Der Code liest die Entscheidungsknoten aus der zweiten Spalte und berechnet den bedingten Ausdruck und gibt true oder false zur√ºck, anstatt nach einer bestimmten Bedingung zu suchen (z. B. ‚Äûder Ball links vom Schl√§ger?‚Äú).  Dies kann implementiert werden, indem eine <i>Skriptsprache</i> wie Lua oder Angelscript eingebettet wird, mit der der Entwickler Objekte aus dem Spiel (z. B. einen Ball und einen Schl√§ger) entnehmen und Variablen erstellen kann, auf die √ºber das Skript zugegriffen werden kann (z. B. ball.position).  Es ist normalerweise einfacher, in einer Skriptsprache zu schreiben als in C ++, und es erfordert keine vollst√§ndige Kompilierungsphase. Daher eignet es sich gut f√ºr schnelle √Ñnderungen an der Spiellogik und erm√∂glicht es weniger technisch versierten Teammitgliedern, Spielfunktionen ohne Eingreifen eines Encoders zu erstellen. <br><br>  Im obigen Beispiel wird die Skriptsprache nur zum Auswerten des bedingten Ausdrucks verwendet. Die endg√ºltigen Aktionen k√∂nnen jedoch auch im Skript beschrieben werden.  Beispielsweise k√∂nnen diese Aktionen vom Typ "Verschieben des Schl√§gers nach rechts" zu einem <code>ball.position.x += 10</code> wie " <code>ball.position.x += 10</code> werden. Das hei√üt, die Aktion wird auch im Skript festgelegt, ohne den MovePaddleRight-Funktionscode zu schreiben. <br><br>  Wenn Sie einen weiteren Schritt nach vorne machen, k√∂nnen Sie (und dies geschieht h√§ufig) zu seiner logischen Schlussfolgerung gehen und den gesamten Entscheidungsbaum in einer Skriptsprache und nicht als Liste von Datenzeilen schreiben.  Dies ist ein Code, der den oben gezeigten bedingten Konstruktionen √§hnelt, nur dass sie nicht ‚Äûfest codiert‚Äú sind - sie befinden sich in externen Skriptdateien, dh sie k√∂nnen ge√§ndert werden, ohne das gesamte Programm neu zu kompilieren.  Es ist oft sogar m√∂glich, die Skriptdatei w√§hrend der Spielausf√ºhrung zu √§ndern, wodurch Entwickler schnell verschiedene Ans√§tze zur Implementierung von KI testen k√∂nnen. <br><br><h2>  Reaktion auf Ereignisse </h2><br>  Die oben gezeigten Beispiele sind f√ºr die Einzelbildausf√ºhrung in einfachen Spielen wie Pong vorgesehen.  Die Idee ist, dass sie kontinuierlich einen Zyklus von "Wahrnehmung-Denken-Handeln" durchf√ºhren und weiterhin auf der Grundlage des letzten Zustands der Welt handeln.  In komplexeren Spielen ist es jedoch oft sinnvoller, auf ‚ÄûEreignisse‚Äú zu reagieren, dh auf wichtige √Ñnderungen in der Spielumgebung, anstatt zu rechnen. <br><br>  Dies gilt nicht besonders f√ºr Pong. W√§hlen wir also ein anderes Beispiel.  Stellen Sie sich ein Shooter-Spiel vor, in dem Feinde bewegungslos sind, bis sie einen Spieler finden. Danach beginnen sie, abh√§ngig von ihrer Klasse Aktionen auszuf√ºhren. Nahk√§mpfer k√∂nnen auf den Spieler zueilen, und Scharfsch√ºtzen bleiben auf Distanz und versuchen zu zielen.  Im Wesentlichen ist dies ein einfaches reaktives System - ‚ÄûWenn wir einen Spieler sehen, dann tun wir etwas‚Äú -, das jedoch logisch in ein Ereignis (‚Äûeinen Spieler sehen‚Äú) und eine Reaktion (eine Antwort ausw√§hlen und ausf√ºhren) unterteilt werden kann. <br><br>  Dies bringt uns zur√ºck zum Zyklus von Wahrnehmung, Denken und Handeln.  M√∂glicherweise haben wir ein Codefragment, bei dem es sich um einen Wahrnehmungscode handelt, der in jedem Frame pr√ºft, ob der Feind den Spieler sieht.  Wenn nicht, passiert nichts.  Aber wenn er sieht, erzeugt dies ein Ereignis "den Spieler sehen".  Der Code wird einen separaten Teil haben, der besagt: ‚ÄûWenn das Ereignis‚Äû Den Spieler sehen ‚Äúeintritt, dann machen wir‚Äû xyz ‚Äúund‚Äû xyz ‚Äúist jede Antwort, die wir zum Denken und Handeln verarbeiten m√∂chten.  F√ºr einen Charakterk√§mpfer k√∂nnen Sie die Lauf- und Angriffsreaktion mit dem Ereignis "Den Spieler sehen" verbinden.  F√ºr den Scharfsch√ºtzen verbinden wir die Antwortfunktion "Verstecken und Zielen" mit diesem Ereignis.  Wie in den vorherigen Beispielen k√∂nnen wir solche Zuordnungen in der Datendatei erstellen, damit sie schnell ge√§ndert werden k√∂nnen, ohne die Engine neu zu erstellen.  Dar√ºber hinaus ist es m√∂glich (und dies wird h√§ufig verwendet), solche Antwortfunktionen in einer Skriptsprache zu schreiben, damit sie bei Auftreten komplexer Ereignisse komplexe L√∂sungen erstellen k√∂nnen. <br><br><h1>  Verbesserte Entscheidungsfindung </h1><br>  Obwohl einfache reaktive Systeme sehr leistungsf√§hig sind, gibt es viele Situationen, in denen sie nicht ausreichen.  Manchmal m√ºssen wir unterschiedliche Entscheidungen treffen, je nachdem, was der Agent gerade tut, und es ist unpraktisch, sie als Bedingung darzustellen.  Manchmal gibt es einfach zu viele Bedingungen, um sie effektiv in Form eines Entscheidungsbaums oder Skripts darzustellen.  Manchmal m√ºssen wir im Voraus √ºberlegen und bewerten, wie sich die Situation √§ndern wird, bevor wir uns f√ºr den n√§chsten Schritt entscheiden.  F√ºr solche Aufgaben werden komplexere L√∂sungen ben√∂tigt. <br><br><h2>  Zustandsautomaten </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine</a> Finite-State-Maschine (FSM) ist eine M√∂glichkeit, mit anderen Worten zu sagen, dass sich ein Objekt - beispielsweise einer unserer KI-Agenten - derzeit in einem von mehreren m√∂glichen Zust√§nden befindet und von dem es ausgehen kann ein Staat zum anderen.  Es gibt eine endliche Anzahl solcher Zust√§nde, daher der Name.  Ein Beispiel aus der realen Welt ist die Ampel, die von rot nach gelb, dann nach gr√ºn und wieder zur√ºck wechselt.  An verschiedenen Orten gibt es verschiedene Lichtfolgen, aber das Prinzip ist das gleiche - jeder Zustand bedeutet etwas ("stehen", "essen", "stehen, wenn m√∂glich" usw.), zu einem bestimmten Zeitpunkt gibt es nur einen Zustand, und √úberg√§nge zwischen ihnen basieren auf einfachen Regeln. <br><br>  Dies gilt gut f√ºr NPCs in Spielen.  Die Wache kann die folgenden klar getrennten Zust√§nde haben: <br><br><ul><li>  Patrouille </li><li>  Angriff </li><li>  Flug </li></ul><br>  Und wir k√∂nnen die folgenden Regeln f√ºr den √úbergang zwischen Staaten aufstellen: <br><br><ul><li>  Wenn der Wachmann den Feind sieht, greift er an </li><li>  Wenn der Wachmann angreift, den Feind aber nicht mehr sieht, patrouilliert er wieder </li><li>  Wenn ein Wachmann angreift, aber schwer verletzt ist, entkommt er </li></ul><br>  Dieses Schema ist recht einfach und wir k√∂nnen es mit genau definierten "Wenn" -Operatoren und einer Variablen aufschreiben, in der der Zustand der Wache und verschiedene Kontrollen gespeichert werden - die Anwesenheit von Feinden in der N√§he, das Gesundheitsniveau der Wache usw.  Aber stellen Sie sich vor, wir m√ºssen noch ein paar Zust√§nde hinzuf√ºgen: <br><br><ul><li>  Warten (zwischen Patrouillen) </li><li>  Suche (wenn sich der zuvor gesehene Feind versteckt hat) </li><li>  Flucht um Hilfe (wenn der Feind entdeckt wird, aber er zu stark ist, um mit ihm allein zu k√§mpfen) </li></ul><br>  Und die Auswahlm√∂glichkeiten in jedem Bundesstaat sind normalerweise begrenzt - zum Beispiel wird ein Wachmann wahrscheinlich nicht nach einem Feind suchen wollen, der aus den Augen verloren wurde, wenn seine Gesundheit zu niedrig ist. <br><br>  Fr√ºher oder sp√§ter wird die lange Liste von "wenn &lt;x und y, aber nicht z&gt; dann &lt;p&gt;" zu umst√§ndlich, und ein formalisierter Ansatz zur Implementierung von Zust√§nden und √úberg√§ngen zwischen ihnen kann hier helfen.  Dazu betrachten wir alle Zust√§nde und listen unter jedem Zustand alle √úberg√§nge zu anderen Zust√§nden zusammen mit den daf√ºr erforderlichen Bedingungen auf.  Wir m√ºssen auch den Anfangszustand angeben, damit wir wissen, wo wir anfangen sollen, bevor wir andere Bedingungen anwenden. <br><br><table><tbody><tr><td>  <b>Zustand</b> </td><td>  <b>√úbergangsbedingung</b> </td><td>  <b>Neuer Zustand</b> </td></tr><tr><td rowspan="4">  Warten </td><td>  erwartet f√ºr 10 Sekunden </td><td>  Patrouille </td></tr><tr><td>  Der Feind ist sichtbar und der Feind ist zu stark </td><td>  Hilfesuche </td></tr><tr><td>  Der Feind ist sichtbar und viel Gesundheit </td><td>  Angriff </td></tr><tr><td>  Der Feind ist sichtbar und wenig Gesundheit </td><td>  Flug </td></tr><tr><td rowspan="4">  Patrouille </td><td>  Patrouillenroute abgeschlossen </td><td>  Warten </td></tr><tr><td>  Der Feind ist sichtbar und der Feind ist zu stark </td><td>  Hilfesuche </td></tr><tr><td>  Der Feind ist sichtbar und viel Gesundheit </td><td>  Angriff </td></tr><tr><td>  Der Feind ist sichtbar und wenig Gesundheit </td><td>  Flug </td></tr><tr><td rowspan="2">  Angriff </td><td>  Der Feind ist nicht sichtbar </td><td>  Warten </td></tr><tr><td>  wenig Gesundheit </td><td>  Flug </td></tr><tr><td>  Flug </td><td>  Der Feind ist nicht sichtbar </td><td>  Warten </td></tr><tr><td rowspan="4">  Suche </td><td>  10 Sekunden lang gesucht </td><td>  Warten </td></tr><tr><td>  Der Feind ist sichtbar und der Feind ist zu stark </td><td>  Hilfesuche </td></tr><tr><td>  Der Feind ist sichtbar und viel Gesundheit </td><td>  Angriff </td></tr><tr><td>  Der Feind ist sichtbar und wenig Gesundheit </td><td>  Flug </td></tr><tr><td>  Hilfesuche </td><td>  Freund sehen </td><td>  Angriff </td></tr><tr><td colspan="3">  <i>Ausgangszustand: Warten</i> </td></tr></tbody></table><br>  Ein solches Schema wird als Zustands√ºbergangstabelle bezeichnet.  Es ist eine komplexe (und unattraktive) Art, ein Raumschiff darzustellen.  Aus diesen Daten k√∂nnen Sie auch ein Diagramm zeichnen und eine komplexe grafische Darstellung des Verhaltens von NPCs erhalten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/a7b/262/ee0a7b2621204b58f17703a71b78ed67.png"></div><br>  Es erfasst das Wesentliche, Entscheidungen f√ºr den Agenten basierend auf der Situation zu treffen, in der er sich befindet.  Jeder Pfeil zeigt einen √úbergang zwischen Zust√§nden an, wenn die Bedingung neben dem Pfeil erf√ºllt ist. <br><br>  Bei jeder Aktualisierung (oder jedem ‚ÄûZyklus‚Äú) √ºberpr√ºfen wir den aktuellen Status des Agenten, sehen uns die Liste der √úberg√§nge an und wechseln in einen neuen Status, wenn die √úbergangsbedingung erf√ºllt ist.  Der Status "Ausstehend" pr√ºft in jedem Frame oder Zyklus, ob der 10-Sekunden-Timer abgelaufen ist.  Wenn es abgelaufen ist, wird der √úbergang in den Status "Patrouille" gestartet.  In √§hnlicher Weise pr√ºft der Status "Angriff", ob der Agent viel Gesundheit hat, und wenn ja, wechselt er in den Status "Flug". <br><br>  So werden Zustands√ºberg√§nge behandelt - aber was ist mit den Verhaltensweisen, die mit den Zust√§nden selbst verbunden sind?  Unter dem Gesichtspunkt, die Aktionen selbst f√ºr einen Staat auszuf√ºhren, gibt es normalerweise zwei Arten, Aktionen an ein Raumschiff anzuh√§ngen: <br><br><ol><li>  Aktionen f√ºr den aktuellen Status werden periodisch ausgef√ºhrt, beispielsweise in jedem Rahmen oder "Zyklus". </li><li>  Aktionen werden w√§hrend des √úbergangs von einem Zustand in einen anderen ausgef√ºhrt. </li></ol><br><br>  Ein Beispiel f√ºr den ersten Typ: Der Status "Patrouille" in jedem Frame oder Zyklus bewegt den Agenten weiterhin entlang der Patrouillenroute.  Der Status ‚ÄûAngriff‚Äú in jedem Frame oder Zyklus versucht, einen Angriff zu starten oder an eine Position zu verschieben, von der aus dies m√∂glich ist.  Usw. <br><br>  Ein Beispiel f√ºr den zweiten Typ: Betrachten Sie den √úbergang "Wenn der Feind sichtbar und der Feind zu stark ist ‚Üí Suche nach Hilfe".  Der Agent muss ausw√§hlen, wohin er umziehen m√∂chte, um Hilfe zu suchen, und diese Informationen speichern, damit der Status "Hilfesuche" wei√ü, wohin er gehen soll.  In √§hnlicher Weise kehrt der Agent im Status "Hilfesuche", wenn Hilfe gefunden wird, wieder in den Status "Angriff" zur√ºck. In diesem Moment m√∂chte er jedoch den freundlichen Charakter √ºber die Bedrohung informieren, sodass w√§hrend dieses √úbergangs m√∂glicherweise die Aktion "Einen Freund √ºber die Gefahr informieren" ausgef√ºhrt wird. <br><br>  Und hier k√∂nnen wir dieses System noch einmal unter dem Gesichtspunkt ‚ÄûWahrnehmung-Denken-Handeln‚Äú betrachten.  Die Wahrnehmung ist in die von der √úbergangslogik verwendeten Daten eingebettet.  Das Denken ist in die √úberg√§nge eingebaut, die f√ºr jeden Zustand verf√ºgbar sind.  Und die Aktion wird durch Aktionen ausgef√ºhrt, die periodisch in einem Zustand oder w√§hrend des √úbergangs zwischen Zust√§nden ausgef√ºhrt werden. <br><br>  Dieses einfache System funktioniert gut, obwohl das st√§ndige Abrufen von √úbergangsbedingungen manchmal ein kostspieliger Prozess sein kann.  Wenn beispielsweise jeder Agent in jedem Frame komplexe Berechnungen durchf√ºhren muss, um die Sichtbarkeit von Feinden zu bestimmen und √ºber den √úbergang von Patrouille zu Angriff zu entscheiden, kann dies viel Prozessorzeit in Anspruch nehmen.  Wie wir bereits gesehen haben, ist es m√∂glich, wichtige Ver√§nderungen im Zustand der Welt als ‚ÄûEreignisse‚Äú wahrzunehmen, die verarbeitet werden, nachdem sie eingetreten sind.  Anstatt die √úbergangsbedingung "Kann mein Agent den Spieler sehen?" Explizit zu √ºberpr√ºfen, k√∂nnen wir daher in jedem Frame ein separates Sichtbarkeitssystem erstellen, das diese √úberpr√ºfungen etwas seltener durchf√ºhrt (z. B. 5 Mal pro Sekunde) und den "Spieler" erstellt siehe ‚Äù, wenn der Test ausgel√∂st wird.  Es wird an die Zustandsmaschine √ºbertragen, die nun die Bedingung f√ºr den √úbergang "Empfangen des Ereignisses" Spieler sehen "" hat und entsprechend darauf reagiert.  Das resultierende Verhalten wird √§hnlich sein, mit Ausnahme einer kaum wahrnehmbaren (und sogar zunehmenden realistischen) Reaktionsverz√∂gerung, aber die Produktivit√§t wird aufgrund der √úbertragung der ‚ÄûWahrnehmung‚Äú auf einen separaten Teil des Programms steigen. <br><br><h2>  Hierarchische Zustandsmaschinen </h2><br>  All dies ist gut, aber mit gro√üen Zustandsautomaten wird es sehr unpraktisch zu arbeiten.  Wenn wir den Status "Angriff" erweitern m√∂chten, indem wir ihn durch separate Zust√§nde "Nahkampfangriff" und "Angriff aus der Ferne" ersetzen, m√ºssen wir die eingehenden √úberg√§nge von jedem gegenw√§rtigen und zuk√ºnftigen Status √§ndern, der die F√§higkeit ben√∂tigt, in den Status "Angriff" zu wechseln. <br><br>  Sie haben wahrscheinlich auch bemerkt, dass es in unserem Beispiel viele doppelte √úberg√§nge gibt.  Die meisten √úberg√§nge im Status "Ausstehend" sind identisch mit √úberg√§ngen im Status "Patrouille", und es w√§re sch√∂n, Doppelarbeit zu vermeiden, insbesondere wenn wir noch √§hnlichere Zust√§nde hinzuf√ºgen m√∂chten.  Es ist logisch, "Warten" und "Patrouillieren" in einer Gruppe "Nichtkampfstaaten" zu kombinieren, die nur einen gemeinsamen Satz von √úberg√§ngen zu Kampfstaaten aufweist.  Wenn wir diese Gruppe als Zustand darstellen, k√∂nnen wir das ‚ÄûWarten‚Äú und das ‚ÄûPatrouillieren‚Äú als ‚ÄûUnterzust√§nde‚Äú dieses Zustands betrachten, wodurch wir das gesamte System effektiver beschreiben k√∂nnen.  Ein Beispiel f√ºr die Verwendung einer separaten Umrechnungstabelle f√ºr einen neuen Nichtkampf-Unterzustand: <br><br>  <b><i>Die Hauptbedingungen:</i></b> <br><br><table><tbody><tr><td>  <b>Zustand</b> </td><td>  <b>√úbergangsbedingung</b> </td><td>  <b>Neuer Zustand</b> </td></tr><tr><td rowspan="3">  Nicht im Kampf </td><td>  Der Feind ist sichtbar und der Feind ist zu stark </td><td>  Hilfesuche </td></tr><tr><td>  Der Feind ist sichtbar und viel Gesundheit </td><td>  Angriff </td></tr><tr><td>  Der Feind ist sichtbar und wenig Gesundheit </td><td>  Flug </td></tr><tr><td rowspan="2">  Angriff </td><td>  Der Feind ist nicht sichtbar </td><td>  Nicht im Kampf </td></tr><tr><td>  wenig Gesundheit </td><td>  Flug </td></tr><tr><td>  Flug </td><td>  Der Feind ist nicht sichtbar </td><td>  Nicht im Kampf </td></tr><tr><td rowspan="4">  Suche </td><td>  10 Sekunden lang gesucht </td><td>  Nicht im Kampf </td></tr><tr><td>  Der Feind ist sichtbar und der Feind ist zu stark </td><td>  Hilfesuche </td></tr><tr><td>  Der Feind ist sichtbar und viel Gesundheit </td><td>  Angriff </td></tr><tr><td>  Der Feind ist sichtbar und wenig Gesundheit </td><td>  Flug </td></tr><tr><td>  Hilfesuche </td><td>  Freund sehen </td><td>  Angriff </td></tr><tr><td colspan="3">  <i>Ausgangszustand: Nichtkampf</i> </td></tr></tbody></table><br>  <b><i>Nichtkampfstatus:</i></b> <br><br><table><tbody><tr><td>  <b>Zustand</b> </td><td>  <b>√úbergangsbedingung</b> <br><br></td><td>  <b>Neuer Zustand</b> <br><br></td></tr><tr><td>  Warten </td><td>  erwartet f√ºr 10 Sekunden </td><td>  Patrouille </td></tr><tr><td>  Patrouille </td><td>  beendete die Patrouillenroute </td><td>  Warten </td></tr><tr><td colspan="3">  <i>Ausgangszustand: Warten</i> </td></tr></tbody></table><br>  Und in Diagrammform: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/7a0/21f/2407a021fd5e60c214d79069b86148d4.png"></div><br>  Tats√§chlich ist dies das gleiche System, nur dass es jetzt einen Nichtkampfzustand gibt, der "Patrouille" und "Warten" ersetzt, die an sich eine Zustandsmaschine mit zwei Unterzust√§nden von Patrouillieren und Warten sind.  Wenn jeder Zustand m√∂glicherweise eine Zustandsmaschine von Unterzust√§nden enthalten kann (und diese Unterzust√§nde k√∂nnen auch eine eigene Zustandsmaschine usw. enthalten), haben wir eine hierarchische Zustandsmaschine (HFSM).  Durch die Gruppierung von Verhaltensweisen au√üerhalb des Kampfes werden eine Reihe unn√∂tiger √úberg√§nge abgeschnitten, und wir k√∂nnen dasselbe f√ºr alle neuen Zust√§nde tun, die m√∂glicherweise gemeinsame √úberg√§nge aufweisen.  Wenn wir beispielsweise in Zukunft den Status "Angriff" auf den Status "Nahkampfangriff" und "Projektilangriff" erweitern, k√∂nnen dies Unterzust√§nde sein, deren √úbergang auf der Entfernung zum Feind und dem Vorhandensein von Munition basiert und die gemeinsame Ausgangs√ºberg√§nge auf der Grundlage des Gesundheitsniveaus und der Munition aufweisen andere Dinge.  Somit k√∂nnen mit einem Minimum an doppelten √úberg√§ngen komplexe Verhaltensweisen und Unterverhalten dargestellt werden. <br><br><h2>  Verhaltensb√§ume </h2><br>  Mit HFSM haben wir die M√∂glichkeit, ziemlich komplexe Verhaltensweisen auf ziemlich intuitive Weise zu erstellen.  Es f√§llt jedoch sofort auf, dass die Entscheidungsfindung in Form von √úbergangsregeln eng mit dem aktuellen Stand zusammenh√§ngt.  Viele Spiele erfordern genau das.  Durch sorgf√§ltige Verwendung der Statushierarchie wird die Anzahl der doppelten √úberg√§nge verringert.  Aber manchmal brauchen wir Regeln, die unabh√§ngig vom aktuellen Status oder in fast allen Bundesstaaten gelten.  Wenn beispielsweise die Gesundheit des Agenten auf 25% gesunken ist, m√∂chte er m√∂glicherweise weglaufen, unabh√§ngig davon, ob er sich im Kampf befindet, wartet oder spricht oder sich in einem anderen Zustand befindet.  Wir m√∂chten uns nicht daran erinnern, dass wir diese Bedingung zu jedem Zustand hinzuf√ºgen m√ºssen, den wir dem Charakter in Zukunft hinzuf√ºgen k√∂nnen.  Wenn der Designer sp√§ter sagt, dass er den Schwellenwert von 25% auf 10% √§ndern m√∂chte, m√ºssen wir nicht jeden entsprechenden √úbergang sortieren und √§ndern. <br><br>  Ideal in einer solchen Situation war ein System, in dem Entscheidungen dar√ºber, in welchem ‚Äã‚ÄãZustand man sich befindet, getrennt von den Zust√§nden selbst existieren, so dass wir nur ein Element √§ndern k√∂nnen und die √úberg√§nge immer noch korrekt verarbeitet werden.  Hier bieten sich Verhaltensb√§ume an. <br><br>  Es gibt verschiedene M√∂glichkeiten, Verhaltensb√§ume zu implementieren, aber das Wesentliche ist f√ºr die meisten gleich und dem oben genannten Entscheidungsbaum sehr √§hnlich: Der Algorithmus beginnt mit der Arbeit am ‚ÄûWurzelknoten‚Äú, und es gibt Knoten im Baum, die Entscheidungen oder Aktionen anzeigen.  Es gibt jedoch wesentliche Unterschiede: <br><br><ul><li>  Knoten geben jetzt einen von drei Werten zur√ºck: "erfolgreich" (wenn der Job abgeschlossen ist), "nicht erfolgreich" (wenn der Job nicht abgeschlossen wurde) oder "ausgef√ºhrt" (wenn der Job noch abgeschlossen ist und nicht vollst√§ndig erfolgreich war oder fehlgeschlagen ist). </li><li>  Jetzt haben wir keine Entscheidungsknoten, in denen wir aus zwei Alternativen ausw√§hlen k√∂nnen, aber es gibt Dekorationsknoten mit einem einzelnen untergeordneten Knoten.  Wenn sie "erfolgreich" sind, f√ºhren sie ihren einzigen untergeordneten Knoten aus.  Dekorationsknoten enthalten h√§ufig Bedingungen, die bestimmen, ob die Ausf√ºhrung mit Erfolg (was bedeutet, dass Sie ihren Teilbaum ausf√ºhren m√ºssen) oder fehlgeschlagen ist (dann muss nichts getan werden).  Sie k√∂nnen auch "in Bearbeitung" zur√ºckkehren. </li><li>  Durchf√ºhren von Aktionsknoten geben den Wert "running" zur√ºck, um anzuzeigen, was passiert. </li></ul><br>  Eine kleine Gruppe von Knoten kann kombiniert werden, wodurch eine gro√üe Anzahl komplexer Verhaltensweisen entsteht. Oft ist dieses Schema sehr kurz.  Beispielsweise k√∂nnen wir die hierarchische Zertifizierungsstelle des Schutzes aus dem vorherigen Beispiel in Form eines Verhaltensbaums umschreiben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b9/0f2/d18/9b90f2d18ce7b78b8a9a0673b8cde3d2.png"></div><br>  Bei Verwendung dieser Struktur ist kein expliziter √úbergang von den Zust√§nden "Warten" oder "Patrouillieren" zu den Zust√§nden "Angreifen" oder anderen Zust√§nden erforderlich. Wenn der Baum von oben nach unten und von links nach rechts durchlaufen wird, wird die richtige Entscheidung auf der Grundlage der aktuellen Situation getroffen.  Wenn der Feind sichtbar ist und der Charakter wenig Gesundheit hat, schlie√üt der Baum die Ausf√ºhrung auf dem Knoten "Flug" ab, unabh√§ngig vom zuvor ausgef√ºhrten Knoten ("Patrouille", "Warten", "Angriff" usw.). <br><br>  M√∂glicherweise stellen Sie fest, dass wir noch keinen √úbergang haben, um von "Patrol" in den Status "Warten" zur√ºckzukehren - und hier werden bedingungslose Dekorateure n√ºtzlich sein.  Der Standard-Dekorationsknoten ist "Wiederholen" - er hat keine Bedingungen, er f√§ngt nur den untergeordneten Knoten ab, der "erfolgreich" zur√ºckgibt, f√ºhrt den untergeordneten Knoten erneut aus und gibt "ausgef√ºhrt" zur√ºck.  Der neue Baum sieht folgenderma√üen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/187/487/d73/187487d733f1db9e07920b0475894bb4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verhaltensb√§ume sind recht komplex, da es oft viele verschiedene M√∂glichkeiten gibt, einen Baum zu erstellen, und die richtige Kombination von Dekorations- und Komponentenknoten zu finden, kann eine entmutigende Aufgabe sein. Es gibt auch Probleme damit, wie oft wir den Baum √ºberpr√ºfen m√ºssen (wollen wir ihn in jedem Frame durchlaufen oder wenn etwas passiert, das die Bedingungen beeinflussen kann?) Und wie der Status relativ zu den Knoten gespeichert wird (woher wissen wir, dass wir 10 Sekunden gewartet haben? Wie Werden wir herausfinden, wie viele Knoten zuletzt ausgef√ºhrt wurden, um die Sequenz korrekt zu vervollst√§ndigen?) Daher gibt es viele verschiedene Implementierungen. Beispielsweise werden auf einigen Systemen, wie dem Unreal Engine 4-Verhaltensbaumsystem, Dekorationsknoten durch Zeichenfolgendekoratoren ersetzt, die den Baum nur dann √ºberpr√ºfen, wenn sich die Dekorationsbedingungen √§ndern und ‚ÄûDienste‚Äú bereitstellen.Diese k√∂nnen mit Knoten verbunden werden und regelm√§√üige Aktualisierungen bereitstellen, auch wenn der Baum nicht erneut √ºberpr√ºft wird. Verhaltensb√§ume sind leistungsstarke Werkzeuge, aber das Erlernen ihrer korrekten Verwendung, insbesondere bei so vielen verschiedenen Implementierungen, kann eine entmutigende Aufgabe sein.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dienstprogrammbasierte Systeme </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einige Spiele erfordern das Vorhandensein vieler verschiedener Aktionen, daher erfordern sie einfachere, zentralisierte √úbergangsregeln, aber sie ben√∂tigen nicht die F√§higkeit, den Verhaltensbaum vollst√§ndig zu implementieren. </font><font style="vertical-align: inherit;">Anstatt eine explizite Auswahl oder einen Baum potenzieller Aktionen mit impliziten Fallback-Positionen zu erstellen, die durch die Struktur des Baums definiert sind, ist es vielleicht besser, einfach alle Aktionen zu untersuchen und die derzeit am besten geeignete auszuw√§hlen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist, was Utility-basierte Systeme tun - dies sind Systeme, in denen der Agent √ºber viele Aktionen verf√ºgt, und er w√§hlt eine aus, die auf dem relativen </font><i><font style="vertical-align: inherit;">Utility</font></i><font style="vertical-align: inherit;"> basiert</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jede Handlung. Die N√ºtzlichkeit ist hier ein willk√ºrliches Ma√ü f√ºr die Wichtigkeit oder den Wunsch eines Agenten, diese Aktion auszuf√ºhren. Durch das Schreiben von Dienstprogrammfunktionen zur Berechnung des Nutzens einer Aktion basierend auf dem aktuellen Status des Agenten und seiner Umgebung kann der Agent die Dienstprogrammwerte √ºberpr√ºfen und den derzeit am besten geeigneten Status ausw√§hlen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist auch einer endlichen Zustandsmaschine sehr √§hnlich, au√üer dass √úberg√§nge durch eine Bewertung jedes m√∂glichen Zustands, einschlie√ülich des aktuellen, bestimmt werden. Es ist erw√§hnenswert, dass wir im allgemeinen Fall den √úbergang zur wertvollsten Aktion w√§hlen (oder dabei sind, wenn wir diese Aktion bereits ausf√ºhren), aber f√ºr eine gr√∂√üere Variabilit√§t kann es sich um eine gewichtete zuf√§llige Auswahl handeln (wobei der wertvollsten Aktion Vorrang einger√§umt wird, aber die Auswahl anderer zugelassen wird). , eine Auswahl von zuf√§lligen Aktionen aus den Top 5 (oder einer anderen Menge) usw.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Standard-Utility-basierte System weist einen bestimmten willk√ºrlichen Bereich von Utility-Werten zu - beispielsweise von 0 (v√∂llig unerw√ºnscht) bis 100 (absolut w√ºnschenswert), und jede Aktion kann eine Reihe von Faktoren haben, die die Art und Weise beeinflussen, wie der Wert berechnet wird. </font><font style="vertical-align: inherit;">Wenn wir zu unserem Beispiel mit der Wache zur√ºckkehren, kann man sich so etwas vorstellen:</font></font><br><br><table><tbody><tr><td>  <b>Aktion</b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dienstprogrammberechnung</font></font></b> <br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hilfesuche</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Feind sichtbar und der Feind stark ist und die Gesundheit niedrig ist, geben Sie 100 zur√ºck, andernfalls 0 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flug</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Feind sichtbar ist und wenig Gesundheit vorhanden ist, geben Sie 90 zur√ºck, andernfalls 0 </font></font><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angriff</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn der Feind sichtbar ist, geben Sie 80 zur√ºck </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir warten und bereits 10 Sekunden warten, geben Sie 0 zur√ºck, andernfalls 50 </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patrouille</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir am Ende der Patrouillenroute sind, geben Sie 0 zur√ºck, andernfalls 50 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einer der wichtigsten Aspekte dieses Schemas ist, dass die √úberg√§nge zwischen Aktionen implizit ausgedr√ºckt werden - von jedem Staat aus k√∂nnen Sie v√∂llig legitim zu jedem anderen gehen. Dar√ºber hinaus sind Aktionspriorit√§ten in den zur√ºckgegebenen Dienstprogrammwerten enthalten. Wenn der Feind sichtbar ist und wenn er stark ist und der Charakter wenig Gesundheit hat, geben Werte ungleich Null die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flug-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hilfesuche zur√ºck</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hilfesuche hat</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> immer eine h√∂here Bewertung. In √§hnlicher Weise geben Aktionen au√üerhalb des Kampfes niemals mehr als 50 zur√ºck, sodass sie immer von den K√§mpfen besiegt werden. In diesem Sinne werden Aktionen und ihre Nutzenberechnungen erstellt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unserem Beispiel geben Aktionen entweder einen konstanten Nutzwert oder einen von zwei konstanten Nutzwerten zur√ºck. Ein realistischeres System verwendet einen R√ºckgabewert aus einem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kontinuierlichen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wertebereich. Beispielsweise kann die Aktion " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flucht"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> h√∂here Nutzwerte zur√ºckgeben, wenn der Zustand des Agenten geringer ist, und die Aktion " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angriff"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann niedrigere Nutzwerte zur√ºckgeben, wenn der Feind zu stark ist. Dadurch kann </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getaway</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorrang vor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assault haben.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in jeder Situation, in der der Agent das Gef√ºhl hat, nicht gesund genug zu sein, um den Feind zu bek√§mpfen. Auf diese Weise k√∂nnen Sie die relativen Priorit√§ten von Aktionen auf der Grundlage einer beliebigen Anzahl von Kriterien √§ndern, wodurch dieser Ansatz flexibler als ein Verhaltensbaum oder ein Raumschiff wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Aktion hat normalerweise mehrere Bedingungen, die die Berechnung des Nutzens beeinflussen. Um nicht alles im Code fest zu machen, k√∂nnen Sie sie in einer Skriptsprache oder als eine Reihe mathematischer Formeln schreiben, die auf verst√§ndliche Weise zusammengestellt werden. Weitere Informationen hierzu finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vortr√§gen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§sentationen von</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dave Mark ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@IADaveMark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einigen Spielen, die versuchen, das t√§gliche Leben des Charakters zu simulieren, beispielsweise in Die Sims, wird eine weitere Berechnungsebene hinzugef√ºgt, in der der Agent ‚ÄûBestrebungen‚Äú oder ‚ÄûMotivationen‚Äú hat, die sich auf die Nutzwerte auswirken. Wenn ein Charakter beispielsweise die Hungermotivation hat, kann sie mit der Zeit zunehmen, und die Berechnung des Nutzens f√ºr die Aktion "Essen" gibt immer h√∂here Werte zur√ºck, bis der Charakter diese Aktion ausf√ºhren kann, wodurch der Hunger und die Aktion " Essen ‚Äúwird auf Null oder einen Wert nahe Null reduziert.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Idee, Aktionen basierend auf dem Punktesystem auszuw√§hlen, ist ziemlich einfach. Es ist daher offensichtlich, dass Sie die Entscheidungsfindung basierend auf dem Nutzen in anderen KI-Entscheidungsprozessen verwenden und nicht vollst√§ndig durch diese ersetzen k√∂nnen. </font><font style="vertical-align: inherit;">Der Entscheidungsbaum kann den Nutzwert seiner beiden untergeordneten Knoten abfragen und den Knoten mit dem h√∂chsten Wert ausw√§hlen. </font><font style="vertical-align: inherit;">In √§hnlicher Weise kann ein Verhaltensbaum einen zusammengesetzten Dienstprogrammknoten haben, der das Dienstprogramm z√§hlt, um den untergeordneten Knoten auszuw√§hlen, der ausgef√ºhrt werden soll.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegung und Navigation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In unseren vorherigen Beispielen gab es entweder einen einfachen Schl√§ger, den wir von links nach rechts bewegen mussten, oder einen Wachcharakter, dem immer befohlen wurde, zu patrouillieren oder anzugreifen. </font><font style="vertical-align: inherit;">Aber wie genau steuern wir die Bewegung eines Agenten √ºber einen bestimmten Zeitraum? </font><font style="vertical-align: inherit;">Wie k√∂nnen wir die Geschwindigkeit einstellen, Hindernissen ausweichen und eine Route planen, wenn es unm√∂glich ist, den Endpunkt direkt zu erreichen? </font><font style="vertical-align: inherit;">Nun werden wir diese Aufgabe betrachten.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lenkung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der einfachsten Ebene ist es oft ratsam, mit jedem Agenten so zu arbeiten, als h√§tte er einen Geschwindigkeitswert, der die Geschwindigkeit und Richtung seiner Bewegung bestimmt. Diese Geschwindigkeit kann in Metern pro Sekunde, in Meilen pro Stunde, in Pixeln pro Sekunde usw. gemessen werden. Wenn wir uns an unseren Zyklus ‚ÄûWahrnehmung-Denken-Handeln‚Äú erinnern, k√∂nnen wir uns vorstellen, dass ‚ÄûDenken‚Äú Geschwindigkeit w√§hlen kann. Danach wendet ‚ÄûHandeln‚Äú diese Geschwindigkeit auf den Agenten an und bewegt ihn um die Welt. Normalerweise gibt es in Spielen ein physikalisches System, das diese Aufgabe unabh√§ngig ausf√ºhrt, den Wert der Geschwindigkeit jeder Entit√§t untersucht und ihre Position entsprechend √§ndert. Daher ist es h√§ufig m√∂glich, diesem System solche Arbeiten zuzuweisen, so dass die KI nur die Aufgabe hat, die Agentengeschwindigkeit zu w√§hlen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir wissen, wo der Agent sein m√∂chte, m√ºssen wir unsere Geschwindigkeit nutzen, um den Agenten in diese Richtung zu bewegen. </font><font style="vertical-align: inherit;">In einer trivialen Form erhalten wir die folgende Gleichung:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gew√ºnschte Reise = Zielposition - Agentenposition </font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich eine 2D-Welt vor, in der sich der Agent an den Koordinaten (-2, -2) befindet und der Zielpunkt ungef√§hr im Nordosten liegt, an den Koordinaten (30, 20), dh um dorthin zu gelangen, m√ºssen Sie sich bewegen (32, 22). </font><font style="vertical-align: inherit;">Nehmen wir an, dass diese Positionen in Metern angegeben sind. </font><font style="vertical-align: inherit;">Wenn wir entscheiden, dass sich der Agent mit einer Geschwindigkeit von 5 m / s bewegen kann, reduzieren Sie die Skalierung des Verschiebungsvektors auf diesen Wert und sehen Sie, dass wir die Geschwindigkeit ungef√§hr (4.12, 2.83) einstellen m√ºssen. </font><font style="vertical-align: inherit;">Wenn sich der Agent basierend auf diesem Wert bewegt, erreicht er erwartungsgem√§√ü in knapp 8 Sekunden den Endpunkt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnungen k√∂nnen jederzeit erneut durchgef√ºhrt werden. Befindet sich der Agent beispielsweise auf halber Strecke zum Ziel, ist die gew√ºnschte Bewegung halb so gro√ü, aber nach Skalierung auf die maximale Agentengeschwindigkeit von 5 m / s bleibt die Geschwindigkeit gleich. Dies funktioniert auch f√ºr sich bewegende Ziele (innerhalb eines angemessenen Rahmens), wodurch der Agent auf dem Weg kleine Anpassungen vornehmen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft brauchen wir jedoch mehr Kontrolle. Zum Beispiel m√ºssen wir m√∂glicherweise die Geschwindigkeit langsam erh√∂hen, als ob der Charakter zuerst stehen geblieben w√§re, dann zu einem Schritt √ºbergegangen w√§re und sp√§ter gelaufen w√§re. Auf der anderen Seite m√ºssen wir es m√∂glicherweise verlangsamen, wenn es sich dem Ziel n√§hert. Oft werden solche Aufgaben mit dem sogenannten " </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Lenkverhalten"</font></a><font style="vertical-align: inherit;"> gel√∂st.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Sie haben ihre eigenen Namen wie" Suchen "," Fliehen "," Ankunft "usw. (Auf Habr√© gibt es eine Reihe von Artikeln √ºber sie: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/post/358366/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) Ihre Idee ist, dass Sie die Agentengeschwindigkeit anwenden k√∂nnen Beschleunigungskr√§fte basierend auf einem Vergleich der Position des Agenten und der aktuellen Bewegungsgeschwindigkeit zum Ziel, wodurch verschiedene Arten der Bewegung zum Ziel geschaffen werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jedes Verhalten hat seinen eigenen, etwas anderen Zweck. Suchen und Ankommen werden verwendet, um den Agenten an sein Ziel zu verschieben. Hindernisvermeidung und -trennung helfen dem Agenten, kleine Korrekturbewegungen auszuf√ºhren, um kleine Hindernisse zwischen dem Agenten und seinem Ziel zu umgehen. Ausrichtung und Zusammenhalt zwingen die Agenten, sich zusammen zu bewegen und Herdentiere nachzuahmen. Alle Variationen verschiedener Lenkverhalten k√∂nnen miteinander kombiniert werden, h√§ufig in Form einer gewichteten Summe, um einen Gesamtwert zu erstellen, der all diese verschiedenen Faktoren ber√ºcksichtigt und einen einzelnen resultierenden Vektor erzeugt. Beispielsweise kann ein Agent das Ankunftsverhalten zusammen mit dem Verhalten von Trennung und Hindernisvermeidung verwenden, um sich von W√§nden und anderen Agenten fernzuhalten. Dieser Ansatz funktioniert gut in offenen Umgebungen, die nicht zu komplex und √ºberf√ºllt sind.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In komplexeren Umgebungen funktioniert das einfache Hinzuf√ºgen der Ausgabewerte des Verhaltens jedoch nicht sehr gut. Manchmal ist die Bewegung in der N√§he des Objekts zu langsam, oder der Agent bleibt h√§ngen, wenn das Ankunftsverhalten das Hindernis passieren m√∂chte, und das Verhalten zur Vermeidung von Hindernissen dr√ºckt den Agenten auf die Seite, von der es stammt . Daher ist es manchmal sinnvoll, Lenkverhaltensvariationen zu ber√ºcksichtigen, die komplizierter sind als das einfache Addieren aller Werte. Eine der Familien solcher Ans√§tze besteht in einer anderen Implementierung - wir ber√ºcksichtigen nicht jedes der Verhaltensweisen, die uns die Richtung geben, gefolgt von ihrer Kombination, um einen Konsens zu erzielen (was an sich m√∂glicherweise unzureichend ist). Stattdessen betrachten wir Bewegungen in verschiedene Richtungen - zum Beispiel in acht Himmelsrichtungen oder an 5-6 Punkten vor dem Agenten.Danach w√§hlen wir die besten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In komplexen Umgebungen mit Sackgassen und Kurvenoptionen ben√∂tigen wir jedoch etwas Fortgeschritteneres, und wir werden bald darauf zur√ºckkommen. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wegfindung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Lenkverhalten eignet sich hervorragend f√ºr einfache Bewegungen in einem ziemlich offenen Bereich wie einem Fu√üballfeld oder einer Arena, in der Sie mit leichten Anpassungen in einer geraden Linie von A nach B gelangen k√∂nnen, um Hindernissen auszuweichen. </font><font style="vertical-align: inherit;">Was aber, wenn der Weg zum Endpunkt komplizierter ist? </font><font style="vertical-align: inherit;">Dann brauchen wir eine ‚ÄûWegfindung‚Äú - die Welt erkunden und einen Weg entlang zeichnen, damit der Agent den Endpunkt erreicht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der einfachste Weg ist, ein Gitter auf die Welt zu legen und f√ºr jede Zelle neben dem Agenten benachbarte Zellen zu betrachten, in die wir uns bewegen k√∂nnen. Wenn einer von ihnen unser Endpunkt ist, gehen Sie die Route von jeder Zelle zur vorherigen zur√ºck, bis wir zum Anfang gelangen, und erhalten Sie so eine Route. Andernfalls wiederholen Sie den Vorgang mit den erreichbaren Nachbarn der vorherigen Nachbarn, bis wir den Endpunkt gefunden haben oder uns die Zellen ausgehen (dies bedeutet, dass es keine Route gibt). Formal wird dieser Ansatz als </font><font style="vertical-align: inherit;">BFS- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Breadth-First Search) bezeichnet, da er bei jedem Schritt in alle Richtungen (dh ‚Äûweit‚Äú) schaut, bevor die Suche verschoben wird. Der Suchraum ist wie eine Wellenfront, die sich bewegt, bis sie auf den Ort st√∂√üt, den wir gesucht haben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein einfaches Beispiel f√ºr eine Suche in Aktion. Der Suchbereich wird in jeder Phase erweitert, bis ein Endpunkt darin enthalten ist. Anschlie√üend k√∂nnen Sie den Pfad zum Anfang verfolgen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/08e/15f/f1208e15fc83ffa2b7ac3eca652854fc.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Ergebnis erhalten wir eine Liste von Gitterzellen, die die Route bilden, die Sie gehen m√ºssen. Normalerweise wird es als "Pfad" bezeichnet, Pfad (daher "Suche nach Pfaden", Pfadfindung), aber Sie k√∂nnen es sich auch als Plan vorstellen, da es sich um eine Liste von Orten handelt, die Sie besuchen m√ºssen, um Ihr Ziel, dh den Endpunkt, zu erreichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem wir die Position jeder Zelle in der Welt kennen, k√∂nnen Sie das oben beschriebene Lenkverhalten verwenden, um sich entlang der Route zu bewegen - zuerst vom Startknoten zu Knoten 2, dann von Knoten 2 zu Knoten 3 und so weiter. Der einfachste Ansatz besteht darin, sich in Richtung der Mitte der n√§chsten Zelle zu bewegen, aber es gibt auch eine beliebte Alternative - sich in Richtung der Mitte der Rippe zwischen der aktuellen Zelle und der n√§chsten zu bewegen. Dies erm√∂glicht es dem Agenten, Ecken scharfer Kurven zu schneiden, um eine realistischere Bewegung zu erzeugen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie sehen, kann dieser Algorithmus Ressourcen verschwenden, da er so viele Zellen in der ‚Äûfalschen‚Äú Richtung untersucht wie in der ‚Äûrichtigen‚Äú. Es erlaubt auch nicht, die Bewegungskosten zu ber√ºcksichtigen, bei denen einige Zellen "teurer" sein k√∂nnen als andere. Hier helfen wir einem komplexeren Algorithmus namens A *. Es funktioniert √§hnlich wie die Breitensuche, aber anstatt Nachbarn, Nachbarn, Nachbarn, Nachbarn, Nachbarn usw. blind zu erkunden, werden alle diese Knoten in eine Liste aufgenommen und so sortiert, dass immer der n√§chste untersuchte Knoten derjenige ist f√ºhrt h√∂chstwahrscheinlich zum k√ºrzesten Weg. Knoten werden nach Heuristiken sortiert (das ist in der Tat eine vern√ºnftige Annahme).Dabei werden zwei Aspekte ber√ºcksichtigt - die Kosten eines hypothetischen Wegs zur Zelle (wobei alle erforderlichen Kosten f√ºr den Umzug ber√ºcksichtigt werden) und eine Bewertung, wie weit diese Zelle vom Endpunkt entfernt ist (wodurch die Suche in die richtige Richtung verschoben wird).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/128/406/091/128406091bee8168b7b0e398386797da.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Beispiel haben wir gezeigt, dass er jeweils eine Zelle untersucht und jedes Mal eine benachbarte Zelle ausw√§hlt, die die besten (oder eine der besten) Aussichten hat. </font><font style="vertical-align: inherit;">Der resultierende Pfad √§hnelt dem Breitensuchpfad, es werden jedoch weniger Zellen untersucht, und dies ist sehr wichtig f√ºr die Leistung des Spiels auf komplexen Ebenen.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegung ohne Netz </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In den vorherigen Beispielen wurde ein der Welt √ºberlagertes Gitter verwendet, und wir haben eine Route um die Welt durch die Zellen dieses Gitters gelegt. Die meisten Spiele √ºberlappen das Raster jedoch nicht, und daher kann das √úberlagern des Rasters zu unrealistischen Bewegungsmustern f√ºhren. Dieser Ansatz erfordert m√∂glicherweise auch Kompromisse hinsichtlich der Gr√∂√üe jeder Zelle. Wenn sie zu gro√ü ist, kann sie kleine Korridore und Kurven nicht angemessen beschreiben. Wenn sie zu klein ist, kann das Durchsuchen von Tausenden von Zellen zu lang sein. Was sind die Alternativen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das erste, was wir verstehen m√ºssen, ist, dass das Gitter aus mathematischer Sicht einen " </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Graphen</font></a><font style="vertical-align: inherit;"> " liefert</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"von verbundenen Knoten. Die A * (und BFS) -Algorithmen arbeiten mit Graphen, und das Gitter ist f√ºr sie nicht wichtig. Daher k√∂nnen wir Knoten an beliebigen Positionen der Welt platzieren, und wenn es eine gerade Linie zwischen zwei verbundenen Knoten gibt, aber es gibt eine Linie zwischen dem Anfang und dem Ende Wenn es nur einen Knoten gibt, funktioniert unser Algorithmus wie zuvor und ist sogar noch besser, da weniger Knoten vorhanden sind. Dies wird h√§ufig als Wegpunktsystem bezeichnet, da jeder Knoten eine wichtige Position in der Welt angibt, die erstellt werden kann Teil einer beliebigen Anzahl von hypothetischen pu </font><font style="vertical-align: inherit;">s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/a64/90f/5b0a6490f8fac6a4101d7d6833946325.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel 1: Ein Knoten in jeder Zelle des Gitters. </font><font style="vertical-align: inherit;">Die Suche beginnt mit dem Knoten, in dem sich der Agent befindet, und endet mit der letzten Zelle.</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f9/a09/70d/0f9a0970dfadfd31260ae81c93d8792b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel 2: Eine viel kleinere Anzahl von Knoten oder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wegpunkten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Suche beginnt mit dem Agenten, durchl√§uft die erforderliche Anzahl von Wegpunkten und bewegt sich zum Endpunkt. Beachten Sie, dass das Bewegen zum ersten Punkt des Pfades s√ºdwestlich des Spielers eine ineffiziente Route ist. Daher ist normalerweise eine Nachbearbeitung des generierten Pfads erforderlich (z. B. um festzustellen, dass der Pfad direkt zum Wegpunkt im Nordosten f√ºhren kann).</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist ein ziemlich flexibles und leistungsstarkes System, das jedoch eine sorgf√§ltige Lokalisierung der Wegpunkte erfordert, da die Agenten sonst m√∂glicherweise nicht den n√§chstgelegenen Wegpunkt sehen, um die Route zu starten. Es w√§re gro√üartig, wenn wir auf der Grundlage der Geometrie der Welt automatisch Wegpunkte generieren k√∂nnten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und dann kommt Navmesh zur Rettung. Dies ist die Abk√ºrzung f√ºr Navigation Mesh. Im Wesentlichen ist dies (normalerweise) ein zweidimensionales Netz von Dreiecken, das sich ungef√§hr mit der Geometrie der Welt an den Stellen √ºberlappt, an denen das Spiel dem Agenten erlaubt, sich zu bewegen. Jedes der Dreiecke im Netz wird zu einem Knoten des Diagramms und hat bis zu drei benachbarte Dreiecke, die zu benachbarten Knoten des Diagramms werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unten finden Sie ein Beispiel aus der Unity-Engine. Die Engine analysierte die Geometrie der Welt und erstellte ein Navmesh (blau), eine Ann√§herung an die Geometrie. Jedes Nammesh-Polygon ist ein Bereich, in dem ein Agent stehen kann, und ein Agent kann von einem Polygon zu einem benachbarten wechseln. (In diesem Beispiel sind die Polygone schmaler als der Boden, auf dem sie liegen, um den Radius des Agenten zu ber√ºcksichtigen, der √ºber die Nennposition des Agenten hinausgeht.)</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/860/051/69e/86005169e23bd5d646664aeecf688b3a.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen erneut mit A * nach einer Route durch ein Netz suchen. Dies gibt uns eine ideale Route um die Welt, die die gesamte Geometrie ber√ºcksichtigt und keine √ºberm√§√üige Anzahl zus√§tzlicher Knoten (wie beim Raster) und die Beteiligung des Menschen an der Erzeugung von Punkten erfordert der Weg. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Finden von Pfaden ist ein umfangreiches Thema, f√ºr das es viele Ans√§tze gibt, insbesondere wenn Sie Details auf niedriger Ebene selbst programmieren m√ºssen. Eine der besten Quellen f√ºr zus√§tzliche Informationen ist die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Website von Amit Patel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (√úbersetzung des Artikels √ºber Habr√©: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://habr.com/post/331192/</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br><br><h1>  Planung </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Beispiel der Suche nach Pfaden haben wir festgestellt, dass es manchmal nicht ausreicht, nur eine Richtung zu w√§hlen und sich darin zu bewegen. Wir m√ºssen eine Route ausw√§hlen und mehrere Bewegungen ausf√ºhren, bevor wir den gew√ºnschten Endpunkt erreichen. Wir k√∂nnen diese Idee auf eine Vielzahl von Konzepten verallgemeinern, bei denen das Ziel nicht nur der n√§chste Schritt ist. Um dies zu erreichen, m√ºssen Sie eine Reihe von Schritten ausf√ºhren. Um zu wissen, was der erste Schritt sein sollte, m√ºssen Sie m√∂glicherweise einige Schritte nach vorne schauen. Dieser Ansatz wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Planung bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Das Finden von Pfaden kann als eine der spezifischen Anwendungen der Planung angesehen werden, aber dieses Konzept hat viel mehr Anwendungen. Zur√ºck zum Zyklus ‚ÄûWahrnehmung-Denken-Handeln‚Äú: Diese Planung ist eine Denkphase, in der versucht wird, mehrere Handlungsphasen f√ºr die Zukunft zu planen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns das Spiel Magic: The Gathering an. </font><font style="vertical-align: inherit;">Wenn Sie Ihren ersten Zug haben, haben Sie mehrere Karten in der Hand, darunter "Sumpf", der 1 Punkt schwarzes Mana ergibt, und "Wald", der 1 Punkt gr√ºnes Mana ergibt, "Exorzist", f√ºr den 1 Punkt blaues Mana ben√∂tigt wird, und " Elven Mystic ‚Äú, um zu nennen, dass du 1 Punkt gr√ºnes Mana brauchst. </font><font style="vertical-align: inherit;">(Der Einfachheit halber lassen wir die verbleibenden drei Karten weg.) Die Regeln besagen, dass ein Spieler eine Landkarte pro Spielzug spielen, seine Landkarten ‚Äûber√ºhren‚Äú kann, um Mana von ihnen zu erhalten, und so viele Zauber (einschlie√ülich Beschw√∂rungskreaturen) wirken kann. wie viel Mana er hat. </font><font style="vertical-align: inherit;">In dieser Situation spielt der Spieler wahrscheinlich "Wald", ber√ºhrt ihn, um 1 gr√ºnen Manapunkt zu erhalten, und ruft dann "Elfenmystiker". </font><font style="vertical-align: inherit;">Aber woher wei√ü eine Gaming-KI, dass eine solche Entscheidung getroffen werden muss?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einfacher "Scheduler" </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein naiver Ansatz kann darin bestehen, einfach jede Aktion der Reihe nach zu durchlaufen, bis es geeignete gibt. Wenn AI auf die Hand schaut, sieht er, dass sie ‚ÄûSwamp‚Äú spielen kann, und tut dies daher. Gibt es nach diesem Zug noch weitere Aktionen? Er kann weder Elven Mystic noch Exile Wizard beschw√∂ren, da dies gr√ºnes oder blaues Mana erfordert und der gespielte Sumpf nur schwarzes Mana gibt. Und wir k√∂nnen "Forest" nicht spielen, weil wir bereits "Swamp" gespielt haben. Das hei√üt, der KI-Spieler wird den Zug gem√§√ü den Regeln ausf√ºhren, aber er wird nicht sehr optimal sein. Zum Gl√ºck gibt es eine bessere L√∂sung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fast so wie bei der Suche nach Pfaden eine Liste von Positionen gefunden wird, um sich um die Welt zu bewegen, um zum richtigen Punkt zu gelangen, kann unser Planer eine Liste von Aktionen finden, die das Spiel in den richtigen Zustand versetzen. </font><font style="vertical-align: inherit;">So wie jede Position auf dem Pfad eine Reihe von Nachbarn hat, die potenzielle Optionen f√ºr die Auswahl des n√§chsten Schritts auf dem Pfad darstellen, hat jede Aktion im Plan Nachbarn oder ‚ÄûErben‚Äú, die Kandidaten f√ºr den n√§chsten Schritt des Plans sind. </font><font style="vertical-align: inherit;">Wir k√∂nnen nach diesen Aktionen und den folgenden Aktionen suchen, bis wir den gew√ºnschten Zustand erreicht haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen wir f√ºr unser Beispiel an, das gew√ºnschte Ergebnis w√§re "eine Kreatur beschw√∂ren, wenn m√∂glich". </font><font style="vertical-align: inherit;">Zu Beginn des Zuges haben wir nur zwei m√∂gliche Aktionen, die nach den Spielregeln zul√§ssig sind:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Spielen Sie "Swamp" (Ergebnis: "Swamp" verl√§sst die Hand und betritt das Spiel)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Spielen Sie "Wald" (Ergebnis: "Wald" verl√§sst die Hand und betritt das Spiel) </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede durchgef√ºhrte Aktion kann weitere Aktionen √∂ffnen oder schlie√üen, auch gem√§√ü den Spielregeln. </font><font style="vertical-align: inherit;">Stellen Sie sich vor, wir haben uns f√ºr "Swamp" entschieden - dies schlie√üt die M√∂glichkeit, diese Karte als potenzielle Vererbungsaktion zu spielen (da "Swamp" bereits gespielt wurde), und schlie√üt die M√∂glichkeit, "Forest" zu spielen (da Sie nach den Spielregeln nur eine Landkarte pro Spielzug spielen d√ºrfen). und f√ºgt die F√§higkeit hinzu, den ‚ÄûSumpf‚Äú zu ber√ºhren, um 1 Punkt schwarzes Mana zu erhalten - und dies ist in der Tat die einzige vererbte Aktion. </font><font style="vertical-align: inherit;">Wenn wir noch einen Schritt machen und "Touch" Swamp "ausw√§hlen, erhalten wir 1 Punkt schwarzes Mana, mit dem wir nichts tun k√∂nnen. Das ist also sinnlos.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Spielen Sie "Swamp" (Ergebnis: "Swamp" verl√§sst die Hand und betritt das Spiel)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            1.1 Ber√ºhre ‚ÄûSumpf‚Äú (Ergebnis: Wir haben ‚ÄûSumpf‚Äú ber√ºhrt, +1 schwarzes Mana ist verf√ºgbar)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        Keine Aktion mehr - ENDE</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Spielen Sie "Wald" (Ergebnis: "Wald" verl√§sst die Hand und betritt das Spiel) </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese kurze Liste von Aktionen hat uns nicht viel gebracht und zu einer ‚ÄûSackgasse‚Äú gef√ºhrt, wenn wir die Analogie mit der Suche nach Pfaden verwenden. </font><font style="vertical-align: inherit;">Daher wiederholen wir den Vorgang f√ºr den n√§chsten Schritt. </font><font style="vertical-align: inherit;">Wir spielen Forest. </font><font style="vertical-align: inherit;">Dies beseitigt auch die F√§higkeit, ‚ÄûWald‚Äú und ‚ÄûSumpf‚Äú zu spielen, und √∂ffnet sich als potenzieller (und einziger) n√§chster Schritt ‚ÄûBer√ºhre den Wald‚Äú. </font><font style="vertical-align: inherit;">Dies gibt uns 1 Punkt gr√ºnes Mana, was wiederum den dritten Schritt er√∂ffnet - "Nenne" Elfenmystiker "."</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1. Spielen Sie "Swamp" (Ergebnis: "Swamp" verl√§sst die Hand und betritt das Spiel)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            1.1 Ber√ºhre ‚ÄûSumpf‚Äú (Ergebnis: Wir haben ‚ÄûSumpf‚Äú ber√ºhrt, +1 schwarzes Mana ist verf√ºgbar)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        Keine Aktion mehr - ENDE</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Spielen Sie "Wald" (Ergebnis: "Wald" verl√§sst die Hand und betritt das Spiel)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            2.1 Ber√ºhre ‚ÄûWald‚Äú (Ergebnis: Wir haben ‚ÄûSumpf‚Äú ber√ºhrt, +1 gr√ºnes Mana ist verf√ºgbar)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                        2.1.1 Rufe "Elven Mystic" (Ergebnis: "Elven Mystic" im Spiel, -1 gr√ºnes Mana ist verf√ºgbar)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
                                    Keine Aktion mehr - ENDE </font></font></pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir alle m√∂glichen Aktionen und Aktionen untersucht, die sich aus diesen Aktionen ergeben, und einen Plan gefunden, mit dem wir die Kreatur beschw√∂ren k√∂nnen: ‚ÄûWald spielen‚Äú, ‚ÄûWald ber√ºhren‚Äú, ‚ÄûElfenmystiker‚Äú nennen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offensichtlich ist dies ein sehr vereinfachtes Beispiel, und normalerweise m√ºssen Sie das </font><i><font style="vertical-align: inherit;">beste</font></i><font style="vertical-align: inherit;"> ausw√§hlen</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Plan und nicht nur ein Plan, der einige Kriterien erf√ºllt (z. B. "eine Kreatur anrufen"). In der Regel k√∂nnen Sie potenzielle Pl√§ne anhand des Endergebnisses oder des kumulierten Nutzens der Verwendung des Plans bewerten. Zum Beispiel k√∂nnen Sie sich 1 Punkt f√ºr eine angelegte Landkarte und 3 Punkte f√ºr das Aufrufen einer Kreatur geben. "Spiel" Sumpf "ist ein kurzer Plan mit 1 Punkt, und der Plan" Wald spielen "‚Üí" Wald "ber√ºhren ‚Üí" Elfenmystiker "nennen gibt 4 Punkte, 1 f√ºr den Boden und 3 f√ºr die Kreatur. Dies ist der rentabelste verf√ºgbare Plan. Sie sollten ihn daher ausw√§hlen, wenn wir solche Punkte festgelegt haben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oben haben wir gezeigt, wie das Planen innerhalb derselben Magic: The Gathering-Bewegung funktioniert, aber es kann auch auf Aktionen in einer Reihe von Z√ºgen angewendet werden (z. B. ‚Äûeinen Bauern bewegen, um Raum f√ºr die Entwicklung des Bischofs zu schaffen‚Äú im Schach oder ‚Äûin Deckung f√ºr eine Einheit laufen‚Äú k√∂nnte in der n√§chsten Runde schie√üen, sicher "in XCOM" oder nach der allgemeinen Strategie des gesamten Spiels (z. B. "Pylone f√ºr alle anderen Protoss-Geb√§ude bauen" in Starcraft oder "einen Trank zur St√§rkung der Gesundheit trinken, bevor der Feind angegriffen wird" in Skyrim). </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verbesserte Planung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal gibt es bei jedem Schritt zu viele m√∂gliche Aktionen, und die Bewertung jeder Option ist unangemessen. Kehren wir zum Beispiel von Magic: The Gathering zur√ºck - stellen Sie sich vor, wir haben mehrere Kreaturen zur Hand, viele L√§nder wurden bereits gespielt, sodass wir jede Kreatur, mehrere Kreaturen mit ihren gespielten F√§higkeiten und ein paar weitere Landkarten auf der Hand nennen k√∂nnen - die Anzahl der Permutationen Land, Landnutzung, Beschw√∂rung von Kreaturen und Nutzung der F√§higkeiten von Kreaturen k√∂nnen Tausenden oder sogar Zehntausenden entsprechen. Gl√ºcklicherweise gibt es verschiedene M√∂glichkeiten, um dieses Problem zu l√∂sen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste hei√üt </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckw√§rtsverkettung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"(" Round Trip "). Anstatt alle Aktionen und ihre Ergebnisse zu √ºberpr√ºfen, k√∂nnen wir mit jedem der gew√ºnschten Endergebnisse beginnen und pr√ºfen, ob wir einen direkten Weg zu ihnen finden k√∂nnen. Sie k√∂nnen dies mit dem Versuch vergleichen, ein bestimmtes Blatt in einem Baum zu erreichen - es ist viel logischer Beginnen Sie von diesem Blatt und gehen Sie zur√ºck, indem Sie eine Route entlang des Stammes legen (und diese Route k√∂nnen wir dann in umgekehrter Reihenfolge gehen), als vom Stamm aus zu beginnen und zu erraten, welcher Zweig bei jedem Schritt zu w√§hlen ist. Wenn Sie am Ende beginnen und in die entgegengesetzte Richtung gehen, dann erstellt e-Plan wird viel schneller und einfacher.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Feind beispielsweise noch 1 Gesundheitspunkt hat, kann es n√ºtzlich sein, einen Plan zu finden, um "dem Feind 1 oder mehr Punkte direkten Schaden zuzuf√ºgen". Unser System wei√ü, dass es, um dieses Ziel zu erreichen, einen direkten Schadenszauber wirken muss, was wiederum bedeutet, dass es in unseren H√§nden sein muss und wir genug Mana brauchen, um es auszusprechen. Dies bedeutet wiederum, dass wir genug Land ber√ºhren m√ºssen, um dieses Mana zu erhalten, was m√∂glicherweise erfordert, dass Sie eine zus√§tzliche Landkarte spielen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere M√∂glichkeit besteht darin, nach der ersten besten √úbereinstimmung zu suchen. Anstatt alle Permutationen f√ºr eine lange Zeit zu umgehen, messen wir, wie ‚Äûgut‚Äú jeder Teilplan ist (√§hnlich wie wir ihn aus den obigen Planoptionen ausgew√§hlt haben) und berechnen jedes Mal den am besten aussehenden. Oft k√∂nnen Sie so einen optimalen oder zumindest ziemlich guten Plan erstellen, ohne jede m√∂gliche Neuanordnung von Pl√§nen ber√ºcksichtigen zu m√ºssen. A * ist eine Variation der Suche nach dem ersten besten Spiel - es untersucht zuerst die vielversprechendsten Routen, sodass es normalerweise den Weg zum Ziel finden kann, ohne zu weit in andere Richtungen klettern zu m√ºssen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine interessante und immer beliebter werdende Suchoption f√ºr das erste beste Match ist die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Monte-Carlo</font></a><font style="vertical-align: inherit;"> -Baumsuche.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Anstatt zu erraten, welche Pl√§ne bei der Auswahl jeder nachfolgenden Aktion besser sind als andere, w√§hlt diese Methode bei jedem Schritt zuf√§llige nachfolgende Aktionen aus, bis das Ende erreicht ist, an dem keine Aktionen mehr m√∂glich sind - wahrscheinlich, weil der hypothetische Plan zu einem Zustand des Sieges oder des Verlusts gef√ºhrt hat - und verwendet dieses Ergebnis, um den zuvor ausgew√§hlten Optionen mehr oder weniger Gewicht zu verleihen. Wenn der Vorgang viele Male wiederholt wird, kann die Methode eine gute Einsch√§tzung des besten n√§chsten Schritts erstellen, selbst wenn sich die Situation √§ndert (z. B. wenn der Feind versucht, unsere Pl√§ne zu vereiteln). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich w√§re keine Diskussion √ºber die Planung in Spielen vollst√§ndig, ohne die zielbasierte </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;">Aktionsplanung</font></a><font style="vertical-align: inherit;"> zu erw√§hnen</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Zielorientierte Aktionsplanung, GOAP). </font><font style="vertical-align: inherit;">Dies ist eine weit verbreitete und viel diskutierte Technik. Wenn Sie jedoch einige spezifische Implementierungsdetails ignorieren, handelt es sich im Wesentlichen um einen Roundtrip-Planer, der mit einem Ziel beginnt und versucht, eine Aktion aufzunehmen, die zu diesem Ziel f√ºhrt, oder wahrscheinlicher eine Liste von Aktionen, die zu diesem Ziel f√ºhren zum Ziel. </font><font style="vertical-align: inherit;">Wenn das Ziel beispielsweise darin bestand, ‚Äûden Spieler zu t√∂ten‚Äú und der Spieler in Deckung war, k√∂nnte der Plan lauten: ‚ÄûDen Spieler mit einer Granate rauchen‚Äú ‚Üí ‚ÄûWaffe herausziehen‚Äú ‚Üí ‚ÄûAngriff‚Äú.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalerweise gibt es mehrere Ziele, und jedes hat seine eigene Priorit√§t. </font><font style="vertical-align: inherit;">Wenn beispielsweise die Ziele mit der h√∂chsten Priorit√§t nicht erreicht werden k√∂nnen, kann keine Reihe von Aktionen den Plan "Spieler t√∂ten" bilden, da der Spieler nicht sichtbar ist. Das System kehrt dann zu den Zielen mit niedrigeren Priorit√§ten zur√ºck, z. B. "Patrouille" oder "Wache vor Ort".</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Training und Anpassung </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Anfang des Artikels haben wir erw√§hnt, dass die Gaming-KI im Allgemeinen kein ‚Äûmaschinelles Lernen‚Äú verwendet, da sie normalerweise nicht f√ºr die Echtzeitsteuerung intelligenter Agenten in der Gaming-Welt geeignet ist. </font><font style="vertical-align: inherit;">Dies bedeutet jedoch nicht, dass wir in diesem Bereich, in dem es sinnvoll ist, nichts ausleihen k√∂nnen. </font><font style="vertical-align: inherit;">M√∂glicherweise ben√∂tigen wir einen Computergegner im Shooter, um die besten Bewegungsorte f√ºr die meisten Kills zu finden. </font><font style="vertical-align: inherit;">Oder wir wollen den Gegner in einem Kampfspiel. </font><font style="vertical-align: inherit;">In Tekken oder Street Fighter lernte er beispielsweise, einen Spieler zu erkennen, der dieselben Combos verwendet, um sie zu blockieren, und zwang den Spieler, andere Taktiken anzuwenden. </font><font style="vertical-align: inherit;">Das hei√üt, es gibt Zeiten, in denen ein bestimmter Prozentsatz des maschinellen Lernens n√ºtzlich ist.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Statistiken und Wahrscheinlichkeiten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bevor wir zu komplexeren Beispielen √ºbergehen, sollten wir herausfinden, wie weit wir gehen k√∂nnen, indem wir einfach Messungen vornehmen und diese Daten verwenden, um Entscheidungen zu treffen. Nehmen wir zum Beispiel an, wir haben ein Spiel im Genre der Echtzeitstrategie, und wir m√ºssen verstehen, ob der Spieler in den ersten Minuten in Eile geht, um zu entscheiden, ob er mehr Verteidigung aufbauen will. Wir k√∂nnen das vorherige Verhalten des Spielers extrapolieren, um zu verstehen, wie das zuk√ºnftige Verhalten aussehen k√∂nnte. Zuerst haben wir keine Daten, die extrapoliert werden k√∂nnen, aber jedes Mal, wenn die KI gegen einen lebenden Feind spielt, kann sie den Zeitpunkt des ersten Angriffs aufzeichnen. Nach einigen Spielen kann diese Zeit gemittelt werden, und wir werden in Zukunft eine ausreichende Ann√§herung an die Angriffszeit des Spielers erhalten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem bei der einfachen Mittelwertbildung besteht darin, dass sie normalerweise im Laufe der Zeit in der Mitte konvergiert. Wenn ein Spieler die Rush-Strategie die ersten 20 Male verwendet und die n√§chsten 20 Male zu einer viel langsameren Strategie gewechselt hat, liegt der Durchschnittswert irgendwo in der Mitte, was uns keine n√ºtzlichen Informationen liefert. Eine M√∂glichkeit zur Verbesserung der Daten besteht darin, ein einfaches Mittelungsfenster zu verwenden, das nur die letzten 20 Datenpunkte ber√ºcksichtigt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein √§hnlicher Ansatz kann verwendet werden, um die Wahrscheinlichkeit bestimmter Aktionen zu bewerten, vorausgesetzt, die vorherigen Pr√§ferenzen des Spielers werden auch in Zukunft beibehalten. Wenn ein Spieler beispielsweise f√ºnf Mal mit einem Feuerball angreift, zwei Mal mit einem Blitz und nur einmal Hand in Hand, dann w√ºrde er h√∂chstwahrscheinlich einen Feuerball 5 von 8 Mal bevorzugen. Aus diesen Daten extrapoliert, k√∂nnen wir sehen, dass die Wahrscheinlichkeit der Verwendung einer Waffe wie folgt ist: Feuerball = 62,5%, Blitz = 25% Nahkampf = 12,5%. Unsere KI-Charaktere werden erkennen, dass sie besser dran sind, feuerfeste R√ºstungen zu finden!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere interessante Methode ist die Verwendung des Naive Bayes-Klassifikators zur Untersuchung gro√üer Mengen von Eingabedaten, um die aktuelle Situation zu klassifizieren, damit der KI-Agent entsprechend reagieren kann. Bayesianische Klassifikatoren sind wahrscheinlich am bekanntesten f√ºr ihre Verwendung in Spam-E-Mail-Filtern, in denen sie die W√∂rter in der E-Mail auswerten und mit den W√∂rtern vergleichen, die in der Vergangenheit am h√§ufigsten in Spam und normalen Nachrichten gefunden wurden. Basierend auf diesen Berechnungen entscheiden sie √ºber die Wahrscheinlichkeit, dass die zuletzt empfangene Nachricht Spam ist. Wir k√∂nnen etwas √Ñhnliches tun, nur mit weniger Input. Durch Aufzeichnen aller beobachtbaren n√ºtzlichen Informationen (z. B. erzeugte feindliche Einheiten,verwendete Zauberspr√ºche oder Forschungstechnologien) und die Verfolgung der daraus resultierenden Situation (Krieg / Frieden, Eilstrategie / Verteidigungsstrategie usw.) k√∂nnen wir basierend darauf das geeignete Verhalten ausw√§hlen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung all dieser Unterrichtstechniken kann ausreichend sein und wird h√§ufig und vorzugsweise auf die Daten angewendet, die w√§hrend des Testens vor der Ver√∂ffentlichung des Spiels gesammelt wurden. </font><font style="vertical-align: inherit;">Dies erm√∂glicht es der KI, sich an die verschiedenen Strategien der Spieletester anzupassen und sich nach der Ver√∂ffentlichung des Spiels nicht zu √§ndern. </font><font style="vertical-align: inherit;">Eine KI, die sich nach der Ver√∂ffentlichung eines Spiels an einen Spieler anpasst, kann zu vorhersehbar oder sogar zu komplex werden, um besiegt zu werden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einfache gewichtsbasierte Anpassung </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen wir noch einen Schritt weiter. </font><font style="vertical-align: inherit;">Anstatt nur die Eingabedaten zu verwenden, um zwischen diskreten vordefinierten Strategien zu w√§hlen, k√∂nnen Sie die Werte √§ndern, die die Entscheidungsfindung beeinflussen. </font><font style="vertical-align: inherit;">Wenn wir die Spielwelt und die Spielregeln gut verstehen, k√∂nnen wir Folgendes tun:</font></font><br><br><ul><li>              (   ); </li><li>    ¬´¬ª       ; </li><li>         . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich einen Computeragenten vor, der in einem Ego-Shooter R√§ume auf einer Karte ausw√§hlen kann. Jedes Zimmer hat ein Gewicht, das bestimmt, wie w√ºnschenswert es ist, dieses Zimmer zu besuchen. Anfangs haben alle R√§ume die gleiche Bedeutung. Bei der Auswahl eines Raums w√§hlt die KI ihn zuf√§llig aus, jedoch unter dem Einfluss dieser Gewichte. Stellen Sie sich nun vor, ein Computeragent, der get√∂tet wird, merkt sich, in welchem ‚Äã‚ÄãRaum dies geschieht, und reduziert sein Gewicht, sodass es weniger wahrscheinlich ist, dass er in Zukunft dorthin zur√ºckkehrt. Stellen Sie sich vor, ein Computeragent hat einen Mord begangen. Dann kann er das Gewicht des Raumes erh√∂hen, in dem er sich befindet, um es in die Liste der Pr√§ferenzen aufzunehmen. Wenn also ein Raum f√ºr den KI-Spieler besonders gef√§hrlich wird, beginnt er dies in Zukunft zu vermeiden, und wenn ein anderer Raum der KI erlaubt, viele Morde zu erleiden,dann wird er dorthin zur√ºckkehren.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Markov-Modelle </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was w√§re, wenn wir die gesammelten Daten f√ºr Prognosen verwenden wollten? </font><font style="vertical-align: inherit;">Wenn wir beispielsweise jeden Raum aufzeichnen, in dem wir einen Spieler f√ºr einen bestimmten Zeitraum sehen, k√∂nnen wir vern√ºnftigerweise vorhersagen, in welchen Raum er wechseln kann. </font><font style="vertical-align: inherit;">Indem wir sowohl den aktuellen Raum, in dem sich der Spieler befindet, als auch den vorherigen verfolgen und diese Wertepaare aufzeichnen, k√∂nnen wir berechnen, wie oft jede der vorherigen Situationen zur n√§chsten Situation f√ºhrt, und dieses Wissen f√ºr Prognosen verwenden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor, es gibt drei R√§ume - rot, gr√ºn und blau - und wir haben w√§hrend der Spielsitzung solche Beobachtungen erhalten:</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der erste Raum, in dem der Spieler gesehen wird</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesamtbeobachtungen</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nebenzimmer</font></font></b> </td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie oft gesehen</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozentsatz</font></font></b> <br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rot </font></font><br><br></td><td rowspan="3">  10 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rot </font></font><br><br></td><td>  2 <br><br></td><td>  20% <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√ºn </font></font><br><br></td><td>  7 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 70% </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blau </font></font><br><br></td><td>  1 <br><br></td><td>  10% <br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√ºn </font></font><br><br></td><td rowspan="3">  10 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rot </font></font><br><br></td><td>  3 <br><br></td><td>  30% <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√ºn </font></font><br><br></td><td>  5 <br><br></td><td>  50% <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blau </font></font><br><br></td><td>  2 <br><br></td><td>  20% <br><br></td></tr><tr><td rowspan="3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blau </font></font><br><br></td><td rowspan="3">  8 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rot </font></font><br><br></td><td>  6 <br><br></td><td>  75% <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gr√ºn </font></font><br></td><td>  2 <br><br></td><td>  25% <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blau </font></font><br><br></td><td>  0 <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0% </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anzahl der Erkennungen in jedem der R√§ume ist ziemlich gleichm√§√üig, so dass wir nicht verstehen, welcher der R√§ume ein guter Ort f√ºr einen Hinterhalt sein kann. Daten k√∂nnen durch die Tatsache verzerrt werden, dass Spieler gleichm√§√üig auf der Karte erscheinen und mit gleicher Wahrscheinlichkeit in einem dieser drei R√§ume erscheinen. Daten zum Besuch des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√§chsten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Raums k√∂nnen jedoch hilfreich sein und uns helfen, die Bewegung des Spielers auf der Karte vorherzusagen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen sofort feststellen, dass der gr√ºne Raum f√ºr Spieler sehr attraktiv ist - die meisten Spieler aus dem roten Raum wurden gr√ºn, und 50% der Spieler, die im gr√ºnen Raum zu sehen sind, bleiben beim n√§chsten Check dort. Wir k√∂nnen auch feststellen, dass das blaue Zimmer ein ziemlich unattraktiver Ort ist. Menschen wechseln selten von roten oder gr√ºnen R√§umen zu blauen und es scheint, dass niemand lange Zeit darin verweilen m√∂chte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber die Daten sagen uns etwas Spezifischeres - sie sagen, dass ein Spieler, der sich im blauen Raum befindet und ihr folgt, eher Rot als Gr√ºn w√§hlt. Trotz der Tatsache, dass der gr√ºne Raum ein viel beliebterer Ort ist als der rote, ist die Tendenz etwas entgegengesetzt, wenn sich der Spieler im blauen Raum befindet. Es scheint, dass der n√§chste Zustand (d. H. Der Raum, in dem er sich weiter bewegt) vom vorherigen Zustand abh√§ngt (d. H. Der Raum, in dem er sich jetzt befindet), sodass diese Daten es uns erm√∂glichen, bessere Vorhersagen √ºber das Verhalten von Spielern zu erstellen als mit unabh√§ngiger Beobachtungsz√§hlung. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Idee, dass wir das Wissen √ºber den vorherigen Zustand nutzen k√∂nnen, um den zuk√ºnftigen Zustand vorherzusagen, wird als </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Markov-Modell bezeichnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und √§hnliche Beispiele, in denen wir Ereignisse genau gemessen haben (zum Beispiel ‚Äûin welchem ‚Äã‚ÄãRaum sich der Spieler befindet‚Äú), werden Markov-Ketten genannt. Da sie die Wahrscheinlichkeit eines √úbergangs zwischen aufeinanderfolgenden Zust√§nden darstellen, werden sie h√§ufig grafisch in Form einer endlichen Zustandsmaschine dargestellt, in deren N√§he jeder √úbergang angegeben ist, dessen Wahrscheinlichkeit angegeben ist. Fr√ºher haben wir eine Zustandsmaschine verwendet, um den Verhaltenszustand darzustellen, in dem sich der Agent befindet. Dieses Konzept kann jedoch auf alle Arten von Zust√§nden erweitert werden, unabh√§ngig davon, ob sie dem Agenten zugeordnet sind oder nicht. In unserem Fall geben Staaten die vom Agenten belegten R√§ume an. Es wird so aussehen:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e43/53b/691/e4353b691807e7476a2255f91dc2f248.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein einfacher Ansatz, um die relative Wahrscheinlichkeit des √úbergangs in verschiedene Zust√§nde anzuzeigen, wodurch AI die M√∂glichkeit erh√§lt, den n√§chsten Zustand vorherzusagen. </font><font style="vertical-align: inherit;">Wir k√∂nnen jedoch noch weiter gehen, indem wir ein System schaffen, das in zwei oder mehr Schritten in die Zukunft blickt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Spieler im gr√ºnen Raum entdeckt wurde, verwenden wir Daten, die uns sagen, dass eine 50-prozentige Wahrscheinlichkeit besteht, dass er sich bei der n√§chsten Beobachtung noch im gr√ºnen Raum befindet. </font><font style="vertical-align: inherit;">Aber wie hoch ist die Wahrscheinlichkeit, dass er zum dritten Mal dabei bleibt? </font><font style="vertical-align: inherit;">Dies ist nicht nur die Wahrscheinlichkeit, dass er f√ºr zwei Beobachtungen im gr√ºnen Raum bleibt (50% * 50% = 25%), sondern auch die Wahrscheinlichkeit, dass er ihn verl√§sst und zur√ºckkehrt. </font><font style="vertical-align: inherit;">Hier ist eine neue Tabelle mit vorherigen Werten, die auf drei Beobachtungen angewendet wurden: eine aktuelle und zwei hypothetische in der Zukunft.</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beobachtung 1</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hypothetische Beobachtung 2</font></font></b> <br><br></td><td> <b>  </b> <br><br></td><td> <b>  3</b> <br><br></td><td> <b>  </b> <br><br></td><td> <b> </b> <br><br></td></tr><tr><td rowspan="10">  <br></td><td rowspan="3">  <br><br></td><td rowspan="3">  30% <br><br></td><td>  <br><br></td><td>  20% <br><br></td><td> 6% <br><br></td></tr><tr><td> <b></b> <br><br></td><td> 70% <br><br></td><td> <b>21%</b> <br><br></td></tr><tr><td>  <br><br></td><td>  10% <br><br></td><td> 3% <br><br></td></tr><tr><td rowspan="3">  <br></td><td rowspan="3">  50% <br><br></td><td>  <br><br></td><td>  30% <br><br></td><td> 15% <br><br></td></tr><tr><td> <b></b> <br><br></td><td>  50% <br><br></td><td> <b>25%</b> <br><br></td></tr><tr><td>  <br><br></td><td>  20% <br><br></td><td>  10% <br><br></td></tr><tr><td rowspan="3">  <br><br></td><td rowspan="3">  20% <br><br></td><td>  <br><br></td><td>  75% <br><br></td><td> 15% <br><br></td></tr><tr><td> <b></b> <br><br></td><td>  25% <br><br></td><td> <b>5%</b> <br><br></td></tr><tr><td>  <br><br></td><td> 0% <br><br></td><td> 0% <br><br></td></tr><tr><td></td><td></td><td></td><td> <i>:</i> <br><br></td><td> 100% </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sehen wir, dass die Wahrscheinlichkeit, einen Spieler nach 2 Beobachtungen im gr√ºnen Raum zu sehen, 51% betr√§gt - 21% dessen, was er aus dem roten Raum kommt, 5% dessen, was wir sehen, wenn der Spieler den blauen Raum besucht, und 25% dessen, was er die ganze Zeit ist wird im gr√ºnen Raum bleiben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Tabelle ist nur ein visueller Hinweis, eine Prozedur erfordert nur eine Multiplikation der Wahrscheinlichkeiten in jeder Phase. Dies bedeutet, dass wir weit in die Zukunft schauen k√∂nnen, aber mit einer wesentlichen Einschr√§nkung: Wir gehen davon aus, dass die Wahrscheinlichkeit, einen Raum zu betreten, vollst√§ndig davon abh√§ngt, in welchem ‚Äã‚ÄãRaum wir uns gerade befinden. Diese Vorstellung, dass der zuk√ºnftige Zustand nur vom aktuellen abh√§ngt, wird als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Markov-Eigenschaft bezeichnet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Obwohl es uns erlaubt, leistungsstarke Werkzeuge wie Markov-Ketten zu verwenden, ist es normalerweise nur eine Ann√§herung. </font><font style="vertical-align: inherit;">Spieler k√∂nnen sich aufgrund anderer Faktoren wie Gesundheitszustand und Munitionsmenge dazu entschlie√üen, R√§ume zu besuchen. Da wir diese Informationen nicht als Teil der Bedingung aufzeichnen, sind unsere Vorhersagen weniger genau.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N Gramm </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir zu unserem Beispiel mit Combo-Erkennung in einem Kampfspiel zur√ºck. Dies ist eine √§hnliche Situation, in der wir den zuk√ºnftigen Zustand basierend auf der Vergangenheit vorhersagen m√∂chten (um zu entscheiden, wie ein Angriff blockiert oder ihm ausgewichen werden soll), aber anstatt einen einzelnen Zustand oder ein einzelnes Ereignis zu untersuchen, werden wir </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequenzen von</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ereignissen betrachten, die eine Kombinationsbewegung erzeugen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine M√∂glichkeit, dies zu tun, besteht darin, jede Spielereingabe (z. B. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Block</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) im Puffer </font><font style="vertical-align: inherit;">zu speichern </font><font style="vertical-align: inherit;">und den gesamten Puffer als Ereignis zu schreiben. Stellen Sie sich vor, ein Spieler dr√ºckt st√§ndig </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Tritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Tritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Angriff ‚Äû </font><i><font style="vertical-align: inherit;">Todeskrebs</font></i><font style="vertical-align: inherit;"> ‚Äú zu verwenden.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", und das KI-System speichert alle Eingaben des Spielers im Puffer und merkt sich die letzten 3 Eintr√§ge, die bei jedem Schritt verwendet wurden. </font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geben Sie ein</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine vorhandene Eingabesequenz</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neuer Eingangsspeicher</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td>  <i>Nein</i> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Handschlag </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick </font></font><br><br></td><td>  <i>Nein</i> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treten, treten, treten, treten </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick, Kick, Kick </font></font><br><br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handschlag</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treten, treten, treten, treten, treten</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kick, Kick, Kick</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blockieren </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treten, Treten, Treten, Treten, Treten, Blockieren </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treten, treten, blockieren </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treten, Treten, Treten, Treten, Treten, Blockieren, Treten </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treten, blocken, treten </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kick </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Treten, Treten, Treten, Treten, Treten, Blockieren, Treten, Treten </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blockieren, treten, treten </font></font><br><br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handschlag</font></font></b> <br><br></td><td> <b> ,  ,  ,  ,  , ,  ,  ,  </b> <br><br></td><td> <b> ,  ,  </b> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(In fetten Linien f√ºhrt der Spieler den Angriff ‚ÄûSuperbuck of Death‚Äú aus.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen alle Zeiten </font><font style="vertical-align: inherit;">anzeigen </font><font style="vertical-align: inherit;">, in denen der Spieler in der Vergangenheit einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gew√§hlt hat </font><font style="vertical-align: inherit;">, gefolgt von einem weiteren </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und feststellen, dass die n√§chste Eingabe immer ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlag ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Auf diese Weise kann der KI-Agent vorhersagen, dass ein Spieler, der gerade einen Tritt gefolgt von einem Tritt gew√§hlt hat, h√∂chstwahrscheinlich als n√§chstes einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausw√§hlt </font><font style="vertical-align: inherit;">und so den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todes-Superkulak startet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Auf diese Weise kann die KI entscheiden, eine Aktion zu w√§hlen, die diesem Schlag entgegenwirkt, z. B. Blockieren oder Ausweichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solche Ereignissequenzen werden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-Gramm genannt.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dabei ist N die Anzahl der gespeicherten Elemente. Im vorherigen Beispiel waren es 3 Gramm, auch Trigramm genannt, dh die ersten beiden Elemente werden verwendet, um das dritte vorherzusagen. Im 5-Gramm wird das f√ºnfte f√ºr die ersten 4 Elemente vorhergesagt und so weiter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entwickler sollten die Gr√∂√üe von N-Gramm sorgf√§ltig ausw√§hlen (manchmal auch als Reihenfolge bezeichnet). Je kleiner die Anzahl, desto weniger Speicher wird ben√∂tigt, denn je kleiner die Anzahl der zul√§ssigen Permutationen ist, desto weniger Verlauf wird gespeichert, was bedeutet, dass der Kontext verloren geht. Zum Beispiel enth√§lt ein 2-Gramm (auch als "Bigram" bezeichnet) Aufzeichnungen zum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Aufzeichnungen zum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kann aber keinen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> speichern </font><font style="vertical-align: inherit;">.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hand kick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kann daher diese combo nicht verfolgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf der anderen Seite, je gr√∂√üer die Reihenfolge, desto mehr Speicher wird ben√∂tigt, und das System wird h√∂chstwahrscheinlich schwieriger zu trainieren sein, da wir viel mehr m√∂gliche Permutationen haben werden, was bedeutet, dass wir niemals dasselbe zweimal treffen k√∂nnen. Wenn es zum Beispiel drei m√∂gliche Eingaben gibt ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kick</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Block</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und wir ein 10-Gramm verwenden, gibt es fast 60.000 verschiedene Permutationen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Bigram-Modell ist im Wesentlichen eine Markov-Trivialkette - jedes Paar ‚Äûzuk√ºnftiger Zustand / aktueller Zustand‚Äú ist ein Bigram und wir k√∂nnen den zweiten Zustand basierend auf dem ersten vorhersagen. Trigramme und gro√üe N-Gramme k√∂nnen auch als Markov-Ketten betrachtet werden, bei denen alle Elemente des N-Gramms mit Ausnahme des letzten den ersten Zustand bilden und das letzte Element der zweite Zustand ist. In unserem Beispiel wird ein Kampfspiel mit der Wahrscheinlichkeit des √úbergangs vom Zustand der dargestellten </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">treten und tritt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in dem Zustand </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kick, dann Punch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Indem wir mehrere Elemente des Eingabeverlaufs als ein einzelnes Element wahrnehmen, transformieren wir die Eingabesequenz im Wesentlichen in ein Fragment des Zustands, wodurch wir eine Markov-Eigenschaft erhalten, mit der wir Markov-Ketten verwenden k√∂nnen, um die n√§chste Eingabe vorherzusagen, dh zu erraten, welche Kombinationsbewegung folgen wird.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wissensrepr√§sentation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben verschiedene M√∂glichkeiten besprochen, Entscheidungen zu treffen, Pl√§ne zu erstellen und Prognosen zu erstellen. Alle M√∂glichkeiten basieren auf den Beobachtungen des Agenten √ºber den Zustand der Welt. </font><font style="vertical-align: inherit;">Aber wie k√∂nnen wir die gesamte Spielwelt effektiv beobachten? </font><font style="vertical-align: inherit;">Oben haben wir gesehen, dass die Art und Weise, wie die Geometrie der Welt dargestellt wird, die Bewegung entlang der Welt stark beeinflusst. Daher ist es leicht vorstellbar, dass dies auch f√ºr andere Aspekte der Spiel-KI gilt. </font><font style="vertical-align: inherit;">Wie k√∂nnen wir alle erforderlichen Informationen auf optimale Weise (so dass sie h√§ufig aktualisiert werden und f√ºr viele Agenten zug√§nglich sind) und praktisch (damit die Informationen leicht im Entscheidungsprozess verwendet werden k√∂nnen) sammeln und organisieren? </font><font style="vertical-align: inherit;">Wie kann man einfache </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wissen umwandeln</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">F√ºr verschiedene Spiele k√∂nnen die L√∂sungen unterschiedlich sein, es gibt jedoch mehrere g√§ngigste Ans√§tze.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tags / Tags </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manchmal haben wir bereits eine gro√üe Menge n√ºtzlicher Daten, und das einzige, was wir brauchen, ist eine gute M√∂glichkeit, sie zu kategorisieren und danach zu suchen. Zum Beispiel kann es in der Spielwelt viele Objekte geben, von denen einige einen guten Schutz vor feindlichen Kugeln bieten. Oder wir haben zum Beispiel eine Reihe von aufgezeichneten Audiodialogen, die in bestimmten Situationen anwendbar sind, und wir brauchen eine M√∂glichkeit, sie schnell herauszufinden. Der naheliegende Schritt besteht darin, eine kleine zus√§tzliche Information hinzuzuf√ºgen, mit der Sie suchen k√∂nnen. Solche Fragmente werden </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tags</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder Tags genannt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kehren wir zum Beispiel des Tierheims zur√ºck. In der Spielwelt kann es eine Reihe von Objekten geben - Kisten, F√§sser, Grashalme, Drahtz√§une. Einige von ihnen eignen sich zum Schutz, zum Beispiel Kisten und F√§sser, andere nicht. Wenn unser Agent die Aktion ‚ÄûIn den Schutz verschieben‚Äú ausf√ºhrt, muss er daher nach Objekten in der N√§he suchen und geeignete Kandidaten identifizieren. Er kann nicht nur nach Namen suchen - vielleicht hat das Spiel Crate_01, Crate_02 bis Crate_27 und wir m√∂chten nicht nach all diesen Namen im Code suchen. Wir m√∂chten dem Code nicht jedes Mal einen anderen Namen hinzuf√ºgen, wenn der K√ºnstler eine neue Variante der Box oder des Fasses erstellt. Stattdessen k√∂nnen Sie nach jedem Namen suchen, der das Wort "Crate" enth√§lt, aber eines Tages kann ein K√ºnstler "Broken_Crate" mit einem riesigen Loch hinzuf√ºgen, das als Unterschlupf ungeeignet ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher erstellen wir stattdessen ein "COVER" -Tag und bitten K√ºnstler und Designer, dieses Tag an alle Objekte anzuh√§ngen, die als Unterschlupf verwendet werden k√∂nnen. Wenn sie allen F√§ssern und (ganzen) Feldern ein Tag hinzuf√ºgen, muss die KI-Prozedur nur Objekte mit diesem Tag finden, und sie wei√ü, dass die Objekte f√ºr diesen Zweck geeignet sind. Das Tag funktioniert auch dann, wenn die Objekte sp√§ter umbenannt werden, und kann in Zukunft zu Objekten hinzugef√ºgt werden, ohne dass unn√∂tige √Ñnderungen am Code vorgenommen werden m√ºssen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Code werden Tags normalerweise als Zeichenfolgen dargestellt. Wenn jedoch alle verwendeten Tags bekannt sind, k√∂nnen Sie Zeichenfolgen in eindeutige Zahlen konvertieren, um Platz zu sparen und die Suche zu beschleunigen. In einigen Engines sind Tags integrierte Funktionen, z. B. in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unreal Engine 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daher reicht es aus, die Auswahl der darin enthaltenen Tags zu bestimmen und sie f√ºr den beabsichtigten Zweck zu verwenden. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intelligente Objekte </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mithilfe von Tags k√∂nnen Sie der Umgebung des Agenten zus√§tzliche Informationen hinzuf√ºgen, um die verf√ºgbaren Optionen zu ermitteln. So werden Anforderungen wie "Finde alle Orte, an denen ich mich am n√§chsten verstecken kann" oder "Finde alle Feinde in der N√§he, die Zauber wirken k√∂nnen" effizient und ausgef√ºhrt mit minimalem Aufwand f√ºr neue Spielressourcen gearbeitet. </font><font style="vertical-align: inherit;">Manchmal enthalten die Tags jedoch nicht gen√ºgend Informationen f√ºr ihre vollst√§ndige Verwendung.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich einen Simulator einer mittelalterlichen Stadt vor, in der Abenteurer dort herumlaufen, wo sie bei Bedarf trainieren, k√§mpfen und sich entspannen m√∂chten. Wir k√∂nnen Trainingsorte in verschiedenen Teilen der Stadt einrichten und ihnen das Tag ‚ÄûTRAINING‚Äú zuweisen, damit die Charaktere leicht einen Platz f√ºr das Training finden k√∂nnen. Aber stellen wir uns vor, einer von ihnen ist ein Schie√üstand f√ºr Bogensch√ºtzen und der andere eine Schule von Zauberern. In jedem dieser F√§lle m√ºssen wir unsere Animation zeigen, da sie unter dem allgemeinen Namen "Training" unterschiedliche Aktionen darstellen und nicht jeder Abenteurer an beiden Trainingsarten interessiert ist. Sie k√∂nnen noch tiefer gehen und ARCHERY-TRAINING- und MAGIC-TRAINING-Tags erstellen, Trainingsverfahren voneinander trennen und sie in die einzelnen Animationen einbetten. Dies hilft, das Problem zu l√∂sen. Aber stell dir vordass die Designer sp√§ter erkl√§ren werden "Lassen Sie uns eine Robin Hood Schule haben, in der Sie Bogenschie√üen und Schwertkampf lernen k√∂nnen"! Und dann, wenn wir den Schwertkampf hinzuf√ºgen, bitten sie um die Schaffung der Gandalf-Akademie f√ºr Zauberspr√ºche und Schwertk√§mpfe. Infolgedessen m√ºssen wir mehrere Tags f√ºr jeden Ort speichern und nach verschiedenen Animationen suchen, je nachdem, welchen Aspekt des Trainings der Charakter ben√∂tigt usw.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine andere M√∂glichkeit besteht darin, Informationen zusammen mit dem Einfluss, den sie auf den Spieler haben, direkt im Objekt zu speichern, sodass der KI-Akteur einfach m√∂gliche Optionen auflisten und entsprechend den Anforderungen des Agenten aus ihnen ausw√§hlen kann. </font><font style="vertical-align: inherit;">Danach kann er an den entsprechenden Ort ziehen, die entsprechenden Animationen (oder andere obligatorische Aktionen) ausf√ºhren, wie im Objekt angegeben, und die entsprechende Belohnung erhalten.</font></font><br><br><table><tbody><tr><td><br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation ausf√ºhren</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benutzerergebnis</font></font></b> <br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schie√üstand</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schusspfeil </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 Bogenschie√üen F√§higkeit </font></font><br><br></td></tr><tr><td> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schule der Magie</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwertduell </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 Schwertfertigkeit </font></font><br><br></td></tr><tr><td rowspan="2"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Robin Hood Schule</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schusspfeil </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +15 Bogenschie√üen F√§higkeit </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwertduell </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +8 Schwertfertigkeit </font></font><br><br></td></tr><tr><td rowspan="2"> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gandalf Akademie</font></font></i> <br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schwertduell </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +5 Schwertfertigkeit </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zauber wirken </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 Magische F√§higkeit </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Bogensch√ºtze neben diesen 4 Orten hat 6 Optionen, von denen 4 nicht auf ihn zutreffen, wenn er kein Schwert oder keine Magie benutzt. </font><font style="vertical-align: inherit;">Wenn wir das Ergebnis in diesem Fall mit einer Verbesserung der F√§higkeiten anstelle eines Namens oder Tags vergleichen, k√∂nnen wir die M√∂glichkeiten der Welt leicht durch neue Verhaltensweisen erweitern. </font><font style="vertical-align: inherit;">Sie k√∂nnen Hotels hinzuf√ºgen, um sich auszuruhen und Ihren Hunger zu stillen. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Charaktere in die Bibliothek gehen lassen und sich √ºber Zauberspr√ºche und fortgeschrittene Bogenschie√ütechniken informieren.</font></font><br><br><table><tbody><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Name des Objekts</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation ausf√ºhren</font></font></b> <br><br></td><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endergebnis</font></font></b> <br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hotel </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kaufen </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -10 zu hungern </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hotel </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schlaf </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -50 bis zur M√ºdigkeit </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Bibliothek </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buch lesen </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +10 Zauberfertigkeit </font></font><br><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Bibliothek </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buch lesen </font></font><br><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +5 Bogenschie√üen F√§higkeit </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir bereits das Verhalten "Bogenschie√üen √ºben" haben und selbst wenn wir die Bibliothek als Ort f√ºr ARCHERY-TRAINING markieren, ben√∂tigen wir h√∂chstwahrscheinlich einen Sonderfall f√ºr die Verarbeitung der Lesebuchanimation anstelle der √ºblichen Schwertkampfanimation. </font><font style="vertical-align: inherit;">Dieses System gibt uns mehr Flexibilit√§t, indem wir diese Assoziationen auf Daten verschieben und Daten in der Welt speichern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Existenz von Objekten oder Orten - Bibliotheken, Hotels oder Schulen - sagt uns, welche Dienstleistungen sie anbieten, welche Charaktere sie erhalten k√∂nnen und wie Sie eine kleine Anzahl von Animationen verwenden k√∂nnen. </font><font style="vertical-align: inherit;">Durch die M√∂glichkeit, einfache Entscheidungen √ºber Ergebnisse zu treffen, k√∂nnen Sie eine Vielzahl interessanter Verhaltensweisen erstellen. </font><font style="vertical-align: inherit;">Anstatt passiv auf eine Anfrage zu warten, k√∂nnen diese Objekte eine F√ºlle von Informationen dar√ºber liefern, wie und warum sie verwendet werden.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reaktionskurven </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oft gibt es eine Situation, in der ein Teil des Zustands der Welt als kontinuierlicher Wert gemessen werden kann. </font></font> Beispiele: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der ‚ÄûProzentsatz der Gesundheit‚Äú reicht normalerweise von 0 (tot) bis 100 (absolut gesund). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Entfernung zum n√§chsten Feind" variiert von 0 bis zu einem beliebigen positiven Wert </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus kann das Spiel einen Aspekt des KI-Systems aufweisen, der die Eingabe kontinuierlicher Werte in einem anderen Intervall erfordert. Um beispielsweise eine Entscheidung zur Flucht zu treffen, kann ein Dienstprogramm-Bewertungssystem sowohl die Entfernung zum n√§chsten Feind als auch die aktuelle Gesundheit des Charakters erfordern. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das System kann jedoch nicht einfach zwei Werte des Zustands der Welt addieren, um ein bestimmtes Ma√ü an ‚ÄûSicherheit‚Äú zu erreichen, da diese beiden Ma√üeinheiten unvergleichlich sind. Die Systeme gehen davon aus, dass sich ein fast toter Charakter 200 Meter vom Feind entfernt in derselben Sicherheit befindet, die absolut gesund ist Charakter 100 Meter vom Feind entfernt. W√§hrend der prozentuale Wert der Gesundheit im weitesten Sinne linear ist, ist die Entfernung nicht so - der Unterschied in der Entfernung vom Feind 200 und 190 Meter ist weniger signifikant als der Unterschied zwischen 10 Metern und Null.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealerweise ben√∂tigen wir eine L√∂sung, bei der zwei Indikatoren in √§hnliche Intervalle umgewandelt werden, damit sie direkt verglichen werden k√∂nnen. Und wir brauchen Designer, die steuern k√∂nnen, wie diese Transformationen berechnet werden, um die relative Bedeutung jedes Werts zu steuern. Zu diesem Zweck werden Reaktionskurven (Antwortkurven) verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Reaktionskurve l√§sst sich am einfachsten als Diagramm mit Eingabe entlang der X-Achse, beliebigen Werten, z. B. ‚ÄûEntfernung zum n√§chsten Feind‚Äú und Ausgabe entlang der Y-Achse (normalerweise ein normalisierter Wert im Bereich von 0,0 bis 1,0) erkl√§ren. Eine Linie oder Kurve im Diagramm bestimmt die Bindung der Eingabe an die normalisierte Ausgabe, und Designer passen diese Linien an, um das gew√ºnschte Verhalten zu erhalten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um das Sicherheitsniveau zu berechnen, k√∂nnen Sie die Linearit√§t der prozentualen Gesundheitswerte beibehalten - beispielsweise 10% mehr Gesundheit. Dies ist normalerweise gut, wenn der Charakter schwer verletzt ist und wenn er leicht verletzt wird. </font><font style="vertical-align: inherit;">Daher ordnen wir diese Werte auf einfache Weise dem Intervall von 0 bis 1 zu:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3f/65f/9a9/e3f65f9a90b2557c5408e529c477fb12.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Entfernung zum n√§chsten Feind ist etwas anders, so dass wir √ºber eine bestimmte Entfernung (z. B. 50 Meter) hinaus √ºberhaupt nicht von Feinden gest√∂rt werden und uns viel mehr f√ºr Unterschiede auf kurze Distanz als auf lange Distanz interessieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sehen wir, dass die Ausgabe von "Sicherheit" f√ºr Feinde auf 40 und 50 Metern fast gleich ist: 0,96 und 1,0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b7/8bf/be7/9b78bfbe758bf8407a3abe44b430e7a5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt jedoch einen viel gr√∂√üeren Unterschied zwischen dem Feind auf 15 Metern (ungef√§hr 0,5) und dem Feind auf 5 Metern (ungef√§hr 0,2). Ein solcher Zeitplan spiegelt besser die Bedeutung der Ann√§herung des Feindes wider. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durch Normalisieren dieser beiden Werte im Bereich von 0 bis 1 k√∂nnen wir den Gesamtsicherheitswert als Durchschnitt dieser beiden Eingabewerte berechnen. Ein Charakter mit 20% Gesundheit und ein Feind auf 50 Metern haben eine Sicherheitsbewertung von 0,6. Ein Charakter mit 75% Gesundheit und einem Feind in nur 5 Metern Entfernung hat eine Sicherheitsbewertung von 0,47. Ein schwer verletzter Charakter mit 10% Gesundheit und einem Feind von 5 Metern hat einen Sicherheitsindex von nur 0,145. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folgendes sollte hier ber√ºcksichtigt werden:</font></font><br><br><ul><li>              ‚Äî                  ,   . </li><li>         ‚Äî ,  ,   50  ‚Äî      ,    ,      . </li><li>        ,   (  )        .       ,       ‚Äî ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Unity AnimationCurve</a>    ,           . </li></ul><br><h2> Blackboards </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oft befinden wir uns in einer Situation, in der die KI des Agenten beginnen muss, das w√§hrend des Spiels erhaltene Wissen und die Informationen zu √ºberwachen, damit sie f√ºr weitere Entscheidungen verwendet werden k√∂nnen. Beispielsweise muss sich ein Agent m√∂glicherweise merken, welchen letzten Charakter er angegriffen hat, um sich f√ºr kurze Zeit auf die Angriffe dieses Charakters zu konzentrieren. Oder er muss sich daran erinnern, wie viel Zeit vergangen ist, nachdem er ein Ger√§usch geh√∂rt hat, so dass er nach einer gewissen Zeit aufh√∂rt, nach seinen Gr√ºnden zu suchen, und zu seinen fr√ºheren Studien zur√ºckkehrt. Sehr oft ist das Datenaufzeichnungssystem stark vom Datenlesesystem getrennt, daher sollte es f√ºr den Agenten leicht zug√§nglich sein und nicht direkt in verschiedene KI-Systeme integriert sein. Das Lesen kann einige Zeit nach dem Schreiben erfolgen, daher m√ºssen die Daten irgendwo gespeichert werden.damit sie sp√§ter abgerufen werden k√∂nnen (und nicht bei Bedarf berechnet werden, was m√∂glicherweise nicht m√∂glich ist).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In einem fest codierten KI-System kann die L√∂sung darin bestehen, die erforderlichen Variablen im Prozess des Bedarfs hinzuzuf√ºgen. Diese Variablen beziehen sich auf Instanzen des Charakters oder Agenten, die entweder direkt in ihn integriert sind oder eine separate Struktur / Klasse zum Speichern solcher Informationen erstellen. KI-Prozeduren k√∂nnen angepasst werden, um diese Daten zu lesen und zu schreiben. In einem einfachen System funktioniert dies gut, aber wenn weitere Informationen hinzugef√ºgt werden, wird dies umst√§ndlich und erfordert normalerweise jedes Mal eine Neuerstellung des Spiels.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein besserer Ansatz besteht darin, das Data Warehouse in eine Struktur umzuwandeln, mit der Systeme beliebige Daten lesen und schreiben k√∂nnen. Mit dieser L√∂sung k√∂nnen Sie neue Variablen hinzuf√ºgen, ohne die Datenstruktur √§ndern zu m√ºssen, und so die Anzahl der √Ñnderungen erh√∂hen, die an Datendateien und Skripten vorgenommen werden k√∂nnen, ohne dass eine erneute Zusammenstellung erforderlich ist. Wenn jeder Agent einfach eine Liste von Schl√ºssel-Wert-Paaren speichert, von denen jedes ein separates Wissen ist, k√∂nnen verschiedene KI-Systeme zusammenarbeiten, indem sie diese Informationen bei Bedarf hinzuf√ºgen und lesen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Entwicklung der KI werden solche Ans√§tze als ‚ÄûTafeln‚Äú (‚ÄûTafeln‚Äú) bezeichnet, da jeder Teilnehmer - in unserem Fall handelt es sich um KI-Verfahren (z. B. Wahrnehmung, Wegfindung und Entscheidungsfindung) - an die ‚ÄûTafel‚Äú schreiben kann, aus der er liest Daten f√ºr die Erf√ºllung ihrer Aufgabe k√∂nnen beliebige andere Teilnehmer sein. Sie k√∂nnen sich dies als ein Expertenteam vorstellen, das sich um das Board versammelt und etwas N√ºtzliches darauf schreibt, das Sie mit der Gruppe teilen m√ºssen. Gleichzeitig k√∂nnen sie die vorherigen Notizen ihrer Kollegen lesen, bis sie zu einer gemeinsamen Entscheidung oder einem gemeinsamen Plan kommen. Eine fest codierte Liste allgemeiner Variablen im Code wird manchmal als "statische Tafel" bezeichnet (da die Elemente, in denen die Informationen gespeichert sind, w√§hrend der Programmausf√ºhrung konstant sind), und eine beliebige Liste von Schl√ºssel-Wert-Paaren wird h√§ufig als "dynamische Tafel" bezeichnet.Sie werden jedoch in etwa auf die gleiche Weise verwendet - als Zwischenverbindung zwischen Teilen des KI-Systems.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der traditionellen KI wird normalerweise der Schwerpunkt auf die Zusammenarbeit verschiedener Systeme f√ºr die gemeinsame Entscheidungsfindung gelegt, aber in der Spiel-KI sind relativ wenige Systeme vorhanden. </font><font style="vertical-align: inherit;">Ein gewisses Ma√ü an Zusammenarbeit kann jedoch noch vorhanden sein. </font><font style="vertical-align: inherit;">Stellen Sie sich in einem Action-Rollenspiel Folgendes vor:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Wahrnehmungssystem scannt regelm√§√üig den Bereich und schreibt die folgenden Eintr√§ge an die Tafel: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> N√§chster Feind: Goblin 412 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Entfernung zum n√§chsten Feind": 35.0 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Enger Freund": "Krieger 43" </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Entfernung zum engsten Freund": 55.4 </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Zeit des letzten Ger√§usches bemerkt": 12:45 Uhr </font></font></li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Systeme wie ein Kampfsystem k√∂nnen wichtige Ereignisse an einer Tafel aufzeichnen, zum Beispiel: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Letzter Schaden: 12:34 Uhr </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele dieser Daten sehen m√∂glicherweise redundant aus. Am Ende k√∂nnen Sie immer die Entfernung zum n√§chsten Feind ermitteln, indem Sie einfach wissen, wer dieser Feind ist, und indem Sie eine Anfrage nach seiner Position erf√ºllen. Wenn sie jedoch mehrmals pro Frame wiederholt wird, um zu entscheiden, ob eine Agentin etwas bedroht oder nicht, wird dies zu einer potenziell langsamen Operation, insbesondere wenn sie eine r√§umliche Abfrage durchf√ºhren muss, um den n√§chsten Feind zu bestimmen. Und die Zeitstempel des ‚Äûzuletzt wahrgenommenen Ger√§usches‚Äú oder des ‚Äûzuletzt erlittenen Schadens‚Äú k√∂nnen immer noch nicht sofort angezeigt werden. Sie m√ºssen die Zeit aufzeichnen, zu der diese Ereignisse stattgefunden haben, und die Tafel ist hierf√ºr ein geeigneter Ort.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unreal Engine 4 verwendet ein dynamisches Blackboard-System zum Speichern von Daten, die von Verhaltensb√§umen √ºbertragen werden. </font><font style="vertical-align: inherit;">Dank dieses gemeinsamen Datenobjekts k√∂nnen Designer auf der Grundlage ihrer Blaupausen (visuelle Skripte) problemlos neue Werte an die Tafel schreiben, und der Verhaltensbaum kann diese Werte sp√§ter lesen, um das Verhalten auszuw√§hlen. All dies erfordert keine Neukompilierung der Engine.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Einflusskarten </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Standardaufgabe in AI besteht darin, zu entscheiden, wohin sich der Agent bewegen soll. </font><font style="vertical-align: inherit;">Im Shooter k√∂nnen wir die Aktion ‚ÄûIn Schutz gehen‚Äú w√§hlen, aber wie kann man entscheiden, wo sich der Schutz unter den Bedingungen bewegt, in denen sich Feinde bewegen? </font><font style="vertical-align: inherit;">√Ñhnlich wie bei der Aktion ‚ÄûEscape‚Äú - wo ist der sicherste Weg zu entkommen? </font><font style="vertical-align: inherit;">Oder in RTS m√ºssen die Truppen m√∂glicherweise eine Schwachstelle in der Verteidigung des Feindes angreifen - wie bestimmen wir, wo sich diese Schwachstelle befindet?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle diese Fragen k√∂nnen als geografische Aufgaben betrachtet werden, da wir eine Frage zur Geometrie und Form der Umgebung und zur Position der Entit√§ten darin stellen. In unserem Spiel sind all diese Daten h√∂chstwahrscheinlich bereits verf√ºgbar, aber es ist keine leichte Aufgabe, ihnen einen Sinn zu geben. Wenn wir zum Beispiel eine Schwachstelle in der Verteidigung des Feindes finden wollen, ist es nicht gut genug, einfach die Position des schw√§chsten Geb√§udes oder der schw√§chsten Befestigung zu w√§hlen, wenn zwei m√§chtige Waffensysteme an den Flanken sind. Wir brauchen einen Weg, um die Umgebung zu ber√ºcksichtigen und die Situation besser zu analysieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daf√ºr ist die Datenstruktur ‚ÄûEinflusskarte‚Äú gedacht. Es beschreibt den ‚ÄûEinfluss‚Äú, den eine Entit√§t auf die Umgebung haben kann. Durch die Kombination des Einflusses mehrerer Entit√§ten schaffen wir einen realistischeren Blick auf die gesamte Landschaft. Unter dem Gesichtspunkt der Implementierung approximieren wir die Spielwelt, indem wir ein 2D-Gitter √ºberlagern. Nachdem wir festgestellt haben, in welcher Zelle des Gitters sich die Entit√§t befindet, wenden wir eine Folgenabsch√§tzung auf diese und die umgebenden Zellen an, die den Aspekt des Spiels angeben, den wir simulieren m√∂chten. Um ein vollst√§ndiges Bild zu erhalten, akkumulieren wir diese Werte im selben Raster. Danach k√∂nnen wir verschiedene Rasterabfragen durchf√ºhren, um die Welt zu verstehen und √ºber Positionierung und Zielpunkte zu entscheiden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nehmen Sie zum Beispiel "den schw√§chsten Punkt in der Verteidigung des Feindes". </font><font style="vertical-align: inherit;">Wir haben eine Verteidigungsmauer, auf deren Angriff wir Fu√üsoldaten schicken wollen, aber dahinter befinden sich 3 Katapulte - 2 links nebeneinander, 1 rechts. </font><font style="vertical-align: inherit;">Wie w√§hlen wir eine gute Angriffsposition? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zun√§chst k√∂nnen wir allen Zellen des Gitters innerhalb des Katapultangriffs +1 Schutzpunkte zuweisen. </font><font style="vertical-align: inherit;">Das Zeichnen dieser Punkte auf der Einflusskarte f√ºr ein Katapult sieht folgenderma√üen aus:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/e37/df8/0cee37df8083ed361e0bf7362a7e5666.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das blaue Rechteck begrenzt alle Zellen, in denen Sie einen Angriff auf die Wand starten k√∂nnen. </font><font style="vertical-align: inherit;">Rote Quadrate zeigen einen Einfluss von +1 Katapult an. </font><font style="vertical-align: inherit;">In unserem Fall bedeutet dies den Angriffsbereich und die Bedrohung f√ºr angreifende Einheiten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nun f√ºgen wir den Effekt des zweiten Katapults hinzu:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db9/e7f/ef1/db9e7fef10229a2f5a38108197548490.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben einen dunklen Bereich, in dem der Einfluss von zwei Katapulten gebildet wird, was diesen Zellen +2 Schutz bietet. Zelle +2 in der blauen Zone kann ein besonders gef√§hrlicher Ort sein, um die Wand anzugreifen! F√ºgen Sie den Einfluss des letzten Katapults hinzu:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1aa/da0/6d7/1aada06d7ea16ef8e2e6bca315c196c5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Symbole: CC-BY: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://game-icons.net/heavenly-dog/originals/defensive-wall.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt haben wir eine vollst√§ndige Bezeichnung des von den Katapulten abgedeckten Gebiets. In der potenziellen Angriffszone gibt es eine Zelle mit +2 Katapult-Einfl√ºssen, 11 Zellen mit +1 Einfluss und 2 Zellen mit 0 Katapult-Einfl√ºssen - dies sind die Hauptkandidaten f√ºr die Angriffsposition. In ihnen k√∂nnen wir die Wand angreifen, ohne Angst vor Katapultfeuer zu haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vorteil von Einflusskarten besteht darin, dass sie einen kontinuierlichen Raum mit einer nahezu unendlichen Menge m√∂glicher Positionen in eine diskrete Menge ungef√§hrer Positionen umwandeln, √ºber die wir sehr schnell Entscheidungen treffen k√∂nnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diesen Vorteil haben wir jedoch nur durch die Auswahl einer kleinen Anzahl potenzieller Angriffspositionen erlangt. Warum sollten wir hier die Einflusskarte verwenden, anstatt die Entfernung von jedem Katapult zu jeder dieser Positionen manuell zu √ºberpr√ºfen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens kann die Berechnung einer Einflusskarte sehr kosteng√ºnstig sein. Nachdem die Einflusspunkte auf die Karte gelegt wurden, muss sie erst ge√§ndert werden, wenn sich die Objekte bewegen. Dies bedeutet, dass wir nicht st√§ndig Entfernungsberechnungen durchf√ºhren oder jede m√∂gliche Einheit iterativ abfragen m√ºssen - wir ‚Äûbacken‚Äú diese Informationen in die Karte und k√∂nnen beliebig oft Anfragen an sie senden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens k√∂nnen wir verschiedene Einflusskarten √ºberlappen und kombinieren, um komplexere Abfragen zu erf√ºllen. </font><font style="vertical-align: inherit;">Um beispielsweise einen sicheren Ort f√ºr die Flucht auszuw√§hlen, k√∂nnen wir eine Karte des Einflusses unserer Feinde erstellen und die Karte unserer Freunde subtrahieren. Die Gitterzellen mit dem gr√∂√üten negativen Wert werden als sicher betrachtet.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/4db/e7b/7264dbe7b1834f3602b36deddc723163.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je roter, gef√§hrlicher und gr√ºner, desto sicherer. </font><font style="vertical-align: inherit;">Bereiche, in denen sich Einfluss√ºberschneidungen ergeben, k√∂nnen ganz oder teilweise neutralisiert werden, um widerspr√ºchliche Einflussbereiche widerzuspiegeln. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich sind Einflusskarten beim Rendern in der Welt leicht zu visualisieren. </font><font style="vertical-align: inherit;">Sie k√∂nnen ein wertvoller Hinweis f√ºr Designer sein, die KI basierend auf sichtbaren Eigenschaften anpassen m√ºssen, und sie k√∂nnen in Echtzeit beobachtet werden, um zu verstehen, warum die KI die Entscheidungen w√§hlt, die sie trifft.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe, der Artikel gab Ihnen einen √úberblick √ºber die beliebtesten Tools und Ans√§tze, die in der Gaming-KI verwendet werden, sowie √ºber Situationen, in denen sie angewendet werden k√∂nnen. </font><font style="vertical-align: inherit;">Der Artikel ber√ºcksichtigte nicht viele andere Techniken (sie werden seltener verwendet, k√∂nnten aber m√∂glicherweise genauso effektiv sein), einschlie√ülich der folgenden:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmen f√ºr Optimierungsaufgaben, einschlie√ülich Aufstieg nach oben, Gradientenabstieg und genetische Algorithmen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wettbewerbsf√§hige Such- / Planungsalgorithmen wie Minimax und Alpha-Beta-Clipping </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klassifikationstechniken, zum Beispiel Perzeptrone, neuronale Netze und die Unterst√ºtzungsvektormethode </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agentenwahrnehmungs- und Speicherverarbeitungssysteme </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Architekturans√§tze f√ºr KI wie Hybridsysteme, pr√§dikative Architekturen (Brooks-Architekturen) und andere Methoden zur Zerlegung von KI-Systemen in Schichten </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animationswerkzeuge wie Bewegungsplanung und Bewegungsanpassung </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Leistungsaufgaben wie Detaillierungsgrad, jederzeitige Algorithmen und Zeitsteuerung </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um mehr √ºber diese Themen sowie die in diesem Artikel behandelten Themen zu erfahren, k√∂nnen Sie die folgenden Quellen studieren. </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameDev.net bietet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel und Tutorials zur k√ºnstlichen Intelligenz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forum zur k√ºnstlichen Intelligenz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AiGameDev.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat viele Pr√§sentationen und Artikel √ºber ein breites Spektrum von Themen der k√ºnstlichen Intelligenz im Zusammenhang mit </font><font style="vertical-align: inherit;">der Entwicklung von </font><font style="vertical-align: inherit;">Spielen</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GDC Vault hat Berichte mit GDC AI Summit, von denen viele kostenlos verf√ºgbar sind: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.gdcvault.com/</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus enth√§lt die AI Game Programmers Guild eine Reihe von Links zu alten Artikeln und Pr√§sentationen dieses Gipfels: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://gameai.com/</font></font></a> <br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der KI-Forscher und Spieleentwickler Tommy Thompson hat einen YouTube-Kanal, der sich der Erkl√§rung und Erforschung der KI in kommerziellen Spielen widmet: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://www.youtube.com/user/tthompso</font></font></a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Viele der Materialien von h√∂chster Qualit√§t sind in B√ºchern enthalten, darunter die folgenden: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Game AI Pro-Serie ist eine Sammlung kurzer Artikel, in denen erl√§utert wird, wie bestimmte Funktionen implementiert oder bestimmte Probleme gel√∂st werden. </font><font style="vertical-align: inherit;">Unter </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.gameaipro.com/ wurden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kostenlose Ausschnitte aus fr√ºheren B√ºchern ver√∂ffentlicht.</font></font><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26amp%3Bxs%3D1%26amp%3Bisjs%3D1%26amp%3Burl%3Dhttps%253A%252F%252Famzn.to%252F2KGoB8n%26amp%3Bxguid%3Df8ad586e5984991508efff4754027dbd%26amp%3Bxuuid%3D305451ecead59d76ca830fded0aab276%26amp%3Bxsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26amp%3Bxcreo%3D0%26amp%3Bxed%3D0%26amp%3Bsref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26amp%3Bpref%3D" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro: Gesammelte Weisheit von Game AI-Profis</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://go.gamedev.net/%3Fid%3D13722X707581%26amp%3Bxs%3D1%26amp%3Bisjs%3D1%26amp%3Burl%3Dhttps%253A%252F%252Famzn.to%252F2KFKyoe%26amp%3Bxguid%3Df8ad586e5984991508efff4754027dbd%26amp%3Bxuuid%3D305451ecead59d76ca830fded0aab276%26amp%3Bxsessid%3D6ccb8b9fa3f10b478b65f7ed703a447b%26amp%3Bxcreo%3D0%26amp%3Bxed%3D0%26amp%3Bsref%3Dhttps%253A%252F%252Fwww.gamedev.net%252Farticles%252Fprogramming%252Fartificial-intelligence%252Fthe-total-beginners-guide-to-game-ai-r4942%252F%253Fdo%253Dedit%2526d%253D1%2526id%253D4942%2526csrfKey%253D7015c6d2c5c643e87baa74f8e5d2c094%26amp%3Bpref%3D" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro 2: Gesammelte Weisheit von Game AI-Profis</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game AI Pro 3: Gesammelte Weisheit von Game AI-Profis</font></font></a> <br></li></ul><br></li><li>  AI Game Programming Wisdom    Game AI Pro.      ,       .    ,          ! <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">AI Game Programming Wisdom 1</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">AI Game Programming Wisdom 2</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">AI Game Programming Wisdom 3</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">AI Game Programming Wisdom 4</a> <br></li></ul></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="external nofollow">Artificial Intelligence: A Modern Approach</a> ‚Äî      ,        .       ,     ,         ,      . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus gibt es mehrere gute B√ºcher √ºber Gaming-KI im Allgemeinen, die von Fachleuten der Branche verfasst wurden. </font><font style="vertical-align: inherit;">Es ist schwierig, jemandem den Vorzug zu geben - lesen Sie die Bewertungen und w√§hlen Sie diejenige aus, die zu Ihnen passt.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420219/">https://habr.com/ru/post/de420219/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420205/index.html">DNA-basierte ROMs, Nukleins√§urespeicher und Substrate f√ºr OxRAM</a></li>
<li><a href="../de420209/index.html">OpenAI demonstriert die √úbertragung komplexer Manipulationen von Simulationen in die reale Welt</a></li>
<li><a href="../de420211/index.html">Magisches Denken √ºber maschinelles Lernen bringt echte KI nicht n√§her</a></li>
<li><a href="../de420213/index.html">√úbersicht √ºber den g√ºnstigen WANHAO D9 Large 3D Printer</a></li>
<li><a href="../de420215/index.html">Konsole, Schalter und viel Kaffee: ein Tag im Leben des VDS-Hostings</a></li>
<li><a href="../de420221/index.html">Angreifer haben Tausende von D-Link-Routern gehackt und ihre Besitzer auf sch√§dliche Ressourcen umgeleitet</a></li>
<li><a href="../de420223/index.html">Ein paar einfache Tipps: So verhindern Sie Sch√§den an der Drohne</a></li>
<li><a href="../de420225/index.html">Unendliche algorithmische Melodie basierend auf Primzahlen</a></li>
<li><a href="../de420227/index.html">Der t√ºrkische Pr√§sident gibt ein Verbot des US-Imports von Elektronik bekannt</a></li>
<li><a href="../de420229/index.html">K√∂nnen Kinder in den D√∂rfern Programmierer werden, wenn sie in der N√§he nur Eisenbahnarbeiter unterrichten? Gespr√§ch mit dem "Kreis"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>