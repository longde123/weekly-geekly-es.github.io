<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😩 ♌️ 👱 Dibujamos una explosión de dibujos animados para 180 líneas de C ++ desnudo 👶 🍱 📅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hace una semana, publiqué otro capítulo de mi curso de conferencia de gráficos por computadora ; Hoy, volvemos nuevamente al trazado de rayos, pero es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dibujamos una explosión de dibujos animados para 180 líneas de C ++ desnudo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437714/"> Hace una semana, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">publiqué otro capítulo</a> de mi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">curso de conferencia de gráficos por computadora</a> ;  Hoy, volvemos nuevamente al trazado de rayos, pero esta vez iremos un poco más allá de la representación de esferas triviales.  No necesito fotorrealismo; para fines de dibujos animados, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tal explosión</a> , me parece, se reducirá. <br><br>  Como siempre, solo tenemos un compilador desnudo a nuestra disposición, no se pueden usar bibliotecas de terceros.  No quiero molestarme con los gestores de ventanas, el procesamiento del mouse / teclado y similares.  El resultado de nuestro programa será una simple imagen guardada en el disco.  No persigo la velocidad / optimización en absoluto, mi objetivo es mostrar los principios básicos. <br><br>  En total, ¿cómo dibujar esa imagen en 180 líneas de código en tales condiciones? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/265/365/052265365c5c2a1da16850f7e0cb6eb1.jpg"><br><a name="habracut"></a><br>  Permítanme incluso insertar un gif animado (seis metros): <br><br><img src="https://github.com/ssloy/tinykaboom/raw/master/kaboom.gif"><br><br>  Y ahora dividiremos toda la tarea en varias etapas: <br><br><h1>  Etapa uno: lee el artículo anterior </h1><br>  Si exactamente.  Lo primero que debe hacer es leer el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capítulo anterior</a> , que habla sobre los conceptos básicos del trazado de rayos.  Es muy corto, en principio, todas las reflexiones-refracciones no se pueden leer, pero al menos hasta una iluminación difusa, recomiendo leerlo.  El código es bastante simple, la gente incluso lo ejecuta en microcontroladores: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc7/080/0d1/cc70800d1c9d4263579068543833351d.gif"><br><br><h1>  Etapa dos: dibuja una esfera </h1><br>  Dibujemos una esfera sin molestarnos con materiales o iluminación.  Por simplicidad, esta esfera vivirá en el centro de coordenadas.  Sobre esta foto quiero obtener: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/384/491/07f/38449107fec46a30b60ea125a61180e7.jpg"><br><br>  Vea el código <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , pero déjeme darle el principal directamente en el texto del artículo: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _USE_MATH_DEFINES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cmath&gt; #include &lt;algorithm&gt; #include &lt;limits&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" const float sphere_radius = 1.5; float signed_distance(const Vec3f &amp;p) { return p.norm() - sphere_radius; } bool sphere_trace(const Vec3f &amp;orig, const Vec3f &amp;dir, Vec3f &amp;pos) { pos = orig; for (size_t i=0; i&lt;128; i++) { float d = signed_distance(pos); if (d &lt; 0) return true; pos = pos + dir*std::max(d*0.1f, .01f); } return false; } int main() { const int width = 640; const int height = 480; const float fov = M_PI/3.; std::vector&lt;Vec3f&gt; framebuffer(width*height); #pragma omp parallel for for (size_t j = 0; j&lt;height; j++) { // actual rendering loop for (size_t i = 0; i&lt;width; i++) { float dir_x = (i + 0.5) - width/2.; float dir_y = -(j + 0.5) + height/2.; // this flips the image at the same time float dir_z = -height/(2.*tan(fov/2.)); Vec3f hit; if (sphere_trace(Vec3f(0, 0, 3), Vec3f(dir_x, dir_y, dir_z).normalize(), hit)) { // the camera is placed to (0,0,3) and it looks along the -z axis framebuffer[i+j*width] = Vec3f(1, 1, 1); } else { framebuffer[i+j*width] = Vec3f(0.2, 0.7, 0.8); // background color } } } std::ofstream ofs("./out.ppm", std::ios::binary); // save the framebuffer to file ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(std::max(0, std::min(255, static_cast&lt;int&gt;(255*framebuffer[i][j])))); } } ofs.close(); return 0; }</span></span></span></span></code> </pre> <br>  La clase de vectores vive en el archivo geometry.h, no lo describiré aquí: en primer lugar, todo es trivial allí, la manipulación simple de vectores de dos y tres dimensiones (suma, resta, asignación, multiplicación por un producto escalar, escalar), y en segundo lugar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">gbg</a> ya lo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">describió</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">detalle</a> como parte de un curso de conferencias sobre gráficos por computadora. <br><br>  Guardo la imagen en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">formato ppm</a> ;  Esta es la forma más fácil de guardar imágenes, aunque no siempre es la más conveniente para su posterior visualización. <br><br>  Entonces, en la función main (), tengo dos ciclos: el segundo ciclo simplemente guarda la imagen en el disco, y el primer ciclo pasa a través de todos los píxeles de la imagen, emite un rayo desde la cámara a través de este píxel, y mira para ver si este rayo se cruza con nuestra esfera. <br><br>  <b>Atención, la idea principal del artículo:</b> si en el último artículo consideramos analíticamente la intersección de un rayo y una esfera, ahora lo cuento numéricamente.  La idea es simple: la esfera tiene una ecuación de la forma x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 = 0;  pero en general la función f (x, y, z) = x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 se define en todo el espacio.  Dentro de la esfera, la función f (x, y, z) tendrá valores negativos, y fuera de la esfera, será positiva.  Es decir, la función f (x, y, z) establece la distancia (¡con un signo!) A nuestra esfera para el punto (x, y, z).  Por lo tanto, simplemente nos deslizamos a lo largo de la viga hasta que nos aburrimos o la función f (x, y, z) se vuelve negativa.  La función sphere_trace () hace exactamente eso. <br><br><h1>  Etapa tres: iluminación primitiva </h1><br>  Codifiquemos la iluminación difusa más simple, quiero obtener una imagen de este tipo en la salida: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b5/a6b/9e6/7b5a6b9e6d05c103b630ffeb6f10018e.jpg"><br><br>  Como en el artículo anterior, para facilitar la lectura, hice un paso = una confirmación.  Los cambios se pueden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver aquí</a> . <br><br>  Para una iluminación difusa, no es suficiente para nosotros calcular el punto de intersección del haz con la superficie, necesitamos conocer el vector normal de la superficie en este punto.  Recibí este vector normal por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">diferencias finitas</a> simples en nuestra función de la distancia a la superficie: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance_field_normal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;pos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> eps = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = signed_distance(pos); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nx = signed_distance(pos + Vec3f(eps, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) - d; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ny = signed_distance(pos + Vec3f(<span class="hljs-number"><span class="hljs-number">0</span></span>, eps, <span class="hljs-number"><span class="hljs-number">0</span></span>)) - d; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nz = signed_distance(pos + Vec3f(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, eps)) - d; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(nx, ny, nz).normalize(); }</code> </pre><br>  En principio, por supuesto, dado que estamos dibujando una esfera, lo normal se puede obtener mucho más fácilmente, pero lo hice con una reserva para el futuro. <br><br><h1>  Etapa cuatro: dibujemos un patrón en nuestra esfera </h1><br>  Y dibujemos algún tipo de patrón en nuestra área, por ejemplo, así: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/061/6cd/67a/0616cd67af48498b5ef3876f9b3e9754.jpg"><br><br>  Para hacer esto, en el código anterior, ¡cambié <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solo dos líneas!</a> <br><br>  ¿Cómo hice esto?  Por supuesto, no tengo texturas.  Acabo de tomar la función g (x, y, z) = sin (x) * sin (y) * sin (z);  se define nuevamente en todo el espacio.  Cuando mi rayo cruza la esfera en algún punto, entonces el valor de la función g (x, y, z) en este punto establece el color del píxel para mí. <br><br>  Por cierto, preste atención a los círculos concéntricos alrededor de la esfera: estos son artefactos de mi cálculo numérico de la intersección. <br><br><h1>  Paso cinco: mapeo de desplazamiento </h1><br>  ¿Por qué quería dibujar este patrón?  Y él me ayudará a dibujar ese erizo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fae/28b/583/fae28b583626fc4b44706a465dc3f328.jpg"><br><br>  Donde mi patrón era negro, quiero hacer un agujero en nuestra esfera, y donde era blanco, por el contrario, estirar la joroba. <br><br>  Para hacer esto, simplemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cambie las tres líneas</a> en nuestro código: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signed_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;p)</span></span></span><span class="hljs-function"> </span></span>{ Vec3f s = Vec3f(p).normalize(sphere_radius); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> displacement = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sx)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sy)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*sz)*noise_amplitude; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.norm() - (sphere_radius + displacement); }</code> </pre><br>  Es decir, cambié el cálculo de la distancia a nuestra superficie, definiéndolo como x ^ 2 + y ^ 2 + z ^ 2 - r ^ 2 - sin (x) * sin (y) * sin (z).  De hecho, definimos una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">función implícita</a> . <br><br><h1>  Paso seis: otra función implícita </h1><br>  ¿Y por qué estoy evaluando el producto de los senos solo para los puntos que se encuentran en la superficie de nuestra esfera?  Vamos a redefinir nuestra función implícita de esta manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signed_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> displacement = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*px)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*py)*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>*pz)*noise_amplitude; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.norm() - (sphere_radius + displacement); }</code> </pre><br>  La diferencia con el código anterior es muy pequeña, es mejor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ver la diferencia</a> .  Aquí está el resultado: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/da1/e29/f72da1e29ba32fb8cbd7df9acfdd4058.jpg"><br><br>  Por lo tanto, podemos definir componentes desconectados en nuestro objeto. <br><br><h1>  Paso siete: ruido pseudoaleatorio </h1><br>  La imagen anterior ya está comenzando a parecerse remotamente a una explosión, pero el producto de los senos tiene un patrón demasiado regular.  Necesitaríamos una función más "desgarrada", más "aleatoria" ... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El ruido de Perlin</a> vendrá en nuestra ayuda.  Aquí hay algo como esto que nos convendría mucho mejor que el producto de los senos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f8/b7a/677/0f8b7a677e99281f724edb3cb94bf9d0.png"><br><br>  Cómo generar ese ruido es un poco extraño, pero esta es la idea principal: debe generar imágenes aleatorias con diferentes resoluciones, suavizarlas para obtener algo como esto: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/24b/577/f9e/24b577f9e194d834d2e243f4dc6d2e3a.png"><br><br>  Y luego simplemente resumirlos: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd0/e8d/172/bd0e8d172b8179a5f9cd30abdcfa3ae7.jpg"><br><br>  Lea más <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Agreguemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un código</a> que genera este ruido y obtengamos esta imagen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/175/da8/80a/175da880a5e746fd8582906bd6c2829e.jpg"><br><br>  Tenga en cuenta que en el código de representación no cambié nada, solo cambió la función que "arruga" nuestra esfera. <br><br><h1>  Etapa ocho, final: agregar color </h1><br>  Lo único que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cambié en este commit</a> es que, en lugar de un color blanco uniforme, apliqué un color que depende linealmente de la cantidad de ruido aplicado: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">palette_fire</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yellow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.7</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.3</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// note that the color is "hot", ie has components &gt;1 const Vec3f orange(1.0, 0.6, 0.0); const Vec3f red(1.0, 0.0, 0.0); const Vec3f darkgray(0.2, 0.2, 0.2); const Vec3f gray(0.4, 0.4, 0.4); float x = std::max(0.f, std::min(1.f, d)); if (x&lt;.25f) return lerp(gray, darkgray, x*4.f); else if (x&lt;.5f) return lerp(darkgray, red, x*4.f-1.f); else if (x&lt;.75f) return lerp(red, orange, x*4.f-2.f); return lerp(orange, yellow, x*4.f-3.f); }</span></span></code> </pre><br>  Este es un gradiente lineal simple entre los cinco colores clave.  Bueno, aquí está la foto! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/052/265/365/052265365c5c2a1da16850f7e0cb6eb1.jpg"><br><br><h1>  Conclusión </h1><br>  Esta técnica de trazado de rayos se llama marcha de rayos.  La tarea es simple: cruce el trazador de rayos anterior con blackjack y reflejos con nuestra explosión, ¡para que la explosión también ilumine todo a su alrededor!  Por cierto, esta explosión carece de translucidez. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437714/">https://habr.com/ru/post/437714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437702/index.html">Análisis de entrevistas de trabajo de Google: consultas sinónimas</a></li>
<li><a href="../437704/index.html">Excelente conocimiento del currículo escolar como indicador de no la más alta inteligencia.</a></li>
<li><a href="../437706/index.html">Año con Tesla</a></li>
<li><a href="../437710/index.html">Limitar al mínimo los derechos de usuario local en Linux</a></li>
<li><a href="../437712/index.html">Estación espacial Roskomnadzor</a></li>
<li><a href="../437716/index.html">Tres formas relativamente honestas de crear un proyecto Flutter</a></li>
<li><a href="../437720/index.html">La lucha por soluciones de calidad en Erlang / Elixir</a></li>
<li><a href="../437722/index.html">Consecuencias Cósmicas de American Shatdown</a></li>
<li><a href="../437724/index.html">OpenSceneGraph: animación procesal de geometría y atributos de estado</a></li>
<li><a href="../437726/index.html">Serialización de Kotlin con Kotlinx.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>