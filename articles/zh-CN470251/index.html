<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😭 👈🏻 🤷 我如何在Flutter上做桌面应用程序（+奖金） 🔱 👩🏼‍🤝‍👨🏾 👏🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近，有个新闻引起了我的注意，即Flutter（1.9）的下一版本已发布 ，它具有许多优点，包括对Web应用程序的早期支持。 

 在工作中，我正在React React上开发移动应用程序，但出于好奇，我对Flutter颇有兴趣。 对于那些尚不了解的人：在Flutter上，您已经可以创建Androi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我如何在Flutter上做桌面应用程序（+奖金）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470251/">最近，有个新闻引起了我的注意，即<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Flutter（1.9）</a>的下一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">版本已发布</a> ，它具有许多优点，包括对Web应用程序的早期支持。 <br><br> 在工作中，我正在React React上开发移动应用程序，但出于好奇，我对Flutter颇有兴趣。 对于那些尚不了解的人：在Flutter上，您已经可以创建Android和iOS的应用程序，正在准备发布Web应用程序，还计划支持桌面。 <br><br> 这就是“一环统治一切”。 <br><br> 经过几天的思考之后，我决定尝试使用哪种应用程序，我决定选择一个带有星号的任务-这些破旧的轨道需要什么？ 在桌面上摇摆并英勇地克服了困难！ 展望未来，我会说几乎没有困难。 <br><br> 切入-关于我如何使用Flutter工具解决通常的React Native程序员任务的故事，以及该技术的总体印象。 <br><br><img src="https://habrastorage.org/webt/hx/cx/hs/hxcxhsjx7ycplrsm2nhgrq0k8xu.png"><br><a name="habracut"></a><br> 考虑到我想“触摸” Flutter的哪些功能，我决定在我的应用程序中应该是： <br><br><ul><li> 向远程API的请求； </li><li> 屏幕之间的过渡； </li><li> 过渡动画 </li><li> 状态管理员-redux或类似的东西。 </li></ul><br> 我不知道如何后端，所以我决定寻找第三方开放API。 结果，我选择了此资源<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-XML和JSON，API的CBR课程</a> 。 好了，我终于决定了该应用程序的功能：将有两个屏幕，主要是一个屏幕，以CBR汇率列出货币，当您单击一个列表项时，我们将打开一个包含详细信息的屏幕。 <br><br><h4> 准备工作 </h4><br> 由于<code>flutter create</code>命令尚不知道如何为Windows / Linux创建项目（当前仅支持Mac，为此请使用<code>--macos</code>标志），因此您必须使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>存储库，其中有一个准备好的示例。 我们克隆存储库，从那里获取<code>example</code>文件夹，如有必要，将其重命名并继续在其中工作。 <br><br> 由于仍在开发对桌面平台的支持，因此您仍然需要执行许多操作。 要访问正在开发的功能，请在终端中运行： <br><br><pre> <code class="bash hljs">flutter channel master flutter upgrade</code> </pre> <br> 另外，您需要告诉Flutter它可以使用您的平台： <br><br><pre> <code class="bash hljs">flutter config --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-linux-desktop</code> </pre> <br> 或 <br><br><pre> <code class="bash hljs">flutter config --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-macos-desktop</code> </pre> <br> 或 <br><br><pre> <code class="bash hljs">flutter config --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-windows-desktop</code> </pre> <br> 如果一切顺利，那么通过运行<code>flutter doctor</code>命令，您应该会看到类似的输出： <br><br><img src="https://habrastorage.org/webt/g0/up/m0/g0upm0iqiijcj7yrwkrm6h-lwvy.png"><br><br> 所以，风景已经准备好了，大厅里的观众们-我们可以开始了。 <br><br><h4> 布局图 </h4><br>  React Native之后引起您注意的第一件事是缺少一种特殊的标记语言la JSX。  Flutter迫使您在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Dart中</a>编写标记和业务逻辑。 最初，这很烦人：外观没什么变化，代码看起来很笨拙，甚至这些括号都位于组件的末尾！ <br><br> 例如： <br><br><img src="https://habrastorage.org/webt/ar/qm/iu/arqmiuoau_llzvwuutjszehkbbw.png"><br><br> 这不是极限！ 值得在错误的地方删除一个，并保证为您带来愉快的（没有）消遣。 <br><br> 另外，由于Flutter中样式组件的特殊性，对于大型组件，从编辑器左边缘开始的缩进非常迅速地增加，并且括号的数量也随之关闭。 <br><br> 此功能是在Flutter中，样式是相同的组件（更确切地说是小部件）。 <br><br> 如果在React Native中在<code>View</code>连续排列三个按钮，以便它们均匀地分布容器空间，那么对于我来说，为样式中的<code>View</code>指定<code>flexDirection: 'row'</code>为样式中的按钮添加<code>flex: 1</code>足够了，那么Flutter具有一个单独的组件一行，用于在一个行中排列元素，而另一个行用于在整个可用空间中元素的“可扩展性”： <code>Expanded</code> 。 <br><br> 结果，代替 <br><br><pre> <code class="javascript hljs">&lt;View style={{<span class="hljs-attr"><span class="hljs-attr">height</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-attr"><span class="hljs-attr">width</span></span>:<span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">flexDirection</span></span>: <span class="hljs-string"><span class="hljs-string">'row'</span></span>}}&gt; &lt;Button title='A' style={{flex:1}}&gt; &lt;Button title='B' style={{flex:1}}&gt; &lt;Button title='C' style={{flex:1}}&gt; &lt;/View&gt;</code> </pre><br> 我们必须这样写： <br><br><pre> <code class="java hljs">Container( height: <span class="hljs-number"><span class="hljs-number">100</span></span>, width: <span class="hljs-number"><span class="hljs-number">300</span></span>, child: Row( children: &lt;Widget&gt;[ Expanded( child: RaisedButton( onPressed: () {}, child: Text(<span class="hljs-string"><span class="hljs-string">'A'</span></span>), ), ), Expanded( child: RaisedButton( onPressed: () {}, child: Text(<span class="hljs-string"><span class="hljs-string">'B'</span></span>), ), ), Expanded( child: RaisedButton( onPressed: () {}, child: Text(<span class="hljs-string"><span class="hljs-string">'C'</span></span>), ), ), ], ), )</code> </pre> <br> 比较冗长，不是吗？ <br><br> 或者说，您想向此容器添加带有圆角边缘的框架。 在React Native中，我们只需添加以下样式： <br><br><pre> <code class="javascript hljs">borderRadius: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">borderWidth</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">borderColor</span></span>: <span class="hljs-string"><span class="hljs-string">'#ccc'</span></span></code> </pre> <br> 在Flutter中，我们必须在容器参数中添加以下内容： <br><br><pre> <code class="java hljs">decoration: BoxDecoration( borderRadius: BorderRadius.all(Radius.circular(<span class="hljs-number"><span class="hljs-number">5</span></span>)), border: Border.all(width: <span class="hljs-number"><span class="hljs-number">1</span></span>, color: Color(<span class="hljs-number"><span class="hljs-number">0xffcccccc</span></span>)) ),</code> </pre> <br> 总的来说，起初，我的标记变成了大量的代码，其中的恶魔会折断他的腿。 但是，并非一切都那么糟糕。 <br><br> 首先，当然必须分解大型组件-将其放置在单独的小部件中，或者至少放置在小部件类的方法中。 <br><br> 其次，VS Code中的Flutter插件有很大帮助-在上图中，括号中的注释由插件本身签名（并且它们不可删除），这有助于避免括号引起混淆。 加上自动格式化工具-半小时后，您就会习惯于定期按<code>Ctrl+Shift+I</code>来格式化代码。 <br><br> 此外，第二版中Dart语言的语法变得更加令人愉悦，因此到今天结束，我已经很喜欢使用它了。 不寻常？ 是的 但不是不愉快的。 <br><br><h4>  API请求 </h4><br> 在React Native中，为了从某些API获取数据，我们通常使用<code>fetch</code>方法，该方法将<code>Promise</code>返回<code>Promise</code>我们。 <br><br> 在Flutter中，情况类似。 在查看了文档中的示例之后，我将http包添加到<code>pubspec.yaml</code> （来自JS world的<code>package.json</code>的类似物），并编写了如下内容： <br><br><pre> <code class="java hljs">Future&lt;http.Response&gt; getAnything() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.get(URL); }</code> </pre> <br>  <code>Future</code>对象的含义与Promise非常相似，因此此处的所有内容都非常透明。 好吧，对于序列化/反序列化json对象，您可以将模型类的概念与特殊方法<code>fromJSON</code> / <code>toJSON</code> 。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>阅读有关此内容的更多信息。 <br><br><h4> 屏幕之间的过渡 </h4><br> 尽管我正在制作桌面应用程序，但从Flutter的角度来看，它在哪个平台上旋转都没有区别。 好吧，也就是说，就我而言，通常是这样-我不知道。 实际上，启动颤动应用程序的系统窗口与智能手机的屏幕相同。 <br><br> 屏幕之间的转换非常简单：我们创建一个屏幕小部件类，然后使用标准的<code>Navigator</code>类。 <br><br> 在最简单的情况下，它可能看起来像这样： <br><br><pre> <code class="java hljs">RaisedButton( child: Text(<span class="hljs-string"><span class="hljs-string">'Go to Detail'</span></span>), onPressed: () { Navigator.of(context).push&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;(MaterialPageRoute(builder: (context) =&gt; DetailScreen())); }, )</code> </pre> <br> 如果您的应用程序有多个屏幕，则首先准备一个路由字典，然后使用<code>pushNamed</code>方法更为合理。 文档中的一个小例子： <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NavigationApp</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( ... routes: &lt;String, WidgetBuilder&gt;{ '/a': (BuildContext context) =&gt; usualNavscreen(), '/b': (BuildContext context) =&gt; drawerNavscreen(), } ... ); } } // AnyWidget ... onPressed: () { Navigator.of(context).pushNamed('/a'); }, ...</span></span></code> </pre><br> 另外，您可以准备一个特殊的动画以在屏幕之间切换并编写如下内容： <br><br><pre> <code class="java hljs">Navigator.of(context).push&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>&gt;(ScaleRoute(page: DetailScreen()));</code> </pre> <br>  <code>ScaleRoute</code>是用于创建过渡动画的特殊类。 这样的动画的很好的例子可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 <br><br><h4> 国家管理 </h4><br> 碰巧我们需要从应用程序的任何部分访问某些数据。 在React Native中， <code>redux</code>通常用于这些目的（如果不是最常见的话）。 <br><br> 对于Flutter，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">存储库</a> ，显示了使用各种应用程序架构的示例-Redux，MVC和MVU，甚至是我以前从未听说过的那些。 <br><br> 在这些示例中稍作改动后，我决定停止使用<code>Provider</code> 。 <br><br> 总的来说，这个想法很简单：我们创建一个<code>ChangeNotifier</code>类的特殊类，在其中存储数据，使用此类的方法对其进行更新，并在必要时从那里进行提取。 有关更多详细信息，请参见软件包<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> 。 <br><br> 为此，请将<code>provider</code>包添加到<code>pubspec.yaml</code>并准备Provider类。 就我而言，它看起来像这样： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:flutter/material.dart'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:rates_app/models/rate.dart'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RateProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChangeNotifier</span></span></span><span class="hljs-class"> </span></span>{ Rate currentrate; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCurrentRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Rate rate)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.currentrate = rate; notifyListeners(); } }</code> </pre> <br> 这里<code>Rate</code>是我的货币模型类（带有<code>name</code> ， <code>code</code> ， <code>value</code>等字段）， <code>currentrate</code>是将存储所选货币的字段， <code>setCurrentRate</code>是<code>currentrate</code>值的方法。 <br><br> 为了将我们的提供程序附加到应用程序，我们更改了应用程序类代码： <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ChangeNotifierProvider( builder: (context) =&gt; RateProvider(), <span class="hljs-comment"><span class="hljs-comment">//   child: MaterialApp( ... ), home: HomeScreen(), ), ); }</span></span></code> </pre> <br> 就是这样，现在，如果我们要保存所选的货币，则可以编写如下代码： <br><br><pre> <code class="java hljs">Provider.of&lt;RateProvider&gt;(context).setCurrentRate(rate);</code> </pre> <br> 如果我们想获取存储的值，则可以这样： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rate = Provider.of&lt;RateProvider&gt;(context).currentrate;</code> </pre> <br> 一切都很透明，没有样板（与Redux不同）。 当然，对于更复杂的应用程序，可能一切都不会那么顺利，但是对于像我的例子那样的纯葡萄酒。 <br><br><h4> 构建应用 </h4><br> 从理论上讲， <code>flutter build &lt;platform&gt;</code>命令用于构建应用程序。 实际上，当我执行<code>flutter build linux</code>命令时，我收到以下消息： <br><br><img src="https://habrastorage.org/webt/cy/ai/px/cyaipxfgk9xrmgncqc9mylbz6j0.png"><br><br>  “它没受伤。”我想， <code>build</code>文件夹的重量让我感到震惊-287.5 MB-由于我的灵魂很简单，我永远删除了该文件夹。 事实证明-是徒劳的。 <br><br> 删除<code>build</code>目录后，项目停止启动。 我无法还原它，所以我从原始示例中复制了它。 它没有帮助-收集器发誓丢失文件。 <br><br> 经过一番研究，结果发现此文件夹中有一个<code>snapshot_blob.bin.d</code>文件，显然，其中写入了项目中使用的所有文件的路径。 我添加了缺少的路径，并且有效。 <br><br> 因此，Flutter目前不知道如何为桌面准备发行版本。 无论如何，对于Linux。 <br><br> 总的来说，如果您不注意这一点，该应用程序就会变成我想要的样子 <br><br><div class="spoiler">  <b class="spoiler_title">所以</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/79/e6/zz/79e6zzdw9kggfwkiyelfsmrokt0.gif"><br></div></div><br><h4> 红利 </h4><br> 我们传递给承诺的奖金。 <br><br> 即使在编写应用程序的阶段，我仍然希望检查将其移植到其他平台有多困难。 让我们从手机开始。 <br><br> 当然，有一种不太野蛮的方法，但是我决定最短的路径是直接的。 因此，我只是创建了一个新的Flutter项目，将<code>pubspec.yaml</code>文件， <code>assets</code> ， <code>fonts</code>和<code>lib</code>目录转移到其中，并将该行添加到<code>AndroidManifest.xml</code> ： <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">uses-permission</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.INTERNET"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br> 该应用程序以半踢开始，我知道了 <br><br><div class="spoiler">  <b class="spoiler_title">图片</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/3m/8p/r4/3m8pr4rwdjllpixpsjdla574kl8.jpeg"><br></div></div><br> 一开始，我不得不修改网络。 我不知道如何创建Web项目，因此我使用了Internet上的说明，由于某些原因，该说明不起作用。 我已经想吐了，但是碰到了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这本</a>手册。 <br><br> 结果，一切都变得尽可能简单-所需要的只是启用对Web应用程序的支持。 挤压手册： <br><br><pre> <code class="bash hljs">flutter channel master flutter upgrade flutter config --<span class="hljs-built_in"><span class="hljs-built_in">enable</span></span>-web <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> &lt;into project directory&gt; flutter create . flutter run -d chrome</code> </pre> <br> 然后，我以同样的野蛮方式将必要的文件传输到该项目，并收到 <br><br><div class="spoiler">  <b class="spoiler_title">结果</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ac/nt/gw/acntgwqqzvghgus9ll6thtbanbe.png"><br></div></div><br><h4> 总体印象 </h4><br> 最初，与Flutter合作并不寻常，我一直试图使用React Native的常规方法，但这样做会造成干扰。 另外，dart代码的一些冗余也很烦人。 <br><br> 当我握了一下手（和锥体）后，我开始看到Flutter比React Native的优势。 我会列出一些。 <br><br>  <b>语言</b> 。  Dart是完全可理解且不错的语言，具有强大的静态类型。 使用JavaScript后，就像呼吸了一口新鲜空气。 我不再担心我的代码会在运行时中断，这是一种令人愉快的感觉。 有人可能会说有Flow和TypeScript，但事实并非如此-在我们的项目中，我们同时使用了两者，而其他东西总是在某个地方出现问题。 当我用React Native编写代码时，我不禁觉得自己的代码在火柴棍道具上，随时可能中断。 使用Flutter，我忘了这种感觉，如果价格是代码冗余，那么我准备付款。 <br><br>  <b>平台</b> 。 在React Native中，您使用本机组件，这通常很好。 但是正因为如此，您有时必须编写特定于平台的代码，并捕获特定于每个平台的错误。 它可能令人难以置信。 使用Flutter，您可以像噩梦一样忘记这些问题（尽管在大型应用程序中情况可能并不那么顺利）。 <br><br>  <b>环境</b> 。 在React Native中使用环境时，一切都是令人悲伤的。  vscode插件会不断脱落，调试器可以吞噬16个可操作的组件和70个可互换的组件，紧密挂起系统（根据个人经验），以及最常见的错误纠正方案：“删除node_modules，再次安装软件包，然后尝试重新启动几次。” 这通常会有所帮助，但是太过分了！ 事实并非如此，并非如此。 <br><br> 此外，您将必须定期运行AndroidStudio和Xcode，因为其中的某些功能仅通过这种方式放置（公平地说，随着RN 0.60的发布，情况会变得更好）。 <br><br> 在这种背景下，vscode的官方Flutter插件看起来非常不错。 代码提示使您无需了解文档即可熟悉平台，自动格式化可解决编码风格，常规调试器等问题。 <br> 通常，它看起来像是一种更成熟的工具。 <br><br>  <b>跨平台</b> 。  React Native奉行“学习一次，到处编写”的原则-学习后，您可以为不同的平台编写代码。 的确，在每个平台下，您都会遇到特定的问题。 但这也许仅仅是React Native不成熟的结果-目前，最新的稳定版本是0.61。 也许随着1.0版的发布，这些问题中的大多数都会消失。 <br><br>  Flutter方法更像一次编写，可在任何地方编译。 即使目前还不能准备生产台式机，Web也处于Alpha状态，但一切都已实现。 对于所有平台拥有单一代码库的能力是一个很强的理由。 <br><br> 当然，Flutter也不是没有缺陷，但是使用它的一些经验不能使我识别出它们。 因此，如果您要进行更客观的评估-请随时轻视新奇效果。 <br><br> 总的来说，应该注意的是，尽管他有成长的空间，但Flutter大多留下了积极的感觉。 在下一个项目中，我将更愿意开始而不是在React Native上开始。 <br><br> 该项目的源代码可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">找到</a> 。 <br><br> 附言：我借此机会祝贺过去的教师节活动中的所有参加者。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN470251/">https://habr.com/ru/post/zh-CN470251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN470229/index.html">UI的声音：主题资源的汇编</a></li>
<li><a href="../zh-CN470235/index.html">CTORECORDS频道创建者Dmitry Simonov的访谈：“ techdir的主要素质是取胜的习惯”</a></li>
<li><a href="../zh-CN470237/index.html">周末文学：易学易读</a></li>
<li><a href="../zh-CN470239/index.html">生产中未开发的ERP：在重症监护室还是太平间？</a></li>
<li><a href="../zh-CN470247/index.html">RESHI.RU-机器人解决并解释数学中的学校课文问题</a></li>
<li><a href="../zh-CN470255/index.html">使用ALGLIB优化债券投资组合</a></li>
<li><a href="../zh-CN470257/index.html">Java中的ImmutableList周围的伪装</a></li>
<li><a href="../zh-CN470259/index.html">搜索中的Aimybox：用于创建语音助手的框架需要iOS向导</a></li>
<li><a href="../zh-CN470265/index.html">C ++缩写备忘单等。 第1部分：C ++</a></li>
<li><a href="../zh-CN470267/index.html">认证温度监控</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>