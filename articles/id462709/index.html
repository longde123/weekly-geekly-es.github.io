<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©â€ğŸš€ ğŸ¥¡ ğŸ§•ğŸ¾ Pengujian mutasi dalam PHP: pengukuran kualitatif untuk cakupan kode ğŸ¤˜ ğŸ™‹ğŸ¾ ğŸŒ†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana cara mengevaluasi kualitas tes? Banyak yang mengandalkan metrik paling populer yang dikenal semua orang - cakupan kode. Tapi ini kuantitatif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian mutasi dalam PHP: pengukuran kualitatif untuk cakupan kode</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/462709/">  Bagaimana cara mengevaluasi kualitas tes?  Banyak yang mengandalkan metrik paling populer yang dikenal semua orang - cakupan kode.  Tapi ini kuantitatif, bukan metrik kualitatif.  Ini menunjukkan seberapa banyak kode Anda dicakup oleh tes, tetapi tidak seberapa baik tes ini ditulis. <br><br>  Salah satu cara untuk mencari tahu ini adalah dengan pengujian mutasi.  Alat ini, membuat perubahan kecil pada kode sumber dan menjalankan kembali pengujian setelah itu, memungkinkan Anda untuk mengidentifikasi tes yang tidak berguna dan cakupan berkualitas rendah. <br><br>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Badoo PHP Meetup pada bulan Maret,</a> saya berbicara tentang bagaimana mengatur pengujian mutasi untuk kode PHP dan masalah apa yang mungkin Anda temui.  Video tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , dan untuk versi teks, selamat datang di cat. <br><br><img src="https://habrastorage.org/webt/qc/xz/fi/qcxzfinlil5-p8zjwtafifv2mqu.jpeg"><br><a name="habracut"></a><br><h2>  Apa itu pengujian mutasi </h2><br>  Untuk menjelaskan apa yang saya maksud, saya akan menunjukkan kepada Anda beberapa contoh.  Mereka sederhana, dilebih-lebihkan di beberapa tempat dan mungkin tampak jelas (walaupun contoh nyata biasanya cukup kompleks dan tidak dapat dilihat dengan mata mereka). <br><br>  Pertimbangkan situasinya: kita memiliki fungsi dasar yang mengaku sebagai orang dewasa, dan ada tes yang mengujinya.  Tes ini memiliki dataProvider, yaitu tes dua kasus: usia 17 tahun dan usia 19 tahun.  Saya pikir jelas bagi banyak dari Anda bahwa Dewasa memiliki cakupan 100%.  Satu-satunya garis.  Itu dilakukan dengan tes.  Semuanya luar biasa. <br><br><img src="https://habrastorage.org/webt/w2/qq/ag/w2qqagnuajffn5ubmkgwnbsubpg.png"><br><br>  Tetapi pemeriksaan lebih dekat mengungkapkan bahwa penyedia kami ditulis dengan buruk dan tidak menguji kondisi batas: usia 18 tahun sebagai syarat batas tidak diuji.  Anda dapat mengganti tanda&gt; dengan&gt; =, dan tes tidak akan menangkap perubahan seperti itu. <br><br>  Contoh lain, sedikit lebih rumit.  Ada fungsi yang membangun beberapa objek sederhana yang berisi setter dan getter.  Kami memiliki tiga bidang yang kami atur, dan ada tes yang memeriksa bahwa fungsi buildPromoBlock benar-benar mengumpulkan objek yang kami harapkan. <br><br><img src="https://habrastorage.org/webt/a6/mr/eq/a6mreqjphzfwflq35qxf5skwfle.png"><br><br>  Jika Anda melihat lebih dekat, kami juga memiliki setSomething, yang menetapkan beberapa properti menjadi true.  Tetapi dalam tes kami tidak memiliki pernyataan seperti itu.  Artinya, kita dapat menghapus baris ini dari buildPromoBlock - dan pengujian kami tidak akan menangkap perubahan ini.  Pada saat yang sama, kami memiliki cakupan 100% dalam fungsi buildPromoBlock, karena ketiga jalur dieksekusi selama pengujian. <br><br>  Dua contoh ini menuntun kita pada pengujian mutasi. <br><br>  Sebelum membongkar algoritma, saya akan memberikan definisi singkat.  Pengujian mutasi adalah mekanisme yang memungkinkan kita, membuat perubahan kecil pada kode, untuk meniru tindakan Pinocchio jahat atau Vasya junior, yang datang dan mulai memecahkannya dengan sengaja, ganti tanda&gt; dengan &lt;, = oleh! =, Dan seterusnya.  Untuk setiap perubahan yang kami buat untuk tujuan yang baik, kami menjalankan tes yang harus mencakup baris yang diubah. <br><br>  Jika tes tidak menunjukkan kepada kami apa pun, jika tidak jatuh, maka itu mungkin tidak cukup efektif.  Mereka tidak menguji kasus batas, tidak mengandung pernyataan: mungkin perlu diperbaiki.  Jika tes jatuh, maka itu keren.  Mereka benar-benar melindungi dari perubahan seperti itu.  Karenanya, kode kami lebih sulit untuk dipatahkan. <br><br>  Sekarang mari kita menganalisis algoritme.  Cukup sederhana.  Hal pertama yang kami lakukan untuk melakukan pengujian mutasi adalah mengambil kode sumber.  Selanjutnya, kita mendapatkan cakupan kode untuk mengetahui tes mana yang harus dijalankan untuk string mana.  Setelah itu, kita membahas kode sumber dan menghasilkan apa yang disebut mutan. <br><br>  Mutan adalah perubahan kode tunggal.  Yaitu, kita mengambil fungsi tertentu di mana ada&gt; perbandingan masuk, jika, kita mengubah tanda ini ke&gt; = - dan kita mendapatkan mutan.  Setelah itu, kami menjalankan tes.  Berikut ini contoh mutasi (kami ganti&gt; dengan&gt; =): <br><br><img src="https://habrastorage.org/webt/tu/fe/rm/tufermumemlipcqjluus2h-bzmm.png"><br><br>  Dalam hal ini, mutasi tidak dilakukan secara acak, tetapi sesuai aturan tertentu.  Respons pengujian mutasi adalah idempoten.  Tidak peduli berapa kali kita menjalankan pengujian mutasi pada kode yang sama, itu menghasilkan hasil yang sama. <br><br>  Hal terakhir yang kami lakukan adalah menjalankan tes yang mencakup garis yang dimutasi.  Dapatkan dari jangkauan.  Ada alat yang tidak optimal yang menggerakkan semua tes.  Tetapi alat yang baik hanya akan mengusir mereka yang dibutuhkan. <br><br>  Setelah itu, kami mengevaluasi hasilnya.  Tes jatuh - maka semuanya baik-baik saja.  Jika mereka tidak jatuh, maka mereka tidak terlalu efektif. <br><br><h2>  Metrik </h2><br>  Metrik apa yang diberikan pengujian mutasi kepada kita?  Ia menambahkan tiga lagi ke cakupan kode, yang akan kita bicarakan sekarang. <br><br>  Tapi pertama-tama, mari kita menganalisis terminologinya. <br><br><img width="400" src="https://habrastorage.org/webt/_6/pu/yz/_6puyzoefm_yith6s0ep8yzwqao.png"><br><br>  Ada konsep mutan yang terbunuh: ini adalah mutan yang uji kami â€œpakuâ€ (yaitu, mereka menangkapnya). <br><br><img width="400" src="https://habrastorage.org/webt/3b/7o/it/3b7oitf-byu91zv3jbooogylvna.png"><br><br>  Ada konsep melarikan diri mutan (surviving mutants).  Ini adalah mutan yang berhasil menghindari hukuman (yaitu, tes tidak menangkap mereka). <br><br><img width="400" src="https://habrastorage.org/webt/dw/8a/ye/dw8ayeaxuwut_6rcbdchfdm0cfg.png"><br><br>  Dan ada konsep yang dibahas mutan - mutan yang tercakup oleh tes, dan mutan yang ditemukan berlawanan dengannya, yang tidak tercakup oleh tes sama sekali (mis. Kita memiliki kode, memiliki logika bisnis, kita dapat mengubahnya, tetapi tidak satu tes pun tidak memeriksa perubahan). <br><br>  Indikator utama yang diberikan pengujian mutasi kepada kita adalah MSI (indikator skor mutasi), rasio jumlah mutan yang terbunuh dengan jumlah totalnya. <br><br>  Indikator kedua adalah cakupan kode mutasi.  Itu hanya kualitatif, bukan kuantitatif, karena itu menunjukkan seberapa banyak logika bisnis yang dapat Anda hancurkan dan lakukan secara teratur, pengujian kami tertangkap. <br><br>  Dan metrik terakhir dibahas MSI, yaitu MSI yang lebih lunak.  Dalam hal ini, kami menghitung MSI hanya untuk mutan yang dicakup oleh tes. <br><br><h2>  Masalah Pengujian Mutasi </h2><br>  Mengapa kurang dari setengah programmer mendengar tentang alat ini?  Mengapa tidak digunakan di mana-mana? <br><br><h3>  Kecepatan rendah </h3><br>  Masalah pertama (salah satu yang utama) adalah kecepatan pengujian mutasi.  Dalam kode, jika kita memiliki lusinan operator mutasi, bahkan untuk kelas paling sederhana, kita dapat menghasilkan ratusan mutasi.  Untuk setiap mutasi, Anda harus menjalankan tes.  Jika kita memiliki, katakanlah, 5.000 tes unit yang berjalan selama sepuluh menit, pengujian mutasi dapat berlangsung berjam-jam. <br><br>  Apa yang bisa dilakukan untuk menaikkan level ini?  Jalankan tes secara paralel, dalam beberapa utas.  Lemparkan aliran ke beberapa mobil.  Itu bekerja. <br><br>  Cara kedua adalah menjalankan incremental.  Tidak perlu menghitung indikator mutasi untuk seluruh cabang setiap kali - Anda dapat mengambil diff cabang.  Jika Anda menggunakan fitur brunch, akan mudah bagi Anda untuk melakukan ini: jalankan tes hanya pada file-file yang telah berubah, dan lihat apa yang terjadi di wisaya, bandingkan, analisis. <br><br>  Hal berikutnya yang dapat Anda lakukan adalah penyetelan mutasi.  Karena operator mutasi dapat diubah, Anda dapat menetapkan aturan tertentu yang digunakannya, lalu Anda dapat menghentikan beberapa mutasi jika mereka secara sadar menyebabkan masalah. <br><br>  Poin penting: pengujian mutasional hanya cocok untuk pengujian unit.  Terlepas dari kenyataan bahwa itu dapat dijalankan untuk tes integrasi, ini jelas merupakan ide yang gagal, karena tes integrasi (seperti ujung ke ujung) berjalan jauh lebih lambat dan mempengaruhi kode lebih banyak.  Anda tidak akan pernah menunggu hasilnya.  Pada prinsipnya, mekanisme ini diciptakan dan dikembangkan secara eksklusif untuk pengujian unit. <br><br><h3>  Mutan tanpa akhir </h3><br>  Masalah kedua yang dapat muncul dengan tes mutasi adalah apa yang disebut mutan tanpa akhir.  Misalnya, ada kode sederhana, sederhana untuk loop: <br><br><img src="https://habrastorage.org/webt/no/tr/az/notrazetuv221u41t1g8rfbkmlc.png"><br><br>  Jika Anda mengganti i ++ dengan i--, maka siklus akan berubah menjadi tak terbatas.  Kode Anda akan menempel untuk waktu yang lama.  Dan pengujian mutasional cukup sering menghasilkan mutasi seperti itu. <br><br>  Hal pertama yang dapat Anda lakukan adalah menyetel mutasi.  Jelas, mengubah i ++ ke i-- dalam for for adalah ide yang sangat buruk: dalam 99% kasus kita akan berakhir dengan infinite loop.  Karena itu, kami dilarang melakukan ini di alat kami. <br><br>  Hal kedua dan terpenting yang melindungi Anda dari masalah seperti itu adalah batas waktu untuk lari.  Misalnya, PHPUnit yang sama memiliki kemampuan untuk menyelesaikan tes batas waktu terlepas dari di mana ia macet.  PHPUnit melalui PCNTL menutup panggilan balik dan menghitung waktu itu sendiri.  Jika pengujian gagal untuk periode tertentu, itu hanya dipaku dan kasus seperti itu dianggap sebagai mutan yang terbunuh, karena kode yang menghasilkan mutasi benar-benar diperiksa oleh tes, yang benar-benar menangkap masalah, yang menunjukkan bahwa kode tersebut menjadi tidak beroperasi. <br><br><h3>  Mutan identik </h3><br>  Masalah ini ada dalam teori pengujian mutasi.  Dalam praktiknya, mereka tidak terlalu sering menemukannya, tetapi Anda perlu mengetahuinya. <br><br>  Pertimbangkan contoh klasik yang menggambarkannya.  Kami memiliki perkalian variabel A dengan -1 dan pembagian A dengan -1.  Dalam kasus umum, operasi ini menghasilkan hasil yang sama.  Kami mengubah tanda A. Oleh karena itu, kami memiliki mutasi yang memungkinkan dua tanda untuk berubah di antara mereka sendiri.  Logika program dengan mutasi semacam itu tidak dilanggar.  Tes dan seharusnya tidak menangkapnya, tidak boleh jatuh.  Karena mutan yang identik seperti itu, beberapa kesulitan muncul. <br><br>  Tidak ada solusi universal - semua orang menyelesaikan masalah ini dengan caranya sendiri.  Mungkin semacam sistem pendaftaran mutan akan membantu.  Kami di Badoo sedang memikirkan sesuatu yang serupa sekarang, kami akan meniru mereka. <br><br><h2>  Ini adalah teori.  Bagaimana dengan PHP? </h2><br>  Ada dua alat yang terkenal untuk pengujian mutasi: Humbug dan Infeksi.  Ketika saya sedang mempersiapkan artikel, saya ingin berbicara tentang mana yang lebih baik dan sampai pada kesimpulan bahwa ini adalah Infeksi. <br>  Tetapi ketika saya pergi ke halaman Humbug, saya melihat yang berikut di sana: Humbug menyatakan dirinya usang dalam mendukung Infeksi.  Karena itu, bagian dari artikel saya ternyata tidak ada artinya.  Jadi Infeksi adalah alat yang sangat bagus.  Saya harus mengucapkan terima kasih kepada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">borNfree</a> dari Minsk, yang membuatnya.  Dia benar-benar bekerja dengan keren.  Anda dapat mengambilnya langsung dari kotak, memasukkannya ke komposer dan memulainya. <br><br>  Kami benar-benar menyukai Infeksi.  Kami ingin menggunakannya.  Tetapi mereka tidak bisa karena dua alasan.  Infeksi memerlukan cakupan kode untuk menjalankan tes untuk mutan dengan benar dan tepat.  Di sini kita punya dua cara.  Kami dapat menghitungnya secara langsung dalam runtime (tetapi kami memiliki 100.000 unit tes).  Atau kita dapat menghitungnya untuk master saat ini (tetapi membangun di cloud kami dari sepuluh mesin yang sangat kuat dalam beberapa utas membutuhkan waktu satu setengah jam).  Jika kita melakukan ini pada setiap menjalankan mutasi, alat mungkin tidak akan berfungsi. <br><br>  Ada opsi untuk memberi makan yang sudah jadi, tetapi dalam format PHPUnit, ini adalah banyak file XML.  Selain fakta bahwa mereka mengandung informasi yang berharga, mereka menyeret banyak struktur, beberapa tanda kurung dan hal-hal lainnya.  Saya pikir secara umum, cakupan kode kami akan mencapai 30 GB, dan kami harus menyeretnya ke semua mesin cloud, terus-menerus membaca dari disk.  Secara umum, idenya begitu-begitu. <br>  Masalah kedua bahkan lebih signifikan.  Kami memiliki perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SoftMocks yang</a> luar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biasa</a> .  Ini memungkinkan kita untuk berurusan dengan kode lama, yang sulit untuk diuji, dan berhasil menulis tes untuk itu.  Kami secara aktif menggunakannya dan tidak akan menolaknya dalam waktu dekat, meskipun kami sedang menulis kode baru sehingga kami tidak memerlukan SoftMock.  Jadi, perpustakaan ini tidak kompatibel dengan Infeksi, karena mereka menggunakan pendekatan yang hampir sama untuk mengubah perubahan. <br><br>  Bagaimana cara kerja SoftMock?  Mereka mencegat inklusi file dan menggantinya dengan yang dimodifikasi, yaitu, alih-alih mengeksekusi kelas A, SoftMock membuat kelas A di tempat yang berbeda dan menghubungkan yang lain, bukan yang asli.  Infeksi bekerja dengan cara yang persis sama, hanya saja ia berfungsi melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">stream_wrapper_register ()</a> , yang melakukan hal yang sama, tetapi pada level sistem.  Akibatnya, SoftMocks atau Infection dapat bekerja untuk kita.  Karena SoftMock diperlukan untuk pengujian kami, sangat sulit untuk membuat kedua alat ini menjadi teman.  Ini mungkin mungkin, tetapi dalam kasus ini kita masuk ke Infeksi sehingga makna dari perubahan seperti itu hilang begitu saja. <br><br>  Mengatasi kesulitan, kami menulis instrumen kecil kami.  Kami meminjam operator mutasi dari Infection (mereka ditulis dengan keren dan sangat mudah digunakan).  Alih-alih memulai mutasi melalui stream_wrapper_register (), kami menjalankannya melalui SoftMocks, yaitu, kami menggunakan alat kami dari kotak.  Toolza kami berteman dengan layanan cakupan kode internal kami.  Yaitu, berdasarkan permintaan dapat menerima cakupan untuk file atau untuk baris tanpa menjalankan semua tes, yang terjadi sangat cepat.  Namun, itu sederhana.  Jika Infection memiliki banyak alat dan fitur (misalnya, diluncurkan di beberapa utas), maka Infeksi kami tidak.  Tetapi kami menggunakan infrastruktur internal kami untuk mengimbangi kekurangan ini.  Misalnya, kami menjalankan uji coba yang sama di beberapa utas melalui cloud kami. <br><br>  Bagaimana kita menggunakan ini? <br><br>  Yang pertama adalah menjalankan manual.  Ini adalah hal pertama yang harus dilakukan.  Semua tes yang Anda tulis diverifikasi secara manual oleh pengujian mutasi.  Itu terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/-5/xc/t1/-5xct1pygkkjfkxsvr8rhcf-rpc.png"><br><br>  Saya menjalankan tes mutasi untuk beberapa file.  Mendapat hasil: 16 mutan.  Dari jumlah tersebut, 15 terbunuh oleh tes, dan satu jatuh dengan kesalahan.  Saya tidak mengatakan bahwa mutasi dapat menyebabkan kematian.  Kami dapat dengan mudah mengubah sesuatu: membuat jenis pengembalian tidak valid, atau sesuatu yang lain.  Ini mungkin, dianggap mutan yang terbunuh, karena pengujian kami akan mulai turun. <br><br>  Namun demikian, Infeksi membedakan mutan-mutan seperti itu dalam kategori terpisah dengan alasan bahwa kadang-kadang layak untuk memberikan perhatian khusus pada kesalahan.  Kebetulan terjadi sesuatu yang aneh - dan mutan tidak dianggap benar dibunuh. <br><br>  Hal kedua yang kami gunakan adalah laporan tentang master.  Sekali sehari, pada malam hari, ketika infrastruktur pembangunan kami menganggur, kami menghasilkan laporan cakupan kode.  Setelah itu, kami membuat laporan pengujian mutasi yang sama.  Ini terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/gf/br/oc/gfbroc92o5cn5xe7a1q3fmwcofm.png"><br><br>  Jika Anda pernah melihat laporan tentang cakupan kode PHPUnit, Anda mungkin memperhatikan bahwa antarmuka mirip, karena kami membuat alat kami dengan analogi.  Dia hanya menghitung semua indikator kunci untuk file tertentu dalam direktori.  Kami juga menetapkan tujuan tertentu (pada kenyataannya, kami mengambilnya dari langit-langit dan belum mematuhinya, karena kami belum memutuskan tujuan mana yang harus dipandu oleh masing-masing metrik, tetapi mereka ada sehingga mudah untuk membuat laporan di masa mendatang). <br><br>  Dan hal terakhir, yang paling penting, yang merupakan konsekuensi dari dua lainnya.  Programmer adalah orang yang malas.  Saya malas: Saya suka semuanya bekerja dan saya tidak harus membuat gerakan ekstra.  Kami membuatnya sehingga ketika pengembang mendorong cabangnya sendiri, indikator cabangnya dan brunch master secara otomatis dihitung secara bertahap. <br><br><img src="https://habrastorage.org/webt/k2/i6/mu/k2i6murvfrlvwfjx-fklewrj2so.png"><br><br>  Sebagai contoh, saya menjalankan dua file dan mendapatkan hasil ini.  Dalam master saya memiliki 548 mutan, 400 terbunuh. Menurut file lain - 147 melawan 63. Di cabang saya, jumlah mutan dalam kedua kasus meningkat.  Tapi di file pertama, mutan itu dipaku, dan di file kedua, dia melarikan diri.  Secara alami, indikator MSI turun.  Hal semacam itu memungkinkan bahkan orang yang tidak ingin membuang waktu untuk menjalankan pengujian mutasi dengan tangan mereka, melihat apa yang telah mereka lakukan lebih buruk, dan memperhatikannya (persis sama dengan cara yang dilakukan oleh pengulas dalam proses review kode). <br><br><h2>  Hasil </h2><br>  Masih sulit untuk memberikan angka: kami tidak memiliki indikator, sekarang sudah muncul, tetapi tidak ada yang bisa dibandingkan. <br><br>  Saya dapat mengatakan bahwa pengujian mutasional memberikan efek psikologis.  Jika Anda mulai menjalankan tes Anda melalui pengujian mutasi, Anda tanpa sadar mulai menulis tes yang lebih baik, dan menulis tes kualitas pasti mengarah pada perubahan dalam cara Anda menulis kode - Anda mulai berpikir bahwa Anda perlu mencakup semua kasus yang dapat Anda hancurkan, Anda memulainya struktur yang lebih baik, membuatnya lebih dapat diuji. <br><br>  Ini adalah opini yang eksklusif subjektif.  Tetapi beberapa kolega saya memberikan umpan balik yang kira-kira sama: ketika mereka mulai terus menggunakan pengujian mutasi dalam pekerjaan mereka, mereka mulai menulis tes dengan lebih baik, dan banyak yang mengatakan bahwa mereka mulai menulis kode dengan lebih baik. <br><br><h2>  Kesimpulan </h2><br>  Cakupan kode adalah metrik penting yang perlu dipantau.  Tetapi indikator ini tidak menjamin apa-apa: itu tidak berarti Anda aman. <br><br>  Pengujian mutasi dapat membantu menjadikan pengujian unit Anda lebih baik, dan melacak cakupan kode masuk akal.  Sudah ada alat untuk PHP, jadi jika Anda memiliki proyek kecil tanpa masalah, maka ambil dan coba hari ini. <br><br>  Mulai setidaknya dengan menjalankan tes mutasi secara manual.  Ambil langkah sederhana ini dan lihat apa yang memberi Anda.  Saya yakin Anda akan menyukainya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462709/">https://habr.com/ru/post/id462709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462699/index.html">Service mesh, "Data plane" dan "Control plane" (Layanan data mesh vs bidang kendali)</a></li>
<li><a href="../id462701/index.html">Perpustakaan generator kode assembler untuk mikrokontroler AVR. Bagian 2</a></li>
<li><a href="../id462703/index.html">Pintu putar "termurah" di Rusia dikendalikan dari smartphone</a></li>
<li><a href="../id462705/index.html">5 bug teratas dalam aplikasi ReactJS saya</a></li>
<li><a href="../id462707/index.html">Kubernetes Meluncurkan Alat Pengembang Aplikasi</a></li>
<li><a href="../id462717/index.html">Perebutan dua yokozun</a></li>
<li><a href="../id462723/index.html">Tangkap kucing dengan TLA +</a></li>
<li><a href="../id462725/index.html">Trik trigonometri</a></li>
<li><a href="../id462727/index.html">Intisari Joomla untuk Juni-Juli 2019</a></li>
<li><a href="../id462729/index.html">Buka kuliah malam tentang desain naratif di VSBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>