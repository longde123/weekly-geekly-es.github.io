<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😬 🎅 🙄 Bitmap-Indizes in Go: Unglaubliche Suchgeschwindigkeit 👵🏾 🤑 🤡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Marko und ich habe dieses Jahr auf der Gophercon Russia einen Vortrag über eine sehr interessante Art von Indizes gehalten, die "Bitmap-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bitmap-Indizes in Go: Unglaubliche Suchgeschwindigkeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/455608/">  Mein Name ist Marko und ich habe dieses Jahr auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gophercon Russia</a> einen Vortrag über eine sehr interessante Art von Indizes gehalten, die "Bitmap-Indizes" genannt werden.  Ich wollte es mit der Community teilen, nicht nur im Videoformat, sondern auch als Artikel.  Es ist eine englische Version und Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> Russisch lesen.  Bitte viel Spaß! <br><br><img src="https://habrastorage.org/webt/of/40/tp/of40tpvu9c7ammhkuygwa6x0eos.jpeg"><br><a name="habracut"></a><br>  Weitere Materialien, Folien und den gesamten Quellcode finden Sie hier: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Original Videoaufnahme: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Fangen wir an! <br><br><h2>  Einführung </h2><br><img src="https://habrastorage.org/webt/tz/mg/ae/tzmgaeevcgq_d8x8boqjdgqxnew.png"><br>  Heute werde ich darüber sprechen <br><br><ul><li>  Was sind Indizes? <br></li><li>  Was ist ein Bitmap-Index? <br></li><li>  Wo es verwendet wird.  Warum es nicht verwendet wird, wo es nicht verwendet wird. <br></li><li>  Wir werden eine einfache Implementierung in Go sehen und dann den Compiler ausprobieren. <br></li><li>  Dann werden wir uns eine etwas weniger einfache, aber merklich schnellere Implementierung in der Go-Assembly ansehen. <br></li><li>  Und danach werde ich die "Probleme" der Bitmap-Indizes einzeln ansprechen. <br></li><li>  Und schließlich werden wir sehen, welche bestehenden Lösungen es gibt. <br></li></ul><br><h2>  Was sind Indizes? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Ein Index ist eine eindeutige Datenstruktur, die zusätzlich zu den Hauptdaten aktualisiert wird, um Suchanforderungen zu beschleunigen.  Ohne Indizes würde die Suche das Durchlaufen aller Daten beinhalten (in einem Prozess, der auch als "vollständiger Scan" bezeichnet wird), und dieser Prozess weist eine lineare algorithmische Komplexität auf.  Datenbanken enthalten jedoch normalerweise große Datenmengen, sodass die lineare Komplexität zu langsam ist.  Idealerweise möchten wir logarithmische oder sogar konstante Komplexitätsgeschwindigkeiten erreichen. <br><br>  Dies ist ein enormes und komplexes Thema, das viele Kompromisse mit sich bringt. Wenn ich jedoch auf jahrzehntelange Datenbankimplementierungen und -recherchen zurückblicke, würde ich argumentieren, dass es nur wenige Ansätze gibt, die häufig verwendet werden: <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Erstens wird der Suchbereich reduziert, indem der gesamte Bereich hierarchisch in kleinere Teile geschnitten wird. <br><br>  Im Allgemeinen wird dies mit Bäumen erreicht.  Es ist ähnlich wie Kisten mit Kisten in Ihrem Kleiderschrank.  Jede Box enthält Materialien, die für eine bestimmte Verwendung in kleinere Boxen sortiert sind.  Wenn wir Materialien benötigen, sollten wir besser nach der Box mit der Bezeichnung "Material" suchen als nach einer Box mit der Bezeichnung "Cookies". <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  Zweitens müssen Sie ein bestimmtes Element oder eine Gruppe von Elementen wie in Hash-Maps oder umgekehrten Indizes sofort lokalisieren.  Die Verwendung von Hash-Maps ähnelt dem vorherigen Beispiel, Sie verwenden jedoch viele kleinere Felder, die keine Felder selbst enthalten, sondern Endelemente. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  Der dritte Ansatz besteht darin, die Notwendigkeit zu beseitigen, überhaupt zu suchen, wie bei Blütenfiltern oder Kuckucksfiltern.  Bloom-Filter können Ihnen sofort eine Antwort geben und Ihnen die Zeit sparen, die Sie sonst für die Suche aufgewendet haben. <br><br><img src="https://habrastorage.org/webt/r2/kk/cn/r2kkcn0uvtidikhqucutgigmvey.png"><br><br>  Der letzte Schritt ist die Beschleunigung der Suche, indem unsere Hardwarefunktionen wie in Bitmap-Indizes besser genutzt werden.  Bei Bitmap-Indizes wird manchmal der gesamte Index durchlaufen, ja, aber dies geschieht auf sehr effiziente Weise. <br><br>  Wie ich bereits sagte, hat die Suche eine Menge Kompromisse, so dass wir oft verschiedene Ansätze verwenden, um die Geschwindigkeit noch weiter zu verbessern oder alle unsere potenziellen Suchtypen abzudecken. <br><br>  Heute möchte ich über einen dieser weniger bekannten Ansätze sprechen: Bitmap-Indizes. <br><br><h2>  Aber wer soll ich über dieses Thema sprechen? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Ich bin Teamleiter bei Badoo (vielleicht kennen Sie eine andere unserer Marken: Bumble).  Wir haben weltweit mehr als 400 Millionen Benutzer und viele der Funktionen, die wir haben, beinhalten die Suche nach der besten Übereinstimmung für Sie!  Für diese Aufgaben verwenden wir maßgeschneiderte Dienste, die unter anderem Bitmap-Indizes verwenden. <br><br><h2>  Was ist nun ein Bitmap-Index? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br><br>  Wie der Name schon sagt, verwenden Bitmap-Indizes Bitmaps, auch Bitsets genannt, um den Suchindex zu implementieren.  Aus der Vogelperspektive besteht dieser Index aus einer oder mehreren Bitmaps, die Entitäten (z. B. Personen) und deren Parameter (z. B. Alter oder Augenfarbe) darstellen, und einem Algorithmus zur Beantwortung von Suchanfragen mit bitweisen Operationen wie AND, OR, NOT usw. . <br><br><img src="https://habrastorage.org/webt/am/ws/tt/amwsttf4ru8rv7vjrrpwncxtamm.png"><br><br>  Bitmap-Indizes werden als sehr nützlich und leistungsstark angesehen, wenn Sie eine Suche durchführen, bei der Abfragen aus mehreren Spalten mit geringer Kardinalität (möglicherweise Augenfarbe oder Familienstand) und einer Entfernung zum Stadtzentrum mit unendlicher Kardinalität kombiniert werden müssen. <br><br>  Aber später in diesem Artikel werde ich zeigen, dass Bitmap-Indizes sogar mit Spalten mit hoher Kardinalität funktionieren. <br><br>  Schauen wir uns das einfachste Beispiel eines Bitmap-Index an ... <br><br><img src="https://habrastorage.org/webt/mp/av/0r/mpav0rhqmrsmaker8gzyzydwdry.png"><br><br>  Stellen Sie sich vor, wir haben eine Liste von Moskauer Restaurants mit binären Merkmalen: <br><br><ul><li>  in der Nähe der U-Bahn <br></li><li>  hat einen privaten Parkplatz <br></li><li>  hat Terrasse <br></li><li>  nimmt Reservierungen entgegen <br></li><li>  vegan-freundlich <br></li><li>  teuer <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Geben Sie jedem Restaurant einen Index ab 0 und weisen Sie 6 Bitmaps zu (eine für jedes Merkmal).  Dann würden wir diese Bitmaps danach füllen, ob das Restaurant eine bestimmte Eigenschaft hat oder nicht.  Wenn das Restaurant Nummer 4 die Terrasse hat, wird Bit Nummer 4 in der Bitmap "Terrasse" auf 1 gesetzt (0, wenn nicht). <br><br><img src="https://habrastorage.org/webt/qo/-k/oo/qo-kooibnag790shhatr6q6nucy.png"><br><br>  Wir haben jetzt den einfachsten möglichen Bitmap-Index, mit dem wir Fragen wie beantworten können <br><br><ul><li>  Gib mir Restaurants, die vegan freundlich sind <br></li><li>  Geben Sie mir Restaurants mit einer Terrasse, die Reservierungen annehmen, aber nicht teuer sind <br></li></ul><br><img src="https://habrastorage.org/webt/qq/76/fv/qq76fv2-j68ou8hvryi9t8jjoog.png"><br><br><img src="https://habrastorage.org/webt/tf/om/e8/tfome8xr_th8yazqnavjfajocwq.png"><br><br>  Wie?  Mal sehen.  Die erste Frage ist einfach.  Wir nehmen einfach eine "vegan-freundliche" Bitmap und geben alle Indizes zurück, die ein Bit gesetzt haben. <br><br><img src="https://habrastorage.org/webt/9p/fq/j2/9pfqj2djha0-ca4vmpjfpgyogbk.png"><br><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br><br>  Die zweite Frage ist etwas komplizierter.  Wir werden die bitweise Operation NICHT für die "teure" Bitmap verwenden, um nicht teure Restaurants zu erhalten, UND sie mit der Bitmap "Reservierung annehmen" und UND mit der Bitmap "Terrasse".  Die resultierende Bitmap besteht aus Restaurants mit all den Eigenschaften, die wir wollten.  Hier sehen wir, dass nur Yunost all diese Eigenschaften hat. <br><br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br><br>  Dies mag etwas theoretisch aussehen, aber keine Sorge, wir werden in Kürze auf den Code eingehen. <br><br><h2>  Wo Bitmap-Indizes verwendet werden </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br><br>  Wenn Sie den "Bitmap-Index" googeln, verweisen 90% der Ergebnisse auf Oracle DB mit grundlegenden Bitmap-Indizes.  Aber sicherlich verwenden auch andere DBMS Bitmap-Indizes, nicht wahr?  Nein, eigentlich nicht.  Lassen Sie uns die üblichen Verdächtigen einzeln durchgehen. <br><br><img src="https://habrastorage.org/webt/eg/of/z2/egofz23p1miavmonz6oeb4xhqiw.png"><br><br><ul><li>  MySQL hat noch keine Bitmap-Indizes, aber es gibt einen Vorschlag, diese hinzuzufügen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ). <br></li><li>  PostgreSQL verfügt nicht über Bitmap-Indizes, verwendet jedoch einfache Bitmaps und bitweise Operationen, um die Ergebnisse mehrerer verschiedener Indizes zu kombinieren. <br></li><li>  Tarantool verfügt über Bitset-Indizes und ermöglicht sehr einfache Suchvorgänge. <br></li><li>  Redis hat Bitfelder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://redis.io/commands/bitfiel</a> d ohne Suchfunktion <br></li><li>  MongoDB hat sie noch nicht, aber es gibt auch einen Vorschlag, sie hinzuzufügen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(https://jira.mongodb.org/browse/SERVER-1723).</a> <br></li><li>  Elasticsearch verwendet intern Bitmaps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> <br></li></ul><br><img src="https://habrastorage.org/webt/4l/ng/4b/4lng4bvs5rnrd5qcnxyhsharkmg.png"><br><ul><li>  Aber es gibt einen neuen Jungen auf dem Block: Pilosa.  Pilosa ist ein neues DBMS, das in Go geschrieben wurde (beachten Sie, dass es kein R gibt, es ist nicht relational), das alles auf Bitmap-Indizes basiert.  Und wir werden später über Pilosa sprechen. <br></li></ul><br><h2>  Implementierung in go </h2><br>  Aber warum?  Warum werden Bitmap-Indizes so selten verwendet?  Bevor ich diese Frage beantworte, möchte ich Sie durch die grundlegende Implementierung des Bitmap-Index in Go führen. <br><br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br><br>  Bitmap wird als Speicherblock dargestellt.  In Go verwenden wir dafür ein Stück Bytes. <br><br>  Wir haben eine Bitmap pro Restaurantmerkmal.  Jedes Bit in einer Bitmap gibt an, ob ein bestimmtes Restaurant diese Eigenschaft aufweist oder nicht. <br><br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br><br>  Wir würden zwei Hilfsfunktionen benötigen.  Eine wird verwendet, um die Bitmap zufällig zu füllen, jedoch mit einer bestimmten Wahrscheinlichkeit, die Charakteristik zu haben.  Ich denke zum Beispiel, dass es nur sehr wenige Restaurants gibt, die keine Reservierungen annehmen, und ungefähr 20% sind vegan-freundlich. <br><br>  Eine andere Funktion gibt uns die Liste der Restaurants aus einer Bitmap. <br><br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br><br>  Um die Frage "Gib mir Restaurants mit einer Terrasse, die Reservierungen annehmen, aber nicht teuer sind" zu beantworten, benötigen wir zwei Operationen: NICHT und UND. <br><br>  Wir können den Code leicht vereinfachen, indem wir eine komplexe Operation UND NICHT einführen. <br><br>  Wir haben die Funktionen für jede von diesen.  Beide Funktionen durchlaufen unsere Slices, indem sie jeweils entsprechende Elemente entnehmen, die Operation ausführen und das Ergebnis in das resultierende Slice schreiben. <br><br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br><br>  Und jetzt können wir unsere Bitmaps und unsere Funktionen verwenden, um die Antwort zu erhalten. <br><br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br><br>  Die Leistung ist hier nicht so gut, obwohl unsere Funktionen sehr einfach sind und wir viel bei der Zuweisung gespart haben, indem wir nicht bei jedem Funktionsaufruf ein neues Slice zurückgegeben haben. <br><br>  Nach einigen Profilen mit pprof stellte ich fest, dass der go-Compiler eine der grundlegenden Optimierungen übersehen hatte: das Inlining von Funktionen. <br><br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br><br>  Sie sehen, der Go-Compiler hat pathologische Angst vor Schleifen durch Slices und weigert sich, jede Funktion mit diesen zu inline. <br><br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br><br>  Aber ich habe keine Angst vor ihnen und kann den Compiler täuschen, indem ich goto für meine Schleife verwende. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Wie Sie sehen können, hat uns das Inlining etwa 2 Mikrosekunden erspart.  Nicht schlecht! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Ein weiterer Engpass ist leicht zu erkennen, wenn Sie sich die Baugruppenleistung genauer ansehen.  Der Go-Compiler hat Bereichsprüfungen in unsere Schleife aufgenommen.  Go ist eine sichere Sprache und der Compiler befürchtet, dass meine drei Bitmaps unterschiedliche Längen haben und ein Pufferüberlauf auftreten könnte. <br><br>  Lassen Sie uns den Compiler beruhigen und zeigen, dass alle meine Bitmaps gleich lang sind.  Dazu können wir am Anfang der Funktion eine einfache Prüfung hinzufügen. <br><br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br><br>  Mit dieser Prüfung überspringt der go-Compiler gerne Bereichsprüfungen und wir sparen einige Nanosekunden. <br><br><h2>  Implementierung in der Montage </h2><br>  Okay, wir haben es also geschafft, durch unsere einfache Implementierung ein bisschen mehr Leistung zu erzielen, aber dieses Ergebnis ist weitaus schlechter als das, was mit aktueller Hardware möglich ist. <br><br>  Sie sehen, was wir tun, sind sehr grundlegende bitweise Operationen, und unsere CPUs sind mit diesen sehr effektiv. <br><br>  Leider versorgen wir unsere CPU mit sehr kleinen Arbeitsblöcken.  Unsere Funktion führt Operationen byteweise aus.  Wir können unsere Implementierung leicht anpassen, um mit 8-Byte-Chunks zu arbeiten, indem wir Slices von uint64 verwenden. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Wie Sie hier sehen können, haben wir bei 8-facher Stapelgröße etwa die 8-fache Leistung erzielt, sodass die Leistungssteigerungen ziemlich linear sind. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br><br>  Dies ist jedoch nicht das Ende der Straße.  Unsere CPUs können mit 16-Byte-, 32-Byte- und sogar 64-Byte-Blöcken arbeiten.  Diese Operationen werden als SIMD (Single Instruction Multiple Data) bezeichnet, und der Prozess der Verwendung solcher CPU-Operationen wird als Vektorisierung bezeichnet. <br><br>  Leider ist der Go-Compiler nicht sehr gut in der Vektorisierung.  Und das einzige, was wir heutzutage tun können, um unseren Code zu vektorisieren, ist, die Go-Assembly zu verwenden und diese SIMD-Anweisungen selbst hinzuzufügen. <br><br><img src="https://habrastorage.org/webt/rs/si/_o/rssi_opod7oxo-e-jk_qepjfvic.png"><br><br>  Go Assembly ist ein seltsames Tier.  Sie würden denken, dass Assembly etwas ist, das an die Architektur gebunden ist, für die Sie schreiben, aber die Assembly von Go ähnelt eher IRL (Intermediate Representation Language): Sie ist plattformunabhängig.  Rob Pike hat vor einigen Jahren einen erstaunlichen Vortrag darüber gehalten. <br><br>  Darüber hinaus verwendet Go ein ungewöhnliches Plan9-Format, das sich sowohl vom AT &amp; T- als auch vom Intel-Format unterscheidet. <br><br><img src="https://habrastorage.org/webt/g4/aq/k5/g4aqk5lflo_4rgmsktoawvsiiuw.png"><br><br>  Man kann mit Sicherheit sagen, dass das Schreiben von Go-Assembler-Code keinen Spaß macht. <br><br>  Zum Glück gibt es bereits zwei übergeordnete Tools, die beim Schreiben der Go-Assemblierung helfen: PeachPy und Avo.  Beide generieren eine Go-Assembly aus einem übergeordneten Code, der in Python bzw. Go geschrieben ist. <br><br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br><br>  Diese Tools vereinfachen Dinge wie die Zuweisung von Registern und Schleifen und reduzieren insgesamt die Komplexität des Einstiegs in den Bereich der Assembly-Programmierung für Go. <br><br>  Wir werden das Vermeiden für diesen Beitrag verwenden, damit unsere Programme fast wie gewöhnlicher Go-Code aussehen. <br><br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br><br>  Dies ist das einfachste Beispiel für ein Avo-Programm.  Wir haben eine main () - Funktion, die eine Funktion namens Add () definiert, die zwei Zahlen hinzufügt.  Es gibt Hilfsfunktionen, um Parameter nach Namen abzurufen und eines der verfügbaren allgemeinen Register abzurufen.  Hier gibt es Funktionen für jede Assemblierungsoperation wie ADDQ, und es gibt Hilfsfunktionen, um das Ergebnis aus einem Register auf den resultierenden Wert zu speichern. <br><br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br><br>  Wenn Sie go generate aufrufen, wird dieses avo-Programm ausgeführt und zwei Dateien werden erstellt <br><br><ul><li>  add.s mit generiertem Assemblycode <br></li><li>  stub.go mit Funktionsheadern, die zum Verbinden unseres Go- und Assembly-Codes benötigt werden <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br><br>  Nachdem wir gesehen haben, was Avo tut, schauen wir uns unsere Funktionen an.  Ich habe sowohl skalare als auch SIMD (Vektor) -Versionen unserer Funktionen implementiert. <br><br>  Mal sehen, wie die skalare Version zuerst aussieht. <br><br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br><br>  Wie in einem vorherigen Beispiel können wir ein allgemeines Register anfordern und vermeiden, dass wir das richtige erhalten, das verfügbar ist.  Wir müssen für unsere Argumente keine Offsets in Bytes verfolgen, um dies für uns zu vermeiden. <br><br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br><br>  Zuvor haben wir aus Leistungsgründen von Schleifen auf goto umgestellt und den go-Compiler getäuscht.  Hier verwenden wir von Anfang an goto (Sprünge) und Beschriftungen, da Schleifen übergeordnete Konstrukte sind.  In der Montage haben wir nur Sprünge. <br><br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br><br>  Anderer Code sollte ziemlich klar sein.  Wir emulieren die Schleife mit Sprüngen und Beschriftungen, nehmen einen kleinen Teil unserer Daten aus unseren beiden Bitmaps, kombinieren sie mit einer der bitweisen Operationen und fügen das Ergebnis in die resultierende Bitmap ein. <br><br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br><br>  Dies ist ein resultierender asm-Code, den wir erhalten.  Wir mussten keine Offsets und Größen (in grün) berechnen, wir mussten uns nicht mit bestimmten Registern (in rot) befassen. <br><br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br><br>  Wenn wir diese Implementierung in Assembly mit der zuvor besten Implementierung vergleichen, die in go geschrieben wurde, würden wir feststellen, dass die Leistung dieselbe ist wie erwartet.  Wir haben nichts anders gemacht. <br><br>  Leider können wir den Go-Compiler nicht zwingen, unsere in asm geschriebenen Funktionen zu integrieren.  Es fehlt völlig die Unterstützung dafür und die Anfrage für diese Funktion besteht seit einiger Zeit.  Deshalb bieten kleine asm-Funktionen in go keinen Nutzen.  Sie müssen entweder größere Funktionen schreiben, ein neues Paket math / bits verwenden oder asm insgesamt überspringen. <br><br>  Schreiben wir jetzt eine Vektorversion unserer Funktionen. <br><br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br><br>  Ich habe mich für AVX2 entschieden, daher werden wir 32-Byte-Chunks verwenden.  Es ist dem Skalar in seiner Struktur sehr ähnlich.  Wir laden Parameter aus, fragen nach allgemeinen Registern usw. <br><br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br><br>  Eine der Änderungen hat mit der Tatsache zu tun, dass Vektoroperationen bestimmte breite Register verwenden.  Für 32 Bytes haben sie das Y-Präfix. Deshalb sehen Sie dort YMM ().  Für 64 Byte hätten sie das Z-Präfix gehabt. <br><br>  Ein weiterer Unterschied hat mit der von mir durchgeführten Optimierung zu tun, die als Abrollen oder Schleifenabwickeln bezeichnet wird.  Ich entschied mich, unsere Schleife teilweise abzuwickeln und 8 Schleifenoperationen nacheinander auszuführen, bevor ich zurückschleife.  Diese Technik beschleunigt den Code, indem sie die vorhandenen Verzweigungen reduziert, und ist durch die Anzahl der verfügbaren Register ziemlich begrenzt. <br><br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br><br>  Was die Leistung betrifft ... ist es erstaunlich.  Wir haben uns im Vergleich zum vorherigen Besten um das 7-fache verbessert.  Ziemlich beeindruckend, oder? <br><br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br><br>  Es sollte möglich sein, diese Ergebnisse durch die Verwendung von AVX512, Prefetching und möglicherweise sogar durch die Verwendung der JIT-Kompilierung (just in time) anstelle des "manuellen" Abfrageplan-Builders noch weiter zu verbessern. Dies wäre jedoch ein Thema für einen völlig anderen Beitrag. <br><br><h2>  Probleme mit dem Bitmap-Index </h2><br>  Nachdem wir die grundlegende Implementierung und die beeindruckende Geschwindigkeit der asm-Implementierung gesehen haben, sprechen wir über die Tatsache, dass Bitmap-Indizes nicht sehr häufig verwendet werden.  Warum ist das so? <br><br><img src="https://habrastorage.org/webt/bp/mr/mw/bpmrmwhfel_gbjklekgwywrj67c.png"><br><br>  Ältere Veröffentlichungen geben uns diese drei Gründe.  Aber die jüngsten und ich argumentieren, dass diese inzwischen "behoben" oder behandelt wurden.  Ich werde hier nicht auf viele Details eingehen, weil wir nicht viel Zeit haben, aber es ist auf jeden Fall einen kurzen Blick wert. <br><br><h2>  Problem mit hoher Kardinalität </h2><br>  Wir haben also erfahren, dass Bitmap-Indizes nur für Felder mit niedriger Kardinalität möglich sind.  dh Felder mit wenigen unterschiedlichen Werten wie Geschlecht oder Augenfarbe.  Der Grund dafür ist, dass die allgemeine Darstellung (ein Bit pro eindeutigem Wert) für Werte mit hoher Kardinalität ziemlich groß werden kann.  Infolgedessen kann die Bitmap auch bei geringer Bevölkerungszahl sehr groß werden. <br><br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><br>  Manchmal kann für diese Felder eine andere Darstellung verwendet werden, z. B. eine Binärzahldarstellung, wie hier gezeigt, aber der größte Game Changer ist eine Komprimierung.  Wissenschaftler haben erstaunliche Komprimierungsalgorithmen entwickelt.  Fast alle basieren auf weit verbreiteten Lauflängenalgorithmen, aber was noch erstaunlicher ist, ist, dass wir keine Bitmaps dekomprimieren müssen, um bitweise Operationen an ihnen durchzuführen.  Normale bitweise Operationen funktionieren mit komprimierten Bitmaps. <br><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><br>  Vor kurzem haben wir gesehen, dass hybride Ansätze wie "brüllende Bitmaps" erscheinen.  Roaring-Bitmaps verwenden drei separate Darstellungen für Bitmaps: Bitmaps, Arrays und "Bitläufe". Sie gleichen die Verwendung dieser drei Darstellungen aus, um die Geschwindigkeit zu maximieren und die Speichernutzung zu minimieren. <br><br>  Brüllende Bitmaps finden sich in einigen der am häufigsten verwendeten Anwendungen, und es gibt Implementierungen für viele Sprachen, einschließlich mehrerer Implementierungen für Go. <br><br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br><br>  Ein anderer Ansatz, der bei Feldern mit hoher Kardinalität helfen kann, ist das Binning.  Stellen Sie sich vor, wir haben ein Feld, das die Größe einer Person darstellt.  Höhe ist ein Schwimmer, aber wir sehen das nicht so.  Es interessiert niemanden, ob Ihre Größe 185,2 oder 185,3 cm beträgt.  Wir können also "virtuelle Behälter" verwenden, um ähnliche Höhen in denselben Behälter zu drücken: in diesem Fall den 1-cm-Behälter.  Und wenn Sie davon ausgehen, dass es nur sehr wenige Menschen mit einer Größe von weniger als 50 cm oder mehr als 250 cm gibt, können wir unsere Größe mit einer Kardinalität von ungefähr 200 Elementen anstelle einer nahezu unendlichen Kardinalität in das Feld umwandeln.  Bei Bedarf können wir die Ergebnisse später zusätzlich filtern. <br><br><h2>  Problem mit hohem Durchsatz </h2><br>  Ein weiterer Grund, warum Bitmap-Indizes schlecht sind, ist, dass das Aktualisieren von Bitmaps teuer sein kann. <br>  Datenbanken führen Aktualisierungen und Suchen parallel durch, sodass Sie in der Lage sein müssen, die Daten zu aktualisieren, während möglicherweise Hunderte von Threads Bitmaps durchlaufen, um eine Suche durchzuführen.  Sperren wären Sperren erforderlich, um Datenrennen oder Datenkonsistenzprobleme zu vermeiden.  Und wo es ein einziges großes Schloss gibt, gibt es einen Schlosskonflikt. <br><br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br><br>  Dieses Problem kann, falls vorhanden, durch Sharding Ihrer Indizes oder gegebenenfalls durch Indexversionen behoben werden. <br><br>  Scherben ist unkompliziert.  Sie teilen sie wie Benutzer in einer Datenbank und jetzt haben Sie anstelle einer Sperre mehrere Sperren, wodurch Ihre Sperrenkonflikte erheblich reduziert werden. <br><br>  Ein anderer Ansatz, der manchmal machbar ist, besteht darin, versionierte Indizes zu haben.  Sie haben den Index, den Sie für die Suche verwenden, und Sie haben einen Index, den Sie für Schreibvorgänge und Aktualisierungen verwenden.  Und Sie kopieren und schalten sie mit einer niedrigen Frequenz, z. B. 100 oder 500 ms. <br><br>  Dieser Ansatz ist jedoch nur möglich, wenn Ihre App veraltete Suchindizes toleriert, die etwas veraltet sind. <br>  Natürlich können diese beiden Ansätze auch zusammen verwendet werden.  Sie können versionierte Indizes gesplittert haben. <br><br><h2>  Nicht triviale Abfragen </h2><br>  Ein weiteres Problem mit dem Bitmap-Index betrifft die Verwendung von Bitmap-Indizes mit Bereichsabfragen.  Und auf den ersten Blick scheinen bitweise Operationen wie UND und ODER nicht sehr nützlich für Bereichsabfragen wie "Gib mir Hotelzimmer, die zwischen 200 und 300 Dollar pro Nacht kosten" zu sein. <br><br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br><br>  Eine naive und sehr ineffiziente Lösung wäre, Ergebnisse für jeden Preispunkt von 200 bis 300 zu erhalten und die Ergebnisse zu ODER. <br><br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br><br>  Ein etwas besserer Ansatz wäre es, Binning zu verwenden und unsere Hotels in Preisklassen mit Reichweiten von beispielsweise 50 Dollar einzuteilen.  Dieser Ansatz würde unsere Suchkosten um etwa das 50-fache reduzieren. <br><br>  Dieses Problem kann aber auch sehr einfach gelöst werden, indem eine spezielle Codierung verwendet wird, die Bereichsabfragen möglich und schnell macht.  In der Literatur werden solche Bitmaps als bereichscodierte Bitmaps bezeichnet. <br><br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br><br>  In bereichskodierten Bitmaps setzen wir nicht nur ein bestimmtes Bit für beispielsweise den Wert 200, sondern setzen alle Bits auf 200 und höher.  Das gleiche gilt für 300. <br><br>  Mit dieser bereichskodierten Bitmap-Darstellung kann die Bereichsabfrage mit nur zwei Durchgängen durch die Bitmap beantwortet werden.  Wir erhalten alle Hotels, die weniger als oder gleich 300 Dollar kosten, und entfernen alle Hotels, die weniger als oder gleich 199 Dollar kosten, aus dem Ergebnis.  Fertig <br><br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br><br>  Sie werden erstaunt sein, aber mit Bitmaps sind auch Geo-Abfragen möglich.  Der Trick besteht darin, eine Darstellung wie Google S2 oder ähnliches zu verwenden, die eine Koordinate in einer geometrischen Figur einschließt, die als drei oder mehr indizierte Linien dargestellt werden kann.  Wenn Sie eine solche Darstellung verwenden, können Sie die Geoabfrage als mehrere Bereichsabfragen in diesen Zeilenindizes darstellen. <br><br><h2>  Fertige Lösungen </h2><br>  Nun, ich hoffe, dass ich Ihr Interesse ein wenig geweckt habe.  Sie haben jetzt ein weiteres Tool unter Ihrem Gürtel und wenn Sie jemals so etwas in Ihrem Service implementieren müssen, wissen Sie, wo Sie suchen müssen. <br><br>  Das ist alles schön und gut, aber nicht jeder hat die Zeit, die Geduld und die Ressourcen, um den Bitmap-Index selbst zu implementieren, insbesondere wenn es um fortgeschrittenere Dinge wie SIMD-Anweisungen geht. <br><br>  Fürchte dich nicht, es gibt zwei Open Source-Produkte, die dir bei deinen Bemühungen helfen können. <br><br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><br><h2>  Brüllend </h2><br>  Erstens gibt es eine Bibliothek, die ich bereits erwähnt habe und die "brüllende Bitmaps" heißt.  Diese Bibliothek implementiert brüllenden "Container" und alle bitweisen Operationen, die Sie benötigen würden, wenn Sie einen vollständigen Bitmap-Index implementieren würden. <br><br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br><br>  Leider verwenden Go-Implementierungen kein SIMD, sodass sie eine etwas geringere Leistung bieten als beispielsweise die C-Implementierung. <br><br><h2>  Pilosa </h2><br>  Ein weiteres Produkt ist ein DBMS namens Pilosa, das nur Bitmap-Indizes enthält.  Es ist ein aktuelles Projekt, aber es hat in letzter Zeit viel Zugkraft gewonnen. <br><br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg">  E-d3BCvTn1CSSDr5Vj6W_9e5_GC1syQ9qSrwdS0 "&gt; <br><br>  Pilosa verwendet brüllende Bitmaps darunter und gibt, vereinfacht oder erklärt fast alle Dinge, über die ich Ihnen heute erzählt habe: Binning, bereichskodierte Bitmaps, die Vorstellung von Feldern usw. <br><br>  Schauen wir uns kurz ein Beispiel für Pilosa an ... <br><br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br><br>  Das Beispiel, das Sie sehen, ist dem, was wir zuvor gesehen haben, sehr, sehr ähnlich.  Wir erstellen einen Client für den Pilosa-Server, erstellen einen Index und Felder für unsere Merkmale.  Wir füllen die Felder mit zufälligen Daten mit einigen Wahrscheinlichkeiten wie zuvor und führen dann unsere Suchabfrage aus. <br>  Sie sehen hier das gleiche Grundmuster.  NICHT teuer gekreuzt oder UND-ed mit Terrasse und gekreuzt mit Reservierungen. <br><br>  Das Ergebnis ist wie erwartet. <br><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><br>  Und schließlich hoffe ich, dass Datenbanken wie mysql und postgresql irgendwann in der Zukunft einen neuen Indextyp erhalten: den Bitmap-Index. <br><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><br><h2>  Schlussworte </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br><br>  Und wenn Sie noch wach sind, danke ich Ihnen dafür.  Zeitmangel hat dazu geführt, dass ich viele Dinge in diesem Beitrag überfliegen musste, aber ich hoffe, es war nützlich und vielleicht sogar inspirierend. <br><br>  Bitmap-Indizes sind eine nützliche Sache, die Sie kennen und verstehen sollten, auch wenn Sie sie gerade nicht benötigen.  Behalten Sie sie als ein weiteres Werkzeug in Ihrem Portfolio. <br><br>  Während meines Vortrags haben wir verschiedene Performance-Tricks gesehen, die wir anwenden können, und Dinge, mit denen Go im Moment zu kämpfen hat.  Dies sind definitiv Dinge, die jeder Go-Programmierer da draußen wissen muss. <br><br>  Und das ist alles, was ich jetzt für dich habe.  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455608/">https://habr.com/ru/post/de455608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455598/index.html">Aktualisieren Sie Exim dringend auf 4.92 - es liegt eine aktive Infektion vor</a></li>
<li><a href="../de455600/index.html">Die 3DEXPERIENCE-Plattform hilft bei der Schaffung öffentlicher Verkehrsmittel der Zukunft</a></li>
<li><a href="../de455602/index.html">Das Provozieren von Browsern stürzt mit Verhaltensfuzzing ab</a></li>
<li><a href="../de455604/index.html">Verantwortlich für die Verwaltung der Windows-Konfiguration. Erfolgsgeschichte</a></li>
<li><a href="../de455606/index.html">Maschinelles Lernen und Datenanalyse: Masterstudiengang an der Higher School of Economics in St. Petersburg</a></li>
<li><a href="../de455610/index.html">Legendärer Intel Core i7-2600K: Testen von Sandy Bridge im Jahr 2019 (Teil 1)</a></li>
<li><a href="../de455612/index.html">Wir denken über die Charaktere von Spielen und Dialogen nach dem Rat von Schriftstellern und am Beispiel von Unterstützern der Theorie einer flachen Erde nach</a></li>
<li><a href="../de455614/index.html">FFI: Schreiben in Rust in einem PHP-Programm</a></li>
<li><a href="../de455616/index.html">Warum zu "Industrial Programming" in der St. Petersburg HSE gehen?</a></li>
<li><a href="../de455618/index.html">DevOps LEGO: Wie wir eine Pipeline auf Würfeln angelegt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>