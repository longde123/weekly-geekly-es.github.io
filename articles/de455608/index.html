<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò¨ üéÖ üôÑ Bitmap-Indizes in Go: Unglaubliche Suchgeschwindigkeit üëµüèæ ü§ë ü§°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Marko und ich habe dieses Jahr auf der Gophercon Russia einen Vortrag √ºber eine sehr interessante Art von Indizes gehalten, die "Bitmap-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bitmap-Indizes in Go: Unglaubliche Suchgeschwindigkeit</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/455608/">  Mein Name ist Marko und ich habe dieses Jahr auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gophercon Russia</a> einen Vortrag √ºber eine sehr interessante Art von Indizes gehalten, die "Bitmap-Indizes" genannt werden.  Ich wollte es mit der Community teilen, nicht nur im Videoformat, sondern auch als Artikel.  Es ist eine englische Version und Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> Russisch lesen.  Bitte viel Spa√ü! <br><br><img src="https://habrastorage.org/webt/of/40/tp/of40tpvu9c7ammhkuygwa6x0eos.jpeg"><br><a name="habracut"></a><br>  Weitere Materialien, Folien und den gesamten Quellcode finden Sie hier: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Original Videoaufnahme: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Fangen wir an! <br><br><h2>  Einf√ºhrung </h2><br><img src="https://habrastorage.org/webt/tz/mg/ae/tzmgaeevcgq_d8x8boqjdgqxnew.png"><br>  Heute werde ich dar√ºber sprechen <br><br><ul><li>  Was sind Indizes? <br></li><li>  Was ist ein Bitmap-Index? <br></li><li>  Wo es verwendet wird.  Warum es nicht verwendet wird, wo es nicht verwendet wird. <br></li><li>  Wir werden eine einfache Implementierung in Go sehen und dann den Compiler ausprobieren. <br></li><li>  Dann werden wir uns eine etwas weniger einfache, aber merklich schnellere Implementierung in der Go-Assembly ansehen. <br></li><li>  Und danach werde ich die "Probleme" der Bitmap-Indizes einzeln ansprechen. <br></li><li>  Und schlie√ülich werden wir sehen, welche bestehenden L√∂sungen es gibt. <br></li></ul><br><h2>  Was sind Indizes? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Ein Index ist eine eindeutige Datenstruktur, die zus√§tzlich zu den Hauptdaten aktualisiert wird, um Suchanforderungen zu beschleunigen.  Ohne Indizes w√ºrde die Suche das Durchlaufen aller Daten beinhalten (in einem Prozess, der auch als "vollst√§ndiger Scan" bezeichnet wird), und dieser Prozess weist eine lineare algorithmische Komplexit√§t auf.  Datenbanken enthalten jedoch normalerweise gro√üe Datenmengen, sodass die lineare Komplexit√§t zu langsam ist.  Idealerweise m√∂chten wir logarithmische oder sogar konstante Komplexit√§tsgeschwindigkeiten erreichen. <br><br>  Dies ist ein enormes und komplexes Thema, das viele Kompromisse mit sich bringt. Wenn ich jedoch auf jahrzehntelange Datenbankimplementierungen und -recherchen zur√ºckblicke, w√ºrde ich argumentieren, dass es nur wenige Ans√§tze gibt, die h√§ufig verwendet werden: <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Erstens wird der Suchbereich reduziert, indem der gesamte Bereich hierarchisch in kleinere Teile geschnitten wird. <br><br>  Im Allgemeinen wird dies mit B√§umen erreicht.  Es ist √§hnlich wie Kisten mit Kisten in Ihrem Kleiderschrank.  Jede Box enth√§lt Materialien, die f√ºr eine bestimmte Verwendung in kleinere Boxen sortiert sind.  Wenn wir Materialien ben√∂tigen, sollten wir besser nach der Box mit der Bezeichnung "Material" suchen als nach einer Box mit der Bezeichnung "Cookies". <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  Zweitens m√ºssen Sie ein bestimmtes Element oder eine Gruppe von Elementen wie in Hash-Maps oder umgekehrten Indizes sofort lokalisieren.  Die Verwendung von Hash-Maps √§hnelt dem vorherigen Beispiel, Sie verwenden jedoch viele kleinere Felder, die keine Felder selbst enthalten, sondern Endelemente. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  Der dritte Ansatz besteht darin, die Notwendigkeit zu beseitigen, √ºberhaupt zu suchen, wie bei Bl√ºtenfiltern oder Kuckucksfiltern.  Bloom-Filter k√∂nnen Ihnen sofort eine Antwort geben und Ihnen die Zeit sparen, die Sie sonst f√ºr die Suche aufgewendet haben. <br><br><img src="https://habrastorage.org/webt/r2/kk/cn/r2kkcn0uvtidikhqucutgigmvey.png"><br><br>  Der letzte Schritt ist die Beschleunigung der Suche, indem unsere Hardwarefunktionen wie in Bitmap-Indizes besser genutzt werden.  Bei Bitmap-Indizes wird manchmal der gesamte Index durchlaufen, ja, aber dies geschieht auf sehr effiziente Weise. <br><br>  Wie ich bereits sagte, hat die Suche eine Menge Kompromisse, so dass wir oft verschiedene Ans√§tze verwenden, um die Geschwindigkeit noch weiter zu verbessern oder alle unsere potenziellen Suchtypen abzudecken. <br><br>  Heute m√∂chte ich √ºber einen dieser weniger bekannten Ans√§tze sprechen: Bitmap-Indizes. <br><br><h2>  Aber wer soll ich √ºber dieses Thema sprechen? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Ich bin Teamleiter bei Badoo (vielleicht kennen Sie eine andere unserer Marken: Bumble).  Wir haben weltweit mehr als 400 Millionen Benutzer und viele der Funktionen, die wir haben, beinhalten die Suche nach der besten √úbereinstimmung f√ºr Sie!  F√ºr diese Aufgaben verwenden wir ma√ügeschneiderte Dienste, die unter anderem Bitmap-Indizes verwenden. <br><br><h2>  Was ist nun ein Bitmap-Index? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br><br>  Wie der Name schon sagt, verwenden Bitmap-Indizes Bitmaps, auch Bitsets genannt, um den Suchindex zu implementieren.  Aus der Vogelperspektive besteht dieser Index aus einer oder mehreren Bitmaps, die Entit√§ten (z. B. Personen) und deren Parameter (z. B. Alter oder Augenfarbe) darstellen, und einem Algorithmus zur Beantwortung von Suchanfragen mit bitweisen Operationen wie AND, OR, NOT usw. . <br><br><img src="https://habrastorage.org/webt/am/ws/tt/amwsttf4ru8rv7vjrrpwncxtamm.png"><br><br>  Bitmap-Indizes werden als sehr n√ºtzlich und leistungsstark angesehen, wenn Sie eine Suche durchf√ºhren, bei der Abfragen aus mehreren Spalten mit geringer Kardinalit√§t (m√∂glicherweise Augenfarbe oder Familienstand) und einer Entfernung zum Stadtzentrum mit unendlicher Kardinalit√§t kombiniert werden m√ºssen. <br><br>  Aber sp√§ter in diesem Artikel werde ich zeigen, dass Bitmap-Indizes sogar mit Spalten mit hoher Kardinalit√§t funktionieren. <br><br>  Schauen wir uns das einfachste Beispiel eines Bitmap-Index an ... <br><br><img src="https://habrastorage.org/webt/mp/av/0r/mpav0rhqmrsmaker8gzyzydwdry.png"><br><br>  Stellen Sie sich vor, wir haben eine Liste von Moskauer Restaurants mit bin√§ren Merkmalen: <br><br><ul><li>  in der N√§he der U-Bahn <br></li><li>  hat einen privaten Parkplatz <br></li><li>  hat Terrasse <br></li><li>  nimmt Reservierungen entgegen <br></li><li>  vegan-freundlich <br></li><li>  teuer <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Geben Sie jedem Restaurant einen Index ab 0 und weisen Sie 6 Bitmaps zu (eine f√ºr jedes Merkmal).  Dann w√ºrden wir diese Bitmaps danach f√ºllen, ob das Restaurant eine bestimmte Eigenschaft hat oder nicht.  Wenn das Restaurant Nummer 4 die Terrasse hat, wird Bit Nummer 4 in der Bitmap "Terrasse" auf 1 gesetzt (0, wenn nicht). <br><br><img src="https://habrastorage.org/webt/qo/-k/oo/qo-kooibnag790shhatr6q6nucy.png"><br><br>  Wir haben jetzt den einfachsten m√∂glichen Bitmap-Index, mit dem wir Fragen wie beantworten k√∂nnen <br><br><ul><li>  Gib mir Restaurants, die vegan freundlich sind <br></li><li>  Geben Sie mir Restaurants mit einer Terrasse, die Reservierungen annehmen, aber nicht teuer sind <br></li></ul><br><img src="https://habrastorage.org/webt/qq/76/fv/qq76fv2-j68ou8hvryi9t8jjoog.png"><br><br><img src="https://habrastorage.org/webt/tf/om/e8/tfome8xr_th8yazqnavjfajocwq.png"><br><br>  Wie?  Mal sehen.  Die erste Frage ist einfach.  Wir nehmen einfach eine "vegan-freundliche" Bitmap und geben alle Indizes zur√ºck, die ein Bit gesetzt haben. <br><br><img src="https://habrastorage.org/webt/9p/fq/j2/9pfqj2djha0-ca4vmpjfpgyogbk.png"><br><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br><br>  Die zweite Frage ist etwas komplizierter.  Wir werden die bitweise Operation NICHT f√ºr die "teure" Bitmap verwenden, um nicht teure Restaurants zu erhalten, UND sie mit der Bitmap "Reservierung annehmen" und UND mit der Bitmap "Terrasse".  Die resultierende Bitmap besteht aus Restaurants mit all den Eigenschaften, die wir wollten.  Hier sehen wir, dass nur Yunost all diese Eigenschaften hat. <br><br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br><br>  Dies mag etwas theoretisch aussehen, aber keine Sorge, wir werden in K√ºrze auf den Code eingehen. <br><br><h2>  Wo Bitmap-Indizes verwendet werden </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br><br>  Wenn Sie den "Bitmap-Index" googeln, verweisen 90% der Ergebnisse auf Oracle DB mit grundlegenden Bitmap-Indizes.  Aber sicherlich verwenden auch andere DBMS Bitmap-Indizes, nicht wahr?  Nein, eigentlich nicht.  Lassen Sie uns die √ºblichen Verd√§chtigen einzeln durchgehen. <br><br><img src="https://habrastorage.org/webt/eg/of/z2/egofz23p1miavmonz6oeb4xhqiw.png"><br><br><ul><li>  MySQL hat noch keine Bitmap-Indizes, aber es gibt einen Vorschlag, diese hinzuzuf√ºgen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ). <br></li><li>  PostgreSQL verf√ºgt nicht √ºber Bitmap-Indizes, verwendet jedoch einfache Bitmaps und bitweise Operationen, um die Ergebnisse mehrerer verschiedener Indizes zu kombinieren. <br></li><li>  Tarantool verf√ºgt √ºber Bitset-Indizes und erm√∂glicht sehr einfache Suchvorg√§nge. <br></li><li>  Redis hat Bitfelder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://redis.io/commands/bitfiel</a> d ohne Suchfunktion <br></li><li>  MongoDB hat sie noch nicht, aber es gibt auch einen Vorschlag, sie hinzuzuf√ºgen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(https://jira.mongodb.org/browse/SERVER-1723).</a> <br></li><li>  Elasticsearch verwendet intern Bitmaps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> <br></li></ul><br><img src="https://habrastorage.org/webt/4l/ng/4b/4lng4bvs5rnrd5qcnxyhsharkmg.png"><br><ul><li>  Aber es gibt einen neuen Jungen auf dem Block: Pilosa.  Pilosa ist ein neues DBMS, das in Go geschrieben wurde (beachten Sie, dass es kein R gibt, es ist nicht relational), das alles auf Bitmap-Indizes basiert.  Und wir werden sp√§ter √ºber Pilosa sprechen. <br></li></ul><br><h2>  Implementierung in go </h2><br>  Aber warum?  Warum werden Bitmap-Indizes so selten verwendet?  Bevor ich diese Frage beantworte, m√∂chte ich Sie durch die grundlegende Implementierung des Bitmap-Index in Go f√ºhren. <br><br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br><br>  Bitmap wird als Speicherblock dargestellt.  In Go verwenden wir daf√ºr ein St√ºck Bytes. <br><br>  Wir haben eine Bitmap pro Restaurantmerkmal.  Jedes Bit in einer Bitmap gibt an, ob ein bestimmtes Restaurant diese Eigenschaft aufweist oder nicht. <br><br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br><br>  Wir w√ºrden zwei Hilfsfunktionen ben√∂tigen.  Eine wird verwendet, um die Bitmap zuf√§llig zu f√ºllen, jedoch mit einer bestimmten Wahrscheinlichkeit, die Charakteristik zu haben.  Ich denke zum Beispiel, dass es nur sehr wenige Restaurants gibt, die keine Reservierungen annehmen, und ungef√§hr 20% sind vegan-freundlich. <br><br>  Eine andere Funktion gibt uns die Liste der Restaurants aus einer Bitmap. <br><br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br><br>  Um die Frage "Gib mir Restaurants mit einer Terrasse, die Reservierungen annehmen, aber nicht teuer sind" zu beantworten, ben√∂tigen wir zwei Operationen: NICHT und UND. <br><br>  Wir k√∂nnen den Code leicht vereinfachen, indem wir eine komplexe Operation UND NICHT einf√ºhren. <br><br>  Wir haben die Funktionen f√ºr jede von diesen.  Beide Funktionen durchlaufen unsere Slices, indem sie jeweils entsprechende Elemente entnehmen, die Operation ausf√ºhren und das Ergebnis in das resultierende Slice schreiben. <br><br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br><br>  Und jetzt k√∂nnen wir unsere Bitmaps und unsere Funktionen verwenden, um die Antwort zu erhalten. <br><br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br><br>  Die Leistung ist hier nicht so gut, obwohl unsere Funktionen sehr einfach sind und wir viel bei der Zuweisung gespart haben, indem wir nicht bei jedem Funktionsaufruf ein neues Slice zur√ºckgegeben haben. <br><br>  Nach einigen Profilen mit pprof stellte ich fest, dass der go-Compiler eine der grundlegenden Optimierungen √ºbersehen hatte: das Inlining von Funktionen. <br><br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br><br>  Sie sehen, der Go-Compiler hat pathologische Angst vor Schleifen durch Slices und weigert sich, jede Funktion mit diesen zu inline. <br><br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br><br>  Aber ich habe keine Angst vor ihnen und kann den Compiler t√§uschen, indem ich goto f√ºr meine Schleife verwende. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Wie Sie sehen k√∂nnen, hat uns das Inlining etwa 2 Mikrosekunden erspart.  Nicht schlecht! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Ein weiterer Engpass ist leicht zu erkennen, wenn Sie sich die Baugruppenleistung genauer ansehen.  Der Go-Compiler hat Bereichspr√ºfungen in unsere Schleife aufgenommen.  Go ist eine sichere Sprache und der Compiler bef√ºrchtet, dass meine drei Bitmaps unterschiedliche L√§ngen haben und ein Puffer√ºberlauf auftreten k√∂nnte. <br><br>  Lassen Sie uns den Compiler beruhigen und zeigen, dass alle meine Bitmaps gleich lang sind.  Dazu k√∂nnen wir am Anfang der Funktion eine einfache Pr√ºfung hinzuf√ºgen. <br><br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br><br>  Mit dieser Pr√ºfung √ºberspringt der go-Compiler gerne Bereichspr√ºfungen und wir sparen einige Nanosekunden. <br><br><h2>  Implementierung in der Montage </h2><br>  Okay, wir haben es also geschafft, durch unsere einfache Implementierung ein bisschen mehr Leistung zu erzielen, aber dieses Ergebnis ist weitaus schlechter als das, was mit aktueller Hardware m√∂glich ist. <br><br>  Sie sehen, was wir tun, sind sehr grundlegende bitweise Operationen, und unsere CPUs sind mit diesen sehr effektiv. <br><br>  Leider versorgen wir unsere CPU mit sehr kleinen Arbeitsbl√∂cken.  Unsere Funktion f√ºhrt Operationen byteweise aus.  Wir k√∂nnen unsere Implementierung leicht anpassen, um mit 8-Byte-Chunks zu arbeiten, indem wir Slices von uint64 verwenden. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Wie Sie hier sehen k√∂nnen, haben wir bei 8-facher Stapelgr√∂√üe etwa die 8-fache Leistung erzielt, sodass die Leistungssteigerungen ziemlich linear sind. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br><br>  Dies ist jedoch nicht das Ende der Stra√üe.  Unsere CPUs k√∂nnen mit 16-Byte-, 32-Byte- und sogar 64-Byte-Bl√∂cken arbeiten.  Diese Operationen werden als SIMD (Single Instruction Multiple Data) bezeichnet, und der Prozess der Verwendung solcher CPU-Operationen wird als Vektorisierung bezeichnet. <br><br>  Leider ist der Go-Compiler nicht sehr gut in der Vektorisierung.  Und das einzige, was wir heutzutage tun k√∂nnen, um unseren Code zu vektorisieren, ist, die Go-Assembly zu verwenden und diese SIMD-Anweisungen selbst hinzuzuf√ºgen. <br><br><img src="https://habrastorage.org/webt/rs/si/_o/rssi_opod7oxo-e-jk_qepjfvic.png"><br><br>  Go Assembly ist ein seltsames Tier.  Sie w√ºrden denken, dass Assembly etwas ist, das an die Architektur gebunden ist, f√ºr die Sie schreiben, aber die Assembly von Go √§hnelt eher IRL (Intermediate Representation Language): Sie ist plattformunabh√§ngig.  Rob Pike hat vor einigen Jahren einen erstaunlichen Vortrag dar√ºber gehalten. <br><br>  Dar√ºber hinaus verwendet Go ein ungew√∂hnliches Plan9-Format, das sich sowohl vom AT &amp; T- als auch vom Intel-Format unterscheidet. <br><br><img src="https://habrastorage.org/webt/g4/aq/k5/g4aqk5lflo_4rgmsktoawvsiiuw.png"><br><br>  Man kann mit Sicherheit sagen, dass das Schreiben von Go-Assembler-Code keinen Spa√ü macht. <br><br>  Zum Gl√ºck gibt es bereits zwei √ºbergeordnete Tools, die beim Schreiben der Go-Assemblierung helfen: PeachPy und Avo.  Beide generieren eine Go-Assembly aus einem √ºbergeordneten Code, der in Python bzw. Go geschrieben ist. <br><br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br><br>  Diese Tools vereinfachen Dinge wie die Zuweisung von Registern und Schleifen und reduzieren insgesamt die Komplexit√§t des Einstiegs in den Bereich der Assembly-Programmierung f√ºr Go. <br><br>  Wir werden das Vermeiden f√ºr diesen Beitrag verwenden, damit unsere Programme fast wie gew√∂hnlicher Go-Code aussehen. <br><br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br><br>  Dies ist das einfachste Beispiel f√ºr ein Avo-Programm.  Wir haben eine main () - Funktion, die eine Funktion namens Add () definiert, die zwei Zahlen hinzuf√ºgt.  Es gibt Hilfsfunktionen, um Parameter nach Namen abzurufen und eines der verf√ºgbaren allgemeinen Register abzurufen.  Hier gibt es Funktionen f√ºr jede Assemblierungsoperation wie ADDQ, und es gibt Hilfsfunktionen, um das Ergebnis aus einem Register auf den resultierenden Wert zu speichern. <br><br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br><br>  Wenn Sie go generate aufrufen, wird dieses avo-Programm ausgef√ºhrt und zwei Dateien werden erstellt <br><br><ul><li>  add.s mit generiertem Assemblycode <br></li><li>  stub.go mit Funktionsheadern, die zum Verbinden unseres Go- und Assembly-Codes ben√∂tigt werden <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br><br>  Nachdem wir gesehen haben, was Avo tut, schauen wir uns unsere Funktionen an.  Ich habe sowohl skalare als auch SIMD (Vektor) -Versionen unserer Funktionen implementiert. <br><br>  Mal sehen, wie die skalare Version zuerst aussieht. <br><br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br><br>  Wie in einem vorherigen Beispiel k√∂nnen wir ein allgemeines Register anfordern und vermeiden, dass wir das richtige erhalten, das verf√ºgbar ist.  Wir m√ºssen f√ºr unsere Argumente keine Offsets in Bytes verfolgen, um dies f√ºr uns zu vermeiden. <br><br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br><br>  Zuvor haben wir aus Leistungsgr√ºnden von Schleifen auf goto umgestellt und den go-Compiler get√§uscht.  Hier verwenden wir von Anfang an goto (Spr√ºnge) und Beschriftungen, da Schleifen √ºbergeordnete Konstrukte sind.  In der Montage haben wir nur Spr√ºnge. <br><br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br><br>  Anderer Code sollte ziemlich klar sein.  Wir emulieren die Schleife mit Spr√ºngen und Beschriftungen, nehmen einen kleinen Teil unserer Daten aus unseren beiden Bitmaps, kombinieren sie mit einer der bitweisen Operationen und f√ºgen das Ergebnis in die resultierende Bitmap ein. <br><br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br><br>  Dies ist ein resultierender asm-Code, den wir erhalten.  Wir mussten keine Offsets und Gr√∂√üen (in gr√ºn) berechnen, wir mussten uns nicht mit bestimmten Registern (in rot) befassen. <br><br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br><br>  Wenn wir diese Implementierung in Assembly mit der zuvor besten Implementierung vergleichen, die in go geschrieben wurde, w√ºrden wir feststellen, dass die Leistung dieselbe ist wie erwartet.  Wir haben nichts anders gemacht. <br><br>  Leider k√∂nnen wir den Go-Compiler nicht zwingen, unsere in asm geschriebenen Funktionen zu integrieren.  Es fehlt v√∂llig die Unterst√ºtzung daf√ºr und die Anfrage f√ºr diese Funktion besteht seit einiger Zeit.  Deshalb bieten kleine asm-Funktionen in go keinen Nutzen.  Sie m√ºssen entweder gr√∂√üere Funktionen schreiben, ein neues Paket math / bits verwenden oder asm insgesamt √ºberspringen. <br><br>  Schreiben wir jetzt eine Vektorversion unserer Funktionen. <br><br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br><br>  Ich habe mich f√ºr AVX2 entschieden, daher werden wir 32-Byte-Chunks verwenden.  Es ist dem Skalar in seiner Struktur sehr √§hnlich.  Wir laden Parameter aus, fragen nach allgemeinen Registern usw. <br><br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br><br>  Eine der √Ñnderungen hat mit der Tatsache zu tun, dass Vektoroperationen bestimmte breite Register verwenden.  F√ºr 32 Bytes haben sie das Y-Pr√§fix. Deshalb sehen Sie dort YMM ().  F√ºr 64 Byte h√§tten sie das Z-Pr√§fix gehabt. <br><br>  Ein weiterer Unterschied hat mit der von mir durchgef√ºhrten Optimierung zu tun, die als Abrollen oder Schleifenabwickeln bezeichnet wird.  Ich entschied mich, unsere Schleife teilweise abzuwickeln und 8 Schleifenoperationen nacheinander auszuf√ºhren, bevor ich zur√ºckschleife.  Diese Technik beschleunigt den Code, indem sie die vorhandenen Verzweigungen reduziert, und ist durch die Anzahl der verf√ºgbaren Register ziemlich begrenzt. <br><br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br><br>  Was die Leistung betrifft ... ist es erstaunlich.  Wir haben uns im Vergleich zum vorherigen Besten um das 7-fache verbessert.  Ziemlich beeindruckend, oder? <br><br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br><br>  Es sollte m√∂glich sein, diese Ergebnisse durch die Verwendung von AVX512, Prefetching und m√∂glicherweise sogar durch die Verwendung der JIT-Kompilierung (just in time) anstelle des "manuellen" Abfrageplan-Builders noch weiter zu verbessern. Dies w√§re jedoch ein Thema f√ºr einen v√∂llig anderen Beitrag. <br><br><h2>  Probleme mit dem Bitmap-Index </h2><br>  Nachdem wir die grundlegende Implementierung und die beeindruckende Geschwindigkeit der asm-Implementierung gesehen haben, sprechen wir √ºber die Tatsache, dass Bitmap-Indizes nicht sehr h√§ufig verwendet werden.  Warum ist das so? <br><br><img src="https://habrastorage.org/webt/bp/mr/mw/bpmrmwhfel_gbjklekgwywrj67c.png"><br><br>  √Ñltere Ver√∂ffentlichungen geben uns diese drei Gr√ºnde.  Aber die j√ºngsten und ich argumentieren, dass diese inzwischen "behoben" oder behandelt wurden.  Ich werde hier nicht auf viele Details eingehen, weil wir nicht viel Zeit haben, aber es ist auf jeden Fall einen kurzen Blick wert. <br><br><h2>  Problem mit hoher Kardinalit√§t </h2><br>  Wir haben also erfahren, dass Bitmap-Indizes nur f√ºr Felder mit niedriger Kardinalit√§t m√∂glich sind.  dh Felder mit wenigen unterschiedlichen Werten wie Geschlecht oder Augenfarbe.  Der Grund daf√ºr ist, dass die allgemeine Darstellung (ein Bit pro eindeutigem Wert) f√ºr Werte mit hoher Kardinalit√§t ziemlich gro√ü werden kann.  Infolgedessen kann die Bitmap auch bei geringer Bev√∂lkerungszahl sehr gro√ü werden. <br><br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><br>  Manchmal kann f√ºr diese Felder eine andere Darstellung verwendet werden, z. B. eine Bin√§rzahldarstellung, wie hier gezeigt, aber der gr√∂√üte Game Changer ist eine Komprimierung.  Wissenschaftler haben erstaunliche Komprimierungsalgorithmen entwickelt.  Fast alle basieren auf weit verbreiteten Laufl√§ngenalgorithmen, aber was noch erstaunlicher ist, ist, dass wir keine Bitmaps dekomprimieren m√ºssen, um bitweise Operationen an ihnen durchzuf√ºhren.  Normale bitweise Operationen funktionieren mit komprimierten Bitmaps. <br><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><br>  Vor kurzem haben wir gesehen, dass hybride Ans√§tze wie "br√ºllende Bitmaps" erscheinen.  Roaring-Bitmaps verwenden drei separate Darstellungen f√ºr Bitmaps: Bitmaps, Arrays und "Bitl√§ufe". Sie gleichen die Verwendung dieser drei Darstellungen aus, um die Geschwindigkeit zu maximieren und die Speichernutzung zu minimieren. <br><br>  Br√ºllende Bitmaps finden sich in einigen der am h√§ufigsten verwendeten Anwendungen, und es gibt Implementierungen f√ºr viele Sprachen, einschlie√ülich mehrerer Implementierungen f√ºr Go. <br><br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br><br>  Ein anderer Ansatz, der bei Feldern mit hoher Kardinalit√§t helfen kann, ist das Binning.  Stellen Sie sich vor, wir haben ein Feld, das die Gr√∂√üe einer Person darstellt.  H√∂he ist ein Schwimmer, aber wir sehen das nicht so.  Es interessiert niemanden, ob Ihre Gr√∂√üe 185,2 oder 185,3 cm betr√§gt.  Wir k√∂nnen also "virtuelle Beh√§lter" verwenden, um √§hnliche H√∂hen in denselben Beh√§lter zu dr√ºcken: in diesem Fall den 1-cm-Beh√§lter.  Und wenn Sie davon ausgehen, dass es nur sehr wenige Menschen mit einer Gr√∂√üe von weniger als 50 cm oder mehr als 250 cm gibt, k√∂nnen wir unsere Gr√∂√üe mit einer Kardinalit√§t von ungef√§hr 200 Elementen anstelle einer nahezu unendlichen Kardinalit√§t in das Feld umwandeln.  Bei Bedarf k√∂nnen wir die Ergebnisse sp√§ter zus√§tzlich filtern. <br><br><h2>  Problem mit hohem Durchsatz </h2><br>  Ein weiterer Grund, warum Bitmap-Indizes schlecht sind, ist, dass das Aktualisieren von Bitmaps teuer sein kann. <br>  Datenbanken f√ºhren Aktualisierungen und Suchen parallel durch, sodass Sie in der Lage sein m√ºssen, die Daten zu aktualisieren, w√§hrend m√∂glicherweise Hunderte von Threads Bitmaps durchlaufen, um eine Suche durchzuf√ºhren.  Sperren w√§ren Sperren erforderlich, um Datenrennen oder Datenkonsistenzprobleme zu vermeiden.  Und wo es ein einziges gro√ües Schloss gibt, gibt es einen Schlosskonflikt. <br><br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br><br>  Dieses Problem kann, falls vorhanden, durch Sharding Ihrer Indizes oder gegebenenfalls durch Indexversionen behoben werden. <br><br>  Scherben ist unkompliziert.  Sie teilen sie wie Benutzer in einer Datenbank und jetzt haben Sie anstelle einer Sperre mehrere Sperren, wodurch Ihre Sperrenkonflikte erheblich reduziert werden. <br><br>  Ein anderer Ansatz, der manchmal machbar ist, besteht darin, versionierte Indizes zu haben.  Sie haben den Index, den Sie f√ºr die Suche verwenden, und Sie haben einen Index, den Sie f√ºr Schreibvorg√§nge und Aktualisierungen verwenden.  Und Sie kopieren und schalten sie mit einer niedrigen Frequenz, z. B. 100 oder 500 ms. <br><br>  Dieser Ansatz ist jedoch nur m√∂glich, wenn Ihre App veraltete Suchindizes toleriert, die etwas veraltet sind. <br>  Nat√ºrlich k√∂nnen diese beiden Ans√§tze auch zusammen verwendet werden.  Sie k√∂nnen versionierte Indizes gesplittert haben. <br><br><h2>  Nicht triviale Abfragen </h2><br>  Ein weiteres Problem mit dem Bitmap-Index betrifft die Verwendung von Bitmap-Indizes mit Bereichsabfragen.  Und auf den ersten Blick scheinen bitweise Operationen wie UND und ODER nicht sehr n√ºtzlich f√ºr Bereichsabfragen wie "Gib mir Hotelzimmer, die zwischen 200 und 300 Dollar pro Nacht kosten" zu sein. <br><br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br><br>  Eine naive und sehr ineffiziente L√∂sung w√§re, Ergebnisse f√ºr jeden Preispunkt von 200 bis 300 zu erhalten und die Ergebnisse zu ODER. <br><br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br><br>  Ein etwas besserer Ansatz w√§re es, Binning zu verwenden und unsere Hotels in Preisklassen mit Reichweiten von beispielsweise 50 Dollar einzuteilen.  Dieser Ansatz w√ºrde unsere Suchkosten um etwa das 50-fache reduzieren. <br><br>  Dieses Problem kann aber auch sehr einfach gel√∂st werden, indem eine spezielle Codierung verwendet wird, die Bereichsabfragen m√∂glich und schnell macht.  In der Literatur werden solche Bitmaps als bereichscodierte Bitmaps bezeichnet. <br><br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br><br>  In bereichskodierten Bitmaps setzen wir nicht nur ein bestimmtes Bit f√ºr beispielsweise den Wert 200, sondern setzen alle Bits auf 200 und h√∂her.  Das gleiche gilt f√ºr 300. <br><br>  Mit dieser bereichskodierten Bitmap-Darstellung kann die Bereichsabfrage mit nur zwei Durchg√§ngen durch die Bitmap beantwortet werden.  Wir erhalten alle Hotels, die weniger als oder gleich 300 Dollar kosten, und entfernen alle Hotels, die weniger als oder gleich 199 Dollar kosten, aus dem Ergebnis.  Fertig <br><br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br><br>  Sie werden erstaunt sein, aber mit Bitmaps sind auch Geo-Abfragen m√∂glich.  Der Trick besteht darin, eine Darstellung wie Google S2 oder √§hnliches zu verwenden, die eine Koordinate in einer geometrischen Figur einschlie√üt, die als drei oder mehr indizierte Linien dargestellt werden kann.  Wenn Sie eine solche Darstellung verwenden, k√∂nnen Sie die Geoabfrage als mehrere Bereichsabfragen in diesen Zeilenindizes darstellen. <br><br><h2>  Fertige L√∂sungen </h2><br>  Nun, ich hoffe, dass ich Ihr Interesse ein wenig geweckt habe.  Sie haben jetzt ein weiteres Tool unter Ihrem G√ºrtel und wenn Sie jemals so etwas in Ihrem Service implementieren m√ºssen, wissen Sie, wo Sie suchen m√ºssen. <br><br>  Das ist alles sch√∂n und gut, aber nicht jeder hat die Zeit, die Geduld und die Ressourcen, um den Bitmap-Index selbst zu implementieren, insbesondere wenn es um fortgeschrittenere Dinge wie SIMD-Anweisungen geht. <br><br>  F√ºrchte dich nicht, es gibt zwei Open Source-Produkte, die dir bei deinen Bem√ºhungen helfen k√∂nnen. <br><br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><br><h2>  Br√ºllend </h2><br>  Erstens gibt es eine Bibliothek, die ich bereits erw√§hnt habe und die "br√ºllende Bitmaps" hei√üt.  Diese Bibliothek implementiert br√ºllenden "Container" und alle bitweisen Operationen, die Sie ben√∂tigen w√ºrden, wenn Sie einen vollst√§ndigen Bitmap-Index implementieren w√ºrden. <br><br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br><br>  Leider verwenden Go-Implementierungen kein SIMD, sodass sie eine etwas geringere Leistung bieten als beispielsweise die C-Implementierung. <br><br><h2>  Pilosa </h2><br>  Ein weiteres Produkt ist ein DBMS namens Pilosa, das nur Bitmap-Indizes enth√§lt.  Es ist ein aktuelles Projekt, aber es hat in letzter Zeit viel Zugkraft gewonnen. <br><br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg">  E-d3BCvTn1CSSDr5Vj6W_9e5_GC1syQ9qSrwdS0 "&gt; <br><br>  Pilosa verwendet br√ºllende Bitmaps darunter und gibt, vereinfacht oder erkl√§rt fast alle Dinge, √ºber die ich Ihnen heute erz√§hlt habe: Binning, bereichskodierte Bitmaps, die Vorstellung von Feldern usw. <br><br>  Schauen wir uns kurz ein Beispiel f√ºr Pilosa an ... <br><br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br><br>  Das Beispiel, das Sie sehen, ist dem, was wir zuvor gesehen haben, sehr, sehr √§hnlich.  Wir erstellen einen Client f√ºr den Pilosa-Server, erstellen einen Index und Felder f√ºr unsere Merkmale.  Wir f√ºllen die Felder mit zuf√§lligen Daten mit einigen Wahrscheinlichkeiten wie zuvor und f√ºhren dann unsere Suchabfrage aus. <br>  Sie sehen hier das gleiche Grundmuster.  NICHT teuer gekreuzt oder UND-ed mit Terrasse und gekreuzt mit Reservierungen. <br><br>  Das Ergebnis ist wie erwartet. <br><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><br>  Und schlie√ülich hoffe ich, dass Datenbanken wie mysql und postgresql irgendwann in der Zukunft einen neuen Indextyp erhalten: den Bitmap-Index. <br><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><br><h2>  Schlussworte </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br><br>  Und wenn Sie noch wach sind, danke ich Ihnen daf√ºr.  Zeitmangel hat dazu gef√ºhrt, dass ich viele Dinge in diesem Beitrag √ºberfliegen musste, aber ich hoffe, es war n√ºtzlich und vielleicht sogar inspirierend. <br><br>  Bitmap-Indizes sind eine n√ºtzliche Sache, die Sie kennen und verstehen sollten, auch wenn Sie sie gerade nicht ben√∂tigen.  Behalten Sie sie als ein weiteres Werkzeug in Ihrem Portfolio. <br><br>  W√§hrend meines Vortrags haben wir verschiedene Performance-Tricks gesehen, die wir anwenden k√∂nnen, und Dinge, mit denen Go im Moment zu k√§mpfen hat.  Dies sind definitiv Dinge, die jeder Go-Programmierer da drau√üen wissen muss. <br><br>  Und das ist alles, was ich jetzt f√ºr dich habe.  Vielen Dank! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455608/">https://habr.com/ru/post/de455608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455598/index.html">Aktualisieren Sie Exim dringend auf 4.92 - es liegt eine aktive Infektion vor</a></li>
<li><a href="../de455600/index.html">Die 3DEXPERIENCE-Plattform hilft bei der Schaffung √∂ffentlicher Verkehrsmittel der Zukunft</a></li>
<li><a href="../de455602/index.html">Das Provozieren von Browsern st√ºrzt mit Verhaltensfuzzing ab</a></li>
<li><a href="../de455604/index.html">Verantwortlich f√ºr die Verwaltung der Windows-Konfiguration. Erfolgsgeschichte</a></li>
<li><a href="../de455606/index.html">Maschinelles Lernen und Datenanalyse: Masterstudiengang an der Higher School of Economics in St. Petersburg</a></li>
<li><a href="../de455610/index.html">Legend√§rer Intel Core i7-2600K: Testen von Sandy Bridge im Jahr 2019 (Teil 1)</a></li>
<li><a href="../de455612/index.html">Wir denken √ºber die Charaktere von Spielen und Dialogen nach dem Rat von Schriftstellern und am Beispiel von Unterst√ºtzern der Theorie einer flachen Erde nach</a></li>
<li><a href="../de455614/index.html">FFI: Schreiben in Rust in einem PHP-Programm</a></li>
<li><a href="../de455616/index.html">Warum zu "Industrial Programming" in der St. Petersburg HSE gehen?</a></li>
<li><a href="../de455618/index.html">DevOps LEGO: Wie wir eine Pipeline auf W√ºrfeln angelegt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>