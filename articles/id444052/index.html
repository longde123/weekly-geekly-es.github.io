<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“º â›´ï¸ ğŸ›°ï¸ Bagaimana kami di IntelliJ IDEA mencari ekspresi lambda ğŸ· ğŸ‘¸ğŸ» ğŸ¤œğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fitur penting dari setiap IDE adalah pencarian dan navigasi melalui kode. Salah satu opsi pencarian Java yang sering digunakan adalah untuk mencari se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami di IntelliJ IDEA mencari ekspresi lambda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains/blog/444052/"><p><img alt="Ketik Hirarki di IntelliJ IDEA" src="https://habrastorage.org/webt/ff/js/7m/ffjs7m9ycsved2ciyrqdvb4uiwe.png" align="right" width="300">  Fitur penting dari setiap IDE adalah pencarian dan navigasi melalui kode.  Salah satu opsi pencarian Java yang sering digunakan adalah untuk mencari semua implementasi dari antarmuka ini.  Seringkali fungsi seperti itu disebut Hirarki Tipe dan terlihat seperti gambar di sebelah kanan. </p><br><p>  Iterasi melalui semua kelas proyek ketika memanggil fungsi ini tidak efisien.  Anda dapat menyimpan hierarki kelas penuh ke indeks pada waktu kompilasi, karena kompiler tetap membuatnya.  Kami melakukan ini jika kompilasi dimulai oleh IDE itu sendiri dan tidak didelegasikan, misalnya, di Gradle.  Tetapi ini hanya berfungsi jika tidak ada yang berubah dalam modul setelah kompilasi.  Tetapi dalam kasus umum, kode sumber adalah sumber informasi yang paling relevan, dan indeks dibuat berdasarkan kode sumber. </p><br><p> Menemukan pewaris langsung adalah tugas sederhana jika kita tidak berurusan dengan antarmuka fungsional.  Saat mencari implementasi dari antarmuka <code>Foo</code> , Anda perlu menemukan semua kelas di mana ada <code>implements Foo</code> , dan antarmuka di mana ada <code>extends Foo</code> , serta kelas anonim dari formulir <code>new Foo(...) {...}</code> .  Untuk melakukan ini, cukup membangun pohon sintaksis dari setiap file proyek terlebih dahulu, menemukan konstruksi yang sesuai dan menambahkannya ke indeks. </p><a name="habracut"></a><br><p>  Tentu saja, ada sedikit kehalusan di sini: mungkin Anda mencari antarmuka <code>com.example.goodcompany.Foo</code> , tetapi di suatu tempat <code>org.example.evilcompany.Foo</code> sebenarnya digunakan.  Apakah mungkin untuk memasukkan nama lengkap dari antarmuka induk dalam indeks?  Ada kesulitan dengan ini.  Misalnya, file tempat antarmuka digunakan mungkin terlihat seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// MyFoo.java import org.example.foo.*; import org.example.bar.*; import org.example.evilcompany.*; class MyFoo implements Foo {...}</span></span></code> </pre> <br><p>  Melihat hanya pada file, kita tidak bisa mengerti apa nama sebenarnya <code>Foo</code> .  Anda harus melihat isi beberapa paket.  Dan setiap paket dapat didefinisikan di beberapa tempat (misalnya, dalam beberapa file jar).  Pengindeksan akan memakan waktu lama jika, dalam menganalisis file ini, kita harus melakukan resolusi penuh karakter.  Tetapi masalah utamanya bukan ini, tetapi indeks yang dibangun di atas file <code>MyFoo.java</code> tidak hanya bergantung pada itu, tetapi juga pada file lain.  Lagipula, kita dapat mentransfer deskripsi antarmuka <code>Foo</code> , misalnya, dari paket <code>org.example.foo</code> ke paket <code>org.example.bar</code> , dan tidak mengubah apa pun di file <code>MyFoo.java</code> , dan nama lengkap <code>Foo</code> akan berubah. </p><br><p>  Indeks dalam IntelliJ IDEA hanya bergantung pada konten dari satu file.  Di satu sisi, ini sangat nyaman: indeks yang berkaitan dengan file tertentu menjadi tidak valid ketika file ini berubah.  Di sisi lain, ini memberlakukan batasan besar pada apa yang dapat ditempatkan dalam indeks.  Sebagai contoh, itu tidak bisa dipercaya menyimpan nama lengkap dari kelas induk dalam indeks.  Tetapi, pada prinsipnya, ini tidak begitu menakutkan.  Saat menanyakan hierarki jenis, kita dapat menemukan semua yang sesuai dengan nama pendek, dan kemudian untuk file-file ini melakukan resolusi karakter yang jujur â€‹â€‹dan menentukan apakah itu benar-benar cocok untuk kita.  Dalam kebanyakan kasus, tidak akan ada terlalu banyak karakter tambahan, dan pemeriksaan seperti itu akan cukup cepat. </p><br><p><img alt="Hirarki Antarmuka Fungsional di IntelliJ IDEA" src="https://habrastorage.org/webt/e-/nn/0y/e-nn0ynvtojiydboaco5uiyzwms.png" align="right" width="300">  Situasi berubah secara dramatis ketika kelas yang keturunannya kita cari adalah antarmuka fungsional.  Kemudian, selain pewaris eksplisit dan anonim, kami mendapatkan ekspresi lambda dan tautan metode.  Apa yang sekarang dimasukkan ke dalam indeks, dan apa yang harus dihitung langsung pada pencarian? </p><br><p>  Misalkan kita memiliki antarmuka fungsional: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">consume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String s)</span></span></span></span>; }</code> </pre> <br><p>  Ada berbagai ekspresi lambda dalam kode.  Sebagai contoh: </p><br><pre> <code class="java hljs">() -&gt; {} <span class="hljs-comment"><span class="hljs-comment">//   :   (a, b) -&gt; a + b //   :   s -&gt; { return list.add(s); //   :   } s -&gt; list.add(s); //   </span></span></code> </pre> <br><p>  Artinya, kita dapat dengan cepat menyaring hanya lambda yang memiliki jumlah parameter yang salah atau jelas jenis pengembalian yang salah, misalnya void versus non-void.  Biasanya tidak mungkin untuk menentukan jenis pengembalian lebih tepat.  Katakan, dalam lambda <code>s -&gt; list.add(s)</code> untuk ini, Anda perlu menyelesaikan <code>list</code> karakter dan <code>add</code> , dan, mungkin, memulai prosedur inferensi jenis lengkap.  Semua ini panjang dan akan membutuhkan pengikatan pada isi file lain. </p><br><p>  Kami beruntung jika antarmuka fungsional kami membutuhkan lima argumen.  Tetapi jika hanya membutuhkan satu argumen, filter seperti itu akan meninggalkan sejumlah besar lambda tambahan.  Lebih buruk lagi dengan referensi metode.  Pada prinsipnya, kemunculan referensi apa pun terhadap suatu metode tidak dapat dikatakan dengan cara apa pun apakah itu sesuai atau tidak. </p><br><p>  Mungkin Anda harus melihat-lihat lambda untuk memahami sesuatu?  Ya, terkadang berhasil.  Sebagai contoh: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//        Predicate&lt;String&gt; p = s -&gt; list.add(s); //      IntPredicate getPredicate() { return s -&gt; list.add(s); } //      SomeType fn; fn = s -&gt; list.add(s); //     foo((SomeFunctionalType)(s -&gt; list.add(s))); //     Foo[] myLambdas = {s -&gt; list.add(s), s -&gt; list.remove(s)};</span></span></code> </pre> <br><p>  Dalam semua kasus ini, nama pendek dari antarmuka fungsional yang sesuai dapat ditemukan dari file saat ini dan dimasukkan ke dalam indeks di sebelah ekspresi fungsional, baik itu lambda atau referensi metode.  Sayangnya, dalam proyek nyata, kasus-kasus ini mencakup sebagian kecil dari semua lambda.  Dalam sebagian besar kasus, lambda digunakan sebagai argumen untuk metode: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Manakah dari tiga lambda ini yang bisa bertipe <code>StringConsumer</code> ?  Jelas bagi programmer bahwa tidak ada.  Karena jelas bahwa di sini kami memiliki rantai API Stream, dan hanya ada antarmuka fungsional dari pustaka standar, tipe kami tidak bisa ada di sana. </p><br><p>  Namun, IDE jangan sampai dibohongi, tetapi harus memberikan jawaban yang akurat.  Bagaimana jika <code>list</code> tersebut bukan <code>java.util.List</code> sama sekali, dan <code>list.stream()</code> tidak mengembalikan <code>java.util.stream.Stream</code> sama sekali?  Untuk melakukan ini, Anda harus menyelesaikan simbol <code>list</code> , yang, seperti yang kita ketahui, tidak dapat dilakukan dengan andal hanya berdasarkan konten file saat ini.  Dan bahkan jika kita menginstalnya, pencarian tidak boleh diletakkan pada implementasi perpustakaan standar.  Mungkin kita secara khusus dalam proyek ini mengganti kelas <code>java.util.List</code> dengan kita sendiri?  Pencarian harus menanggapi ini.  Yah, tentu saja, lambda digunakan tidak hanya dalam aliran standar, ada banyak metode lain di mana mereka ditransfer. </p><br><p>  Hasilnya, ternyata kami dapat meminta indeks untuk daftar semua file Java yang menggunakan lambdas dengan jumlah parameter yang diperlukan dan jenis pengembalian yang valid (pada kenyataannya, kami hanya melacak empat opsi: void, non-void, boolean, dan apa saja).  Lalu apa?  Untuk masing-masing file ini, buat pohon PSI lengkap (apakah seperti pohon parse, tetapi dengan resolusi karakter, inferensi tipe, dan hal-hal pintar lainnya) dan jalankan inferensi tipe jujur â€‹â€‹untuk lambda?  Kemudian dalam proyek besar Anda tidak akan menunggu daftar semua implementasi antarmuka, bahkan jika hanya ada dua dari mereka. </p><br><p>  Ternyata kita perlu melakukan langkah-langkah berikut: </p><br><ul><li>  Tanyakan indeksnya (murah) </li><li>  Membangun PSI (mahal) </li><li>  Jenis cetak lambda (sangat mahal) </li></ul><br><p>  Dalam Java versi 8 dan yang lebih baru, ketik inferensi adalah operasi yang sangat mahal.  Dalam rantai panggilan yang kompleks, Anda dapat memiliki banyak parameter wildcard generik, yang nilainya perlu ditentukan menggunakan prosedur marah yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bab 18 dari</a> spesifikasi.  Ini dapat dilakukan di latar belakang untuk file yang sedang diedit, tetapi akan sulit untuk melakukan ini untuk ribuan file yang belum dibuka. </p><br><p>  Di sini, bagaimanapun, Anda dapat memotong sudut sedikit: dalam kebanyakan kasus kita tidak perlu tipe final.  Jika hanya lambda tidak diteruskan ke metode yang mengambil parameter generik di tempat ini, kita bisa menyingkirkan langkah terakhir dari penggantian parameter.  Katakanlah, jika kita menyimpulkan tipe lambda <code>java.util.function.Function&lt;T, R&gt;</code> , kita tidak dapat menghitung nilai parameter substitusi <code>T</code> dan <code>R</code> : dan jadi jelas apakah akan mengembalikannya ke hasil pencarian atau tidak.  Meskipun ini tidak akan berfungsi ketika memanggil metode seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; aClass, T value)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br><p>  Metode ini bisa disebut seperti ini: <code>doSmth(Runnable.class, () -&gt; {})</code> .  Maka jenis lambda akan ditampilkan sebagai <code>T</code> , dan Anda harus mengganti pula.  Tapi ini kasus yang jarang terjadi.  Karena itu, ternyata menghemat, tetapi tidak lebih dari 10%.  Masalahnya tidak terpecahkan secara mendasar. </p><br><p>  Gagasan lain: jika inferensi tipe yang tepat kompleks, maka mari buat kesimpulan perkiraan.  Biarkan ini bekerja hanya pada tipe kelas yang terhapus dan tidak mengurangi set batasan, seperti yang tertulis dalam spesifikasi, tetapi cukup ikuti rantai panggilan.  Selama tipe yang dihapus tidak termasuk parameter generik, maka semuanya baik-baik saja.  Misalnya, ambil aliran dari contoh di atas dan tentukan apakah lambda terakhir mengimplementasikan <code>StringConsumer</code> kami: </p><br><ul><li>  <code>list</code> variabel -&gt; ketik <code>java.util.List</code> </li><li>  <code>List.stream()</code> - <code>List.stream()</code> tipe <code>java.util.stream.Stream</code> </li><li>  <code>Stream.filter(...)</code> â†’ ketik <code>java.util.stream.Stream</code> , kami bahkan tidak melihat argumen <code>filter</code> , apa bedanya </li><li>  <code>Stream.map(...)</code> - <code>Stream.map(...)</code> tipe <code>java.util.stream.Stream</code> , sama </li><li>  Metode <code>Stream.forEach(...)</code> â†’ ada metode seperti itu, parameternya adalah tipe <code>Consumer</code> , yang, jelas, bukan <code>StringConsumer</code> . </li></ul><br><p>  Yah, mereka melakukannya tanpa inferensi tipe penuh.  Namun, dengan pendekatan sederhana seperti itu, mudah untuk mengalami metode kelebihan beban.  Jika kami tidak memulai inferensi jenis sepenuhnya, maka Anda tidak dapat memilih versi kelebihan beban yang benar.  Meskipun tidak, kadang-kadang mungkin jika jumlah parameter metode berbeda.  Sebagai contoh: </p><br><pre> <code class="java hljs">CompletableFuture.supplyAsync(Foo::bar, myExecutor).thenRunAsync(s -&gt; list.add(s));</code> </pre> <br><p>  Di sini kita dapat dengan mudah memahaminya </p><br><ul><li>  Ada dua metode <code>CompletableFuture.supplyAsync</code> , tetapi satu mengambil satu argumen dan yang kedua mengambil dua, jadi pilihlah yang membutuhkan dua.  Ini mengembalikan <code>CompletableFuture</code> . </li><li>  Metode <code>thenRunAsync</code> juga dua, dan dari mereka Anda juga dapat memilih salah satu yang mengambil satu argumen.  Parameter yang sesuai bertipe <code>Runnable</code> , yang berarti bukan <code>StringConsumer</code> . </li></ul><br><p>  Jika beberapa metode menerima jumlah parameter yang sama, atau beberapa memiliki sejumlah variabel parameter dan juga terlihat cocok, maka Anda harus melacak semua opsi.  Namun seringkali ini juga tidak menakutkan.  Sebagai contoh: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder().append(foo).append(bar).chars().forEach(s -&gt; list.add(s));</code> </pre> <br><ul><li>  <code>new StringBuilder()</code> jelas menciptakan <code>java.lang.StringBuilder</code> .  Untuk desainer, kami masih mengizinkan tautan, tetapi inferensi tipe kompleks tidak diperlukan di sini.  Bahkan jika ada <code>new Foo&lt;&gt;(x, y, z)</code> , kami tidak menampilkan nilai-nilai parameter khas, kami hanya tertarik pada <code>Foo</code> . </li><li>  Ada <code>StringBuilder.append</code> metode <code>StringBuilder.append</code> yang mengambil satu argumen, tetapi semuanya mengembalikan tipe <code>java.lang.StringBuilder</code> , jadi tidak masalah apa pun jenis <code>foo</code> dan <code>bar</code> . </li><li>  Metode <code>StringBuilder.chars</code> satu dan mengembalikan <code>java.util.stream.IntStream</code> . </li><li>  Metode <code>IntStream.forEach</code> satu dan menerima tipe <code>IntConsumer</code> . </li></ul><br><p>  Bahkan jika beberapa opsi tetap ada di suatu tempat, Anda dapat melacak semuanya.  Misalnya, jenis lambda yang diteruskan ke <code>ForkJoinPool.getInstance().submit(...)</code> mungkin <code>Runnable</code> atau <code>Callable</code> , tetapi jika kita mencari sesuatu yang ketiga, kita masih dapat membuang lambda itu. </p><br><p>  Situasi yang tidak menyenangkan terjadi ketika suatu metode mengembalikan parameter generik.  Kemudian prosedur rusak dan Anda harus menjalankan inferensi tipe penuh.  Namun, kami mendukung satu kasing.  Itu muncul dengan baik di perpustakaan StreamEx saya, yang memiliki kelas abstrak <code>AbstractStreamEx&lt;T, S extends AbstractStreamEx&lt;T, S&gt;&gt;</code> berisi metode seperti <code>S filter(Predicate&lt;? super T&gt; predicate)</code> .  Biasanya orang bekerja dengan kelas tertentu <code>StreamEx&lt;T&gt; extends AbstractStreamEx&lt;T, StreamEx&lt;T&gt;&gt;</code> .  Dalam hal ini, Anda dapat melakukan penggantian parameter tipe dan mengetahui bahwa <code>S = StreamEx</code> . </p><br><p>  Nah, dalam banyak kasus kami menyingkirkan inferensi tipe yang sangat mahal.  Tapi kami tidak melakukan apa pun dengan pembangunan PSI.  Sayang memilah file menjadi lima ratus baris hanya untuk mengetahui bahwa lambda di baris 480 tidak sesuai dengan kueri kami.  Mari kita kembali ke aliran kita: </p><br><pre> <code class="java hljs">list.stream() .filter(s -&gt; StringUtil.isNonEmpty(s)) .map(s -&gt; s.trim()) .forEach(s -&gt; list.add(s));</code> </pre> <br><p>  Jika <code>list</code> adalah variabel lokal, parameter metode atau bidang dalam kelas saat ini, maka sudah pada tahap pengindeksan kita dapat menemukan deklarasi dan menetapkan bahwa nama pendek dari tipe tersebut adalah <br>  <code>List</code>  Dengan demikian, dalam indeks untuk lambda terakhir kita dapat memasukkan informasi berikut: </p><br><blockquote>  Tipe lambda ini adalah tipe parameter dari metode <code>forEach</code> dari satu argumen, dipanggil pada hasil metode <code>map</code> dari satu argumen, dipanggil pada hasil dari metode <code>filter</code> dari satu argumen, dipanggil pada hasil dari metode <code>stream</code> dari argumen nol, dipanggil pada objek dari daftar tipe. </blockquote><p>  Semua informasi ini tersedia di file saat ini, yang berarti dapat ditempatkan dalam indeks.  Selama pencarian, kami meminta indeks untuk informasi seperti itu tentang semua lambda dan mencoba mengembalikan tipe lambda tanpa membangun PSI.  Pertama, Anda harus melakukan pencarian global untuk kelas dengan <code>List</code> nama pendek.  Tentu saja, kita tidak hanya akan menemukan <code>java.util.List</code> , tetapi juga <code>java.awt.List</code> atau sesuatu dari kode proyek pengguna.  Selanjutnya kami akan menyerahkan semua kelas ini ke prosedur yang sama dari resolusi tipe yang tidak akurat yang kami gunakan sebelumnya.  Seringkali kelas tambahan sendiri dengan cepat disaring.  Sebagai contoh, di <code>java.awt.List</code> tidak ada metode <code>stream</code> , oleh karena itu dikecualikan lebih lanjut.  Tetapi bahkan jika sesuatu yang berlebihan ada bersama kita sampai akhir dan kita menemukan beberapa kandidat untuk jenis lambda kita, ada peluang bagus bahwa mereka semua tidak akan sesuai dengan permintaan pencarian, dan kita masih akan menghindari membangun PSI penuh. </p><br><p>  Ada kemungkinan bahwa pencarian global akan terlalu mahal (ada banyak kelas <code>List</code> dalam proyek), baik awal rantai tidak diperbolehkan dalam konteks satu file (katakanlah ini adalah bidang kelas induk), atau rantai akan pecah di suatu tempat, karena metode mengembalikan parameter generik.  Maka kami tidak menyerah segera dan mencoba lagi untuk memulai dengan pencarian global pada metode rantai berikutnya.  Misalnya, untuk <code>map.get(key).updateAndGet(a -&gt; a * 2)</code> , pernyataan berikut masuk ke dalam indeks: </p><br><blockquote>  Tipe lambda adalah tipe satu-satunya parameter dari metode <code>updateAndGet</code> , dipanggil pada hasil metode <code>get</code> dengan satu parameter, dipanggil pada objek tipe <code>Map</code> . </blockquote><p>  Mari kita beruntung dan dalam proyek ini hanya ada satu jenis <code>Map</code> - <code>java.util.Map</code> .  Itu memang memiliki metode <code>get(Object)</code> , tapi sayangnya ia mengembalikan parameter generik <code>V</code>  Lalu kita lepaskan rantai dan lihat secara global untuk metode <code>updateAndGet</code> dengan satu parameter (tentu saja menggunakan indeks).  <code>AtomicInteger</code> , hanya ada tiga metode dalam proyek ini, di kelas <code>AtomicInteger</code> , <code>AtomicLong</code> dan <code>AtomicReference</code> dengan parameter tipe <code>IntUnaryOperator</code> , <code>LongUnaryOperator</code> dan <code>UnaryOperator</code> .  Jika kami mencari jenis lain, maka kami menemukan bahwa lambda ini tidak cocok dan PSI tidak dapat dibangun. </p><br><p>  Anehnya, ini adalah contoh nyata dari fitur yang, seiring waktu, itu sendiri mulai bekerja lebih lambat.  Misalnya, Anda mencari implementasi antarmuka fungsional, hanya ada tiga di antaranya dalam proyek, dan IntelliJ IDEA mencari mereka selama sepuluh detik.  Dan Anda ingat betul bahwa tiga tahun lalu ada juga tiga, Anda juga mencarinya, tetapi kemudian lingkungan memberi jawaban dalam dua detik pada mesin yang sama.  Dan proyek Anda, meskipun besar, telah berkembang dalam tiga tahun, mungkin sebesar lima persen.  Tentu saja, Anda mulai membenci apa yang dikacaukan oleh para pengembang ini sehingga IDE mulai sangat lambat.  Tangan untuk merobek programmer yang malang ini. </p><br><p>  Dan mungkin kita tidak mengubah apa pun.  Mungkin pencariannya sama dengan tiga tahun lalu.  Hanya tiga tahun yang lalu Anda baru saja beralih ke Java 8, dan Anda telah, katakanlah, seratus lambda dalam proyek Anda.  Dan sekarang kolega Anda mengubah kelas anonim menjadi lambda, mulai aktif menggunakan aliran atau menghubungkan semacam perpustakaan reaktif, sebagai akibat dari lambdas itu menjadi bukan seratus, tetapi sepuluh ribu.  Dan sekarang, untuk menggali tiga lambda yang diperlukan, IDE harus dicari seratus kali lebih banyak. </p><br><p>  Saya berkata "mungkin" karena, tentu saja, kami kembali ke pencarian ini dari waktu ke waktu dan mencoba mempercepatnya.  Tapi di sini Anda harus mendayung bahkan tidak melawan arus, tetapi naik air terjun.  Kami mencoba, tetapi jumlah lambda dalam proyek tumbuh sangat cepat. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444052/">https://habr.com/ru/post/id444052/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444038/index.html">Pengalaman menggunakan "koordinator" dalam proyek "iOS" nyata</a></li>
<li><a href="../id444040/index.html">Peringkat autosentris. Laporan Yandex tentang menemukan audiens yang relevan untuk penulis Zen</a></li>
<li><a href="../id444044/index.html">Eropa akan mendaur ulang pusat data besi</a></li>
<li><a href="../id444048/index.html">Tip & Trik Forensik Digital: Cara Mendeteksi Perubahan Kebijakan Grup yang digerakkan oleh Penyelundup</a></li>
<li><a href="../id444050/index.html">Diskusi: Apakah Penyimpanan DNA Menjadi Masif</a></li>
<li><a href="../id444056/index.html">Penyedia internet di Krimea meningkat tajam harga untuk layanan</a></li>
<li><a href="../id444058/index.html">Ketika anak-anak mengerti bahwa seluruh hidup mereka sudah online</a></li>
<li><a href="../id444060/index.html">Bermigrasi dari Nagios ke Icinga2 di Australia</a></li>
<li><a href="../id444062/index.html">Menyala! Transformasi malam dari Lakhta Center</a></li>
<li><a href="../id444064/index.html">Gagasan baru untuk masa depan yang baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>