<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏉 💻 🧔 当我们在NASA太空应用程序挑战黑客马拉松上编写应用程序时 🙏🏼 🐫 🤦🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="10月20日至21日，“ 美国国家航空航天局（NASA）太空应用挑战赛”国际黑客马拉松在莫斯科举行。 它在俄罗斯的组织者来自Russian.Hackers社区。 作为活动的一部分，参与者被要求解决20个不同主题的案例：从拍摄有关黑客马拉松的电影到开发监控应用程序和设计自动飞机。 主题的完整列表可以通...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>当我们在NASA太空应用程序挑战黑客马拉松上编写应用程序时</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/singularis/blog/430480/">  10月20日至21日，“ <strong>美国国家航空航天局（NASA）太空应用挑战赛”</strong>国际黑客马拉松在莫斯科举行。 它在俄罗斯的组织者来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Russian.Hackers</a>社区。 作为活动的一部分，参与者被要求解决20个不同主题的案例：从拍摄有关黑客马拉松的电影到开发监控应用程序和设计自动飞机。 主题的完整列表可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考</a>或在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Habré上</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章中</a>进行研究。 <br><img src="https://habrastorage.org/webt/zb/xr/n8/zbxrn8ng1jnvhth73omf4dgorbe.png"><br> 我们的“ Space Monkeys”团队包括Oleg Borodin（Singularis实验室的前端开发人员），Vladislav Plotnikov（Singularis实验室的QA工程师），Yegor Shvetsov，Dmitry Petrov，Yuri Bederov和Nikolai Denisenko在内，决定解决这个棘手的问题标题为“火灾现场！”，其措辞如下：“ <em>应用众包，使人们能够为森林火灾的发现，确认和跟踪做出贡献。</em>  <em>该解决方案可以是移动应用程序或Web应用程序。</em>  ” <br><br> 由于该团队聚集了5位具有针对各种平台开发经验的开发人员，因此立即决定将我们的应用程序原型应用于Web和Mobile平台。 <br><a name="habracut"></a><br><h2> 我们使用了哪些NASA数据？ </h2><br><p>尽管如此，这次黑客马拉松还是在美国国家航空航天局的主持下举行的，因此不使用来自NASA储藏室的开放数据是错误的。 此外，我们立即找到了所需的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Active Fire Data数据</a>集。 该数据集包含有关世界各地火灾坐标的信息（您可以下载特定大陆上的信息）。 数据每天更新（您可以在24小时，48小时，7天之内收到数据）。 </p><br><p> 该文件包含以下字段的信息：纬度，经度，亮度，扫描，跟踪，acq_date，acq_time，卫星，置信度，版本，bright_t31，frp，白天，其中我们仅使用着火点的坐标（纬度和经度）。 </p><br><h2> 应用原理 </h2><br><p> 由于应用程序是众包的，因此理想情况下，应由大量用户使用。 该应用程序的原理如下： </p><br><ol><li><p> 检测到火灾的用户为火灾拍照（带有地理标记）并使用该服务加载火灾。 具有地理标签和发送坐标的照片将转到应用程序服务器。 可以从Web或移动版本的应用程序下载摄影。 </p></li><li><p> 得到的照片由训练有素的神经网络在服务器上进行处理，以确认照片确实着火了。 脚本的结果是预测的准确性，如果&gt; 0.7，则照片确实会发光。 否则，我们不会记录此信息，并要求用户上传另一张照片。 </p></li><li><p> 如果图像分析脚本给出了肯定的结果，则来自地理标签的坐标将与所有坐标一起添加到数据集中。 接下来，计算来自NASA数据集的第<em>i</em>个点与来自用户的点之间的距离。 如果点之间的距离<strong>≤3</strong> km，则将来自NASA集合的点添加到字典中。 因此，我们遍历了所有要点。 之后，将坐标满足条件的json返回到应用程序的客户端。 如果在给定条件下找不到坐标，那么我们将返回从用户那里收到的唯一点。 </p></li><li><p> 如果服务器返回一个点数组，则该应用程序的客户端部分将在地图上绘制一个防火区域。 如果服务器返回了一个点，则会在地图上标记一个特殊标签。 </p></li></ol><br><h2> 二手技术栈 </h2><br><h3>  <em>Web应用程序的前端部分</em> </h3><br><p> 可从浏览器访问的Web应用程序专注于计算机屏幕，并且不具有自适应性，但是，易于使用的技术使针对移动设备改进此方面成为可能。 我们在网络端使用了以下技术堆栈： </p><br><ul><li>  Google的Angular 6 TypeScript框架 </li><li>  CSS＆JS框架实现 </li><li> 用于下载文件的模块<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ng2-file-upload</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">OpenStreetMap</a>地图， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">传单</a>库 </li></ul><br><h4> 工作场景 </h4><br><p> 用户打开应用程序并查看其位置： </p><br><img src="https://habrastorage.org/webt/p2/j1/uk/p2j1ukxxirwd_5ch-rsaje4sflc.jpeg"><br><br><p> 地图和用户地理位置的初始化： </p><br><pre><code class="plaintext hljs">this.map = L.map('map').setView([latitude, longitude], 17); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&amp; copy; &lt;a href="https://www.openstreetmap.org/copyright"&gt;OpenStreetMap&lt;/a&gt; contributors' }).addTo(this.map); L.circle([latitude, longitude]).addTo(this.map) .bindPopup('You are here') .openPopup();</code> </pre> <br><p> 如果方圆<em>n</em> （自定义变量）的半径处着火，那么它将以多边形的形式显示，并带有其他信息的摘要： </p><br><img src="https://habrastorage.org/webt/6q/1e/k5/6q1ek54slbxacie85pqrdsuwzko.jpeg"><br><br><p> 用户在地图上选择一个火灾地点： </p><br><img src="https://habrastorage.org/webt/1t/qv/p9/1tqvp9ytbpe3r1kmwogvtviii34.jpeg"><br><br><p> 消防标签设置： </p><br><pre> <code class="plaintext hljs">let marker; this.map.on('click', function (e) { if (marker) { self.map.removeLayer(marker); } marker = L.circle([e.latlng.lat, e.latlng.lng], { color: 'red', fillColor: '#f03', fillOpacity: 0.5, radius: 15 }).addTo(self.map) .bindPopup(' ') .openPopup(); self.appService.coordinatesStorage.latitude = e.latlng.lat; self.appService.coordinatesStorage.longitude = e.latlng.lng; console.log('fire', self.appService.coordinatesStorage); });</code> </pre><br><p> 接下来，用户使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ng2-file-upload上传</a>火的照片。 </p><br><p> 这些操作的结果是，以下数据被传输到服务器： </p><br><ul><li> 用户坐标 </li><li> 指定火的坐标 </li><li> 火照片 </li></ul><br><p> 应用程序的输出是识别结果。 </p><br><br><h3>  <em>手机应用程序</em> </h3><br><h4> 二手技术 </h4><br><ul><li>  React native-用于为iOS和Android开发跨平台应用程序的框架 </li><li>  Redux-应用程序数据流控制 </li><li>  Redux-Saga-在Redux中使用副作用的库 </li></ul><br><h4> 工作场景 </h4><br><table><tbody><tr><td><p> 消防照片选择 <br><img src="https://habrastorage.org/webt/m_/n0/ex/m_n0exwfthzn0-yl3so514frun4.jpeg"><br></p><br></td><td><p> 用户的评论 <br><img src="https://habrastorage.org/webt/wg/u5/yd/wgu5ydugmpmcr0j5yaqg52721ia.jpeg"><br></p><br></td><td><p> 火标 <br><img src="https://habrastorage.org/webt/4g/hc/et/4ghceta2dtzzj3mwb8ry2ikc5ws.jpeg"><br></p><br></td></tr></tbody></table><br><h3>  <em>应用程序的后端部分</em> </h3><br><ul><li><p> 编程语言-JAVA 8 </p></li><li><p> 云平台-Microsoft Azure </p></li><li><p>  Web应用程序框架-Play框架 </p></li><li><p> 对象关系映射-Ebean框架 </p></li></ul><br><p> 该服务器有2个用Python编写的脚本：predict.py和getZone.py，安装了以下Python库以完成其工作： </p><br><ul><li> 熊猫-用于数据处理和分析 </li><li>  geopandas-用于处理地理数据 </li><li>  numpy-用于多维数组 </li><li>  matplotlib-用于可视化数据二维（2D）图形（也支持3D图形） </li><li> 匀称-用于处理和分析平面几何对象。 </li></ul><br><p> 服务器API： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fire.iconx.app/api</a> </p><br><ul><li> 加载坐标 </li></ul><br><pre> <code class="plaintext hljs">post /pictures {} return { id }</code> </pre><br><ul><li> 上传图片 </li></ul><br><pre> <code class="plaintext hljs">post /pictures/:id</code> </pre><br><p>  <strong>脚本预报</strong> </p><br><p> 输入脚本接收到一张图片，然后对该图片进行了简单的预处理（有关更多信息，请参见“模型训练”部分），并基于保存的文件也具有权重，该文件也位于服务器上，发出了预测。 如果模型产生的准确度&gt; 0.7，则说明火灾是固定的，否则-不。 </p><br><p> 该脚本以经典方式运行。 </p><pre> <code class="plaintext hljs">$ python predict.py image.jpg</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">代码清单：</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import keras import sys from keras.layers import Dense from keras.models import model_from_json from sklearn.externals import joblib from PIL import Image import numpy as np from keras import models, layers, optimizers from keras.applications import MobileNet from keras.models import Sequential from keras.layers import Dense, Dropout, Flatten from keras.layers import Conv2D, MaxPooling2D def crop_resize(img_path, img_size_square): # Get dimensions mysize = img_size_square image = Image.open(img_path) width, height = image.size # resize if (width and height) &gt;= img_size_square: if width &gt; height: wpercent = (mysize/float(image.size[1])) vsize = int((float(image.size[0])*float(wpercent))) image = image.resize((vsize, mysize), Image.ANTIALIAS) else: wpercent = (mysize/float(image.size[0])) hsize = int((float(image.size[1])*float(wpercent))) image = image.resize((mysize, hsize), Image.ANTIALIAS) # crop width, height = image.size left = (width - mysize)/2 top = (height - mysize)/2 right = (width + mysize)/2 bottom = (height + mysize)/2 image=image.crop((left, top, right, bottom)) return image conv_base = MobileNet(weights='imagenet', include_top=False, input_shape=(224, 224, 3)) def build_model(): model = models.Sequential() model.add(conv_base) model.add(layers.Flatten()) model.add(layers.Dense(256, activation='relu')) model.add(layers.Dense(64, activation='relu')) model.add(layers.Dense(1, activation='sigmoid')) model.compile(loss='binary_crossentropy', optimizer=optimizers.RMSprop(lr=2e-5), metrics=['acc']) return model image=crop_resize(sys.argv[1],224) image = np.reshape(image,[1,224,224,3]) #Loading models and text processing model = build_model() print('building a model') model.load_weights('./models/mobile_weights.h5') print('model loaded') pred_cat=model.predict(image) if pred_cat &gt; 0.7: print('fire {}'.format(pred_cat)) else: print('no fire {}'.format(pred_cat))</code> </pre><br></div></div><br><br><p>  <strong>脚本getZone.py</strong> </p><br><p> 脚本的输入是来自应用程序客户端的点的坐标。 该脚本会收紧来自NASA的所有坐标，为此文件添加新的纬度和经度，覆盖原始文件并开始寻找最近的点。 点之间的距离是使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Haversine公式计算的</a> 。 </p><br><p> 为此，将点的经度和纬度转换为弧度： </p><br><pre> <code class="plaintext hljs">pt1_lon, pt1_lat, pt2_lon, pt2_lat = map(radians, [pt1_lon, pt1_lat, pt2_lon, pt2_lat])</code> </pre><br><p> 每个点的经度和纬度有所不同： </p><br><pre> <code class="plaintext hljs">d_lon = pt2_lon - pt1_lon d_lat = pt2_lat - pt1_lat</code> </pre><br><p> 所有这些都被替换为haversine公式： </p><br><pre> <code class="plaintext hljs">a = sin(d_lat/2)**2 + cos(pt1_lat) * cos(pt2_lat) * sin(d_lon/2)**2</code> </pre><br><p> 我们取计算结果的根，计算反正弦值并将结果乘以2。 </p><br><pre> <code class="plaintext hljs">c = 2 * asin(sqrt(a))</code> </pre><br><p> 该距离将是地球半径（6371 km）与先前计算结果的乘积。 </p><br><h2> 模型训练 </h2><br><p> 要分析有火的图片，我们需要一组训练有火的照片。 照片是通过脚本从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.flickr.com/</a>网站收集的，并进行了手动标记。 </p><br><p> 下载使用FlikerAPI进行。 该脚本对图片执行了标准的预处理操作：裁剪-居中对齐的正方形（比率1：1），并调整为256×256格式。 </p><br><div class="spoiler">  <b class="spoiler_title">代码清单：</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">import flickrapi import urllib.request from PIL import Image import pathlib import os from tqdm import tqdm # Flickr api access key flickr=flickrapi.FlickrAPI('your API key', 'your secret key', cache=True) def get_links(): search_term = input("Input keywords for images: ") keyword = search_term max_pics=2000 photos = flickr.walk(text=keyword, tag_mode='all', tags=keyword, extras='url_c', per_page=500, # mb you can try different numbers.. sort='relevance') urls = [] for i, photo in enumerate(photos): url = photo.get('url_c') if url is not None: urls.append(url) if i &gt; max_pics: break num_of_pics=len(urls) print('total urls:',len(urls)) # print number of images available for a keywords return urls, keyword, num_of_pics #resizing and cropping output images will be besquare def crop_resize(img_path, img_size_square): # Get dimensions mysize = img_size_square image = Image.open(img_path) width, height = image.size # resize if (width and height) &gt;= img_size_square: if width &gt; height: wpercent = (mysize/float(image.size[1])) vsize = int((float(image.size[0])*float(wpercent))) image = image.resize((vsize, mysize), Image.ANTIALIAS) else: wpercent = (mysize/float(image.size[0])) hsize = int((float(image.size[1])*float(wpercent))) image = image.resize((mysize, hsize), Image.ANTIALIAS) # crop width, height = image.size left = (width - mysize)/2 top = (height - mysize)/2 right = (width + mysize)/2 bottom = (height + mysize)/2 image=image.crop((left, top, right, bottom)) return image def download_images(urls_,keyword_, num_of_pics_): num_of_pics=num_of_pics_ keyword=keyword_ urls=urls_ i=0 base_path='./flickr_data/' # your base folder to save pics for item in tqdm(urls): name=''.join([keyword,'_',str(i),'.jpg']) i+=1 keyword_=''.join([keyword,'_',str(num_of_pics)]) dir_path= os.path.join(base_path,keyword_) file_path=os.path.join(dir_path,name) pathlib.Path(dir_path).mkdir(parents=True, exist_ok=True) urllib.request.urlretrieve(item, file_path) resized_img=crop_resize(file_path, 256) #set output image size try: resized_img.save(file_path) except: pass urls, keyword, num_of_pics =get_links() continue = input("continue or try other keywords (y,n): ") if continue =='y': download_images(urls, keyword, num_of_pics) elif continue =='n': get_links() else: pass</code> </pre><br></div></div><br><p> 自然地，使用预训练模型的神经网络的卷积架构可用于处理图片。 选择落在了（预期的） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MobileNet上</a> ，因为： </p><br><ul><li> 轻量级-重要的是应用程序的响应时间应尽可能短。 </li><li> 快速-最小化应用程序响应时间非常重要。 </li><li> 确实<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>-MobileNet</em></a>可以进行必要的预测。 </li></ul><br><p> 经过培训，该网络产生的准确度约为0.85。 </p><br><p> 为了构建模型，训练和预测，使用了一堆<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Keras</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Tensorflow</a> 。 通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pandas</a>进行数据处理。 </p><br><p> 由于NASA数据集是地理数据，因此我们想使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GeoPandas</a>库。 该库是熊猫提供几何类型空间方法和操作功能的扩展。 几何运算是通过图形库实现的，并与文件-fiona，图形-matplotlib一起使用。 </p><br><p> 我们花了将近一天半的时间来弄清楚这个库，所以我们放弃了它，因为我们找不到可以从中使用它的真正优势的地方。 我们计算坐标的任务非常小，因此最后，所有操作都是本地实现的。 </p><br><h2> 接下来是什么？ </h2><br><p> 自然，我们得到的结果是极其不稳定且原始的应用程序，该应用程序有待最终确定。 </p><br><p> 我们已经成功： </p><br><ol><li> 实现能够拍照的移动和Web应用程序的原型（仅限移动版），然后将其上传并发送到服务器。 另外，发送成功的坐标到达服务器。 </li><li> 在服务器上，可以部署2个脚本来实现应用程序的主要逻辑。 安排了输入数据到这些脚本的流程以及接收输出数据并随后将其发送到客户端的过程。 </li><li> 实现我们应用程序的真正“原型”。 </li></ol><br><p> 我们没有设法实现它，但是我想解决以下问题并添加功能（各项根据任务的优先级而定）： </p><br><ol><li> 组织从数据集到数据库的所有坐标的记录，以便直接与数据库进行交互。 </li><li> 组织从NASA网站自动上传新文件，即 安排自动的每日坐标更新。 </li><li> 向靠近火区的用户添加通知。 </li><li> 添加注册（实现第一段所必需）。 </li><li> 重写火区计算算法。 </li><li> 解决设计任务-为应用程序的移动版和Web版带来美感。 </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430480/">https://habr.com/ru/post/zh-CN430480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430470/index.html">为什么要保持客户帐户的背景-诚实而有利可图</a></li>
<li><a href="../zh-CN430472/index.html">DIY无缝DECT网络</a></li>
<li><a href="../zh-CN430474/index.html">CephFS和GlusterFS</a></li>
<li><a href="../zh-CN430476/index.html">NCBI基因组工作台：濒危研究</a></li>
<li><a href="../zh-CN430478/index.html">加密货币市场的交易机器人。 从哪里开始？</a></li>
<li><a href="../zh-CN430482/index.html">东西方文化中的装甲主题</a></li>
<li><a href="../zh-CN430484/index.html">典型的NGFW实施方案</a></li>
<li><a href="../zh-CN430486/index.html">自由职业者的生活：从开发人员到技术撰稿人</a></li>
<li><a href="../zh-CN430488/index.html">通过SSH与远程应用程序进行异步数据交换</a></li>
<li><a href="../zh-CN430490/index.html">预期，教育和决定：EPAM如何以及为何建立Java能力中心</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>