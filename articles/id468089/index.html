<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👄 🥤 🐣 Redefinisi Berbasis Edisi: apakah mungkin dalam produksi? 📿 🔁 📍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Nama saya Antonina, saya adalah pengembang Oracle dari divisi IT Sportmaster Lab. Saya telah bekerja di sini hanya selama dua tahun, tetapi berkat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redefinisi Berbasis Edisi: apakah mungkin dalam produksi?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/468089/"> Hai  Nama saya Antonina, saya adalah pengembang Oracle dari divisi IT Sportmaster Lab.  Saya telah bekerja di sini hanya selama dua tahun, tetapi berkat tim yang ramah, tim yang erat, sistem bimbingan, dan pelatihan perusahaan, massa yang sangat kritis telah terkumpul ketika Anda ingin tidak hanya mengonsumsi pengetahuan, tetapi juga berbagi pengalaman Anda. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/1v/vr/yw/1vvrywedjwzo3_hztztisvlbycu.png" width="900"></a> <br><br>  Jadi, Redefinisi Berbasis Edisi.  Mengapa kita bahkan memiliki kebutuhan untuk mempelajari teknologi ini, apalagi, istilah "ketersediaan tinggi" dan bagaimana Redefinisi Berbasis Edisi membantu kita sebagai pengembang Oracle menghemat waktu? <br><br>  Apa yang diusulkan sebagai solusi oleh Oracle?  Apa yang terjadi di halaman belakang ketika menerapkan teknologi ini, masalah apa yang kami temui ... Secara umum, ada banyak pertanyaan.  Saya akan mencoba menjawabnya dalam dua posting pada topik, dan yang pertama sudah di bawah cut. <br><a name="habracut"></a><br>  Setiap tim pengembang, membuat aplikasi mereka sendiri, berusaha membuat algoritma yang paling terjangkau, paling toleran, dan paling andal.  Mengapa kita semua berjuang untuk ini?  Mungkin bukan karena kami sangat baik dan kami ingin merilis produk yang keren.  Lebih tepatnya, bukan hanya karena kita begitu baik.  Ini juga penting untuk bisnis.  Terlepas dari kenyataan bahwa kita dapat menulis algoritma yang keren, menutupinya dengan unit test, melihat bahwa itu toleran terhadap kesalahan, kita masih (pengembang Oracle) memiliki masalah - kita dihadapkan dengan kebutuhan untuk meningkatkan aplikasi kita.  Misalnya, kolega kami dalam sistem loyalitas dipaksa melakukan ini di malam hari. <br><br>  Jika ini terjadi dengan cepat, pengguna akan melihat gambar: "Maafkan saya!", "Jangan sedih!", "Tunggu, kami memiliki pembaruan dan pekerjaan teknis di sini."  Mengapa ini sangat penting untuk bisnis?  Tapi itu sangat sederhana - untuk waktu yang lama, bisnis telah meletakkan kerugiannya tidak hanya kerugian beberapa barang nyata, nilai materi, tetapi juga kerugian dari infrastruktur yang rusak.  Misalnya, menurut majalah Forbes, kembali 13, satu menit dari pemadaman layanan Amazon kemudian biaya 66 ribu dolar.  Artinya, dalam setengah jam orang-orang kehilangan hampir $ 2 juta. <br><br>  Jelas bahwa untuk usaha menengah dan kecil, dan bukan untuk raksasa seperti Amazon, karakteristik kuantitatif ini akan jauh lebih sedikit, tetapi meskipun demikian, secara relatif, ini tetap merupakan karakteristik evaluasi yang signifikan. <br><br><img src="https://habrastorage.org/webt/6i/-9/e5/6i-9e5e2g8_zayjsmfkagvvtlkg.png" width="900"><br><br>  Jadi, kita perlu memastikan ketersediaan aplikasi kita yang tinggi.  Apa saja tempat yang berpotensi berbahaya yang dimiliki pengembang Oracle untuk aksesibilitas ini? <br><br>  Hal pertama yang pertama, perangkat keras kita mungkin gagal.  Kami, sebagai pengembang, tidak bertanggung jawab untuk ini.  Administrator jaringan harus memastikan bahwa server dan objek struktural operasional.  Yang kami tuju adalah peningkatan perangkat lunak.  Sekali lagi, pembaruan perangkat lunak terjadwal dapat dibagi menjadi dua kelas.  Atau kami mengubah beberapa jenis infrastruktur, misalnya memperbarui sistem operasi tempat server berputar.  Entah kami memutuskan untuk pindah ke rilis baru Oracle (alangkah baiknya jika kami berhasil pindah ke sana :)) ... Atau, kelas kedua, ini adalah yang memiliki hubungan maksimum dengan kami - ini memperbarui objek aplikasi yang kami kembangkan bersama Anda. <br><br>  Sekali lagi, pembaruan ini dapat dibagi menjadi dua kelas lagi. <br><br>  Atau kita mengubah beberapa karakteristik fisik dari objek ini (saya pikir setiap pengembang Oracle terkadang menemukan fakta bahwa indeksnya turun, dia harus membangun kembali indeks dengan cepat).  Atau, katakanlah kita memperkenalkan bagian baru di tabel kita, yaitu, tidak akan berhenti terjadi.  Dan tempat yang sangat bermasalah adalah perubahan dalam logika aplikasi. <br><br>  Jadi apa hubungannya Redefinisi Berbasis Edisi dengan itu?  Dan teknologi ini - ini hanya tentang cara memperbarui aplikasi online, dengan cepat, tanpa memengaruhi pekerjaan pengguna. <br><br><img src="https://habrastorage.org/webt/vn/qi/lt/vnqilthbzkpbqaxt83yo_eh0kh8.png" width="900"><br><br>  Apa persyaratan untuk pembaruan online ini?  Kita harus melakukan ini tanpa disadari oleh pengguna, yaitu, semuanya harus tetap dalam kondisi kerja, semua aplikasi.  Asalkan situasi seperti itu dapat terjadi ketika pengguna duduk, mulai bekerja dan ingat dengan tajam bahwa ia memiliki pertemuan yang mendesak, atau bahwa ia perlu membawa mobil ke layanan.  Dia bangkit, lari karena tempat kerjanya.  Dan pada saat itu, kami entah bagaimana memperbarui aplikasi kami, logika pekerjaan berubah, pengguna baru sudah terhubung dengan kami, data sudah mulai diproses dengan cara baru.  Jadi, pada akhirnya kita perlu memastikan pertukaran data antara versi asli aplikasi dan versi baru aplikasi tersebut.  Inilah mereka, dua persyaratan yang diajukan untuk pembaruan online. <br><br><img src="https://habrastorage.org/webt/gt/k8/v2/gtk8v2v47uemgh9pnpddfzribze.png" width="900"><br><br>  Apa yang diusulkan sebagai solusi?  Dimulai dengan versi 11.2 Rilis Oracle, teknologi Redefenition Berbasis Edisi diperkenalkan dan konsep-konsep seperti edisi, objek edisi, tampilan edisi, pemicu lintas-edisi diperkenalkan.  Kami mengizinkan terjemahan semacam itu sebagai "versi".  Secara umum, teknologi EBR dengan beberapa peregangan bisa disebut versi objek DBMS di dalam DBMS itu sendiri. <br><br>  Jadi, apa Edition sebagai entitas? <br><br>  Ini adalah semacam wadah di mana Anda dapat mengubah dan mengatur kode.  Di dalam ruang lingkup Anda sendiri, di dalam versi Anda sendiri.  Dalam hal ini, data akan diubah dan ditulis hanya untuk struktur yang terlihat dalam Edisi saat ini.  Representasi versi akan bertanggung jawab untuk ini, dan kami akan mempertimbangkan pekerjaan mereka lebih lanjut. <br><br><img src="https://habrastorage.org/webt/5q/t4/8u/5qt48ujp3qjrq5o-aqhmdo8pr2i.png" width="900"><br><br>  Seperti inilah teknologi di luar.  Bagaimana cara kerjanya?  Sebagai permulaan - pada tingkat kode.  Kami akan memiliki aplikasi asli kami, versi 1, di mana ada beberapa algoritma yang memproses data kami.  Ketika kami memahami bahwa kami perlu memutakhirkan, saat membuat edisi baru, terjadi hal berikut: semua objek yang memproses kode diwariskan dalam edisi baru ... Pada saat yang sama, di kotak pasir yang baru dibuat ini, kami dapat bersenang-senang seperti yang kami inginkan, tanpa terlihat oleh pengguna: kami dapat mengubah pekerjaan mana yang fungsi, prosedur;  ganti paket;  kita bahkan dapat menolak untuk menggunakan objek apa pun. <br><br>  Apa yang akan terjadi  Versi asli tetap tidak berubah, tetap tersedia untuk pengguna dan semua fungsionalitas tersedia.  Dalam versi yang kami buat, dalam edisi baru, objek-objek yang belum diubah tetap tidak berubah, yaitu, diwarisi dari versi asli aplikasi.  Dengan blok yang telah kami sentuh, objek diperbarui dalam versi baru.  Dan tentu saja, ketika Anda menghapus suatu objek, itu tidak tersedia untuk kita dalam versi baru dari aplikasi kita, tetapi tetap berfungsi dalam versi asli. Begitulah cara kerjanya pada tingkat kode. <br><br><img src="https://habrastorage.org/webt/jf/4e/hn/jf4ehn23kk2ysfbvmfpxss4ipry.png"><br><br>  Apa yang terjadi pada struktur data dan apa hubungan tampilan versi dengan itu? <br><br><img src="https://habrastorage.org/webt/te/6p/ma/te6pma74mzekuype6ngu2hkpjj4.png" width="900"><br><br>  Karena struktur data yang kami maksudkan adalah sebuah tabel, dan tampilan versi, ini sebenarnya adalah sebuah shell (saya menyebut diri saya "pencarian" etologis dari tabel kami), yang merupakan proyeksi ke kolom asli.  Ketika kami memahami bahwa kami perlu mengubah operasi aplikasi kami, dan, katakanlah, entah bagaimana menambahkan kolom ke tabel, atau bahkan melarang penggunaannya, kami membuat tampilan versi baru dalam versi baru kami. <br><br><img src="https://habrastorage.org/webt/o-/8v/va/o-8vvax1gwowb-8qe3htrmfktki.png" width="900"><br><br>  Dengan demikian, di dalamnya kita hanya akan menggunakan kumpulan kolom yang kita butuhkan, yang akan kita proses.  Jadi, dalam versi asli aplikasi, data ditulis ke set yang didefinisikan dalam lingkup ini.  Aplikasi baru akan menulis ke set kolom yang didefinisikan dalam ruang lingkupnya. <br><br><img src="https://habrastorage.org/webt/nz/r1/d3/nzr1d3eatoy6qf907f-hwnvyoyy.png" width="900"><br><br>  Strukturnya jelas, tetapi apa yang terjadi pada data?  Dan bagaimana semua ini saling berhubungan, Kami memiliki data yang disimpan dalam struktur asli.  Ketika kita memahami bahwa kita memiliki algoritma tertentu yang memungkinkan kita untuk mengkonversi data dari struktur asli dan menguraikan data ini menjadi struktur baru, algoritma ini dapat dimasukkan ke dalam apa yang disebut pemicu versi silang.  Mereka hanya bertujuan melihat struktur dari berbagai versi aplikasi.  Artinya, tergantung pada ketersediaan algoritma seperti itu, kita dapat menggantungnya di atas meja.  Dalam hal ini, data akan ditransformasikan dari struktur asli ke yang baru, dan pemicu maju progresif akan bertanggung jawab untuk ini.  Asalkan kita perlu memastikan transfer data ke versi lama, sekali lagi, berdasarkan beberapa jenis algoritma, pemicu terbalik akan bertanggung jawab untuk ini. <br><br>  Apa yang terjadi ketika kami memutuskan bahwa struktur data kami telah berubah dan kami siap untuk bekerja dalam mode paralel baik untuk versi aplikasi yang lama maupun untuk versi aplikasi yang baru?  Kami cukup menginisialisasi pengisian struktur baru dengan beberapa pembaruan menganggur.  Setelah itu, kedua versi aplikasi kami tersedia untuk digunakan oleh pengguna.  Fungsionalitas tetap untuk pengguna lama dari versi lama aplikasi, untuk pengguna baru, fungsionalitas akan berasal dari versi baru aplikasi. <br><br><img src="https://habrastorage.org/webt/rg/-_/3l/rg-_3l0qpzoklsp1ilqj8ridkoo.png" width="900"><br><br>  Ketika kami menyadari bahwa pengguna dari aplikasi lama semuanya terputus, versi ini bisa disembunyikan dari penggunaan.  Mungkin bahkan struktur data telah diubah.  Kami ingat bahwa dengan kami tampilan versi dalam versi yang baru dibuat akan hanya akan melihat kumpulan kolom 1, 3,4,5.  Nah dan sesuai, jika kita tidak membutuhkan struktur ini, itu bisa dihapus.  Berikut ini ringkasan singkat cara kerjanya. <br><br><img src="https://habrastorage.org/webt/zf/n9/4a/zfn94ady30lnm4c6p9-vtaub_ny.png" width="900"><br><br>  Apa batasan yang diberlakukan?  Yaitu, Oracle yang berhasil, Oracle yang luar biasa, Oracle yang luar biasa: mereka datang dengan hal yang keren.  Keterbatasan pertama saat ini adalah objek dari tipe versi, ini adalah objek PL / SQL, yaitu, prosedur, paket, fungsi, pemicu, dan sebagainya.  Sinonim diversi dan tampilan diversi. <br><br>  Apa yang tidak diversi dan tidak akan pernah diversi adalah tabel dan indeks, pandangan terwujud.  Yaitu, dalam versi pertama, Anda dan saya hanya mengubah metadata dan dapat menyimpan salinannya sebanyak yang Anda inginkan ... pada kenyataannya, sejumlah salinan metadata ini, tetapi lebih lanjut tentang itu nanti.  Yang kedua menyangkut data pengguna, dan replikasi mereka akan membutuhkan banyak ruang disk, yang tidak logis dan sangat mahal. <br><br><img src="https://habrastorage.org/webt/tq/lm/b7/tqlmb7lcbjybq_lbuq2ipn0qnpc.png" width="900"><br><br>  Batasan berikutnya adalah bahwa objek skema akan sepenuhnya versi jika dan hanya jika mereka milik pengguna yang diotorisasi versi.  Bahkan, hak istimewa ini bagi pengguna hanyalah semacam tanda dalam basis data.  Anda dapat memberikan izin ini dengan perintah biasa.  Tetapi saya menarik perhatian Anda pada fakta bahwa tindakan ini tidak dapat diubah.  Karena itu, jangan langsung menyingsingkan lengan baju kita, ketik semua ini di server pertempuran, dan pertama kita akan menguji. <br><br>  Batasan berikutnya adalah bahwa objek yang tidak berversi tidak dapat bergantung pada yang berversi.  Ya, itu cukup logis.  Minimal, kami tidak akan mengerti edisi mana, versi objek yang akan dilihat.  Pada titik ini, saya ingin menarik perhatian, karena kami harus bersaing dengan momen ini. <br><br>  Selanjutnya  Tampilan berversi milik pemilik skema, pemilik tabel, dan hanya di setiap versi.  Pada intinya, tampilan berversi adalah pembungkus tabel, jadi jelas bahwa itu harus unik di setiap versi aplikasi. <br><br>  Yang juga penting, jumlah versi dalam hierarki mungkin 2000. Kemungkinan besar, ini karena Anda tidak memuat kamus dengan berat.  Saya katakan awalnya bahwa objek, ketika membuat edisi baru, diwariskan.  Sekarang hierarki ini dibangun secara linier secara eksklusif - satu orangtua, satu keturunan.  Mungkin akan ada semacam struktur pohon, saya melihat beberapa prasyarat untuk ini dalam kenyataan bahwa Anda dapat mengatur perintah pembuatan versi sebagai pewaris dari edisi tertentu.  Ini saat ini merupakan hierarki yang sepenuhnya linier, dan jumlah tautan dalam rantai ini adalah 2000. <br><br>  Jelas bahwa dengan beberapa peningkatan aplikasi kami, jumlah ini dapat habis atau melampaui batas, tetapi mulai dengan rilis Oracle yang ke-12, edisi ekstrem yang dibuat dalam rantai ini dapat dipotong dengan ketentuan bahwa mereka tidak lagi digunakan. <br><br><img src="https://habrastorage.org/webt/b5/xf/uq/b5xfuqo5n7ifpdzfkaw8hvqkgxw.png" width="900"><br><br>  Saya harap Anda sekarang mengerti kira-kira cara kerjanya.  Jika Anda memutuskan - "Ya, kami ingin menyentuhnya" - apa yang perlu dilakukan untuk beralih menggunakan teknologi ini? <br><br>  Hal pertama yang pertama, Anda perlu menentukan strategi penggunaan.  Tentang apa ini?  Memahami seberapa sering struktur tabel kita berubah, apakah kita perlu menggunakan tampilan berversi, terutama jika kita membutuhkan pemicu lintas-versi untuk memastikan perubahan data.  Atau kita hanya akan versi kode PL / SQL kami.  Dalam kasus kami, ketika kami menguji, kami melihat bahwa kami masih memiliki perubahan tabel, jadi kami mungkin juga akan menggunakan tampilan versi. <br><br>  Selanjutnya, secara alami, skema yang dipilih diberikan hak berversi. <br>  Setelah itu, kami mengganti nama tabel.  Mengapa ini dilakukan?  Hanya untuk melindungi objek kode PL / SQL kami dari modifikasi tabel. <br><br>  Kami memutuskan untuk melempar simbol tajam di ujung meja kami, mengingat batas 30 karakter.  Setelah itu, tampilan versi dibuat dengan nama tabel asli.  Dan mereka sudah akan digunakan di dalam kode.  Adalah penting bahwa dalam versi pertama yang kita pindahkan, tampilan berversi adalah kumpulan kolom lengkap dalam tabel sumber, karena objek kode PL / SQL dapat mengakses semua kolom ini persis sama. <br><br>  Setelah itu, kami melebihi pemicu DML dari tabel ke tampilan berversi (ya, tampilan berversi memungkinkan kami untuk menggantung pemicu di atasnya).  Mungkin kita mencabut hibah dari tabel dan memberikannya kepada pandangan yang baru dibuat ... Secara teori, semua poin ini sudah cukup, kita hanya perlu mengkompilasi ulang kode PL / SQL dan pandangan dependen. <br><br>  I-dan-dan-dan-dan ... Secara alami, tes, tes, dan tes sebanyak mungkin.  Kenapa harus tes?  Itu tidak bisa sesederhana itu.  Apa yang kami temukan? <br><br>  Inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pos kedua saya</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468089/">https://habr.com/ru/post/id468089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468079/index.html">Dimensi khusus di Google Analytics yang menyelamatkan kami lebih dari sekali</a></li>
<li><a href="../id468081/index.html">“Data anonim” atau apa yang direncanakan di 152-FZ</a></li>
<li><a href="../id468083/index.html">Android Camera2 API dari ketel</a></li>
<li><a href="../id468085/index.html">Buku "Safe DevOps. Pengoperasian Sistem yang Efisien</a></li>
<li><a href="../id468087/index.html">Metode pembagian dua bagian dalam pengujian</a></li>
<li><a href="../id468091/index.html">RUU tentang penciptaan database tunggal dengan data warga diadopsi di Duma Negara dalam bacaan pertama</a></li>
<li><a href="../id468093/index.html">Nitrat dalam produk: toko Swiss vs toko Rusia vs pondok musim panas</a></li>
<li><a href="../id468097/index.html">Microsoft Edge - Generic XSS</a></li>
<li><a href="../id468099/index.html">C / C ++ dari Python (CFFI, pybind11)</a></li>
<li><a href="../id468107/index.html">Cara membuat model lebih tepat daripada transfermarkt dan tidak memprediksi atau apa yang paling mempengaruhi biaya transfer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>