<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â™¿ï¸ ğŸ…¿ï¸ ğŸš½ TON: rekomendasi dan praktik terbaik ğŸ›• ğŸ‘´ğŸ¿ â›½ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah terjemahan dari dokumen yang diterbitkan pada halaman TON blockchain: smc-guidelines.txt . Mungkin ini akan membantu seseorang untu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TON: rekomendasi dan praktik terbaik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470772/"><p>  Artikel ini adalah terjemahan dari dokumen yang diterbitkan pada halaman TON blockchain: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">smc-guidelines.txt</a> .  Mungkin ini akan membantu seseorang untuk mengambil langkah menuju pengembangan untuk blockchain ini.  Juga, pada akhirnya saya membuat ringkasan singkat. </p><a name="habracut"></a><br><h2 id="vnutrennie-soobscheniya">  Pesan internal </h2><br><p>  Kontrak pintar saling berinteraksi dengan mengirimkan apa yang disebut pesan internal.  Ketika pesan internal mencapai tujuan yang ditentukan, transaksi reguler dibuat atas nama akun tujuan, dan pesan internal diproses sesuai dengan kode yang ditentukan dan data konstan dari akun ini (kontrak pintar).  Secara khusus, transaksi pemrosesan dapat membuat satu atau lebih pesan internal, beberapa di antaranya mungkin ditujukan ke alamat sumber dari pesan internal yang sedang diproses.  Ini dapat digunakan untuk membuat "aplikasi klien-server" sederhana ketika permintaan tertanam (dienkapsulasi) dalam pesan internal dan dikirim ke kontrak pintar lain yang memproses permintaan dan mengirimkan respons kembali, lagi sebagai pesan internal. </p><br><p> Pendekatan ini mengarah pada kebutuhan untuk membedakan antara pesan internal dengan "permintaan" dan "respons" (sebagai "kueri" atau sebagai "respons"), atau tidak memerlukan pemrosesan tambahan (seperti transfer uang sederhana).  Selain itu, ketika jawaban datang, harus ada cara untuk memahami permintaan mana yang terkait. </p><br><p>  Untuk mencapai tujuan ini, disarankan untuk menggunakan templat pesan internal berikut (ingat bahwa blockchain TON tidak memberlakukan batasan pada badan pesan, yaitu, itu hanya rekomendasi): </p><br><p>  0) Badan pesan dapat tertanam dalam pesan itu sendiri, atau dapat disimpan dalam sel terpisah (sel *), yang dirujuk dalam pesan, seperti yang ditunjukkan dalam fragmen TL-B diagram (dalam bahasa Inggris lebih mudah dimengerti: atau disimpan dalam terpisah sel yang dirujuk dari pesan, seperti yang ditunjukkan oleh fragmen skema TL-B): </p><br><pre><code class="plaintext hljs">message$_ {X:Type} ... body:(Either X ^X) = Message X;</code> </pre> <br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://core.telegram.org/mtproto</a> - di sini Anda dapat membaca tentang skema TL) </p><br><p>  Kontrak pintar penerima harus menerima setidaknya pesan internal dengan badan pesan tertanam (bahkan jika mereka ditempatkan di sel yang berisi pesan - setiap kali mereka masuk ke dalam sel yang mengandung pesan - tidak jelas apa artinya ini, oleh karena itu, lampirkan teks asli).  Jika kontrak menerima badan pesan dalam sel yang terpisah (menggunakan konstruktor "kanan" <code>(Either X ^X)</code> ), pemrosesan pesan yang masuk tidak harus bergantung pada metode tertentu dalam menyematkan badan pesan.  Di sisi lain, sangat sah untuk tidak mendukung badan pesan di sel yang terpisah sama sekali untuk menyederhanakan permintaan dan tanggapan. </p><br><p>  1) Badan pesan biasanya dimulai dengan bidang-bidang berikut: </p><br><ul><li>  <em>op</em> - integer unsigned 32-bit (big-endian) yang mengidentifikasi operasi yang akan dijalankan, atau metode kontrak pintar untuk memanggil. </li><li>  <em>query_id</em> adalah integer unsigned 64-bit (big-endian) yang digunakan dalam semua pesan pertanyaan dan jawaban internal untuk mengidentifikasi hubungan respons terhadap permintaan ( <em>query_id dari</em> respons harus sama dengan <em>query_id dari</em> permintaan yang sesuai).  Jika <em>op</em> bukan metode respons permintaan (ia memanggil metode yang tidak diharapkan responsnya), maka <em>kueri_id</em> dapat dihilangkan. </li><li>  sisa isi pesan dikhususkan untuk setiap nilai parameter <em>op yang</em> didukung </li></ul><br><p>  2) Jika <em>op</em> adalah nol, maka pesannya adalah pesan transfer sederhana dengan komentar.  Komentar terkandung dalam sisa pesan (tanpa <em>query_id</em> dan seterusnya, yaitu, dimulai dari byte ke-5 (penjelasan: jika <em>query_id</em> tidak, maka bidang <em>op</em> mengambil 4 byte pertama)).  Jika tidak dimulai dengan byte 0xff, komentar adalah teks satu;);  itu dapat ditampilkan kepada pengguna akhir dompet "apa adanya" (setelah memfilter karakter yang tidak valid dan mengontrol dan memeriksa bahwa ini adalah string UTF-8 yang valid).  Misalnya, pengguna dapat menentukan tujuan transfer sederhana dari dompet mereka ke dompet pengguna lain di bidang ini.  Di sisi lain, jika komentar dimulai dengan byte 0xff, sisa pesan adalah "komentar biner" yang tidak boleh ditampilkan kepada pengguna akhir sebagai teks (hanya sebagai hex dump jika perlu).  Usulan penggunaan komentar biner, misalnya, berisi pengidentifikasi pembayaran untuk pembayaran di toko, dan secara otomatis dihasilkan dan diproses oleh perangkat lunak toko. </p><br><p>  Sebagian besar kontrak pintar tidak harus melakukan tindakan nontrivial atau menolak pesan masuk ketika mereka menerima "pesan transfer sederhana".  Jadi, ketika <em>op</em> ternyata nol, fungsi kontrak pintar untuk memproses pesan internal yang masuk (biasanya disebut <code>recv_internal()</code> ) harus segera keluar dengan kode 0, menunjukkan keberhasilan (misalnya, melempar pengecualian 0 jika handler kustom tidak dipasang dalam kontrak pintar pengecualian).  Ini akan mengarah pada fakta bahwa jumlah yang ditransfer oleh pesan akan dikreditkan ke akun penerima tanpa efek lebih lanjut. </p><br><p>  3) "Transfer pesan sederhana tanpa komentar" memiliki badan kosong (bahkan tanpa bidang <em>op</em> ).  Pertimbangan di atas berlaku untuk pesan tersebut.  Harap dicatat bahwa pesan tersebut harus memiliki tubuh mereka sendiri yang tertanam di dalam sel pesan. </p><br><p>  4) Kami berharap bahwa bidang <em>op</em> pesan permintaan akan memiliki bit pertama ("bit orde tinggi", diterjemahkan sebagai yang pertama, ini mungkin salah, tetapi seperti yang dijelaskan kemudian menjadi jelas) kosong, artinya nilai bidang harus berada dalam kisaran <code>1 .. 2^31-1</code> , dan untuk pesan respon bit pertama (tingkat tinggi) harus sama dengan 1, yaitu, nilai bidang dalam kisaran <code>2^31 .. 2^32-1</code> .  Jika pesan tersebut bukan permintaan atau respons (badan tidak mengandung parameter <em>query_id</em> ), maka itu harus berisi parameter <em>op</em> dalam rentang seperti dalam pesan permintaan: <code>1 .. 2^31 - 1</code> . </p><br><p>  5) Ada beberapa pesan respons "standar" yang <em>opnya</em> 0xffffffff dan 0xffffffffe.  Secara umum, nilai <em>op</em> dari 0xfffffff0 hingga 0xffffffff dicadangkan untuk jawaban standar tersebut. </p><br><ul><li>  <em>op = 0xffffffff</em> berarti "operasi tidak didukung."  Itu diikuti oleh 64-bit <em>query_id</em> diekstraksi dari permintaan asli, dan <em>op</em> 32-bit <em>dari</em> permintaan asli.  Semua kecuali kontrak pintar yang paling sederhana akan mengembalikan kesalahan ini ketika mereka menerima permintaan dengan <em>op yang</em> tidak dikenal di kisaran 1 ... 2 ^ 31-1. </li><li>  <em>op = 0xfffffffe</em> berarti "operasi tidak diizinkan."  Itu diikuti oleh <em>query_id</em> 64-bit <em>dari</em> permintaan asli, dan kemudian <em>op</em> 32-bit diekstraksi dari permintaan asli. </li></ul><br><p>  Perhatikan bahwa "jawaban" yang tidak diketahui (dengan <em>op</em> dalam kisaran 2 ^ 31 ... 2 ^ 32-1) harus diabaikan (khususnya, Anda tidak boleh menghasilkan respons dengan <em>op</em> sama dengan 0xffffffff), serta pengembalian yang tidak terduga ( bouncing) -messages (dengan set flag "bouncing"). </p><br><h2 id="oplata-za-obrabotku-zaprosov-i-otpravlenie-otvetov">  Pembayaran untuk memproses permintaan dan mengirim balasan </h2><br><p>  Secara umum, jika kontrak pintar ingin mengirim permintaan ke kontrak pintar lain, ia harus membayar untuk mengirim pesan internal ke kontrak pintar target (biaya penerusan pesan), untuk memproses pesan ini di tempat tujuan (biaya gas: biaya gas) dan untuk mengirim respons jika diperlukan (biaya penerusan pesan). </p><br><p>  Dalam kebanyakan kasus, pengirim akan melampirkan sejumlah kecil gram ke pesan internal (misalnya, 1 gram) (cukup untuk membayar memproses pesan ini) dan menetapkan bendera "bouncing" di atasnya (artinya, ia akan mengirim pesan internal yang terpental);  penerima akan mengembalikan bagian yang tidak terpakai dari nilai yang diterima dengan jawabannya (mengurangi biaya untuk mengirim pesan darinya).  Ini biasanya dicapai dengan memanggil SENDRAWMSG dengan mode = 64 (lih. Lampiran A untuk dokumentasi TON VM). </p><br><p>  Jika penerima tidak dapat memproses pesan yang diterima dan eksekusi berakhir dengan kode keluar yang tidak nol (misalnya, karena deserialisasi sel yang tidak tertangani), pesan akan secara otomatis "dipantulkan" kembali ke pengirim, dan bendera "pantulan" akan dicentang dan disetel. bendera "memantul".  Isi pesan yang dipantulkan akan sama dengan pesan aslinya;  Oleh karena itu, penting untuk memeriksa bendera "bouncing" dari pesan internal yang masuk sebelum menguraikan bidang <em>op</em> dalam kontrak pintar dan memproses permintaan yang sesuai (jika tidak ada risiko bahwa permintaan yang terkandung dalam pesan bouncing akan diproses oleh pengirim aslinya sebagai permintaan terpisah yang baru).  Jika bendera "bouncing" disetel, kode khusus dapat memahami permintaan mana yang gagal (misalnya, dengan <em>membatalkan operasi</em> <em>op</em> dan <em>query_id</em> dari pesan <em>bouncing</em> ) dan mengambil tindakan yang sesuai.  Kontrak pintar yang lebih sederhana dapat dengan mudah mengabaikan semua pesan yang dikembalikan (diakhiri dengan kode keluar nol jika bendera "terpental" disetel). </p><br><p>  Di sisi lain, penerima berhasil mem-parsing permintaan masuk dan menemukan bahwa metode operasi yang diminta tidak didukung atau bahwa kondisi kesalahan lain telah terpenuhi.  Maka respons dengan <em>op</em> sama dengan 0xffffffff atau nilai lain yang sesuai harus dikirim kembali menggunakan SENDRAWMSG dengan mode = 64, seperti yang disebutkan di atas. </p><br><p>  Dalam beberapa situasi, pengirim ingin mentransfer sejumlah uang pada saat yang sama?  ke pengirim?  (di sini, tampaknya, kesalahan, dan dimaksudkan untuk "penerima") dan menerima konfirmasi atau pesan kesalahan.  Misalnya, kontrak pintar pemilihan validator menerima permintaan untuk berpartisipasi dalam pemilihan bersama dengan tawaran sebagai nilai tambah.  Dalam kasus seperti itu, masuk akal untuk melampirkan, katakanlah, satu gram tambahan ke nilai estimasi [biaya] (Di sini kata value digunakan di mana-mana, dalam arti pembayaran untuk beberapa tindakan, jadi saya menggunakan kata "biaya").  Jika kesalahan terjadi (misalnya, tawaran tidak dapat diterima karena alasan apa pun), jumlah penuh yang diterima (dikurangi biaya pemrosesan) harus dikembalikan ke pengirim bersama dengan pesan kesalahan (misalnya, menggunakan SENDRAWMSG dengan mode = 64, seperti yang dijelaskan di atas).  Jika berhasil, pesan konfirmasi dibuat dan tepat satu gram dikirim kembali (biaya transfer pesan dikurangi dari nilai ini; ini adalah mode = 1 dari SENDRAWMSG). </p><br><h2 id="ispolzovanie-nevozvratnyh-non-bounceable-soobscheniy">  Menggunakan pesan yang tidak dapat di-bouncing </h2><br><p>  Hampir semua pesan internal yang dikirim antara kontrak pintar harus dikembalikan (Anda dapat menerjemahkannya sebagai "memantul", tetapi agar tidak bingung, lebih mudah menggunakan terminologi ini), yaitu, mereka harus memiliki "pantulan" sedikit tidak kosong.  Kemudian, jika target kontrak pintar tidak ada, atau jika ia menciptakan pengecualian yang tidak tertangani saat memproses pesan ini, pesan tersebut akan â€œdikembalikanâ€ kembali, dengan menanggung sisa biaya awal (nilai) (dikurangi semua biaya untuk pengiriman pesan dan gas).  Pesan yang dikembalikan akan memiliki badan yang sama, tetapi dengan bendera "bouncing" dihapus dan set "bouncing" bendera.  Oleh karena itu, semua kontrak pintar harus memeriksa bendera "terpental" dari semua pesan yang masuk dan menerimanya dengan diam-diam (segera diakhiri dengan kode keluar nol) atau melakukan beberapa pemrosesan khusus untuk menentukan permintaan keluar mana yang gagal.  Permintaan yang terkandung dalam isi pesan yang dikembalikan tidak boleh dieksekusi. </p><br><p>  Dalam beberapa kasus, pesan internal yang tidak dapat dipantulkan harus digunakan.  Misalnya, akun baru tidak dapat dibuat tanpa setidaknya satu pesan internal yang tidak dapat dibatalkan dikirim ke sana.  Jika pesan ini tidak mengandung StateInit dengan kode dan data kontrak pintar yang baru, tidak masuk akal untuk memiliki badan yang tidak kosong dalam pesan internal yang tidak kembali. </p><br><p>  Merupakan ide yang baik untuk mencegah pengguna akhir (mis., Dompet) mengirim pesan yang tidak dapat dibatalkan yang membawa jumlah besar (mis., Lebih dari lima gram), atau setidaknya memperingatkan mereka jika mereka mencoba melakukan ini.  Lebih baik mengirim sejumlah kecil dulu, lalu buat kontrak pintar baru, lalu kirim jumlah lebih besar. </p><br><h2 id="vneshnie-soobscheniya">  Pesan Eksternal </h2><br><p>  Pesan eksternal dikirim secara eksternal ke kontrak pintar yang berada di blockchain TON untuk memaksa mereka melakukan tindakan tertentu.  Misalnya, kontrak pintar dompet mengharapkan untuk menerima pesan eksternal yang berisi pesanan (misalnya, pesan internal yang akan dikirim dari kontrak pintar dompet) yang ditandatangani oleh pemilik dompet;  ketika pesan eksternal tersebut diterima oleh kontrak pintar dompet, ia pertama-tama memverifikasi tanda tangan, kemudian menerima pesan (dengan meluncurkan TVM ACCEPT primitive), dan kemudian melakukan semua tindakan yang diperlukan. </p><br><p>  Harap dicatat bahwa semua pesan eksternal harus dilindungi dari serangan replay.  Validator biasanya menghapus pesan eksternal dari kumpulan pesan eksternal yang diusulkan (diterima dari jaringan);  Namun, dalam beberapa situasi, validator lain dapat memproses pesan eksternal yang sama dua kali (sehingga menciptakan transaksi kedua untuk pesan eksternal yang sama, yang mengarah pada duplikasi tindakan asli).  Lebih buruk lagi, penyerang dapat mengekstrak pesan eksternal dari blok yang berisi transaksi pemrosesan dan mengirimnya kembali nanti.  Ini dapat menyebabkan, misalnya, kontrak dompet pintar untuk mengulangi pembayaran. </p><br><p>  Cara termudah untuk melindungi kontrak pintar dari mengendus serangan yang terkait dengan pesan eksternal adalah dengan menyimpan <em>penghitung cur-seqno</em> 32-bit dalam data konstan kontrak pintar dan menunggu nilai <em>req-seqno</em> di (bagian yang ditandatangani) dari setiap pesan eksternal yang masuk.  Kemudian pesan eksternal diterima (DITERIMA - petunjuk dari DITERIMA primitif) hanya jika tanda tangan valid dan <em>req-seqno</em> sama dengan <em>cur-seqno</em> .  Setelah pemrosesan berhasil, nilai <em>cur-seqno</em> dalam data persisten meningkat satu, sehingga pesan eksternal yang sama tidak akan pernah diterima lagi. </p><br><p>  Anda juga bisa memasukkan bidang <em>kedaluwarsa di</em> dalam pesan eksternal dan menerima pesan hanya jika waktu Unix saat ini kurang dari nilai bidang ini.  Pendekatan ini dapat digunakan dalam kombinasi dengan <em>seqno</em> ;  sebagai alternatif, kontrak pintar penerima dapat menyimpan set (hashes) dari semua pesan eksternal yang terakhir (tidak kedaluwarsa) yang diterima dalam data permanennya dan menolak pesan eksternal baru jika itu merupakan duplikat dari salah satu pesan yang disimpan.  Anda juga harus menerapkan pengumpulan dan penghapusan pesan kadaluwarsa dalam set ini untuk menghindari pertumbuhan data persisten yang tidak terbatas. </p><br><p>  Biasanya, pesan eksternal dimulai dengan tanda tangan 256-bit (jika perlu), 32-bit <em>req-seqno</em> (jika perlu), 32-bit <em>berakhir pada</em> (jika perlu), dan mungkin <em>op</em> 32-bit dan parameter lain yang diperlukan di tergantung pada <em>op</em> .  Templat pesan eksternal tidak harus distandarisasi sebagai templat pesan internal, karena pesan eksternal tidak digunakan untuk interaksi antara berbagai kontrak pintar (ditulis oleh pengembang yang berbeda dan dikelola oleh pemilik yang berbeda). </p><br><h2 id="get-metody">  Dapatkan metode </h2><br><p>  Beberapa kontrak cerdas diharapkan untuk menerapkan metode-metode tertentu yang terdefinisi dengan baik.  Sebagai contoh, setiap kontrak pintar resolver dns untuk TON DNS diharapkan untuk mengimplementasikan metode get dnsresolve.  Kontrak pintar khusus dapat menentukan metode get spesifik mereka.  Satu-satunya rekomendasi umum kami saat ini adalah untuk mengimplementasikan metode get "seqno" (tanpa parameter), yang mengembalikan <em>seqno</em> saat ini <em>dari</em> kontrak pintar, yang menggunakan nomor urut untuk mencegah serangan pemutaran yang terkait dengan metode eksternal yang masuk setiap kali metode tersebut memiliki artinya </p><br><p>  Kamus: </p><br><ul><li>  Sel - Sel TVM terdiri dari paling banyak 1023 bit data, dan paling banyak empat referensi ke sel lain.  Semua data persisten (termasuk kode TVM) di TON Blockchain direpresentasikan sebagai kumpulan sel TVM (lih. [1, 2.5.14]).  - sel TVM terdiri dari tidak lebih dari 1023 bit data dan tidak lebih dari empat tautan ke sel lain.  Semua data persisten (termasuk kode TVM) di TON blockchain disajikan sebagai satu set sel TVM (lih. [1, 2.5.14]).  - kutipan dari deskripsi TON Virtual Machine ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://test.ton.org/tvm.pdf</a> ) </li></ul><br><h2 id="kakie-mozhno-sdelat-vyvody-na-osnove-prochitannogo">  Kesimpulan apa yang bisa ditarik berdasarkan apa yang saya baca? </h2><br><ol><li>  Anda dapat mengirim pesan eksternal ke kontrak untuk memicu tindakan. </li><li>  Serangan - ada, misalnya, serangan replay </li><li>  Layak membuat metode <em>seqno</em> untuk melindungi dari serangan replay. </li><li>  Penyelesai Dns memiliki metode dnsresolve </li><li>  Anda dapat menyimpan hash pesan eksternal untuk melindungi dari serangan, tetapi Anda harus menghapusnya tepat waktu, karena ini ada baiknya menggunakan bidang <em>expired_at</em> untuk pesan eksternal </li><li>  Pesan tidak-kembali hanya diperlukan untuk membuat kontrak, jika tidak, semua pesan internal akan dikembalikan </li><li>  Pesan respons-permintaan harus berisi bidang-bidang berikut: <em>op, query_id</em> - opsional, dan beberapa lainnya tergantung pada nilai <em>op</em> </li><li>  Anda dapat melampirkan komentar teks dalam format UTF-8 untuk orang-orang dan "komentar biner" untuk dibaca dan diproses secara otomatis oleh perangkat lunak pihak ketiga. </li><li>  Ada baiknya menangani pengecualian dan melakukannya dengan bijak </li><li>  "Pesan sederhana tanpa komentar" - harus memiliki badan kosong </li><li>  Sedikit pesan permintaan respons tingkat tinggi mengambil nilai 0 untuk pesan permintaan, dan nilai 1 untuk pesan respons </li><li>  Ada nilai op standar untuk pesan respons untuk mengidentifikasi kesalahan </li><li>  Jika pesan respons diterima dengan op yang tidak dikenal, itu harus diabaikan, yaitu, eksekusi lengkap dengan kode 0 </li><li>  Anda harus membayar untuk mengirim pesan, untuk bensin dan untuk mengirim tanggapan.  Pada saat yang sama, jika dia mengirim lebih dari yang diperlukan, kelebihannya akan kembali pada jawabannya. </li><li>  Saat menerima pesan, selalu perlu memeriksa bendera yang <em>dipantulkan terlebih dahulu.</em> </li></ol><br><p>  Terima kasih atas perhatian Anda, saya akan dengan senang hati memberikan tanggapan yang membangun! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470772/">https://habr.com/ru/post/id470772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470750/index.html">Amazon ketahuan menangkap produk unggulan</a></li>
<li><a href="../id470752/index.html">Parsing Pembayaran Weechat</a></li>
<li><a href="../id470754/index.html">RASA Chatbot: Parallels Experience</a></li>
<li><a href="../id470756/index.html">Membuat aplikasi backend untuk obrolan online Apollo, Node.js</a></li>
<li><a href="../id470758/index.html">Tinjauan aktivitas viral pada September 2019</a></li>
<li><a href="../id470774/index.html">Anotasi Jenis Baru di Python 3.8 (Protokol, Final, TypedDict, Literal)</a></li>
<li><a href="../id470778/index.html">Ulasan drive Seagate ST2000DM008: fast â€œtwoâ€ tanpa overprice</a></li>
<li><a href="../id470780/index.html">Bilah diambil - yang baru dari Seagate untuk penyimpanan</a></li>
<li><a href="../id470782/index.html">Data di Border: Cara Membangun Arsitektur TI Baru</a></li>
<li><a href="../id470784/index.html">Desain warna dunia Sel Mati yang misterius</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>