<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖕🏿 🧓🏿 👨🏾‍🎓 3DTouch-在iPhone上缩放：入门 🐲 😟 👨🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="iPhone 6s和iPhone 6s Plus带有支持3D Touch技术的屏幕进入市场后，几乎在App Store中就出现了一个用于称重李子和桃子的应用程序。 



 我不能肯定地说出这些水果为何正确，但是我可以肯定地说出为什么这些确切结果。 事实是，iPhone屏幕传感器的工作原理是检测传感...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>3DTouch-在iPhone上缩放：入门</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417221/"> iPhone 6s和iPhone 6s Plus带有支持<b>3D Touch</b>技术的屏幕进入市场后，几乎在App Store中就出现了一个用于称重李子和桃子的应用程序。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f2/2d4/bd1/5f22d4bd13701e9335692b50a749f6db.png" alt="图片"><br><a name="habracut"></a><br> 我不能肯定地说出这些水果为何正确，但是我可以肯定地说出为什么这些确切结果。 事实是，iPhone屏幕传感器的工作原理是检测传感器表面的电流泄漏，对于这种泄漏，您需要带电的手指或具有电容的东西。 我想每个人都知道i设备的屏幕不能在塑料笔或指甲上工作。 这就是为什么无法在该应用程序上称重金属的原因。 但是水果有电容量，传感器被触发并且<b>3D Touch</b>直接正常工作。 <br><br> 很快，该应用程序已从App Store中删除。 就我个人而言，这似乎是由于心胸狭窄的用户尝试在其设备上称磅重量而完成的。 当然，这些设备坏了，然后将它们带到服务中心。 然后他们在系列中说了一些话：“该应用程序是从官方商店下载的，他们没有警告那里不可能……”。 <br><br> 结果，商店中没有这样的应用程序，但是没有人会阻止我们为自己创建它。 <br><br><h3> 挑战赛 </h3><br> 我们需要编写一个应用程序，该应用程序由一个控制器组成，上面有一个邀请字样，一个位于屏幕中央的画圆圈，以克为单位的重量指示器和所确定的力的百分比（在本文中将更加清楚）。 当您单击屏幕时，触摸点处将出现一个圆圈，该圆圈将根据压力而增加或减少。 必须马上说在模拟器上不能测试这样的应用程序。 因此，您将需要在真实设备上运行该应用程序。 最后，您应该获得这样的应用程序： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e76/072/e4f/e76072e4f770fccdeba9e1bff6ed5741.gif" alt="图片"><br><br><h3> 项目创建 </h3><br> 打开Xcode，选择创建一个新项目， <b>Single View Application</b>模板 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06f/11d/554/06f11d55440aabdf164ae8134b3f4e5e.png" alt="图片"><br><br><h3> 在Xcode中建立介面 </h3><br> 转到<b>情节提要</b> ，从元素库中将几个<b>UILabel</b>拖动到控制器上，将它们靠近控制器的上边缘或下边缘。 原来是这样的： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b43/c44/5a9/b43c445a90e3087318db534d0c918571.png" alt="图片"><br><br> 为了美观，我们将突出显示将对象放置在红色圆圈中的位置。 您可以用圆圈拍摄现成的图片，但这不是我们的方法））。 我们将使用<b>Core Graphics</b>的方法绘制圆。 从UIView创建继承类并已经使用它会更加方便。 <br><br> 向项目添加一个新文件，将其命名为<b>ScaleView</b> 。 在此文件中创建一个从<b>UIView</b>继承的<b>ScaleView</b>类。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/412/e5e/ab7/412e5eab7d7f179923c41d4fc5ed09ea.png" alt="图片"><br><br><pre><code class="hljs objectivec">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ScaleView: <span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> { override func draw(_ rect: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>) { } }</code> </pre> <br> 接下来，转到<b>StoryBoard</b> ，将其从<b>UIView</b>元素库转移到控制器，并将其放置在控制器的中心。 选择新添加的<b>UIView，</b>然后在<b>Identity Inspector中</b>设置我们之前创建的<b>ScaleView</b>类。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/354/aac/8aa354aacf9827ccc82f172e14dcd076.png" alt="图片"><br><br> 另外，借助常量，您可以设置屏幕上元素的相对排列规则。 对我来说看起来像这样： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72e/791/e70/72e791e70fba5daeb39f4b796e91c2fd.png" alt="图片"><br><br><h3> 画圆 </h3><br> 转到<i>ScaleView.swift</i>文件。 在<b>ScaleView</b>类中<b>，</b>我们创建了<i>draw（_ rect :)</i>方法，该方法将用于在此<b>UIView</b>的显示区域内进行绘制。 <br><br> 将以下代码添加到<i>draw（_ rect :)</i>方法中 <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect: CGRect)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = <span class="hljs-type"><span class="hljs-type">UIGraphicsGetCurrentContext</span></span>() <span class="hljs-comment"><span class="hljs-comment">// 1 context?.setStrokeColor(UIColor.red.cgColor) // 2 context?.setLineWidth(14.0) // 3 context?.addArc(center: CGPoint(x: 375 / 2, y: 375 / 2), radius: 375 / 2 - 14, startAngle: 0, endAngle: 2 * CGFloat(M_PI), clockwise: true) // 4 context?.strokePath() // 5 }</span></span></code> </pre><br><ol><li> 我们得到了将要绘制的图形上下文 </li><li> 我们设置绘制颜色。 在这种情况下。 是红色的 </li><li> 设置绘制线条的宽度。 </li><li> 我们以弧线的形式设置绘制路径，弧线的中心位于ScaleView的中心，半径等于ScaleView的宽度的一半减去14（这是将弧线插入可见的视图中），以及长弧线-围绕整个圆周360度。 请注意，我的宽度数字在上一段中使用常量进行了硬编码。 </li><li> 我们使用给定的参数绘制给定的路径 </li></ol><br> 您可以对其进行编译以进行验证，但也可以设置指令以直接在<b>Interface Builder中</b>显示更改。 <br><br>  <b>@IBDesignable</b>指令中的所有魔力。 用此指令标记<b>ScaleView</b>类<b>。</b> <br><br><pre> <code class="hljs objectivec">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> @IBDesignable <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ScaleView: <span class="hljs-built_in"><span class="hljs-built_in">UIView</span></span> { override func draw(_ rect: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>) { let context = <span class="hljs-built_in"><span class="hljs-built_in">UIGraphicsGetCurrentContext</span></span>() context?.setStrokeColor(<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>.red.cgColor) context?.setLineWidth(<span class="hljs-number"><span class="hljs-number">14.0</span></span>) context?.addArc(center: <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>(x: <span class="hljs-number"><span class="hljs-number">375</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">375</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>), radius: <span class="hljs-number"><span class="hljs-number">375</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">14</span></span>, startAngle: <span class="hljs-number"><span class="hljs-number">0</span></span>, endAngle: <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span>(M_PI), clockwise: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) context?.strokePath() } }</code> </pre><br> 之后，转到<b>StoryBoard</b> ，稍等片刻，您将在<b>ViewController</b>的中心看到一个红色圆圈 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec6/58b/c68/ec658bc68480cba218ea3d884a4a8f90.png" alt="图片"><br><br> 让我们练习并画出一个更小或更细的圆。 为此，将以下代码添加到<b>ScaleView</b>文件中的<i>draw（_ rect :)</i>方法中： <br><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">context</span></span>?.setLineWidth(<span class="hljs-number"><span class="hljs-number">1.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>?.setStrokeColor(UIColor.lightGray.cgColor) <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>?.addArc(center: CGPoint(x: <span class="hljs-number"><span class="hljs-number">375</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">375</span></span> / <span class="hljs-number"><span class="hljs-number">2</span></span>), radius: <span class="hljs-number"><span class="hljs-number">375</span></span> / <span class="hljs-number"><span class="hljs-number">4</span></span> - <span class="hljs-number"><span class="hljs-number">14</span></span>, startAngle: <span class="hljs-number"><span class="hljs-number">0</span></span>, endAngle: <span class="hljs-number"><span class="hljs-number">2</span></span> * CGFloat(M_PI), clockwise: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">context</span></span>?.strokePath()</code> </pre><br> 我认为这很清楚，因此我们添加了。 实际上，我们又添加了一个圆形，灰色，半径为<b>ScaleView</b>宽度的<b>四分之一</b>和一个点的宽度。 <br><br>  <b>StoryBoard中的</b>结果： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87c/e4a/915/87ce4a91510e918c2a8bfdef9c109c3c.png" alt="图片"><br><br> 准备工作的最后一部分将是为<b>ScaleView</b>和两个<b>UILabel</b>创建出口，这将显示按百分比的屏幕强度和以克为单位的重量。  <b>按住Ctrl键</b>从<b>ViewController中</b>拖动项目将创建必要的出口。 <br><br><pre> <code class="hljs swift"><span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scaleView: <span class="hljs-type"><span class="hljs-type">ScaleView!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> forceLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grammLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span></code> </pre><br><h3> 直接秤 </h3><br> 因此，我们接近测量按压屏幕的力的时刻。 转到<b>ViewController</b>并在<i>viewDidLoad（）</i>方法中为所有<b>UILabel</b>添加起始值 <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">viewDidLoad</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.viewDidLoad() forceLabel.text = <span class="hljs-string"><span class="hljs-string">"0% force"</span></span> grammLabel.text = <span class="hljs-string"><span class="hljs-string">"0 "</span></span> }</code> </pre><br> 像所有与屏幕点击相关的过程一样，在控制器中，它们可以被<i>touchesMoved（_：:)</i>方法捕获。 当屏幕及时触摸时，此方法有效。 即 如果手指在屏幕上或在屏幕上移动，则此方法有效，并且您可以跟踪所有触摸及其属性。 将其添加到<b>ViewController</b>并编写以下代码： <br><br><pre> <code class="hljs pgsql">override func touchesMoved(_ touches: <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;UITouch&gt;, <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> event: UIEvent?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let touch = touches.first { // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #available(iOS <span class="hljs-number"><span class="hljs-number">9.0</span></span>, *) { // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> traitCollection.forceTouchCapability == UIForceTouchCapability.available { // <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> touch.force &gt;= touch.maximumPossibleForce { // <span class="hljs-number"><span class="hljs-number">4</span></span> forceLabel.text = "100%+ force" grammLabel.text = "385 " } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { let force = (touch.force / touch.maximumPossibleForce) * <span class="hljs-number"><span class="hljs-number">100</span></span> // <span class="hljs-number"><span class="hljs-number">5</span></span> let grams = force * <span class="hljs-number"><span class="hljs-number">385</span></span> / <span class="hljs-number"><span class="hljs-number">100</span></span> // <span class="hljs-number"><span class="hljs-number">6</span></span> let roundGrams = <span class="hljs-type"><span class="hljs-type">Int</span></span>(grams) // <span class="hljs-number"><span class="hljs-number">7</span></span> forceLabel.text = "\(Int(force))% force" // <span class="hljs-number"><span class="hljs-number">8</span></span> grammLabel.text = "\(roundGrams) " } } } } }</code> </pre><br>  <b>Libra</b> iOS应用程序的所有机制都是这种方法。 我们将在本课程中进一步做的所有其他事情就是改进。 我们已经完成了所有基本工作。 让我们拆开 <br><br><ol><li> 从整个屏幕触摸中，我们选择第一个 </li><li> 该伪指令检查设备上已安装的操作系统，并且仅在操作系统版本为9.0或更高时才跳过。 仅在iOS的第9版中，才可以使用<b>3D Touch</b> 。 尝试在较早版本的痛苦中处理它没有任何意义 </li><li> 在这一行中，正在测试该设备是否支持<b>3D Touch</b>功能的屏幕。 毕竟，iOS 10也可以安装在iPhone 6上，但是从这一点来看，这款智能手机的屏幕将无法区分压力。 此检查必须在严格的Apple要求下进行。 </li><li> 触摸具有force属性，每次<i>touchesMoved（_：:)</i>方法工作时，都会传递力。 在这一行中，我们将当前按压力的值与按压力的最大可能值进行比较。 如果按压力大于最大值，则在<b>UILabel中</b>传递最大值，即力的<b>100</b> ％和<b>385</b>克。 应该注意为什么它是385克。 事实是<b>3D Touch</b>技术的制造方式是，按压力的100％相当于385克。 相应地，获得压力的百分比，我们可以轻松地计算出以克为单位的重量。 </li><li> 在这里，我们进行这些计算。 在这一行中，我们计算压力百分比 </li><li> 在这里，我们根据公式<b>100％= 385克</b>计算重量（ <b>克）</b> </li><li> 这是对整个克的简单四舍五入 </li><li> 我们将以克为单位的强度和重量百分比传递给<b>UILabel</b> </li></ol><br> 在启动和检查应用程序之前，您需要添加另一种在屏幕上的所有触摸都停止<i>touchesEnded（：:)</i>时起作用的方法，以便设置<i>UILabel</i>的初始位置并将其值传递给0％和0克。 将此方法添加到<b>ViewController</b>类。 <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">touchesEnded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span></span></span> { forceLabel.text = <span class="hljs-string"><span class="hljs-string">"0% force"</span></span> grammLabel.text = <span class="hljs-string"><span class="hljs-string">"0 "</span></span> }</code> </pre><br> 现在您可以编译应用程序并进行检查。 当然，您需要在真实设备上执行此操作才能查看结果。 模拟器无法在屏幕上模拟强制点击。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebb/663/93e/ebb66393e6b57094146b1ec867afe979.gif" alt="图片"><br><br><h3> 改进之处 </h3><br> 主要功能已经准备就绪，但是当我编写此应用程序时，我决定添加三件事： <br><br><ol><li> 当达到最大值时，我希望振动响应起作用 </li><li>  <b>UILabel中的</b>值更新非常迅速（我认为您在测试时注意到了这一点），因此需要增加一些平滑度。 </li><li> 半透明的圆圈应该出现在按压点处。 其直径应随压力增加而增大，而随压力减小而减小 </li></ol><br> 我们将在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以下文章中</a>处理这些新增<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内容</a> ：-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN417221/">https://habr.com/ru/post/zh-CN417221/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN417207/index.html">背景：Hyperloop子弹头列车</a></li>
<li><a href="../zh-CN417209/index.html">从头开始的神经网络。 免费且无需注册的俄语课程和文章概述</a></li>
<li><a href="../zh-CN417211/index.html">用于学习电路基础的表。 为什么不呢</a></li>
<li><a href="../zh-CN417215/index.html">您需要了解的有关Python中垃圾收集器的所有信息</a></li>
<li><a href="../zh-CN417219/index.html">忘了汉堡王吧！ 文件泄漏更危险</a></li>
<li><a href="../zh-CN417223/index.html">胶囊神经网络</a></li>
<li><a href="../zh-CN417225/index.html">Boshernitsan定理</a></li>
<li><a href="../zh-CN417227/index.html">费米悖论发生了什么</a></li>
<li><a href="../zh-CN417229/index.html">忘记PascalABC.Net的几个原因</a></li>
<li><a href="../zh-CN417231/index.html">具有人机界面的企业商品</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>