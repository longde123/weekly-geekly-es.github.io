<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÄüèª üë®‚Äçüë©‚Äçüë¶ üñï Pensamiento funcional Parte 7 üâë üç¥ üë©üèΩ‚Äçü§ù‚Äçüë®üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos nuestra serie de art√≠culos sobre programaci√≥n funcional en F #. Hoy tenemos un tema muy interesante: la definici√≥n de funciones. Incluyend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamiento funcional Parte 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p>  Continuamos nuestra serie de art√≠culos sobre programaci√≥n funcional en F #.  Hoy tenemos un tema muy interesante: la definici√≥n de funciones.  Incluyendo, hablemos de funciones an√≥nimas, funciones sin par√°metros, funciones recursivas, combinadores y mucho m√°s.  ¬°Mira debajo del gato! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segunda parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cuarta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quinta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sexta parte</a></strong> <a name="habracut"></a></li></ul><br><h1>  Definici√≥n de funci√≥n </h1><br><p>  Ya sabemos c√≥mo crear funciones regulares utilizando la sintaxis "let": </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  En este art√≠culo, veremos algunas otras formas de crear funciones, as√≠ como consejos para definirlas. </p><br><h2>  Funciones an√≥nimas (lambdas) </h2><br><p>  Si est√° familiarizado con lambdas en otros idiomas, los siguientes p√°rrafos le parecer√°n familiares.  Las funciones an√≥nimas (o "expresiones lambda") se definen de la siguiente manera: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  En comparaci√≥n con las lambdas de C #, hay dos diferencias: </p><br><ul><li>  lambdas debe comenzar con la palabra clave <code>fun</code> , que no se requiere en C # </li><li>  <code>-&gt;</code> usa una sola flecha <code>-&gt;</code> , en lugar de doble <code>=&gt;</code> de C #. </li></ul><br><p>  Definici√≥n lambda de la funci√≥n de suma: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  Misma funci√≥n en forma tradicional: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Las lambdas se usan a menudo en forma de peque√±as expresiones o cuando no se desea definir una funci√≥n separada para una expresi√≥n.  Como ya has visto, cuando trabajas con listas, esto no es raro. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Tenga en cuenta que los par√©ntesis deben usarse alrededor de lambdas. </p><br><p>  Las lambdas tambi√©n se usan cuando se necesita una funci√≥n claramente diferente.  Por ejemplo, el " <code>adderGenerator</code> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discutido anteriormente,</a> que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discutimos anteriormente,</a> puede reescribirse usando lambdas. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  La versi√≥n lambda es un poco m√°s larga, pero inmediatamente deja en claro que se devolver√° una funci√≥n intermedia. </p><br><p>  Las lambdas pueden estar anidadas.  Otro ejemplo de una definici√≥n de <code>adderGenerator</code> , esta vez solo en lambdas. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  ¬øEst√° claro que las tres definiciones son equivalentes? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  De lo contrario, vuelva a leer el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cap√≠tulo sobre curry</a> .  ¬°Esto es muy importante para entender! </p><br><h2>  Coincidencia de patrones </h2><br><p>  Cuando se define una funci√≥n, es posible pasarle par√°metros expl√≠citamente, como en los ejemplos anteriores, pero tambi√©n es posible compararla directamente con una plantilla en la secci√≥n de par√°metros.  En otras palabras, la secci√≥n de par√°metros puede contener patrones (patrones coincidentes), ¬°y no solo identificadores! </p><br><p>  El siguiente ejemplo demuestra el uso de patrones en una definici√≥n de funci√≥n: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  Este tipo de comparaci√≥n solo puede ocurrir cuando la correspondencia siempre es decidible.  Por ejemplo, no puede hacer coincidir los tipos de uni√≥n y las listas de esta manera, porque algunos casos no pueden coincidir. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  El compilador dar√° una advertencia sobre una coincidencia incompleta (una lista vac√≠a causar√° un error en tiempo de ejecuci√≥n en la entrada de esta funci√≥n). </p><br><h2>  Error com√∫n: tuplas vs.  muchos par√°metros </h2><br><p>  Si proviene de un lenguaje tipo C, la tupla utilizada como √∫nico argumento de la funci√≥n puede parecerse dolorosamente a una funci√≥n de par√°metros m√∫ltiples.  ¬°Pero esto no es lo mismo!  Como se√±al√© anteriormente, si ve una coma, es muy probable que sea una tupla.  Los par√°metros est√°n separados por espacios. </p><br><p>  Ejemplo de confusi√≥n: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  La primera definici√≥n, " <code>addTwoParams</code> ", toma dos par√°metros, separados por un espacio. </li><li>  La segunda definici√≥n, " <code>addTuple</code> ", toma un par√°metro.  Este par√°metro une "x" e "y" de la tupla y los suma. </li><li>  La tercera definici√≥n, " <code>addConfusingTuple</code> ", toma un par√°metro como " <code>addTuple</code> ", pero el truco es que esta tupla se desempaqueta (coincide con el patr√≥n) y se enlaza como parte de la definici√≥n del par√°metro mediante la coincidencia de patrones.  Detr√°s de escena, todo sucede exactamente igual que en <code>addTuple</code> . </li></ul><br><p>  Echemos un vistazo a las firmas (siempre m√≠relas si no est√° seguro de algo). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  Y ahora aqu√≠: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Aqu√≠ vemos un error en la segunda llamada. </p><br><p>  Primero, el compilador trata <code>(1,2)</code> como una tupla generalizada del formulario <code>('a * 'b)</code> , que intenta pasar como el primer par√°metro a " <code>addTwoParams</code> ".  Despu√©s de lo cual se queja de que el primer par√°metro esperado <code>addTwoParams</code> no <code>addTwoParams</code> <code>int</code> , sino que se intent√≥ pasar una tupla. </p><br><p>  Para hacer una tupla, usa una coma. </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  Y viceversa, si pasa varios argumentos a una funci√≥n que espera una tupla, tambi√©n obtiene un error incomprensible. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  Esta vez, el compilador decidi√≥ que una vez que se <code>addConfusingTuple</code> dos argumentos, <code>addConfusingTuple</code> deber√≠a curry.  Y la entrada " <code>addConfusingTuple 1</code> " es una aplicaci√≥n parcial y deber√≠a devolver una funci√≥n intermedia.  Intentar llamar a esta funci√≥n intermedia con el par√°metro "2" arrojar√° un error, porque  ¬°no hay una funci√≥n intermedia!  Vemos el mismo error que en el cap√≠tulo sobre curry, donde discutimos problemas con demasiados par√°metros. </p><br><h3>  ¬øPor qu√© no usar tuplas como par√°metros? </h3><br><p>  La discusi√≥n de las tuplas anterior muestra otra forma de definir funciones con muchos par√°metros: en lugar de pasarlas por separado, todos los par√°metros pueden ensamblarse en una estructura.  En el siguiente ejemplo, la funci√≥n toma un solo par√°metro: una tupla de tres elementos. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Cabe se√±alar que la firma es diferente de la firma de una funci√≥n con tres par√°metros.  Solo hay una flecha, un par√°metro y asteriscos que apuntan a la tupla <code>(int*int*int)</code> . </p><br><p>  ¬øCu√°ndo es necesario presentar argumentos con par√°metros separados y cu√°ndo una tupla? </p><br><ul><li>  Cuando las tuplas son significativas en s√≠ mismas.  Por ejemplo, para operaciones en espacio tridimensional, las tuplas triples ser√°n m√°s convenientes que las tres coordenadas por separado. </li><li>  A veces, las tuplas se usan para combinar datos que deben almacenarse juntos en una sola estructura.  Por ejemplo, los m√©todos <code>TryParse</code> de la biblioteca .NET devuelven el resultado y una variable booleana como una tupla.  Pero para almacenar una gran cantidad de datos relacionados, es mejor definir una clase o registro ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registro</a> . </li></ul><br><h3>  Caso especial: tuplas y funciones de la biblioteca .NET </h3><br><p>  ¬°Al llamar a las bibliotecas .NET, las comas son muy comunes! </p><br><p>  Todos aceptan tuplas y las llamadas tienen el mismo aspecto que en C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  La raz√≥n es que las funciones de .NET cl√°sico no son curry y no se pueden aplicar parcialmente.  <em>Todos los</em> par√°metros <em>siempre</em> deben transmitirse de inmediato, y la forma m√°s obvia es usar una tupla. </p><br><p>  Tenga en cuenta que estas llamadas solo parecen transferir tuplas, pero este es realmente un caso especial.  No puedes pasar tuplas reales a tales funciones: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  Si desea aplicar parcialmente las funciones .NET, simplemente escriba envoltorios sobre ellas, como se hizo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriormente</a> , o como se muestra a continuaci√≥n: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Gu√≠a para seleccionar par√°metros individuales y agrupados </h2><br><p>  La discusi√≥n de las tuplas conduce a un tema m√°s general: ¬øcu√°ndo deben separarse los par√°metros y cu√°ndo deben agruparse? </p><br><p>  Debe prestar atenci√≥n a c√≥mo F # difiere de C # a este respecto.  En C #, <em>todos los</em> par√°metros <em>siempre se</em> pasan, por lo que esta pregunta ni siquiera surge all√≠.  En F #, debido a la aplicaci√≥n parcial, solo se pueden representar algunos de los par√°metros, por lo que es necesario distinguir entre el caso cuando los par√°metros deben combinarse y el caso cuando son independientes. </p><br><p>  Recomendaciones generales sobre c√≥mo estructurar par√°metros al dise√±ar sus propias funciones. </p><br><ul><li>  En el caso general, siempre es mejor usar par√°metros separados en lugar de pasar una estructura, ya sea una tupla o un registro.  Esto permite un comportamiento m√°s flexible, como la aplicaci√≥n parcial. </li><li>  Pero, cuando se <em>necesita</em> pasar un grupo de par√°metros <em>a la</em> vez, se debe utilizar alg√∫n tipo de mecanismo de agrupaci√≥n. </li></ul><br><p>  En otras palabras, cuando desarrolle una funci√≥n, preg√∫ntese: "¬øPuedo proporcionar este par√°metro por separado?"  Si la respuesta es no, entonces los par√°metros deben agruparse. </p><br><p>  Veamos algunos ejemplos: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Finalmente, aseg√∫rese de que el orden de los par√°metros ayudar√° en la aplicaci√≥n parcial (consulte el manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> ).  Por ejemplo, ¬øpor qu√© puse <code>myCredentials</code> antes de <code>aName</code> en la √∫ltima funci√≥n? </p><br><h2>  Funciones sin par√°metros. </h2><br><p>  A veces puede necesitar una funci√≥n que no acepte ning√∫n par√°metro.  Por ejemplo, necesita la funci√≥n "hola mundo" que se puede llamar varias veces.  Como se muestra en la secci√≥n anterior, la definici√≥n ingenua no funciona. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  Pero esto se puede solucionar agregando un par√°metro de unidad a la funci√≥n o usando una lambda. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  Despu√©s de eso, la funci√≥n siempre debe llamarse con el argumento de la <code>unit</code> : </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  Lo que sucede con bastante frecuencia cuando interact√∫a con las bibliotecas .NET: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  Recuerda, ¬°ll√°malos con los par√°metros de la <code>unit</code> ! </p><br><h2>  Definiendo nuevos operadores </h2><br><p>  Puede definir funciones utilizando uno o m√°s caracteres de operador (consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> para obtener una lista de caracteres): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  Debe usar par√©ntesis alrededor de los caracteres para definir funciones. </p><br><p>  Los operadores que comienzan con <code>*</code> requieren un espacio entre par√©ntesis y <code>*</code> , porque  en F # <code>(*</code> act√∫a como el comienzo de un comentario (como <code>/*...*/</code> en C #): </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Una vez definida, una nueva funci√≥n se puede usar de la manera habitual si est√° entre par√©ntesis: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  Si la funci√≥n se usa con dos par√°metros, puede usar el registro de operador infijo sin par√©ntesis. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  ¬°Tambi√©n puede definir operadores de prefijo comenzando por <code>!</code>  o <code>~</code> (con algunas restricciones, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  En F #, la definici√≥n de declaraciones es una operaci√≥n bastante com√∫n, y muchas bibliotecas exportar√°n declaraciones con nombres como <code>&gt;=&gt;</code> y <code>&lt;*&gt;</code> . </p><br><h2>  Estilo sin puntos </h2><br><p>  Ya hemos visto muchos ejemplos de funciones que carec√≠an de los √∫ltimos par√°metros para reducir el nivel de caos.  Este estilo se llama <strong>estilo libre de puntos</strong> o <strong>programaci√≥n t√°cita</strong> . </p><br><p>  Aqu√≠ hay algunos ejemplos: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  Este estilo tiene sus pros y sus contras. </p><br><p>  Una de las ventajas es que el √©nfasis est√° en la composici√≥n de funciones de orden superior en lugar de preocuparse por los objetos de bajo nivel.  Por ejemplo, " <code>(+) 1 &gt;&gt; (*) 2</code> " es una suma expl√≠cita seguida de multiplicaci√≥n.  Y " <code>List.reduce (+)</code> " deja en claro que la operaci√≥n de adici√≥n es importante, independientemente de la informaci√≥n de la lista. </p><br><p>  Un estilo sin sentido le permite centrarse en el algoritmo b√°sico e identificar caracter√≠sticas comunes en el c√≥digo.  La funci√≥n " <code>reduce</code> " utilizada anteriormente es un buen ejemplo.  Este tema se discutir√° en una serie planificada sobre el procesamiento de listas. </p><br><p>  Por otro lado, el uso excesivo de tal estilo puede hacer que el c√≥digo sea oscuro.  Los par√°metros expl√≠citos act√∫an como documentaci√≥n y sus nombres (como "lista") facilitan la comprensi√≥n de lo que hace la funci√≥n. </p><br><p>  Como todo en programaci√≥n, la mejor recomendaci√≥n es preferir el enfoque que brinde la mayor claridad. </p><br><h2>  Combinadores </h2><br><p>  Los " <strong>combinadores</strong> " se denominan funciones cuyo resultado depende solo de sus par√°metros.  Esto significa que no hay dependencia del mundo exterior y, en particular, ninguna otra funci√≥n o valor global puede afectarlos. </p><br><p>  En la pr√°ctica, esto significa que las funciones combinatorias est√°n limitadas por una combinaci√≥n de sus par√°metros de varias maneras. </p><br><p>  Ya hemos visto varios combinadores: una tuber√≠a y un operador de composici√≥n.  Si observa sus definiciones, est√° claro que todo lo que hacen es reordenar los par√°metros de varias maneras. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  Por otro lado, funciones como "printf", aunque primitivas, no son combinadores porque dependen del mundo exterior (E / S). </p><br><h3>  P√°jaros combinatorios </h3><br><p>  Los combinadores son la base de toda una secci√≥n de l√≥gica (naturalmente llamada "l√≥gica combinatoria"), que fue inventada muchos a√±os antes que las computadoras y los lenguajes de programaci√≥n.  La l√≥gica combinatoria tiene una gran influencia en la programaci√≥n funcional. </p><br><p>  Para obtener m√°s informaci√≥n sobre los combinadores y la l√≥gica combinatoria, recomiendo el libro de Raymond Smullyan "To Mock a Mockingbird".  En √©l, explica otros combinadores y les da fantasiosamente <a href="">nombres de p√°jaros</a> .  Estos son algunos ejemplos de combinadores est√°ndar y sus nombres de aves: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Los nombres de las letras son bastante est√°ndar, por lo que puede referirse al combinador K a cualquiera que est√© familiarizado con esta terminolog√≠a. </p><br><p>  Resulta que muchos patrones de programaci√≥n comunes se pueden representar a trav√©s de estos combinadores est√°ndar.  Por ejemplo, Kestrel es un patr√≥n regular en la interfaz fluida donde haces algo pero devuelves el objeto original.  Thrush es una tuber√≠a, Queer es una composici√≥n directa, y el combinador en Y hace un excelente trabajo al crear funciones recursivas. </p><br><p>  De hecho, existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teorema bien conocido de</a> que cualquier funci√≥n computable puede construirse utilizando solo dos combinadores b√°sicos, Kestrel y Starling. </p><br><h3>  Bibliotecas combinatorias </h3><br><p>  Las bibliotecas combinatorias son bibliotecas que exportan muchas funciones combinatorias que est√°n dise√±adas para ser compartidas.  Un usuario de dicha biblioteca puede combinar f√°cilmente funciones para obtener funciones a√∫n m√°s grandes y complejas, como los cubos f√°cilmente. </p><br><p>  Una biblioteca combinada bien dise√±ada le permite centrarse en funciones de alto nivel y ocultar el "ruido" de bajo nivel.  Ya hemos visto su poder en varios ejemplos en la serie "por qu√© usar F #", y el m√≥dulo <code>List</code> est√° lleno de tales funciones, " <code>fold</code> " y " <code>map</code> " tambi√©n son combinadores si lo piensas. </p><br><p>  Otra ventaja de los combinadores es que son el tipo de funci√≥n m√°s seguro.  Porque  no tienen dependencias del mundo exterior, no pueden cambiar cuando cambia el entorno global.  Una funci√≥n que lee un valor global o usa funciones de biblioteca puede romperse o cambiar entre llamadas si el contexto cambia.  Esto nunca le suceder√° a los combinadores. </p><br><p>  En F #, las bibliotecas de combinador est√°n disponibles para analizar (FParsec), crear HTML, probar marcos, etc.  Discutiremos y usaremos combinadores m√°s adelante en la pr√≥xima serie. </p><br><h2>  Funciones recursivas </h2><br><p>  A menudo, una funci√≥n necesita referirse a s√≠ misma desde su cuerpo.  Un ejemplo cl√°sico es la funci√≥n de Fibonacci. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Desafortunadamente, esta funci√≥n no podr√° compilar: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  Debe decirle al compilador que esta es una funci√≥n recursiva que utiliza la palabra clave <code>rec</code> . </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Las funciones recursivas y las estructuras de datos son muy comunes en la programaci√≥n funcional, y espero dedicar una serie completa a este tema m√°s adelante. </p><br><h1>  Recursos Adicionales </h1><br><p>  Hay muchos tutoriales para F #, incluidos los materiales para aquellos que vienen con experiencia en C # o Java.  Los siguientes enlaces pueden ser √∫tiles a medida que profundiza en F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # por diversi√≥n y ganancias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprenda X en minutos Y: F #</a> </li></ul><br><p>  Tambi√©n se describen varias otras formas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de comenzar a aprender F #</a> . </p><br><p>  Finalmente, la comunidad F # es muy amigable para principiantes.  Hay un chat muy activo en Slack, respaldado por la F # Software Foundation, con salas para principiantes a las que puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unirte libremente</a> .  ¬°Recomendamos encarecidamente que haga esto! </p><br><p>  ¬°No te olvides de visitar el sitio de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de habla rusa F #</a> !  Si tiene alguna pregunta sobre el aprendizaje de un idioma, estaremos encantados de discutirlo en las salas de chat: </p><br><ul><li>  room <code>#ru_general</code> en el <code>#ru_general</code> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en gitter</a> </li><li>  room #en_general en el chat flojo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  Sobre autores de traducci√≥n </h2><br><p>  Traducido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  La traducci√≥n y los cambios editoriales fueron realizados por los esfuerzos de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de desarrolladores de F # de habla rusa</a> .  Tambi√©n agradecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@schvepsss</em></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@shwars</em></a> por preparar este art√≠culo para su publicaci√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433398/">https://habr.com/ru/post/es433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433386/index.html">C√≥mo usar una visi√≥n por computadora para evaluar la condici√≥n del autom√≥vil. Vive Yandex.Taxi</a></li>
<li><a href="../es433388/index.html">Fan√°tico de la f√≥rmula o por qu√© jugamos juegos</a></li>
<li><a href="../es433390/index.html">Yandex se uni√≥ a la protecci√≥n de Linux y la industria de TI del trolling de patentes</a></li>
<li><a href="../es433392/index.html">Revisi√≥n del tel√©fono Snom D725 IP</a></li>
<li><a href="../es433396/index.html">Frontend 2018: resultados del a√±o</a></li>
<li><a href="../es433400/index.html">Tutorial React Parte 2: Componentes funcionales</a></li>
<li><a href="../es433402/index.html">Pensamiento funcional Parte 8</a></li>
<li><a href="../es433404/index.html">Tutorial React Parte 3: Archivos de componentes, estructura del proyecto</a></li>
<li><a href="../es433406/index.html">Pensamiento funcional Parte 9</a></li>
<li><a href="../es433408/index.html">Manejo eficiente de la memoria en Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>