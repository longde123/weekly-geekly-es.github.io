<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏻 👨‍👩‍👦 🖕 Pensamiento funcional Parte 7 🉑 🍴 👩🏽‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuamos nuestra serie de artículos sobre programación funcional en F #. Hoy tenemos un tema muy interesante: la definición de funciones. Incluyend...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamiento funcional Parte 7</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433398/"><p>  Continuamos nuestra serie de artículos sobre programación funcional en F #.  Hoy tenemos un tema muy interesante: la definición de funciones.  Incluyendo, hablemos de funciones anónimas, funciones sin parámetros, funciones recursivas, combinadores y mucho más.  ¡Mira debajo del gato! </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segunda parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cuarta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quinta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sexta parte</a></strong> <a name="habracut"></a></li></ul><br><h1>  Definición de función </h1><br><p>  Ya sabemos cómo crear funciones regulares utilizando la sintaxis "let": </p><br><pre><code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  En este artículo, veremos algunas otras formas de crear funciones, así como consejos para definirlas. </p><br><h2>  Funciones anónimas (lambdas) </h2><br><p>  Si está familiarizado con lambdas en otros idiomas, los siguientes párrafos le parecerán familiares.  Las funciones anónimas (o "expresiones lambda") se definen de la siguiente manera: </p><br><pre> <code class="plaintext hljs">fun parameter1 parameter2 etc -&gt; expression</code> </pre> <br><p>  En comparación con las lambdas de C #, hay dos diferencias: </p><br><ul><li>  lambdas debe comenzar con la palabra clave <code>fun</code> , que no se requiere en C # </li><li>  <code>-&gt;</code> usa una sola flecha <code>-&gt;</code> , en lugar de doble <code>=&gt;</code> de C #. </li></ul><br><p>  Definición lambda de la función de suma: </p><br><pre> <code class="plaintext hljs">let add = fun xy -&gt; x + y</code> </pre> <br><p>  Misma función en forma tradicional: </p><br><pre> <code class="plaintext hljs">let add xy = x + y</code> </pre> <br><p>  Las lambdas se usan a menudo en forma de pequeñas expresiones o cuando no se desea definir una función separada para una expresión.  Como ya has visto, cuando trabajas con listas, esto no es raro. </p><br><pre> <code class="plaintext hljs">//    let add1 i = i + 1 [1..10] |&gt; List.map add1 //        [1..10] |&gt; List.map (fun i -&gt; i + 1)</code> </pre> <br><p>  Tenga en cuenta que los paréntesis deben usarse alrededor de lambdas. </p><br><p>  Las lambdas también se usan cuando se necesita una función claramente diferente.  Por ejemplo, el " <code>adderGenerator</code> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discutido anteriormente,</a> que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discutimos anteriormente,</a> puede reescribirse usando lambdas. </p><br><pre> <code class="plaintext hljs">//   let adderGenerator x = (+) x //     let adderGenerator x = fun y -&gt; x + y</code> </pre> <br><p>  La versión lambda es un poco más larga, pero inmediatamente deja en claro que se devolverá una función intermedia. </p><br><p>  Las lambdas pueden estar anidadas.  Otro ejemplo de una definición de <code>adderGenerator</code> , esta vez solo en lambdas. </p><br><pre> <code class="plaintext hljs">let adderGenerator = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  ¿Está claro que las tres definiciones son equivalentes? </p><br><pre> <code class="plaintext hljs">let adderGenerator1 xy = x + y let adderGenerator2 x = fun y -&gt; x + y let adderGenerator3 = fun x -&gt; (fun y -&gt; x + y)</code> </pre> <br><p>  De lo contrario, vuelva a leer el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">capítulo sobre curry</a> .  ¡Esto es muy importante para entender! </p><br><h2>  Coincidencia de patrones </h2><br><p>  Cuando se define una función, es posible pasarle parámetros explícitamente, como en los ejemplos anteriores, pero también es posible compararla directamente con una plantilla en la sección de parámetros.  En otras palabras, la sección de parámetros puede contener patrones (patrones coincidentes), ¡y no solo identificadores! </p><br><p>  El siguiente ejemplo demuestra el uso de patrones en una definición de función: </p><br><pre> <code class="plaintext hljs">type Name = {first:string; last:string} //    let bob = {first="bob"; last="smith"} //   //     let f1 name = //   let {first=f; last=l} = name //     printfn "first=%s; last=%s" fl //   let f2 {first=f; last=l} = //        printfn "first=%s; last=%s" fl //  f1 bob f2 bob</code> </pre> <br><p>  Este tipo de comparación solo puede ocurrir cuando la correspondencia siempre es decidible.  Por ejemplo, no puede hacer coincidir los tipos de unión y las listas de esta manera, porque algunos casos no pueden coincidir. </p><br><pre> <code class="plaintext hljs">let f3 (x::xs) = //       printfn "first element is=%A" x</code> </pre> <br><p>  El compilador dará una advertencia sobre una coincidencia incompleta (una lista vacía causará un error en tiempo de ejecución en la entrada de esta función). </p><br><h2>  Error común: tuplas vs.  muchos parámetros </h2><br><p>  Si proviene de un lenguaje tipo C, la tupla utilizada como único argumento de la función puede parecerse dolorosamente a una función de parámetros múltiples.  ¡Pero esto no es lo mismo!  Como señalé anteriormente, si ve una coma, es muy probable que sea una tupla.  Los parámetros están separados por espacios. </p><br><p>  Ejemplo de confusión: </p><br><pre> <code class="plaintext hljs">//      let addTwoParams xy = x + y //      -  let addTuple aTuple = let (x,y) = aTuple x + y //         //        let addConfusingTuple (x,y) = x + y</code> </pre> <br><ul><li>  La primera definición, " <code>addTwoParams</code> ", toma dos parámetros, separados por un espacio. </li><li>  La segunda definición, " <code>addTuple</code> ", toma un parámetro.  Este parámetro une "x" e "y" de la tupla y los suma. </li><li>  La tercera definición, " <code>addConfusingTuple</code> ", toma un parámetro como " <code>addTuple</code> ", pero el truco es que esta tupla se desempaqueta (coincide con el patrón) y se enlaza como parte de la definición del parámetro mediante la coincidencia de patrones.  Detrás de escena, todo sucede exactamente igual que en <code>addTuple</code> . </li></ul><br><p>  Echemos un vistazo a las firmas (siempre mírelas si no está seguro de algo). </p><br><pre> <code class="plaintext hljs">val addTwoParams : int -&gt; int -&gt; int //   val addTuple : int * int -&gt; int // tuple-&gt;int val addConfusingTuple : int * int -&gt; int // tuple-&gt;int</code> </pre> <br><p>  Y ahora aquí: </p><br><pre> <code class="plaintext hljs">// addTwoParams 1 2 // ok --      addTwoParams (1,2) // error -     // =&gt; error FS0001: This expression was expected to have type // int but here has type 'a * 'b</code> </pre> <br><p>  Aquí vemos un error en la segunda llamada. </p><br><p>  Primero, el compilador trata <code>(1,2)</code> como una tupla generalizada del formulario <code>('a * 'b)</code> , que intenta pasar como el primer parámetro a " <code>addTwoParams</code> ".  Después de lo cual se queja de que el primer parámetro esperado <code>addTwoParams</code> no <code>addTwoParams</code> <code>int</code> , sino que se intentó pasar una tupla. </p><br><p>  Para hacer una tupla, usa una coma. </p><br><pre> <code class="plaintext hljs">addTuple (1,2) // ok addConfusingTuple (1,2) // ok let x = (1,2) addTuple x // ok let y = 1,2 //  , //  ! addTuple y // ok addConfusingTuple y // ok</code> </pre> <br><p>  Y viceversa, si pasa varios argumentos a una función que espera una tupla, también obtiene un error incomprensible. </p><br><pre> <code class="plaintext hljs">addConfusingTuple 1 2 // error --          // =&gt; error FS0003: This value is not a function and // cannot be applied</code> </pre> <br><p>  Esta vez, el compilador decidió que una vez que se <code>addConfusingTuple</code> dos argumentos, <code>addConfusingTuple</code> debería curry.  Y la entrada " <code>addConfusingTuple 1</code> " es una aplicación parcial y debería devolver una función intermedia.  Intentar llamar a esta función intermedia con el parámetro "2" arrojará un error, porque  ¡no hay una función intermedia!  Vemos el mismo error que en el capítulo sobre curry, donde discutimos problemas con demasiados parámetros. </p><br><h3>  ¿Por qué no usar tuplas como parámetros? </h3><br><p>  La discusión de las tuplas anterior muestra otra forma de definir funciones con muchos parámetros: en lugar de pasarlas por separado, todos los parámetros pueden ensamblarse en una estructura.  En el siguiente ejemplo, la función toma un solo parámetro: una tupla de tres elementos. </p><br><pre> <code class="plaintext hljs">let f (x,y,z) = x + y * z //  - int * int * int -&gt; int //  f (1,2,3)</code> </pre> <br><p>  Cabe señalar que la firma es diferente de la firma de una función con tres parámetros.  Solo hay una flecha, un parámetro y asteriscos que apuntan a la tupla <code>(int*int*int)</code> . </p><br><p>  ¿Cuándo es necesario presentar argumentos con parámetros separados y cuándo una tupla? </p><br><ul><li>  Cuando las tuplas son significativas en sí mismas.  Por ejemplo, para operaciones en espacio tridimensional, las tuplas triples serán más convenientes que las tres coordenadas por separado. </li><li>  A veces, las tuplas se usan para combinar datos que deben almacenarse juntos en una sola estructura.  Por ejemplo, los métodos <code>TryParse</code> de la biblioteca .NET devuelven el resultado y una variable booleana como una tupla.  Pero para almacenar una gran cantidad de datos relacionados, es mejor definir una clase o registro ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">registro</a> . </li></ul><br><h3>  Caso especial: tuplas y funciones de la biblioteca .NET </h3><br><p>  ¡Al llamar a las bibliotecas .NET, las comas son muy comunes! </p><br><p>  Todos aceptan tuplas y las llamadas tienen el mismo aspecto que en C #: </p><br><pre> <code class="plaintext hljs">//  System.String.Compare("a","b") //   System.String.Compare "a" "b"</code> </pre> <br><p>  La razón es que las funciones de .NET clásico no son curry y no se pueden aplicar parcialmente.  <em>Todos los</em> parámetros <em>siempre</em> deben transmitirse de inmediato, y la forma más obvia es usar una tupla. </p><br><p>  Tenga en cuenta que estas llamadas solo parecen transferir tuplas, pero este es realmente un caso especial.  No puedes pasar tuplas reales a tales funciones: </p><br><pre> <code class="plaintext hljs">let tuple = ("a","b") System.String.Compare tuple // error System.String.Compare "a","b" // error</code> </pre> <br><p>  Si desea aplicar parcialmente las funciones .NET, simplemente escriba envoltorios sobre ellas, como se hizo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">anteriormente</a> , o como se muestra a continuación: </p><br><pre> <code class="plaintext hljs">//    let strCompare xy = System.String.Compare(x,y) //    let strCompareWithB = strCompare "B" //      ["A";"B";"C"] |&gt; List.map strCompareWithB</code> </pre> <br><h2>  Guía para seleccionar parámetros individuales y agrupados </h2><br><p>  La discusión de las tuplas conduce a un tema más general: ¿cuándo deben separarse los parámetros y cuándo deben agruparse? </p><br><p>  Debe prestar atención a cómo F # difiere de C # a este respecto.  En C #, <em>todos los</em> parámetros <em>siempre se</em> pasan, por lo que esta pregunta ni siquiera surge allí.  En F #, debido a la aplicación parcial, solo se pueden representar algunos de los parámetros, por lo que es necesario distinguir entre el caso cuando los parámetros deben combinarse y el caso cuando son independientes. </p><br><p>  Recomendaciones generales sobre cómo estructurar parámetros al diseñar sus propias funciones. </p><br><ul><li>  En el caso general, siempre es mejor usar parámetros separados en lugar de pasar una estructura, ya sea una tupla o un registro.  Esto permite un comportamiento más flexible, como la aplicación parcial. </li><li>  Pero, cuando se <em>necesita</em> pasar un grupo de parámetros <em>a la</em> vez, se debe utilizar algún tipo de mecanismo de agrupación. </li></ul><br><p>  En otras palabras, cuando desarrolle una función, pregúntese: "¿Puedo proporcionar este parámetro por separado?"  Si la respuesta es no, entonces los parámetros deben agruparse. </p><br><p>  Veamos algunos ejemplos: </p><br><pre> <code class="plaintext hljs">//     . //      ,       let add xy = x + y //         //      ,    let locateOnMap (xCoord,yCoord) = //  //      //      -     type CustomerName = {First:string; Last:string} let setCustomerName aCustomerName = //  let setCustomerName first last = //   //     //     //    ,     let setCustomerName myCredentials aName = //</code> </pre> <br><p>  Finalmente, asegúrese de que el orden de los parámetros ayudará en la aplicación parcial (consulte el manual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> ).  Por ejemplo, ¿por qué puse <code>myCredentials</code> antes de <code>aName</code> en la última función? </p><br><h2>  Funciones sin parámetros. </h2><br><p>  A veces puede necesitar una función que no acepte ningún parámetro.  Por ejemplo, necesita la función "hola mundo" que se puede llamar varias veces.  Como se muestra en la sección anterior, la definición ingenua no funciona. </p><br><pre> <code class="plaintext hljs">let sayHello = printfn "Hello World!" //     </code> </pre> <br><p>  Pero esto se puede solucionar agregando un parámetro de unidad a la función o usando una lambda. </p><br><pre> <code class="plaintext hljs">let sayHello() = printfn "Hello World!" //  let sayHello = fun () -&gt; printfn "Hello World!" // </code> </pre> <br><p>  Después de eso, la función siempre debe llamarse con el argumento de la <code>unit</code> : </p><br><pre> <code class="plaintext hljs">//  sayHello()</code> </pre> <br><p>  Lo que sucede con bastante frecuencia cuando interactúa con las bibliotecas .NET: </p><br><pre> <code class="plaintext hljs">Console.ReadLine() System.Environment.GetCommandLineArgs() System.IO.Directory.GetCurrentDirectory()</code> </pre> <br><p>  Recuerda, ¡llámalos con los parámetros de la <code>unit</code> ! </p><br><h2>  Definiendo nuevos operadores </h2><br><p>  Puede definir funciones utilizando uno o más caracteres de operador (consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> para obtener una lista de caracteres): </p><br><pre> <code class="plaintext hljs">//  let (.*%) xy = x + y + 1</code> </pre> <br><p>  Debe usar paréntesis alrededor de los caracteres para definir funciones. </p><br><p>  Los operadores que comienzan con <code>*</code> requieren un espacio entre paréntesis y <code>*</code> , porque  en F # <code>(*</code> actúa como el comienzo de un comentario (como <code>/*...*/</code> en C #): </p><br><pre> <code class="plaintext hljs">let ( *+* ) xy = x + y + 1</code> </pre> <br><p>  Una vez definida, una nueva función se puede usar de la manera habitual si está entre paréntesis: </p><br><pre> <code class="plaintext hljs">let result = (.*%) 2 3</code> </pre> <br><p>  Si la función se usa con dos parámetros, puede usar el registro de operador infijo sin paréntesis. </p><br><pre> <code class="plaintext hljs">let result = 2 .*% 3</code> </pre> <br><p>  ¡También puede definir operadores de prefijo comenzando por <code>!</code>  o <code>~</code> (con algunas restricciones, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> ) </p><br><pre> <code class="plaintext hljs">let (~%%) (s:string) = s.ToCharArray() // let result = %% "hello"</code> </pre> <br><p>  En F #, la definición de declaraciones es una operación bastante común, y muchas bibliotecas exportarán declaraciones con nombres como <code>&gt;=&gt;</code> y <code>&lt;*&gt;</code> . </p><br><h2>  Estilo sin puntos </h2><br><p>  Ya hemos visto muchos ejemplos de funciones que carecían de los últimos parámetros para reducir el nivel de caos.  Este estilo se llama <strong>estilo libre de puntos</strong> o <strong>programación tácita</strong> . </p><br><p>  Aquí hay algunos ejemplos: </p><br><pre> <code class="plaintext hljs">let add xy = x + y //  let add x = (+) x // point free let add1Times2 x = (x + 1) * 2 //  let add1Times2 = (+) 1 &gt;&gt; (*) 2 // point free let sum list = List.reduce (fun sum e -&gt; sum+e) list //  let sum = List.reduce (+) // point free</code> </pre> <br><p>  Este estilo tiene sus pros y sus contras. </p><br><p>  Una de las ventajas es que el énfasis está en la composición de funciones de orden superior en lugar de preocuparse por los objetos de bajo nivel.  Por ejemplo, " <code>(+) 1 &gt;&gt; (*) 2</code> " es una suma explícita seguida de multiplicación.  Y " <code>List.reduce (+)</code> " deja en claro que la operación de adición es importante, independientemente de la información de la lista. </p><br><p>  Un estilo sin sentido le permite centrarse en el algoritmo básico e identificar características comunes en el código.  La función " <code>reduce</code> " utilizada anteriormente es un buen ejemplo.  Este tema se discutirá en una serie planificada sobre el procesamiento de listas. </p><br><p>  Por otro lado, el uso excesivo de tal estilo puede hacer que el código sea oscuro.  Los parámetros explícitos actúan como documentación y sus nombres (como "lista") facilitan la comprensión de lo que hace la función. </p><br><p>  Como todo en programación, la mejor recomendación es preferir el enfoque que brinde la mayor claridad. </p><br><h2>  Combinadores </h2><br><p>  Los " <strong>combinadores</strong> " se denominan funciones cuyo resultado depende solo de sus parámetros.  Esto significa que no hay dependencia del mundo exterior y, en particular, ninguna otra función o valor global puede afectarlos. </p><br><p>  En la práctica, esto significa que las funciones combinatorias están limitadas por una combinación de sus parámetros de varias maneras. </p><br><p>  Ya hemos visto varios combinadores: una tubería y un operador de composición.  Si observa sus definiciones, está claro que todo lo que hacen es reordenar los parámetros de varias maneras. </p><br><pre> <code class="plaintext hljs">let (|&gt;) xf = fx //  pipe let (&lt;|) fx = fx //  pipe let (&gt;&gt;) fgx = g (fx) //   let (&lt;&lt;) gfx = g (fx) //  </code> </pre> <br><p>  Por otro lado, funciones como "printf", aunque primitivas, no son combinadores porque dependen del mundo exterior (E / S). </p><br><h3>  Pájaros combinatorios </h3><br><p>  Los combinadores son la base de toda una sección de lógica (naturalmente llamada "lógica combinatoria"), que fue inventada muchos años antes que las computadoras y los lenguajes de programación.  La lógica combinatoria tiene una gran influencia en la programación funcional. </p><br><p>  Para obtener más información sobre los combinadores y la lógica combinatoria, recomiendo el libro de Raymond Smullyan "To Mock a Mockingbird".  En él, explica otros combinadores y les da fantasiosamente <a href="">nombres de pájaros</a> .  Estos son algunos ejemplos de combinadores estándar y sus nombres de aves: </p><br><pre> <code class="plaintext hljs">let I x = x //  ,  Idiot bird let K xy = x // the Kestrel let M x = x &gt;&gt; x // the Mockingbird let T xy = yx // the Thrush ( !) let Q xyz = y (xz) // the Queer bird ( !) let S xyz = xz (yz) // The Starling //   ... let rec Y fx = f (Y f) x // Y-,  Sage bird</code> </pre> <br><p>  Los nombres de las letras son bastante estándar, por lo que puede referirse al combinador K a cualquiera que esté familiarizado con esta terminología. </p><br><p>  Resulta que muchos patrones de programación comunes se pueden representar a través de estos combinadores estándar.  Por ejemplo, Kestrel es un patrón regular en la interfaz fluida donde haces algo pero devuelves el objeto original.  Thrush es una tubería, Queer es una composición directa, y el combinador en Y hace un excelente trabajo al crear funciones recursivas. </p><br><p>  De hecho, existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">teorema bien conocido de</a> que cualquier función computable puede construirse utilizando solo dos combinadores básicos, Kestrel y Starling. </p><br><h3>  Bibliotecas combinatorias </h3><br><p>  Las bibliotecas combinatorias son bibliotecas que exportan muchas funciones combinatorias que están diseñadas para ser compartidas.  Un usuario de dicha biblioteca puede combinar fácilmente funciones para obtener funciones aún más grandes y complejas, como los cubos fácilmente. </p><br><p>  Una biblioteca combinada bien diseñada le permite centrarse en funciones de alto nivel y ocultar el "ruido" de bajo nivel.  Ya hemos visto su poder en varios ejemplos en la serie "por qué usar F #", y el módulo <code>List</code> está lleno de tales funciones, " <code>fold</code> " y " <code>map</code> " también son combinadores si lo piensas. </p><br><p>  Otra ventaja de los combinadores es que son el tipo de función más seguro.  Porque  no tienen dependencias del mundo exterior, no pueden cambiar cuando cambia el entorno global.  Una función que lee un valor global o usa funciones de biblioteca puede romperse o cambiar entre llamadas si el contexto cambia.  Esto nunca le sucederá a los combinadores. </p><br><p>  En F #, las bibliotecas de combinador están disponibles para analizar (FParsec), crear HTML, probar marcos, etc.  Discutiremos y usaremos combinadores más adelante en la próxima serie. </p><br><h2>  Funciones recursivas </h2><br><p>  A menudo, una función necesita referirse a sí misma desde su cuerpo.  Un ejemplo clásico es la función de Fibonacci. </p><br><pre> <code class="plaintext hljs">let fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Desafortunadamente, esta función no podrá compilar: </p><br><pre> <code class="plaintext hljs">error FS0039: The value or constructor 'fib' is not defined</code> </pre> <br><p>  Debe decirle al compilador que esta es una función recursiva que utiliza la palabra clave <code>rec</code> . </p><br><pre> <code class="plaintext hljs">let rec fib i = match i with | 1 -&gt; 1 | 2 -&gt; 1 | n -&gt; fib(n-1) + fib(n-2)</code> </pre> <br><p>  Las funciones recursivas y las estructuras de datos son muy comunes en la programación funcional, y espero dedicar una serie completa a este tema más adelante. </p><br><h1>  Recursos Adicionales </h1><br><p>  Hay muchos tutoriales para F #, incluidos los materiales para aquellos que vienen con experiencia en C # o Java.  Los siguientes enlaces pueden ser útiles a medida que profundiza en F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # por diversión y ganancias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprenda X en minutos Y: F #</a> </li></ul><br><p>  También se describen varias otras formas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de comenzar a aprender F #</a> . </p><br><p>  Finalmente, la comunidad F # es muy amigable para principiantes.  Hay un chat muy activo en Slack, respaldado por la F # Software Foundation, con salas para principiantes a las que puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unirte libremente</a> .  ¡Recomendamos encarecidamente que haga esto! </p><br><p>  ¡No te olvides de visitar el sitio de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de habla rusa F #</a> !  Si tiene alguna pregunta sobre el aprendizaje de un idioma, estaremos encantados de discutirlo en las salas de chat: </p><br><ul><li>  room <code>#ru_general</code> en el <code>#ru_general</code> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en gitter</a> </li><li>  room #en_general en el chat flojo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  Sobre autores de traducción </h2><br><p>  Traducido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  La traducción y los cambios editoriales fueron realizados por los esfuerzos de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de desarrolladores de F # de habla rusa</a> .  También agradecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@schvepsss</em></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@shwars</em></a> por preparar este artículo para su publicación. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433398/">https://habr.com/ru/post/es433398/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433386/index.html">Cómo usar una visión por computadora para evaluar la condición del automóvil. Vive Yandex.Taxi</a></li>
<li><a href="../es433388/index.html">Fanático de la fórmula o por qué jugamos juegos</a></li>
<li><a href="../es433390/index.html">Yandex se unió a la protección de Linux y la industria de TI del trolling de patentes</a></li>
<li><a href="../es433392/index.html">Revisión del teléfono Snom D725 IP</a></li>
<li><a href="../es433396/index.html">Frontend 2018: resultados del año</a></li>
<li><a href="../es433400/index.html">Tutorial React Parte 2: Componentes funcionales</a></li>
<li><a href="../es433402/index.html">Pensamiento funcional Parte 8</a></li>
<li><a href="../es433404/index.html">Tutorial React Parte 3: Archivos de componentes, estructura del proyecto</a></li>
<li><a href="../es433406/index.html">Pensamiento funcional Parte 9</a></li>
<li><a href="../es433408/index.html">Manejo eficiente de la memoria en Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>