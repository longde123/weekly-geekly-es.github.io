<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèø‚Äçü§ù‚Äçüßëüèø üï∏Ô∏è üç† Spring Cache: Vom Verbindungs-Caching in 1 Minute bis zur flexiblen Konfiguration des Cache-Managers ü§û üíä üì¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fr√ºher hatte ich Angst vor dem Caching. Ich wollte wirklich nicht klettern und herausfinden, was es war, ich stellte mir sofort einige Dinge im Motorr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Cache: Vom Verbindungs-Caching in 1 Minute bis zur flexiblen Konfiguration des Cache-Managers</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465667/"> Fr√ºher hatte ich Angst vor dem Caching.  Ich wollte wirklich nicht klettern und herausfinden, was es war, ich stellte mir sofort einige Dinge im Motorraum vor, die nur der Gewinner der Mathematikolympiade herausfinden konnte.  Es stellte sich heraus, dass dies nicht so ist.  Das Caching erwies sich als sehr einfach, verst√§ndlich und unglaublich einfach in jedem Projekt zu implementieren. <br><br><img src="https://habrastorage.org/webt/1f/my/g2/1fmyg2ofjbgqmyf3lorqqkan85u.jpeg"><br><br>  In diesem Beitrag werde ich versuchen, das Caching so einfach zu erkl√§ren, wie ich es jetzt verstehe.  Sie erfahren, wie Sie das Caching in 1 Minute implementieren, wie Sie nach Schl√ºssel zwischenspeichern, die Cache-Lebensdauer festlegen und viele andere Dinge, die Sie wissen m√ºssen, wenn Sie angewiesen wurden, etwas in Ihrem Arbeitsprojekt zwischenzuspeichern, und Sie m√∂chten nicht schmutzig werden Gesicht. <br><a name="habracut"></a><br>  Warum sage ich "anvertraut"?  Da Caching in der Regel sinnvoll ist, ist es sinnvoll, es in gro√üen, hoch ausgelasteten Projekten mit Zehntausenden von Anforderungen pro Minute anzuwenden.  In solchen Projekten werden normalerweise Repository-Aufrufe zwischengespeichert, um die Datenbank nicht zu √ºberlasten.  Insbesondere wenn bekannt ist, dass die Daten eines Mastersystems mit einer bestimmten H√§ufigkeit aktualisiert werden.  Wir selbst schreiben solche Projekte nicht, wir arbeiten daran.  Wenn das Projekt klein ist und keine √úberlastung droht, ist es nat√ºrlich besser, nichts zwischenzuspeichern - immer frische Daten sind immer besser als regelm√§√üig aktualisierte. <br><br>  Normalerweise kriecht der Sprecher in den Schulungsbeitr√§gen zuerst unter die Motorhaube, beginnt, sich in die Eingeweide der Technologie zu vertiefen, was den Leser sehr st√∂rt, und erst dann, wenn er die gute H√§lfte des Artikels durchbl√§ttert und nichts verstanden hat, wird erkl√§rt, wie es funktioniert.  Bei uns wird alles anders sein.  Zuerst sorgen wir daf√ºr, dass es funktioniert, und vorzugsweise mit geringstem Aufwand. Erst dann k√∂nnen Sie, wenn Sie interessiert sind, unter die Cache-Haube schauen, in den Bin selbst schauen und das Caching optimieren.  Aber selbst wenn Sie dies nicht tun (und dies beginnt mit Punkt 6), funktioniert Ihr Caching so. <br><br>  Wir werden ein Projekt erstellen, in dem wir alle Aspekte des Caching analysieren, die ich versprochen habe.  Am Ende wird wie gewohnt ein Link zum Projekt selbst vorhanden sein. <br><br><h2>  0. Ein Projekt erstellen </h2><br>  Wir werden ein sehr einfaches Projekt erstellen, in dem wir die Entit√§t aus der Datenbank entnehmen k√∂nnen.  Ich habe dem Projekt Lombok, Spring Cache, Spring Data JPA und H2 hinzugef√ºgt.  Es kann jedoch nur auf Spring Cache verzichtet werden. <br><br><pre><code class="java hljs">plugins { id <span class="hljs-string"><span class="hljs-string">'org.springframework.boot'</span></span> version <span class="hljs-string"><span class="hljs-string">'2.1.7.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'io.spring.dependency-management'</span></span> version <span class="hljs-string"><span class="hljs-string">'1.0.8.RELEASE'</span></span> id <span class="hljs-string"><span class="hljs-string">'java'</span></span> } group = <span class="hljs-string"><span class="hljs-string">'ru.xpendence'</span></span> version = <span class="hljs-string"><span class="hljs-string">'0.0.1-SNAPSHOT'</span></span> sourceCompatibility = <span class="hljs-string"><span class="hljs-string">'1.8'</span></span> configurations { compileOnly { extendsFrom annotationProcessor } } repositories { mavenCentral() } dependencies { implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-cache'</span></span> implementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-data-jpa'</span></span> compileOnly <span class="hljs-string"><span class="hljs-string">'org.projectlombok:lombok'</span></span> runtimeOnly <span class="hljs-string"><span class="hljs-string">'com.h2database:h2'</span></span> annotationProcessor <span class="hljs-string"><span class="hljs-string">'org.projectlombok:lombok'</span></span> testImplementation <span class="hljs-string"><span class="hljs-string">'org.springframework.boot:spring-boot-starter-test'</span></span> }</code> </pre> <br>  Wir werden nur eine Entit√§t haben, nennen wir es Benutzer. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Data</span></span> <span class="hljs-meta"><span class="hljs-meta">@NoArgsConstructor</span></span> <span class="hljs-meta"><span class="hljs-meta">@ToString</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = GenerationType.IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"name"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"email"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String email; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">User</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String email)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.email = email; } }</code> </pre> <br>  F√ºgen Sie das Repository und den Service hinzu: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Long</span></span></span><span class="hljs-class">&gt; </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserServiceImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> UserRepository repository; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserServiceImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserRepository repository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository = repository; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(user); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"getting user by id: {}"</span></span>, id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findById(id) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntityNotFoundException(<span class="hljs-string"><span class="hljs-string">"User not found by id "</span></span> + id)); } }</code> </pre> <br>  Wenn wir die Dienstmethode get () eingeben, schreiben wir dar√ºber in das Protokoll. <br><br>  Stellen Sie eine Verbindung zum Spring Cache-Projekt her. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableCaching</span></span> <span class="hljs-comment"><span class="hljs-comment">// Spring Cache public class CacheApplication { public static void main(String[] args) { SpringApplication.run(CacheApplication.class, args); } }</span></span></code> </pre> <br>  Das Projekt ist fertig. <br><br><h2>  1. Zwischenspeichern des R√ºckgabeergebnisses </h2><br>  Was macht Spring Cache?  Spring Cache speichert einfach das R√ºckgabeergebnis f√ºr bestimmte Eingabeparameter zwischen.  Lass es uns √ºberpr√ºfen.  Wir werden die Annotation @Cacheable √ºber die Dienstmethode get () setzen, um die zur√ºckgegebenen Daten zwischenzuspeichern.  Wir geben dieser Anmerkung den Namen "Benutzer" (wir werden weiter analysieren, warum dies separat erfolgt). <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(<span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"getting user by id: {}"</span></span>, id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findById(id) .orElseThrow(() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EntityNotFoundException(<span class="hljs-string"><span class="hljs-string">"User not found by id "</span></span> + id)); }</code> </pre> <br>  Um zu √ºberpr√ºfen, wie dies funktioniert, schreiben wir einen einfachen Test. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(SpringRunner.class) <span class="hljs-meta"><span class="hljs-meta">@SpringBootTest</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractTest</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserServiceTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UserService service; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ User user1 = service.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); User user2 = service.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Kolya"</span></span>, <span class="hljs-string"><span class="hljs-string">"kolya@mail.ru"</span></span>)); getAndPrint(user1.getId()); getAndPrint(user2.getId()); getAndPrint(user1.getId()); getAndPrint(user2.getId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAndPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"user found: {}"</span></span>, service.get(id)); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ein kleiner Exkurs, warum ich normalerweise AbstractTest schreibe und alle Tests davon erbe.</b> <div class="spoiler_text">  Wenn die Klasse √ºber eine eigene @ SpringBootTest-Annotation verf√ºgt, wird der Kontext f√ºr eine solche Klasse jedes Mal neu ausgel√∂st.  Da der Kontext 5 Sekunden oder vielleicht 40 Sekunden lang ansteigen kann, wird der Testprozess in jedem Fall stark behindert.  Gleichzeitig gibt es normalerweise keinen Unterschied im Kontext, und wenn Sie jede Gruppe von Tests innerhalb derselben Klasse ausf√ºhren, muss der Kontext nicht neu gestartet werden.  Wenn wir wie in unserem Fall nur eine Anmerkung √ºber eine abstrakte Klasse setzen, k√∂nnen wir den Kontext nur einmal erh√∂hen. <br><br>  Daher ziehe ich es vor, die Anzahl der w√§hrend des Testens / Zusammenbaus aufgeworfenen Kontexte nach M√∂glichkeit zu reduzieren. <br></div></div><br>  Was macht unser Test?  Er erstellt zwei Benutzer und zieht sie dann zweimal aus der Datenbank.  Wie wir uns erinnern, setzen wir die Annotation @Cacheable ein, die die zur√ºckgegebenen Werte zwischenspeichert.  Nach dem Empfang des Objekts von der Methode get () geben wir das Objekt in das Protokoll aus.  Au√üerdem protokollieren wir Informationen zu jedem Besuch der Anwendung in der Methode get (). <br><br>  F√ºhren Sie den Test aus.  Das bekommen wir in der Konsole. <br><br><pre> <code class="java hljs">getting user by id: <span class="hljs-number"><span class="hljs-number">1</span></span> user found: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> user found: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Kolya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) user found: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) user found: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Kolya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru)</code> </pre> <br>  Wie wir sehen, sind wir die ersten beiden Male wirklich zur get () -Methode gegangen und haben den Benutzer tats√§chlich aus der Datenbank abgerufen.  In allen anderen F√§llen gab es keinen wirklichen Aufruf der Methode, die Anwendung nahm zwischengespeicherte Daten per Schl√ºssel (in diesem Fall ist dies die ID). <br><br><h2>  2. Caching-Schl√ºsseldeklaration </h2><br>  Es gibt Situationen, in denen mehrere Parameter zur zwischengespeicherten Methode kommen.  In diesem Fall kann es erforderlich sein, den Parameter zu bestimmen, anhand dessen das Caching erfolgt.  Wir f√ºgen einer Methode ein Beispiel hinzu, mit der eine durch Parameter zusammengestellte Entit√§t in der Datenbank gespeichert wird. Wenn jedoch bereits eine Entit√§t mit demselben Namen vorhanden ist, wird sie nicht gespeichert.  Dazu definieren wir den Parameter name als Schl√ºssel f√ºr das Caching.  Es wird so aussehen: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(value = <span class="hljs-string"><span class="hljs-string">"users"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#name"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String email)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"creating user with parameters: {}, {}"</span></span>, name, email); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(name, email)); }</code> </pre> <br>  Schreiben wir den entsprechenden Test: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>); createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan1122@mail.ru"</span></span>); createAndPrint(<span class="hljs-string"><span class="hljs-string">"Sergey"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>); log.info(<span class="hljs-string"><span class="hljs-string">"all entries are below:"</span></span>); service.getAll().forEach(u -&gt; log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, u.toString())); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndPrint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, String email)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"created user: {}"</span></span>, service.create(name, email)); }</code> </pre> <br>  Wir werden versuchen, drei Benutzer zu erstellen, f√ºr zwei ist der Name gleich <br><br><pre> <code class="java hljs"> createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>); createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan1122@mail.ru"</span></span>);</code> </pre> <br>  und f√ºr zwei davon wird die E-Mail √ºbereinstimmen <br><br><pre> <code class="java hljs"> createAndPrint(<span class="hljs-string"><span class="hljs-string">"Ivan"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>); createAndPrint(<span class="hljs-string"><span class="hljs-string">"Sergey"</span></span>, <span class="hljs-string"><span class="hljs-string">"ivan@mail.ru"</span></span>);</code> </pre> <br>  In der Erstellungsmethode protokollieren wir jede Tatsache, dass die Methode aufgerufen wird, und protokollieren au√üerdem alle Entit√§ten, die diese Methode an uns zur√ºckgegeben hat.  Das Ergebnis wird folgenderma√üen aussehen: <br><br><pre> <code class="java hljs">creating user with parameters: Ivan, ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru created user: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Ivan, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Ivan, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) creating user with parameters: Sergey, ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru created user: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Sergey, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) all entries are below: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Ivan, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Sergey, email=ivan<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru)</code> </pre> <br>  Wir sehen, dass die Anwendung die Methode tats√§chlich dreimal aufgerufen hat und nur zweimal darauf eingegangen ist.  Sobald ein Schl√ºssel mit einer Methode √ºbereinstimmte und einfach einen zwischengespeicherten Wert zur√ºckgab. <br><br><h2>  3. Erzwungenes Caching.  @CachePut </h2><br>  Es gibt Situationen, in denen wir den R√ºckgabewert f√ºr eine Entit√§t zwischenspeichern m√∂chten, gleichzeitig aber den Cache aktualisieren m√ºssen.  F√ºr solche Anforderungen ist die Annotation @CachePut vorhanden.  Die Anwendung wird an die Methode √ºbergeben, w√§hrend der Cache f√ºr den R√ºckgabewert aktualisiert wird, auch wenn er bereits zwischengespeichert ist. <br><br>  F√ºgen Sie einige Methoden hinzu, mit denen wir den Benutzer speichern.  Wir werden einen von ihnen mit der √ºblichen @ Cache-f√§higen Annotation markieren, den zweiten mit @ CachePut. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(value = <span class="hljs-string"><span class="hljs-string">"users"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#user.name"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createOrReturnCached</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"creating user: {}"</span></span>, user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(user); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@CachePut</span></span>(value = <span class="hljs-string"><span class="hljs-string">"users"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#user.name"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndRefreshCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"creating user: {}"</span></span>, user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.save(user); }</code> </pre> <br>  Die erste Methode gibt einfach die zwischengespeicherten Werte zur√ºck, die zweite erzwingt die Aktualisierung des Caches.  Das Caching wird mit dem Schl√ºssel # user.name durchgef√ºhrt.  Wir werden den entsprechenden Test schreiben. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAndRefresh</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ User user1 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"created user1: {}"</span></span>, user1); User user2 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"misha@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"created user2: {}"</span></span>, user2); User user3 = service.createAndRefreshCache(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"kolya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"created user3: {}"</span></span>, user3); User user4 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"petya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"created user4: {}"</span></span>, user4); }</code> </pre> <br>  Gem√§√ü der bereits beschriebenen Logik erhalten wir beim ersten Speichern eines Benutzers mit dem Namen ‚ÄûVasya‚Äú √ºber die Methode createOrReturnCached () eine zwischengespeicherte Entit√§t, und die Anwendung gibt die Methode selbst nicht ein.  Wenn wir die Methode createAndRefreshCache () aufrufen, wird die zwischengespeicherte Entit√§t f√ºr den Schl√ºssel mit dem Namen "Vasya" im Cache √ºberschrieben.  Lassen Sie uns den Test ausf√ºhren und sehen, was in der Konsole angezeigt wird. <br><br><pre> <code class="java hljs">creating user: User(id=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user1: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user2: User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) creating user: User(id=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name=Vasya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user3: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Vasya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) created user4: User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Vasya, email=kolya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru)</code> </pre> <br>  Wir sehen, dass Benutzer1 erfolgreich in die Datenbank und den Cache geschrieben hat.  Wenn wir versuchen, den Benutzer mit demselben Namen erneut aufzuzeichnen, erhalten wir das zwischengespeicherte Ergebnis des ersten Aufrufs (Benutzer2, f√ºr den die ID mit Benutzer1 identisch ist, was besagt, dass der Benutzer nicht geschrieben wurde und dies nur ein Cache ist).  Als n√§chstes schreiben wir den dritten Benutzer √ºber die zweite Methode, die trotz des zwischengespeicherten Ergebnisses immer noch die Methode aufruft und ein neues Ergebnis in den Cache schreibt.  Dies ist user3.  Wie wir sehen k√∂nnen, hat er bereits eine neue ID.  Danach rufen wir die erste Methode auf, die den von Benutzer3 hinzugef√ºgten neuen Cache verwendet. <br><br><h2>  4. Entfernen aus dem Cache.  @CacheEvict </h2><br>  Manchmal ist es notwendig, einige Daten im Cache hart zu aktualisieren.  Beispielsweise wurde eine Entit√§t bereits aus der Datenbank gel√∂scht, auf sie kann jedoch weiterhin √ºber den Cache zugegriffen werden.  Um die Datenkonsistenz zu gew√§hrleisten, m√ºssen gel√∂schte Daten zumindest nicht im Cache gespeichert werden. <br><br>  F√ºgen Sie dem Service einige weitere Methoden hinzu. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"deleting user by id: {}"</span></span>, id); repository.deleteById(id); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAndEvict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"deleting user by id: {}"</span></span>, id); repository.deleteById(id); }</code> </pre> <br>  Der erste l√∂scht den Benutzer einfach, der zweite l√∂scht ihn ebenfalls, aber wir markieren ihn mit der Annotation @CacheEvict.  F√ºgen Sie einen Test hinzu, der zwei Benutzer erstellt. Danach wird einer durch eine einfache Methode und der zweite durch eine mit Anmerkungen versehene Methode gel√∂scht.  Danach werden wir diese Benutzer durch die get () -Methode erhalten. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ User user1 = service.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user1.getId())); User user2 = service.create(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user2.getId())); service.delete(user1.getId()); service.deleteAndEvict(user2.getId()); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user1.getId())); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user2.getId())); }</code> </pre> <br>  Es ist logisch, dass das Entfernen, da unser Benutzer bereits zwischengespeichert ist, das Entfernen nicht daran hindert, es zu erhalten, da es zwischengespeichert ist.  Sehen wir uns die Protokolle an. <br><br><pre> <code class="java hljs">getting user by id: <span class="hljs-number"><span class="hljs-number">1</span></span> User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) deleting user by id: <span class="hljs-number"><span class="hljs-number">1</span></span> deleting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> javax.persistence.EntityNotFoundException: User not found by id <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Wir sehen, dass die Anwendung beide Male sicher zur get () -Methode gegangen ist und Spring diese Entit√§ten zwischengespeichert hat.  Als n√§chstes haben wir sie mit verschiedenen Methoden gel√∂scht.  Wir haben den ersten auf die √ºbliche Weise gel√∂scht, und der zwischengespeicherte Wert blieb erhalten. Als wir versuchten, den Benutzer unter ID 1 zu bringen, war dies erfolgreich.  Als wir versuchten, Benutzer 2 abzurufen, gab die Methode eine EntityNotFoundException zur√ºck - es befand sich kein solcher Benutzer im Cache. <br><br><h2>  5. Gruppierungseinstellungen.  @Caching </h2><br>  Manchmal erfordert eine einzelne Methode mehrere Caching-Einstellungen.  Die Annotation @Caching wird f√ºr diese Zwecke verwendet.  Es k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Caching</span></span>( cacheable = { <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(<span class="hljs-string"><span class="hljs-string">"users"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@Cacheable</span></span>(<span class="hljs-string"><span class="hljs-string">"contacts"</span></span>) }, put = { <span class="hljs-meta"><span class="hljs-meta">@CachePut</span></span>(<span class="hljs-string"><span class="hljs-string">"tables"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@CachePut</span></span>(<span class="hljs-string"><span class="hljs-string">"chairs"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@CachePut</span></span>(value = <span class="hljs-string"><span class="hljs-string">"meals"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#user.email"</span></span>) }, evict = { <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(value = <span class="hljs-string"><span class="hljs-string">"services"</span></span>, key = <span class="hljs-string"><span class="hljs-string">"#user.name"</span></span>) } ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheExample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Dies ist die einzige M√∂glichkeit, Anmerkungen zu gruppieren.  Wenn Sie versuchen, so etwas zu stapeln <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"users"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"meals"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"contacts"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@CacheEvict</span></span>(<span class="hljs-string"><span class="hljs-string">"tables"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheExample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(User user)</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  dann wird IDEA Ihnen sagen, dass dies nicht der Fall ist. <br><br><h2>  6. Flexible Konfiguration.  Cachemanager </h2><br>  Schlie√ülich haben wir den Cache herausgefunden und er war f√ºr uns nicht mehr unverst√§ndlich und be√§ngstigend.  Lassen Sie uns nun unter die Haube schauen und sehen, wie wir das Caching im Allgemeinen konfigurieren k√∂nnen. <br><br>  F√ºr solche Aufgaben gibt es einen CacheManager.  Es existiert √ºberall dort, wo Spring Cache ist.  Wenn wir die Annotation @EnableCache hinzugef√ºgt haben, wird ein solcher Cache-Manager von Spring automatisch erstellt.  Wir k√∂nnen dies √ºberpr√ºfen, wenn wir den ApplicationContext automatisch umbrechen und am Haltepunkt √∂ffnen.  Unter anderem wird es eine cacheManager-Bean geben. <br><br><img src="https://habrastorage.org/webt/nc/bn/vp/ncbnvpwm57vw-2i9t7xpaiwr29s.png"><br><br>  Ich habe die Anwendung zu dem Zeitpunkt gestoppt, als bereits zwei Benutzer erstellt und in den Cache gestellt wurden.  Wenn wir die Bean, die wir ben√∂tigen, √ºber Evaluate Expression aufrufen, werden wir feststellen, dass es wirklich eine solche Bean gibt. Sie hat einen ConcurentMapCache mit dem Schl√ºssel "users" und dem Wert ConcurrentHashMap, der bereits zwischengespeicherte Benutzer enth√§lt. <br><br><img src="https://habrastorage.org/webt/7-/xt/s9/7-xts9jrjipidhtsls1nv4gr2o0.png"><br><br>  Wir k√∂nnen wiederum unseren Cache-Manager mit Habr und Programmierern erstellen und ihn dann nach unserem Geschmack optimieren. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"habrCacheManager"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CacheManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Es bleibt nur zu entscheiden, welchen Cache-Manager wir verwenden, da es viele davon gibt.  Ich werde nicht alle Cache-Manager auflisten, es wird ausreichen zu wissen, dass es solche gibt: <br><br><ul><li>  <i><b>SimpleCacheManager</b></i> ist der einfachste Cache-Manager, der zum Lernen und Testen <i><b>geeignet</b></i> ist. </li><li>  <i><b>ConcurrentMapCacheManager</b></i> - Initialisiert zur√ºckgegebene Instanzen f√ºr jede Anforderung tr√§ge.  Es wird auch zum Testen und Erlernen der Arbeit mit dem Cache sowie f√ºr einige einfache Aktionen wie unsere empfohlen.  F√ºr ernsthafte Arbeiten mit dem Cache wird die folgende Implementierung empfohlen. </li><li>  <i><b>JCacheCacheManager</b></i> , <i><b>EhCacheCacheManager</b></i> und <i><b>CaffeineCacheManager</b></i> sind seri√∂se <i><b>partnerbasierte</b></i> Cache-Manager, die flexibel anpassbar sind und Aufgaben mit einer Vielzahl von Aktionen ausf√ºhren. </li></ul><br>  Als Teil meines bescheidenen Beitrags werde ich die Cache-Manager der letzten drei nicht beschreiben.  Stattdessen werden verschiedene Aspekte des Einrichtens eines Cache-Managers am Beispiel des ConcurrentMapCacheManager betrachtet. <br><br>  Erstellen wir also unseren Cache-Manager neu. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"habrCacheManager"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CacheManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentMapCacheManager(); }</code> </pre> <br>  Unser Cache-Manager ist bereit. <br><br><h2>  7. Cache-Setup.  Lebensdauer, maximale Gr√∂√üe und so weiter. </h2><br>  Dazu ben√∂tigen wir eine recht beliebte Google Guava-Bibliothek.  Ich habe den letzten genommen. <br><br><pre> <code class="java hljs">compile group: <span class="hljs-string"><span class="hljs-string">'com.google.guava'</span></span>, name: <span class="hljs-string"><span class="hljs-string">'guava'</span></span>, version: <span class="hljs-string"><span class="hljs-string">'28.1-jre'</span></span></code> </pre> <br>  Beim Erstellen des Cache-Managers definieren wir die Methode createConcurrentMapCache neu, in der wir CacheBuilder von Guava aus aufrufen.  Dabei werden wir aufgefordert, den Cache-Manager durch Initialisieren der folgenden Methoden zu konfigurieren: <br><br><ul><li>  MaximumSize - Die maximale Gr√∂√üe der Werte, die der Cache enthalten kann.  Mit diesem Parameter k√∂nnen Sie versuchen, einen Kompromiss zwischen der Auslastung der Datenbank und dem JVM-RAM zu finden. </li><li>  refreshAfterWrite - Zeit nach dem Schreiben des Werts in den Cache, nach der er automatisch aktualisiert wird. </li><li>  expireAfterAccess - die Lebensdauer des Werts nach dem letzten Aufruf. </li><li>  expireAfterWrite - Lebensdauer des Werts nach dem Schreiben in den Cache.  Dies ist der Parameter, den wir definieren werden. </li></ul><br>  und andere. <br><br>  Wir definieren im Manager die Lebensdauer des Datensatzes.  Um nicht lange zu warten, stellen Sie 1 Sekunde ein. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span>(<span class="hljs-string"><span class="hljs-string">"habrCacheManager"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> CacheManager </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cacheManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentMapCacheManager() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Cache </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createConcurrentMapCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentMapCache( name, CacheBuilder.newBuilder() .expireAfterWrite(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS) .build().asMap(), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }; }</code> </pre> <br>  Wir schreiben einen Test, der diesem Fall entspricht. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ User user1 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user1.getId())); User user2 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user2.getId())); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000L</span></span>); User user3 = service.createOrReturnCached(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(<span class="hljs-string"><span class="hljs-string">"Vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"vasya@mail.ru"</span></span>)); log.info(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, service.get(user3.getId())); }</code> </pre> <br>  Wir speichern mehrere Werte in der Datenbank, und wenn die Daten zwischengespeichert werden, speichern wir nichts.  Zuerst speichern wir zwei Werte, dann warten wir 1 Sekunde, bis der Cache leer ist. Danach speichern wir einen weiteren Wert. <br><br><pre> <code class="java hljs">creating user: User(id=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">1</span></span> User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) User(id=<span class="hljs-number"><span class="hljs-number">1</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) creating user: User(id=<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru) getting user by id: <span class="hljs-number"><span class="hljs-number">2</span></span> User(id=<span class="hljs-number"><span class="hljs-number">2</span></span>, name=Vasya, email=vasya<span class="hljs-meta"><span class="hljs-meta">@mail</span></span>.ru)</code> </pre> <br>  Protokolle zeigen, dass wir zuerst einen Benutzer erstellt und dann einen anderen ausprobiert haben. Da die Daten jedoch zwischengespeichert wurden, haben wir sie aus dem Cache abgerufen (in beiden F√§llen beim Speichern und beim Abrufen aus der Datenbank).  Dann wurde der Cache fehlerhaft, da ein Datensatz uns √ºber das tats√§chliche Speichern und den tats√§chlichen Empfang des Benutzers informiert. <br><br><h2>  8. Zusammenfassend </h2><br>  Fr√ºher oder sp√§ter muss der Entwickler das Caching im Projekt implementieren.  Ich hoffe, dieser Artikel hilft Ihnen dabei, das Thema zu verstehen und Caching-Probleme k√ºhner zu betrachten. <br><br>  Github des Projekts hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/promoscow/cache</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de465667/">https://habr.com/ru/post/de465667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de465655/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 474 (13.08.2019 - 08.08.2019)</a></li>
<li><a href="../de465657/index.html">Parkinson-Gesetz: Sie k√∂nnen es schlagen</a></li>
<li><a href="../de465659/index.html">Antwort auf den Artikel ‚ÄûDie Eroberung Sibiriens durch die Moskauer‚Äú oder 20 Jahre sp√§ter</a></li>
<li><a href="../de465661/index.html">Hast du auch so einen Freund? Oder bist du es vielleicht?</a></li>
<li><a href="../de465663/index.html">Superjob API FAQ (Stellenausschreibung)</a></li>
<li><a href="../de465669/index.html">Z√§hlen der Download-Geschwindigkeit in Ihrer Anwendung</a></li>
<li><a href="../de465673/index.html">Hedi Lamarr: Erfinder aus Hollywood</a></li>
<li><a href="../de465675/index.html">Wie sich die NASA um die Sicherheit und Intelligenz ihrer Astronauten k√ºmmert</a></li>
<li><a href="../de465677/index.html">Vergessen Sie den Walkman: Es geht nur um die Kopfh√∂rer</a></li>
<li><a href="../de465679/index.html">Was kann eine Uhr neben der Zeitanzeige tun und wie w√§hlt man die erste Uhr aus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>