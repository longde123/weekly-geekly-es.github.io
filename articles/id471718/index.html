<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛌 🏯 💪 SSEGWSW: Server-Terkirim Acara Gateway oleh Pekerja Layanan 🧙🏾 🎌 🚪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai 

 Nama saya Sasha dan saya bekerja sebagai arsitek di Tinkoff Business. 

 Pada artikel ini saya ingin berbicara tentang cara mengatasi batas bro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SSEGWSW: Server-Terkirim Acara Gateway oleh Pekerja Layanan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/471718/">  Hai <br><br>  Nama saya Sasha dan saya bekerja sebagai arsitek di Tinkoff Business. <br><br>  Pada artikel ini saya ingin berbicara tentang cara mengatasi batas browser pada jumlah koneksi HTTP yang berumur panjang dalam domain yang sama menggunakan pekerja layanan. <br><br>  Jika Anda mau, silakan lewati latar belakang, uraian masalah, cari solusi, dan segera lanjutkan ke hasilnya. <br><br><img src="https://habrastorage.org/webt/y0/bo/yc/y0boycn5hjiaplzub_5g7rviwpu.png" alt="SSEGWSW"><br><a name="habracut"></a><br><h3>  Latar belakang </h3><br>  Sekali waktu di Tinkoff Business ada obrolan yang berhasil di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Websocket</a> . <br><br>  Setelah beberapa waktu, ia tidak lagi cocok dengan desain akun pribadinya, dan secara umum ia sudah lama meminta penulisan ulang dari sudut 1,6 ke sudut 2+.  Saya memutuskan bahwa sudah waktunya untuk mulai memperbaruinya.  Seorang kolega-pendukung menemukan bahwa frontend obrolan akan berubah, dan menyarankan pada saat yang sama mengulang API, khususnya - mengubah transportasi dari websocket ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSE (peristiwa yang dikirim server)</a> .  Dia menyarankan ini karena ketika memperbarui konfigurasi NGINX semua koneksi terputus, yang kemudian menyakitkan untuk dipulihkan. <br><br>  Kami membahas arsitektur solusi baru dan sampai pada kesimpulan bahwa kami akan menerima dan mengirim data menggunakan permintaan HTTP biasa.  Misalnya, kirim pesan <i>POST: / api / kirim-pesan</i> , dapatkan daftar dialog <i>GET: / api / daftar percakapan,</i> dan sebagainya.  Dan peristiwa tak sinkron seperti "pesan baru dari teman bicara" akan dikirim melalui SSE.  Jadi kami akan meningkatkan toleransi kesalahan aplikasi: jika koneksi SSE terputus, obrolan akan tetap berfungsi, hanya saja ia tidak akan menerima notifikasi waktu nyata. <br><br>  Selain obrolan di websocket, kami mengejar acara untuk komponen "pemberitahuan tipis".  Komponen ini memungkinkan Anda untuk mengirim berbagai pemberitahuan ke akun pribadi pengguna, misalnya, bahwa impor akun, yang mungkin memakan waktu beberapa menit, telah berhasil diselesaikan.  Untuk sepenuhnya meninggalkan websocket, kami memindahkan komponen ini ke koneksi SSE yang terpisah. <br><br><h3>  Masalah </h3><br>  Ketika Anda membuka satu tab browser, dua koneksi SSE dibuat: satu untuk obrolan dan satu untuk pemberitahuan halus.  Baiklah, biarkan mereka diciptakan.  Maaf atau apa?  Kami tidak merasa menyesal, tetapi browser merasa menyesal!  Mereka memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">batasan jumlah koneksi persisten bersamaan untuk suatu domain</a> .  Coba tebak berapa banyak di Chrome?  Benar enam!  Saya membuka tiga tab - Saya mencetak seluruh kumpulan koneksi dan Anda tidak bisa lagi membuat permintaan HTTP.  Ini berlaku untuk protokol HTTP / 1.x.  Dalam HTTP / 2 tidak ada masalah seperti itu karena multiplexing. <br><br>  Ada beberapa cara untuk mengatasi masalah ini di tingkat infrastruktur: <br><br><ol><li>  <a href="">Pecahan domain.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://developers.google.com/web/fundamentals/performance/">HTTP / 2.</a> </li></ol><br>  Kedua metode ini tampaknya mahal, karena banyak infrastruktur yang harus terkena dampak. <br><br>  Karenanya, sebagai permulaan, kami mencoba menyelesaikan masalah di sisi browser.  Gagasan pertama adalah membuat semacam transportasi antar tab, misalnya, melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LocalStorage</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Broadcast Channel API</a> . <br><br>  Artinya adalah ini: kita membuka koneksi SSE hanya dalam satu tab dan mengirim data ke yang lain.  Solusi ini juga tidak terlihat optimal, karena akan membutuhkan pelepasan seluruh 50 SPA, yang merupakan akun pribadi Tinkoff Business.  Melepaskan 50 aplikasi juga mahal, jadi saya terus mencari cara lain. <br><br><h3>  Solusi </h3><br>  Saya baru-baru ini bekerja dengan pekerja layanan dan berpikir: apakah mungkin menerapkannya dalam situasi ini? <br><br>  Untuk menjawab pertanyaan ini, Anda harus terlebih dahulu memahami apa yang biasanya dilakukan oleh pekerja layanan?  Mereka dapat mem-proxy permintaan, tampilannya seperti ini: <br><br><pre><code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = self.caches.open(<span class="hljs-string"><span class="hljs-string">'example'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">caches</span></span></span><span class="hljs-function"> =&gt;</span></span> caches.match(event.request)) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> response || fetch(event.request)); event.respondWith(response); });</code> </pre> <br>  Kami mendengarkan acara untuk permintaan HTTP dan merespons sesuka kami.  Dalam hal ini, kami mencoba merespons dari cache, dan jika tidak berhasil, maka kami membuat permintaan ke server. <br><br>  Oke, mari kita coba untuk mencegat koneksi SSE dan menjawabnya: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } event.respondWith(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>)); });</code> </pre><br>  Dalam permintaan jaringan, kita melihat gambar berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/101/629/3b8/1016293b8b2996a1a3e53478b69eaff6.png" alt="gambar"><br><br>  Dan di konsol, ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d3/22e/b05/1d322eb0533cf21a456790c4d9bef519.png" alt="gambar"><br><br>  Sudah tidak buruk.  Permintaan dicegat, tetapi SSE tidak menginginkan respons dalam bentuk <i>teks / polos</i> , tetapi menginginkan <i>teks / aliran acara</i> .  Bagaimana cara membuat streaming sekarang?  Tetapi bisakah saya bahkan merespons dengan aliran dari pekerja layanan?  Baiklah mari kita lihat: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ab8/c87/efd/ab8c87efd887d4693c2d6d9cddd986ee.png" alt="gambar"><br><br>  Hebat!  Kelas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Respons</a> diambil sebagai body <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReadableStream</a> .  Setelah membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , Anda dapat mengetahui bahwa <i>ReadableStream</i> memiliki pengontrol yang memiliki metode <i>enqueue ()</i> - dengan bantuannya Anda dapat mengalirkan data.  Cocok, bawa! <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseText = <span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseData = <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>.from(responseText, x =&gt; x.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableStream({<span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function"> =&gt;</span></span> controller.enqueue(responseData)}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(stream); event.respondWith(response); });</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/40b/35b/6a3/40b35b6a369d02e804e34c2179c0f273.png" alt="gambar"><br><br>  Tidak ada kesalahan, koneksi hang dalam status pending dan tidak ada data tiba di sisi klien.  Membandingkan permintaan saya dengan permintaan server nyata, saya menyadari bahwa jawabannya ada di header.  Untuk permintaan SSE, tajuk berikut harus ditentukan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseHeaders = { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>, <span class="hljs-string"><span class="hljs-string">'Transfer-Encoding'</span></span>: <span class="hljs-string"><span class="hljs-string">'chunked'</span></span>, <span class="hljs-string"><span class="hljs-string">'Connection'</span></span>: <span class="hljs-string"><span class="hljs-string">'keep-alive'</span></span>, };</code> </pre><br>  Ketika Anda menambahkan header ini, koneksi akan terbuka dengan sukses, tetapi data tidak akan diterima di sisi klien.  Ini jelas, karena Anda tidak bisa hanya mengirim teks acak - pasti ada beberapa format. <br><br>  Di javascript.info, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format data</a> di mana Anda ingin mengirim data dari server <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan dengan baik</a> .  Dapat dengan mudah dijelaskan dengan satu fungsi: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseChunkData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data: string, event?: string, retry?: number, id?: number</span></span></span><span class="hljs-function">): </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({event, id, data, retry}) .filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> ![<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>].includes(value)) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>;</code> </pre><br>  Untuk mematuhi format SSE, server harus mengirim pesan yang dipisahkan oleh jeda baris ganda <i>\ n \ n</i> . <br><br>  Pesan terdiri dari bidang-bidang berikut: <br><br><ul><li>  <b>data</b> - badan pesan, beberapa data dalam satu baris ditafsirkan sebagai satu pesan, dipisahkan oleh jeda baris \ n; </li><li>  <b>id</b> - memperbarui properti lastEventId yang dikirim dalam header Last-Event-ID saat menghubungkan kembali; </li><li>  <b>coba lagi</b> - penundaan yang disarankan sebelum menghubungkan kembali dalam milidetik, tidak dapat diatur menggunakan JavaScript; </li><li>  <b>acara</b> - nama acara pengguna, ditunjukkan sebelum data. </li></ul><br>  Tambahkan tajuk yang diperlukan, ubah jawaban ke format yang diinginkan dan lihat apa yang terjadi: <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSSERequest) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseChunkData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data, event, retry, id</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries({event, id, data, retry}) .filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> ![<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>].includes(value)) .map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[key, value]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${key}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${value}</span></span></span><span class="hljs-string">`</span></span>) .join(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) + <span class="hljs-string"><span class="hljs-string">'\n\n'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sseHeaders = { <span class="hljs-string"><span class="hljs-string">'content-type'</span></span>: <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>, <span class="hljs-string"><span class="hljs-string">'Transfer-Encoding'</span></span>: <span class="hljs-string"><span class="hljs-string">'chunked'</span></span>, <span class="hljs-string"><span class="hljs-string">'Connection'</span></span>: <span class="hljs-string"><span class="hljs-string">'keep-alive'</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseText = sseChunkData(<span class="hljs-string"><span class="hljs-string">'Hello!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> responseData = <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>.from(responseText, x =&gt; x.charCodeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReadableStream({<span class="hljs-attr"><span class="hljs-attr">start</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">controller</span></span></span><span class="hljs-function"> =&gt;</span></span> controller.enqueue(responseData)}); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(stream, {<span class="hljs-attr"><span class="hljs-attr">headers</span></span>: sseHeaders}); event.respondWith(response); });</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/216/ecb/010/216ecb0104e296f91267f3d18ab21ff0.png" alt="gambar"><br><br>  Astaga!  Ya, saya membuat koneksi SSE tanpa server! <br><br><h3>  Hasil </h3><br>  Sekarang kita berhasil mencegat permintaan SSE dan meresponsnya tanpa melampaui browser. <br><br>  Awalnya, idenya adalah untuk membuat koneksi dengan server, tetapi hanya satu hal - dan darinya mengirim data ke tab.  Ayo lakukan! <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, event =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {headers, url} = event.request; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isSSERequest = headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>) === <span class="hljs-string"><span class="hljs-string">'text/event-stream'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   SSE- if (!isSSERequest) { return; } //    SSE const sseHeaders = { 'content-type': 'text/event-stream', 'Transfer-Encoding': 'chunked', 'Connection': 'keep-alive', }; // ,    SSE const sseChunkData = (data, event, retry, id) =&gt; Object.entries({event, id, data, retry}) .filter(([, value]) =&gt; ![undefined, null].includes(value)) .map(([key, value]) =&gt; `${key}: ${value}`) .join('\n') + '\n\n'; //    ,   — url,  — EventSource const serverConnections = {}; //   url             const getServerConnection = url =&gt; { if (!serverConnections[url]) serverConnections[url] = new EventSource(url); return serverConnections[url]; }; //          const onServerMessage = (controller, {data, type, retry, lastEventId}) =&gt; { const responseText = sseChunkData(data, type, retry, lastEventId); const responseData = Uint8Array.from(responseText, x =&gt; x.charCodeAt(0)); controller.enqueue(responseData); }; const stream = new ReadableStream({ start: controller =&gt; getServerConnection(url).onmessage = onServerMessage.bind(null, controller) }); const response = new Response(stream, {headers: sseHeaders}); event.respondWith(response); });</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode yang sama di github.</a> <br>  Saya mendapat solusi yang cukup sederhana untuk tugas yang tidak terlalu sepele.  Tapi, tentu saja, masih banyak nuansa.  Misalnya, Anda harus menutup koneksi ke server saat menutup semua tab, mendukung protokol SSE, dan sebagainya. <br><br>  Kami telah berhasil memutuskan semua ini - saya yakin tidak akan sulit bagi Anda! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471718/">https://habr.com/ru/post/id471718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471704/index.html">Buku “Mitokondria egois. Cara menjaga kesehatan dan memindahkan usia lanjut "</a></li>
<li><a href="../id471706/index.html">9 masalah jaringan tipikal yang dapat dideteksi menggunakan analisis NetFlow (menggunakan Flowmon sebagai contoh)</a></li>
<li><a href="../id471708/index.html">Storypoints berbahaya untuk pengembangan aplikasi client-server</a></li>
<li><a href="../id471712/index.html">Membuat aplikasi obrolan seluler di React Native</a></li>
<li><a href="../id471716/index.html">Pameran teknologi GITEX 2019 - bagaimana rasanya</a></li>
<li><a href="../id471722/index.html">Bagaimana seorang pria 17 tahun mengangkut arcade era 80-an ke komputer</a></li>
<li><a href="../id471724/index.html">Cekatan dan Kebutuhan Otak: Manajemen Stres</a></li>
<li><a href="../id471726/index.html">Metode modern untuk mengukur respons impuls dan distorsi non-linear</a></li>
<li><a href="../id471728/index.html">Avalonia pro dan kontra saya</a></li>
<li><a href="../id471736/index.html">Sensor Ethernet Non-Kontak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>