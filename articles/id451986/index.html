<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ğŸ» ğŸ›¤ï¸ â™‰ï¸ Mengambil data dengan ORM itu mudah! Atau tidak? ğŸ‡ğŸ¿ ğŸ•ºğŸ¾ ğŸ¤šğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Hampir semua sistem informasi dalam satu atau lain cara berinteraksi dengan penyimpanan data eksternal. Dalam kebanyakan kasus, ini ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengambil data dengan ORM itu mudah! Atau tidak?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/haulmont/blog/451986/"><p><img src="https://habrastorage.org/webt/uv/4h/wb/uv4hwblmcfkf-f6018hxpbkf1s8.jpeg"></p><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Hampir semua sistem informasi dalam satu atau lain cara berinteraksi dengan penyimpanan data eksternal.  Dalam kebanyakan kasus, ini adalah database relasional, dan, seringkali, semacam kerangka kerja ORM digunakan untuk bekerja dengan data.  ORM menghilangkan sebagian besar operasi rutin, alih-alih menawarkan serangkaian kecil abstraksi tambahan untuk bekerja dengan data. </p><br><p>  Martin Fowler menerbitkan sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang</a> menarik, salah satu pemikiran utama di sana: "ORM membantu kami memecahkan sejumlah besar masalah dalam aplikasi perusahaan ... Alat ini tidak bisa disebut cantik, tetapi masalah yang dihadapinya juga tidak baik.  Saya pikir ORM layak mendapatkan lebih banyak rasa hormat dan pengertian. </p><br><p>  Kami menggunakan ORM dengan sangat intensif dalam kerangka kerja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA</a> , jadi kami tahu secara langsung masalah dan keterbatasan teknologi ini, karena CUBA digunakan dalam berbagai proyek di seluruh dunia.  Ada banyak topik yang dapat didiskusikan sehubungan dengan ORM, tetapi kami akan fokus pada salah satu dari mereka: pilihan antara metode "malas" (malas) dan "rakus" (bersemangat) dalam pengambilan sampel data.  Kami akan berbicara tentang berbagai pendekatan untuk menyelesaikan masalah ini dengan ilustrasi dari JPA API dan Spring, dan juga menjelaskan bagaimana (dan mengapa tepatnya) ORM digunakan dalam CUBA dan pekerjaan apa yang kami lakukan untuk meningkatkan pekerjaan dengan data dalam kerangka kerja kami. </p><a name="habracut"></a><br><h2 id="vyborka-dannyh-lenivaya-ili-net">  Pengambilan sampel data: malas atau tidak? </h2><br><p> Jika model data Anda hanya memiliki satu entitas, maka kemungkinan besar Anda tidak akan melihat adanya masalah saat bekerja dengan ORM.  Mari kita lihat contoh kecil.  Misalkan kita memiliki entitas <code>User ()</code> yang memiliki dua atribut: <code>ID</code> dan <code>Name ()</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Untuk mendapatkan instance entitas ini dari database, kita hanya perlu memanggil satu metode objek <code>EntityManager</code> : </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, id);</code> </pre> <br><p>  Hal-hal menjadi sedikit lebih menarik ketika hubungan satu-ke-banyak muncul: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Jika kita perlu mengekstrak instance pengguna dari database, muncul pertanyaan: "Apakah kita juga memilih alamat?".  Dan jawaban "benar" di sini adalah: "Tergantung pada ..." Dalam beberapa kasus kita akan memerlukan alamat, dalam beberapa - tidak.  Biasanya, ORM menyediakan dua cara untuk mengambil catatan yang bergantung: malas dan serakah.  Secara default, sebagian besar ORM menggunakan cara malas.  Tetapi, jika kita menulis kode ini: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>); em.close(); System.out.println(user.getAddresses().get(<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br><p>  ... lalu kita mendapatkan pengecualian <code>â€œLazyInitExceptionâ€</code> , yang sangat membingungkan pendatang baru yang baru saja mulai bekerja dengan ORM.  Dan inilah saatnya ketika Anda perlu memulai sebuah cerita tentang apa yang "Terlampir" dan "Terpisah" contoh entitas, apa sesi dan transaksi. <br>  Ya, itu berarti entitas harus "dilampirkan" ke sesi sehingga Anda dapat memilih data dependen.  Baiklah, jangan langsung menutup transaksi, dan hidup akan segera menjadi lebih mudah.  Dan di sini muncul masalah lain - transaksi menjadi lebih lama, yang meningkatkan risiko kebuntuan.  Buat transaksi lebih pendek?  Itu mungkin, tetapi jika Anda membuat banyak, banyak transaksi kecil, kita mendapatkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Kisah Komar Komarovich - hidung panjang dan tentang Misha berbulu - ekor pendek"</a> tentang bagaimana gerombolan nyamuk beruang kecil menang - itu akan terjadi dengan database.  Jika jumlah transaksi kecil meningkat secara signifikan, maka masalah kinerja akan muncul. <br>  Seperti yang dikatakan, ketika mengambil data tentang pengguna, alamat mungkin diperlukan atau tidak, oleh karena itu, tergantung pada logika bisnis, Anda harus memilih koleksi atau tidak.  Penting untuk menambahkan kondisi baru ke kode ... Hmmm ... Ada sesuatu yang semakin rumit. </p><br><p>  Jadi, bagaimana jika Anda mencoba jenis sampel yang berbeda? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.EAGER) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Baiklah ... Anda tidak bisa mengatakan itu banyak membantu.  Ya, kami akan menyingkirkan <code>LazyInit</code> dibenci dan tidak perlu memeriksa apakah entitas melekat pada sesi atau tidak.  Tetapi sekarang kita mungkin memiliki masalah kinerja, karena kita tidak selalu memerlukan alamat, tetapi kita masih memilih objek-objek ini dalam memori server. <br>  Ada ide lagi? </p><br><h2 id="spring-jdbc">  Spring jdbc </h2><br><p>  Beberapa pengembang sangat bosan dengan ORM sehingga mereka beralih ke kerangka kerja alternatif.  Misalnya, pada Spring JDBC, yang menyediakan kemampuan untuk mengkonversi data relasional ke data objek dalam mode "semi-otomatis".  Pengembang menulis kueri untuk setiap kasus di mana set atribut tertentu diperlukan (atau kode yang sama digunakan kembali untuk kasus di mana struktur data yang sama diperlukan). </p><br><p>  Ini memberi kita fleksibilitas besar.  Misalnya, Anda dapat memilih hanya satu atribut tanpa membuat objek entitas yang sesuai: </p><br><pre> <code class="java hljs">String name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, String.class);</code> </pre> <br><p>  Atau pilih objek dalam bentuk biasa: </p><br><pre> <code class="java hljs">User user = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select id, name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowMapper&lt;User&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ResultSet rs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ User user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); user.setName(rs.getString(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)); user.setId(rs.getInt(<span class="hljs-string"><span class="hljs-string">"id"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; } });</code> </pre> <br><p>  Anda juga dapat memilih daftar alamat untuk pengguna, Anda hanya perlu menulis sedikit lebih banyak kode dan menyusun query SQL dengan benar untuk menghindari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah n + 1 query</a> . </p><br><p>  Soooo, rumit lagi.  Ya, kami mengontrol semua kueri dan bagaimana data dipetakan ke objek, tetapi kami perlu menulis lebih banyak kode, mempelajari SQL, dan mengetahui bagaimana kueri dieksekusi dalam database.  Secara pribadi, saya berpikir bahwa pengetahuan tentang SQL adalah keterampilan yang diperlukan untuk seorang programmer aplikasi, tetapi tidak semua orang berpikir seperti itu, dan saya tidak akan terlibat dalam polemik.  Bagaimanapun, pengetahuan tentang instruksi perakitan x86 hari ini juga opsional.  Lebih baik kita pikirkan bagaimana membuat hidup lebih mudah bagi programmer. </p><br><h2 id="jpa-entitygraph">  JPA EntityGraph </h2><br><p>  Dan mari kita mundur selangkah dan berpikir, apa yang kita butuhkan?  Tampaknya kita hanya perlu menunjukkan atribut apa yang kita butuhkan dalam setiap kasus.  Baiklah, mari kita lakukan!  JPA 2.1 memperkenalkan API baru - EntityGraph (grafik entitas).  Idenya sangat sederhana: kami menggunakan anotasi untuk menggambarkan apa yang akan kami pilih dari basis data.  Berikut ini sebuah contoh: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraphs</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-only-entity-graph"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>, attributeNodes = {<span class="hljs-meta"><span class="hljs-meta">@NamedAttributeNode</span></span>(<span class="hljs-string"><span class="hljs-string">"addresses"</span></span>)}) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.LAZY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Dua grafik dijelaskan untuk entitas ini: <code>user-only-entity-graph</code> tidak memilih atribut <code>Addresses</code> (ditandai sebagai malas), sedangkan grafik kedua memberitahu ORM untuk memilih atribut ini.  Jika kami menandai <code>Addresses</code> sebagai keinginan, grafik akan diabaikan dan alamat akan tetap dipilih. </p><br><p>  Jadi, di JPA 2.1, Anda dapat mengambil sampel data seperti ini: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); EntityGraph graph = em.getEntityGraph(<span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>); Map&lt;String, Object&gt; properties = Map.of(<span class="hljs-string"><span class="hljs-string">"javax.persistence.fetchgraph"</span></span>, graph); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>, properties); em.close();</code> </pre> <br><p>  Pendekatan ini sangat menyederhanakan pekerjaan, tidak perlu berpikir secara terpisah tentang atribut malas, dan panjang transaksi.  Bonus tambahan adalah grafik diterapkan pada tingkat permintaan SQL, sehingga data "ekstra" tidak dipilih dalam aplikasi Java.  Tetapi ada satu masalah kecil: Anda tidak bisa mengatakan atribut mana yang dipilih dan mana yang tidak.  Ada API untuk memeriksa, ini dilakukan menggunakan kelas <code>PersistenceUtil</code> : </p><br><pre> <code class="java hljs">PersistenceUtil pu = entityManagerFactory.getPersistenceUnitUtil(); System.out.println(<span class="hljs-string"><span class="hljs-string">"User.addresses loaded: "</span></span> + pu.isLoaded(user, <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>));</code> </pre> <br><p>  Tapi ini sangat membosankan dan tidak semua orang siap untuk melakukan pemeriksaan seperti itu.  Apakah ada hal lain yang dapat Anda sederhanakan dan tidak menunjukkan atribut yang tidak dipilih? </p><br><h2 id="proekcii-spring">  Proyeksi Musim Semi </h2><br><p>  Kerangka Kerja Pegas memiliki hal hebat yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyeksi</a> (dan ini tidak sama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyeksi di Hibernate</a> ).  Jika Anda hanya perlu memilih beberapa atribut dari suatu entitas, sebuah antarmuka dengan atribut yang diperlukan dibuat, dan Spring memilih "instance" dari antarmuka ini dari database.  Sebagai contoh, pertimbangkan antarmuka berikut: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamesOnly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  Sekarang Anda dapat mendefinisikan repositori Spring JPA untuk mengambil entitas Pengguna sebagai berikut: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Collection&lt;NamesOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastname)</span></span></span></span>; }</code> </pre> <br><p>  Dalam hal ini, setelah memanggil metode findByName, dalam daftar yang dihasilkan kita mendapatkan entitas yang hanya memiliki akses ke atribut yang didefinisikan dalam antarmuka!  Menurut prinsip yang sama, seseorang dapat memilih entitas dependen, yaitu  segera pilih hubungan "detail utama".  Selain itu, Spring menghasilkan SQL "benar" dalam banyak kasus, yaitu  hanya atribut-atribut yang dijelaskan dalam proyeksi yang dipilih dari database, ini sangat mirip dengan cara kerja entitas graph. <br>  Ini adalah API yang sangat kuat. Saat mendefinisikan antarmuka, Anda dapat menggunakan ekspresi SpEL, menggunakan kelas dengan semacam logika bawaan, bukan antarmuka, dan banyak lagi, semuanya dijelaskan secara rinci dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> . <br>  Satu-satunya masalah dengan proyeksi adalah bahwa di dalam mereka diimplementasikan sebagai pasangan kunci-nilai, yaitu  hanya baca.  Ini berarti bahwa bahkan jika kita mendefinisikan metode penyetel untuk proyeksi, kita tidak akan dapat menyimpan perubahan baik melalui repositori CRUD atau melalui EntityManager.  Jadi proyeksi adalah DTO yang dapat dikonversi kembali ke Entitas dan disimpan hanya jika Anda menulis kode Anda sendiri untuk ini. </p><br><h2 id="kak-vybirayutsya-dannye-v-cuba">  Cara memilih data di CUBA </h2><br><p>  Sejak awal pengembangan kerangka kerja CUBA, kami mencoba untuk mengoptimalkan bagian dari kode yang bekerja dengan basis data.  Di CUBA, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EclipseLink</a> sebagai dasar untuk API akses data.  Apa yang baik tentang EclipseLink adalah bahwa ia mendukung pemuatan entitas parsial sejak awal, dan ini merupakan faktor penentu dalam memilih antara itu dan Hibernate.  Di EclipseLink, Anda bisa menentukan atribut untuk memuat jauh sebelum standar JPA 2.1 muncul.  CUBA memiliki caranya sendiri untuk menggambarkan grafik entitas, yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CUBA Views</a> .  Representasi CUBA adalah API yang agak maju, Anda dapat mewarisi beberapa representasi dari yang lain, menggabungkannya, melamar ke entitas master dan detail.  Motivasi lain untuk membuat tampilan CUBA adalah bahwa kami ingin menggunakan transaksi pendek sehingga kami dapat bekerja dengan entitas terpisah di antarmuka pengguna web. <br>  Dalam CUBA, tampilan dijelaskan dalam file XML, seperti dalam contoh di bawah ini: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.sample.User"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">extends</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"_minimal"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user-minimal-view"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"addresses"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">view</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"address-street-only-view"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Tampilan ini memilih entitas <code>User</code> dan <code>name</code> atribut lokalnya, dan juga memilih alamat dengan menerapkan tampilan <code>address-street-only-view</code> .  Semua ini terjadi (perhatian!) Di tingkat permintaan SQL.  Saat tampilan dibuat, Anda bisa menggunakannya dalam pemilihan data menggunakan kelas DataManager: </p><br><pre> <code class="java hljs">List&lt;User&gt; users = dataManager.load(User.class).view(<span class="hljs-string"><span class="hljs-string">"user-edit-view"</span></span>).list();</code> </pre> <br><p>  Pendekatan ini berfungsi dengan baik, sementara memakan lalu lintas jaringan secara ekonomis, karena atribut yang tidak digunakan tidak ditransfer dari database ke aplikasi, tetapi, seperti dalam kasus JPA, ada masalah: tidak dapat dikatakan atribut entitas yang mana yang dimuat.  Dan di CUBA ada pengecualian <code>â€œIllegalStateException: Cannot get unfetched attribute [...] from detached objectâ€</code> , yang, seperti <code>LazyInit</code> , pasti ditemui oleh semua orang yang menulis menggunakan kerangka kerja kami.  Seperti dalam JPA, ada cara untuk memeriksa atribut mana yang dimuat dan mana yang tidak, tetapi, sekali lagi, menulis cek semacam itu adalah tugas yang membosankan dan melelahkan yang membuat banyak pengembang kesal.  Sesuatu yang lain perlu diciptakan agar tidak membebani orang dengan pekerjaan yang, secara teori, dapat dilakukan mesin. </p><br><h2 id="koncept---cuba-view-interfaces">  Konsep - Antarmuka Tampilan CUBA </h2><br><p>  Tetapi bagaimana jika Anda mencoba untuk menggabungkan grafik entitas dan proyeksi?  Kami memutuskan untuk mencoba ini dan mengembangkan antarmuka untuk antarmuka tampilan entitas yang mengikuti pendekatan proyeksi Spring.  Antarmuka ini diterjemahkan ke dalam tampilan CUBA saat startup aplikasi dan dapat digunakan dalam DataManager.  Idenya sederhana: kita menggambarkan sebuah antarmuka (atau satu set antarmuka), yang merupakan grafik entitas. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserMinimalView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String val)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;AddressStreetOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAddresses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressStreetOnly</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String street)</span></span></span></span>; } }</code> </pre> <br><p>  Perlu dicatat bahwa untuk beberapa kasus tertentu, Anda dapat membuat antarmuka lokal, seperti dalam kasus <code>AddressStreetOnly</code> dari contoh di atas, agar tidak "mencemari" API publik aplikasi Anda. </p><br><p>  Dalam proses memulai aplikasi CUBA (yang sebagian besar merupakan inisialisasi konteks Spring), kami secara terprogram membuat tampilan CUBA dan menempatkannya dalam repositori kacang internal dalam konteks. <br>  Sekarang Anda perlu sedikit memodifikasi implementasi kelas DataManager sehingga menerima tampilan antarmuka, dan Anda dapat memilih entitas dengan cara ini: </p><br><pre> <code class="java hljs">List&lt;UserMinimalView&gt; users = dataManager.load(UserMinimalView.class).list();</code> </pre> <br><p>  Di bawah tenda, objek proxy dihasilkan yang mengimplementasikan antarmuka dan membungkus instance entitas yang dipilih dari basis data (dengan cara yang hampir sama seperti di Hibernate).  Dan, ketika pengembang memanggil nilai atribut, proxy mendelegasikan panggilan metode ke instance "real" entitas. </p><br><p>  Dalam mengembangkan konsep ini, kami mencoba membunuh dua burung dengan satu batu: </p><br><ul><li>  Data yang tidak dijelaskan dalam antarmuka tidak dimuat ke dalam aplikasi, sehingga menghemat sumber daya server. </li><li>  Pengembang hanya dapat menggunakan atribut-atribut yang dapat diakses melalui antarmuka (dan, karena itu, dipilih dari database), sehingga menghilangkan pengecualian <code>UnfetchedAttribute</code> yang kami tulis di atas. </li></ul><br><p>  Tidak seperti proyeksi Spring, kami membungkus entitas dalam objek proxy, selain itu, setiap antarmuka mewarisi antarmuka CUBA standar - <code>Entity</code> .  Ini berarti bahwa atribut Entity View dapat diubah, dan kemudian menyimpan perubahan ini ke database menggunakan API CUBA standar untuk bekerja dengan data. <br>  Dan, omong-omong, "kelinci ketiga" - Anda dapat membuat atribut read-only jika Anda mendefinisikan antarmuka dengan metode pengambil saja.  Dengan demikian, kami telah menetapkan aturan modifikasi di tingkat API entitas. <br>  Selain itu, Anda dapat melakukan beberapa operasi lokal untuk entitas terpisah menggunakan atribut yang tersedia, misalnya, konversi string nama, seperti dalam contoh di bawah ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MetaProperty</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNameLowercase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getName().toLowerCase(); }</code> </pre> <br><p>  Perhatikan bahwa atribut yang dikomputasi dapat dikeluarkan dari model kelas entitas dan ditransfer ke antarmuka yang berlaku untuk logika bisnis tertentu. </p><br><p>  Fitur lain yang menarik adalah pewarisan antarmuka.  Anda dapat membuat beberapa tampilan dengan set atribut yang berbeda, dan kemudian menggabungkannya.  Misalnya, Anda bisa membuat antarmuka untuk entitas Pengguna dengan atribut nama dan email, dan lainnya dengan atribut nama dan alamat.  Sekarang, jika Anda perlu memilih nama, email, dan alamat, maka Anda tidak perlu menyalin atribut ini ke antarmuka ketiga, Anda hanya perlu mewarisi dari dua tampilan pertama.  Dan ya, contoh antarmuka ketiga dapat diteruskan ke metode yang menerima parameter dengan jenis antarmuka induk, aturan OOP adalah sama untuk semua orang. </p><br><p>  Konversi antara tampilan juga diterapkan - setiap antarmuka memiliki metode reload (), di mana Anda dapat melewati kelas tampilan sebagai parameter: </p><br><pre> <code class="java hljs">UserFullView userFull = userMinimal.reload(UserFullView.class);</code> </pre> <br><p>  UserFullView dapat berisi atribut tambahan, sehingga entitas akan dimuat ulang dari database, jika perlu.  Dan proses ini tertunda.  Akses ke database hanya akan dilakukan ketika akses pertama ke atribut entitas terjadi.  Ini akan sedikit memperlambat panggilan pertama, tetapi pendekatan ini dipilih dengan sengaja - jika instance entitas digunakan dalam modul "web", yang berisi UI dan pengendali REST sendiri, modul ini dapat digunakan pada server yang terpisah.  Dan ini berarti bahwa overload paksa entitas akan membuat lalu lintas jaringan tambahan - akses ke modul inti dan kemudian ke database.  Jadi, menunda kelebihan hingga saat diperlukan, kami menghemat lalu lintas dan mengurangi jumlah kueri basis data. </p><br><p>  Konsep ini dirancang sebagai modul untuk CUBA, contoh penggunaan dapat diunduh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> . </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Tampaknya dalam waktu dekat kita masih akan secara masif menggunakan ORM dalam aplikasi perusahaan hanya karena kita membutuhkan sesuatu yang akan mengubah data relasional menjadi objek.  Tentu saja, solusi spesifik akan dikembangkan untuk aplikasi yang kompleks, unik, dan berkapasitas sangat tinggi, tetapi tampaknya kerangka kerja ORM akan hidup selama basis data relasional. <br>  Di CUBA, kami mencoba menyederhanakan pekerjaan dengan ORM secara maksimal, dan dalam versi yang akan datang kami akan memperkenalkan fitur baru untuk bekerja dengan data.  Akan sulit untuk mengatakan apakah ini akan menjadi antarmuka presentasi atau sesuatu yang lain, tetapi saya yakin akan satu hal: kami akan terus menyederhanakan pekerjaan dengan data di versi kerangka kerja yang akan datang. </p><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id451986/">https://habr.com/ru/post/id451986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id451970/index.html">Thrangrycat: kerentanan kritis dalam firmware perangkat Cisco memungkinkan peretas untuk menginstal backdoors pada mereka</a></li>
<li><a href="../id451972/index.html">QuadCast - Kedengarannya Nyata</a></li>
<li><a href="../id451974/index.html">Sejarah AMD: 50 Tahun Perkembangan Pesat</a></li>
<li><a href="../id451976/index.html">Berapa harga Runet "berdaulat"?</a></li>
<li><a href="../id451982/index.html">Semakin cepat Anda melupakan OOP, semakin baik untuk Anda dan program Anda.</a></li>
<li><a href="../id451990/index.html">FAQ tentang transfer dan penerbangan lanjutan: apa perbedaan yang bisa dan tidak bisa dilakukan penumpang</a></li>
<li><a href="../id451996/index.html">Pengalaman saya tentang kesalahan</a></li>
<li><a href="../id451998/index.html">Masalah pertanian presisi dan cara hidup bersama mereka</a></li>
<li><a href="../id452000/index.html">Bagaimana di Leroy Merlin Anda dapat membeli barang-barang dari gudang pemasok yang tidak ada dalam bermacam-macam toko</a></li>
<li><a href="../id452004/index.html">Menemukan lokasi jatuhnya perangkat "Bereshit" ke bulan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>