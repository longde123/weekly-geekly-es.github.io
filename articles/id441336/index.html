<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ­ ğŸ¯ ğŸ›°ï¸ RTOS atau bukan RTOS adalah pertanyaannya â€¼ï¸ ğŸ‘©ğŸ¼â€ğŸ¤â€ğŸ‘¨ğŸ» ğŸ•µğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya diminta untuk menulis artikel ini dengan cabang komentar yang panjang (sayangnya saya tidak dapat menyebut ini sebagai diskusi) ke artikel saya y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RTOS atau bukan RTOS adalah pertanyaannya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/441336/"><img src="https://habrastorage.org/files/3ff/676/da5/3ff676da5b2f4acabdd782f871f1b782.jpg" alt="gambar" align="right">  Saya diminta untuk menulis artikel ini dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cabang komentar yang panjang</a> (sayangnya saya tidak dapat menyebut ini sebagai diskusi) ke artikel saya yang terbaru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">â€œDunia yang beragam dari sistem embedded dan tempat Embox di dalamnyaâ€</a> .  Saya dicela di beberapa tempat karena membingungkan RTOS dan Embedded OS, yang saya sebut LynxOS, QNX dan VxWorks bukan RTOS, meskipun menurut saya, tentu saja, saya tidak melakukannya.  Saya menyarankan penulis komentar ini beberapa kali untuk menulis artikel di mana ia akan menyatakan visinya tentang konsep "sistem operasi real-time", tetapi untuk beberapa alasan ia menolak.  Baiklah, saya akan menyampaikan visi saya tentang istilah ini, dan mari kita bahas apa yang disebut RTOS dan apa yang tidak.  Pada akhirnya, pertanyaan ini sering ditanyakan sehubungan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Embox</a> . <br><a name="habracut"></a><br><h2>  Istilah OS RV (RTOS) mengacu pada bidang pemasaran! </h2><br>  Saya berpikir untuk memulai dengan cara ilmiah, dengan memperkenalkan istilah-istilah, tetapi memutuskan bahwa tesis provokatif ini akan disambut dengan sangat baik.  Jadi, mengapa saya berpendapat bahwa istilah RTOS (sistem operasi real-time) mengacu pada pemasaran, lebih tepatnya, adalah slogan pemasaran (periklanan)?  Semuanya sederhana.  Ketika suatu produk diproduksi, itu perlu dijual.  Tetapi jika Anda mencoba menjual hanya sistem operasinya, kesulitan akan muncul.  Di sinilah posisi pasar datang untuk menyelamatkan.  Misalnya, Anda bisa mengatakan "kami lebih cepat dari mereka." <br><br><div class="spoiler">  <b class="spoiler_title">Fakta menarik:</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QNX awalnya bernama Quick Unix (Qunix), "OS ini awalnya bernama Qunix," Quick UNIX ", sampai mereka menerima surat sopan dari pengacara AT&amp;T yang meminta mereka mengganti nama."</a> <br></div></div><br>  Tapi Anda bisa ke pengadilan untuk itu!  Dan di sana Anda perlu memberikan bukti.  Tetapi bagaimana membuktikan bahwa Anda lebih cepat dalam semua kasus?  Ini bukan kompetisi lari.  Tetapi tentu saja, persaingan yang tidak sepenuhnya benar semacam itu sedikit keluar dari posisi pasar normal. <br><br>  Pemosisian normal melibatkan pembentukan potret konsumen, mengidentifikasi sifat-sifat produk yang lebih diminati, dan berfokus pada sifat-sifat ini.  Baik, atau Anda membentuk kebutuhan ini di pengguna.  Misalnya, prosesor kami memiliki frekuensi seperti itu, smartphone memiliki prosesor N-core, dan sebagainya. <br><br>  Karena klasik genre telah merumuskan bahwa sistem operasi diperlukan tidak hanya untuk sistem pengguna, tetapi juga untuk mengendalikan berbagai proses teknologi dalam mode otomatis, dan bahkan memperkenalkan konsep sistem operasi real-time, maka, Anda tahu, itu dosa untuk tidak menggunakannya.  Memperkenalkan konsep sistem real-time, klasik berbicara tentang ambang waktu kritis tertentu.  Artinya, ini berbeda dari sistem konvensional, di mana jika pengguna menunggu sesuatu, maka dia bisa menunggu, sistem real-time yang keras, misalnya, mengendalikan turbin, tidak bisa menunggu, kalau tidak Anda dapat beralih ke sesuatu yang buruk. <br><br>  Dengan demikian, Anda dapat memberi tahu pengguna bahwa, tidak seperti sistem operasi konvensional, mereka akan diberikan sistem yang menjamin waktu respons sistem.  Secara alami, semakin kecil, semakin banyak jumlah proses teknologi yang dapat dikontrol oleh sistem.  Dan banyak tabel muncul di mana berbagai parameter kunci RTOS diberikan sebagai parameter kunci. <br><br>  Bagaimana mereka diterima?  Proses ini dijelaskan dengan jujur!  Di sini kita mengambil masalah model ini dan itu, ini dan itu platform perangkat keras, dan menerapkan efeknya.  Nah, pemasaran, tentu saja, dapat menyederhanakan dan memberi, waktu reaksi 1 Î¼s.  Tapi kami tidak memperhitungkan ini, kami percaya bahwa semuanya dijelaskan dengan jujur. <br><br>  Tapi permisi, bagaimana jika ada tugas lain?  10 tugas, 100 tugas?  Dan jika kunci programmer mabuk mengganggu?  Dan jika dalam sistem programmer tidak memprioritaskan tugas dengan benar? <br><br>  Ada kasus ketika Embox lulus tes secara real time.  Kami duduk dan berpikir bagaimana membuktikan bahwa ini adalah sistem operasi real-time.  Ada laboratorium, ada pelanggan yang menginginkannya demikian.  Kami mengetahui bahwa untuk pelanggan waktu-nyata berarti waktu respons sistem adalah 1 Î¼s.  Saya bertanya apakah percobaan berikut akan menjadi bukti: <br><br><ul><li>  Kami mengambil platform perangkat keras tertentu </li><li>  Terapkan sinyal ke salah satu input GPIO </li><li>  Secara terprogram menangkap suatu peristiwa </li><li>  Pada keluaran GPIO, kami secara terprogram memberi sinyal </li><li>  Pengukuran dilakukan menggunakan osiloskop, waktu reaksi akan menjadi perbedaan antara input dan output front. </li></ul><br>  Pelanggan menegaskan bahwa inilah yang dibutuhkan.  Saya mengajukan pertanyaan klarifikasi, dan kami sedang merancang sistem model dan mungkin tidak memulai (tidak memuat) dengan tugas lain.  Artinya, normal bahwa sistem hanya akan melakukan tugas tes yang sederhana.  Pelanggan mengatakan bahwa ini membutuhkan tugas pengujian.  Mungkin Anda sendiri mengerti bahwa sistem telah lulus tes!  Secara alami, dengan konfirmasi karakteristik, yaitu dampaknya berulang. <br><br>  Bagian ini sama sekali tidak ditulis untuk meremehkan OS atau pengembang apa pun.  Tetapi semata-mata untuk menunjukkan seluruh ketidaklengkapan gambar.  Saya tidak mengklaim bahwa karakteristik beberapa sistem operasi tidak memungkinkan mereka untuk dikaitkan dengan RTOS, tetapi istilah ini hanya digunakan oleh pemasar.  Saya melihat tes lain ketika saya memesan pilihan sistem operasi laboratorium independen berdasarkan persyaratan tugas.  Ada serangkaian tugas model yang kompleks, dan interaksi jaringan dipertimbangkan, dan bagaimana parameter berubah jika sistem dimuat, dan perilaku dalam berbagai situasi darurat. <br><br><h2>  Definisi istilah "sistem operasi waktu-nyata" </h2><br>  Sekarang saya akan memperkenalkan istilah "sistem operasi Real-time".  Tidak, saya tidak akan.  Faktanya adalah bahwa ada banyak definisi dari istilah ini.  Setidaknya ambil komentar di artikel asli: <br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalam sistem waktu nyata, seseorang pada umumnya berlebihan dan, karenanya, kecepatan sistem waktu nyata harus dibandingkan dengan proses yang dikontrolnya, apakah itu mobil otonom atau sistem kontrol proses di sebuah pabrik.</a> </blockquote><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SRV / RTOS - ini semata-mata sebuah peringkat pada prediktabilitas respons terhadap peristiwa kritis.</a> </blockquote><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS adalah OS semacam itu di mana kebenaran suatu tugas tidak hanya dicirikan oleh kebenaran logis, tetapi pada saat yang dibutuhkan untuk menyelesaikan tugas ini.</a> </blockquote><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tetapkan kriteria untuk mengalihkan konteks tugas apa pun menjadi 1 Î¼s per prosesor 100 MHz dengan floating-point coprocessor dengan penentuan 0,1 Î¼s dan semuanya akan jatuh ke tempatnya.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Anda akan melihat dengan jelas di mana RTOS dan di mana tidak.</a> </blockquote>  Yah, saya tidak bisa mengabaikan pendapat yang saya bicarakan dalam sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> yang disuarakan di salah satu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konferensi OSDAY</a> : <br><blockquote>  Suatu sistem dapat dianggap sebagai sistem waktu-nyata yang sulit jika tidak memiliki tempat di mana, dengan interupsi yang dikunci, ada siklus dengan jumlah iterasi yang tidak diketahui. </blockquote>  Tapi mungkin itu semua hanya khusus, dan seperti yang disarankan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar</a> , Anda hanya perlu menggunakan klasik dan tidak membuat sepeda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Saya akan mengutip</a> klasik yang ditentukan (Andrew Tanenbaum, jika seseorang tidak menebak): <br><blockquote>  â€œJenis lain dari sistem operasi adalah sistem real-time.  Sistem ini ditandai dengan memiliki waktu sebagai parameter kunci.  Misalnya, dalam sistem kontrol proses industri, komputer waktu nyata harus mengumpulkan data tentang proses produksi dan menggunakannya untuk mengendalikan mesin di pabrik.  Seringkali ada tenggat waktu yang sulit yang harus dipenuhi.  Misalnya, jika mobil bergerak di jalur perakitan, tindakan tertentu harus dilakukan pada saat tertentu.  Jika robot pengelasan dilas terlalu awal atau terlambat, mobil akan hancur.  Jika tindakan mutlak harus terjadi pada saat tertentu (atau dalam rentang tertentu), kami memiliki sistem waktu-nyata yang sulit.  Banyak dari ini ditemukan dalam kontrol proses industri, avionik, militer, dan area aplikasi serupa.  Sistem ini harus memberikan jaminan mutlak bahwa tindakan tertentu akan terjadi pada waktu tertentu. <br><br>  Jenis lain dari sistem waktu nyata adalah sistem waktu nyata lunak, di mana kehilangan batas waktu sesekali, meskipun tidak diinginkan, dapat diterima dan tidak menyebabkan kerusakan permanen.  Sistem audio atau multimedia digital termasuk dalam kategori ini.  Telepon digital juga merupakan sistem waktu nyata yang lunak. <br><br>  Karena memenuhi tenggat waktu yang ketat sangat penting dalam sistem waktu-nyata, kadang-kadang sistem operasi hanyalah sebuah perpustakaan yang dihubungkan dengan program aplikasi, dengan segala sesuatu digabungkan secara erat dan tidak ada perlindungan antara bagian-bagian dari sistem.  Contoh dari sistem real-time jenis ini adalah e-Cos. <br><br>  Kategori perangkat genggam, sistem tertanam, dan sistem waktu nyata tumpang tindih secara signifikan.  Hampir semuanya memiliki setidaknya beberapa aspek waktu nyata yang lunak.  Sistem tertanam dan waktu nyata hanya menjalankan perangkat lunak yang dimasukkan oleh perancang sistem;  pengguna tidak dapat menambahkan perangkat lunak mereka sendiri, yang membuat perlindungan lebih mudah.  Handheld dan embedded system ditujukan untuk konsumen, sedangkan sistem real-time lebih untuk penggunaan industri.  Meskipun demikian, mereka memiliki jumlah tertentu yang sama. â€ </blockquote>  Tetapi dari uraian ini hanya mengikuti bahwa sistem dapat digunakan dalam sistem di mana tidak adanya reaksi dalam periode tertentu dapat menyebabkan konsekuensi bencana.  Nah, untuk mencapai parameter kunci (tidak melebihi waktu reaksi), OS bisa menjadi perpustakaan, contoh dari eCos. <br><br><div class="spoiler">  <b class="spoiler_title">Tentang real-time lunak dan keras</b> <div class="spoiler_text">  Saya sengaja tidak memperhatikan pembagian menjadi lunak dan keras, karena OS universal modern apa pun dapat dianggap sebagai sistem waktu nyata yang lunak, yah, misalnya, windows memutar file multimedia dengan sempurna.  Dan saya mengerti bahwa di sini lebih tentang semua jenis DSP, yaitu pemrosesan sinyal.  Tetapi jika kita juga mempertimbangkan bagian ini, maka kita tidak akan pernah menyelesaikannya sama sekali.  Secara umum, selanjutnya kami hanya bermaksud sistem di mana tidak mungkin untuk melanggar batas waktu, yaitu real-time yang sulit. <br></div></div><br><h2>  Cara mencapai karakteristik real-time </h2><br>  Saya tidak bisa memberikan definisi yang ketat (jika seseorang siap memberi, tulis di komentar).  Tetapi dalam semua definisi di atas, beberapa properti terlihat (kali ini dan dapat diprediksi).  Jika Anda menerjemahkan waktu ke dalam opsi prediktabilitas (bobot busur saat berpindah dari satu kondisi ke kondisi lain), maka hanya prediktabilitas yang tersisa! <br><br>  Mari kita pikirkan bagaimana mencapai ini. <br><br>  Jelas akan menghapus semua yang tidak perlu dari sistem kritis.  Sistem universal sepertinya tidak akan stabil.  Bahkan Kamerad Tanenbaum membicarakan hal ini, maksud saya, ketika dia berbicara tentang eCos. <br><br>  Pendekatan lain yang meningkatkan prediktabilitas sistem, sekali lagi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diusulkan oleh Tanenbaum</a> , adalah penggunaan algoritma khusus (sederhana) untuk perencanaan sumber daya, terutama waktu prosesor, yaitu, penjadwal tugas khusus.  Dia menyarankan beberapa pendekatan untuk perencanaan, tetapi saya ingin fokus pada tabel yang digerakkan oleh tabel statis terlebih dahulu. <br><br>  Pengembang harus memastikan bahwa semua tugas berhasil menyelesaikan irisan waktu mereka.  Untuk melakukan ini, diusulkan untuk menganalisis secara statis tugas kritis dan menentukan nilai ambangnya.  Pendekatan ini ditetapkan dalam standar ARINC-653.  Standar untuk sistem on-board, dan Anda sendiri mengerti, jika sesuatu tiba-tiba tidak punya waktu untuk bekerja di pesawat, maka malapetaka bisa terjadi. <br><br>  Pendekatan selanjutnya adalah jadwal statis, tetapi didasarkan pada prioritas.  Artinya, pengembang harus menganalisis kembali semua situasi dan, setelah menetapkan semua tugas dalam prioritas sistem, memastikan bahwa tugas-tugas penting diselesaikan pada waktu tertentu. <br><br>  Saya tidak ingin melanjutkan, karena ada yang asli!  Itu ditulis, tentu saja, lebih baik daripada yang bisa saya lakukan, dan di samping itu, mereka dapat dituduh mengubah fakta.  Saya mengutip dengan tepat pendekatan ini untuk menunjukkan bahwa dalam hal apa pun, pengembang sistem akhir memiliki tanggung jawab untuk memastikan karakteristik sistem.  Dan sistem operasi seharusnya hanya menyediakan kemampuan yang sesuai. <br><br>  Melanjutkan diskusi tentang metode untuk meningkatkan prediktabilitas, saya ingin memberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar</a> lain <br><blockquote>  "Anda dapat mencapai waktu nyata dengan raspberry, tetapi tidak dengan RTOS, tetapi dengan mesin negara kecil yang membobol cache-nya." </blockquote>  Di sini saya ingin memperhatikan beberapa hal berikut: <br><br><ul><li>  peningkatan prediktabilitas (properti waktu nyata) karena pengecualian RTOS dari sistem </li><li>  representasi program oleh mesin negara </li><li>  Yah, ketergantungan sistem waktu-nyata tidak hanya pada sifat-sifat perangkat lunak, tetapi juga pada perangkat keras. </li></ul><br>  Dengan penurunan jumlah ketidakpastian dalam kasus penurunan jumlah baris kode, saya pikir semua orang setuju.  Meskipun, seperti biasa, saya tidak setuju, tetapi lebih pada nanti. <br><br>  Apa pengaruh perangkat keras juga kemungkinan besar tidak diragukan.  Secara khusus, ketika dikatakan bahwa tidak ada loop dengan jumlah iterasi sewenang-wenang dalam keadaan interupsi terkunci, terdengar bahwa pada beberapa korteks-m dalam RTOS yang dijelaskan tidak ada pemutusan interupsi sama sekali.  Ini sedikit licik, karena di sana pengendali interupsi menonaktifkan interupsi dengan prioritas yang sama atau lebih rendah, secara independen, tetapi fakta pengaruh jelas.  Dan tentu saja, keberadaan cache, terjemahan alamat (atau lebih tepatnya ketinggalan pada halaman), berkontribusi pada ketidakpastian.  Terutama, saya ingin menarik perhatian pada kenyataan bahwa, pada kenyataannya, tidak ada yang bisa menjamin seratus persen pengoperasian peralatan yang benar.  Nah, postingan jatuh dari Anda, bagaimana kehadiran RTOS akan membantu untuk menghindari hasil bencana? <br><br>  Representasi program sebagai mesin negara, saya ingin mengusulkan untuk mempertimbangkannya dari sisi yang tidak jelas.  Yaitu, bahwa program prediktabilitas dapat dianalisis.  Dan karena kita berbicara tentang semua kondisi, maka itu harus dianalisis, dan secara statis, untuk semua situasi yang mungkin terjadi.  Yah, karena bahasa pemrograman fungsional jauh lebih cocok untuk analisis statis, adalah mungkin untuk mengembangkan suatu program dalam beberapa bahasa khusus, atau menambahkan penggunaan bahasa pemrograman khusus.  Pendekatan pertama digunakan, misalnya, di kernel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seL4</a> terverifikasi.  Contoh dari pendekatan kedua adalah standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ARINC-653 yang</a> sama, dengan pembentukan persyaratan wajib dalam XML. <br><br>  Ada metode lain yang meningkatkan prediktabilitas atau, jika Anda suka, faktor yang mempengaruhi prediktabilitas sistem.  Saya membuat laporan tentang topik ini di salah satu konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OSDay</a> .  Secara khusus, selain yang sudah terdaftar, saya telah menyoroti pendekatan arsitektur.  Lagi pula, sudah diketahui bahwa, misalnya, arsitektur microkernel dapat meningkatkan prediktabilitas sistem.  Tetapi bahkan dalam laporan yang sama, pendekatan organisasi yang agak tidak jelas ditekankan.  Ini hanya tentang titik di mana saya tidak setuju bahwa kurangnya RTOS menyebabkan peningkatan kemampuan prediksi.  Jika Anda memikirkannya, maka secara umum konsep sistem operasi telah secara signifikan mengurangi jumlah kesalahan karena penggunaan kembali kode.  Artinya, jika Anda tidak memiliki kode yang benar-benar cocok menjadi satu saklar / kasing, maka lebih baik menggunakan modul yang sudah jadi.  Setelah semua, parameter "jumlah kesalahan per 1000 baris kode" belum dibatalkan, dan tidak peduli seberapa debug kode baru Anda, ada kesalahan. <br><br><h2>  Apakah RTOS ada? </h2><br>  Setelah menyelesaikan pernyataan di bagian sebelumnya bahwa ada kesalahan dalam kode apa pun, saya ingin membuat satu tesis yang lebih provokatif.  Apakah RTOS ada? <br><br>  Mari kita cari tahu.  Membahas dengan seorang teman tentang sistem waktu nyata, kami sepakat sejauh bahwa sistem operasi waktu nyata (kita berbicara tentang sistem waktu nyata yang sulit) hampir tidak ada.  Dia mengusulkan untuk mewakili seluruh sistem sebagai mesin negara atau grafik dengan deskripsi waktu transisi maksimum dari satu negara ke yang lain.  Selain itu, sistem dapat dianggap stabil jika terbukti bahwa untuk semua input dan keadaan internal, ada busur yang mengarah ke keadaan tertentu dengan batas waktu.  Anda tahu, ini hanya mungkin untuk sistem yang sangat kecil, hanya mesin negara yang disebutkan dalam komentar, tetapi di dunia modern hanya sedikit orang yang membutuhkan sistem seperti itu. <br><br>  Tetapi kami tidak ragu bahwa sistem waktu nyata ada.  Dan tentu saja, RTOS juga.  Jika tidak demikian, <s>maka pelatuk terbang pertama akan menghancurkan peradaban,</s> maka tidak akan ada avionik, astronotika, robot, ACS-TP dan banyak lagi. <br><br>  Bagaimana keluar dari situasi tersebut.  Ini sangat sederhana, meskipun secara umum masalahnya kemungkinan besar tidak dapat diselesaikan, tetapi untuk masalah tertentu, dimungkinkan untuk menerapkan batasan yang membuatnya dapat dipecahkan, dengan beberapa jenis kemungkinan kesalahan yang berarti. <br><br>  Sebagai contoh, standar diperkenalkan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">POSIX realtime</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ARINC-653</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ITRON</a> .  Standar-standar ini, pada kenyataannya, membedakan kelas tugas yang dapat diselesaikan jika Anda mematuhi standar ini.  Atau studi dilakukan oleh laboratorium independen yang mempelajari apakah sifat-sifat OS tertentu cocok untuk memecahkan masalah target. <br><br><h2>  Jadi Embox RTOS atau bukan RTOS? </h2><br>  Menurut pendapat saya, untuk menjawab pertanyaan serupa, baik untuk Embox dan untuk OS lainnya, Anda hanya dapat bertanya: "Apa maksud Anda?".  Lebih tepatnya: "Apa yang Anda maksudkan dengan konsep waktu nyata?".  Yaitu, jika waktu pemrosesan interupsi menarik, dan apakah mungkin untuk memanggil penangan interupsi secara langsung, ini adalah satu hal, jika Anda perlu meningkatkan keandalan kerja, meskipun lambat, tetapi tentu saja jauh lebih kecil kemungkinannya gagal, ini adalah hal lain, kepatuhan dengan standar apa pun adalah yang ketiga, Verifikasi adalah yang keempat.  Bukan kebetulan bahwa klasik besar Andrei Tanenbaum, meskipun ia mengusulkan metode untuk meningkatkan prediktabilitas, menggunakan konsep sistem real-time, tetapi menahan diri dari definisi yang ketat. <br><br>  PS Pada saat penulisan ini, tidak ada satu RTOS yang terpengaruh. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441336/">https://habr.com/ru/post/id441336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441326/index.html">Berhentilah berbicara tentang â€œmenjaga keamanan dan privasi dengan seriusâ€</a></li>
<li><a href="../id441328/index.html">Tentang komputasi kuantum dan kehendak bebas</a></li>
<li><a href="../id441330/index.html">[spoiler] Movie Wandering Earth: Matahari hancur. Cina dan satu astronot Rusia dengan termos vodka akan menyelamatkan semua orang</a></li>
<li><a href="../id441332/index.html">Koloni. Bab 26: Port Demetrio</a></li>
<li><a href="../id441334/index.html">"Staf listrik" - sekarang jelas</a></li>
<li><a href="../id441338/index.html">Bagaimana kami membuat sistem pembayaran cryptocurrency: lima masalah utama</a></li>
<li><a href="../id441340/index.html">Warisan budaya Kazakhstan dalam model-3D</a></li>
<li><a href="../id441344/index.html">Melangkah ke langit. Kisah jujur â€‹â€‹tentang hasrat serius terjun payung</a></li>
<li><a href="../id441346/index.html">Meet A Content Strategist: Wawancara dengan Dmitry Kabanov, kurator Startup Digest Techstars dan Penasihat SXSW</a></li>
<li><a href="../id441348/index.html">Routing dan balancing langsung dengan NFT vs Nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>