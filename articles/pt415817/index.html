<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏽 🤾🏾 👶🏽 Fazemos um overclock do backup. Palestra Yandex 🛀🏻 🏴 👨🏻‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Várias palestras programadas serão baseadas no primeiro Y. Subbotnik em bancos de dados realizados na primavera . Primeiro, o desenvolvedor Andrei Bor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fazemos um overclock do backup. Palestra Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/415817/">  Várias palestras programadas serão baseadas no primeiro Y. Subbotnik em bancos de dados realizados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na primavera</a> .  Primeiro, o desenvolvedor Andrei Borodin falou no Y. Subbotnik.  Ele falou sobre o WAL-G, uma ferramenta simples e eficaz para fazer backup do PostgreSQL na nuvem, bem como algoritmos e tecnologias que permitem ao WAL-G criar backups mais rapidamente.  A principal característica do WAL-G são os backups delta.  Na palestra, você aprenderá sobre a implementação deles e como o suporte a essa tecnologia está se desenvolvendo no PostgreSQL. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bXuN4Na0cEo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  oi!  Sou desenvolvedor Yandex de Yekaterinburg.  Para a tecnologia de backup rápido.  Fazemos backup há algum tempo; houve relatos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Vladimir Borodin</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Evgeny Dyukov</a> sobre como pesquisamos e o que desenvolvemos para armazenar dados com segurança, confiabilidade, conveniência e eficiência.  Esta série é dedicada aos mais recentes desenvolvimentos nesta área. <br><br>  Vamos falar sobre backups no PostgreSQL em princípio.  O utilitário padrão para transferência de dados - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pg_dump</a> - é definido como um utilitário do console que cria um arquivo com uma representação lógica dos seus dados. <br><a name="habracut"></a><br>  O fato de ser uma cópia lógica é bastante conveniente.  Você sempre pode transferir dados entre versões diferentes, pode cortar seu banco de dados em pedaços, e esta é uma ferramenta padrão que, por exemplo, vem em uma caixa com o utilitário de administração PgAdmin. <br><br><img src="https://habrastorage.org/webt/3j/zs/kh/3jzskhrdbobeb5pfvdyebjvv9bi.jpeg"><br>  Primeiro de tudo, sobre o pg_dump, você precisa saber que esta é uma ferramenta de desenvolvedor. <br><br>  Esta não é uma ferramenta de manutenção de banco de dados.  O pg_dump não foi projetado para funcionar com um banco de dados altamente carregado. <br><br><img src="https://habrastorage.org/webt/rb/sk/yf/rbskyfdmcwqb9ctu6-idvcj6ywm.jpeg"><br>  Suponha que tudo seja sério e você queira usar a tecnologia "Recuperação pontual", que usa a API do PostgreSQL para trabalhar com backups online.  Você chama a função pg_start_backup e faz uma cópia do arquivo do banco de dados.  De fato, pg_start_backup força o banco de dados a executar o CHECKPOINT;  e habilite gravações de página inteira no log de gravação antecipada.  A cópia do banco de dados que você cria quando chama a API não é uma cópia consistente dos dados.  Você também precisa de um log write-ahead para poder restaurar seu banco de dados durante a chamada pg_stop_backup, ou seja, no final do backup. <br><br><img src="https://habrastorage.org/webt/0a/aw/v1/0aawv1w0gp9okkkbjuja0k-ywg4.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do slide</a></sup></sub> </h5><br>  Após o término da remoção do backup e na presença de um registro inicial, você pode recuperar o ponto desejado na vida útil do seu banco de dados. <br><br>  O utilitário pg_basebackup é fornecido na caixa, que implementa toda essa tecnologia de forma canônica e permite fazer backup com a funcionalidade mínima necessária. <br><br>  Se você ainda é mais sério do que antes, usa algum tipo de software de gerenciamento de backup e, geralmente, é o Barman. <br><br>  Ele tem várias vantagens.  A principal vantagem é um utilitário muito comum, possui uma comunidade enorme, um grande número de perguntas sobre o Stack Overflow. <br><br><img src="https://habrastorage.org/webt/hk/_s/xx/hk_sxxzzua_byoapw4kvxdexymm.jpeg"><br><br>  Você só precisa pegar um servidor de backup e fazer backup de todo o seu PostgreSQL lá.  Isso é muito conveniente - desde que um servidor de backup seja suficiente para você. <br><br>  Assim que você tiver muitos servidores de backup, precisará monitorar se algum deles está cheio.  Em caso de falha de algum servidor de backup, você precisa entender quais bancos de dados estão em perigo.  Você precisa entender em princípio onde copiar um novo cluster de banco de dados ao criá-lo. <br><br>  Existe um utilitário de remoção de backup muito mais simples chamado WAL-E. <br><br><img src="https://habrastorage.org/webt/jf/l1/a0/jfl1a07ymxdr0luksh1zg_cb7ii.jpeg"><br>  O WAL-E executa quatro comandos principais.  O comando WAL-PUSH envia um arquivo WAL para a nuvem e o WAL-FETCH pega um arquivo WAL se restore_command precisar ser restaurado. <br><br>  Também há BACKUP-PUSH (implementa a remoção da API de backup) e BACKUP-FETCH (coleta todos os dados da nuvem).  Os dados são armazenados na nuvem; portanto, você não precisa monitorar nada, isso já é um problema de serviço em nuvem, como garantir a disponibilidade dos seus dados quando você precisar.  Esta é provavelmente a principal vantagem do WAL-E. <br><br><img src="https://habrastorage.org/webt/tz/2e/h5/tz2eh51uc_vtsp-oylcltmgep1i.jpeg"><br>  Existem muitas funcionalidades.  Há uma lista de backups, há uma política de retenção, ou seja, queremos armazenar backups nos últimos sete dias, por exemplo, ou nos últimos cinco backups, algo assim.  E o WAL-E pode fazer backup para uma enorme variedade de serviços em nuvem: S3, Azure, Google, pode chamar o sistema de arquivos local de nuvem. <br><br><img src="https://habrastorage.org/webt/n9/wj/uz/n9wjuz9n4tg_w8cvkkbp4g7_imi.jpeg"><br>  Tem várias propriedades.  Primeiro, ele é escrito em Python e usa ativamente o pipeline do Unix, em parte por causa disso, possui dependências e não é muito produtivo.  Isso é normal porque o WAL-E se concentra na facilidade de uso e na configuração, para que você não cometa erros ao fazer um plano de backup.  E essa é uma ideia muito boa. <br><br>  Existem muitos recursos escritos no WAL-E, e onde os autores o desenvolveram ainda não foi muito claro para os autores.  Surgiu a ideia de que eu precisava de uma nova ferramenta. <br><br><img src="https://habrastorage.org/webt/ov/tj/ed/ovtjeduv1bhofpvnrbv2oong4ok.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do slide</a></sup></sub> </h5><br>  Sua principal característica é que ele é reescrito no Go, não possui quase dependências externas, se você não usar criptografia externa, e é muito mais produtivo. <br><br><img src="https://habrastorage.org/webt/fl/pl/h2/flplh2x6ugfya5ydixenji9hmxg.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do slide</a></sup></sub> </h5><br>  O WAL-G foi originalmente criado por dois autores do Citus Data, e a principal vantagem é mostrada neste histograma - a velocidade de envio dos "eixos".  Vemos que o WAL-E é rápido, pode ser qualquer coisa, pode ser uma grande coluna perto de zero. <br><br><img src="https://habrastorage.org/webt/r_/si/dn/r_sidnqgiipagw5sosfzo8ze90e.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do slide</a></sup></sub> </h5><br>  O WAL-G possui uma largura de banda bastante estável.  Em testes no Citus Data, ele mostrou que envia de forma estável cerca de 800 Mb / s de "eixos". <br><br>  Além disso, no WAL-G, por exemplo, escrevi um recurso que implementa backup de uma réplica.  Você não precisa carregar seu mestre de banco de dados com uma carga de leitura; é possível remover o backup da réplica. <br><br><img src="https://habrastorage.org/webt/ck/bl/jj/ckbljjqa0ujh35rnlmncx5guauw.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do slide</a></sup></sub> </h5><br>  Mas há um pequeno problema.  No momento em que você começa a fazer o backup, nomeie-o de alguma forma.  O nome inclui uma linha do tempo, que será alterada se uma réplica for promovida.  Se ocorrer um failover na cadeia de réplicas antes da réplica com a qual você está fazendo backup, você notará algumas das réplicas, a linha do tempo será alterada.  O WAL-G entende que essa situação não é consistente, pois, tendo um nome na linha do tempo antiga, o nome promete que você poderá continuar o desenvolvimento do histórico do banco de dados em qualquer direção existente.  Mas isso não é verdade.  Você já foi a uma das direções; não pode pular para outra linha do tempo com o carro de volta.  Portanto, o WAL-G entende essa situação e não faz upload de um arquivo JSON fiscal na nuvem.  Você cria uma cópia física.  Mas é necessária intervenção do administrador para que esta cópia possa ser usada. <br><br><img src="https://habrastorage.org/webt/no/yo/nv/noyonvp7l8d-0myokmscgjts31w.jpeg"><br><br>  Implementamos cópias delta no WAL-G, também trabalhei nesse desenvolvimento.  Isso permite que você obtenha menos dados no próximo backup de base, não faça uma cópia dessas páginas de dados que não foram alteradas no backup anterior. <br><br><img src="https://habrastorage.org/webt/dt/cn/ag/dtcnaglkk_z3i6rsm_hvs56m28o.jpeg"><br>  Ao configurar o WAL-G, você especifica o número de etapas que estão mais distantes do backup base, do backup delta e da política de cópia delta.  Você faz uma cópia do último delta existente ou faz um delta do backup completo original.  Isso é necessário no caso em que o mesmo componente do banco de dados sempre muda no seu banco de dados, os mesmos dados estão constantemente mudando. <br><br>  Por que, em princípio, precisamos de cópias delta do banco de dados?  Em teoria, você tem um WAL e pode rolar para qualquer lugar. <br><br>  Em um servidor ocupado, a reprodução do WAL de cinco segundos físicos do passado pode levar quatro segundos físicos do presente.  Se você for solicitado a rolar o WAL em quatro dias, isso significa que é possível que a pessoa que solicita isso espere mais três dias.  Nem sempre é uma situação aceitável. <br><br>  Você precisa de backups básicos para todos os dias, mas, no entanto, não é possível armazenar 7 ou 14 cópias completas do seu banco de dados, mesmo que o WAL-G os arquive, ele ainda será muito grande.  E, neste caso, cópias delta ajudam. <br><br><img src="https://habrastorage.org/webt/xw/aw/-l/xwaw-ll2y9911p6gjynx3dxhfb0.jpeg"><br>  Ao desenvolver cópias delta, vários formatos possíveis de arquivos de dados foram discutidos.  Antes de tudo, o formato foi proposto; quando não perturbamos a página, simplesmente a anulamos.  Mas chegamos à conclusão de que essa não é uma maneira muito eficaz, os zeros são efetivamente compactados, mas recusamos esse método de armazenamento, porque é difícil depurá-lo em caso de situações de emergência. <br><br><img src="https://habrastorage.org/webt/y1/cd/m-/y1cdm-xvhv7sq-4wt8e3y_xzaia.jpeg"><br>  A próxima tecnologia considerada é primeiro armazenar o número do bloco e depois o bloco alterado.  Mas aqui nos deparamos com a peculiaridade do armazenamento em arquivos TAR, que precisamos primeiro indicar o tamanho dos arquivos TAR nos quais armazenamos nossa cópia delta e depois começar a gravá-la.  Eu queria fazer a implementação da tecnologia com um mínimo de RAM consumida, então tivemos que usar o terceiro formato no qual lemos completamente cada arquivo de dados, procuramos as páginas de dados alteradas, primeiro armazenamos o número dos blocos alterados no arquivo TAR e somente então os próprios blocos alterados. <br><br><img src="https://habrastorage.org/webt/ew/le/eo/ewleeouqovcrezeke5wv6nndmby.jpeg"><br><img src="https://habrastorage.org/webt/mj/qx/rg/mjqxrg9h-jhu0nlatbxarh1jaaw.jpeg"><br><br>  Esse recurso ainda não foi implementado.  Estou olhando para ela ou procurando alguém que queira fazer uma solicitação pull no WAL-G.  Ao se recuperar de uma cópia delta, o banco de dados sobrevive a cada uma das reencarnações do banco de dados em cada etapa do backup delta.  Às vezes, no meio da vida, alguns arquivos são excluídos.  Ao mesmo tempo, não precisaríamos nos preocupar com a condição deles se eles fossem excluídos de qualquer maneira e depois recriados a partir da cópia delta.  Esse não parece ser um recurso muito complicado; portanto, se você estiver interessado em escrever algo sobre o Go, consulte esse recurso. <br><br><img src="https://habrastorage.org/webt/g3/fa/7d/g3fa7d6otwscpktvrov045nvmni.jpeg"><br>  Agende sobre o uso de rede, CPU e disco.  No WAL-E, como podemos ver, o backup aqui ainda não terminou, começou às uma da manhã em Moscou e não terminou no último relatório que vemos.  O cronograma do WAL-G terminou, funciona mais rápido e é muito mais uniforme em termos de consumo de recursos. <br><br>  O mais interessante é o gráfico do consumo de recursos durante uma cópia delta.  Vemos que todos os recursos se tornaram quase zero.  A carga na CPU é quase a carga padrão no banco de dados; à noite, algumas consultas são executadas.  Vemos um grande ponto de leitura.  Eu também lido com isso, também gostaria de receber um pedido ou farei eu mesmo no verão.  O ponto principal é que ainda precisamos ler nossos dados para descobrir o que mudou neles.  Esta leitura poderia ter sido evitada. <br><br><img src="https://habrastorage.org/webt/6g/bz/w7/6gbzw7p2zf7bbczdq3hnc-z1ni8.jpeg"><br><br>  Há uma exclusão no WAL-G quando indicamos o número de backups ou a data a partir da qual precisamos armazenar todos os WALs e todos os backups de base.  E o WAL-G já está lidando com a questão de quais WALs e backups básicos são necessários.  Até o momento, não temos recursos que excluam tudo.  No WAL-E, é também uma ocasião para uma solicitação de recebimento.  Um comando interessante DELETE TUDO ainda não foi implementado. <br><br><img src="https://habrastorage.org/webt/5q/1t/aw/5q1tawrrz1gj-l4wu1igxubfd4q.jpeg"><br><br>  Há uma lista de backups. <br><br><img src="https://habrastorage.org/webt/kq/gs/mw/kqgsmwqqiezwwifwb8puxmzlugm.jpeg"><br>  Definimos a variável de ambiente necessária para o WAL-G funcionar e chamamos o utilitário do console WAL-G.  Os backups que precisamos visualizar são exibidos. <br><br><img src="https://habrastorage.org/webt/id/uv/rg/iduvrgdmb1nca0nbfcpvs0cxfc8.jpeg"><br>  O WAL-G implementa várias tecnologias para backups paralelos e geralmente várias operações.  Por exemplo, essa tecnologia é usada para enviar "eixos" para o arquivo.  Assim que o PostgreSQL chama archive_command para enviar um arquivo, o WAL-G procura ver se há mais arquivos por perto prontos. <br><br>  Em geral, esse não é um recurso muito documentado, é muito estável nas versões mais recentes do PostgreSQL; muitas tecnologias o utilizam.  Examinamos se há arquivos WAL prontos no status de arquivamento e também os enviamos junto com o que pediu para enviar o banco de dados para o arquivamento.  E quando o PostgreSQL pede que eles enviem, nós já os enviamos, estamos prontos.  Isso acelera significativamente o envio de WALs em bases carregadas e permite que você não seja um thread único.  Normalmente, o PostgreSQL prepara um arquivo, depois espera que ele vá, prepara o próximo.  Conseguimos evitar esse trabalho consistente. <br><br><img src="https://habrastorage.org/webt/pc/3k/5f/pc3k5fkukjj7o5zqxm7hsjr3way.jpeg"><br>  Durante o WAL-FETCH, quando o cluster é restaurado, também tentamos fazer o download dos N arquivos a seguir necessários e equilibrar as pausas entre o início da pré-definição de novos arquivos WAL, para que possamos utilizar todos os recursos que temos o máximo possível: seja executado na rede ou executar em um disco em casos raros. <br><br><img src="https://habrastorage.org/webt/pd/v2/mn/pdv2mnfn4_ne1jbp00nhl35n7y4.jpeg"><br>  Tudo isso é definido por variáveis ​​de ambiente. <br><br><img src="https://habrastorage.org/webt/oe/ro/k5/oerok5u-varh4b3rcwq4dgwarmm.jpeg"><br>  Também há simultaneidade de fazer uma cópia.  Embora esse recurso não esteja presente em várias versões - A.B foi lançada na versão 0.1.10 em junho de 2018 -, já que o paralelismo da leitura do disco permite garantir a execução em uma rede ou em um disco.  Isso não é muito bom com um banco de dados carregado.  O WAL-E tinha um recurso que permitia a otimização.  Até agora, não temos isso.  É necessário limitar a velocidade da remoção do backup, para que a base possa viver sua própria vida e servir a carga. <br><br>  Nossa principal característica não é realmente sobre tecnologia. <br><br>  Dois anos atrás, Zhenya Dyukov implementou a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tecnologia delta-backup</a> para Barman, ainda não foi realizada, a comunidade ainda está discutindo isso. <br><br>  Há quase um ano, Zhenya corrigiu o bug do WAL-E e o enviamos por seis meses ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para o GitHub</a> - aprox. Ed.).  Muitas vezes, em soluções de código aberto, há um problema com o fato de que elas não são muito bem mantidas. <br><br><img src="https://habrastorage.org/webt/jy/hg/mf/jyhgmfxdz_srayrm8vsxdnq-a3q.jpeg"><br>  Com o WAL-G, tudo é bem simples: usamos e eu mantenho.  Se você ou você precisar de algo, basta relatar que tem um problema.  Vamos tentar resolvê-lo. <br><br>  A solicitação padrão da comunidade é simples - "vamos fazer isso mais". <br><br>  Mais criptografia, mais plataformas.  Talvez não apenas o PostgreSQL, mas o MySQL ainda faça backup ou algo mais?  Eu vejo algumas outras coisas. <br><br><img src="https://habrastorage.org/webt/yi/sg/ck/yisgckbaa1bhbae-ixrx_u-fetm.jpeg"><br>  Antes de tudo, agora, ao enviar o "eixo", pudemos entender quais blocos de banco de dados foram alterados, digitalize esses arquivos WAL e salve informações sobre o que foi alterado. <br><br>  E quando o cron chega com outro backup delta, não conseguimos digitalizar todo o banco de dados, arquivar esse dente da leitura do disco e apenas saber quais páginas precisamos arrastar para a nuvem. <br><br>  Tentamos usar a tecnologia de rastreamento de página.  Ele implementa o rastreamento de alterações de página no nível do kernel do banco de dados.  O backup é removido muito rapidamente.  O principal problema com o PTRACK é que ele é muito invasivo.  Ele contém muitas alterações no núcleo do PostgreSQL em locais muito sensíveis, portanto é improvável que seja adotado em breve. <br><br><img src="https://habrastorage.org/webt/4z/ea/px/4zeapxt_ji4odqmc57wnjpxilik.jpeg"><br>  Além disso, seus deltas são ligeiramente diferentes dos que temos agora.  Ao remover o delta baseado em LSN, removemos todas as alterações no arquivo delta ocorridas desde o início anterior até a hora atual. <br><br><img src="https://habrastorage.org/webt/ul/oh/pi/ulohpi0sz8mtyz5g018fxactms8.jpeg"><br>  No caso do PTRACK, obtemos alterações no arquivo delta, a partir do delta anterior recebido.  Não temos o tempo delta exato antes do início do backup, antes do início das alterações.  Este não é o principal problema do PTRACK, em geral, ele funciona bem, mas até agora é difícil de aceitar. <br><br><img src="https://habrastorage.org/webt/9-/qv/ou/9-qvouutaphuo35-ag0q_w1nnww.jpeg"><br>  O PTRACK não permite a remoção delta no modo LATEST_FULL, porque armazena um mapa de blocos alterados da remoção anterior deste mapa.  A Oracle tem uma tecnologia interessante, existem 8 cartões anteriores que eles salvam por precaução.  Talvez possamos fazer algo semelhante, mas até agora não estamos trabalhando nessa direção. <br><br><img src="https://habrastorage.org/webt/bx/do/z-/bxdoz-i2yzsnya6y6kzqbc30e3y.jpeg"><br><h5>  <sub><sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Link do slide</a></sup></sub> </h5><br>  Em setembro passado, tentei oferecer à comunidade uma tecnologia baseada no fato de que apenas adicionamos os ganchos necessários ao kernel e implementamos o rastreamento de páginas alteradas na extensão para que o patch de rastreamento de páginas não seja muito invasivo.  Depois de discutir essa tecnologia, chegamos à conclusão de que precisamos de vários protótipos e adicionaremos ganchos quando houver protótipos.  Talvez veremos como eles funcionam.  Atualmente, estou trabalhando em protótipos dessas extensões que poderiam usar ganchos do kernel para rastrear alterações no banco de dados. <br><br>  Há uma expressão na comunidade de que todo postgresista deve ter sua própria ferramenta de backup.  Isso é ruim.  Todo mundo faz suas próprias coisas, o que faz uma tarefa crítica.  Deve haver uma coisa em que tudo estará na caixa, tudo será perfeito em um mundo ideal. <br><br>  O que eu gostaria de ver em uma caixa no basebackup?  Gostaríamos de ver, provavelmente, arquivando na nuvem.  E cópias delta. <br><br><img src="https://habrastorage.org/webt/6w/ea/zh/6weazhzi3fkxbhvzz2tlrdj4ujg.jpeg"><br>  Eu também gostaria de compactação, simultaneidade, criptografia, limitação, listagem de backups, verificação, validação de backups ... Muitas coisas.  Entendemos que se tudo isso agora for oferecido à comunidade, resultará em várias dezenas de patches, que são bastante difíceis de discutir e implementar por meio do commitfest.  Portanto, agora ainda estamos usando uma ferramenta separada, mas há um desejo de dedicar tempo e tecnologia à comunidade para melhorar o PostgreSQL. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt415817/">https://habr.com/ru/post/pt415817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt415805/index.html">Modificação do módulo de barreira GSM Doorhan para controle da Internet</a></li>
<li><a href="../pt415809/index.html">Como usar soy, requirejs, backbone js em plugins para o Atlassian Jira</a></li>
<li><a href="../pt415811/index.html">AI, curso prático. Visão geral de redes neurais para classificação de imagens</a></li>
<li><a href="../pt415813/index.html">Algumas notas sobre o estado atual do Cloud Gaming</a></li>
<li><a href="../pt415815/index.html">Na vanguarda da ciência: uma análise dos artigos do arxiv.org</a></li>
<li><a href="../pt415819/index.html">Relatório do Clube de Roma de 2018, Capítulo 3.16: Governo Global</a></li>
<li><a href="../pt415821/index.html">A maneira de organizar uma casa "inteligente" com o controle elétrico mais amplo possível</a></li>
<li><a href="../pt415823/index.html">FindFace fecha para meros mortais</a></li>
<li><a href="../pt415829/index.html">Introdução às classes de dados</a></li>
<li><a href="../pt415831/index.html">Os Novos Dez Mandamentos de Roskosmos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>