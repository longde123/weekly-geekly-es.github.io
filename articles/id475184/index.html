<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¥üèª üàÅ üë©üèª‚Äçüíª Panggilan sistem Linux yang mewah üîä üò¢ üë©üèæ‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang dilihat oleh programmer ketika mulai bekerja dengan bahasa C? Dia melihat fopen , printf , scanf dan banyak lagi fungsi lainnya. Dia melihat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panggilan sistem Linux yang mewah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475184/"><p> <a href=""><img alt="ls / usr / share / man / man2 /" src="https://habrastorage.org/webt/ej/cn/w4/ejcnw4zqrqo_wee6kw-evxqziui.png"></a> </p><br><p> Apa yang dilihat oleh programmer ketika mulai bekerja dengan bahasa C?  Dia melihat <code>fopen</code> , <code>printf</code> , <code>scanf</code> dan banyak lagi fungsi lainnya.  Dia melihat segala macam <code>open</code> dan <code>mmap</code> - sepertinya, mengapa menyoroti mereka?  Tetapi, tidak seperti grup pertama, kedua fungsi ini ketika dijalankan pada kernel Linux adalah pemanggilan sistem ( <em>sebenarnya tidak</em> , hampir tidak pernah pemanggilan sistem hanya dapat disebut sebagai fungsi, dan karenanya <code>libc</code> berisi pembungkus yang mengemas ulang argumen dan terkadang, seperti dalam kasus dengan <code>open</code> , ganti panggilan sistem lama dengan yang baru yang lebih umum).  Secara umum, tidak seperti ribuan fungsi pustaka yang tersedia pada sistem GNU / Linux yang khas, antarmuka kernel memiliki jumlah titik masuk yang agak terbatas - dari urutan beberapa ratus, tetapi untuk ruang pengguna itu macet (misalnya, mengakses halaman yang hilang), untuk kernel - mode operasi standar. </p><br><p>  Dalam artikel ini saya akan memberi tahu Anda beberapa fakta menarik menurut saya.  Itu tidak akan memiliki rincian implementasi <code>futex</code> dan membosankan lainnya (mungkin).  Ini akan menjadi penyebab utama reaksi saya, "Dan apa, mungkinkah begitu?!?". </p><a name="habracut"></a><br><p>  Pertama, beberapa komentar pada teks sebelum kat: beberapa panggilan sistem memiliki antarmuka opsional dalam bentuk fungsi dari objek bersama yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">vDSO</a> , yang dimasukkan kernel ke dalam proses.  Ada beberapa fungsi seperti itu (sesuatu di sekitar empat, tetapi jumlah spesifik, tampaknya, mungkin tergantung pada versi kernel dan arsitektur) - ini semua jenis <code>time</code> dan <code>time</code> , yang, di satu sisi, sering digunakan, dan di sisi lain, mereka diimplementasikan tanpa beralih ke konteks kernel. </p><br><p>  Kedua, SIGSEGV tidak selalu berakhir dengan crash proses, tetapi kita akan membicarakan ini <code>userfaultfd</code> ketika datang ke <code>userfaultfd</code> . </p><br><p>  <strong>PENOLAKAN:</strong> Ingatlah bahwa menggunakan sebagian besar fitur yang disajikan di sini, Anda mengikat program Linux Anda.  Ini normal jika dengan cara ini Anda melakukan optimasi opsional untuk jenis sistem tertentu atau fitur tambahan yang jika tidak maka tidak akan ada.  Tetapi sebaliknya, saya sarankan untuk berpikir tentang cara membuat mundur lintas platform. </p><br><h2 id="obschie-voprosy">  Pertanyaan umum </h2><br><p>  Sebagai permulaan, bagaimana semua ini bisa di-debug?  Tentu saja <code>strace</code> akan membantu kami!  Karena rangkaian panggilan sistem terbatas, dan sebagian besar <code>strace</code> tahu "oleh penglihatan", itu akan menunjukkan tidak hanya "pointer 0x12345678 telah dilewati", tetapi akan menjelaskan apa yang sedang ditransfer ke arah ini atau itu dalam struktur ini.  Jika <code>strace</code> cukup segar, maka menggunakan opsi <code>-k</code> Anda dapat memintanya untuk mengeluarkan tumpukan panggilan. </p><br><div class="spoiler">  <b class="spoiler_title">Itu terlihat seperti ini</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ strace -k sleep 1 execve("/bin/sleep", ["sleep", "1"], 0x7ffe9f9cce30 /* 60 vars */) = 0 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(execve+0xb) [0xe601b] &gt; /usr/bin/strace(+0x0) [0xa279c] &gt; /usr/bin/strace(+0x0) [0xa41d2] &gt; /usr/bin/strace(+0x0) [0x7090b] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xf3) [0x271e3] &gt; /usr/bin/strace(+0x0) [0x7112a] brk(NULL) = 0x558936ded000 &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_error+0x20b) [0x1ccdb] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1cd2) [0x1b872] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] arch_prctl(0x3001 /* ARCH_??? */, 0x7fff593c0070) = -1 EINVAL ( ) &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1e25) [0x1b9c5] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] access("/etc/ld.so.preload", R_OK) = -1 ENOENT (    ) &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_error+0x10cb) [0x1db9b] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x3c12] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1e7b) [0x1ba1b] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3 &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_error+0x1238) [0x1dd08] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_debug_state+0x73a) [0x11d4a] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_exception_free+0x908) [0x189c8] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0xa362] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x41b5) [0xeb35] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_exception+0x65) [0x1ca85] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x4603) [0xef83] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x3c55] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1e7b) [0x1ba1b] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] fstat(3, {st_mode=S_IFREG|0644, st_size=254851, ...}) = 0 &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_error+0x1009) [0x1dad9] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_debug_state+0x761) [0x11d71] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_exception_free+0x908) [0x189c8] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0xa362] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x41b5) [0xeb35] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_exception+0x65) [0x1ca85] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x4603) [0xef83] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x3c55] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1e7b) [0x1ba1b] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] mmap(NULL, 254851, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fc49621c000 &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_error+0x1426) [0x1def6] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_debug_state+0x79d) [0x11dad] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_exception_free+0x908) [0x189c8] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0xa362] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x41b5) [0xeb35] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_exception+0x65) [0x1ca85] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x4603) [0xef83] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x3c55] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1e7b) [0x1ba1b] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] close(3) = 0 &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_error+0x10fb) [0x1dbcb] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_debug_state+0x780) [0x11d90] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_exception_free+0x908) [0x189c8] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0xa362] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x41b5) [0xeb35] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_exception+0x65) [0x1ca85] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x4603) [0xef83] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x3c55] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1e7b) [0x1ba1b] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3 &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_error+0x1238) [0x1dd08] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x7d40] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0xa3a8] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x41b5) [0xeb35] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_exception+0x65) [0x1ca85] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x4603) [0xef83] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x3c55] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1e7b) [0x1ba1b] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\360r\2\0\0\0\0\0"..., 832) = 832 &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_error+0x12f8) [0x1ddc8] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x7d79] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0xa3a8] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x41b5) [0xeb35] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_catch_exception+0x65) [0x1ca85] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(_dl_rtld_di_serinfo+0x4603) [0xef83] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x3c55] &gt; /lib/x86_64-linux-gnu/ld-2.30.so(__get_cpu_features+0x1e7b) [0x1ba1b] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x203c] &gt; /lib/x86_64-linux-gnu/ld-2.30.so() [0x1108] ...    ... brk(NULL) = 0x558936ded000 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(brk+0xb) [0x11755b] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__sbrk+0x67) [0x117617] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__default_morecore+0xd) [0x9fd3d] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(thrd_yield+0x2725) [0x9a745] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(thrd_yield+0x3943) [0x9b963] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(thrd_yield+0x3b2b) [0x9bb4b] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(thrd_yield+0x4d9e) [0x9cdbe] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(textdomain+0x740) [0x3be70] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x1d35) [0x35515] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0xbdf) [0x343bf] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x215) [0x339f5] &gt; /bin/sleep() [0x25f0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xf3) [0x271e3] &gt; /bin/sleep() [0x287e] brk(0x558936e0e000) = 0x558936e0e000 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(brk+0xb) [0x11755b] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__sbrk+0x91) [0x117641] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__default_morecore+0xd) [0x9fd3d] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(thrd_yield+0x2725) [0x9a745] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(thrd_yield+0x3943) [0x9b963] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(thrd_yield+0x3b2b) [0x9bb4b] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(thrd_yield+0x4d9e) [0x9cdbe] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(textdomain+0x740) [0x3be70] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x1d35) [0x35515] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0xbdf) [0x343bf] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x215) [0x339f5] &gt; /bin/sleep() [0x25f0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xf3) [0x271e3] &gt; /bin/sleep() [0x287e] openat(AT_FDCWD, "/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__open64_nocancel+0x4c) [0x11679c] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x1ce9) [0x354c9] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0xbdf) [0x343bf] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x215) [0x339f5] &gt; /bin/sleep() [0x25f0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xf3) [0x271e3] &gt; /bin/sleep() [0x287e] fstat(3, {st_mode=S_IFREG|0644, st_size=8994080, ...}) = 0 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__fxstat64+0x19) [0x1107b9] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x1e33) [0x35613] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0xbdf) [0x343bf] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x215) [0x339f5] &gt; /bin/sleep() [0x25f0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xf3) [0x271e3] &gt; /bin/sleep() [0x287e] mmap(NULL, 8994080, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fc495795000 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(mmap64+0x26) [0x11baf6] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x1e5d) [0x3563d] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0xbdf) [0x343bf] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x215) [0x339f5] &gt; /bin/sleep() [0x25f0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xf3) [0x271e3] &gt; /bin/sleep() [0x287e] close(3) = 0 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__close_nocancel+0xb) [0x1165bb] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x1eab) [0x3568b] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0xbdf) [0x343bf] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(setlocale+0x215) [0x339f5] &gt; /bin/sleep() [0x25f0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xf3) [0x271e3] &gt; /bin/sleep() [0x287e] nanosleep({tv_sec=1, tv_nsec=0}, NULL) = 0 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(nanosleep+0x17) [0xe5d17] &gt; /bin/sleep() [0x5827] &gt; /bin/sleep() [0x5600] &gt; /bin/sleep() [0x27b0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xf3) [0x271e3] &gt; /bin/sleep() [0x287e] close(1) = 0 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__close_nocancel+0xb) [0x1165bb] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(_IO_file_close_it+0x70) [0x92fc0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(fclose+0x166) [0x85006] &gt; /bin/sleep() [0x5881] &gt; /bin/sleep() [0x2d27] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_secure_getenv+0x127) [0x49ba7] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(exit+0x20) [0x49d60] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xfa) [0x271ea] &gt; /bin/sleep() [0x287e] close(2) = 0 &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__close_nocancel+0xb) [0x1165bb] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(_IO_file_close_it+0x70) [0x92fc0] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(fclose+0x166) [0x85006] &gt; /bin/sleep() [0x5881] &gt; /bin/sleep() [0x2d4d] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_secure_getenv+0x127) [0x49ba7] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(exit+0x20) [0x49d60] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xfa) [0x271ea] &gt; /bin/sleep() [0x287e] exit_group(0) = ? +++ exited with 0 +++ &gt; /lib/x86_64-linux-gnu/libc-2.30.so(_exit+0x36) [0xe5fe6] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_secure_getenv+0x242) [0x49cc2] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(exit+0x20) [0x49d60] &gt; /lib/x86_64-linux-gnu/libc-2.30.so(__libc_start_main+0xfa) [0x271ea] &gt; /bin/sleep(+0x0) [0x287e]</code> </pre> </div></div><br><p>  Benar, nama file sumber dan nomor baris tidak ditampilkan di sini.  <code>addr2line</code> akan membantu <code>addr2line</code> (jika informasi ini pada prinsipnya ada, tentu saja). </p><br><p>  Ada pertanyaan kedua: beberapa panggilan sistem tidak memiliki pembungkus di <code>libc</code> .  Kemudian Anda dapat menggunakan pembungkus universal yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>syscall</code></a> : </p><br><pre> <code class="cpp hljs"> syscall(SYS_kcmp, getpid(), getpid(), KCMP_FILE, <span class="hljs-number"><span class="hljs-number">1</span></span>, fd)</code> </pre> <br><h2 id="fayl-----eto-ochen-uzh-strannyy-predmet">  File adalah hal yang sangat aneh ... </h2><br><p>  Panggilan sistem bukan hanya cara untuk meminta kernel mengakses perangkat keras atas nama proses.  Ini juga merupakan API universal yang dapat dimengerti oleh semua perpustakaan dalam sistem.  Jadi, jika fungsionalitas yang Anda butuhkan tidak didukung di perpustakaan, itu mungkin akan bekerja secara otomatis jika Anda meminta kernel dengan benar.  Selain itu, bagian dari "pengaturan" proses diwariskan oleh <code>execve</code> , sehingga Anda dapat mencoba melakukan ini tanpa kruk rumit dengan hanya membentuk negara dengan benar sebelum memulai proses (sesuatu seperti "mengapa mentransfer <code>stderr</code> ke file secara manual, jika Anda bisa membuka file dan melakukan FD # 2 untuk proses anak "). </p><br><p>  Suatu kali, saya perlu mengurangi urutan paket jaringan dari sebuah file.  Pada titik tertentu, jumlah kruk melebihi semua batas yang masuk akal, dan saya memutuskan bahwa tidak mungkin <code>libpcap</code> akan lebih rumit daripada yang saya tulis, terlebih lagi, itu standar, dan ada alat yang diterima secara umum untuk membuka file-file ini.  Ternyata menggunakan <code>libpcap</code> untuk membaca dump hampir sama sulitnya dengan <code>fopen</code> untuk membaca file: Anda cukup membuka dump dengan <code>pcap_(f)open_offline</code> dan mengambil paket melalui <code>pcap_next_ex</code> .  Itu saja!  Yah, masih layak untuk menutup tempat sampah setelah selesai bekerja ... </p><br><p>  Tapi inilah masalahnya: tampaknya <code>libpcap</code> tidak dapat membaca dari memori.  Mungkin dia bisa, tentu saja, jika Anda menyelidiki hal itu, tetapi untuk "laboratorium" kami, kami akan membayangkan bahwa ia tidak bisa. </p><br><p>  Jadi, contoh model: kita menunggu <code>stdin</code> urutan byte, setelah itu ada dump sejajar dengan 4 byte.  Saya mengerti bahwa Anda dapat menggunakan input buffered dan beberapa <code>ungetc</code> (karena <code>libpcap</code> masih memerlukan <code>FILE *</code> ), tetapi dalam kasus umum, kita dapat membukanya saat bepergian, misalnya, atau perpustakaan dapat bekerja secara langsung dengan <code>read</code> / <code>write</code> . </p><br><h3 id="reshenie-1-memfd_create">  Solusi 1: memfd_create </h3><br><p>  <code>memfd_create</code> sistem <code>memfd_create</code> memungkinkan <code>memfd_create</code> membuat deskriptor file "umumnya anonim".  File ada di memori dan ada sementara setidaknya satu deskriptor terbuka di sana.  Dalam kasus yang paling sederhana, Anda hanya mendapatkan deskriptor seperti itu, menulis data ke sana melalui <code>write</code> , mundur <code>lseek</code> , dan dengan <code>fdopen</code> beri tahu <code>libc</code> tentang hal itu: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = memfd_create(<span class="hljs-string"><span class="hljs-string">"pcap-dump-contents"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); write(fd, buf, length); lseek(fd, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_SET); FILE *file = fdopen(fd, <span class="hljs-string"><span class="hljs-string">"r"</span></span>);</code> </pre> <br><p>  Nama file yang diteruskan dengan argumen pertama akan ditampilkan dalam symlink di <code>/proc/&lt;PID&gt;/fd</code> : </p><br><pre> <code class="plaintext hljs">$ ls -l /proc/31747/fd  0 lr-x------ 1 trosinenko trosinenko 64  10 13:12 0 -&gt; /path/to/128test.pcap lrwx------ 1 trosinenko trosinenko 64  10 13:12 1 -&gt; /dev/pts/17 lrwx------ 1 trosinenko trosinenko 64  10 13:12 2 -&gt; /dev/pts/17 lrwx------ 1 trosinenko trosinenko 64  10 13:12 23 -&gt; '/home/trosinenko/.cache/appstream-cache-AH3OA0.mdb (deleted)' lrwx------ 1 trosinenko trosinenko 64  10 13:12 3 -&gt; '/memfd:pcap-dump-contents (deleted)' lrwx------ 1 trosinenko trosinenko 64  10 13:12 57 -&gt; 'socket:[41036]'</code> </pre> <br><h3 id="reshenie-2-open-s-flagom-o_tmpfile">  Solusi 2: buka dengan bendera O_TMPFILE </h3><br><p>  Di Linux, dimulai dengan versi, saat membuat file, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>  O_TMPFILE</code></a> dan nama direktori alih-alih nama file.  Akibatnya, file tersebut, seperti yang biasa dikatakan oleh satu karakter sastra (kira-kira), <em>tampaknya ada di sana, tetapi tidak ada</em> ... Saya tidak tahu apakah data ditulis ke disk, tetapi mungkin tergantung pada sistem file (ngomong-ngomong, itu harus mendukung mode ini) .  File masih hilang ketika tautan terakhir ditutup, tetapi bisa dilampirkan ke pohon direktori menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>linkat</code></a> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = open(<span class="hljs-string"><span class="hljs-string">"."</span></span>, O_RDWR | O_TMPFILE, S_IRUSR | S_IWUSR); assert(fd != <span class="hljs-number"><span class="hljs-number">-1</span></span>); assert(write(fd, buffer + offset, len - offset) == len - offset); assert(lseek(fd, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_SET) == <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *link_to = getenv(<span class="hljs-string"><span class="hljs-string">"LINK_TO"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (link_to != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> path[<span class="hljs-number"><span class="hljs-number">128</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(path, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(path), <span class="hljs-string"><span class="hljs-string">"/proc/self/fd/%d"</span></span>, fd); linkat(AT_FDCWD, path, AT_FDCWD, link_to, AT_SYMLINK_FOLLOW); }</code> </pre> <br><p>  Selain kesempatan untuk tidak menderita dengan penamaan file, memungkinkan untuk mengisi file, mengkonfigurasi hak, dll., Dan kemudian secara atom menghubungkan ke pohon direktori. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh (untuk kedua pendekatan)</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> NDEBUG </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    assert  -   # undef NDEBUG #endif #include &lt;sys/mman.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;signal.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;pcap.h&gt; //     PCAP (   -- . ) static const uint32_t pcap_mgc = 0xA1B2C3D4; char buffer[1 &lt;&lt; 20]; int main() { int len = read(0, buffer, sizeof(buffer)); //  -      "", //     pcap_mgc,   //   4  .   ... int offset = -1; for (int i = 0; i &lt; len; i += 4) { if (*(uint32_t *)(buffer + i) == pcap_mgc) { offset = i; break; } } if (offset &gt;= 0) { printf("Found PCAP dump at offset %d\n", offset); } else { fprintf(stderr, "No PCAP dump found.\n"); exit(1); } //   ,  libpcap ,   //   . #if 0 int fd = memfd_create("pcap-dump-contents", 0); assert(fd != -1); assert(write(fd, buffer + offset, len - offset) == len - offset); assert(lseek(fd, 0, SEEK_SET) == 0); #else int fd = open(".", O_RDWR | O_TMPFILE, S_IRUSR | S_IWUSR); assert(fd != -1); assert(write(fd, buffer + offset, len - offset) == len - offset); assert(lseek(fd, 0, SEEK_SET) == 0); const char *link_to = getenv("LINK_TO"); if (link_to != NULL) { char path[128]; snprintf(path, sizeof(path), "/proc/self/fd/%d", fd); linkat(AT_FDCWD, path, AT_FDCWD, link_to, AT_SYMLINK_FOLLOW); } #endif raise(SIGSTOP); //    /proc/PID/fd/ //      - ... FILE *file = fdopen(fd, "r"); char errbuf[PCAP_ERRBUF_SIZE]; pcap_t * dump = pcap_fopen_offline(file, errbuf); assert(dump != NULL); struct pcap_pkthdr *hdr; const uint8_t *data; while (pcap_next_ex(dump, &amp;hdr, &amp;data) == 1) { printf("Read packet: full length = %d bytes, available %d bytes.\n", hdr-&gt;len, hdr-&gt;caplen); } return 0; }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ fallocate -l 128 zero128 $ cat zero128 test.pcap &gt; 128test.pcap $ ./memfd &lt; 128test.pcap Found PCAP dump at offset 128 Read packet: full length = 105 bytes, available 105 bytes. Read packet: full length = 105 bytes, available 105 bytes. Read packet: full length = 66 bytes, available 66 bytes. Read packet: full length = 385 bytes, available 385 bytes. Read packet: full length = 66 bytes, available 66 bytes. ...</code> </pre> </div></div><br><h2 id="userfaultfd-obrabotka-oshibok-pamyati-v-userspace">  userfaultfd: menangani kesalahan memori di userspace </h2><br><p>  Saya pikir tidak akan ada sesuatu yang sangat baru dalam mengatakan bahwa pada sistem seperti UNIX, deskriptor file tidak menunjukkan apa-apa.  Misalnya, di Linux dapat berupa soket, pipa, eventfd, atau bahkan tautan ke program ebpf.  Tapi mungkin contoh ini masih akan mengejutkan Anda.  Pada awal artikel saya berbicara tentang fakta bahwa kesalahan halaman adalah hal yang umum untuk kernel: swap, copy-on-write, itu saja ... Ketika proses pengguna "meleset", SIGSEGV dikirim ke sana.  Sejauh yang saya tahu, kontrol kembali dari handler SIGSEGV yang dihasilkan oleh kernel adalah perilaku yang tidak terdefinisi, dan meskipun demikian, ada perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">libsigsegv GNU</a> yang menggeneralisasi fitur penanganan kesalahan akses memori pada berbagai platform, bahkan Windows <strong>(PERHATIAN: lisensi GPL, jika tidak siap untuk mendistribusikan program Anda, jangan gunakan libsigsegv)</strong> .  Belum lama ini, metode yang sepenuhnya didokumentasikan muncul di Linux, yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>userfaultfd</code></a> : menggunakan pemanggilan sistem dengan nama yang sama, Anda membuka deskriptor file, membaca dan menulis yang struktur perintahnya adalah perintah. </p><br><p>  Dengan deskriptor file seperti itu, Anda dapat menandai serangkaian alamat virtual untuk proses Anda.  Setelah itu, pada akses pertama ke setiap halaman memori yang ditandai, aliran akan tertidur, dan membaca dari deskriptor file akan mengembalikan informasi tentang apa yang terjadi.  Setelah itu, pawang akan mengisi struktur respons dengan pointer ke data yang perlu digunakan untuk menginisialisasi halaman "masalah", kernel akan menginisialisasi dan membangunkan aliran yang mengalir.  Dalam hal ini, diasumsikan bahwa ada aliran terpisah, yang tugasnya termasuk membaca perintah dari deskriptor dan mengeluarkan jawaban.  <em>Secara umum, informasi lain <code>userfaultfd</code> dapat diperoleh melalui <code>userfaultfd</code> , misalnya, beberapa pemberitahuan tentang proses perubahan kartu virtual.</em> </p><br><div class="spoiler">  <b class="spoiler_title">Contoh penggunaan</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> NDEBUG </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    assert  -   # undef NDEBUG #endif #include &lt;linux/userfaultfd.h&gt; #include &lt;syscall.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;unistd.h&gt; #include &lt;pthread.h&gt; #include &lt;assert.h&gt; #include &lt;stdint.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; // -,   sysconf... #define PAGE_SIZE 4096 #define PAGE_MASK (PAGE_SIZE - 1) static void *thread_fn(void * arg) { int uffd = (intptr_t)arg; struct uffd_msg msg; // ,    hugepages... uint8_t *replacement_page = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1 ,0); while(1) { assert(read(uffd, &amp;msg, sizeof msg) &gt; 0); //    ,    if (msg.event == UFFD_EVENT_PAGEFAULT) { uintptr_t addr = msg.arg.pagefault.address; fprintf(stderr, "Fault: addr = 0x%zx\n", addr); //       uint8_t *page_addr = (uint8_t *)((uintptr_t)addr &amp; ~PAGE_MASK); //  "" ,  ""! memset(replacement_page, 0xAB, PAGE_SIZE); //     struct uffdio_copy copy; copy.src = (uintptr_t)replacement_page; copy.dst = (uintptr_t)page_addr; copy.mode = 0; // ,  --   copy.copy = 0; //   --      copy.len = PAGE_SIZE; assert(ioctl(uffd, UFFDIO_COPY, &amp;copy) != -1); } } } static int init_userfaultfd(void) { //   int uffd = syscall(__NR_userfaultfd, 0); // ,       struct uffdio_api api; api.api = UFFD_API; api.features = 0; assert(ioctl(uffd, UFFDIO_API, &amp;api) != -1); fprintf(stderr, "UFFD open\n"); //  - pthread_t thread; memset(&amp;thread, 0, sizeof(thread)); // ...    int  void *? pthread_create(&amp;thread, 0, thread_fn, (void *)(intptr_t)uffd); return uffd; } static void register_region(int uffd, void * aligned_addr, size_t size) { struct uffdio_register reg; memset(&amp;reg, 0, sizeof reg); reg.range.start = (uintptr_t)aligned_addr; reg.range.len = size; reg.mode = UFFDIO_REGISTER_MODE_MISSING; assert (ioctl(uffd, UFFDIO_REGISTER, &amp;reg) != -1); } int main() { void *addr = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); int uffd = init_userfaultfd(); register_region(uffd, addr, PAGE_SIZE); fprintf(stderr, "Before reading\n"); fprintf(stderr, "Data at %p: %x\n", addr, *(volatile int *)addr); return 0; }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ ./userfaultfd UFFD open Before reading Fault: addr = 0x7f46f40d5000 Data at 0x7f46f40d5000: abababab</code> </pre> </div></div><br><h2 id="laquoklyuchevoy-vopros-matematiki-ne-vsyo-li-ravnoraquo-c">  "Pertanyaan kunci matematika: apakah semuanya sama" ¬© </h2><br><p>  Bagaimana jika Anda perlu mencari tahu apakah deskriptor file ini merujuk ke <code>stdin</code> ?  Tampaknya <code>if (fd == 0) ...</code> - dan hanya itu.  Baiklah, ok ... </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;unistd.h&gt; #include &lt;stdio.h&gt; int main() { int fd = dup(0); printf("stdin is fd %d, too\n", fd); if (fd == 0) printf("stdin"); else printf("not stdin"); return 0; }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ gcc kcmp.c -o kcmp $ ./kcmp stdin is fd 3, too not stdin</code> </pre> <br><p>  Ups ... Pegangannya agak mirip, tapi alias berbeda.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRIU</a> - Checkpoint / Restore In Userspace akan membantu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kami</a> .  ,     ,      .     userspace-,    ,   ,      <code>kcmp</code> :    PID,   , ,  ,   ,          : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _GNU_SOURCE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/kcmp.h&gt; #include &lt;syscall.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; int main() { int fd = dup(0); printf("stdin is fd %d, too\n", fd); int pid = getpid(); if (syscall(SYS_kcmp, pid, pid, KCMP_FILE /*    _FILES! */, 0 /* stdin fd */, fd) == 0) printf("stdin\n"); else printf("not stdin\n"); if (syscall(SYS_kcmp, pid, pid, KCMP_FILE, 1 /* stdout fd */, fd) == 0) printf("stdout\n"); else printf("not stdout\n"); return 0; }</span></span></span></span></code> </pre> <br><pre> <code class="plaintext hljs">$ ./kcmp stdin is fd 3, too stdin stdout</code> </pre> <br><p>   !  ,   ... </p><br><pre> <code class="plaintext hljs">$ ls -l /proc/self/fd  0 lrwx------ 1 trosinenko trosinenko 64  10 14:45 0 -&gt; /dev/pts/17 lrwx------ 1 trosinenko trosinenko 64  10 14:45 1 -&gt; /dev/pts/17 lrwx------ 1 trosinenko trosinenko 64  10 14:45 2 -&gt; /dev/pts/17 lrwx------ 1 trosinenko trosinenko 64  10 14:45 23 -&gt; '/home/trosinenko/.cache/appstream-cache-AH3OA0.mdb (deleted)' lr-x------ 1 trosinenko trosinenko 64  10 14:45 3 -&gt; /proc/17265/fd lrwx------ 1 trosinenko trosinenko 64  10 14:45 57 -&gt; 'socket:[41036]'</code> </pre> <br><p> ,   ,   ,  ,       .  ,  bash        ,    <code>ls</code> ! </p><br><pre> <code class="plaintext hljs">$ ./kcmp &lt; kcmp.c stdin is fd 3, too stdin not stdout</code> </pre> <br><p>   ,       ‚Äî         -,   best effort   -    . </p><br><h2 id="obo-vsyom-i-ponemnozhku">     </h2><br><p>   , ... </p><br><ul><li> ‚Ä¶      JIT-    userspace?  ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> eBPF-</a> .       ,  ( ,   ,      -)  . .,    JIT-,  . ,      , BPF. </li><li> ‚Ä¶        ?  ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>sigaltstack</code></a> . </li><li> ‚Ä¶       ,     : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>readahead</code></a> </li></ul><br><p>           <code>oldolduname</code> ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475184/">https://habr.com/ru/post/id475184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475172/index.html">5 Cara Menggunakan Raspberry Pi Menguntungkan Bagian tiga</a></li>
<li><a href="../id475174/index.html">Cara melepas baterai atau sedikit teori paramotor listrik. Bagian 1</a></li>
<li><a href="../id475178/index.html">Mengganti EAV dengan JSONB di PostgreSQL</a></li>
<li><a href="../id475180/index.html">Bagaimana melepas baterai atau praktik mengoperasikan paramotor listrik SkyMax. Bagian 2</a></li>
<li><a href="../id475182/index.html">Bagaimana Saya Memutuskan Kompetisi Pembelajaran Mesin Seperti Data</a></li>
<li><a href="../id475188/index.html">Algoritma penempatan ubin berbasis kendala</a></li>
<li><a href="../id475192/index.html">Bagaimana menemukan pekerjaan di perusahaan yang membantu memerangi pemanasan global?</a></li>
<li><a href="../id475194/index.html">Menulis redux oleh SOLID</a></li>
<li><a href="../id475196/index.html">Intisari materi menarik untuk pengembang ponsel # 321 (pada 4 - 10 November)</a></li>
<li><a href="../id475200/index.html">Berita dari dunia OpenStreetMap No. 484 (10/22/2019 - 28/10/2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>