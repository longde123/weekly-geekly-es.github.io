<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèº üìà üë®üèæ‚Äçüè´ Laberintos: clasificaci√≥n, generaci√≥n, b√∫squeda de soluciones. üëÜüèø ‚óæÔ∏è üíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta publicaci√≥n cl√°sica detalla las formas m√°s populares de crear y recorrer laberintos. El art√≠culo se divide en cuatro partes: clasificaci√≥n, algor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Laberintos: clasificaci√≥n, generaci√≥n, b√∫squeda de soluciones.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445378/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"></div><br>  <i>Esta publicaci√≥n cl√°sica detalla las formas m√°s populares de crear y recorrer laberintos.</i>  <i>El art√≠culo se divide en cuatro partes: clasificaci√≥n, algoritmos de generaci√≥n, algoritmos para resolver laberintos y otras operaciones con laberintos.</i> <br><br><h2>  Clasificaci√≥n del laberinto </h2><br>  Los laberintos en su conjunto (y, por lo tanto, los algoritmos para crearlos) se pueden dividir en siete clasificaciones diferentes: dimensi√≥n, hiperdimensi√≥n, topolog√≠a, teselaci√≥n, enrutamiento, textura y prioridad.  El laberinto puede usar un elemento de cada clase en cualquier combinaci√≥n. <a name="habracut"></a><br>  <b>Dimensi√≥n:</b> la clase de dimensi√≥n determina esencialmente cu√°ntas dimensiones en el espacio ocupa el laberinto.  Los siguientes tipos est√°n disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Bidimensional</b> <b>: la</b> mayor√≠a de los laberintos, tanto de papel como reales, tienen esta dimensi√≥n, es decir, siempre podemos mostrar el plano del laberinto en una hoja de papel y movernos a lo largo de √©l sin cruzar ning√∫n otro corredor del laberinto. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>Tridimensional</b></a> <b>: el</b> laberinto tridimensional tiene varios niveles;  en √©l (al menos en la versi√≥n ortogonal), los pasajes pueden, adem√°s de las cuatro direcciones cardinales, bajar y subir.  Un laberinto 3D a menudo se visualiza como una matriz de niveles 2D con escaleras arriba y abajo. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/999/897/373/9998973734d2c66d06205a9ade0b501c.gif"><br><br>  <b>Dimensiones superiores</b> <b>:</b> puede crear laberintos de cuatro dimensiones e incluso m√°s multidimensionales.  A veces se visualizan como laberintos 3D con "portales" que conducen a trav√©s de la cuarta dimensi√≥n, por ejemplo, portales hacia el "pasado" y el "futuro". </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br>  <b>Entrelazado</b> <b>:</b> laberintos con entrelazado: estos son esencialmente laberintos bidimensionales (o m√°s bien 2.5 dimensionales), en los que, sin embargo, los pasajes pueden superponerse entre s√≠.  Cuando se muestra, generalmente es bastante obvio d√≥nde est√°n los callejones sin salida y c√≥mo un pasaje est√° por encima del otro.  Los laberintos del mundo real, en los que hay puentes que conectan una parte del laberinto con otra, se entrelazan parcialmente. </li></ul><br>  <b>Hiperdimensi√≥n: la</b> clasificaci√≥n seg√∫n la hiperdimensi√≥n corresponde a la dimensi√≥n de un objeto que se mueve a trav√©s de un laberinto, y no al laberinto en s√≠.  Los siguientes tipos est√°n disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>No hiperlabirintios</b> <b>:</b> casi todos los laberintos, incluso aquellos creados en alta dimensionalidad o con reglas especiales, generalmente no son hiperlabirintios.  En ellos trabajamos con un punto o un objeto peque√±o, por ejemplo, una pelota o el jugador mismo, que se mueve de un punto a otro, y la ruta pavimentada forma una l√≠nea.  En cada punto, hay un n√∫mero de opciones f√°cilmente contables. </li><li>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hiperlabirinto: los</a></b> hiperlabirinto son laberintos en los que el objeto que se resuelve no es solo un punto.  Un hiperlabirinto est√°ndar (o hiperlabirinto de primer orden) consiste en una l√≠nea que forma una superficie cuando se mueve a lo largo de un camino.  El hiperlabirinto solo puede existir en 3D o en un medio con una dimensi√≥n m√°s grande, y la entrada al hiperlabirinto a menudo no es un punto, sino una l√≠nea.  Hyperlabyrinth es fundamentalmente diferente, porque es necesario tener en cuenta y trabajar simult√°neamente con varias partes a lo largo de la l√≠nea, y en un momento dado hay un n√∫mero casi infinito de estados y opciones para lo que se puede hacer con la l√≠nea.  La l√≠nea de soluci√≥n es infinita, o sus puntos finales est√°n fuera del hiperlabirinto para evitar que la l√≠nea se comprima a un punto, porque en este caso puede considerarse un no hiperlabirinto. </li><li>  <b>Hyper-hyperlabyrinth:</b> hyperlabyrinths puede ser arbitrariamente alta dimensi√≥n.  Hyper-hyperlabyrinth (o hyperlabyrinth de segundo orden) nuevamente aumenta la dimensi√≥n del objeto que se est√° resolviendo.  Aqu√≠, el objeto a resolver es un plano que, al moverse a lo largo del camino, forma una figura tridimensional.  Hyper-hyperlabyrinth solo puede existir en un entorno dimensional 4D o superior. </li></ul><br>  <b>Topolog√≠a: la</b> clase de topolog√≠a describe la geometr√≠a del espacio laber√≠ntico en el que existe en su conjunto.  Los siguientes tipos est√°n disponibles: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Normal</b> <b>:</b> este es el laberinto est√°ndar en el espacio euclidiano. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br>  <b>Planair</b> <b>: El</b> t√©rmino "planair" describe cualquier laberinto con una topolog√≠a inusual.  Por lo general, esto significa que los bordes del laberinto est√°n conectados de una manera interesante.  Ejemplos: laberintos en la superficie de un cubo, laberintos en la superficie de una tira de Mobius y laberintos equivalentes a aquellos en un toro donde los lados izquierdo y derecho, superior e inferior est√°n conectados en pares. </li></ul><br>  <b>Teselaci√≥n: una</b> clasificaci√≥n de la geometr√≠a de las celdas individuales que componen el laberinto.  Tipos existentes: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ortogonal</b> <b>:</b> esta es una cuadr√≠cula rectangular est√°ndar en la que las celdas tienen pasajes que se cruzan en √°ngulo recto.  En el contexto de la teselaci√≥n, tambi√©n se les puede llamar laberintos gamma. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Delta</b> <b>: los</b> laberintos Delta consisten en tri√°ngulos conectados, y cada celda puede tener hasta tres pasajes conectados. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/650/dcd/b76/650dcdb76582619209847e3111cb0ad4.gif"><br><br>  <b>Sigma</b> <b>: los</b> laberintos Sigma est√°n formados por hex√°gonos conectados;  cada celda puede tener hasta seis pases. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/b12/0eb/9da/b120eb9da20a99a3985e76a644b4e740.gif"><br><br>  <b>Theta</b> <b>: los</b> laberintos de Theta consisten en c√≠rculos conc√©ntricos de pasajes en los que el principio o el final est√°n en el centro y el otro en el borde exterior.  Las celdas generalmente tienen cuatro rutas de conexi√≥n posibles, pero puede haber m√°s debido a la mayor cantidad de celdas en los anillos exteriores de los pasillos. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/283/751/2a5/2837512a58f5ad292e93b65a832e80fa.gif"><br><br>  <b>Epsilon</b> <b>: los</b> laberintos de Epsilon consisten en oct√°gonos o cuadrados conectados, cada celda en ellos puede tener hasta ocho o cuatro pases. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/bba/929/e12/bba929e1276ce4be65f121f20bf101c0.gif"><br><br>  <b>Zeta</b> <b>: el</b> laberinto zeta se encuentra en una cuadr√≠cula rectangular, solo que adem√°s de los pasajes horizontales y verticales, se permiten pasajes diagonales en un √°ngulo de 45 grados. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br>  <b>Omega</b> <b>: el</b> t√©rmino omega se refiere a casi cualquier laberinto con teselaci√≥n no ortogonal constante.  Los laberintos delta, sigma, theta e ipsilon son de este tipo, como muchos otros esquemas en los que se puede pensar, por ejemplo, un laberinto que consiste en pares de tri√°ngulos en √°ngulo recto. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br>  <b>Grieta</b> <b>: un</b> laberinto de grietas es un laberinto amorfo sin teselaci√≥n constante, en el que las paredes y las pasarelas se ubican en √°ngulos aleatorios. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/538/fe4/b6e/538fe4b6e758b139f1e9b1b258a5bc25.gif"><br><br>  <b>Fractal</b> <b>: un</b> laberinto fractal es un laberinto formado por laberintos m√°s peque√±os.  Un laberinto fractal de c√©lulas anidadas es un laberinto en cada celda en el que se colocan otros laberintos, y este proceso puede repetirse varias veces.  Un laberinto fractal infinitamente recursivo es un verdadero fractal en el que el contenido del laberinto se replica a s√≠ mismo, creando un laberinto esencialmente infinitamente grande. </li></ul><br>  <b>Enrutamiento: la</b> clasificaci√≥n por enrutamiento es probablemente el aspecto m√°s interesante en la generaci√≥n de laberintos.  Desde est√° asociado con los tipos de pasadas dentro de la geometr√≠a definida en las categor√≠as descritas anteriormente. <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> "ideal" es un laberinto sin bucles o circuitos cerrados y sin √°reas inalcanzables.  Tambi√©n se llama un laberinto simplemente conectado.  Desde cada punto hay exactamente un camino hacia cualquier otro punto.  Labyrinth tiene solo una soluci√≥n.  Desde el punto de vista de la programaci√≥n, dicho laberinto puede describirse como un √°rbol, un conjunto de celdas o v√©rtices de conexi√≥n. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br>  <b>Trenzado</b> <b>:</b> Trenzado significa que no hay callejones sin salida en el laberinto.  Tambi√©n se llama el laberinto del laberinto puramente conectado.  En tal laberinto, se usan pasajes que est√°n cerrados y regresan entre s√≠ (de ah√≠ el nombre de "mimbre"), les hacen pasar m√°s tiempo caminando en c√≠rculos en lugar de meterse en callejones sin salida.  Un laberinto tejido de calidad puede ser mucho m√°s complicado que un laberinto ideal del mismo tama√±o. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br>  <b>Ruta √∫nica (Unicursal)</b> <b>:</b> <b>ruta</b> √∫nica significa un laberinto sin tenedores.  El laberinto unidireccional contiene un largo y sinuoso pasaje que cambia de direcci√≥n en todo el laberinto.  No es muy complicado, solo si no retrocede accidentalmente hasta la mitad y no regresa al principio. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/add/a2c/cb6/adda2ccb6c09bd76428e17a395f8fd3e.gif"><br><br></b>  <b>Escaso: un</b> laberinto escaso no hace pases a trav√©s de cada celda, es decir, algunos de ellos no se crean.  Esto implica la presencia de √°reas inalcanzables, es decir, en cierto sentido, es lo opuesto al laberinto de mimbre.  Se puede aplicar un concepto similar al agregar paredes, por lo que puede obtener un laberinto desigual con pasillos y habitaciones anchas. </li><li>  <b>Parcialmente mimbre:</b> Parcialmente mimbre laberinto es un laberinto mixto que tiene bucles y callejones sin salida.  La palabra "mimbre" se puede usar para la evaluaci√≥n cuantitativa, es decir, un "laberinto con tejido fuerte" es un laberinto con muchos lazos o paredes removidos, y solo hay unos pocos en el "laberinto con tejido d√©bil". </li></ul><br>  <b>Textura: la</b> clasificaci√≥n de <b>textura</b> describe el estilo de pases con diferentes enrutamiento y geometr√≠a.  La textura no son solo par√°metros que se pueden activar o desactivar.  Aqu√≠ hay algunos ejemplos de variables: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/96d/730/eb5/96d730eb5f18e0c65786b410e5cb77cd.gif"><br><br>  <b>Sesgo</b> <b>:</b> en un laberinto con pasajes desplazados, los pasajes rectos tienden a ir m√°s en una direcci√≥n que en otras.  Por ejemplo, en un laberinto con un alto desplazamiento horizontal, tendremos pasajes largos de izquierda a derecha, y solo pasajes cortos de arriba a abajo que los conectan.  Tal laberinto suele ser m√°s dif√≠cil de pasar "a trav√©s de las fibras". </li><li><img src="https://habrastorage.org/getpro/habr/post_images/264/855/d73/264855d73cffcf3937c7497f8e021ae1.gif"><br><br>  <b>Sobrevuelo</b> <b>: la</b> m√©trica <b>Sobrevuelo</b> determina cu√°nto tiempo tardar√°n los pasillos antes de que aparezcan los turnos forzados.  En un laberinto con un tramo bajo, no habr√° pasajes rectos de m√°s de tres o cuatro celdas, y se ver√° muy al azar.  En un laberinto con un tramo alto, el laberinto tendr√° un gran porcentaje de pases largos, lo que lo har√° parecer un microchip. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/923/8dd/bac/9238ddbac833a6b351ddbec6aef9eee0.gif"><br><br></b>  <b>Elitismo: El</b> indicador de " <b>elitismo</b> " del laberinto determina la longitud de la soluci√≥n en relaci√≥n con el tama√±o del laberinto.  Los laberintos de √©lite generalmente tienen una soluci√≥n corta y directa, mientras que en los laberintos que no son de √©lite, la soluci√≥n pasa sobre una gran parte del √°rea del laberinto.  Un laberinto de √©lite de alta calidad puede ser mucho m√°s complicado que un laberinto que no sea de √©lite. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/471/8e1/c13/4718e1c13d43140bd41c40081eaf0b4c.gif"><br><br>  <b>Simetr√≠a</b> <b>: un</b> laberinto sim√©trico tiene pasos sim√©tricos, por ejemplo, en la simetr√≠a de rotaci√≥n relativa al centro, o reflejada a lo largo de los ejes horizontal o vertical.  El laberinto puede ser parcial o completamente sim√©trico, y puede repetir el patr√≥n varias veces. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br></b>  <b>Homogeneidad: un</b> algoritmo homog√©neo genera todos los laberintos posibles con la misma probabilidad.  Se puede llamar a un laberinto que tiene una textura homog√©nea si se parece a un laberinto t√≠pico generado por un algoritmo homog√©neo.  En teor√≠a, un algoritmo heterog√©neo tambi√©n puede generar todos los laberintos posibles en cualquier espacio, pero no con la misma probabilidad.  La heterogeneidad puede ir a√∫n m√°s lejos: puede haber laberintos que el algoritmo nunca generar√°. </li><li>  <b>Flujo del r√≠o: la</b> caracter√≠stica de "flujo" significa que al crear un laberinto, el algoritmo buscar√° y limpiar√° las celdas (o paredes) vecinas a la actual, es decir, fluir√° (de ah√≠ el t√©rmino "fluidez") a las partes a√∫n no creadas del laberinto, como el agua.  En un laberinto ideal con una velocidad de flujo m√°s baja, generalmente habr√° muchos callejones sin salida cortos, y en un laberinto m√°s "fluido" habr√° menos callejones sin salida, pero ser√°n m√°s largos. </li></ul><br>  <b>Prioridad:</b> esta clasificaci√≥n muestra que los procesos de creaci√≥n de laberintos se pueden dividir en dos tipos principales: agregar paredes y tallar pasajes.  Por lo general, al generar esto, se reduce solo a la diferencia en los algoritmos, y no a diferencias notables en los laberintos, pero a√∫n es √∫til tener esto en cuenta.  El mismo laberinto a menudo se genera de ambas maneras: <br><br><ul><li>  <b>Agregar muros: los</b> algoritmos para los que los muros son una prioridad comienzan con un √°rea vac√≠a (o borde externo), agregando muros en el proceso.  En el mundo real, los laberintos reales que consisten en setos, techos o paredes de madera definitivamente est√°n agregando paredes. </li><li>  <b>Corte de pasillos: los</b> algoritmos cuya prioridad son los pasillos comienzan con un bloque s√≥lido y cortan pasajes en el proceso.  En el mundo real, tales laberintos son t√∫neles de minas o laberintos dentro de tuber√≠as. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br></b>  <b>Plantilla: por</b> supuesto, los laberintos pueden cortar simult√°neamente pasajes y agregar paredes;  Algunos algoritmos inform√°ticos hacen eso.  Una plantilla de laberinto es una imagen gr√°fica que no es un laberinto, que en el menor n√∫mero de pasos se convierte en un laberinto real, pero a√∫n conserva la textura de la plantilla gr√°fica original.  Los estilos complejos de laberinto, como las espirales de intersecci√≥n, son m√°s f√°ciles de implementar como patrones en una computadora, en lugar de tratar de crear el laberinto correcto mientras se conserva su estilo. </li></ul><br>  <b>Otro: lo</b> anterior no es una lista exhaustiva de todas las clases o elementos posibles dentro de cada clase.  Estos son solo esos tipos de laberintos que yo mismo cre√©.  Tenga en cuenta que casi todos los tipos de laberintos, incluidos los laberintos con reglas especiales, se pueden expresar como un gr√°fico dirigido en el que habr√° un n√∫mero finito de estados y un n√∫mero finito de opciones en cada estado, y esto se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>equivalencia de los laberintos</b></a> .  Aqu√≠ hay algunas otras clasificaciones y tipos de laberintos: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/d19/d0e/264/d19d0e264db5d3d8521fbe62037c1b07.gif"><br><br>  <b>Orientaci√≥n</b> <b>:</b> en ciertos pasajes solo puedes moverte en una direcci√≥n.  Desde el punto de vista de la programaci√≥n, dicho laberinto se describir√° mediante un gr√°fico dirigido, en contraste con un gr√°fico no dirigido que describe todos los dem√°s tipos. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/43e/596/214/43e596214c1af1f52950a1223d111c3e.gif"><br><br>  <b>Segmentaci√≥n</b> <b>: el</b> laberinto puede tener diferentes partes correspondientes a diferentes clases. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/099/aee/262/099aee262a4d50e33bb92ab5b82946c6.gif"><br><br></b>  <b>Laberintos de longitud infinita:</b> podemos crear un laberinto infinitamente largo (un n√∫mero finito de columnas y cualquier n√∫mero de filas), pero al mismo tiempo almacenamos solo una parte del laberinto en la memoria, "desplaz√°ndonos" de un extremo al otro y destruyendo las l√≠neas anteriores al crear el siguiente.  Un ejemplo es una versi√≥n modificada del algoritmo Hunt and Kill.  Uno puede imaginar un laberinto potencialmente interminable en forma de una pel√≠cula larga compuesta de cuadros individuales.  Solo dos cuadros consecutivos se almacenan en la memoria a la vez.  Ejecutemos el algoritmo Hunt and Kill, aunque crea un sesgo que es propenso al marco superior, por lo que termina primero.  Una vez completado, el marco ya no es necesario, puede imprimirlo o hacer algo m√°s con √©l.  Sea como fuere, des√©chelo, convierta el cuadro inferior parcialmente creado en un nuevo cuadro superior y borre el nuevo cuadro inferior.  Repita el proceso hasta que decidamos detener, y luego espere hasta que Hunt And Kill complete ambos fotogramas.  La √∫nica limitaci√≥n es que el laberinto nunca tendr√° un camino que se bifurque hacia la entrada por una longitud de m√°s de dos cuadros.  La forma m√°s f√°cil de crear un laberinto sin fin es el algoritmo Eller o el algoritmo Sidewinder, porque ya crean laberintos una l√≠nea a la vez, por lo que puede dejar que agreguen l√≠neas sin fin al laberinto. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/8e1/677/f0f/8e1677f0fc6dbdfb99739ed66ec8d534.png" alt="imagen"><br><br></b>  <b>Laberintos fractales</b> virtuales <b>:</b> virtual es un laberinto en el que todo el laberinto no se almacena en la memoria al mismo tiempo.  Por ejemplo, solo puede almacenar parte de los pasillos de 100x100 cerca de su ubicaci√≥n en una simulaci√≥n en la que camina por un laberinto grande.  La extensi√≥n de laberintos fractales anidados se puede utilizar para crear enormes laberintos virtuales, por ejemplo, mil millones por mil millones de pases.  Si construimos una copia real del laberinto de mil millones por mil millones de pases (con una distancia de seis pies entre los pasajes), ¬°entonces llenar√≠a la superficie de la Tierra m√°s de 6,000 veces!  Considere un laberinto de 10 <sup>9</sup> a 10 <sup>9</sup> pases, o un laberinto cerrado con solo 9 niveles.  Si queremos tener al menos una parte de 100x100 a nuestro alrededor, es suficiente para nosotros crear en el nivel m√°s bajo un sub laberinto de 100x100 pases y siete laberintos de 10x10 en los que est√° incrustado para saber exactamente d√≥nde est√°n las paredes dentro de la parte de 100x100.  (En realidad, es mejor tener cuatro partes adyacentes de tama√±o 100x100, formando un cuadrado en caso de que est√© cerca del borde o la esquina de la parte, pero el mismo concepto se aplica aqu√≠.) Para garantizar que el laberinto sea constante y sin cambios cuando se mueva alrededor de √©l, tenemos una f√≥rmula, definiendo un n√∫mero de semilla aleatorio para cada coordenada en cada nivel de anidaci√≥n.  Los laberintos fractales virtuales son similares al fractal de Mandelbrot, en cuyas im√°genes existe virtualmente, y necesitamos visitar cierta coordenada con un aumento bastante alto.  para que aparezca. </li></ul><br><h2>  Algoritmos de laberinto </h2><br>  Aqu√≠ hay una lista de algoritmos generalizados para crear las diversas clases de laberintos descritos anteriormente: <br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/0a7/93f/443/0a793f443fe8f89980ecfd43559ccc81.gif"><br><br>  <b>Ideal</b> <b>:</b> para crear un laberinto ideal est√°ndar, generalmente es necesario "cultivarlo", asegurando la ausencia de bucles y √°reas aisladas.  Comenzamos desde el muro exterior y agregamos aleatoriamente un fragmento del muro que lo toca.  Continuamos agregando aleatoriamente segmentos de muro al laberinto, pero nos aseguramos de que cada nuevo segmento toque un extremo del muro existente, y su otro extremo est√© en la parte a√∫n no creada del laberinto.  Si agrega un segmento de pared, cuyos extremos est√°n separados del resto del laberinto, esto crear√° una pared no conectada con un bucle alrededor, y si agrega un segmento, cuyos extremos tocan el laberinto, crear√° un √°rea inalcanzable.  Este es un m√©todo para agregar muros;  es casi an√°logo a cortar pasajes, en los cuales partes de los pasajes se cortan de modo que solo un extremo toque el pase existente. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47a/0e8/60b/47a0e860b7ea1df363248e3348616cd7.gif"><br><br> <b></b> <b>:</b>               ,   ,          .      : (1)    , (2)       ,    ,          -¬´¬ª, (3)        ,   ,     , (4)        ,       ,      (3)   ,     ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/21d/cca/63c/21dcca63cf5cfd7d0b36e6bdff94da1f.gif"><br><br> <b></b> <b>:</b>        ‚Äî   ,  ,     ,    ,      .      U- ,      ,       ,       ,       .           .    ,           :          ,      ,       ,   .      ,             .     ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/ce1/9b2/36c/ce19b236c5dd3f766d0c817aeb551bdc.gif"><br><br> :</b>         ,     .              ,      ,     .  -       ,       ,            ,  ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>3D</b></a> <b>:</b>           ,     ,          ,      . -         . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/56a/89a/c01/56a89ac017b5faa694d3e15ab8d3948d.gif"><br><br> <b></b> <b>:</b>           ,          ,               .             (        ):     ,      ,       ,         .           ,  .    ,   ;    ,     .           ,      ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/47f/d14/6db/47fd146dba649e214e28a18207a7da89.gif"><br><br> <b>Crack</b> <b>:</b> Crack-         ,      ,     .  ,     ,     ,  ¬´¬ª        .   ,      ,    .  ,  -       . ,           ,             ;      .        ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/488/88c/28f/48888c28fd1c5ad3601c0dbb4e3716f6.gif"><br><br> <b></b> <b>:</b>     ¬´¬ª    ,           ,   . ,   -    : (1)  ,           . (2)     ,      ,    ,         ,    ,      (..      ). (3)     ,  ,     .            ,            . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7d0/844/5f9/7d08445f9ee145b6db8b844d70f9d21c.gif"><br><br> <b></b> <b>:</b>  ‚Äî  3D-,       -,      ,  .   3D-       ,       ,    .           ,             ,         .         ,         .         ,     (   ),          ,          ,    . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d52/35d/ff3d5235d49cbe3a9d2a562033d73202.gif"><br><br> <b>Planair</b> <b>:</b> Planair-               ,         .     ‚Äî       .      ,          . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/788/7d3/94f/7887d394fd2acf973c1dcfd4616dc09f.gif"><br><br> :</b> ,   , ,    -,      ,    ,     ,   .     ,     . ,   ,         ,    ,    ,          . </li></ul><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay muchas formas de crear laberintos perfectos, y cada uno de ellos tiene sus propias caracter√≠sticas. </font><font style="vertical-align: inherit;">A continuaci√≥n se muestra una lista de algoritmos espec√≠ficos. </font><font style="vertical-align: inherit;">Todos ellos describen la creaci√≥n de un laberinto cortando pasajes, sin embargo, a menos que se indique lo contrario, cada uno tambi√©n puede implementarse agregando paredes:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/128/314/7ba/1283147bad2733851cdba5fb965b7530.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rastreador recursivo </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>   -      recursive backtracker,   ,       .       ,       ,       .  ,      ,     .        ,      .  ,       .         ,  ,   ,        .      ,       . Recursive backtracking      ,       ,    ,          . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br> <b> </b> <b>:</b>  ,    .  ,     ¬´¬ª   ,          ,           .      ,   ,               (          ).     ,        .           ,             ,     .          ,      - ,    ,    .        ,    ,    .          ,            . ,             - (union-find algorithm):      ,    .       .        ,    -      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/7c3/316/387/7c3316387d28cf3b3ebdcd9caacef988.gif"><br><br>  <b>Algoritmo de Prim (verdadero)</b> <b>:</b> este algoritmo crea un √°rbol de expansi√≥n m√≠nimo al procesar pesos de borde √∫nicos al azar.  La cantidad de memoria requerida es proporcional al tama√±o del laberinto.  Comenzamos desde cualquier v√©rtice (el laberinto terminado ser√° el mismo, no importa desde la parte superior que comencemos).  Seleccionamos el borde del pasaje con el menor peso conectando el laberinto a un punto que a√∫n no est√° en √©l, y luego lo conectamos al laberinto.  El laberinto se completa cuando los bordes en cuesti√≥n ya no quedan.  Para seleccionar eficientemente el siguiente borde, necesita una cola prioritaria (generalmente implementada usando un mont√≥n) que almacena todos los bordes del borde.  Sin embargo, este algoritmo es bastante lento porque lleva tiempo de registro (n) seleccionar elementos del mont√≥n.  Por lo tanto, es mejor preferir el algoritmo de Kraskal, que tambi√©n crea un √°rbol de expansi√≥n m√≠nimo, porque es m√°s r√°pido y crea laberintos con una estructura id√©ntica.  De hecho, con la misma semilla aleatoria, los algoritmos Prima y Kraskal pueden crear los mismos laberintos. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/fe7/700/d75/fe7700d7554d3456bb9f7c185b16dec1.gif"><br><br>  <b>Algoritmo de Prim (simplificado)</b> <b>:</b> este algoritmo de Prim crea un √°rbol de expansi√≥n m√≠nimo.  Se simplifica de tal manera que todos los pesos de los bordes son iguales.  Requiere una capacidad de memoria proporcional al tama√±o del laberinto.  Partimos de un pico aleatorio.  Seleccionamos al azar el borde del pasaje que conecta el laberinto con un punto que a√∫n no est√° en √©l, y luego lo conectamos al laberinto.  El laberinto se completa cuando los bordes en cuesti√≥n ya no quedan.  Como los bordes no tienen peso y no est√°n ordenados, se pueden almacenar como una lista simple, es decir, la selecci√≥n de elementos de la lista ser√° muy r√°pida y tomar√° un tiempo constante.  Por lo tanto, es mucho m√°s r√°pido que el verdadero algoritmo Prim con pesos de arista aleatorios.  La textura del laberinto creado tendr√° una velocidad de flujo m√°s baja y una soluci√≥n m√°s simple que el verdadero m√©todo Prim, ya que se extiende desde el punto de partida de manera uniforme, como el jarabe derramado, y no evita los fragmentos de costillas con un peso mayor, que se tienen en cuenta m√°s adelante. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/95d/7bf/e0a/95d7bfe0ad94b47045e086ff12847b94.gif"><br><br>  <b>Algoritmo de Prim (modificado)</b> <b>:</b> este algoritmo de Prim crea un √°rbol de expansi√≥n m√≠nimo, modificado para que todos los pesos de los bordes sean iguales.  Sin embargo, se implementa de tal manera que en lugar de bordes mira las celdas.  La cantidad de memoria es proporcional al tama√±o del laberinto.  En el proceso de creaci√≥n, cada celda puede tener uno de tres tipos: (1) "interna": la celda es parte del laberinto y ya est√° cortada en ella, (2) "l√≠mite": la celda no es parte del laberinto y a√∫n no ha sido cortada, pero est√° ubicada junto a una celda que ya es "interna", y (3) "externa": la celda a√∫n no es parte del laberinto, y ninguno de sus vecinos es tambi√©n una celda "interna".  Comenzamos eligiendo una celda, la hacemos "interna" y para todos sus vecinos establecemos el tipo en "l√≠mite".  Seleccionamos al azar la celda "l√≠mite" y cortamos un pasaje de una de las celdas "internas" vecinas.  Cambiamos el estado de esta celda "l√≠mite" a "interno" y cambiamos el tipo de todos sus vecinos de "externo" a "borde".  El laberinto se completa cuando no quedan m√°s celdas "l√≠mite" (es decir, no quedan celdas "externas", lo que significa que todos se han vuelto "internos").  Este algoritmo crea laberintos con un √≠ndice de rendimiento muy bajo, tiene muchos puntos muertos cortos y una soluci√≥n bastante sencilla.  El laberinto resultante es muy similar al resultado del algoritmo Prima simplificado, con una ligera diferencia: los vac√≠os en el √°rbol de expansi√≥n se llenan solo si se selecciona aleatoriamente una celda l√≠mite, en contraste con la triple probabilidad de llenar esta celda a trav√©s de una de las celdas l√≠mite que la conducen.  Adem√°s, el algoritmo es muy r√°pido, m√°s r√°pido que el algoritmo Prim simplificado, ya que no necesita compilar y procesar la lista de bordes. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  Algoritmo de <b>Aldous-Broder</b> : lo interesante de este algoritmo es que es homog√©neo, es decir, crea con la misma probabilidad todos los laberintos posibles de un tama√±o determinado.  Adem√°s, no requiere memoria adicional o una pila.  Seleccionamos un punto y nos movemos aleatoriamente a una celda vecina.  Si nos metimos en una celda sin cortar, corta el pasaje de la celda anterior.  Continuamos movi√©ndonos a las celdas vecinas hasta que cortamos los pasajes a todas las celdas.  Este algoritmo crea laberintos con un caudal bajo, solo un poco m√°s alto que el algoritmo de Kraskal.  (Esto significa que para un intercambio dado, hay m√°s laberintos con un √≠ndice de rendimiento bajo que con uno alto, porque el laberinto con una probabilidad promedio es igualmente bajo). Lo malo de este algoritmo es que es muy lento porque no realiza una b√∫squeda intelectual de este √∫ltimo. es decir, las c√©lulas, de hecho, no tienen garant√≠as de finalizaci√≥n.  Sin embargo, debido a su simplicidad, puede pasar r√°pidamente por muchas celdas, por lo que se completa m√°s r√°pido de lo que parece.  En promedio, tarda siete veces m√°s en completarse que los algoritmos est√°ndar, aunque en casos malos puede ser mucho m√°s largo si el generador de n√∫meros aleatorios evita constantemente las √∫ltimas celdas.  Se puede implementar como la adici√≥n de muros, si el muro del borde se considera un solo v√©rtice, es decir, si el movimiento nos mueve al muro del borde, nos teletransportamos a un punto aleatorio a lo largo del borde, y solo entonces continuamos movi√©ndonos.  En el caso de agregar paredes, funciona casi el doble de r√°pido, porque la teletransportaci√≥n a lo largo del muro fronterizo permite un acceso m√°s r√°pido a las partes m√°s alejadas del laberinto. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/8a9/d2b/0c6/8a9d2b0c60f1c65e96bac07fd947c565.gif"><br><br>  <b>Algoritmo de Wilson</b> <b>:</b> esta es una versi√≥n mejorada del algoritmo Aldous-Broder, crea laberintos con exactamente la misma textura (los algoritmos son homog√©neos, es decir, todos los laberintos posibles se generan con la misma probabilidad), pero el algoritmo Wilson es mucho m√°s r√°pido.  Lleva memoria hasta el tama√±o del laberinto.  Comenzamos con una celda de laberinto inicial seleccionada al azar.  Seleccionamos una celda aleatoria que a√∫n no es parte del laberinto y realizamos una caminata aleatoria hasta que encontremos una celda que ya pertenece al laberinto.  Tan pronto como nos topamos con la parte ya creada del laberinto, volvemos a la celda aleatoria seleccionada y cortamos todo el camino realizado agregando estas celdas al laberinto.  M√°s espec√≠ficamente, cuando regresamos a lo largo del camino, cortamos cada celda en la direcci√≥n en la que se realiz√≥ la caminata aleatoria la √∫ltima vez que salimos de la celda.  Esto evita la aparici√≥n de bucles a lo largo del camino de retorno, de modo que un largo pasaje se une al laberinto.  El laberinto se completa cuando todas las c√©lulas est√°n unidas a √©l.  El algoritmo tiene los mismos problemas de velocidad que Aldous-Broder, porque puede llevar mucho tiempo encontrar la primera ruta aleatoria a la celda inicial, pero despu√©s de colocar varias rutas, el resto del laberinto se corta con bastante rapidez.  En promedio, funciona cinco veces m√°s r√°pido que Aldous-Broder, y menos de dos veces m√°s lento que los mejores algoritmos.  Vale la pena considerar que, en el caso de agregar paredes, funciona el doble de r√°pido, ya que toda la pared del borde es inicialmente parte del laberinto, por lo que las primeras paredes se unen mucho m√°s r√°pido. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/912/5a5/0b6/9125a50b62f3da5c999aa65dc144bc4a.gif"><br><br>  Algoritmo <b>Hunt and kill</b> <b>:</b> este algoritmo es conveniente porque no requiere memoria adicional o una pila, y por lo tanto es adecuado para crear laberintos o laberintos enormes en computadoras d√©biles debido a la imposibilidad de quedarse sin memoria.  Como no tiene reglas que deban seguirse constantemente, tambi√©n es m√°s f√°cil modificar y crear laberintos con diferentes texturas.  Es casi similar a un rastreador recursivo, solo que no hay una celda no creada cerca de la posici√≥n actual.  Entramos en el modo de "b√∫squeda" y escaneamos sistem√°ticamente el laberinto hasta encontrar una celda no creada al lado de la celda ya cortada.  En esta etapa, nuevamente comenzamos a cortar en esta nueva ubicaci√≥n.  El laberinto se completa cuando en el modo "caza" se escanean todas las celdas.  Este algoritmo tiende a crear laberintos con una velocidad de flujo alta, pero no tan alta como el rastreador recursivo.  Puede forzarlo a generar laberintos con una velocidad de flujo m√°s baja, entrando con mayor frecuencia en el modo "caza".  Funciona m√°s lento debido al tiempo dedicado a buscar las √∫ltimas celdas, pero no mucho m√°s lento que el algoritmo de Kraskal.  Se puede implementar de acuerdo con el principio de agregar muros, si ocasionalmente se teletransporta al azar para evitar los problemas inherentes a un rastreador recursivo. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/823/3be/623/8233be62330af193c9f7a6ff63841cca.gif"><br><br>  <b>Algoritmo de crecimiento</b> <b><br></b>  <b>√°rbol (algoritmo de √°rbol en crecimiento)</b> <b>:</b> este es un algoritmo generalizado que puede crear laberintos con diferentes texturas.  La memoria requerida puede alcanzar el tama√±o del laberinto.  Cada vez que se corta una celda, la agregamos a la lista.  Seleccione una celda de la lista y recorte el pasaje a la celda no creada al lado.  Si no hay celdas sin crear cerca de la actual, elimine la celda actual de la lista.  El laberinto se completa cuando no hay nada m√°s en la lista.  Lo interesante del algoritmo es que, dependiendo de c√≥mo seleccione una celda de la lista, puede crear muchas texturas diferentes.  Por ejemplo, si siempre selecciona la √∫ltima celda agregada, este algoritmo se convierte en un rastreador recursivo.  Si siempre selecciona celdas al azar, entonces se comporta de manera similar, pero no de manera id√©ntica al algoritmo Prim.  Si siempre selecciona las celdas m√°s antiguas agregadas a la lista, crearemos un laberinto con el √≠ndice de rendimiento m√°s bajo posible, incluso m√°s bajo que el del algoritmo Prim.  Si generalmente elige la √∫ltima celda, pero ocasionalmente elige una celda aleatoria, entonces el laberinto tendr√° una velocidad de flujo alta, pero una soluci√≥n corta y directa.  Si se selecciona al azar una de las celdas m√°s recientes, el laberinto tendr√° un caudal bajo, pero una soluci√≥n larga y sinuosa. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/3ee/6d6/3d0/3ee6d63d01f5e26e2f1c8b4a0f1e10e2.gif"><br><br>  <b>Algoritmo de bosque en crecimiento</b> <b>:</b> este es un algoritmo m√°s generalizado que combina tipos basados ‚Äã‚Äãen √°rboles y conjuntos.  Es una extensi√≥n del algoritmo de crecimiento de √°rboles, que esencialmente incluye varias instancias que se expanden simult√°neamente.  Comenzamos con todas las celdas ordenadas aleatoriamente en una lista de "nuevo";  Adem√°s, cada celda tiene su propio conjunto, como al comienzo del algoritmo de Kruskal.  Primero, seleccione una o m√°s celdas movi√©ndolas de la lista de "nuevo" a la lista de "activo".  Seleccione una celda de la lista "activa" y recorte el pasaje a la siguiente celda no creada de la lista "nueva", agregue una nueva celda a la lista de "activos" y combine los conjuntos de dos celdas.  Si se intenta cortar la parte existente del laberinto, habil√≠telo si las celdas est√°n en conjuntos diferentes y combine las celdas, como se hace en el algoritmo de Kraskal.  Si no hay celdas "nuevas" cerca de la celda actual, mueva la celda actual a la lista de las "terminadas".  El laberinto se completa cuando la lista de "activos" se vac√≠a.  Al final, combinamos todos los conjuntos restantes, como en el algoritmo de Kruskal.  Peri√≥dicamente, puede crear nuevos √°rboles moviendo una o m√°s celdas de la lista de "nuevos" a la lista de "activos", como se hizo al principio.  Al controlar el n√∫mero de √°rboles originales y las partes compartidas de los √°rboles reci√©n creados, puede generar muchas texturas √∫nicas que se combinan con los par√°metros ya flexibles del algoritmo de crecimiento de √°rboles. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/0df/4b2/2af/0df4b22af0d9c528721505c5863baa81.gif"><br><br>  <b>Algoritmo de Eller</b> <b>:</b> este es un algoritmo especial, porque no solo es m√°s r√°pido que todos los dem√°s, sino que tampoco tiene sesgos o defectos obvios;  Adem√°s, cuando se crea, la memoria se utiliza de manera m√°s eficiente.  Ni siquiera requiere que todo el laberinto est√© en la memoria, usa un volumen proporcional al tama√±o de la l√≠nea.  Crea un laberinto l√≠nea por l√≠nea, despu√©s de que se completa la generaci√≥n de la cadena, el algoritmo ya no lo tiene en cuenta.  Cada celda en una fila est√° contenida en un conjunto;  dos celdas pertenecen al mismo conjunto si hay una ruta entre ellas a lo largo del laberinto ya creado.  Esta informaci√≥n le permite cortar pasajes en la l√≠nea actual sin crear bucles o √°reas aisladas.  De hecho, es bastante similar al algoritmo de Kraskal, solo que aqu√≠ se forma una l√≠nea a la vez, mientras que Kraskal mira a trav√©s de todo el laberinto.  La creaci√≥n de una fila consta de dos partes: conectar aleatoriamente celdas adyacentes dentro de la fila, es decir  cortamos pasajes horizontales, luego conectamos aleatoriamente las celdas entre la fila actual y la siguiente, es decir  cortar pasajes verticales.  Al cortar pasajes horizontales, no conectamos celdas que ya est√°n en el mismo conjunto (porque de lo contrario se crear√° un bucle), y al cortar pasajes verticales debemos conectar una celda si tiene un tama√±o de unidad (porque si la deja, crear√° un √°rea aislada).  Al cortar pasajes horizontales, conectamos celdas si est√°n en el mismo conjunto (porque ahora hay un camino entre ellas), y al cortar pasajes verticales cuando no nos conectamos con la celda, lo colocamos en un conjunto separado (porque ahora est√° separado del resto del laberinto )  La creaci√≥n comienza con el hecho de que antes de conectar las celdas en la primera fila, cada celda tiene su propio conjunto.  La creaci√≥n se completa despu√©s de que las celdas se conectan en la √∫ltima fila.  Hay una regla especial de finalizaci√≥n: en el momento de la finalizaci√≥n, cada celda debe estar en el mismo conjunto para evitar √°reas aisladas.  (La √∫ltima l√≠nea se crea combinando cada uno de los pares de celdas vecinas que a√∫n no est√°n en el mismo conjunto). Es mejor implementar el conjunto utilizando una lista c√≠clica de celdas doblemente enlazadas (que puede ser solo una matriz que une celdas a pares de celdas en ambos lados del mismo conjunto), permitiendo Realizar la inserci√≥n, eliminaci√≥n y verificaci√≥n de la presencia de c√©lulas vecinas en un conjunto durante un tiempo constante.  El problema con este algoritmo es el desequilibrio en el procesamiento de los diferentes bordes del laberinto;  Para evitar manchas en las texturas, debe conectar y omitir las celdas de conexi√≥n en las proporciones correctas. </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/50c/8cc/ddc/50c8ccddc7242a00cf9dd62fba696ed2.gif"><br><br></b>  <b>Divisi√≥n recursiva:</b> este algoritmo es algo similar al retroceso recursivo, porque ambos usan pilas, solo que no funciona con pasillos, sino con paredes.  Comenzamos creando una pared horizontal o vertical aleatoria que intersecta un √°rea accesible en una fila o columna aleatoria, y coloca aleatoriamente espacios vac√≠os a lo largo de ella.  Luego repetimos recursivamente el proceso para las dos subregiones generadas por la pared divisoria.  Para obtener los mejores resultados, debe agregar una desviaci√≥n en la elecci√≥n de horizontal o vertical en funci√≥n de las proporciones del √°rea, por ejemplo, un √°rea cuyo ancho es el doble de la altura deber√≠a dividirse m√°s a menudo por paredes verticales.  Este es el algoritmo m√°s r√°pido sin desviaciones en las direcciones, y a menudo incluso puede competir con laberintos basados ‚Äã‚Äãen √°rboles binarios, porque crea varias celdas al mismo tiempo, aunque tiene un inconveniente obvio en forma de paredes largas que se cruzan en el interior del laberinto.  Este algoritmo es un tipo de laberintos fractales incrustados, pero en lugar de crear constantemente laberintos de celdas de un tama√±o fijo con laberintos del mismo tama√±o dentro de cada celda, divide aleatoriamente un √°rea dada en un laberinto de tama√±o aleatorio: 1x2 o 2x1.  La divisi√≥n recursiva no se puede utilizar para cortar pasajes, ya que esto lleva a la creaci√≥n de una soluci√≥n obvia que sigue a lo largo del borde exterior o que, de lo contrario, se cruza directamente con el interior. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d01/81f/8a0/d0181f8a04730302dbe6d88d0dc91431.gif"><br><br>  <b>Laberintos basados ‚Äã‚Äãen √°rboles binarios</b> <b>:</b> de hecho, estos son los algoritmos m√°s simples y r√°pidos posibles, sin embargo, los laberintos creados tienen una textura con un sesgo muy alto.  Para cada celda, cortamos un pasaje hacia arriba o hacia la izquierda, pero nunca en ambas direcciones.  En la versi√≥n con la adici√≥n de paredes, se agrega un segmento de pared para cada v√©rtice que conduce hacia abajo o hacia la derecha, pero no en ambas direcciones.  Cada celda es independiente de todas las dem√°s celdas, porque no necesitamos verificar el estado de algunas otras celdas al crearla.  Por lo tanto, este es un algoritmo real para generar laberintos sin memoria, no limitado por el tama√±o de los laberintos creados.  De hecho, este es un √°rbol binario, si consideramos la esquina superior izquierda como una ra√≠z, y cada nodo o celda tiene un nodo primario √∫nico, que es una celda en la parte superior o izquierda.  Los laberintos basados ‚Äã‚Äãen √°rboles binarios son diferentes de los laberintos ideales est√°ndar, porque m√°s de la mitad de los tipos de c√©lulas no pueden existir en ellos.  Por ejemplo, nunca habr√° intersecciones en ellos, y todos los callejones sin salida tienen pasajes que conducen hacia arriba o hacia la izquierda, y nunca hacia abajo o hacia la derecha.  Los laberintos tienden a tener pasajes que conducen diagonalmente desde la esquina superior izquierda a la esquina inferior derecha, y es mucho m√°s f√°cil moverse de la parte inferior derecha a la esquina superior izquierda.  Siempre puede moverse hacia arriba o hacia la izquierda, pero nunca simult√°neamente en ambas direcciones, por lo que siempre puede moverse de manera determinista diagonalmente hacia arriba y hacia la izquierda, sin encontrar barreras.  Tendr√° la oportunidad de elegir y caer en callejones sin salida movi√©ndose hacia abajo y hacia la derecha. ,            ,  ,        . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f3f/f8c/58c/f3ff8c58c53fce1c8d57401f7f41c924.gif"><br><br>  Sidewinder:</b>         ,    .       :      ,    ,  .    ,   ,      ,       ,  ,   .           ,     (    ,      ).                ,  sidewinder     .              ,    sidewinder        .     ,  sidewinder        ,          ,  .   sidewinder            ,   ¬´    ¬ª.   ,       sidewinder ‚Äî      ,      ,   ,  ,    .  sidewinder     ,       ,         ,   . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b>% </b> </td><td> <b></b> </td><td> <b></b> </td><td> <b> ?</b> </td><td> <b>?</b> </td><td> <b></b> </td><td> <b></b> </td><td> <b>% </b> </td></tr><tr><td>  </td><td>  0 0 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 379 </td><td> 100.0 </td></tr><tr><td> Recursive Backtracker </td><td>  10 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  27 </td><td> 19.0 </td></tr><tr><td> Hunt and Kill </td><td> 11 (21) </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  0 0 </td><td> 100 (143) </td><td> 9.5 (3.9) </td></tr><tr><td>   </td><td>  23 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N* </td><td>  10 </td><td> 7.2 </td></tr><tr><td>   </td><td>  25 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> 0* </td><td>  10 </td><td> 2.0 </td></tr><tr><td> Sidewinder </td><td>  27 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> 0* </td><td> 12 </td><td> 2.6 </td></tr><tr><td>   </td><td>  28 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N* </td><td>  20 </td><td> 4.2 (3.2) </td></tr><tr><td>   </td><td>  29 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 48 (25) </td><td>  4.5 4.5 </td></tr><tr><td>  - </td><td>  29 </td><td>  </td><td>  </td><td>  </td><td>  </td><td>  0 0 </td><td> 279 (208) </td><td>  4.5 4.5 </td></tr><tr><td>   </td><td>  30 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 33 </td><td> 4.1 </td></tr><tr><td>   () </td><td>  30 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 160 </td><td> 4.1 </td></tr><tr><td>   () </td><td>  32 </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  59 </td><td> 2.3 </td></tr><tr><td>   () </td><td> 36 (31) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  30 </td><td> 2.3 </td></tr><tr><td>   </td><td> 49 (39) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td> 48 </td><td> 11.0 </td></tr><tr><td>   </td><td> 49 (39) </td><td>  </td><td>  </td><td>  </td><td>  </td><td> N^2 </td><td>  76 </td><td> 11.0 </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta tabla resume las caracter√≠sticas de los algoritmos para crear laberintos ideales descritos anteriormente. A modo de comparaci√≥n, se ha agregado un algoritmo de laberinto de ruta √∫nica (te√≥ricamente, los laberintos de ruta √∫nica son ideales). Explicaci√≥n de columna:</font></font><br><br><ul><li> <b>:</b>    ,    ,     ,    2D-.       .       ,     ,     ,        .           10% (     )  49% (    ).        Recursive Backtracker    1%.           66%:              . </li><li> <b>:</b>       :        ,    ,           .       ,   ,   ,    ,           .  ,    ,    . </li><li> <b>:</b>        ,    .          .       ,           ,       . Recursive Backtracker     ,          ,    ,          . ,        ,       .  , Hunt and Kill          ,        ,            . </li><li> <b> :</b>          ,          .     ,           . Sidewinder  ,           .      ,      .  Hunt and Kill  ,      ,     ,       . </li><li> <b>:</b>         . ¬´¬ª ,    . ¬´¬ª ,            ,     . ¬´¬ª ,    ,      . ,           . </li><li> <b>:</b>     ,    .        ,        ,    (N),     (N^2).          ,        (   ).        ,     ,        .  Sidewinder       ,           .          ,         . </li><li> <b>:</b>      ,          ,   ,    .      ,       (     10),          .         100x100    Daedalus.         ,     ,     ,       . </li><li> <b>:</b>    ,        ,  .  ,     100x100 .        .     ¬´¬ª  .     ,       .      ,                  .        ,    ,     ,         . </li></ul><br><h2>    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay muchas formas de resolver laberintos, y cada uno de ellos tiene sus propias caracter√≠sticas. </font><font style="vertical-align: inherit;">Aqu√≠ hay una lista de algoritmos espec√≠ficos:</font></font><br><br><ul><li><img src="https://habrastorage.org/getpro/habr/post_images/62b/7f0/7c6/62b7f07c68ae7a9544c6ad481577e816.gif"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siguiendo a lo largo de las paredes (seguidor de la pared) </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b>     .        (¬´¬ª),         .            (  ).        ,      ( )           .         ,  .       ,    ,   .      ,     ,           ,             .     3D-    ,  3D-  2D-, .. ,          -,      -,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/d5b/25c/4de/d5b25c4de2e848708f6f9ba70a47957f.gif"><br><br> <b> </b> <b>:</b>      ,    ¬´¬ª    ,      .          2D-    ,       , ..    .           ,        ,         .            .   ,    ,        .  ,         ,    .       ,             ,   .        , ,   ‚Äî  -1,    ‚Äî  1.            ,      , ..     360   ,        ¬´¬ª.  ,         ¬´¬ª,      ,        ,      ,      ,         .  ,             ,           .      ,    ‚Äî    ,              . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/885/45e/39a/88545e39a856cc77b791086ebc958e0c.gif"><br><br> <b> </b> <b>:</b>   (Chain algorithm)  ,        (  )     .        ,         ,   .       ,    .  ,      ,      .      ,              .      (     )    ,      .         .     ,      ,    .      ¬´¬ª      ,   .          ,     ,       ,      .       ,    .          ,         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/402/cba/ed2/402cbaed27df8e2319b04647f963dc2e.gif"><br><br> Recursive backtracker:</b>    ,     .       ,              .   :      (    ),   ¬´¬ª, ,     ,  ¬´¬ª, ,       .  ,         ,    ¬´¬ª;    ¬´¬ª       .    (backtracking)       ,      ,    .  ,       .     ,   ,      . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/965/84c/528/96584c52805bc66d81e23eeae05b2057.gif"><br><br>   (Tr√©maux's algorithm):</b>          .    recursive backtracker      :         ,   .           ,  .   ,     ,     .          ,   ,         ,  . (     ,           .)    ,     (..  ),    ,     ,   ,       (.. ,    ).     ,       ,   ,        ,   ,             .     ,            .     ,     ,      . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/949/1f9/5b9/9491f95b97951ee9f10551bb24187e94.gif"><br><br> <b>  (Dead end filler)</b> <b>:</b>     .     ,         .        ,       ,    .         ,        .       ,   ,      .         ,         ,           . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/af6/640/839/af6640839e35705adb99b781278d56a9.gif"><br><br> <b>Cul-de-sac filler</b> <b>:</b>         ,     ,         .    dead end filler,    ,        .        (  ‚Äî   ,           ,      )  ,       .    dead end filler.     ,    ,       ,     ,       .       ,   ,     ,   dead end filler. </li><li><img src="https://habrastorage.org/getpro/habr/post_images/a01/d27/475/a01d27475d474454f478264e022e0383.gif"><br><br> <b>Blind alley filler</b> <b>:</b>      ,    ,     .   ,    .   ‚Äî   ,      ,             .     ,    ,    cul-de-sac filler,      .       .    ,    , ,  ,  .            ,   ,  ,          (           ).   ,             ,          .      ,   cul-de-sac filler  - ,     collision solver    ,      - . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/105/ade/5a7/105ade5a7dd7cbce67bcbd57d3ba3b7e.gif"><br><br> <b>Blind alley sealer</b> <b>:</b>     blind alley filler ,       ,     .                 .               .     ,   ,  blind alley filler,     .         .   ,    ,     ,        ,        .  ,      ,     .          ,     .      ,          ,   .  ,               ,    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/5e2/562/508/5e25625080da8af3396476127a2cc9ed.gif"><br><br>    (Shortest path finder):</b>     ,     ,        .        ,           ,   .   collision solver, ,  ,   ¬´¬ª ,          (      ),   ¬´¬ª  , ,     .      ¬´¬ª,       ,     .        ,             -    ,    .  ,  ,  ,    A*  ,       . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/396/221/e2e/396221e2ed8b51be85c22fc94f5610db.gif"><br><br> <b>   (Shortest paths finder)</b> <b>:</b>       ,     .     ,        ,     ,   ,   ,       ,    ,     -     ,    .  ,     ,     ,   ¬´¬ª ,         ,     ,      .         ,   ,       ,      ,    .         ,                  . </li><li> <b>Collision solver:</b>   "amoeba" solver.      .        ,                        .    ¬´¬ª ,          (  ).   ¬´ ¬ª       (   ),       ,   .      ¬´¬ª,     ,       ,   ,     . ( ,    ¬´¬ª,     .   ,      ,         ,    .)  ,   shortest paths finder,     (           )    (         ). </li><li> <b>Random mouse:</b>       ,       , ..            ,      .       180 ,     .    ,       ,    .         ,           ,          . </li></ul><br><table><tbody><tr><td> <b></b> </td><td> <b></b> </td><td> <b>?</b> </td><td> <b></b> </td><td> <b> ?</b> </td><td> <b>  ?</b> </td><td> <b>  ?</b> </td><td> <b>?</b> </td></tr><tr><td> Random Mouse </td><td>  1 </td><td>  </td><td>  </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td> Wall Follower </td><td>  1 </td><td>  </td><td>  </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td>   </td><td>  1 </td><td>  </td><td>  </td><td>  /  </td><td>  </td><td>  </td><td>  </td></tr><tr><td>   </td><td>  1 </td><td>  </td><td> + </td><td>  </td><td>  </td><td>  </td><td>  </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rastreador recursivo </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usted es </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritmo de Tremo </font></font></td><td>  1 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usted es </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dentro / sobre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relleno de callej√≥n sin salida </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todos + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laberinto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relleno de callej√≥n sin salida </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todos + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laberinto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sellador de callejones sin salida </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todos + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laberinto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relleno de callej√≥n sin salida </font></font></td><td>  Todos </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laberinto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobre </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Solucionador de colisiones </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todo m√°s corto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usted + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Busca los caminos m√°s cortos </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Todo m√°s corto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usted + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Busca el camino m√°s corto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 m√°s corto </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usted + </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta tabla enumera brevemente las caracter√≠sticas de los algoritmos de resoluci√≥n de laberintos descritos anteriormente. </font><font style="vertical-align: inherit;">De acuerdo con estos criterios, es posible clasificar y evaluar algoritmos para resolver laberintos. </font><font style="vertical-align: inherit;">Explicaciones de columna:</font></font><br><br><ul><li> <b>:</b>       ,   .        .  ,  ()       . Dead end filler  cul-de-sac filler (  blind alley sealer     )   ,      ,        ,      ¬´+¬ª. </li><li> <b>:</b>        .  Random mouse  ¬´¬ª,      ,   wall follower     ¬´¬ª,       ,     .  dead end filler  cul-de-sac filler  ¬´¬ª,           . </li><li> <b>:</b>      :   ¬´¬ª (  )    .    ,       (   ¬´¬ª)    (¬´+¬ª)          .    ,          . </li><li> <b> :</b>        ,     ,     .   ,   ¬´¬ª,    ,    (  ),  ,   ,    ,     .            . </li><li> <b>  :</b>      .   ,       ,     ,     ,         . Wall follower,             . Recursive backtracker  shortest path(s) finder     . </li><li> <b>  :</b>         .                    . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√°pido:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> el proceso de decisi√≥n se considera r√°pido. </font><font style="vertical-align: inherit;">Los algoritmos m√°s eficientes son suficientes para mirar cada celda del laberinto solo una vez, o pueden omitir completamente partes de √©l. </font><font style="vertical-align: inherit;">El tiempo de ejecuci√≥n debe ser proporcional al tama√±o del laberinto, u O (n ^ 2), donde n es el n√∫mero de celdas a lo largo de un lado. </font><font style="vertical-align: inherit;">El mouse aleatorio es lento porque su finalizaci√≥n no est√° garantizada, y el relleno de callej√≥n sin salida resuelve potencialmente el laberinto de cada bifurcaci√≥n.</font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otras operaciones con laberintos. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adem√°s de crear y resolver laberintos, puede realizar otras operaciones con ellos: </font></font><br><br><ul><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/6f7/fee/d6d/6f7feed6d3542670945c7601c6d17656.gif"><br><br> :</b>  ¬´  ¬ª,      ,         Fill  FloodFill.  FloodFill   ,      ,     .  ,       ,  FloodFill  ,     .  ,      ,  FloodFill  ,      ,        .          ¬´¬ª    . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/f09/223/2e3/f092232e3f56154a43c81d5b71eee6c2.gif"><br><br>    (Isolation remover):</b>    ,        ,        .   ,       .    ,     .   (   ,      )    ,    .         ,        ,      .         . </li><li> <b><img src="https://habrastorage.org/getpro/habr/post_images/e02/4fb/283/e024fb2832bd8e5d855b80393a75cf67.gif"><br><br>  :</b>    ,            ,               .        ,      ,  .    ,    .   (   ,       )        .         ,    ,        ,     .                ,        . </li><li><img src="https://habrastorage.org/getpro/habr/post_images/ea4/f95/188/ea4f951888f580d0a1446246e20e0ea1.gif"><br><br> <b>  </b> <b>:</b>       ,       .   ,       ,    ,        ,    .  ,      ,   .       ,        .           ,    blind alley sealer (    ,            ).   ,    ,   . </li></ul><br><h2>   </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>Daedalus</b></a> <b>:</b>           Daedalus,       Windows.    Daedalus    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445378/">https://habr.com/ru/post/445378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445362/index.html">El libro "Sistemas distribuidos. Patrones de dise√±o</a></li>
<li><a href="../445366/index.html">C√≥mo acelerar el cifrado seg√∫n GOST 28147-89 en el procesador Baikal-T1 debido al bloque SIMD</a></li>
<li><a href="../445368/index.html">Prueba de carga de un juego con un par de cientos de miles de usuarios virtuales</a></li>
<li><a href="../445370/index.html">An√°lisis de TSDB en Prometheus 2</a></li>
<li><a href="../445372/index.html">Visi√≥n artificial versus intuici√≥n humana: algoritmos para interrumpir el funcionamiento de los programas de reconocimiento de objetos.</a></li>
<li><a href="../445380/index.html">PHP moderno es hermoso y productivo</a></li>
<li><a href="../445384/index.html">Misi√≥n Chang'e-4: equipo cient√≠fico en el m√≥dulo de aterrizaje y el sat√©lite repetidor</a></li>
<li><a href="../445390/index.html">IDE de una persona normal o por qu√© elegimos M√≥naco</a></li>
<li><a href="../445392/index.html">Remarketing din√°mico MyTarget: recomendaciones de productos no personales</a></li>
<li><a href="../445394/index.html">Cambios en el protocolo de seguridad 3D: conozca 3-D Secure 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>