<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✌️ 🐓 🧔 回到Istio的微服务。 第二部分 ✌🏿 💛 🙌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注意事项 佩雷夫 ：本系列的第一部分专门介绍Istio并在实际中进行演示。 现在，我们将讨论该服务网格的配置和使用的更复杂方面，尤其是关于微调的路由和网络流量管理。 

 我们还提醒您，本文使用istio-mastery存储库中的配置（Kubernetes和Istio的清单）。  

 交通管理 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>回到Istio的微服务。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/440378/"><img src="https://habrastorage.org/webt/bj/j4/oy/bjj4oyjxqshrbjf5eks9sgsvbeg.png"><br><br>  <i><b>注意事项</b></i>  <i><b>佩雷夫</b></i>  <i>：本系列<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的第一部分</a>专门介绍Istio并在实际中进行演示。</i>  <i>现在，我们将讨论该服务网格的配置和使用的更复杂方面，尤其是关于微调的路由和网络流量管理。</i> <i><br><br></i>  <i>我们还提醒您，本文使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">istio-mastery</a>存储库中的配置（Kubernetes和Istio的清单）。</i> <i><a name="habracut"></a></i> <br><br><h2> 交通管理 </h2><br> 使用Istio，新功能会出现在群集中，以提供： <br><br><ul><li>  <b>动态查询路由</b> ：金丝雀推出，A / B测试； </li><li>  <b>负载平衡</b> ：简单且一致，基于哈希； </li><li>  <b>秋季恢复</b> ：超时，重试，断路器； </li><li>  <b>故障输入</b> ：延迟，请求中断等 </li></ul><br> 在本文的后续部分，这些功能将作为所选应用程序的示例显示，并且将在此过程中引入新的概念。 第一个这样的概念将是<code>DestinationRules</code> <i>（即有关流量/请求接收者的规则-大约是Transl。）</i> ，通过它我们可以启动A / B测试。 <br><br><h2>  A / B测试：实际中的DestinationRules </h2><br> 如果应用程序有两个版本（通常在视觉上有所不同），并且我们不确定100％确定哪个版本可以改善用户交互，则使用A / B测试。 因此，我们同时启动两个版本并收集指标。 <br><br> 要部署演示A / B测试所需的前端的第二个版本，请运行以下命令： <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/kube/ab-testing/sa-frontend-green-deployment.yaml deployment.extensions/sa-frontend-green created</code> </pre> <br>  “绿色版本”的部署清单在两个地方有所不同： <br><br><ol><li> 该图片基于另一个标记<code>istio-green</code> ， </li><li> 豆荚有一个<code>version: green</code>标签。 </li></ol><br> 由于两个部署都具有<code>app: sa-frontend</code>标签，因此由<code>sa-external-services</code>虚拟服务路由到<code>sa-frontend</code>服务的请求将被重定向到其所有实例，并且将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">round-robin算法</a>分配负载，这将导致以下情况： <br><br><img src="https://habrastorage.org/webt/p-/bi/mj/p-bimjrw8ywosk5q020d3loefsy.png"><br>  <i>找不到请求的文件</i> <br><br> 找不到这些文件是因为它们在应用程序的不同版本中被不同地调用。 让我们确保这一点： <br><br><pre> <code class="bash hljs">$ curl --silent http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/ | tr <span class="hljs-string"><span class="hljs-string">'"'</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span> | grep main /static/css/main.c7071b22.css /static/js/main.059f8e9c.js $ curl --silent http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/ | tr <span class="hljs-string"><span class="hljs-string">'"'</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span> | grep main /static/css/main.f87cd8c9.css /static/js/main.f7659dbb.js</code> </pre> <br> 这意味着，请求平衡文件的一种版本的<code>index.html</code>可以由负载平衡器发送到具有不同版本的Pod，在这些Pod中，由于明显的原因，这些文件不存在。 因此，为了使该应用程序正常工作，我们需要施加一个限制：“ <b>提供index.html的相同版本的应用程序也必须满足后续请求</b> 。” <br><br> 我们将通过基于一致性的基于哈希的负载平衡<i>（Consistent Hash Loadbalancing）</i>来实现该目标。 在这种情况下， <b>来自一个客户端的请求将发送到同一后端实例</b> ，该<b>后端实例</b>使用预定义的属性-例如HTTP标头。 使用DestinationRules实现。 <br><br><h2>  DestinationRules </h2><br> 在<b>VirtualService</b>向所需的服务发送请求之后，使用DestinationRules，我们可以确定将应用于发往该服务实例的流量的策略： <br><br><img src="https://habrastorage.org/webt/sd/be/iy/sdbeiy6vndddkdjifebk9a7-q2m.png"><br>  <i>Istio资源流量管理</i> <br><br>  <b>注意</b> ：此处以简化的方式介绍了Istio资源对网络流量的影响。 确切地说，Envoy在CRD中配置的Ingress网关中决定将请求发送到哪个实例。 <br><br> 使用目标规则，我们可以配置负载平衡，以便使用一致的哈希值，并确保来自同一服务实例的响应被提供给同一用户。 通过以下配置，此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目标地址</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">destinationrule-sa-frontend.yaml</a> ）可以实现此目的： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: sa-frontend spec: host: sa-frontend trafficPolicy: loadBalancer: consistentHash: httpHeaderName: version # 1</code> </pre> <br>  1-将基于HTTP <code>version</code>标头的内容生成哈希。 <br><br> 使用以下命令应用配置： <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/ab-testing/destinationrule-sa-frontend.yaml destinationrule.networking.istio.io/sa-frontend created</code> </pre> <br> 现在运行下面的命令，并确保在指定<code>version</code>头时获得所需的文件： <br><br><pre> <code class="bash hljs">$ curl --silent -H <span class="hljs-string"><span class="hljs-string">"version: yogo"</span></span> http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/ | tr <span class="hljs-string"><span class="hljs-string">'"'</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span> | grep main</code> </pre> <br>  <b>注意</b> ：要在标题中添加不同的值并直接在浏览器中测试结果，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将此扩展名</a>用于Chrome <i>（对于Firefox</i> ，请使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此扩展名</a> <i>-大约翻译）</i> 。 <br><br> 通常，DestinationRules在负载均衡领域中有更多选项-请查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档以</a>了解详细信息。 <br><br> 在进一步探索VirtualService之前，我们将通过执行以下命令来删除应用程序的“绿色版本”和流量方向上的相应规则： <br><br><pre> <code class="bash hljs">$ kubectl delete -f resource-manifests/kube/ab-testing/sa-frontend-green-deployment.yaml deployment.extensions “sa-frontend-green” deleted $ kubectl delete -f resource-manifests/istio/ab-testing/destinationrule-sa-frontend.yaml destinationrule.networking.istio.io “sa-frontend” deleted</code> </pre> <br><h2> 镜像：实践中的虚拟服务 </h2><br> 在我们想要测试生产变更而不影响最终用户的情况下，会使用阴影<i>（“屏蔽”）</i>或镜像<i>（“镜像”）</i> ：为此，我们在第二次实例中重复（“镜像”）请求，并在必要时进行了更改，看看后果。  <i>简而言之，这是您的（一位）同事选择最关键的问题并以巨大污垢的形式提出拉动请求时，实际上没有人可以对他进行审查。</i> <br><br> 要测试实际情况，请通过运行以下命令来创建第二个带有错误（ <code>buggy</code> ）的SA-Logic实例： <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/kube/shadowing/sa-logic-service-buggy.yaml deployment.extensions/sa-logic-buggy created</code> </pre> <br> 现在，我们执行命令以确保所有具有<code>app=sa-logic</code>实例<code>app=sa-logic</code>具有带有相应版本的标签： <br><br><pre> <code class="bash hljs">$ kubectl get pods -l app=sa-logic --show-labels NAME READY LABELS sa-logic-568498cb4d-2sjwj 2/2 app=sa-logic,version=v1 sa-logic-568498cb4d-p4f8c 2/2 app=sa-logic,version=v1 sa-logic-buggy-76dff55847-2fl66 2/2 app=sa-logic,version=v2 sa-logic-buggy-76dff55847-kx8zz 2/2 app=sa-logic,version=v2</code> </pre> <br>  <code>sa-logic</code>针对带有<code>app=sa-logic</code>标签的pod，因此所有请求将在所有实例之间分配： <br><br><img src="https://habrastorage.org/webt/6d/po/v8/6dpov8tnmom1j_sr7tcedj7bufo.png"><br><br>  ...但是我们希望将请求定向到版本v1的实例并镜像到版本v2的实例： <br><br><img src="https://habrastorage.org/webt/7u/n6/aj/7un6aj7gerw57imbzmwgkwgjajw.png"><br><br> 我们将通过将VirtualService与DestinationRule结合使用来实现此目标，在DestinationRule中，规则将确定VirtualService的子集和到特定子集的路由。 <br><br><h2> 在目标规则中定义子集 </h2><br>  <i>子集</i>由以下配置（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sa-logic-subsets-destinationrule.yaml</a> ）定义： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: sa-logic spec: host: sa-logic # 1 subsets: - name: v1 # 2 labels: version: v1 # 3 - name: v2 labels: version: v2</code> </pre> <br><ol><li>  <code>host</code>确定此规则仅适用于路由进入<code>sa-logic</code> ； </li><li> 路由到子集的实例时使用子集的名称。 </li><li> 标签定义实例必须匹配的键/值对，才能成为子集的一部分。 </li></ol><br> 使用以下命令应用配置： <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/shadowing/sa-logic-subsets-destinationrule.yaml destinationrule.networking.istio.io/sa-logic created</code> </pre> <br> 现在已经定义了子集，您可以继续并配置VirtualService以将规则应用于对sa-logic的请求，以便它们： <br><br><ol><li> 路由到<code>v1</code>的子集， </li><li> 镜像到<code>v2</code>的子集。 </li></ol><br> 以下清单可帮助您实现计划（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sa-logic-subsets-shadowing-vs。yaml</a> ）： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: sa-logic spec: hosts: - sa-logic http: - route: - destination: host: sa-logic subset: v1 mirror: host: sa-logic subset: v2</code> </pre> <br> 这里不需要解释，因此只需看一下操作即可： <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/shadowing/sa-logic-subsets-shadowing-vs.yaml virtualservice.networking.istio.io/sa-logic created</code> </pre> <br> 通过调用以下命令来添加负载： <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> curl -v http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/sentiment \ -H <span class="hljs-string"><span class="hljs-string">"Content-type: application/json"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{"sentence": "I love yogobella"}'</span></span>; \ sleep .8; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br> 让我们看一下Grafana中的结果，在这里我们可以看到有<code>buggy</code>版本在大约60％的请求中崩溃，但是这些崩溃都不会影响最终用户，因为他们拥有有效的服务。 <br><br><img src="https://habrastorage.org/webt/x3/g6/so/x3g6so65q5jmyjj48-_kjf254de.png"><br>  <i>不同版本的sa-logic服务的响应成功</i> <br><br> 在这里，我们首先看到了如何将VirtualService应用于服务的Envoy：当<code>sa-web-app</code>向<code>sa-logic</code>发出请求时，它将通过sidecar Envoy，后者通过VirtualService被配置为将请求路由到子集v1和镜像对<code>sa-logic</code> v2的子集的请求。 <br><br> 我知道：您已经有时间认为虚拟服务很简单。 在下一部分中，我们通过它们也确实很棒的事实来扩展这种观点。 <br><br><h2> 金丝雀卷 </h2><br>  Canary Deployment是为少数用户推出应用程序新版本的过程。 它用于确保发行版中没有问题，仅在此之后，已经对其足够的（发行版）质量充满信心，才能传播到更大的受众群体。 <br><br> 为了演示金丝雀的推出，我们将继续使用<code>sa-logic</code>的<code>buggy</code>集。 <br><br> 让我们不要浪费时间，立即将20％的用户发送给有错误的版本（它将代表我们的Canary推出），其余80％的用户返回正常服务。 为此，请应用以下VirtualService（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sa-logic-subsets-canary-vs.yaml</a> ）： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: sa-logic spec: hosts: - sa-logic http: - route: - destination: host: sa-logic subset: v1 weight: 80 # 1 - destination: host: sa-logic subset: v2 weight: 20 # 1</code> </pre> <br>  1是权重，它确定将发送给接收者或接收者子集的请求的百分比。 <br><br>  <code>sa-logic</code>以下命令为<code>sa-logic</code>更新以前的VirtualService配置： <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/canary/sa-logic-subsets-canary-vs.yaml virtualservice.networking.istio.io/sa-logic configured</code> </pre> <br>  ...并立即看到部分请求崩溃： <br><br><pre> <code class="bash hljs">$ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> \ curl -i http://<span class="hljs-variable"><span class="hljs-variable">$EXTERNAL_IP</span></span>/sentiment \ -H <span class="hljs-string"><span class="hljs-string">"Content-type: application/json"</span></span> \ -d <span class="hljs-string"><span class="hljs-string">'{"sentence": "I love yogobella"}'</span></span> \ --silent -w <span class="hljs-string"><span class="hljs-string">"Time: %{time_total}s \t Status: %{http_code}\n"</span></span> \ -o /dev/null; sleep .1; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> Time: 0.153075s Status: 200 Time: 0.137581s Status: 200 Time: 0.139345s Status: 200 Time: 30.291806s Status: 500</code> </pre> <br>  VirtualServices激活了金丝雀的推出：在这种情况下，我们将问题的潜在影响范围缩小到了20％的用户群。 太好了！ 现在，在每种情况下，当我们不确定我们的代码时（换句话说，总是...），我们可以使用镜像和canary卷展栏。 <br><br><h2> 超时和重试 </h2><br> 但并非总是在代码中包含错误。 在“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">分布式计算</a>中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">8个错误</a> ”列表中，首先出现了“网络可靠”的错误观点。 实际上，网络是<b>不</b>可靠的，因此，我们需要超时和<i>重试</i> 。 <br><br> 为了进行演示，我们将继续使用相同版本的<code>sa-logic</code> （ <code>buggy</code> ），并将模拟随机故障导致的网络不可靠性。 <br><br> 让我们的错误服务有1/3的机会响应时间太长，有1/3的机会完成内部服务器错误，有1/3的机会返回成功的页面。 <br><br> 为了减轻此类问题的后果并改善用户的生活，我们可以： <br><br><ol><li> 如果服务响应时间超过8秒，请添加超时， </li><li> 如果请求失败，请重试。 </li></ol><br> 为了实现，我们将使用以下资源定义（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">sa-logic-retries-timeouts-vs.yaml</a> ）： <br><br><pre> <code class="plaintext hljs">apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: sa-logic spec: hosts: - sa-logic http: - route: - destination: host: sa-logic subset: v1 weight: 50 - destination: host: sa-logic subset: v2 weight: 50 timeout: 8s # 1 retries: attempts: 3 # 2 perTryTimeout: 3s # 3</code> </pre> <br><ol><li> 请求的超时设置为8秒； </li><li> 重复请求尝试3次； </li><li> 如果响应时间超过3秒，则每次尝试都将被视为失败。 </li></ol><br> 因此，我们已经实现了优化，因为用户不必等待超过8秒的时间，并且在发生故障时我们将进行三种新的尝试来获得答案，从而增加了成功响应的机会。 <br><br> 使用以下命令应用更新的配置： <br><br><pre> <code class="bash hljs">$ kubectl apply -f resource-manifests/istio/retries/sa-logic-retries-timeouts-vs.yaml virtualservice.networking.istio.io/sa-logic configured</code> </pre> <br> 并检查Grafana的图形，成功答案的数量已经结束： <br><br><img src="https://habrastorage.org/webt/ee/l_/qs/eel_qsg8z2vwzjwi35xmqg6eiko.png"><br>  <i>添加超时和重试后，成功响应统计信息的改进</i> <br><br> 在继续下一节<i>（或者，因为本文中不会进行更多实验-大约翻译）之前</i> ，请通过运行以下命令删除<code>sa-logic-buggy</code>和VirtualService： <br><br><pre> <code class="bash hljs">$ kubectl delete deployment sa-logic-buggy deployment.extensions “sa-logic-buggy” deleted $ kubectl delete virtualservice sa-logic virtualservice.networking.istio.io “sa-logic” deleted</code> </pre> <br><h2> 断路器和隔板模式 </h2><br> 我们正在谈论微服务体系结构中的两个重要模式，这些模式可让您实现<i>自我修复</i>服务。 <br><br>  <b>电路断路器</b> <i>（“电路断路器”）</i>用于停止请求到不健康服务实例的请求，并在客户端请求重定向到该服务的健康实例（恢复成功响应的百分比）时恢复该请求。  <i>（注意：例如，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>找到关于模式的更详细的描述。）</i> <br><br>  <b>隔板</b> <i>（“分区”）</i>将服务故障与整个系统的故障隔离开来。 例如，服务B中断，另一个服务（服务B的客户端）向服务B发出请求，结果它将耗尽其线程池，并且将无法服务其他请求（即使它们与服务B不相关）。  <i>（注意：例如，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a>找到关于模式的更详细的描述。）</i> <br><br> 我将省略有关这些模式的实现的详细信息，因为它们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档</a>中很容易找到，并且我确实想显示身份验证和授权，这将在本文的下一部分中进行讨论。 <br><br><h2> 译者的PS </h2><br> 另请参阅我们的博客： <br><br><ul><li>  “使用Istio返回微服务”： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分（熟悉主要功能）</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分（认证和授权）</a> ； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">导管-Kubernetes的轻量级服务网格</a> ”； </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是服务网格？为什么（对于带有微服务的云应用程序）需要它？</a>  ”。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN440378/">https://habr.com/ru/post/zh-CN440378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440366/index.html">有关Habré的文章的生命周期：我们编写了habraparser</a></li>
<li><a href="../zh-CN440370/index.html">服务条款：99％的用户根本不了解他们</a></li>
<li><a href="../zh-CN440372/index.html">我的Pascal编译器和波兰当代艺术</a></li>
<li><a href="../zh-CN440374/index.html">Yandex函数发送邮件</a></li>
<li><a href="../zh-CN440376/index.html">20个游戏来教孩子编程</a></li>
<li><a href="../zh-CN440382/index.html">200是好是坏？</a></li>
<li><a href="../zh-CN440386/index.html">通过消除错误来释放错误处理</a></li>
<li><a href="../zh-CN440388/index.html">时间间隔：即将到来的C ++演变</a></li>
<li><a href="../zh-CN440390/index.html">嵌入式系统的多样化世界以及Embox在其中的地位</a></li>
<li><a href="../zh-CN440392/index.html">您网站上的WebRTC-没有错误，也没有预算</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>