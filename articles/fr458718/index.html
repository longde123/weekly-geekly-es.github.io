<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚ÄçüöÄ üñêüèæ üé∂ Grande interview avec Cliff Click, le p√®re de la compilation JIT en Java üßì üëÉüèæ ü•ù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cliff Click est le CTO de Cratus (capteurs IoT pour l'am√©lioration des processus), le fondateur et co-fondateur de plusieurs startups (dont Rocket Rea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grande interview avec Cliff Click, le p√®re de la compilation JIT en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/458718/"><p><img src="https://habrastorage.org/getpro/habr/post_images/bed/01d/799/bed01d799e35f74331803908a94516bb.jpg" width="200" align="left">  <strong>Cliff Click</strong> est le CTO de Cratus (capteurs IoT pour l'am√©lioration des processus), le fondateur et co-fondateur de plusieurs startups (dont Rocket Realtime School, Neurensic et H2O.ai) avec plusieurs sorties r√©ussies.  Cliff a √©crit son premier compilateur √† 15 ans (Pascal pour TRS Z-80)!  Mieux connu pour avoir travaill√© sur C2 en Java (le Sea of ‚Äã‚ÄãNodes IR).  Ce compilateur a montr√© au monde que JIT peut produire du code de haute qualit√©, qui est devenu l'un des facteurs qui font de Java l'une des principales plates-formes logicielles modernes.  Cliff a ensuite aid√© Azul Systems √† construire un ordinateur central √† 864 c≈ìurs avec un logiciel Java pur prenant en charge les pauses GC sur un tas de 500 gigaoctets pendant 10 millisecondes.  En g√©n√©ral, Cliff a r√©ussi √† travailler sur tous les aspects de la JVM. <br clear="all"><br>  Ce hubrapost est une excellente interview avec Cliff.  Nous parlerons des sujets suivants: </p><br><ul><li>  Transition vers des optimisations de bas niveau </li><li>  Comment faire beaucoup de refactoring </li><li>  Mod√®le de co√ªt </li><li>  Formation d'optimisation de bas niveau </li><li>  √âtudes de cas d'am√©lioration de la productivit√© </li><li>  Pourquoi cr√©er votre propre langage de programmation </li><li>  Carri√®re d'ing√©nieur de performance </li><li>  D√©fis techniques </li><li>  Un peu sur l'allocation des registres et le multic≈ìur </li><li>  Le plus grand d√©fi de la vie </li></ul><br><p>  Entretiens r√©alis√©s par: </p><br><ul><li>  <strong>Andrey Satarin</strong> d'Amazon Web Services.  Au cours de sa carri√®re, il a r√©ussi √† travailler dans des projets compl√®tement diff√©rents: il a test√© la base de donn√©es distribu√©e NewSQL dans Yandex, le syst√®me de d√©tection de cloud dans Kaspersky Lab, le jeu multi-utilisateurs dans Mail.ru et le service de calcul de change de devises dans la Deutsche Bank.  Il souhaite tester des syst√®mes backend et distribu√©s √† grande √©chelle. </li><li>  <strong>Vladimir Sitnikov</strong> de Netcracker.  Depuis dix ans, il travaille sur les performances et l'√©volutivit√© de NetCracker OS, un logiciel utilis√© par les op√©rateurs t√©l√©coms pour automatiser les processus de gestion des r√©seaux et des √©quipements r√©seaux.  Il s'int√©resse aux probl√®mes de performances Java et Oracle Database.  L'auteur de plus d'une douzaine d'am√©liorations des performances du pilote JDBC PostgreSQL officiel. <a name="habracut"></a></li></ul><br><h1 id="perehod-k-nizkourovnevym-optimizaciyam">  Transition vers des optimisations de bas niveau </h1><br><p>  <strong>Andrei</strong> : Vous √™tes une personne c√©l√®bre dans le monde de la compilation JIT, en Java et travaillez sur la performance en g√©n√©ral, non? </p><br><p>  <strong>Cliff</strong> : C'est √ßa! </p><br><p>  <strong>Andrew</strong> : Commen√ßons par des questions g√©n√©rales sur le travail sur les performances.  Que pensez-vous du choix entre les optimisations de haut niveau et de bas niveau comme le travail au niveau du processeur? </p><br><p> <strong>Cliff</strong> : C'est facile.  Le code le plus rapide est celui qui ne s'ex√©cute jamais.  Par cons√©quent, vous devez toujours partir d'un niveau √©lev√©, travailler sur des algorithmes.  Une meilleure notation O battra une pire notation O, √† moins que des constantes assez grandes n'interviennent.  Les choses de bas niveau sont les derni√®res.  Habituellement, si vous optimisez assez bien le reste de la pile, et qu'il reste encore quelque chose d'int√©ressant - c'est le niveau bas.  Mais comment partir d'un haut niveau?  Comment savoir que suffisamment de travail a √©t√© effectu√© √† un niveau √©lev√©?  Eh bien ... pas question.  Il n'y a pas de recettes toutes faites.  Vous devez comprendre le probl√®me, d√©cider de ce que vous allez faire (afin de ne pas faire des √©tapes inutiles √† l'avenir) et ensuite vous pouvez d√©couvrir un profileur qui peut dire quelque chose d'utile.  √Ä un moment donn√©, vous comprenez vous-m√™me que vous vous √™tes d√©barrass√© des choses inutiles et il est temps de r√©gler avec pr√©cision le niveau bas.  Il s'agit certainement d'un type d'art particulier.  Beaucoup de gens font des choses inutiles, mais vont si vite qu'ils n'ont pas le temps de se soucier de la performance.  Mais c'est tant que la question ne tient pas debout.  Habituellement, 99% du temps, personne ne se soucie de ce que je fais, jusqu'au moment o√π une chose importante dont quelqu'un se soucie ne se trouve pas sur le chemin critique.  Et ici, tout le monde commence √† vous harceler sur le sujet "pourquoi cela n'a pas fonctionn√© parfaitement d√®s le d√©but."  En g√©n√©ral, il y a toujours quelque chose √† am√©liorer dans les performances.  Mais 99% du temps, vous n'avez pas de pistes!  Vous essayez simplement de faire fonctionner quelque chose et, ce faisant, vous comprenez ce qui est important.  Vous ne pouvez jamais savoir √† l'avance que cette pi√®ce doit √™tre rendue parfaite, donc, en substance, vous devez √™tre parfait en tout.  Et c'est impossible, et vous ne le faites pas.  Il y a toujours beaucoup de choses √† corriger - et c'est parfaitement normal. </p><br><h1 id="kak-delat-bolshoy-refaktoring">  Comment faire beaucoup de refactoring </h1><br><p>  <strong>Andrew</strong> : Comment travaillez-vous sur la performance?  Il s'agit d'une question transversale.  Par exemple, avez-vous d√ª travailler sur des probl√®mes r√©sultant de l'intersection d'une grande quantit√© de fonctionnalit√©s existantes? </p><br><p>  <strong>Cliff</strong> : J'essaye d'√©viter cela.  Si je sais que les performances deviendront un probl√®me, j'y pense avant de commencer √† coder, en particulier sur les structures de donn√©es.  Mais souvent, vous d√©couvrez tout cela beaucoup plus tard.  Et puis vous devez prendre des mesures extr√™mes et faire ce que j'appelle ¬´r√©√©crire et conqu√©rir¬ª: vous devez saisir une pi√®ce assez grande.  Une partie du code devra encore √™tre r√©√©crite en raison de probl√®mes de performances ou d'autre chose.  Quelle que soit la raison de la r√©√©criture du code, il est presque toujours pr√©f√©rable de r√©√©crire un bloc plus grand qu'un bloc plus petit.  En ce moment, tout le monde commence √† trembler de peur: "Oh mon Dieu, vous ne pouvez pas toucher autant de code!"  Mais, en fait, cette approche fonctionne presque toujours beaucoup mieux.  Vous devez imm√©diatement r√©soudre le gros probl√®me, dessiner un grand cercle autour de lui et dire: je vais tout r√©√©crire √† l'int√©rieur du cercle.  La bordure est beaucoup plus petite que le contenu √† l'int√©rieur qui doit √™tre remplac√©.  Et si une telle d√©limitation des fronti√®res vous permet de faire le travail √† l'int√©rieur parfaitement - vous avez les mains d√©li√©es, faites ce que vous voulez.  Une fois que vous avez compris le probl√®me, le processus de r√©√©criture est beaucoup plus facile, alors mordez un gros morceau! <br>  Dans le m√™me temps, lorsque vous r√©√©crivez en gros morceaux et que vous comprenez que les performances deviendront un probl√®me, vous pouvez imm√©diatement commencer √† vous en pr√©occuper.  Habituellement, cela se transforme en des choses simples comme ¬´ne copiez pas de donn√©es, g√©rez les donn√©es aussi simplement que possible, r√©duisez-les¬ª.  Dans les grandes r√©√©critures, il existe des moyens standard d'am√©liorer les performances.  Et ils tournent presque toujours autour des donn√©es. </p><br><h1 id="model-stoimosti">  Mod√®le de co√ªt </h1><br><p>  <strong>Andrew</strong> : Dans l'un des podcasts, vous avez parl√© de mod√®les de co√ªts dans le contexte de la productivit√©.  Pouvez-vous expliquer ce que cela voulait dire? </p><br><p>  <strong>Cliff</strong> : Bien s√ªr.  Je suis n√© √† une √©poque o√π les performances du processeur √©taient extr√™mement importantes.  Et cette √®re est de retour - le destin n'est pas sans ironie.  J'ai commenc√© √† vivre √† l'√©poque des machines huit bits; mon premier ordinateur fonctionnait avec 256 octets.  Ce sont des octets.  Tout √©tait tr√®s petit.  Nous avons d√ª lire les instructions et d√®s que nous avons commenc√© √† monter dans la pile des langages de programmation, les langages ont pris de plus en plus.  Il y avait Assembler, puis Basic, puis C, et C a repris le travail avec de nombreux d√©tails, tels que l'allocation des registres et la s√©lection des instructions.  Mais tout √©tait assez clair l√†-bas, et si j'ai fait un pointeur vers une instance d'une variable, alors j'obtiendrai la charge, et le co√ªt est connu pour cette instruction.  Le fer produit un nombre connu de cycles machine, de sorte que la vitesse d'ex√©cution de diff√©rentes pi√®ces peut √™tre calcul√©e simplement en ajoutant toutes les instructions que vous √©tiez sur le point d'ex√©cuter.  Chaque comparaison / test / branche / appel / chargement / magasin pourrait √™tre pli√© et dit: ici, vous avez le d√©lai d'ex√©cution.  Lorsque vous am√©liorez les performances, vous serez certainement attentif au type de chiffres correspondant aux petits cycles chauds. <br>  Mais d√®s que vous passez √† Java, Python et des choses similaires, vous vous √©loignez tr√®s rapidement du fer de bas niveau.  Combien co√ªte un appel getter en Java?  Si le JIT dans HotSpot est correctement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ins√©r√©</a> , il sera charg√©, mais si ce n'est pas le cas, ce sera un appel de fonction.  Comme le d√©fi r√©side dans la boucle chaude, il annulera toutes les autres optimisations de cette boucle.  Par cons√©quent, la valeur r√©elle sera beaucoup plus √©lev√©e.  Et vous perdez imm√©diatement la possibilit√© de regarder un morceau de code et de comprendre que nous devons l'ex√©cuter en termes de vitesse d'horloge du processeur, de m√©moire utilis√©e et de cache.  Tout cela ne devient int√©ressant que si vous √™tes vraiment ivre de performances. <br>  Nous sommes maintenant dans une situation o√π la vitesse des processeurs n'a presque pas augment√© depuis une d√©cennie.  Les temps anciens sont de retour!  Vous ne pouvez plus compter sur de bonnes performances monothread.  Mais si vous vous lancez soudainement dans l'informatique parall√®le - c'est incroyablement difficile, tout le monde vous regarde comme James Bond.  Une acc√©l√©ration d√©cupl√©e se produit g√©n√©ralement dans les endroits o√π quelqu'un gifle quelque chose.  La concurrence n√©cessite beaucoup de travail.  Pour obtenir la m√™me acc√©l√©ration d√©cupl√©e, vous devez comprendre le mod√®le de co√ªt.  Quoi et combien cela co√ªte.  Et pour cela, vous devez comprendre comment la langue repose sur le fer sous-jacent. <br>  Martin Thompson a un grand mot pour son blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mechanical Sympathy</a> !  Vous devez comprendre ce que le fer va faire, comment exactement il le fera et pourquoi il fait g√©n√©ralement ce qu'il fait.  En utilisant cela, il est assez simple de commencer √† lire les instructions et de d√©couvrir o√π se d√©roule le temps d'ex√©cution.  Si vous n'avez pas la formation appropri√©e, vous cherchez simplement un chat noir dans une pi√®ce sombre.  Je vois constamment des gens qui optimisent les performances et qui n'ont aucune id√©e de ce qu'ils font.  Ils sont tr√®s tourment√©s et ne vont pas vraiment quelque part.  Et quand je prends le m√™me morceau de code, y glisse quelques petits hacks et obtiens une acc√©l√©ration cinq ou dix fois, ils sont comme √ßa: eh bien, c'est tellement malhonn√™te, nous savions d√©j√† que vous allez mieux.  C‚Äôest incroyable.  De quoi je parle ... le mod√®le de co√ªt concerne le code que vous √©crivez et la vitesse √† laquelle il fonctionne en moyenne dans l'image globale. </p><br><p>  <strong>Andrew</strong> : Et comment garder un tel volume dans votre t√™te?  Est-ce atteint par plus d'exp√©rience, ou?  O√π une telle exp√©rience est-elle acquise? </p><br><p>  <strong>Cliff</strong> : Eh bien, mon exp√©rience n'a pas √©t√© la plus simple.  J'ai programm√© dans Assembler √† une √©poque o√π il √©tait possible de comprendre chaque instruction individuelle.  Cela peut para√Ætre idiot, mais depuis lors, dans ma t√™te, dans ma m√©moire, le jeu d'instructions Z80 est rest√© pour toujours.  Je ne me souviens pas du nom des personnes une minute apr√®s la conversation, mais je me souviens du code √©crit il y a 40 ans.  C'est dr√¥le, √ßa ressemble √† un syndrome de "l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">idiot savant</a> ". </p><br><h1 id="obuchenie-nizkourovnevym-optimizaciyam">  Formation d'optimisation de bas niveau </h1><br><p>  <strong>Andrew</strong> : Existe-t-il un moyen plus simple de se lancer en affaires? </p><br><p>  <strong>Cliff</strong> : Oui et non.  Le fer que nous utilisons tous n'a pas tellement chang√© pendant cette p√©riode.  Tout le monde utilise x86, √† l'exception des smartphones Arm.  Si vous ne faites pas d‚Äôincorporation hardcore, vous avez la m√™me chose.  Ok, ensuite.  Les instructions, elles aussi, n'ont pas chang√© depuis des si√®cles.  Vous devez aller √©crire quelque chose dans Assembler.  Un peu, mais assez pour commencer √† comprendre.  Vous souriez, mais je suis absolument s√©rieux.  Il est n√©cessaire de comprendre la correspondance du langage et du fer.  Apr√®s cela, vous devez aller faire pipi un peu et faire un petit compilateur de jouets pour un petit langage de jouets.  ¬´Jouet¬ª signifie que vous devez le faire dans un d√©lai raisonnable.  Cela peut √™tre super simple, mais il doit g√©n√©rer des instructions.  Le fait de g√©n√©rer des instructions nous permettra de comprendre le mod√®le de co√ªt du pont entre le code de haut niveau sur lequel tout le monde √©crit et le code machine qui s'ex√©cute sur le mat√©riel.  Cette correspondance sera br√ªl√©e dans le cerveau au moment de la r√©daction du compilateur.  M√™me le compilateur le plus simple.  Apr√®s cela, vous pouvez commencer √† regarder Java et le fait qu'il a un foss√© s√©mantique plus profond, et construire des ponts par-dessus est beaucoup plus difficile.  En Java, il est beaucoup plus difficile de comprendre si notre pont s'est av√©r√© bon ou mauvais, ce qui le fera s'effondrer et non.  Mais vous avez besoin d'un point de d√©part lorsque vous regardez le code et comprenez: ¬´oui, ce getter doit √™tre en ligne √† chaque fois¬ª.  Et puis il s'av√®re que cela arrive parfois, √† l'exception de la situation o√π la m√©thode devient trop volumineuse et le JIT commence √† tout aligner.  La performance de ces lieux peut √™tre pr√©dite instantan√©ment.  Habituellement, les getters fonctionnent bien, mais ensuite vous regardez les grandes boucles chaudes et vous vous rendez compte qu'il existe des appels de fonctions flottants qui ne savent pas ce qu'ils font.  C'est le probl√®me de l'utilisation g√©n√©ralis√©e des getters, la raison pour laquelle ils ne s'alignent pas - il n'est pas clair s'il s'agit d'un getter.  Si vous avez une base de code tr√®s petite, vous pouvez simplement vous en souvenir et dire: c'est un getter, mais c'est un setter.  Dans une grande base de code, chaque fonction vit sa propre histoire, qui, en g√©n√©ral, n'est connue de personne.  Le profileur dit que nous avons perdu 24% de notre temps sur une sorte de cycle, et pour comprendre ce que fait ce cycle, nous devons regarder chaque fonction √† l'int√©rieur.  Il est impossible de comprendre cela sans √©tudier la fonction, ce qui ralentit s√©rieusement le processus de compr√©hension.  C'est pourquoi je n'utilise pas de getters et setters, je suis pass√© √† un nouveau niveau! <br>  O√π trouver le mod√®le de co√ªt?  Eh bien, vous pouvez lire quelque chose, bien s√ªr ... Mais je pense que la meilleure fa√ßon est d'agir.  Faites un petit compilateur et ce sera le meilleur moyen de r√©aliser le mod√®le de co√ªt et de l'adapter √† votre propre t√™te.  Un petit compilateur qui fonctionnerait pour la programmation micro-ondes est une t√¢che pour un d√©butant.  Eh bien, je veux dire, si vous avez d√©j√† des comp√©tences en programmation, elles devraient suffire.  Toutes ces choses sont comme analyser une cha√Æne, dont vous aurez une sorte d'expression alg√©brique, extraire les instructions des op√©rations math√©matiques √† partir de l√† dans le bon ordre, prendre les valeurs correctes des registres - tout cela se fait √† la fois.  Et pendant que vous le ferez, il sera imprim√© dans le cerveau.  Je pense que tout le monde sait ce que fait le compilateur.  Et cela donnera une compr√©hension du mod√®le de co√ªt. </p><br><h1 id="prakticheskie-primery-uluchsheniya-proizvoditelnosti">  √âtudes de cas d'am√©lioration de la productivit√© </h1><br><p>  <strong>Andrew</strong> : √Ä quoi d'autre vaut-il attention lorsque vous travaillez sur la performance? </p><br><p>  <strong>Cliff</strong> : structures de donn√©es.  Soit dit en passant, oui, je n'ai pas enseign√© ces cours depuis longtemps ... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rocket School</a> .  C'√©tait dr√¥le, mais il a fallu tellement d'efforts pour investir, et j'ai aussi la vie!  D'accord.  Donc, dans l'une des grandes et int√©ressantes classes, ¬´O√π vont vos performances¬ª, j'ai donn√© un exemple aux √©tudiants: deux gigaoctets et demi de donn√©es fintech ont √©t√© lues √† partir d'un fichier CSV, puis nous avons d√ª calculer le nombre de produits vendus.  Donn√©es de march√© des ticks r√©guli√®res.  Paquets UDP convertis au format texte depuis les ann√©es 70.  Le Chicago Mercantile Exchange regroupe toutes sortes de choses comme le beurre, le ma√Øs, le soja, etc.  Il a fallu compter ces produits, le nombre de transactions, le volume moyen des mouvements de fonds et de marchandises, etc.  C'est un calcul commercial assez simple: trouvez le code produit (ce sont 1-2 caract√®res dans la table de hachage), obtenez le montant, ajoutez-le √† l'un des ensembles d'op√©rations, ajoutez du volume, ajoutez de la valeur et quelques autres choses.  Math√©matiques tr√®s simples.  L'impl√©mentation du jouet √©tait tr√®s simple: tout se trouve dans le fichier, je lis le fichier et je le d√©place, s√©parant les entr√©es individuelles en cha√Ænes Java, recherchant les √©l√©ments n√©cessaires en elles et les pliant selon les math√©matiques d√©crites ci-dessus.  Et cela fonctionne √† une faible vitesse. </p><br><p> Avec cette approche, tout ce qui se passe est √©vident, et le calcul parall√®le n'aidera pas ici, non?  Il s'av√®re qu'une multiplication par cinq de la productivit√© ne peut √™tre obtenue qu'en choisissant les bonnes structures de donn√©es.  Et cela surprend m√™me les programmeurs exp√©riment√©s!  Dans mon cas particulier, l'astuce √©tait que vous ne devriez pas faire d'allocations de m√©moire dans une boucle chaude.  Eh bien, ce n'est pas toute la v√©rit√©, mais en g√©n√©ral - vous ne devriez pas mettre en √©vidence "une fois dans X" lorsque X est assez grand.  Lorsque X est de deux gigaoctets et demi, vous ne devez rien allouer ¬´une fois par lettre¬ª, ¬´une fois par ligne¬ª ou ¬´une fois par champ¬ª, rien de tout cela.  C‚Äôest exactement ce qui prend du temps.  Comment √ßa marche m√™me?  Imaginez <code>String.split()</code> un appel √† <code>String.split()</code> ou <code>BufferedReader.readLine()</code> .  <code>Readline</code> cr√©e une ligne √† partir d'un ensemble d'octets venant sur le r√©seau, une fois pour chaque ligne, pour chacune des centaines de millions de lignes.  Je prends cette ligne, j'analyse et je la jette.  Pourquoi le jeter - eh bien, je l'ai d√©j√† trait√©, c'est tout.  Donc, pour chaque octet lu √† partir de ces 2.7G, deux caract√®res seront √©crits dans la ligne, c'est-√†-dire 5.4G d√©j√†, et je n'en ai plus besoin, donc ils sont rejet√©s.  Si vous regardez la bande passante m√©moire, nous chargeons 2,7 G, qui passent par la m√©moire et le bus m√©moire du processeur, puis deux fois plus sont envoy√©s √† la ligne situ√©e dans la m√©moire, et tout cela est effac√© lors de la cr√©ation de chaque nouvelle ligne.  Mais j'ai besoin de le lire, le fer le lit, m√™me si alors tout sera frott√©.  Et je dois l'√©crire, car j'ai cr√©√© la ligne et les caches √©taient pleins - le cache ne peut pas contenir 2,7 G.  Au total, pour chaque octet lu, je lis deux autres octets et j'√©cris deux octets suppl√©mentaires, et en cons√©quence, ils ont un rapport 4: 1 - dans ce rapport, nous gaspillons la bande passante m√©moire.  Et puis il s'av√®re que si je fais <code>String.split()</code> , alors je ne le fais pas la derni√®re fois, il peut y avoir encore 6-7 champs √† l'int√©rieur.  Par cons√©quent, le code de lecture CSV classique suivi d'une analyse de ligne entra√Æne une perte de bande passante m√©moire de l'ordre de 14: 1 par rapport √† ce que vous aimeriez vraiment avoir.  Si vous jetez ces s√©cr√©tions, vous pouvez obtenir une acc√©l√©ration quintuple. </p><br><p>  Et ce n'est pas si difficile.  Si vous regardez le code sous le bon angle, tout devient assez simple, d√®s que vous vous rendez compte de l'essence du probl√®me.  N'arr√™tez m√™me pas d'allouer de la m√©moire: le seul probl√®me est que vous allouez quelque chose et il meurt imm√©diatement et br√ªle une ressource importante en cours de route, qui dans ce cas est la bande passante m√©moire.  Et tout cela se traduit par une baisse de productivit√©.  Sur x86, vous devez g√©n√©ralement graver activement les horloges du processeur, et ici, vous avez br√ªl√© toute la m√©moire beaucoup plus t√¥t.  Solution - vous devez r√©duire la quantit√© de d√©charge. <br>  Une autre partie du probl√®me est que si vous d√©marrez le profileur √† la fin de la bande de m√©moire, juste au moment o√π cela se produit, vous attendez g√©n√©ralement le retour du cache, car il est plein de d√©chets que vous venez d'appara√Ætre avec toutes ces lignes.  Par cons√©quent, chaque op√©ration de chargement ou de stockage devient lente, car elles entra√Ænent des √©checs dans le cache - le cache entier est devenu lent, attendant que les ordures le quittent.  Par cons√©quent, le profileur n'affichera que du bruit al√©atoire chaud √©tal√© tout au long du cycle - il n'y aura pas d'instruction chaude s√©par√©e ni de place dans le code.  Juste le bruit.  Et si vous regardez les cycles GC, ils seront tous de jeune g√©n√©ration et ultra-rapides - microsecondes ou millisecondes maximum.  Apr√®s tout, toute cette m√©moire meurt instantan√©ment.  Vous allouez des milliards de gigaoctets, et cela les coupe, et les coupe, et les coupe √† nouveau.  Tout cela se passe tr√®s rapidement.  Il s'av√®re qu'il existe des cycles GC bon march√©, du bruit chaud tout au long du cycle, mais nous voulons obtenir une acc√©l√©ration 5x.  √Ä ce moment, quelque chose devrait se refermer dans ma t√™te et sonner: "pourquoi donc?!"  Le d√©bordement de bande passante n'appara√Æt pas dans le d√©bogueur classique, vous devez ex√©cuter le d√©bogueur du compteur de performances mat√©rielles et le voir vous-m√™me et directement.  Et pas directement, on peut soup√ßonner ces trois sympt√¥mes.  Le troisi√®me sympt√¥me est quand vous regardez ce que vous mettez en √©vidence, demandez au profileur, et il r√©pond: "Vous avez fait un milliard de lignes, mais le GC a fonctionn√© gratuitement."  D√®s que cela s'est produit, vous vous rendez compte que vous avez g√©n√©r√© trop d'objets et br√ªl√© toute la bande de m√©moire.  Il existe un moyen de comprendre cela, mais ce n'est pas √©vident. </p><br><p>  Le probl√®me est dans la structure des donn√©es: la structure nue derri√®re tout ce qui se passe, elle est trop grande, elle est de 2,7 G sur le disque, donc faire une copie de cette chose est tr√®s ind√©sirable - je veux la charger du tampon d'octets r√©seau imm√©diatement dans les registres afin de ne pas lire-√©crire dans la cha√Æne d'avant en arri√®re cinq fois.  Malheureusement, Java par d√©faut ne vous offre pas une telle biblioth√®que dans le cadre du JDK.  Mais c'est trivial, non?  En fait, ce sont 5 √† 10 lignes de code qui seront utilis√©es pour impl√©menter votre propre chargeur de ligne en m√©moire tampon, qui r√©p√®te le comportement de la classe de ligne, tout en √©tant un wrapper autour du tampon d'octets sous-jacent.  En cons√©quence, il s'av√®re que vous travaillez presque comme avec des cha√Ænes, mais en fait, il y a des pointeurs vers le tampon, et les octets bruts ne sont copi√©s nulle part, et donc les m√™mes tampons sont r√©utilis√©s, maintes et maintes fois, et le syst√®me d'exploitation est heureux de prendre en charge des choses auxquelles il est destin√©, comme la double mise en m√©moire tampon cach√©e de ces tampons d'octets, et vous-m√™me ne broyez plus un flux sans fin de donn√©es inutiles.  Par ailleurs, vous comprenez, lorsque vous travaillez avec le GC, il est garanti que chaque allocation de m√©moire ne sera pas visible pour le processeur apr√®s le dernier cycle du GC?  Par cons√©quent, tout cela ne peut en aucun cas √™tre dans le cache, puis un √©chec garanti √† 100% se produit.  Lorsque vous travaillez avec un pointeur sur x86, la soustraction d'un registre de la m√©moire prend 1-2 cycles, et d√®s que cela se produit, vous payez, payez, payez, car la m√©moire est enti√®rement sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">neuf caches</a> - et c'est le co√ªt d'allocation de m√©moire.  Valeur actuelle. </p><br><p>  En d'autres termes, les structures de donn√©es sont les plus difficiles √† modifier.  Et d√®s que vous r√©alisez que vous avez choisi la mauvaise structure de donn√©es qui tuera la productivit√© √† l'avenir, vous devez g√©n√©ralement acc√©l√©rer le travail essentiel, mais si vous ne le faites pas, ce sera pire.  Tout d'abord, vous devez penser aux structures de donn√©es, c'est important.  Le co√ªt principal r√©side ici dans les structures de donn√©es en gras, qu'ils commencent √† utiliser dans le style "J'ai copi√© la structure de donn√©es X dans la structure de donn√©es Y, parce que j'aime mieux la forme."  Mais l'op√©ration de copie (qui semble bon march√©) d√©pense en fait une bande de m√©moire et ici tout le temps d'ex√©cution perdu est enterr√©.  Si j'ai une cha√Æne g√©ante avec JSON et que je veux la transformer en un arbre DOM structur√© √† partir de POJO ou quelque chose comme √ßa, l'op√©ration d'analyse de cette cha√Æne et de construction d'un POJO, puis un nouvel appel √† POJO √† l'avenir se r√©v√©lera sans valeur - ce n'est pas une chose ch√®re.  Sauf si vous courrez sur POJO beaucoup plus souvent que sur une ligne.  √Ä la place, vous pouvez essayer de d√©chiffrer la cha√Æne et de n'en extraire que ce dont vous avez besoin, sans la transformer en POJO.  Si tout cela se produit sur le chemin √† partir duquel des performances maximales sont requises, pas de POJO pour vous - vous devez en quelque sorte creuser directement dans la ligne. </p><br><h1 id="zachem-sozdavat-svoy-yazyk-programmirovaniya">  Pourquoi cr√©er votre propre langage de programmation </h1><br><p>  <strong>Andrei</strong> : Vous avez dit que pour comprendre le mod√®le de co√ªt, vous devez √©crire votre propre petite langue ... </p><br><p>  <strong>Cliff</strong> : Pas un langage, mais un compilateur.  Le langage et le compilateur sont deux choses diff√©rentes.  La diff√©rence la plus importante est dans votre t√™te. </p><br><p>  <strong>Andrei</strong> : Au fait, pour autant que je sache, vous exp√©rimentez la cr√©ation de vos propres langues.  Pourquoi? </p><br><p>  <strong>Cliff</strong> : Parce que je peux!  Je suis √† moiti√© retrait√©, c'est donc mon hobby.  J'ai impl√©ment√© les langues de quelqu'un d'autre toute ma vie.  J'ai √©galement travaill√© dur sur le style de codage.  Et aussi parce que je vois des probl√®mes dans d'autres langues.  Je vois qu'il y a de meilleures fa√ßons de faire les choses habituelles.  Et je les utiliserais.  J'en ai juste assez de voir des probl√®mes en moi, en Java, en Python, dans n'importe quel autre langage.  J'√©cris sur React Native, JavaScript et Elm comme passe-temps, qui ne concerne pas la retraite, mais le travail actif.  Et j'√©cris √©galement en Python et, tr√®s probablement, je continuerai √† travailler sur l'apprentissage automatique pour les backends Java.  Il existe de nombreuses langues populaires et toutes ont des fonctionnalit√©s int√©ressantes.  Tout le monde est bon dans quelque chose qui lui est propre et vous pouvez essayer de rassembler tous ces jetons.  Donc, j'√©tudie les choses qui m'int√©ressent, le comportement du langage, j'essaye de trouver une s√©mantique raisonnable.  Et jusqu'ici je le fais!  En ce moment, je lutte avec la s√©mantique de la m√©moire, car je veux l'avoir √† la fois en C et en Java, et obtenir un mod√®le de m√©moire et une s√©mantique de m√©moire solides pour les charges et les magasins.  Dans le m√™me temps, avoir une inf√©rence de type automatique comme dans Haskell.  Ici, j'essaie de m√©langer l'inf√©rence de type Haskell avec la m√©moire fonctionnant √† la fois en C et en Java.  Je fais cela depuis 2-3 mois, par exemple. </p><br><p>  <strong>Andrei</strong> : Si vous construisez une langue qui prend de meilleurs aspects des autres langues, pensiez-vous que quelqu'un ferait le contraire: prenez vos id√©es et utilisez-les? </p><br><p>  <strong>Cliff</strong> : C'est comme √ßa que de nouvelles langues apparaissent!  Pourquoi Java est-il similaire √† C?  Parce que C avait une bonne syntaxe que tout le monde comprenait et Java s'est inspir√© de cette syntaxe, ajoutant la s√©curit√© des types, v√©rifiant les limites des tableaux, GC, et ils ont √©galement am√©lior√© certaines choses de C. Ils ont ajout√© les leurs.  Mais ils ont √©t√© un peu inspir√©s, non?  Tout le monde se tient sur les √©paules des g√©ants qui vous ont pr√©c√©d√© - c'est ainsi que les progr√®s sont r√©alis√©s. </p><br><p>  <strong>Andrew</strong> : Si je comprends bien, votre langue sera en s√©curit√© concernant l'utilisation de la m√©moire.  Avez-vous d√©j√† pens√© √† impl√©menter quelque chose comme le v√©rificateur d'emprunt de Rust?  Tu l'as regard√©, comment t'aimait-il? </p><br><p>  <strong>Cliff</strong> : Eh bien, j'√©cris du C depuis des lustres, avec tous ces malloc et gratuitement, et je g√®re manuellement la dur√©e de vie.  Vous savez, 90 √† 95% d'une dur√©e de vie g√©r√©e manuellement a la m√™me structure.  Et c'est tr√®s, tr√®s douloureux de le faire manuellement.  J'aimerais que le compilateur dise simplement ce qui se passe l√†-bas et ce que vous avez r√©alis√© avec vos actions.  Pour certaines choses, un v√©rificateur d'emprunt le fait hors de la bo√Æte.  Et il devrait afficher automatiquement les informations, tout comprendre et ne pas me surcharger pour affirmer cette compr√©hension.  Il doit faire au moins une analyse d'√©chappement locale, et seulement s'il √©choue, vous devez ajouter des annotations de type qui d√©crivent la dur√©e de vie - et un tel sch√©ma est beaucoup plus compliqu√© qu'un v√©rificateur d'emprunt ou tout v√©rificateur de m√©moire existant.  Le choix entre "tout est en ordre" et "je n'ai rien compris" - non, il doit y avoir quelque chose de mieux. <br>  Donc, en tant que personne qui a √©crit beaucoup de code C, je pense que la prise en charge du contr√¥le automatique de la dur√©e de vie est la chose la plus importante.  Et je me suis lass√© de la quantit√© de m√©moire utilis√©e par Java et la principale plainte concerne GC.  Lors de l'allocation de m√©moire en Java, vous ne retournerez pas la m√©moire qui √©tait locale sur la derni√®re boucle GC.  Dans les langues avec une gestion de m√©moire plus pr√©cise, ce n'est pas le cas.  Si vous appelez malloc, vous obtenez imm√©diatement la m√©moire qui vient d'√™tre utilis√©e.  Habituellement, vous faites des choses temporaires avec votre m√©moire et vous les ramenez imm√©diatement.  Et elle retourne imm√©diatement √† la piscine malloc, et le prochain cycle malloc la sort de nouveau.  Par cons√©quent, l'utilisation r√©elle de la m√©moire est r√©duite √† un ensemble d'objets vivants √† un moment donn√©, plus les fuites.  Et si tout ne se d√©roule pas de mani√®re ind√©cente, la majeure partie de la m√©moire s'installe dans les caches et le processeur, et cela fonctionne rapidement.  Mais cela n√©cessite beaucoup de gestion manuelle de la m√©moire avec malloc et gratuit, appel√© dans le bon ordre, au bon endroit.  La rouille elle-m√™me peut g√©rer cela correctement et dans un tas de cas donner des performances encore plus √©lev√©es, car la consommation de m√©moire est limit√©e uniquement aux calculs actuels - au lieu d'attendre le prochain cycle de GC pour lib√©rer de la m√©moire.  En cons√©quence, nous avons obtenu un moyen tr√®s int√©ressant d'am√©liorer les performances.  Et assez puissant - dans le sens, j'ai fait de telles choses lors du traitement des donn√©es pour la fintech, et cela m'a permis d'obtenir une acc√©l√©ration cinq fois.  Il s'agit d'une acc√©l√©ration assez importante, en particulier dans un monde o√π les processeurs ne vont pas plus vite, et nous continuons tous d'attendre des am√©liorations. </p><br><h1 id="karera-performans-inzhenera">  Carri√®re d'ing√©nieur de performance </h1><br><p>  <strong>Andrew</strong> : Je voudrais √©galement poser des questions sur la carri√®re dans son ensemble.  Vous √™tes devenu c√©l√®bre pour avoir travaill√© chez JIT √† HotSpot puis avoir d√©m√©nag√© √† Azul - et c'est √©galement une entreprise JVM.  Mais ils √©taient d√©j√† engag√©s dans plus de fer que de logiciels.  Et puis, tout √† coup, je suis pass√© au Big Data et au Machine Learning, puis √† la d√©tection des fraudes.  Comment est-ce arriv√©?  Ce sont des domaines de d√©veloppement tr√®s diff√©rents. </p><br><p>  <strong>Cliff</strong> : Je programme depuis un certain temps maintenant et j'ai r√©ussi √† m'enregistrer dans des classes tr√®s diff√©rentes.  Et quand les gens disent: ¬´Oh, c'est toi qui a fait JIT pour Java!¬ª, C'est toujours dr√¥le.  Mais avant cela, j'√©tais engag√© dans le clone PostScript - le langage qu'Apple utilisait autrefois pour ses imprimantes laser.  Et avant cela, il a fait la mise en ≈ìuvre de la langue Forth.  Je pense que le th√®me commun pour moi est le d√©veloppement d'outils.  Toute ma vie, j'ai cr√©√© des outils avec lesquels d'autres personnes √©crivent leurs programmes sympas.  Mais j'ai √©galement √©t√© impliqu√© dans le d√©veloppement de syst√®mes d'exploitation, de pilotes, de d√©bogueurs au niveau du noyau, de langages pour d√©velopper le syst√®me d'exploitation, qui a commenc√© trivialement, mais au fil du temps, tout est devenu compliqu√© et compliqu√©.  Mais le sujet principal est n√©anmoins le d√©veloppement d'outils.  Un gros morceau de vie s'est pass√© entre Azul et Sun, et il s'agissait de Java.  Mais quand j'ai commenc√© le Big Data et le Machine Learning, j'ai mis mon chapeau de nouveau et j'ai dit: "Oh, et maintenant nous avons un probl√®me non trivial, et ici beaucoup de choses int√©ressantes et de gens qui font quelque chose" se produisent.  C'est un excellent chemin de d√©veloppement qui m√©rite d'√™tre suivi. </p><br><p>  Oui, j'aime vraiment l'informatique distribu√©e.  Mon premier travail a √©t√© √©tudiant en C, sur un projet publicitaire.  Celles-ci √©taient r√©parties sur des puces Zilog Z80, qui collectaient des donn√©es pour la reconnaissance optique de texte analogique produites par un v√©ritable analyseur analogique.  C'√©tait un sujet cool et totalement anormal.  Mais il y avait des probl√®mes, une partie n'√©tait pas reconnue correctement, il √©tait donc n√©cessaire d'obtenir une photo et de la montrer √† une personne qui lisait d√©j√† avec ses yeux et informait ce qui s'y disait, et donc il y avait des jongleurs de donn√©es, et ce travail avait sa propre langue .  Il y avait un backend qui g√©rait tout cela - fonctionnant parall√®lement au Z80 avec des terminaux vt100 en cours d'ex√©cution - un par personne, et il y avait un mod√®le de programmation parall√®le sur le Z80.  Un certain morceau de m√©moire commun partag√© par tous les Z80 √† l'int√©rieur d'une configuration en √©toile;  le fond de panier √©tait partag√©, et la moiti√© de la RAM √©tait partag√©e au sein du r√©seau, et une autre moiti√© √©tait priv√©e ou d√©pens√©e pour autre chose.  Un syst√®me distribu√© parall√®le significativement complexe avec une m√©moire partag√©e ... semi-partag√©e.  Quand c'√©tait ... D√©j√† √† ne pas me souvenir, quelque part au milieu des ann√©es 80.  Il y a tr√®s longtemps. <br>  Oui, nous supposerons que 30 ans, c'est assez long. Les t√¢ches associ√©es √† l'informatique distribu√©e existent depuis longtemps, les gens ont longtemps combattu avec les clusters <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Beowulf</a> .  De tels clusters ressemblent √† ... Par exemple: il y a Ethernet et votre x86 rapide est connect√© √† cet Ethernet, et maintenant vous voulez obtenir de la fausse m√©moire partag√©e, car personne ne pouvait alors faire le codage de l'informatique distribu√©e, c'√©tait trop compliqu√© et donc c'√©tait de la fausse m√©moire partag√©e avec protection pages de m√©moire x86, et si vous avez √©crit sur cette page, nous avons dit aux autres processeurs que s'ils avaient acc√®s √† la m√™me m√©moire partag√©e, elle devrait √™tre t√©l√©charg√©e de vous, et donc quelque chose comme un protocole de prise en charge de la coh√©rence du cache est apparu et un logiciel pour cela.  Concept int√©ressant.  Le vrai probl√®me, bien s√ªr, √©tait diff√©rent.  Tout cela a fonctionn√©, mais vous avez rapidement rencontr√© des probl√®mes de performances, car personne ne comprenait les mod√®les de performances √† un niveau suffisamment bon - quels mod√®les d'acc√®s √† la m√©moire sont l√†, comment s'assurer que les n≈ìuds ne se pingent pas sans fin, etc. </p><br><p>  Dans H2O, j'ai trouv√© ceci: les d√©veloppeurs eux-m√™mes sont responsables de d√©terminer o√π le parall√©lisme est cach√© et o√π il ne l'est pas.  J'ai cr√©√© un tel mod√®le de codage que l'√©criture de code haute performance √©tait facile et simple.  Mais l'√©criture de code √† ex√©cution lente est difficile, elle sera mauvaise.  Vous devez s√©rieusement essayer d'√©crire du code lent, vous devez utiliser des m√©thodes non standard.  Le code de freinage est visible en un coup d'≈ìil.  Par cons√©quent, le code est g√©n√©ralement √©crit et fonctionne rapidement, mais vous devez savoir quoi faire dans le cas de la m√©moire partag√©e.  Tout cela est li√© aux grands tableaux et le comportement y est similaire aux grands tableaux non volatils en Java parall√®le.  Je veux dire, imaginez que deux threads √©crivent dans un tableau parall√®le, l'un d'eux gagne, et l'autre, respectivement, perd, et vous ne savez pas lequel d'entre eux est qui.  S'ils ne sont pas volatils, l'ordre peut √™tre n'importe quoi - et cela fonctionne vraiment bien.  Les gens se soucient vraiment de l'ordre des op√©rations, ils d√©finissent correctement la volatilit√© et ils s'attendent √† des probl√®mes de m√©moire aux bons endroits.  Sinon, ils √©criraient simplement du code sous la forme de cycles de 1 √† N, o√π N repr√©sente quelques milliers de milliards, dans l'espoir que tous les cas complexes deviendront automatiquement parall√®les - et l√† cela ne fonctionne pas.  Mais dans H2O ce n'est ni Java ni Scala, vous pouvez le consid√©rer comme ¬´Java moins moins¬ª si vous le souhaitez.  Il s'agit d'un style de programmation tr√®s compr√©hensible et similaire √† l'√©criture de code C ou Java simple avec des boucles et des tableaux.  Mais en m√™me temps, la m√©moire peut √™tre trait√©e avec des t√©raoctets.  J'utilise toujours H2O.        ‚Äì        ,     .    Big Data   ,    H2O. </p><br><h1 id="tehnicheskie-chellenzhi">   </h1><br><p> <strong></strong> :          ? </p><br><p> <strong></strong> :        ?   ,    ‚Äì  . <br>    .    .    ,     ,     ,      ,  .     Sun,   ,    ,      ,       .      ,      ,   .     ,   C1,      ,    ‚Äì      .                   ,         . ,         x86-    ,    ,      5-10    ,       50 . </p><br><p>  ,       ,        ,        ,    C.  , ,   - ,   C  .       C,       C    .   ,    ,     C,      - ‚Ä¶    ,      .     ,      .     ,           ,     .      ,    ,        5% .          -    ‚Äì     ,         ¬´     ¬ª,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,    .     :               ,  ,    .     .  ,     ‚Äì    ,       .    ,        .       -  ‚Äì    .   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>   ,    (   ,   ),  ,     ,       .       ,    ,     ,      . </p><br><p>   , ,    ,  ,     ,       ,   .    ,   ,        ,   -   .     ,     ,     ,          .    ,      ,       ,  ,    . ,     :     ,           . ,   ,  - : ,   ,   -   ,    .      ‚Äì  , ,    ‚Äì   ! ‚Äì     ,      .       Java. Java    ,         ,   ,   ,       ‚Äì   ,       ¬´  ¬ª.           , ,   .            ,   Java  C    .    ‚Äì      Java,       C   ,   ,    ,   . ,    ‚Äì  ,      .    ,  .    ,    ,       .     :      . </p><br><h1 id="nemnogo-pro-allokaciyu-registrov-i-mnogoyadernost">       </h1><br><p> <strong></strong> :      -   . ,   ,  -   ,     ? </p><br><p> <strong></strong> : !   ‚Äì  ,     NP-     - .        , ?   . , Ahead of Time  ‚Äì    .     -  .   ,       ,       ‚Äì   ,      !   ‚Äì  ,   .       ,      ,    .    .   ?    ,       : ,   ,   -  !  -  ,             .   .     ,       ,       .      : - , - .        ,      ,   .  ,     ,  ,      ,     - .    !      ,     ,  ,   ‚Äì        .    .      NP- . </p><br><p> <strong></strong> :  ,       ‚Äì    . ,   ,   ,   ,     ‚Ä¶ </p><br><p> <strong></strong> :     .       ¬´¬ª.       .   ,     .        ‚Äì  ,  ,  ,             ( , ).   ,  -  .    ,   ,   ,        . , ,   .            ,     .   ,             ,     .     ,   ,   .          ,     ,  -       ,     ‚Äì .      ‚Äì              . ,     GC,    , ,  ,     ‚Äì  ,     .    ,  .              ,     ,         . ,   ‚Äì    , ?       ,       . </p><br><p> <strong></strong> :     ,    ?   ? </p><br><p> <strong></strong> :  GPU ,   ! </p><br><p> <strong></strong> :   .      ? </p><br><p> <strong></strong> : ,   - Azul.     ,      .      .   H2O  ,       .     ,    GPU.            ? ,     Azul,  :   ‚Äì  . </p><br><h1 id="samyy-bolshoy-chellenzh-v-zhizni">      </h1><br><p> <strong></strong> :    ? </p><br><p> <strong></strong> :      ,   ‚Ä¶     .   ,       . ,    ,    ,   ,             .   ,   ,    . ,   Java   C1  C2 ‚Äì   . ,   Java        ‚Äì   . ,      ,    ‚Äì    .       ‚Ä¶   . - ,      Sun,  ‚Ä¶ ,   ,        .     ,           .  ,        .       ‚Ä¶        ‚Ä¶  ,        .   , , .       .     - ,      :   .  , , ,   ,  ,    ,     .   ,        .          .      ,    . ¬´    ,   ,   ¬ª.   : ¬´!¬ª.    ,  , , : ,           . </p><br><p>  ‚Äì    ,    ,       ,     .      .      ,        ,            ,  ,    .  ,      Java JIT,  C2.       ,  ‚Äì         .       ,   ‚Äì   !    .  ,   ,  ,     ,    ,       ,    .        .    .        ,   . ,      ,       ,      ,        :      ,     ,     .   ,           ‚Äì      .       ,     ,      -   .     : ¬´     ?¬ª.  ,          .      ,     ,      : ,    ,        ‚Äì     ?       ,  .  ,   ,  ,  ,         ,    ,     - . </p><br><p> <strong></strong> :         ,    -.     ? </p><br><p> <strong></strong> : ,     ,       .      ‚Äì   .      . ,    .        .          .   :    ,   ,   - ‚Äì          .      .  ,       ,      ‚Äì   ,       . ,    ,    ,          ,  -  ,        .       ,       .       ,       ,     - .   ,    ,     ‚Äì   ,  . <br>       ,    .   ,    ‚Äì   ,   ,    .  ,   .     ,       ‚Äì   .     ,       .   ,     ,     ¬´  ¬ª,      ,  ‚Äì   ,   ,       ,     ,        .     ,  ,    ¬´  ¬ª. </p><br><p>       .   .   - ,      ,        ¬´¬ª:    ,    ‚Äì .  ‚Äì     .         ,  ,    . ¬´,     -,     ,    ¬ª.       ,     : ,  .  ,     ,     .  .   ‚Äì ,     . , ?  ,     ?    ? ,          ?        .       ,  .    ‚Äì   .     .  ,     .     ‚Äì    ‚Äì  ,        .        ,   ¬´ ¬ª   .    : ¬´--¬ª,  : ¬´, !¬ª   .   .   ,       ,   ,    ,        .     ,      .        ,         .    ,         ‚Äì      ,    .    ‚Äì   ,            .      ,    ,   ,   . </p><br><p> ,           ‚Äì   , .          ,        , .    ,   .         ,    ,    ,    ,      .        ,      ,       . ,       ,      ,          ,      .          .     ,      ,     ,      .    ,     ,    ,        ,    .      , ,    ,   .   ,       ‚Äì  , ,    ,      .     ,     . </p><br><p> <strong></strong> :  ‚Ä¶ . ,          .          .   Hydra! </p><br><blockquote>         Hydra 2019,   11-12  2019   -.     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´The Azul Hardware Transactional Memory experience¬ª</a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458718/">https://habr.com/ru/post/fr458718/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458704/index.html">Mise en place d'un syst√®me DLP sur l'exemple du retail</a></li>
<li><a href="../fr458706/index.html">Les Gopniks sont maintenant sur les march√©s √©trangers, ou "Pourquoi est-il si difficile de trouver un programmeur normal?"</a></li>
<li><a href="../fr458708/index.html">Vous voulez <s> perdre du poids </s> pour apprendre les TI par vous-m√™me? Demandez moi comment</a></li>
<li><a href="../fr458710/index.html">Obfuscateur d'espaces blancs pour PHP</a></li>
<li><a href="../fr458716/index.html">Premier aper√ßu de l'onduleur Delta Amplon RT</a></li>
<li><a href="../fr458720/index.html">L'√©cole de programmeurs hh.ru ouvre pour la 10√®me fois un ensemble de sp√©cialistes informatiques</a></li>
<li><a href="../fr458724/index.html">R√©seaux de neurones et apprentissage profond, chapitre 3, partie 1: am√©liorer la formation des r√©seaux de neurones</a></li>
<li><a href="../fr458726/index.html">Habr Special // Podcast avec l'auteur d'Invasion. Une br√®ve histoire des pirates russes</a></li>
<li><a href="../fr458728/index.html">Que sont les v√©los √©lectriques (examen de groupe de cinq mod√®les de deux fabricants), partie 2</a></li>
<li><a href="../fr458730/index.html">Lutter contre la complexit√© du d√©veloppement logiciel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>