<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òÄÔ∏è üåï üëõ Linux Kernel 5.0 - √©criture de Simple Block Device sous blk-mq üåÄ üë©üèø‚ÄçüöÄ üèØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonne nouvelle √† tous! 

 Le noyau Linux 5.0 est d√©j√† l√† et appara√Æt dans des distributions exp√©rimentales telles que Arch, openSUSE Tumbleweed, Fedor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Linux Kernel 5.0 - √©criture de Simple Block Device sous blk-mq</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/veeam/blog/446148/">  Bonne nouvelle √† tous! <br><br>  Le noyau Linux 5.0 est d√©j√† l√† et appara√Æt dans des distributions exp√©rimentales telles que Arch, openSUSE Tumbleweed, Fedora. <br><br><img src="https://habrastorage.org/webt/me/zn/aq/meznaq4kak63su90hds63zvj1tq.png"><br><br>  Et si vous regardez les distributions RC d'Ubuntu Disko Dingo et de Red Hat 8, alors cela devient clair: bient√¥t le noyau 5.0 sera √©galement transf√©r√© des bureaux de fans aux serveurs s√©rieux. <br>  Quelqu'un dira - alors quoi.  La prochaine version, rien de sp√©cial.  Donc Linus Torvalds lui-m√™me a dit: <blockquote>  Je voudrais souligner (encore une fois) que nous ne faisons pas de versions bas√©es sur les fonctionnalit√©s, et que "5.0" ne signifie rien de plus que le fait que les nombres 4.x ont commenc√© √† devenir suffisamment gros pour que je manque de doigts et les orteils. <br><br>  ( <i>Encore une fois, je le r√©p√®te - nos versions ne sont li√©es √† aucune fonctionnalit√© sp√©cifique, donc le num√©ro de la nouvelle version 5.0 signifie seulement que pour la num√©rotation des versions 4.x, je n'ai d√©j√† pas assez de doigts et d'orteils</i> ) <br></blockquote><br>  Cependant, le module pour les disquettes (qui ne sait pas - ce sont des disques de la taille d'une chemise de poche poitrine, d'une capacit√© de 1,44 Mo) - corrig√© ... <br>  Et voici pourquoi: <br><a name="habracut"></a><br>  Il s'agit de la couche de bloc multi-file d'attente (blk-mq).  Il existe de nombreux articles d'introduction √† son sujet sur Internet, alors allons droit au but.  La transition vers blk-mq a commenc√© il y a longtemps et progressait lentement.  Scsi multi-file d'attente (param√®tre du noyau scsi_mod.use_blk_mq) est apparu, de nouveaux ordonnanceurs mq-deadline, bfq et ainsi de suite sont apparus‚Ä¶ <br><br><pre><code class="dos hljs">[root@fedora-<span class="hljs-number"><span class="hljs-number">29</span></span> sblkdev]# cat /sys/block/sda/queue/scheduler [mq-deadline] none</code> </pre> <br>  Au fait, quel est le v√¥tre? <br><br>  Le nombre de pilotes de p√©riph√©riques de blocs fonctionnant √† l'ancienne a √©t√© r√©duit.  Et dans 5.0, la fonction blk_init_queue () a √©t√© supprim√©e car inutile.  Et maintenant, l'ancien code glorieux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lwn.net/Articles/58720</a> de 2003 ne va pas non plus, mais perd √©galement sa pertinence.  De plus, les nouvelles distributions, qui sont en cours de pr√©paration pour √™tre publi√©es cette ann√©e, utilisent une couche de bloc √† files d'attente multiples dans la configuration par d√©faut.  Par exemple, le 18 Manjaro, le noyau, bien que la version 4.19, est blk-mq par d√©faut. <br><br>  Par cons√©quent, nous pouvons supposer que la transition vers blk-mq dans le noyau 5.0 est termin√©e.  Et pour moi, c'est un √©v√©nement important qui n√©cessitera la r√©√©criture du code et des tests suppl√©mentaires.  Ce qui en soi promet l'apparition de bugs grands et petits, ainsi que plusieurs serveurs en panne (Il faut, Fedya, c'est n√©cessaire! (C)). <br><br>  Soit dit en passant, si quelqu'un pense que pour rhel8, ce point de basculement n'est pas venu, puisque le noyau a √©t√© "flash√©" par la version 4.18, alors vous vous trompez.  Dans la nouvelle RC sur rhel8, les nouveaux produits de 5.0 avaient d√©j√† migr√© et la fonction blk_init_queue () avait √©galement √©t√© supprim√©e (probablement lors du d√©placement d'un autre enregistrement de github.com/torvalds/linux vers ses sources). <br>  En g√©n√©ral, la version ¬´gel¬ª du noyau pour les distributeurs Linux tels que SUSE et Red Hat est depuis longtemps un concept marketing.  Le syst√®me signale que la version, par exemple, est 4.4, et en fait la fonctionnalit√© provient d'une nouvelle vanille 4.8.  Dans le m√™me temps, une inscription s'affiche sur le site officiel comme: "Dans la nouvelle distribution, nous avons gard√© un noyau 4.4 stable pour vous." <br><br>  Mais nous √©tions distraits ... <br><br>  Alors voil√†.  Nous avons besoin d'un nouveau pilote de p√©riph√©rique de bloc simple pour rendre plus clair comment cela fonctionne. <br>  Donc, la source sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github.com/CodeImp/sblkdev</a> .  Je propose de discuter, de faire des demandes de tirage, de lancer le probl√®me - je vais le r√©parer.  QA n'a pas encore test√©. <br><br>  Plus loin dans l'article, j'essaierai de d√©crire ce pourquoi.  Par cons√©quent, il y a beaucoup de code. <br>  Je m'excuse tout de suite que le style de codage du noyau Linux n'est pas enti√®rement respect√©, et oui - je n'aime pas goto. <br><br>  Commen√ßons donc par les points d'entr√©e. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; _sblkdev_major = register_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to get major number\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EBUSY; } ret = sblkdev_add_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret) unregister_blkdev(_sblkdev_major, _sblkdev_name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ sblkdev_remove_device(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_sblkdev_major &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) unregister_blkdev(_sblkdev_major, _sblkdev_name); } module_init(sblkdev_init); module_exit(sblkdev_exit);</code> </pre><br>  √âvidemment, lorsque le module est charg√©, la fonction sblkdev_init () est lanc√©e, lorsque sblkdev_exit () est d√©charg√©e. <br>  La fonction register_blkdev () enregistre un p√©riph√©rique de bloc.  Il se voit attribuer un num√©ro majeur.  unregister_blkdev () - lib√®re ce nombre. <br><br>  La structure cl√© de notre module est sblkdev_device_t. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The internal representation of our device typedef struct sblkdev_device_s { sector_t capacity; // Device size in bytes u8* data; // The data aray. u8 - 8 bytes atomic_t open_counter; // How many openers struct blk_mq_tag_set tag_set; struct request_queue *queue; // For mutual exclusion struct gendisk *disk; // The gendisk structure } sblkdev_device_t;</span></span></code> </pre><br>  Il contient toutes les informations sur le p√©riph√©rique n√©cessaires au module noyau, en particulier: la capacit√© du p√©riph√©rique bloc, les donn√©es elles-m√™mes (c'est simple), les pointeurs vers le disque et la file d'attente. <br><br>  Toutes les initialisations de p√©riph√©rique de bloc sont effectu√©es dans la fonction sblkdev_add_device (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_add_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = kzalloc(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: unable to allocate %ld bytes\n"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } _sblkdev_device = dev; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ ret = sblkdev_allocate_buffer(dev); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ret) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//simply variant with helper function blk_mq_init_sq_queue. It`s available from kernel 4.20 (vanilla). {//configure tag_set struct request_queue *queue; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.driver_data = dev; queue = blk_mq_init_sq_queue(&amp;dev-&gt;tag_set, &amp;_mq_ops, 128, BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: unable to allocate and initialize tag set\n"); break; } dev-&gt;queue = queue; } #else // more flexible variant {//configure tag_set dev-&gt;tag_set.ops = &amp;_mq_ops; dev-&gt;tag_set.nr_hw_queues = 1; dev-&gt;tag_set.queue_depth = 128; dev-&gt;tag_set.numa_node = NUMA_NO_NODE; dev-&gt;tag_set.cmd_size = sizeof(sblkdev_cmd_t); dev-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE | BLK_MQ_F_SG_MERGE; dev-&gt;tag_set.driver_data = dev; ret = blk_mq_alloc_tag_set(&amp;dev-&gt;tag_set); if (ret) { printk(KERN_WARNING "sblkdev: unable to allocate tag set\n"); break; } } {//configure queue struct request_queue *queue = blk_mq_init_queue(&amp;dev-&gt;tag_set); if (IS_ERR(queue)) { ret = PTR_ERR(queue); printk(KERN_WARNING "sblkdev: Failed to allocate queue\n"); break; } dev-&gt;queue = queue; } #endif dev-&gt;queue-&gt;queuedata = dev; {// configure disk struct gendisk *disk = alloc_disk(1); //only one partition if (disk == NULL) { printk(KERN_WARNING "sblkdev: Failed to allocate disk\n"); ret = -ENOMEM; break; } disk-&gt;flags |= GENHD_FL_NO_PART_SCAN; //only one partition //disk-&gt;flags |= GENHD_FL_EXT_DEVT; disk-&gt;flags |= GENHD_FL_REMOVABLE; disk-&gt;major = _sblkdev_major; disk-&gt;first_minor = 0; disk-&gt;fops = &amp;_fops; disk-&gt;private_data = dev; disk-&gt;queue = dev-&gt;queue; sprintf(disk-&gt;disk_name, "sblkdev%d", 0); set_capacity(disk, dev-&gt;capacity); dev-&gt;disk = disk; add_disk(disk); } printk(KERN_WARNING "sblkdev: simple block device was created\n"); }while(false); if (ret){ sblkdev_remove_device(); printk(KERN_WARNING "sblkdev: Failed add block device\n"); } return ret; }</span></span></span></span></code> </pre><br>  Nous allouons de la m√©moire √† la structure, allouons un tampon pour stocker les donn√©es.  Rien de sp√©cial ici. <br>  Ensuite, nous initialisons la file d'attente de traitement des demandes avec soit une fonction blk_mq_init_sq_queue (), soit deux √† la fois: blk_mq_alloc_tag_set () + blk_mq_init_queue (). <br><br>  Soit dit en passant, si vous regardez le code source de la fonction blk_mq_init_sq_queue (), vous verrez qu'il ne s'agit que d'un wrapper sur les fonctions blk_mq_alloc_tag_set () et blk_mq_init_queue (), qui sont apparues dans le noyau 4.20.  De plus, il nous cache de nombreux param√®tres de la file d'attente, mais il semble beaucoup plus simple.  Vous devez choisir quelle option est la meilleure, mais je pr√©f√®re une option plus explicite. <br><br>  La cl√© de ce code est la variable globale _mq_ops. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_ops</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mq_ops</span></span></span><span class="hljs-class"> = {</span></span> .queue_rq = queue_rq, };</code> </pre><br>  C'est l√† que se trouve la fonction qui assure le traitement des demandes, mais plus √† ce sujet plus tard.  L'essentiel est que nous ayons d√©sign√© le point d'entr√©e du gestionnaire de requ√™tes. <br><br>  Maintenant que nous avons cr√©√© la file d'attente, nous pouvons cr√©er une instance du disque. <br><br>  Il n'y a pas de changements majeurs.  Le disque est allou√©, les param√®tres sont d√©finis et le disque est ajout√© au syst√®me.  Je veux expliquer le param√®tre disk-&gt; flags.  Il vous permet d'indiquer au syst√®me que le disque est amovible ou, par exemple, qu'il ne contient pas de partitions et que vous n'avez pas besoin de les rechercher √† cet endroit. <br><br>  Il existe une structure _fops pour la gestion des disques. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block_device_operations</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .open = _open, .release = _release, .ioctl = _ioctl, #ifdef CONFIG_COMPAT .compat_ioctl = _compat_ioctl, #endif };</code> </pre><br>  Les points d'entr√©e _open et _release pour nous pour un module de module bloc simple ne sont pas encore tr√®s int√©ressants.  En plus du compteur d'incr√©mentation et de d√©cr√©mentation atomique, il n'y a rien.  J'ai √©galement laiss√© compat_ioctl sans impl√©mentation, car la version des syst√®mes avec un noyau 64 bits et un environnement d'espace utilisateur 32 bits ne me semble pas prometteuse. <br><br>  Mais _ioctl vous permet de traiter les demandes du syst√®me pour ce lecteur.  Lorsqu'un disque appara√Æt, le syst√®me essaie d'en savoir plus.  Vous pouvez r√©pondre √† certaines requ√™tes comme bon vous semble (par exemple, pour faire semblant d'√™tre un nouveau CD), mais la r√®gle g√©n√©rale est la suivante: si vous ne souhaitez pas r√©pondre √† des requ√™tes qui ne vous int√©ressent pas, renvoyez simplement le code d'erreur -ENOTTY.  Au fait, si n√©cessaire, vous pouvez ajouter ici vos gestionnaires de demandes concernant ce lecteur particulier. <br><br>  Nous avons donc ajout√© l'appareil - nous devons nous occuper de la lib√©ration des ressources.  La rouille n'est pas <s>l√† pour</s> vous. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sblkdev_remove_device</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span>* dev = _sblkdev_device; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) del_gendisk(dev-&gt;disk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { blk_cleanup_queue(dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>); dev-&gt;<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span> = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;tag_set.tags) blk_mq_free_tag_set(&amp;dev-&gt;tag_set); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;disk) { put_disk(dev-&gt;disk); dev-&gt;disk = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } sblkdev_free_buffer(dev); kfree(dev); _sblkdev_device = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: simple block device was removed\n"</span></span>); } }</code> </pre><br>  En principe, tout est √©vident: nous supprimons l'objet disque du syst√®me et lib√©rons la file d'attente, apr√®s quoi nous lib√©rons √©galement nos tampons (zones de donn√©es). <br><br>  Et maintenant, la chose la plus importante est le traitement des requ√™tes dans la fonction queue_rq (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> blk_status_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queue_rq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct blk_mq_hw_ctx *hctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct blk_mq_queue_data* bd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">blk_status_t</span></span> status = BLK_STS_OK; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bd</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> blk_mq_start_request(rq); <span class="hljs-comment"><span class="hljs-comment">//we cannot use any locks that make the thread sleep { unsigned int nr_bytes = 0; if (do_simple_request(rq, &amp;nr_bytes) != SUCCESS) status = BLK_STS_IOERR; printk(KERN_WARNING "sblkdev: request process %d bytes\n", nr_bytes); #if 0 //simply and can be called from proprietary module blk_mq_end_request(rq, status); #else //can set real processed bytes count if (blk_update_request(rq, status, nr_bytes)) //GPL-only symbol BUG(); __blk_mq_end_request(rq, status); #endif } return BLK_STS_OK;//always return ok }</span></span></code> </pre><br>  Consid√©rons d'abord les param√®tres.  Le premier est struct blk_mq_hw_ctx * hctx - l'√©tat de la file d'attente mat√©rielle.  Dans notre cas, nous nous passons de la file d'attente mat√©rielle, donc inutilis√©e. <br><br>  Le deuxi√®me param√®tre est const struct blk_mq_queue_data * bd - un param√®tre avec une structure tr√®s concise, que je n'ai pas peur de pr√©senter √† votre attention dans son int√©gralit√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blk_mq_queue_data</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rq</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> last; };</code> </pre><br>  Il s'av√®re que c'est essentiellement la m√™me demande, qui nous est venue de moments dont le chroniqueur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">elixir.bootlin.com</a> ne se souvient plus.  Nous prenons donc la requ√™te et commen√ßons √† la traiter, dont nous informons le noyau en appelant blk_mq_start_request ().  √Ä la fin du traitement de la demande, nous en informerons le noyau en appelant la fonction blk_mq_end_request (). <br><br>  Voici une petite note: la fonction blk_mq_end_request () est essentiellement un wrapper sur les appels √† blk_update_request () + __blk_mq_end_request ().  Lorsque vous utilisez la fonction blk_mq_end_request (), vous ne pouvez pas sp√©cifier le nombre d'octets r√©ellement trait√©s.  Estime que tout est trait√©. <br><br>  L'option alternative a une autre fonctionnalit√©: la fonction blk_update_request est export√©e uniquement pour les modules GPL uniquement.  Autrement dit, si vous souhaitez cr√©er un module de noyau propri√©taire (laissez PM vous sauver de ce chemin √©pineux), vous ne pouvez pas utiliser blk_update_request ().  Donc, le choix vous appartient. <br><br>  D√©calant directement les octets de la demande vers le tampon et vice versa, je mets dans la fonction do_simple_request (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_simple_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct request *rq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *nr_bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = SUCCESS; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bio_vec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bvec</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req_iterator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sblkdev_device_t</span></span> *dev = rq-&gt;q-&gt;queuedata; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> pos = blk_rq_pos(rq) &lt;&lt; SECTOR_SHIFT; <span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span> dev_size = (<span class="hljs-keyword"><span class="hljs-keyword">loff_t</span></span>)(dev-&gt;capacity &lt;&lt; SECTOR_SHIFT); printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"sblkdev: request start from sector %ld \n"</span></span>, blk_rq_pos(rq)); rq_for_each_segment(bvec, rq, iter) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b_len = bvec.bv_len; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* b_buf = page_address(bvec.bv_page) + bvec.bv_offset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pos + b_len) &gt; dev_size) b_len = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)(dev_size - pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rq_data_dir(rq))<span class="hljs-comment"><span class="hljs-comment">//WRITE memcpy(dev-&gt;data + pos, b_buf, b_len); else//READ memcpy(b_buf, dev-&gt;data + pos, b_len); pos += b_len; *nr_bytes += b_len; } return ret; }</span></span></code> </pre><br>  Il n'y a rien de nouveau: rq_for_each_segment it√®re sur tout ce qui est bio, et ils ont tous des structures bio_vec, nous permettant d'acc√©der aux pages avec les donn√©es de la requ√™te. <br><br>  Quelles sont vos impressions?  Tout semble simple?  Le traitement des demandes en g√©n√©ral consiste simplement √† copier des donn√©es entre les pages de la demande et le tampon interne.  Tout √† fait digne d'un simple pilote de p√©riph√©rique de bloc, non? <br><br>  Mais il y a un probl√®me: <b>ce n'est pas pour une utilisation r√©elle!</b> <br><br>  L'essence du probl√®me est que la fonction de traitement des demandes queue_rq () est appel√©e dans une boucle qui traite les demandes de la liste.  Je ne sais pas quel verrou pour cette liste est utilis√© ici, Spin ou RCU (je ne veux pas mentir - qui sait, corrigez-moi), mais lorsque vous essayez d'utiliser, par exemple, mutex dans la fonction de traitement des demandes, le noyau de d√©bogage jure et avertit: somnoler ici c'est impossible.  Autrement dit, il est impossible d'utiliser des outils de synchronisation conventionnels ou de la m√©moire virtuelle contigu√´ - celle qui est allou√©e √† l'aide de vmalloc et peut basculer avec tout ce qu'elle implique -, car le processus ne peut pas passer en √©tat de veille. <br><br>  Par cons√©quent, seuls les verrous Spin ou RCU et un tampon sous la forme d'un tableau de pages, ou une liste, ou une arborescence, comme impl√©ment√© dans .. \ linux \ drivers \ block \ brd.c, ou un traitement retard√© dans un autre thread, comme impl√©ment√© dans .. \ linux \ drivers \ block \ loop.c. <br><br>  Je pense qu'il n'est pas n√©cessaire de d√©crire comment assembler le module, comment le charger dans le syst√®me et comment le d√©charger.  Il n'y a pas de nouveaux produits sur ce front, et merci pour √ßa :) Donc, si quelqu'un veut l'essayer, je serai s√ªr de le d√©couvrir.  <b>Ne le faites pas tout de suite sur votre ordinateur portable pr√©f√©r√©!</b>  Soulevez une virtualochka ou faites au moins une sauvegarde sur une balle. <br><br>  Soit dit en passant, Veeam Backup pour Linux 3.0.1.1046 est d√©j√† disponible.  N'essayez simplement pas d'ex√©cuter VAL 3.0.1.1046 sur un noyau 5.0 ou ult√©rieur.  veeamsnap ne s'assemble pas.  Et certaines innovations multi-files d'attente sont encore au stade des tests. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr446148/">https://habr.com/ru/post/fr446148/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr446134/index.html">Injection de d√©pendance dans Flutter</a></li>
<li><a href="../fr446136/index.html">Ma machine en marbre imprim√©e en 3D</a></li>
<li><a href="../fr446138/index.html">Comme il est facile d'organiser l√©galement votre startup sous la forme d'un simple partenariat</a></li>
<li><a href="../fr446142/index.html">Terre plate: exp√©riences et preuves</a></li>
<li><a href="../fr446144/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 292 (25 mars - 31 mars)</a></li>
<li><a href="../fr446150/index.html">Apprentissage automatique sans Python, Anaconda et autres reptiles</a></li>
<li><a href="../fr446152/index.html">Commando VM - Kali Linux Alternative pour Windows</a></li>
<li><a href="../fr446162/index.html">Comment devenir un "junior intelligent". Exp√©rience personnelle</a></li>
<li><a href="../fr446166/index.html">Codec sprintf ASN1 simple</a></li>
<li><a href="../fr446172/index.html">Limite Messages API VK - que faire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>