<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙉 🖇️ ✌🏻 Panduan Pengembangan Berbasis Komponen ✊🏿 🍨 👏🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modularitas telah menjadi salah satu prinsip utama pengembangan perangkat lunak sejak 1960-an. Menerapkan prinsip ini membawa banyak manfaat bagi pemr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Panduan Pengembangan Berbasis Komponen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/461661/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modularitas telah</a> menjadi salah satu prinsip utama pengembangan perangkat lunak sejak 1960-an.  Menerapkan prinsip ini membawa banyak manfaat bagi pemrograman.  Modularitas berkontribusi pada penggunaan efektif prinsip pemisahan tanggung jawab, yang mengarah pada peningkatan kemampuan untuk membuat, menggunakan kembali, membangun kode. <br><br>  Saat ini, penerapan prinsip modularitas dalam desain perangkat lunak telah mengambil bentuk baru, yang terkandung dalam komponen.  Ini adalah Component Driven Development (CDD).  Pustaka dan kerangka kerja modern untuk mengembangkan antarmuka pengguna, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vue,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Angular</a> , serta alat yang berorientasi CDD seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bit</a> , memungkinkan Anda membuat aplikasi berdasarkan komponen modular.  Pemrogram memiliki kemampuan dan pola yang diperlukan untuk mengembangkan komponen dalam isolasi dan membangun komposisi komponen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a43/42b/797/a4342b797c285bea1e54f23de1fc3a11.gif"></div><br>  Komponen adalah fragmen independen yang jelas dari antarmuka aplikasi.  Sebagai contoh komponen, Anda dapat mengutip entitas seperti tombol, slider, jendela untuk menampilkan pesan obrolan.  Memahami fitur-fitur CDD dan mengetahui cara menerapkan pendekatan ini untuk pengembangan, kita dapat menggunakan komponen sebagai dasar aplikasi.  Ini, ketika membuat proyek perangkat lunak, memberi kita segala sesuatu yang berguna, yang berarti menerapkan prinsip-prinsip pemrograman modular. <br><br>  Jika Anda melihat dengan cermat apa yang terjadi sekarang di bidang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komponen web</a> , Anda akan melihat bahwa CDD menjadi pendekatan standar untuk pengembangan frontend. <br><br>  Bahan, yang kami terbitkan terjemahan hari ini, adalah panduan pengembangan berbasis komponen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">CDD dalam pengembangan antarmuka pengguna</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7e/d14/aca/b7ed14acaf00de0e5c081ad77bc06d0e.gif"></div><br>  <i><font color="#999999">Bekerja pada Bit: membuat, mengisolasi, menggunakan kembali, dan berkolaborasi pada komponen</font></i> <br><br>  Sederhananya, pengembangan berbasis komponen mendesain aplikasi dengan membuat blok kode independen yang digabungkan secara longgar.  Masing-masing dari mereka memiliki antarmuka yang dirancang untuk mengatur interaksi dengan bagian lain dari sistem.  Banyak komponen, dikombinasikan satu sama lain melalui komposisi, membentuk aplikasi modular. <br><br>  Misalnya, penggunaan CDD dalam membuat aplikasi Bereaksi berarti bahwa mereka pertama-tama membuat komponen yang membentuk dasar dari aplikasi, dan kemudian melanjutkan untuk mengumpulkan dari mereka bagian-bagian aplikasi yang lebih besar, seperti seluruh halaman dan blok besar fungsionalitas. <br><br>  CDD terkait dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">desain atom</a> (di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini adalah</a> materi yang berguna tentang topik ini) dan dengan pendekatan untuk mengembangkan bagian sisi klien dari proyek web, yang dikenal sebagai " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">micro frontend</a> ". <br><br>  CDD membantu memecah proses pengembangan proyek besar menjadi proses pengembangan yang lebih kecil untuk komponen individu.  Setiap komponen dirancang secara independen dari sisa aplikasi dan dibuat dengan mempertimbangkan kemungkinan interaksi dengan bagian lain dari sistem.  Merancang setiap komponen sebagai entitas independen memberi pengembang banyak fitur yang bermanfaat. <br><br>  Eddie Osmani menguraikan beberapa manfaat utama menggunakan CDD.  Dia merancang mereka dalam seperangkat prinsip yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PERTAMA</a> . <br><br>  Prinsip-prinsip ini adalah: <br><br><ul><li>  Akselerasi pembangunan (Faster development).  Fakta bahwa upaya pengembang ditujukan untuk membuat komponen terpisah memungkinkan pembuatan bagian modular aplikasi dengan API yang sangat terspesialisasi.  Ini berarti bahwa komponen dapat, di satu sisi, dikembangkan dengan cepat, dan di sisi lain, bahwa lebih mudah untuk mengembangkannya ke tingkat kualitas yang dibutuhkan oleh proyek ketika mereka dikembangkan. </li><li>  Penyederhanaan dukungan (Perawatan lebih mudah).  Ketika Anda perlu memodifikasi atau memperbarui bagian dari aplikasi, Anda dapat memperluas atau memperbarui komponen, daripada refactoring sebagian besar aplikasi.  Ini dapat dibandingkan dengan prosedur medis, dengan operasi pada organ yang terpisah, menggantikan operasi yang melibatkan intervensi di hampir semua bagian tubuh. </li><li>  Kemampuan menggunakan kembali kode yang lebih baik.  Karena penggunaan prinsip pemisahan tanggung jawab, komponen, selama pembuatan aplikasi selesai dari mereka, dapat digunakan kembali atau diperluas.  Ini jauh lebih baik daripada kebutuhan untuk menulis ulang mereka lagi dan lagi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inilah</a> bahan pada topik ini). </li><li>  Meningkatkan kemampuan untuk menerapkan metodologi TDD (Better TDD).  Selama pengembangan komponen modular, jauh lebih mudah daripada menggunakan pendekatan lain untuk mengimplementasikan tes unit yang bertujuan memverifikasi fungsionalitas komponen yang sempit.  Hasilnya, ternyata lebih mudah untuk menguji sistem besar yang dirakit dari komponen.  Faktanya adalah bahwa ketika menggunakan pendekatan modular, lebih mudah bagi pengembang untuk memahami apa tepatnya yang menjadi tanggung jawab satu atau beberapa bagian dari sistem. </li><li>  Kurva pembelajaran pemendek (Kurva belajar lebih pendek).  Ketika seorang pengembang harus berurusan dengan proyek baru untuknya, ternyata lebih mudah untuk memahami esensi dan struktur komponen individu daripada mempelajari seluk-beluk seluruh proyek. </li><li>  Meningkatkan kemampuan sistem pemodelan (Pemodelan sistem yang lebih baik).  Ketika sistem dibuat dari komponen modular, pengembang akan lebih mudah memahami struktur umum sistem, memahaminya, dan belajar bagaimana mempengaruhinya. </li></ul><br><h2>  <font color="#3AC1EF">Alat CDD</font> </h2><br>  Jika pengembangan didasarkan pada komponen, ini berarti bahwa programmer membutuhkan alat khusus.  Alat-alat tersebut ditujukan untuk membuat komponen, mengujinya, mengatur akses umum ke sana, dan mendukung kolaborasi dengannya. <br><br>  Secara khusus, penting untuk merancang dan menguji komponen secara terpisah.  Ini memungkinkan mereka untuk bekerja dalam bentuk unit independen yang dapat digunakan dalam aplikasi.  Selain itu, dukungan untuk penggunaan kembali komponen dan kemampuan untuk membagikannya juga penting.  Ini memungkinkan seseorang yang bekerja sebagai bagian dari tim pada proyek besar untuk tidak menemukan kembali roda, yang, dalam bentuk komponen, telah ditemukan oleh salah satu anggota tim. <br><br>  Berikut adalah beberapa alat yang berguna untuk membantu Anda mengatur pekerjaan Anda pada proyek gaya CDD.  Dalam salah satu bagian berikut, kita akan berbicara tentang arsitektur proyek yang direkomendasikan untuk implementasi praktis prinsip-prinsip CDD. <br><br><h3>  <font color="#3AC1EF">▍Bit: pengembangan komponen dan individu</font> </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bit</a> adalah alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">open source</a> , yang pada dasarnya dibuat untuk mendukung aplikasi praktis dari metodologi CDD.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> video tentang Bit.  Alat ini membantu Anda mengembangkan komponen, berkolaborasi dengannya, dan membuat proyek web menggunakannya. <br><br>  Intinya adalah bahwa dengan Bit berarti Anda dapat mengisolasi komponen yang sedang dikembangkan sebagai bagian dari proyek.  Katakan - dalam aplikasi atau perpustakaan.  Bit mendukung alat baris perintah, ini membantu mengatur enkapsulasi komponen dengan semua file dan dependensinya.  Bit memungkinkan Anda untuk mengembangkan dan menguji representasi virtual dari komponen yang dienkapsulasi secara terpisah. <br><br>  Ini berarti bahwa komponen yang dibuat dalam aplikasi dapat dilengkapi dengan semua dependensinya, dienkapsulasi dan diubah menjadi entitas yang dapat digunakan dan diuji di luar aplikasi. <br><br>  Lebih lanjut, Bit memungkinkan Anda untuk mengemas komponen yang terpisah dan dienkapsulasi dan mengatur pembagiannya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat cloud</a> .  Ini memungkinkan tim yang mengerjakan proyek untuk menggunakan semua komponen yang dibagikan.  Komunitas Bit memiliki sekitar 50.000 pengembang.  Upaya mereka menciptakan ribuan komponen sumber terbuka yang tersedia untuk semua orang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbe/ace/17b/dbeace17b5c29d298e6d4f242a669362.png"></div><br>  <i><font color="#999999">Pengembangan proyek menggunakan komponen yang dienkapsulasi</font></i> <br><br>  Berkat kemampuan platform cloud, tim pengembangan dapat menginstal komponen sumber terbuka di aplikasi mereka.  Anggota tim juga dapat menawarkan gagasan pembuat komponen untuk meningkatkan komponen dengan melakukannya langsung dari lingkungan kerja mereka.  Bit memperluas kemampuan Git untuk melacak dan menyinkronkan perubahan kode sumber komponen di seluruh proyek.  Ini memberi pengembang kemampuan untuk mengelola perubahan dan pembaruan komponen. <br><br>  Bit menyimpan pohon dependensi komponen yang lengkap.  Ini memberi pengembang kesempatan untuk belajar tentang cara memperbarui komponen yang dapat memengaruhi komponen dependen, tentang apa yang mungkin “rusak” dalam suatu proyek ketika perubahan dilakukan pada suatu komponen.  Ini berarti bahwa, terima kasih kepada Bit, pemrogram memiliki kemampuan penuh untuk mengatur pengembangan berdasarkan komponen, memungkinkan Anda untuk membuat komponen, menguji mereka dan mengatur kerja bersama pada mereka dan penggunaan bersama mereka. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b03/7f2/0e5/b037f20e579d14f3a43401e62ad1c096.jpg"></div><br>  <i><font color="#999999">Kemampuan cloud dalam CDD</font></i> <br><br>  Fitur lain yang berguna dari Bit adalah bahwa platform ini memungkinkan tim pengembangan tidak hanya untuk bekerja dengan komponen mereka menggunakan antarmuka tunggal, tetapi juga untuk menggunakan komponen lain yang diletakkan dalam domain publik dan untuk berinteraksi dengan pembuat komponen ini. <br><br>  Desainer antarmuka, perwakilan dari proyek pelanggan, serta pemrogram dapat, dalam pekerjaan bersama pada proyek, menggunakan alat visual yang umum.  Ini menjembatani kesenjangan antara desainer dan programmer.  Selain itu, perlu dicatat bahwa dalam situasi ini tidak hanya manfaat desainer dan programer, tetapi juga pengguna akhir aplikasi yang mengalami lebih sedikit heterogenitas dan kesalahan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> adalah beberapa materi tentang berbagai aspek penggunaan Bit. <br><br><h3>  <font color="#3AC1EF">▍ Pengembangan dan penelitian komponen UI: Storybook dan Styleguidist</font> </h3><br>  StoryBook dan Styleguidist adalah lingkungan untuk mengembangkan elemen antarmuka pengguna dengan cepat menggunakan React.  Kedua proyek ini adalah alat yang hebat untuk mempercepat pengembangan komponen. <br><br><h4>  Buku cerita </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StoryBook</a> adalah lingkungan untuk mengembangkan komponen UI dengan cepat.  Ini memungkinkan Anda untuk bekerja dengan perpustakaan komponen, melihat berbagai status komponen, terlibat dalam pengembangan interaktif dan pengujian komponen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cb/1f8/73b/5cb1f873b550abcfa671ab5c8bdcb99f.gif"></div><br>  <i><font color="#999999">Bekerja di StoryBook</font></i> <br><br>  StoryBook membantu merancang komponen secara terpisah dari aplikasi.  Ini membantu meningkatkan reusability komponen dan meningkatkan testability komponen. <br><br>  Menggunakan StoryBook, Anda dapat melihat komponen yang disimpan di perpustakaan, dan bereksperimen dengan propertinya secara online.  Perubahan yang dilakukan pada komponen segera, tanpa memuat ulang halaman, divisualisasikan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut</a> adalah beberapa contoh komponen yang dibuat di StoryBook. <br><br>  Ada berbagai plugin yang dapat mempercepat pengembangan komponen menggunakan StoryBook.  Ini memungkinkan Anda untuk mengurangi waktu yang berlalu antara mengubah kode komponen dan pembentukan representasi visualnya.  Perlu dicatat bahwa StoryBook, selain Bereaksi, juga mendukung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bereaksi Asli</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vue.js.</a> <br><br><h4>  Bereaksi styleguidist </h4><br>  Bereaksi Styleguidist adalah lingkungan pengembangan komponen.  Lingkungan ini berisi server pengembangan yang mendukung boot panas.  Ini juga memiliki sistem manajemen gaya interaktif yang menampilkan <code>propTypes</code> komponen dan menyediakan pengembang dengan contoh yang dapat diedit dari penggunaan komponen berdasarkan file .md. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/292/d37/f4b/292d37f4b167b41182f201313fb66a1b.gif"></div><br>  <i><font color="#999999">Bereaksi styleguidist</font></i> <br><br>  Platform ini mendukung JavaScript ES6, Flow, dan TypeScript.  Dia dapat, tanpa pengaturan tambahan, untuk bekerja dengan Aplikasi Buat Bereaksi.  Styleguidist memiliki kemampuan untuk secara otomatis membuat dokumentasi komponen.  Ini memungkinkan sistem ini untuk memainkan peran portal dokumentasi visual untuk komponen yang sedang dikerjakan oleh beberapa tim. <br><br>  Jika Anda tertarik pada proyek seperti StoryBook dan Styleguidist, maka Anda mungkin ingin melihat proyek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">React Live</a> , yang sedang dikembangkan oleh Formidable. <br><br><h4>  Perbedaan antara Storybook dan Styleguidist </h4><br>  Saat bekerja dengan StoryBook, seorang programmer menulis "cerita" dalam file JavaScript.  Ketika bekerja dengan Stuleguidist, ia menulis "contoh" dalam file Markdown.  Sementara Storybook hanya menampilkan satu variasi komponen pada satu waktu, Styleguidist dapat menampilkan beberapa variasi komponen yang berbeda.  StoryBook bagus untuk menganalisis berbagai status komponen, dan Styleguidist hebat untuk menghasilkan dokumentasi komponen dan menunjukkan kemampuan komponen. <br><br><h2>  <font color="#3AC1EF">Keputusan Arsitektur Digunakan Menggunakan Metodologi CDD</font> </h2><br>  Bekerja dengan gaya CDD berarti bahwa ketika mengembangkan aplikasi, komponen dibuat terlebih dahulu.  Selain itu, komponen tersebut harus independen satu sama lain.  Ini berarti bahwa pengembang tidak hanya membuat "set komponen".  Dia juga mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem desain yang</a> disebut komponen antarmuka pengguna. <br><br>  Komponen dapat dibuat baik dalam kerangka aplikasi itu sendiri (yaitu, dalam proyek yang sama, repositori), dan dalam format proyek yang terpisah (repositori) - dalam bentuk perpustakaan komponen. <br><br>  Alat seperti Bit memungkinkan Anda untuk mengisolasi dan merangkum komponen.  Ini memberi pengembang banyak peluang untuk membuat, menguji, menggunakan kembali komponen, dan memungkinkan mereka untuk diselesaikan di mana saja - di mana pun komponen itu dibuat. <br><br>  Jika kita mengatakan bahwa penggunaan CDD menyediakan untuk pengembangan komponen dalam bentuk langkah pertama bekerja pada suatu proyek, maka ini juga menyiratkan bahwa komponen cenderung membuatnya cocok untuk penggunaan berulang.  Ini memungkinkan Anda untuk menerapkannya saat membuat berbagai aplikasi.  Oleh karena itu, pengembang perlu mencari tahu persis apa yang harus ia lakukan untuk membuat komponen tersebut.  Tidak ada yang lebih buruk daripada menghabiskan enam bulan untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan</a> , yang pada akhirnya tidak akan digunakan oleh siapa pun.  Sayangnya, ini terjadi dengan banyak tim. <br><br><h2>  <font color="#3AC1EF">Mengapa membuat perpustakaan komponen?</font> </h2><br>  Saya akan jujur ​​dengan Anda: Repositori Git tidak disusun dengan mempertimbangkan kemungkinan menyimpan kode komponen atom di dalamnya, yang direncanakan akan dibagikan dalam berbagai proyek.  Untuk mengatasi masalah ini, manajer paket tidak cocok.  Keduanya diciptakan, yang dapat dimengerti, untuk mendukung repositori kode.  Komponen bukan repositori. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe8/2ae/3a0/fe82ae3a08029576a3d921319ed2fc0f.jpg"></div><br>  <i><font color="#999999">Berbagi komponen dalam berbagai proyek</font></i> <br><br>  Itu sebabnya, jika Anda perlu mengambil komponen dari satu aplikasi dan menggunakannya di aplikasi lain, Anda perlu membuat repositori baru.  Untuk menyelamatkan diri dari pekerjaan yang tidak perlu dalam membuat repositori terpisah untuk setiap komponen tersebut, sebagian besar tim membuat satu repositori bersama yang dirancang untuk menyimpan 20-30 komponen. <br><br>  Saat menggunakan alat seperti Bit, pustaka komponen seperti itu tidak perlu.  Alat tersebut memungkinkan Anda untuk mengunduh komponen dari aplikasi ke cloud dan mengimplementasikan komponen ini di proyek lain.  Jika kita membandingkan skema kerja ini dengan repositori tradisional, maka kita dapat mengatakan bahwa ini adalah sesuatu seperti membandingkan CD musik dan Spotify.  Benar, jika Anda dekat dengan ide mengembangkan dan menggunakan pustaka komponen, kemampuan platform seperti Bit dan StoryBook akan memungkinkan Anda untuk bekerja dengan pustaka. <br><br>  Saat mendesain perpustakaan, Anda perlu membuat beberapa keputusan penting.  Di bawah ini akan dipertimbangkan beberapa prinsip penting yang akan membantu Anda dalam hal ini.  Poin utama dari prinsip-prinsip ini adalah bahwa tugas Anda adalah membuat komponen independen.  Tahap-tahap pekerjaan yang tersisa pada proyek menyerupai perakitan konstruktor Lego.  Jika prinsip pengembangan komponen independen tidak dihormati, maka suatu hari Anda mungkin akan mengalami masalah.  Masalah akan dimulai ketika seseorang membutuhkan sesuatu yang berbeda dari apa yang ada di perpustakaan.  Faktanya, ketika ini terjadi, tim berhenti menggunakan pustaka komponen. <br><br>  Misalkan Anda memutuskan untuk membuat perpustakaan komponen.  Jika demikian - kami menawarkan beberapa kiat yang akan membantu Anda dalam hal ini. <br><br><h2>  <font color="#3AC1EF">7 prinsip untuk mengembangkan perpustakaan berorientasi CDD berkualitas</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b74/5fb/1ef/b745fb1ef37cd116a46bafd7c68e99ea.jpg"></div><br><ol><li>  Standar  Standar pengembangan apa yang Anda patuhi saat membuat perpustakaan Anda?  Di mana komponen berada?  Di mana tes itu berada?  Bagaimana dengan gaya?  Apa tumpukan teknologi yang Anda gunakan?  Misalnya - apakah Anda berencana menggunakan TypeScript?  Bagaimana komponen dibagi?  Apakah komponen "Tabel", misalnya, terdiri dari "Baris" dan "Sel"?  Apakah panel dengan tab terdiri dari tab terpisah (dapatkah pertanyaan yang sama diajukan terkait dengan entitas serupa lainnya)?  Saya kira Anda sudah mengerti arti dari rekomendasi ini.  Juga sangat penting untuk menyertakan desainer dalam proses pembentukan standar.  Ini akan memastikan bahwa perpustakaan cukup fleksibel dan akan memenuhi persyaratan desain yang mungkin muncul di masa depan. </li><li>  Stilisasi.  Bagaimana Anda berencana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menata</a> komponen?  Apakah Anda akan menautkan kode CSS yang sesuai ke setiap komponen?  Jika demikian, apa yang terjadi ketika seorang desainer perlu mengubah sesuatu hanya untuk aplikasi terpisah yang menggunakan komponen?  Mungkin untuk meningkatkan pemisahan komponen dari gaya perlu menggunakan perpustakaan yang mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CSS dalam</a> teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JS</a> ?  Mungkin ada baiknya mencari beberapa pendekatan lain untuk styling?  Misalnya, menggunakan Bit, Anda dapat menyorot topik sebagai komponen terpisah.  Topik semacam itu dapat diterapkan pada komponen yang menerapkan semacam logika.  Ini memungkinkan Anda untuk membuat aplikasi di mana desain dan logika digabungkan persis seperti yang dibutuhkan pengembang.  Berikut adalah contoh fleksibilitas ekstrim dari sistem yang dibangun menggunakan prinsip modularitas. </li><li>  Pengujian.  Bagaimana Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menguji</a> komponen yang termasuk dalam perpustakaan?  Menggunakan Jest dan Enzim?  Pemilihan kombinasi yang baik dari alat pengujian komponen harus didekati dengan semua tanggung jawab.  Ini akan memungkinkan alat tersebut untuk membantu Anda menerapkan metodologi CDD.  Pilihan alat yang buruk akan mengganggu pekerjaan.  Tes unit bagus.  Tetapi mereka harus memeriksa API fungsional komponen, bukan rincian implementasinya.  Tes integrasi dan end-to-end sama pentingnya dengan tes unit.  Metodologi TDD bekerja dengan baik ketika diterapkan dalam proyek menggunakan CDD. </li><li>  Proses perakitan kode.  Kode perlu dikompilasi.  Bagaimana Anda akan mengatur proses pembuatan kode untuk perpustakaan Anda?  Bagaimana rilis akan diimplementasikan?  Apakah Anda berencana untuk hanya menyalin kode dari aplikasi dan menempelkannya ke perpustakaan (mungkin sedikit memodifikasinya)?  Apakah Anda akan menentukan konfigurasi perakitan untuk setiap komponen (Lerna) dan menerapkan mekanisme yang sesuai dengan kode sebelum menerbitkannya?  Apakah Anda berencana untuk menggunakan, katakanlah, Bit yang telah disebutkan lebih dari satu kali untuk menyesuaikan proses pembuatan yang berlaku untuk semua komponen (atau individu)?  Jika Anda terlalu menyulitkan proses perakitan, akan menjadi lebih sulit untuk terlibat dalam pengembangan, modularitas proyek akan memburuk.  Kurva pembelajaran yang dibutuhkan untuk berpartisipasi dalam pengembangan akan menjadi terlalu curam. </li><li>  Manajemen kode.  Siapa yang memiliki perpustakaan?  Dalam organisasi yang cukup besar, sering ada tim pengembang front-end dan, kadang-kadang, arsitek.  Mereka menciptakan produk yang disebut "perpustakaan bersama."  Tim pengembangan front-end lainnya membuat aplikasi menggunakan perpustakaan serupa.  Dengan skema interaksi ini, sangat penting untuk menggunakan sistem yang memungkinkan Anda untuk dengan mudah menemukan komponen yang diperlukan (Bit, Storybook).  Yang lebih penting, mungkin, adalah mekanisme di mana pengguna komponen dapat mengusulkan peningkatan komponen.  Jika tidak ada mekanisme seperti itu dalam organisasi, maka tim pengguna komponen tidak akan ingin mengaitkan aplikasi mereka dengan perpustakaan dan menunggu PR mereka diterima, yang mungkin tidak mereka tunggu.  Tidak perlu memaksa programmer untuk melakukan apa pun.  Penting untuk menjalin kerjasama yang sehat.  Jika Anda tidak berusaha untuk ini, tidak ada yang akan menggunakan perpustakaan.  Pemrogram hanya akan menyalin dan menempelkan kode, dan tidak ada yang akan melakukan apa pun tentang itu.  Selain itu, ini akan menjadi kesalahan Anda.  Jika Anda bekerja dalam tim kecil, tentukan dengan jelas siapa yang mengelola kode.  Bahkan jika tidak ada yang terlibat dalam basis kode sepanjang waktu, pilih beberapa spesialis yang akan mendukung kode ini.  Sisanya akan melakukan PR - sama seperti di GitHub. </li><li>  Mencari komponen.  Perpustakaan tidak akan membawa banyak manfaat jika pemrogram tidak dapat menemukan komponen yang mereka butuhkan, tidak dapat mempelajari cara kerja komponen ini, dan tidak dapat menggunakannya dalam kode mereka.  Bit memiliki kemampuan bawaan yang membantu pengembang menemukan komponen.  Selain platform ini (atau bukan platform), Anda dapat menggunakan kemampuan StoryBook atau semacam solusi sendiri.  Platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Codesandbox</a> dapat memberikan beberapa manfaat dalam menyelesaikan masalah yang terkait dengan pemilihan komponen dan bekerja dengan dokumentasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuknya</a> . </li><li>  Organisasi kolaborasi pada komponen.  Apa yang terjadi ketika pengembang (mungkin dari tim lain, atau bahkan dari negara lain) perlu mengubah sesuatu yang terkait dengan komponen dari perpustakaan Anda?  Apakah dia perlu lebih dalam membuat PR untuk perpustakaan Anda, dan, semoga saja, tunggu hasilnya.  Bagi banyak pengembang, ini terlalu rumit, mereka tidak akan melakukan ini bahkan jika Anda mencoba mempengaruhi mereka.  Akan jauh lebih baik jika Anda menggunakan platform tertentu yang menyederhanakan kolaborasi pada proyek. </li></ol><br>  Ingatlah bahwa perpustakaan hanyalah repositori yang ada untuk memfasilitasi pembagian komponen dalam berbagai proyek.  Perpustakaan tidak skala dengan sangat baik, kode di dalamnya menjadi usang, mereka menderita berbagai masalah.  Mungkin lebih baik menyediakan akses langsung ke komponen yang dimaksudkan untuk berbagi, menggunakan semacam platform cloud. <br><br><h2>  <font color="#3AC1EF">Manfaat Tim CDD</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/854/acd/d57/854acdd574bd458dd4f4987b595ff737.png"></div><br>  Tim yang menggunakan prinsip CDD mendapat manfaat dari pengembangan yang dipercepat, peningkatan penggunaan kembali kode, peningkatan TDD dan antarmuka sistem desain yang konsisten. <br><br>  Pemrogram dapat menulis kode dengan akses ke komponen yang sudah ditulis dan bekerja bersama untuk membuat perubahan pada komponen.  Pengembangan fitur atau aplikasi baru bermuara pada penyesuaian dan perluasan komponen dasar.  Ini, sebagai tambahan, membantu mencegah kesalahan yang hanya ditemukan dalam produksi. <br><br>  Berbagi kode berarti, antara lain, mengurangi jumlah kode yang perlu didukung.  Ini memungkinkan programmer untuk fokus pada menciptakan sesuatu yang baru.  Ketika aplikasi dikembangkan berdasarkan komponen, ini menstandarkan pekerjaan karena fakta bahwa setiap orang menggunakan basis tunggal blok bangunan aplikasi.  Pendekatan komponen juga berkontribusi pada fleksibilitas kerja. <br><br>  Beberapa tim melaporkan bahwa alur kerja mereka menjadi lebih cepat hingga 60% berkat penggunaan komponen modular berdasarkan sistem desain yang diimplementasikan sebagai rangkaian komponen Bereaksi.  Beberapa organisasi telah menemukan bahwa melalui pengenalan CDD, mereka dapat menghapus sekitar 30% dari kode dari basis kode mereka. <br><br>  Perusahaan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Uber, Airbnb, Shopify,</a> dan lainnya memperkenalkan pendekatan komponen. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Secara pribadi, saya tidak terkejut bahwa penggunaan CDD meningkatkan efisiensi pengembangan perangkat lunak.  Menurut Brad Frost, penulis buku tentang desain atom, modularitas dan komposisi adalah konsep paling penting dalam biologi, ekonomi, dan di banyak bidang lainnya.  Modularitas dalam aplikasi untuk pengembangan perangkat lunak memberikan kecepatan, keandalan, kemudahan pengembangan.  Ini mempromosikan penggunaan kembali entitas, meningkatkan testability dan ekstensibilitas kode.  Modularitas memberi pengembang kemampuan untuk menggunakan komposisi saat membuat sistem yang kompleks.  Semua ini sangat memengaruhi proses dan hasil pengembangan aplikasi. <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan metodologi CDD saat mengerjakan proyek Anda? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461661/">https://habr.com/ru/post/id461661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461651/index.html">Frontend Weekly Digest (22 - 28 Juli 2019)</a></li>
<li><a href="../id461653/index.html">Software Defined Radio - bagaimana cara kerjanya? Bagian 10</a></li>
<li><a href="../id461655/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 373 (22 - 28 Juli 2019)</a></li>
<li><a href="../id461657/index.html">Membeli Topi Merah: Akan Membantu Pertempuran Raksasa Biru Untuk Kepemimpinan Awan Hibrida</a></li>
<li><a href="../id461659/index.html">Neural Networks dan Deep Learning, Bab 4: Bukti Visual bahwa Neural Networks Dapat Menghitung Semua Fungsi</a></li>
<li><a href="../id461663/index.html">Kisah bagaimana Linux membawa Windows</a></li>
<li><a href="../id461665/index.html">Zen2. Evolusi platform AM4 pada contoh Ryzen 7 3700x</a></li>
<li><a href="../id461669/index.html">PHP Digest No. 161 (15 - 29 Juli 2019)</a></li>
<li><a href="../id461673/index.html">8 tips untuk programmer pemula atau retrospeksi karir saya</a></li>
<li><a href="../id461677/index.html">Perpustakaan Hampir Sempurna oleh Seni Elektronik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>