<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§õüèª üèÖ üëè Ein Spiel f√ºr Game Boy erstellen üí´ üÉè üëçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor ein paar Wochen habe ich beschlossen, an einem Spiel f√ºr Game Boy zu arbeiten, dessen Erstellung mir gro√üe Freude bereitete. Sein Arbeitsname ist ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ein Spiel f√ºr Game Boy erstellen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436330/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/913/597/052/91359705210df58524bc0e6c9e9955a8.png" alt="Bild"></div><br>  Vor ein paar Wochen habe ich beschlossen, an einem Spiel f√ºr Game Boy zu arbeiten, dessen Erstellung mir gro√üe Freude bereitete.  Sein Arbeitsname ist Aqua and Ashes.  Das Spiel hat Open Source und ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub ver√∂ffentlicht</a> . <br><br><h2>  Wie kam ich auf diese Idee? </h2><br>  Ich habe k√ºrzlich einen Praktikumsjob bekommen und ein Backend in PHP und Python f√ºr die Website meiner Universit√§t erstellt.  Dies ist eine gute und interessante Arbeit, f√ºr die ich sehr dankbar bin.  Aber ... gleichzeitig hat mich all dieser hochrangige Webentwicklungscode mit einem uners√§ttlichen Wunsch infiziert.  Und es war der Wunsch nach Arbeit auf niedriger Ebene mit Bits. <br><br>  Ich erhielt eine w√∂chentliche itch.io-√úbersicht √ºber Game Jams in der Mail, die den Beginn von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mini Jam 4</a> ank√ºndigte.  Es war ein 48-Stunden-Jam (eigentlich ein bisschen gr√∂√üer), bei dem die Einschr√§nkung darin bestand, Grafiken im Stil von Game Boy zu erstellen.  Meine erste logische Reaktion war, ein Homebrew-Spiel f√ºr Game Boy zu erstellen.  Das Thema der Marmelade war "Jahreszeiten" und "Flamme". <br><br>  Nachdem ich ein wenig √ºber die Handlung und die Mechanik nachgedacht hatte, die in 48 Stunden implementiert werden k√∂nnen und in die Grenzen des Themas passen, kam ich zu einem <s>Klon einer</s> neuen Interpretation des Levels aus dem SNES-Spiel Tiny Toon Adventures: Buster Busts Loose! Von 1993, in dem der Spieler in der Rolle des Baster American Football spielt . <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XmyJZkJ-zeA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Mir hat es immer gefallen, wie die Macher dieses Levels einen unglaublich komplexen Sport betrieben, alle Tricks, Positionen und strategischen Elemente beseitigt haben, als Ergebnis eines √§u√üerst interessanten und einfachen Spiels.  Offensichtlich wird eine derart vereinfachte Sichtweise des amerikanischen Fu√üballs Madden nicht ersetzen, ebenso wie NBA Jam (eine √§hnliche Idee: nur 4 Spieler auf einem viel kleineren Feld mit einem einfacheren Gameplay als in einem regul√§ren Spiel) die 2K-Serie nicht ersetzen wird.  Diese Idee hat jedoch einen gewissen Reiz, und die Verkaufszahlen von NBA Jam best√§tigen dies. <br><br>  Wie h√§ngt das alles mit meiner Idee zusammen?  Ich habe beschlossen, dieses Fu√üballlevel zu nehmen und es neu zu gestalten, damit es dem Original √§hnlich bleibt und gleichzeitig frisch ist.  Erstens habe ich das Spiel auf nur vier Spieler reduziert - einen Verteidiger und einen Angreifer.  Dies geschah haupts√§chlich aufgrund der Einschr√§nkungen der Hardware, aber gleichzeitig kann ich ein bisschen mit einer intelligenteren KI experimentieren, ohne auf das Prinzip "links laufen und manchmal springen" beim Spielen auf SNES zu beschr√§nken. <br><br>  Aus Gr√ºnden der √úbereinstimmung mit dem Thema werde ich die Tore durch brennende S√§ulen oder Lagerfeuer oder √§hnliches ersetzen (ich habe mich noch nicht entschieden) und einen Fu√üball mit Fackeln und Wassereimern.  Der Gewinner wird das Team sein, das beide Lagerfeuer kontrolliert, und um dieses einfache Konzept herum k√∂nnen Sie leicht eine Handlung erstellen.  Die Jahreszeiten werden ebenfalls ber√ºcksichtigt: Ich habe beschlossen, dass sich die Jahreszeiten in jeder Runde √§ndern, damit das Feuerteam im Sommer und das Feuerteam im Winter einen Vorteil erhalten.  Dieser Vorteil sieht aus wie Hindernisse auf dem Spielfeld, die nur die gegnerische Mannschaft st√∂ren. <br><br>  Nat√ºrlich wurden bei der Bildung von zwei Teams zwei Tiere ben√∂tigt, die Feuer lieben und nicht m√∂gen.  Zuerst dachte ich an Feuerameisen und einige Wasserwanzen, Gottesanbeterinnen und dergleichen, aber nachdem ich das Problem untersucht hatte, fand ich im Winter keine aktiven Insekten und ersetzte sie durch Polarf√ºchse und Geckos.  Polarf√ºchse m√∂gen Schnee, Geckos liegen gern in der Sonne, also scheint alles logisch.  Am Ende ist es nur ein Spiel f√ºr Game Boy. <br><br>  Falls dies immer noch nicht klar ist, war das Spiel am Ende des Staus noch nicht zu Ende.  Jedenfalls hat es Spa√ü gemacht. <br><br><h2>  Game Boy Training </h2><br>  Zuerst m√ºssen Sie die Anforderungen bestimmen.  Ich habe mich entschieden, f√ºr DMG zu schreiben (interner Name f√ºr Game Boy-Modell, kurz f√ºr Dot Matrix Game).  Haupts√§chlich um die Anforderungen eines Game Jam zu erf√ºllen, aber auch weil ich es wirklich wollte.  Pers√∂nlich hatte ich noch nie Spiele f√ºr DMG (obwohl es mehrere Spiele f√ºr Game Boy Color gibt), aber ich finde, dass die 2-Bit-√Ñsthetik eine sehr sch√∂ne und interessante Einschr√§nkung f√ºr Experimente ist.  Vielleicht werde ich zus√§tzliche Farben f√ºr SGB und CGB hinzuf√ºgen, aber bisher habe ich nicht dar√ºber nachgedacht. <br><br>  Ich habe mich auch f√ºr eine Kassette mit 32K ROM + ohne RAM entschieden, nur f√ºr den Fall, dass ich eine physische Kopie des Spiels erstellen m√∂chte.  CatSkull, das mehrere Game Boy-Spiele wie Sheep it Up! Ver√∂ffentlicht hat, bietet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sehr g√ºnstige 32-Kilobyte-Blitzpatronen an</a> , die perfekt f√ºr mich sind.  Dies ist eine weitere zus√§tzliche Einschr√§nkung, aber ich glaube nicht, dass ich in naher Zukunft das 32K-Volumen mit einem so einfachen Spiel √ºberwinden kann.  Das Schwierigste wird mit der Grafik sein, und wenn alles v√∂llig schlecht ist, werde ich versuchen, es zu komprimieren. <br><br>  Was die Arbeit von Game Boy betrifft, so ist alles ziemlich kompliziert.  Um ehrlich zu sein, war Game Boy von allen Retro-Konsolen, mit denen ich arbeiten musste, die angenehmste.  Ich habe mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hervorragenden Tutorial</a> (zumindest zum ersten Mal, weil es nie abgeschlossen wurde) des Autors von AssemblyDigest begonnen.  Ich wusste, dass es am besten ist, in ASM zu schreiben, wie schmerzhaft es manchmal auch sein mag, da die Hardware nicht f√ºr C ausgelegt ist, und ich war mir nicht sicher, ob der im Tutorial erw√§hnte coole Sprach-Wiz langfristig geeignet ist.  Au√üerdem mache ich das haupts√§chlich, weil <em>ich</em> mit ASM arbeiten kann. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberpr√ºfen Sie das Commit 8c0a4ea</a> <br><br>  Das erste, was zu tun war, war, den Game Boy zum Booten zu bringen.  Wenn das Nintendo-Logo bei einem Versatz von <code>$104</code> nicht gefunden wird und der Rest des Headers nicht richtig konfiguriert ist, geht das Game Boy-Ger√§t davon aus, dass die Kassette falsch eingesetzt ist, und lehnt das Laden ab.  Die L√∂sung dieses Problems ist sehr einfach, da bereits viele Tutorials dar√ºber geschrieben wurden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So habe ich das √úberschriftenproblem gel√∂st.</a>  Es gibt nichts, was besondere Aufmerksamkeit verdient. <br><br>  Es wird schwieriger sein, nach dem Laden sinnvolle Aktionen auszuf√ºhren.  Es ist sehr einfach, das System in einen unendlichen Besch√§ftigungszyklus zu versetzen, in dem immer wieder eine Codezeile ausgef√ºhrt wird.  Die Codeausf√ºhrung beginnt mit dem Label <code>main</code> (wo der Sprung zur Adresse <code>$100</code> anzeigt), daher m√ºssen Sie dort einfachen Code einf√ºgen.  Zum Beispiel: <br><br><pre> <code class="hljs pgsql">main: .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: halt jr .<span class="hljs-keyword"><span class="hljs-keyword">loop</span></span></code> </pre> <br>  und es tut absolut nichts anderes, als auf den Start des Interrupts zu warten, wonach es zum <code>.loop</code> Label zur√ºckkehrt.  (Im Folgenden werde ich die detaillierte Beschreibung von ASM weglassen. Wenn Sie verwirrt sind, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen Sie die von mir verwendete Assembler-Dokumentation</a> .) Sie sind vielleicht neugierig, warum ich einfach nicht zum Hauptetikett zur√ºckkehre.  Dies geschieht, weil ich m√∂chte, dass alles vor dem <code>.loop</code> Label die Initialisierung des Programms ist und alles, nachdem es in jedem Frame passiert.  Somit muss ich den Zyklus des Ladens von Daten von der Kassette nicht umgehen und den Speicher in jedem Frame l√∂schen. <br><br>  Machen wir noch einen Schritt.  Das von mir verwendete RGBDS-Assembler-Paket enth√§lt einen Bildkonverter.  Da ich zu diesem Zeitpunkt noch keine Ressourcen f√ºr das Spiel gezeichnet habe, habe ich beschlossen, die monochrome Schaltfl√§che auf meiner Info-Seite als Test-Bitmap zu verwenden.  Mit RGBGFX habe ich es in das Game Boy-Format konvertiert und mit dem Assembler-Befehl .incbin nach der <code>main</code> eingef√ºgt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26e/1d4/8b2/26e1d48b29e761edb6df6c6a3a3d035b.png" alt="Bild"></div><br>  Um es auf dem Bildschirm anzuzeigen, ben√∂tige ich Folgendes: <br><br><ol><li>  LCD aus </li><li>  Palette einstellen </li><li>  Bildlaufposition einstellen </li><li>  Videospeicher l√∂schen (VRAM) </li><li>  Laden Sie Kachelgrafiken in VRAM </li><li>  Laden Sie die VRAM-Kachel-Hintergrundkarte herunter </li><li>  Schalten Sie das LCD wieder ein </li></ol><br><h3>  LCD aus </h3><br>  F√ºr Anf√§nger wird dies zum schwerwiegendsten Hindernis.  Beim ersten Game Boy ist es unm√∂glich, jederzeit einfach Daten in VRAM zu schreiben.  Es muss auf den Moment gewartet werden, in dem das System nichts zeichnet.  Bei der Nachahmung des Phosphorgl√ºhens in alten CRT-Fernsehern wird das Intervall zwischen den einzelnen Bildern bei ge√∂ffnetem VRAM als Vertical-Blank oder VBlank bezeichnet (bei CRT ist dies ein Impuls zum L√∂schen des Kinescope-Strahls w√§hrend eines R√ºckw√§rtsscans).  (Es gibt auch HBlank zwischen jeder Zeile des Displays, aber es ist sehr kurz.) Wir k√∂nnen dieses Problem jedoch umgehen, indem wir den LCD-Bildschirm ausschalten, dh wir <em>k√∂nnen</em> im VRAM aufzeichnen, unabh√§ngig davon, wo sich die ‚ÄûPhosphorspur‚Äú des CRT-Bildschirms befindet. <br><br>  Wenn Sie verwirrt sind, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sollte Ihnen diese Bewertung viel erkl√§ren</a> .  Darin wird die Frage aus der Sicht von SNES betrachtet. Vergessen Sie also nicht, dass es keinen Elektronenstrahl gibt und die Zahlen unterschiedlich sind, aber in allem anderen ist sie durchaus anwendbar.  Im Wesentlichen m√ºssen wir das FBlank-Flag setzen. <br><br>  Der Trick des Game Boy besteht jedoch darin, dass Sie das LCD nur w√§hrend VBlank ausschalten k√∂nnen.  Das hei√üt, wir m√ºssen auf VBlank warten.  Verwenden Sie dazu Interrupts.  Interrupts sind Signale, dass der Game Boy Hardware an die CPU sendet.  Wenn der Interrupt-Handler gesetzt ist, stoppt der Prozessor seine Arbeit und ruft den Handler auf.  Game Boy unterst√ºtzt f√ºnf Interrupts, von denen einer beim Start von VBlank startet. <br><br>  Interrupts k√∂nnen auf zwei verschiedene Arten behandelt werden.  Die erste und h√§ufigste ist die Aufgabe <em>eines Interrupt-Handlers</em> , der wie oben erl√§utert funktioniert.  Wir k√∂nnen jedoch einen bestimmten Interrupt aktivieren und alle Handler deaktivieren, indem wir das Aktivierungsflag f√ºr diesen Interrupt setzen und den <code>di</code> Opcode verwenden.  Es tut normalerweise nichts, hat aber den Nebeneffekt, dass der HALT-Opcode beendet wird, wodurch die CPU gestoppt wird, bevor ein Interrupt auftritt.  (Dies geschieht auch, wenn die Handler eingeschaltet sind, wodurch wir den HALT-Zyklus <code>main</code> .) Wenn Sie interessiert sind, erstellen wir im Laufe der Zeit auch einen VBlank-Handler, der jedoch h√§ufig von bestimmten Werten an bestimmten Adressen abh√§ngt.  Da bisher nichts im RAM eingestellt wurde, kann ein Versuch, den VBlank-Handler aufzurufen, zu einem Systemabsturz f√ºhren. <br><br>  Um die Werte festzulegen, m√ºssen wir Befehle an die Game Boy-Hardwareregister senden.  Es gibt spezielle Speicheradressen, die in direktem Zusammenhang mit verschiedenen Teilen des Ger√§ts stehen, in unserem Fall der CPU, mit denen Sie die Funktionsweise √§ndern k√∂nnen.  Wir sind besonders an den Adressen <code>$FFFF</code> (Interrupt-Aktivierungsbitfeld), <code>$FF0F</code> (aktiviertes, aber nicht behandeltes Interrupt-Bitfeld) und <code>$FF40</code> (LCD-Steuerung) <code>$FF40</code> .  Eine Liste dieser Register finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf den Seiten,</a> die dem Abschnitt "Dokumentation" der Liste "Awesome Game Boy Development" zugeordnet sind. <br><br>  Um das LCD auszuschalten, schalten wir nur den VBlank-Interrupt ein, weisen <code>$FFFF</code> Wert <code>$01</code> , f√ºhren HALT aus, bis die Bedingung <code>$FF0F == $01</code> erf√ºllt ist, und weisen dann Bit 7 der Adresse <code>$FF40</code> zu. <br><br><h3>  Einstellen der Palette und der Bildlaufposition </h3><br>  Das ist einfach zu machen.  Nachdem das LCD ausgeschaltet ist, m√ºssen wir uns keine Sorgen mehr um VBlank machen.  Um die Bildlaufposition einzustellen, reicht es aus, die X- und Y-Register auf 0 zu setzen. Mit der Palette ist alles etwas schwieriger.  In Game Boy k√∂nnen Sie Schattierungen von der ersten bis zur vierten Grafik einer der 4 Graustufen (oder Sumpfgr√ºn, wenn Sie m√∂chten) zuweisen, was f√ºr √úberg√§nge und dergleichen n√ºtzlich ist.  Ich habe einen einfachen Verlauf als Palette festgelegt, der als Liste der Bits <code>%11100100</code> . <br><br><h3>  VRAM l√∂schen und Kachelgrafiken laden </h3><br>  Beim Start bestehen alle Grafikdaten und die Hintergrundkarte nur aus einem scrollenden Nintendo-Logo, das beim Systemstart angezeigt wird.  Wenn ich Sprites einschalte (sie sind standardm√§√üig deaktiviert), werden sie √ºber den Bildschirm verteilt.  Sie m√ºssen den Videospeicher l√∂schen, um von vorne zu beginnen. <br><br>  Dazu ben√∂tige ich eine Funktion wie <code>memset</code> von C. (Ich ben√∂tige auch ein analoges <code>memcpy</code> um die Grafikdaten zu kopieren.) Die <code>memset</code> Funktion setzt das angegebene Speicherfragment auf ein bestimmtes Byte.  Es wird mir leicht fallen, dies selbst zu implementieren, aber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AssemblyDigest-Tutorial</a> verf√ºgt bereits √ºber diese Funktionen, sodass ich sie verwende. <br><br>  Zu diesem Zeitpunkt kann ich VRAM mit <code>memset</code> indem ich <code>$00</code> schreibe (obwohl beim ersten Commit der ebenfalls geeignete Wert <code>$FF</code> wurde) und dann die Kachelgrafiken mit <code>memcpy</code> in VRAM laden.  Insbesondere muss ich es an die Adresse <code>$9000</code> kopieren, da dies Kacheln sind, die nur f√ºr Hintergrundgrafiken verwendet werden.  (Die Adressen <code>$8000-$87FF</code> werden nur f√ºr Sprite-Kacheln verwendet, und die Adressen <code>$8800-$8FFF</code> sind f√ºr beide Typen gleich.) <br><br><h3>  Kachelkarteneinstellung </h3><br>  Game Boy hat eine Hintergrundebene, die in 8x8-Kacheln unterteilt ist.  Die Hintergrundebene selbst ben√∂tigt ungef√§hr 32 x 32 Kacheln, dh sie hat eine Gesamtgr√∂√üe von 256 x 256.  (Zum Vergleich: Der Konsolenbildschirm hat eine Aufl√∂sung von 160 x 144.) Ich musste die Kacheln, aus denen mein Bild besteht, Zeile f√ºr Zeile manuell angeben.  Gl√ºcklicherweise wurden alle Kacheln in der richtigen Reihenfolge angeordnet, sodass ich nur jede Zeile mit Werten von <code>N*11</code> bis <code>N*11 + 10</code> f√ºllen musste, wobei <code>N</code> die Zeilennummer ist und die verbleibenden 22 Kachelelemente <code>$FF</code> ausf√ºllen. <br><br><h3>  LCD einschalten </h3><br>  Hier m√ºssen wir nicht auf VBlank warten, da sich der Bildschirm erst nach VBlank einschaltet, also habe ich einfach wieder in das LCD-Steuerregister geschrieben.  Ich habe auch Hintergrund- und Sprite-Ebenen eingef√ºgt und die korrekten Adressen der Kachelkarte und der Kachelgrafiken angegeben.  Danach habe ich folgende Ergebnisse erhalten.  Ich habe auch die Interrupt-Handler mit dem <code>ei</code> Opcode wieder eingeschaltet. <br><br>  Um es noch interessanter zu machen, habe ich an dieser Stelle einen sehr einfachen Interrupt-Handler f√ºr VBlank geschrieben.  Durch Hinzuf√ºgen des √úbergangs-Opcodes <code>$40</code> kann ich dem Handler jede Funktion geben, die ich ben√∂tige.  In diesem Fall habe ich eine einfache Funktion geschrieben, die den Bildschirm nach oben und unten scrollt. <br><br>  Hier sind die fertigen Ergebnisse.  [Erg√§nzung: Ich habe gerade festgestellt, dass das GIF nicht korrekt geloopt ist, sondern das Bild st√§ndig √ºbertragen muss.] <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd0/c84/9db/fd0c849dbe3bc68910d186b1ef014c66.gif"></div><br>  Bisher nichts besonders √ºberraschendes, aber es ist trotzdem cool, dass ich theoretisch meinen alten Game Boy Color bekommen und sehen kann, wie mein eigener Code darauf ausgef√ºhrt wird. <br><br><h2>  Spa√ü mit karierten Laken </h2><br>  Um etwas auf den Bildschirm zu zeichnen, brauche ich nat√ºrlich eine Art Sprite.  Nachdem ich die PPU (Picture Processing Unit) der Game Boy-Konsole studiert hatte, entschied ich mich, mich auf 8x8- oder 8x16-Sprites zu konzentrieren.  Wahrscheinlich brauche ich die letzte Option, aber um die Gr√∂√üe zu sp√ºren, habe ich schnell einen Screenshot des Spiels im Ma√üstab 1: 8 auf kariertes Papier gekritzelt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/b5b/ece/887b5becec39b13f2fd167e9436c63e5.jpg"></div><br>  Ich wollte den oberen Bildschirmrand unter dem HUD belassen.  Es schien mir, dass es nat√ºrlicher aussehen wird als von unten, denn wenn es oben ist, k√∂nnen die Charaktere es vor√ºbergehend tun, wenn sie das HUD vor√ºbergehend blockieren m√ºssen, wie in Super Mario Bros.  Dieses Spiel wird keine komplexe Plattform haben, und in der Tat auch das Level-Design, so dass ich keine sehr allgemeine Sicht auf das Feld zeigen muss.  Die Position der Zeichen auf dem Bildschirm und m√∂glicherweise Hindernisse, die von Zeit zu Zeit auftreten, sind v√∂llig ausreichend.  Daher kann ich mir ziemlich gro√üe Sprites leisten. <br><br>  Wenn also ein Quadrat eine 8x8-Kachel w√§re, w√ºrde ein Sprite <em>nicht</em> ausreichen, egal welche Gr√∂√üe ich w√§hle.  Dies gilt insbesondere, da es mit Ausnahme von Spr√ºngen fast keine vertikale Bewegung im Spiel gibt.  Also habe ich beschlossen, Sprites aus vier 8x16-Sprites zu erstellen.  Die Ausnahme war der Schwanz des Fuchses, der zwei 8x16 Sprites besetzt.  Nach einfachen Berechnungen wurde klar, dass zwei F√ºchse und zwei Geckos 20 der 40 Sprites besetzen werden, dh es wird m√∂glich sein, viele weitere Sprites hinzuzuf√ºgen.  (8x8-Sprites w√ºrden schnell mein Limit √ºberschreiten, was ich in den fr√ºhen Entwicklungsstadien nicht tun m√∂chte.) <br><br>  Im Moment muss ich nur Sprites zeichnen.  Unten finden Sie grobe Skizzen auf kariertem Papier.  Ich habe ein wartendes Sprite, ein "denkendes" Sprite, um zu entscheiden, ob ich bestehen oder rennen m√∂chte, wie in einem SNES-Spiel ... und das war's.  Ich hatte auch vor, Sprites aus laufenden Charakteren, springenden Charakteren und Charakteren zu machen, die Gegner greifen.  Aber f√ºr den Anfang habe ich nur wartende und denkende Sprites gezeichnet, um nicht zu komplizieren.  Den Rest habe ich immer noch nicht gemacht, ich muss das machen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/623/20c/124/62320c12434cacf0c0ca06a2aad33fae.jpg"></div><br>  Ja, ich wei√ü, ich zeichne nicht sehr gut.  Perspektive ist eine schwierige Sache.  (Ja, und dieses Gesicht des Polarfuchses ist schrecklich.) Aber es passt perfekt zu mir.  Das Charakter-Design hat keine besonderen Merkmale, ist aber f√ºr Game-Jam geeignet.  Nat√ºrlich habe ich echte Geckos und Polarf√ºchse als Referenz verwendet.  Ist es nicht wahrnehmbar? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fe/b2e/936/1feb2e936415aeceaf8cd35596d7e55d.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/215/cc8/568/215cc856884bb518df111799d6e10a87.jpg"></div><br>  Sie k√∂nnen es nicht sagen.  (F√ºrs Protokoll: Nachdem ich mir diese Bilder noch einmal angesehen habe, habe ich festgestellt, dass es einen gro√üen Unterschied zwischen Geckos und Eidechsen gibt. Ich wei√ü nicht, was ich damit anfangen soll, au√üer mich f√ºr dumm zu halten ...) Ich denke, Sie k√∂nnen sich vorstellen, dass dies die Quelle der Inspiration ist Blaze the Cat aus der Sonic-Spieleserie diente als Kopf des Fuchses. <br><br>  Anfangs wollte ich, dass die Verteidiger und St√ºrmer in jeder Mannschaft unterschiedliche Geschlechter haben, und es war einfacher, zwischen ihnen zu unterscheiden.  (Ich wollte die Spieler auch das Geschlecht ihres Charakters ausw√§hlen lassen.) Dies w√ºrde jedoch viel mehr Zeichnen erfordern.  Also habe ich mich f√ºr m√§nnliche Geckos und weibliche F√ºchse entschieden. <br><br>  Und schlie√ülich habe ich einen Begr√º√üungsbildschirm gezeichnet, weil auf einem St√ºck kariertem Papier Platz daf√ºr war. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/5ac/30a/c675ac30af04025014da7eee842d285d.jpg"></div><br>  Ja, Action-Posen sind immer noch alles andere als ideal.  Der Polarfuchs sollte mehr ver√§rgert sein und rennen, und der Gecko sollte bedrohlich aussehen.  Defender Fox im Hintergrund - ein lustiger Hinweis auf die Kunst auf der Doom-Box. <br><br><h2>  Digitalisierung von Sprites </h2><br>  Dann fing ich an, Papierzeichnungen in Sprites umzuwandeln.  Daf√ºr habe ich das GraphicsGale-Programm verwendet, das k√ºrzlich kostenlos gemacht wurde.  (Ich wei√ü, dass Sie Asesprite verwenden k√∂nnen, aber ich bevorzuge GraphicsGale.) Die Arbeit an Sprites erwies sich als viel komplizierter als erwartet.  Jedes dieser Quadrate aus den oben gezeigten Sprites ben√∂tigt bis zu 4 Pixel in einem 2x2-Raster.  Und diese Quadrate hatten oft VIEL mehr Details als 4 Pixel.  Deshalb musste ich viele Details der Skizzen loswerden.  Manchmal war es sogar schwierig, sich an eine einfache Form zu halten, weil man einen f√ºr Augen oder Nase akzeptablen Ort verlassen musste.  Aber es scheint mir, dass alles gut aussieht, auch wenn das Sprite v√∂llig anders geworden ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39f/789/d16/39f789d16e3c10c85fa4f0613a0cf571.png"></div><br>  Die Augen des Fuchses verloren ihre Mandelform und verwandelten sich in eine zwei Pixel hohe Linie.  Die Augen des Geckos haben ihre Rundheit beibehalten.  Der Kopf des Geckos musste vergr√∂√üert werden, um breite Schultern loszuwerden, und alle Biegungen, die der Fuchs h√§tte haben k√∂nnen, wurden deutlich gegl√§ttet.  Aber ehrlich gesagt sind all diese einfachen √Ñnderungen nicht so schlimm.  Manchmal konnte ich kaum w√§hlen, welche der Variationen besser ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/32f/d71/a5232fd71193a02dfaebdc2c043edbe5.png"></div><br>  GraphicsGale bietet au√üerdem praktische Funktionen f√ºr Ebenen und Animationen.  Dies bedeutet, dass ich den Schwanz des Fuchses getrennt von ihrem K√∂rper animieren kann.  Dies hilft sehr, wertvollen VRAM-Platz zu sparen, da ich den Schwanz nicht in jedem Frame duplizieren muss.  Au√üerdem bedeutete dies, dass Sie mit dem Schwanz mit variabler Geschwindigkeit wedeln, im Stehen des Charakters langsamer und beim Laufen schneller werden konnten.  Dies macht die Programmierung jedoch etwas komplizierter.  Trotzdem werde ich diese Aufgabe √ºbernehmen.  Ich habe mich f√ºr 4 Frames Animation entschieden, weil das genug ist. <br><br>  M√∂glicherweise stellen Sie fest, dass der Polarfuchs die drei hellsten Graustufen verwendet, w√§hrend der Gecko die drei dunkelsten Graustufen verwendet.  In GameBoy ist dies akzeptabel, da ein Sprite zwar nur drei Farben enthalten kann, Sie in der Konsole jedoch zwei Paletten angeben k√∂nnen.  Ich habe es so gemacht, dass Palette 0 f√ºr F√ºchse und Palette 1 f√ºr Geckos verwendet wird. Damit ist der gesamte verf√ºgbare Palettensatz beendet, aber ich glaube nicht, dass ich andere brauchen werde. <br><br>  Ich musste mich auch um den Hintergrund k√ºmmern.  Ich habe mich nicht um seine Skizzen gek√ºmmert, weil ich geplant hatte, dass es eine feste Farbe oder ein einfaches geometrisches Muster sein w√ºrde.  Ich habe den Bildschirmschoner noch nicht digitalisiert, weil ich nicht genug Zeit hatte. <br><br><h2>  Laden von Sprites ins Spiel </h2><br>  √úberpr√ºfen Sie dies mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">be99d97-</a> Commit. <br><br>  Nachdem jeder einzelne Frame von Charaktergrafiken gespeichert wurde, war es m√∂glich, sie in das GameBoy-Format zu konvertieren.  Es stellte sich heraus, dass es in RGBDS ein sehr praktisches Dienstprogramm namens RGBGFX gibt.  Es kann mit dem Befehl <code>rgbgfx -h -o output.bin input.png</code> und erstellt eine Reihe von Kacheln, die mit GameBoy kompatibel sind.  (Der Schalter -h gibt einen Kachelmodus an, der mit 8x16 kompatibel ist, sodass die Konvertierung von oben nach unten und nicht von links nach rechts durchgef√ºhrt wird.) Er bietet jedoch keine Bindungen und kann keine doppelten Kacheln verfolgen, wenn jedes Bild ein separates Bild ist.  Aber wir werden dieses Problem f√ºr sp√§ter belassen. <br><br>  Nachdem Sie die .bin-Ausgabedateien generiert haben, f√ºgen Sie sie einfach mit <code>incbin "output.bin"</code> im Assembler <code>incbin "output.bin"</code> .  Um alles zusammenzuhalten, habe ich eine gemeinsame Datei ‚Äûgfxinclude.z80‚Äú erstellt, die alle hinzuzuf√ºgenden Grafiken enth√§lt. <br><br>  Es war jedoch sehr langweilig, die Grafiken jedes Mal manuell neu zu generieren, wenn sich etwas √§nderte.  Also habe ich die Datei build.bat bearbeitet und die Zeile <code>for %%f in (gfx/*.png) do rgbds\rgbgfx -h -o gfx/bin/%%f.bin gfx/%%f</code> , die jede Datei konvertiert. png im Ordner gfx / in die bin-Datei und speichert sie in gfx / bin.  Es hat mein Leben sehr vereinfacht. <br><br>  Um Hintergrundgrafiken zu erstellen, habe ich <em>viel</em> fauler vorgegangen.  RGBASM hat eine <code>dw `</code> -Richtlinie.  Es folgt eine Zeile mit 8 Werten von 0 bis 4, die einer Zeile mit Pixeldaten entsprechen.  Da Hintergrund-Sprites sehr einfach waren, stellte sich heraus, dass es einfacher war, ein einfaches geometrisches Muster zu kopieren und einzuf√ºgen, um ein festes, gestreiftes oder Schachbrettmuster zu erstellen.  Hier sieht es zum Beispiel aus wie ein Landpl√§ttchen. <br><br><pre> <code class="hljs powershell">bg_dirt: dw `00110011 dw `00000000 dw `01100110 dw `00000000 dw `11001100 dw `00000000 dw `10011001 dw `00000000</code> </pre> <br>  Er schafft eine Reihe von verschobenen Streifen mit der Illusion der Perspektive.  Dies ist ein einfacher, aber kluger Ansatz.  Mit Gras war es etwas komplizierter.  Urspr√ºnglich war es eine Gruppe horizontaler Linien mit einer H√∂he von 2 Pixel, aber ich habe manuell einige Pixel hinzugef√ºgt, die ein wenig Rauschen hinzuf√ºgen, wodurch das Gras besser aussieht: <br><br><pre> <code class="hljs powershell">bg_grass: dw `12121112 dw `12121212 dw `22112211 dw `11121212 dw `22112211 dw `21212121 dw `12121212 dw `12211222</code> </pre> <br><h2>  Grafik-Rendering </h2><br>  In GameBoy werden Sprites in einem Bereich namens OAM oder Object Attribute Memory gespeichert.  Es enth√§lt nur Attribute (Richtung, Palette und Priorit√§t) sowie die Kachelnummer.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gen√ºgte mir, diesen Speicherbereich zu f√ºllen, um Sprites auf dem Bildschirm anzuzeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obwohl es kleine Funktionen gibt. Zun√§chst m√ºssen Sie die Grafiken aus dem ROM in den VRAM laden. GameBoy kann nur Kacheln rendern, die in einem speziellen Speicherbereich namens VRAM gespeichert sind. Gl√ºcklicherweise reicht es zum Kopieren vom ROM in den VRAM aus, dies </font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Initialisierungsphase des Programms </font><font style="vertical-align: inherit;">durchzuf√ºhren </font><font style="vertical-align: inherit;">. Es stellte sich heraus, dass ich mit nur 6 Zeichen-Sprites und 4 Tail-Kacheln bereits ein Viertel der VRAM-Fl√§che f√ºr Sprites belegt habe. (VRAM ist normalerweise in Bereiche mit Hintergrund und Sprites unterteilt, und 128 Bytes sind ihnen gemeinsam.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dar√ºber hinaus ist der Zugriff auf OAM nur w√§hrend VBlank m√∂glich. Ich begann damit, dass VBlank auf Sprite-Berechnungen wartete, aber ich stie√ü auf Probleme, weil die Sprite-Berechnungen die gesamte von VBlank zugewiesene Zeit dauerten und es unm√∂glich war, sie zu beenden. Die L√∂sung besteht darin, in einen </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separaten</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Speicherbereich au√üerhalb von VBlank </font><font style="vertical-align: inherit;">zu schreiben </font><font style="vertical-align: inherit;">und diese w√§hrend VBlank einfach in OAM zu kopieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie sich herausstellte, verf√ºgt GameBoy √ºber ein spezielles Hardware-Kopierverfahren, eine Art DMA (Direct Memory Access, Direct Access to Memory), das genau das tut. Durch Schreiben in ein bestimmtes Register und Aufrufen des Besetztzyklus in HiRAM (da ROM w√§hrend DMA nicht verf√ºgbar ist) k√∂nnen Sie Daten viel schneller aus dem RAM in das OAM kopieren als mit der Funktion</font></font><code>memcpy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei Interesse finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saftige Details </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt konnte ich nur eine Prozedur erstellen, die bestimmt, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schlie√ülich in den DMA geschrieben wird. </font><font style="vertical-align: inherit;">Dazu musste ich den Status von Objekten an einem anderen Ort speichern. </font><font style="vertical-align: inherit;">Zumindest war Folgendes erforderlich:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typ (Gecko, Polarfuchs oder Tragegegenstand eines der Teams) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Richtung </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> X Position </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y-Position </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animationsrahmen </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animations-Timer </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der ersten, sehr ungepflegten Entscheidung habe ich den Typ des Objekts √ºberpr√ºft und abh√§ngig davon zu einer Prozedur gewechselt, die diesen Objekttyp spritisch zeichnet. Das Polarfuchs-Verfahren nahm beispielsweise je nach Richtung eine Position in X ein, addierte oder subtrahierte 16, f√ºgte zwei Schwanz-Sprites hinzu und bewegte sich dann im Haupt-Sprite auf und ab. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier ist ein Screenshot davon, wie das Sprite beim Rendern auf dem Bildschirm in VRAM aussah. Der linke Teil besteht aus einzelnen Sprites, Hexadezimalzahlen daneben, von oben nach unten - vertikale und horizontale Position, Kachel- und Attributflags. Rechts sehen Sie, wie alles nach der Montage aussah.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e9/e7d/240/8e9e7d2401e1a07d0c77e2f0c6c99e3d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit der Schwanzanimation war es etwas komplizierter. In der ersten L√∂sung habe ich einfach den Animations-Timer in jedem Frame inkrementiert und ein logisches Inkrement </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem Wert durchgef√ºhrt </font></font><code>%11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Frame-Nummer zu erhalten. Dann k√∂nnen Sie einfach 4 * die Frame-Nummer (jedes Animationsframe besteht aus 4 Kacheln) zur ersten Endkachel im VRAM hinzuf√ºgen, um 4 verschiedene Frames im VRAM zu speichern. Es funktionierte (besonders das mit der Schwanzkachelsuche), aber der Schwanz wedelte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wahnsinnig</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schnell und ich musste einen Weg finden, ihn zu verlangsamen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zweitens bessere Entscheidungen, f√ºhrte ich in jedem Rahmen erh√∂ht </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den globalen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Timer, und wenn der Wert der Transaktionen </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ihnen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und der von mir gew√§hlte Grad von zwei war 0, das Inkrement des Objekt-Timers wurde durchgef√ºhrt. Somit kann jedes einzelne Objekt seinen Animations-Timer mit jeder ben√∂tigten Geschwindigkeit herunterz√§hlen. Dies funktionierte perfekt und erlaubte mir, den Schwanz auf ein vern√ºnftiges Niveau zu verlangsamen.</font></font><br><br><h2>  Schwierigkeiten </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber wenn alles so einfach w√§re. Vergessen Sie nicht, dass ich all dies im Code verwaltet habe, indem ich f√ºr jedes Objekt meine eigene Unterprozedur verwendet habe. Wenn Sie fortfahren m√ºssen, m√ºssen Sie dies in jedem Frame tun. Ich musste angeben, wie ich zum n√§chsten Sprite √ºbergehen soll und aus welcher Kachel es besteht, indem ich die Register manuell manipuliere. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war ein v√∂llig instabiles System. Um einen Frame zu zeichnen, war es notwendig, eine ausreichend gro√üe Anzahl von Registern und CPU-Zeit zu jonglieren. Es war fast unm√∂glich, Unterst√ºtzung f√ºr andere Mitarbeiter hinzuzuf√ºgen, und selbst wenn es mir gelingen w√ºrde, w√§re die Systemunterst√ºtzung sehr schmerzhaft. </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Glauben Sie mir, es war echtes Chaos.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich brauchte ein System, in dem der Code zum Rendern von Sprites verallgemeinert und unkompliziert ist, damit keine Bedingungen, Manipulationen von Registern und mathematischen Operatoren miteinander verwoben werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie habe ich das behoben? </font><font style="vertical-align: inherit;">Ich werde im n√§chsten Teil des Artikels dar√ºber sprechen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/47d/f64/3a2/47df643a2bd620cf8899b3601162748b.gif" alt="Bild"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436330/">https://habr.com/ru/post/de436330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436320/index.html">Viele Eigenschaften oder Eigenschaftsobjekt: Auswahlkriterien</a></li>
<li><a href="../de436322/index.html">@ Pythonetc Dezember 2018</a></li>
<li><a href="../de436324/index.html">Tipps und Tricks von meinem Telegramm-Kanal @pythonetc, Dezember 2018</a></li>
<li><a href="../de436326/index.html">Re-Dezentralisierung des Web. Diesmal f√ºr immer</a></li>
<li><a href="../de436328/index.html">PVS-Studio 7.00</a></li>
<li><a href="../de436332/index.html">PVS-Studio 7.00</a></li>
<li><a href="../de436334/index.html">Lernkonzepte durch sensomotorische Interaktion</a></li>
<li><a href="../de436338/index.html">Wie funktioniert der Flughafen Vnukovo?</a></li>
<li><a href="../de436340/index.html">Separate Protokollierungsstufe f√ºr jede Anforderung</a></li>
<li><a href="../de436342/index.html">Eine Einf√ºhrung in die robuste Optimierung [... und eine kleine Einkaufsliste, die ich vergessen habe ...]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>