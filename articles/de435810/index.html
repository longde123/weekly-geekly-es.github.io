<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêé üçÆ üí™üèæ JOIN local collection und DbSet in Entity Framework ‚û∞ üôãüèº ‚òÆÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Etwas mehr als ein Jahr lang fand unter meiner Teilnahme der folgende "Dialog" statt: 


 .Net App : Hey Entity Framework, gib mir bitte viele Daten! ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JOIN local collection und DbSet in Entity Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435810/"><p>  Etwas mehr als ein Jahr lang fand unter meiner Teilnahme der folgende "Dialog" statt: </p><br><p>  <strong>.Net App</strong> : Hey Entity Framework, gib mir bitte viele Daten! <br>  <strong>Entity Framework</strong> : Entschuldigung, ich habe Sie nicht verstanden.  Was meinst du? <br>  <strong>.Net App</strong> : Ja, ich habe gerade eine Sammlung von 100.000 Transaktionen erhalten.  Und jetzt m√ºssen wir schnell die Richtigkeit der dort angegebenen Wertpapierpreise √ºberpr√ºfen. <br>  <strong>Entity Framework</strong> : Ahh, nun, lass es uns versuchen ... <br>  <strong>.Net App</strong> : Hier ist der Code: </p><br><pre><code class="cpp hljs">var query = from p in context.Prices join t in transactions on <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { p.Ticker, p.TradedOn, p.PriceSourceId } equals <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t.Ticker, t.TradedOn, t.PriceSourceId } select p; query.ToList();</code> </pre> <br><p>  <strong>Entity Framework</strong> : </p><br><p><img src="https://habrastorage.org/webt/kc/jh/lp/kcjhlpnggo_fhkdgik481svjuea.png"></p><br><p>  Klassisch  Ich denke, viele Leute sind mit dieser Situation vertraut: Wenn ich wirklich ‚Äûsch√∂n‚Äú und schnell eine Suche in der Datenbank mit dem <em>JOIN der</em> lokalen Sammlung und <em>DbSet durchf√ºhren m√∂chte</em> .  Normalerweise ist diese Erfahrung entt√§uschend. </p><br><p>  In diesem Artikel (der eine <em>kostenlose √úbersetzung meines anderen Artikels ist</em> ) werde ich eine Reihe von Experimenten durchf√ºhren und verschiedene Wege ausprobieren, um diese Einschr√§nkung zu umgehen.  Es wird einen Code (unkompliziert), Gedanken und so etwas wie ein Happy End geben. </p><a name="habracut"></a><br><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Jeder kennt das <em>Entity Framework</em> , viele verwenden es jeden Tag und es gibt viele gute Artikel dar√ºber, wie man es richtig kocht (verwenden Sie einfachere Abfragen, verwenden Sie die Parameter in Skip and Take, verwenden Sie VIEW, fordern Sie nur die erforderlichen Felder an, √ºberwachen Sie das Zwischenspeichern von Abfragen und Sonstiges) ist das <em>JOIN-</em> Thema der lokalen Sammlung und von <em>DbSet</em> jedoch immer noch eine Schwachstelle. </p><br><h2 id="zadacha">  Herausforderung </h2><br><p>  Angenommen, es gibt eine Datenbank mit Preisen und eine Sammlung von Transaktionen, f√ºr die Sie die Richtigkeit der Preise √ºberpr√ºfen m√ºssen.  Angenommen, wir haben den folgenden Code. </p><br><pre> <code class="cpp hljs">var localData = GetDataFromApiOrUser(); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in localData on <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { s.Ticker, p.TradedOn, p.PriceSourceId } equals <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t.Ticker, t.TradedOn, t.PriceSourceId } select p; var result = query.ToList();</code> </pre> <br><p>  Dieser Code funktioniert in <em>Entity Framework 6</em> √ºberhaupt nicht.  Im <em>Entity Framework Core</em> funktioniert dies, aber alles wird auf der Clientseite ausgef√ºhrt, und wenn sich Millionen von Datens√§tzen in der Datenbank befinden, ist dies keine Option. </p><br><p>  Wie gesagt, ich werde verschiedene Wege versuchen, um dies zu umgehen.  Von einfach bis komplex.  F√ºr meine Experimente verwende ich den Code aus dem folgenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Repository</a> .  Der Code wird geschrieben mit: <em>C #</em> , <em>.Net Core</em> , <em>EF Core</em> und <em>PostgreSQL</em> . </p><br><p>  Ich habe auch einige Metriken aufgenommen: Zeitaufwand und Speicherverbrauch.  Haftungsausschluss: Wenn der Test l√§nger als 10 Minuten durchgef√ºhrt wurde, habe ich ihn unterbrochen (die Einschr√§nkung ist von oben).  Testmaschine Intel Core i5, 8 GB RAM, SSD. </p><br><div class="spoiler">  <b class="spoiler_title">DB-Schema</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/getpro/habr/post_images/1d5/f8c/cec/1d5f8ccec6ef1b7361195c18ac139d09.png" alt="Bild"></p><br><p>  Nur 3 Tabellen: <em>Preise</em> , <em>Wertpapiere</em> und <em>Preisquellen</em> .  <em>Preise</em> - enth√§lt 10 Millionen Eintr√§ge. </p></div></div><br><h4 id="sposob-1-naive">  Methode 1. Naiv </h4><br><p>  Beginnen wir einfach und verwenden den folgenden Code: </p><br><div class="spoiler">  <b class="spoiler_title">Code f√ºr Methode 1</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { foreach (var testElement in TestData) { result.AddRange(context.Prices.Where( x =&gt; x.Security.Ticker == testElement.Ticker &amp;&amp; x.TradedOn == testElement.TradedOn &amp;&amp; x.PriceSourceId == testElement.PriceSourceId)); } }</code> </pre> </div></div><br><p>  Die Idee ist einfach: In einer Schleife lesen wir nacheinander Datens√§tze aus der Datenbank und f√ºgen sie der resultierenden Sammlung hinzu.  Dieser Code hat nur einen Vorteil - Einfachheit.  Ein Nachteil ist die geringe Geschwindigkeit: Selbst wenn sich ein Index in der Datenbank befindet, wird die meiste Zeit die Kommunikation mit dem Datenbankserver ben√∂tigt.  Die Metriken sind wie folgt: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/985/61c/b6a/98561cb6a2566faff490fc2bf7432fb9.png" alt="Bild"></p><br><p>  Der Speicherverbrauch ist gering.  Eine gro√üe Sammlung dauert 1 Minute.  F√ºr den Anfang nicht schlecht, aber ich will es schneller. </p><br><h4 id="sposob-2-naive-parallel">  Methode 2: Naive Parallele </h4><br><p>  Versuchen wir, Parallelit√§t hinzuzuf√ºgen.  Die Idee ist, von mehreren Threads auf die Datenbank zuzugreifen. </p><br><div class="spoiler">  <b class="spoiler_title">Code f√ºr Methode 2</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;Price&gt;(); var partitioner = Partitioner.Create(<span class="hljs-number"><span class="hljs-number">0</span></span>, TestData.Count); Parallel.ForEach(partitioner, range =&gt; { var subList = TestData.Skip(range.Item1) .Take(range.Item2 - range.Item1) .ToList(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { foreach (var testElement in subList) { var query = context.Prices.Where( x =&gt; x.Security.Ticker == testElement.Ticker &amp;&amp; x.TradedOn == testElement.TradedOn &amp;&amp; x.PriceSourceId == testElement.PriceSourceId); foreach (var el in query) { result.Add(el); } } } });</code> </pre> </div></div><br><p>  Ergebnis: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/916/d22/428/916d224282a3020dc31df6c67a18b070.png" alt="Bild"></p><br><p>  Bei kleinen Sammlungen ist dieser Ansatz sogar langsamer als die erste Methode.  Und f√ºr die Gr√∂√üten - 2 mal schneller.  Interessanterweise wurden auf meinem Computer 4 Threads generiert, was jedoch nicht zu einer 4-fachen Beschleunigung f√ºhrte.  Dies deutet darauf hin, dass der Overhead bei dieser Methode erheblich ist: sowohl auf der Clientseite als auch auf der Serverseite.  Der Speicherverbrauch hat zugenommen, aber nicht wesentlich. </p><br><h4 id="sposob-3-multiple-contains">  Methode 3: Mehrere enth√§lt </h4><br><p>  Zeit, etwas anderes auszuprobieren und die Aufgabe auf eine Abfrage zu reduzieren.  Dies kann wie folgt erfolgen: </p><br><ol><li>  <em>Bereiten</em> Sie 3 einzigartige Sammlungen von <em>Ticker</em> , <em>PriceSourceId</em> und <em>Date vor</em> </li><li>  F√ºhren Sie die Anforderung aus und verwenden Sie 3 <em>Enth√§lt</em> </li><li>  √úberpr√ºfen Sie die Ergebnisse lokal erneut </li></ol><br><div class="spoiler">  <b class="spoiler_title">Code f√ºr Methode 3</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { <span class="hljs-comment"><span class="hljs-comment">//   var tickers = TestData.Select(x =&gt; x.Ticker).Distinct().ToList(); var dates = TestData.Select(x =&gt; x.TradedOn).Distinct().ToList(); var ps = TestData.Select(x =&gt; x.PriceSourceId).Distinct().ToList(); //    3 Contains var data = context.Prices .Where(x =&gt; tickers.Contains(x.Security.Ticker) &amp;&amp; dates.Contains(x.TradedOn) &amp;&amp; ps.Contains(x.PriceSourceId)) .Select(x =&gt; new { Price = x, Ticker = x.Security.Ticker, }) .ToList(); var lookup = data.ToLookup(x =&gt; $"{x.Ticker}, {x.Price.TradedOn}, {x.Price.PriceSourceId}"); //  foreach (var el in TestData) { var key = $"{el.Ticker}, {el.TradedOn}, {el.PriceSourceId}"; result.AddRange(lookup[key].Select(x =&gt; x.Price)); } }</span></span></code> </pre> </div></div><br><p>  Das Problem hierbei ist, dass die Ausf√ºhrungszeit und die Menge der zur√ºckgegebenen Daten stark von den Daten selbst abh√§ngen (sowohl in der Abfrage als auch in der Datenbank).  Das hei√üt, es kann nur ein Satz der erforderlichen Daten zur√ºckgegeben werden, und es k√∂nnen zus√§tzliche Datens√§tze zur√ºckgegeben werden (sogar 100-mal mehr). </p><br><p>  Dies kann anhand des folgenden Beispiels erkl√§rt werden.  Angenommen, es gibt die folgende Tabelle mit Daten: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3f/2bb/ea5/f3f2bbea5148127963cab9010d2b2f10.png" alt="Bild"></p><br><p>  Angenommen, ich ben√∂tige Preise f√ºr <em>Ticker1</em> mit <em>TradedOn</em> = <em>2018-01-01</em> und f√ºr <em>Ticker2</em> mit <em>TradedOn</em> = <em>2018-01-02</em> . </p><br><p>  Dann eindeutige Werte f√ºr <em>Ticker</em> = ( <em>Ticker1</em> , <em>Ticker2</em> ) <br>  Und eindeutige Werte f√ºr <em>TradedOn</em> = ( <em>2018-01-01</em> , <em>2018-01-02</em> ) </p><br><p>  Als Ergebnis werden jedoch 4 Datens√§tze zur√ºckgegeben, da sie diesen Kombinationen wirklich entsprechen.  Das Schlimme ist, dass je mehr Felder verwendet werden, desto gr√∂√üer ist die Chance, zus√§tzliche Datens√§tze zu erhalten. </p><br><p>  Aus diesem Grund m√ºssen mit dieser Methode erhaltene Daten zus√§tzlich clientseitig gefiltert werden.  Und das ist der gr√∂√üte Nachteil. <br>  Die Metriken sind wie folgt: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd5/078/5ef/dd50785efd38900c4d18467607b87a1e.png" alt="Bild"></p><br><p>  Der Speicherverbrauch ist schlechter als bei allen vorherigen Methoden.  Die Anzahl der gelesenen Zeilen ist um ein Vielfaches gr√∂√üer als die angeforderte Anzahl.  Tests f√ºr gro√üe Sammlungen wurden unterbrochen, da sie l√§nger als 10 Minuten liefen.  Diese Methode ist nicht gut. </p><br><h4 id="sposob-4-predicate-builder">  Methode 4. Pr√§dikaten-Builder </h4><br><p>  Versuchen wir es auf der anderen Seite: dem guten alten <em>Ausdruck</em> .  Mit ihnen k√∂nnen Sie 1 gro√üe Abfrage in der folgenden Form erstellen: </p><br><p> <code>‚Ä¶ (.. AND .. AND ..) OR (.. AND .. AND ..) OR (.. AND .. AND ..) ‚Ä¶</code> </p> <br><p>  Dies gibt Hoffnung, dass es m√∂glich sein wird, eine Anfrage zu erstellen und nur die erforderlichen Daten f√ºr einen Anruf zu erhalten.  Code: </p><br><div class="spoiler">  <b class="spoiler_title">Code f√ºr Methode 4</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { var baseQuery = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId select <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestData() { Ticker = s.Ticker, TradedOn = p.TradedOn, PriceSourceId = p.PriceSourceId, PriceObject = p }; var tradedOnProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>); var priceSourceIdProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>); var tickerProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>); var paramExpression = Expression.Parameter(typeof(TestData)); Expression wholeClause = null; foreach (var td in TestData) { var elementClause = Expression.AndAlso( Expression.Equal( Expression.MakeMemberAccess( paramExpression, tradedOnProperty), Expression.Constant(td.TradedOn) ), Expression.AndAlso( Expression.Equal( Expression.MakeMemberAccess( paramExpression, priceSourceIdProperty), Expression.Constant(td.PriceSourceId) ), Expression.Equal( Expression.MakeMemberAccess( paramExpression, tickerProperty), Expression.Constant(td.Ticker)) )); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wholeClause == null) wholeClause = elementClause; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> wholeClause = Expression.OrElse(wholeClause, elementClause); } var query = baseQuery.Where( (Expression&lt;Func&lt;TestData, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt;)Expression.Lambda( wholeClause, paramExpression)).Select(x =&gt; x.PriceObject); result.AddRange(query); }</code> </pre> </div></div><br><p>  Der Code erwies sich als komplizierter als bei den vorherigen Methoden.  Das manuelle Erstellen von <em>Expression ist</em> nicht die einfachste und schnellste Operation. </p><br><p>  Metriken: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/312/373/4fc/3123734fc82c4fc4d783f4f9ce2cf225.png" alt="Bild"></p><br><p>  Tempor√§re Ergebnisse waren noch schlechter als bei der vorherigen Methode.  Es scheint, dass der Aufwand w√§hrend des Baus und beim Gehen durch den Baum viel mehr war als der Gewinn aus der Verwendung einer Anfrage. </p><br><h4 id="sposob-5-shared-query-data-table">  Methode 5: Gemeinsame Abfragedatentabelle </h4><br><p>  Versuchen wir eine andere Option: <br>  Ich habe eine neue Tabelle in der Datenbank erstellt, in die ich die Daten schreiben werde, die zum <em>Abschlie√üen</em> der Anforderung erforderlich sind (implizit ben√∂tige ich ein neues <em>DbSet</em> im Kontext). </p><br><p>  Um das Ergebnis zu erhalten, das Sie ben√∂tigen: </p><br><ol><li>  Transaktion starten </li><li>  Laden Sie Abfragedaten in eine neue Tabelle hoch </li><li>  F√ºhren Sie die Abfrage selbst aus (unter Verwendung der neuen Tabelle). </li><li>  Rollback einer Transaktion (um die Datentabelle f√ºr Abfragen zu l√∂schen) </li></ol><br><p>  Der Code sieht folgenderma√üen aus: </p><br><div class="spoiler">  <b class="spoiler_title">Code f√ºr Methode 5</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { context.Database.BeginTransaction(); var reducedData = TestData.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedQueryModel() { PriceSourceId = x.PriceSourceId, Ticker = x.Ticker, TradedOn = x.TradedOn }).ToList(); <span class="hljs-comment"><span class="hljs-comment">//      context.QueryDataShared.AddRange(reducedData); context.SaveChanges(); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in context.QueryDataShared on new { s.Ticker, p.TradedOn, p.PriceSourceId } equals new { t.Ticker, t.TradedOn, t.PriceSourceId } select p; result.AddRange(query); context.Database.RollbackTransaction(); }</span></span></code> </pre> </div></div><br><p>  Erste Metriken: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df0/ab7/d7d/df0ab7d7d01b0aeaeebf2b9a41f5e75b.png" alt="Bild"></p><br><p>  Alle Tests haben funktioniert und schnell funktioniert!  Der Speicherverbrauch ist ebenfalls akzeptabel. <br>  Somit kann diese Tabelle durch die Verwendung einer Transaktion von mehreren Prozessen gleichzeitig verwendet werden.  Und da es sich um eine real vorhandene Tabelle handelt, stehen uns alle Funktionen des <em>Entity Framework</em> zur Verf√ºgung: Sie m√ºssen nur die Daten in die Tabelle laden, eine Abfrage mit <em>JOIN</em> erstellen und ausf√ºhren.  Auf den ersten Blick ist dies das, was Sie brauchen, aber es gibt erhebliche Nachteile: </p><br><ul><li>  Sie m√ºssen eine Tabelle f√ºr einen bestimmten Abfragetyp erstellen </li><li>  Es ist notwendig, Transaktionen zu verwenden (und DBMS-Ressourcen darauf zu verschwenden). </li><li>  Und die blo√üe Idee, dass Sie etwas SCHREIBEN m√ºssen, wenn Sie LESEN m√ºssen, sieht seltsam aus.  Und bei Read Replica funktioniert es einfach nicht. <br>  Und der Rest ist eine mehr oder weniger funktionierende L√∂sung, die bereits verwendet werden kann. </li></ul><br><h4 id="sposob-6-memoryjoin-extension">  Methode 6. MemoryJoin-Erweiterung </h4><br><p>  Jetzt k√∂nnen Sie versuchen, den vorherigen Ansatz zu verbessern.  Die Gedanken sind: </p><br><ul><li>  Anstatt eine Tabelle zu verwenden, die f√ºr einen Abfragetyp spezifisch ist, k√∂nnen Sie eine verallgemeinerte Option verwenden.  Erstellen Sie n√§mlich eine Tabelle mit einem Namen wie <em>shared_query_data</em> und f√ºgen Sie mehrere <em>Guid-</em> Felder, mehrere <em>Long-</em> , mehrere <em>String-</em> usw. hinzu.  Es k√∂nnen einfache Namen verwendet werden: <em>Guid1</em> , <em>Guid2</em> , <em>String1</em> , <em>Long1</em> , <em>Date2</em> usw.  Dann kann diese Tabelle f√ºr 95% der Abfragetypen verwendet werden.  Eigenschaftsnamen k√∂nnen sp√§ter mithilfe der <strong>Auswahlperspektive</strong> ‚Äûangepasst‚Äú werden. </li><li>  Als n√§chstes m√ºssen Sie ein <em>DbSet</em> f√ºr <em>shared_query_data hinzuf√ºgen</em> . </li><li>  Was aber, wenn anstelle des Schreibens von Daten in die Datenbank Werte mit dem Konstrukt <strong>VALUES √ºbergeben</strong> werden?  Das hei√üt, es ist erforderlich, dass in der endg√ºltigen SQL-Abfrage anstelle des Zugriffs auf <em>shared_query_data</em> ein Aufruf an <strong>VALUES erfolgt</strong> .  Wie kann man das machen? <br><ul><li>  In Entity Framework Core - nur mit <em>FromSql</em> . </li><li>  In Entity Framework 6 - Sie m√ºssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DbInterception verwenden</a> - √§ndern Sie die generierte SQL, indem Sie das <strong>VALUES-</strong> Konstrukt unmittelbar vor der Ausf√ºhrung hinzuf√ºgen.  Dies f√ºhrt zu einer Einschr√§nkung: In einer einzelnen Anforderung <strong>darf</strong> nicht mehr als ein <strong>VALUES-</strong> Konstrukt vorhanden sein.  Aber es wird funktionieren! </li></ul></li><li>  Da wir nicht in die Datenbank schreiben, wird die Tabelle <em>shared_query_data</em> im ersten Schritt erstellt. <em>Wird</em> sie √ºberhaupt nicht ben√∂tigt?  Antwort: Ja, es wird nicht ben√∂tigt, aber <em>DbSet</em> wird weiterhin ben√∂tigt, da das Entity Framework das Datenschema kennen muss, um Abfragen zu erstellen.  Es stellt sich heraus, dass wir ein <em>DbSet</em> f√ºr ein verallgemeinertes Modell ben√∂tigen, das nicht in der Datenbank vorhanden ist und nur dazu verwendet wird, das Entity Framework zu inspirieren, dass es wei√ü, was es tut. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Konvertieren Sie IEnumerable in IQueryable Example</b> <div class="spoiler_text"><ol><li>  Die Eingabe erhielt eine Sammlung von Objekten des folgenden Typs: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeQueryData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Ticker {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTimeTradedOn {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PriceSourceId {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} }</code> </pre> </li><li>  Wir verf√ºgen √ºber <em>DbSet</em> mit den Feldern <em>String1</em> , <em>String2</em> , <em>Date1</em> , <em>Long1</em> <em>usw.</em> </li><li>  Lassen Sie <em>Ticker</em> in <em>String1</em> , <em>TradedOn</em> in <em>Date1</em> und <em>PriceSourceId</em> in <em>Long1 gespeichert</em> ( <em>int</em> mapps in <em>long</em> , um Felder f√ºr <em>int</em> und <em>long nicht</em> getrennt zu machen). </li><li>  Dann <em>sieht FromSql</em> + <em>VALUES</em> folgenderma√üen aus: <br><pre> <code class="cpp hljs">var query = context.QuerySharedData.FromSql( <span class="hljs-string"><span class="hljs-string">"SELECT * FROM ( VALUES (1, 'Ticker1', @date1, @id1), (2, 'Ticker2', @date2, @id2) ) AS __gen_query_data__ (id, string1, date1, long1)"</span></span>)</code> </pre> </li><li>  Jetzt k√∂nnen Sie eine Projektion <em>erstellen</em> und eine bequeme <em>IQueryable</em> mit demselben Typ zur√ºckgeben, der am Eingang war: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeQueryData() { Ticker = x.String1, TradedOn = x.Date1, PriceSourceId = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x.Long1 });</code> </pre> </li></ol></div></div><br><p>  Ich habe es geschafft, diesen Ansatz zu implementieren und ihn sogar als NuGet-Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EntityFrameworkCore.MemoryJoin zu entwerfen</a> (der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code ist</a> ebenfalls verf√ºgbar).  Trotz der Tatsache, dass der Name das Wort <em>Core</em> enth√§lt, wird auch <em>Entity Framework</em> 6 unterst√ºtzt.  Ich habe es <strong>MemoryJoin genannt</strong> , aber tats√§chlich sendet es lokale Daten an das DBMS im <em>VALUES-</em> Konstrukt und die ganze Arbeit wird daran erledigt. </p><br><p>  Der Code lautet wie folgt: </p><br><div class="spoiler">  <b class="spoiler_title">Code f√ºr Methode 6</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { <span class="hljs-comment"><span class="hljs-comment">// :    ,      var reducedData = TestData.Select(x =&gt; new { x.Ticker, x.TradedOn, x.PriceSourceId }).ToList(); //  IEnumerable&lt;&gt;   IQueryable&lt;&gt; var queryable = context.FromLocalList(reducedData); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in queryable on new { s.Ticker, p.TradedOn, p.PriceSourceId } equals new { t.Ticker, t.TradedOn, t.PriceSourceId } select p; result.AddRange(query); }</span></span></code> </pre> </div></div><br><p>  Metriken: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a7/d72/bb2/6a7d72bb265d9dedbc8e54d94fe16a4f.png" alt="Bild"></p><br><p>  Dies ist das beste Ergebnis, das ich je versucht habe.  Der Code war sehr einfach und unkompliziert und funktionierte gleichzeitig f√ºr Read Replica. </p><br><div class="spoiler">  <b class="spoiler_title">Ein Beispiel f√ºr eine generierte Anforderung zum Empfangen von 3 Elementen</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"ClosePrice"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"OpenPrice"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"Price"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-string"><span class="hljs-string">"Security"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"s"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span> = <span class="hljs-string"><span class="hljs-string">"s"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"string1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"date1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"long1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> int4) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, @__gen_q_p0, @__gen_q_p1, @__gen_q_p2), (<span class="hljs-number"><span class="hljs-number">2</span></span>, @__gen_q_p3, @__gen_q_p4, @__gen_q_p5), (<span class="hljs-number"><span class="hljs-number">3</span></span>, @__gen_q_p6, @__gen_q_p7, @__gen_q_p8) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> __gen_query_data__ (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, string1, date1, long1) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"t"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ((<span class="hljs-string"><span class="hljs-string">"s"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span> = <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (<span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> = <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>)</code> </pre> <br><p>  Hier k√∂nnen Sie auch sehen, wie das verallgemeinerte Modell (mit den Feldern <em>String1</em> , <em>Date1</em> , <em>Long1</em> ) mit Select in das im Code verwendete Modell (mit den Feldern <em>Ticker</em> , <em>TradedOn</em> , <em>PriceSourceId</em> ) umgewandelt wird. </p></div></div><br><p>  Alle Arbeiten werden in einer Abfrage auf dem SQL Server ausgef√ºhrt.  Und das ist ein kleines Happy End, √ºber das ich am Anfang gesprochen habe.  Die Verwendung dieser Methode erfordert jedoch Verst√§ndnis und die folgenden Schritte: </p><br><ul><li>  Sie m√ºssen Ihrem Kontext ein zus√§tzliches <em>DbSet</em> hinzuf√ºgen (obwohl die Tabelle selbst <em>weggelassen</em> werden <em>kann</em> ). </li><li>  In dem standardisierten Modell, das standardm√§√üig verwendet wird, werden 3 Felder der Typen <em>Guid</em> , <em>String</em> , <em>Double</em> , <em>Long</em> , <em>Date</em> usw. deklariert.  Das sollte f√ºr 95% der Anfragetypen ausreichen.  Wenn Sie eine Sammlung von Objekten mit 20 Feldern an <em>FromLocalList √ºbergeben</em> , wird eine <em>Ausnahme</em> ausgel√∂st, die besagt, dass das Objekt zu komplex ist.  Dies ist eine weiche Einschr√§nkung und kann umgangen werden. Sie k√∂nnen Ihren Typ deklarieren und dort mindestens 100 Felder hinzuf√ºgen.  Mehr Felder arbeiten jedoch langsamer. </li><li>  Weitere technische Details sind in meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel beschrieben</a> . </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  In diesem Artikel habe ich meine Gedanken zum Thema JOIN local collection und DbSet vorgestellt.  Es schien mir, dass meine Entwicklung mit <em>VALUES</em> f√ºr die Community von Interesse <em>sein</em> k√∂nnte.  Zumindest bin ich einem solchen Ansatz nicht begegnet, als ich dieses Problem selbst gel√∂st habe.  Pers√∂nlich hat mir diese Methode geholfen, eine Reihe von Leistungsproblemen in meinen aktuellen Projekten zu √ºberwinden. Vielleicht hilft sie Ihnen auch. </p><br><p>  Jemand wird sagen, dass die Verwendung von <em>MemoryJoin</em> zu "abstrus" ist und weiterentwickelt werden muss, und bis dahin m√ºssen Sie es nicht verwenden.  Dies ist genau der Grund, warum ich sehr zweifelhaft war und fast ein Jahr lang diesen Artikel nicht geschrieben habe.  Ich stimme zu, dass ich m√∂chte, dass es einfacher funktioniert (ich hoffe, dass es eines Tages so sein wird), aber ich sage auch, dass die Optimierung nie die Aufgabe der Junioren war.  Die Optimierung erfordert immer ein Verst√§ndnis der Funktionsweise des Tools.  Und wenn es die M√∂glichkeit gibt, das 8-fache zu beschleunigen ( <em>Naive Parallel</em> vs <em>MemoryJoin</em> ), w√ºrde ich 2 Punkte und Dokumentation beherrschen. </p><br><p>  Und schlie√ülich die Diagramme: </p><br><p>  Zeit verbracht.  Nur 4 Methoden haben die Aufgabe in weniger als 10 Minuten <em>erledigt</em> , und <em>MemoryJoin</em> ist die einzige M√∂glichkeit, die Aufgabe in weniger als 10 Sekunden zu erledigen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/720/256/846/72025684620477d221c0f113a6cb354f.png" alt="Bild"></p><br><p>  Speicherverbrauch.  Alle Methoden mit Ausnahme von <em>Multiple Contains</em> zeigten ungef√§hr den gleichen Speicherverbrauch.  Dies liegt an der Menge der zur√ºckgegebenen Daten. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e07/a91/b63/e07a91b63375d49a21adb81e8213ffdb.png" alt="Bild"></p><br><p>  Danke f√ºrs Lesen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435810/">https://habr.com/ru/post/de435810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435798/index.html">Sony WH-1000XM3 - die besten kabellosen Kopfh√∂rer?</a></li>
<li><a href="../de435800/index.html">Dekabristenbrief 11</a></li>
<li><a href="../de435802/index.html">OpenVPN, von dem Sie so wenig wussten</a></li>
<li><a href="../de435804/index.html">Intel Cyclone speichert die Konfiguration nach dem Neustart nicht</a></li>
<li><a href="../de435806/index.html">In Japan wurden klinische Studien zu Bioengineering-Patchwork am Herzen angek√ºndigt</a></li>
<li><a href="../de435812/index.html">Theorie des Gl√ºcks. Statistik als wissenschaftlicher Weg, nichts zu wissen</a></li>
<li><a href="../de435814/index.html">[The Old New Thing] Kann ich meinen Stapel nach Belieben verwenden?</a></li>
<li><a href="../de435816/index.html">Das Massachusetts Hospital und DeepMind haben unabh√§ngig voneinander die AI Black Box in der Medizin ge√∂ffnet</a></li>
<li><a href="../de435822/index.html">So steuern Sie Hardware in einem Rechenzentrum mithilfe von Sound</a></li>
<li><a href="../de435824/index.html">Was Sie wissen m√ºssen, bevor Sie eine Karriere in der Audioindustrie beginnen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>