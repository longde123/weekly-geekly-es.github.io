<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≠ üìõ üö¥üèæ Expresiones regulares aplicativas como functor alternativo gratuito üë©üèæ‚Äçüåæ üßòüèæ üè°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les traigo a su atenci√≥n una traducci√≥n de un maravilloso art√≠culo nuevo de Justin Le. En su blog en Code, este autor habla en un lenguaje bastante f√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Expresiones regulares aplicativas como functor alternativo gratuito</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448644/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/zn/lx/ku/znlxkuzq-mdn9op_dfy7enlrwsy.png" width="90%"></div><br><p>  <em>Les traigo a su atenci√≥n una traducci√≥n de un maravilloso art√≠culo nuevo de Justin Le.</em>  <em>En su blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Code,</a> este autor habla en un lenguaje bastante f√°cil sobre la esencia matem√°tica de soluciones funcionales hermosas y elegantes para problemas pr√°cticos.</em>  <em>Este art√≠culo examina en detalle un ejemplo de c√≥mo la transferencia de la estructura matem√°tica que forman los datos en un √°rea tem√°tica a un sistema de tipos de programas puede inmediatamente, como Gerald y Sassman escribieron "autom√°ticamente", conducir a una soluci√≥n de trabajo.</em> </p><br><p> <em>El c√≥digo que se muestra en la imagen es una implementaci√≥n completa y aut√≥noma y extensible del analizador de expresiones regulares, escrito desde cero.</em>  <em>De primera clase, tipo real de magia!</em> </p><a name="habracut"></a><br><p>  ¬°Hoy implementamos analizadores y expresiones regulares aplicativas (en el esp√≠ritu de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicativa regex</a> ) usando estructuras algebraicas gratuitas!  Las estructuras libres son una de mis herramientas favoritas en Haskell y escrib√≠ anteriormente sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">grupos libres</a> , variaciones sobre el tema de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las m√≥nadas libres</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">functor aplicativo "libre" en monoides</a> . </p><br><p>  Las expresiones regulares (y los analizadores para ellos) son omnipresentes en programaci√≥n y ciencias de la computaci√≥n, por lo que espero que al demostrar cu√°n f√°ciles son de implementar utilizando estructuras libres, ayudar√© al lector a apreciar los m√©ritos de este enfoque sin temor a perderse en detalles innecesarios. </p><br><p> Todo el c√≥digo del art√≠culo est√° <a href="">disponible en</a> l√≠nea como un "ejecutable de pila".  Si lo ejecuta ( <code>./regexp.hs</code> ), la sesi√≥n de GHCi comenzar√° con todas las definiciones, por lo que tendr√° la oportunidad de jugar con las funciones y sus tipos. </p><br><p>  Este art√≠culo ser√° completamente comprensible para el "principiante avanzado" o el "especialista principiante" en Haskell.  Requiere el conocimiento de los conceptos b√°sicos de un lenguaje: coincidencia de patrones, tipos de datos algebraicos y abstracciones como monoides, functores y anotaciones do. </p><br><h1 id="regulyarnye-yazyki">  Idiomas regulares </h1><br><p>  Una expresi√≥n regular es una forma de definir un lenguaje regular.  Formalmente, tal expresi√≥n est√° construida de tres elementos b√°sicos: </p><br><ol><li>  Un conjunto vac√≠o es un elemento que no se asigna a nada. </li><li>  Una cadena vac√≠a es un elemento neutral que coincide trivialmente con una cadena vac√≠a. </li><li>  Un literal es un s√≠mbolo que coincide con s√≠ mismo.  Un mont√≥n de un elemento. </li></ol><br><p>  Y tambi√©n de tres operaciones: </p><br><ol><li>  Concatenaci√≥n: <code>RS</code> , secuencia de expresiones.  El producto de conjuntos (cartesiano). </li><li>  Alternativa: <code>R|S</code> , elecci√≥n entre expresiones.  La uni√≥n de conjuntos. </li><li>  Wedge Star: <code>R*</code> , repetici√≥n de una expresi√≥n un n√∫mero arbitrario de veces (incluido cero). </li></ol><br><p>  Y eso es todo lo que compone las expresiones regulares, ni m√°s ni menos.  A partir de estos componentes b√°sicos, puede construir todas las dem√°s operaciones conocidas en expresiones regulares; por ejemplo, <code>a+</code> puede expresarse como <code>aa*</code> , y categor√≠as como <code>\w</code> pueden representarse como una alternativa a los caracteres adecuados. </p><br><div class="spoiler">  <b class="spoiler_title">Nota del traductor</b> <div class="spoiler_text"><p>  La definici√≥n m√≠nima anterior de un lenguaje regular es bastante completa para un matem√°tico, pero poco pr√°ctica.  Por ejemplo, la operaci√≥n de negaci√≥n o adici√≥n ("cualquier car√°cter excepto el especificado") puede escribirse como parte de la definici√≥n b√°sica, pero su aplicaci√≥n directa conducir√° a un aumento exponencial de los recursos utilizados. </p></div></div><br><h1 id="alternativnyy-funktor">  Functor alternativo </h1><br><p>  Cuando miras la estructura de las expresiones regulares, ¬øno te parece familiar?  Me recuerda mucho a la clase de tipo <code>Alternative</code> .  Si un functor pertenece a esta clase, esto significa que se definen los siguientes para √©l: </p><br><ol><li>  Un elemento vac√≠o correspondiente a la falla o error de c√°lculo. </li><li>  <code>pure x</code> : un elemento √∫nico (de la clase <code>Applicative</code> ). </li><li>  Operaci√≥n <code>&lt;*&gt;</code> , organizaci√≥n de c√°lculos secuenciales. </li><li>  Operaci√≥n <code>&lt;|&gt;</code> , organizaci√≥n de c√°lculos alternativos. </li><li>  La funci√≥n <code>many</code> es la operaci√≥n de repetir c√°lculos cero o m√°s veces. </li></ol><br><p>  Todo esto es muy similar a la construcci√≥n de un lenguaje regular, ¬øverdad?  Quiz√°s el functor alternativo es casi lo que necesitamos, lo √∫nico que falta es la primitiva correspondiente al car√°cter literal. </p><br><p>  Cualquier persona nueva en la clase <code>Alternative</code> puede encontrar una buena introducci√≥n a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Typeclassopedia</a> .  Pero en el marco de nuestro art√≠culo, esta clase representa simplemente un "doble monoide" con dos formas de combinar <code>&lt;*&gt;</code> y <code>&lt;|&gt;</code> , que, en cierto sentido, se pueden comparar con las operaciones <code>*</code> y <code>+</code> para los n√∫meros.  En general, para determinar un functor alternativo, los cinco puntos anteriores y algunas leyes adicionales de conmutatividad y distributividad son suficientes. </p><br><div class="spoiler">  <b class="spoiler_title">Nota del traductor (aburrida)</b> <div class="spoiler_text"><p>  Para ser precisos, el autor se emocion√≥ un poco con el "doble monoide".  La clase <code>Alternative</code> ampl√≠a el functor aplicativo, que (bajo ciertas restricciones) es un semigrupo, a un semired, donde la operaci√≥n de suma <code>&lt;|&gt;</code> con el elemento neutro <code>empty</code> desempe√±a el papel de un monoide conmutativo.  Operador de aplicaciones </p><br><pre> <code class="haskell hljs">(&lt;*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; f (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  no puede actuar como un an√°logo de la operaci√≥n de multiplicaci√≥n en un semired, ya que ni siquiera forma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">magma</a> .  Sin embargo, junto con el operador <code>&lt;*&gt;</code> , los operadores "unilaterales" <code>*&gt;</code> y <code>&lt;*</code> definen en el paquete <code>Control.Applicative</code> .  Cada uno de ellos ignora el resultado del operando que la "esquina" no muestra: </p><br><pre> <code class="haskell hljs">(&lt;*) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fa (*&gt;) :: <span class="hljs-type"><span class="hljs-type">Applicative</span></span> f =&gt; fa -&gt; fb -&gt; fb</code> </pre> <br><p>  Si los tipos <code>b</code> coinciden, entonces con estas operaciones obtenemos un semigrupo (la asociatividad se deriva de las propiedades de la composici√≥n).  Se puede verificar que para un functor alternativo, la multiplicaci√≥n es distributiva con respecto a la suma, tanto a la derecha como a la izquierda, y, adem√°s, el elemento neutro para la suma (an√°logo de cero) es un elemento absorbente para la operaci√≥n de multiplicaci√≥n. </p><br><p>  Semirings tambi√©n forman n√∫meros, conjuntos, matrices de semirremolques, tipos algebraicos y ... expresiones regulares, as√≠ que, en realidad, estamos hablando de la misma estructura algebraica. </p></div></div><br><p>  Por lo tanto, podemos considerar las expresiones regulares como un functor alternativo, m√°s una primitiva para un car√°cter literal.  Pero, hay otra forma de verlos, y nos lleva directamente a estructuras libres.  En lugar del "functor alternativo con literales", podemos convertir el literal en una instancia de la clase <code>Alternative</code> . </p><br><h1 id="svoboda">  Libertad </h1><br><p>  Escribamos as√≠.  Escriba para literal primitivo: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span></span></code> </pre> <br><p>  Tenga en cuenta que dado que trabajamos con functores (aplicativos, alternativos), con todas nuestras expresiones regulares se asociar√° un cierto "resultado".  Esto se debe a que al definir una instancia para las clases <code>Functor</code> , <code>Applicative</code> y <code>Alternative</code> , debemos tener un tipo de par√°metro. </p><br><p>  Por un lado, puede ignorar este tipo, pero por otro lado, debe usar este valor como resultado de la coincidencia con una expresi√≥n regular, como se hace en aplicaciones industriales que funcionan con expresiones regulares. </p><br><p>  En nuestro caso, <code>Prim 'a' 1 :: Prim Int</code> representar√° una primitiva que se asigna al car√°cter <code>'a'</code> y se interpreta de inmediato, dando como resultado una unidad. </p><br><p>  Bueno, ahora ... demosle a nuestro primitivo la estructura matem√°tica deseada usando el functor alternativo gratuito de la biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>free</code></a> : </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free type RegExp = Alt Prim</code> </pre> <br><p>  Eso es todo!  ¬°Este es nuestro tipo completo para expresiones regulares!  Al declarar el tipo <code>Alt</code> como una instancia de la clase <code>Functor</code> , obtuvimos todas las operaciones de las clases <code>Applicative</code> y <code>Alternative</code> , ya que en este caso hay instancias de <code>Applicative (Alt f)</code> y <code>Alternative (Alt f)</code> .  Ahora tenemos: </p><br><ul><li>  Conjunto vac√≠o trivial: <code>empty</code> de la clase <code>Alternative</code> </li><li>  Cadena vac√≠a: <code>pure</code> de la clase <code>Applicative</code> </li><li>  Car√°cter Literal - <code>Prim</code> B√°sico </li><li>  Concatenaci√≥n - <code>&lt;*&gt;</code> de la clase <code>Applicative</code> </li><li>  Alternativa - <code>&lt;|&gt;</code> de la clase <code>Alternative</code> </li><li>  Kleene Star - <code>many</code> de la clase <code>Alternative</code> </li></ul><br><p>  ¬°Y todo esto lo obtuvimos completamente "gratis", es decir, "gratis"! </p><br><p>  Esencialmente, una estructura libre autom√°ticamente nos proporciona solo una abstracci√≥n para el tipo base y nada m√°s.  Pero las expresiones regulares, por s√≠ mismas, tambi√©n representan solo una estructura: elementos b√°sicos y un conjunto de operaciones, ni m√°s ni menos, por lo que el functor alternativo gratuito nos proporciona exactamente lo que necesitamos.  No m√°s, pero no menos. </p><br><p>  Despu√©s de agregar algunas funciones de envoltura convenientes ... ¬°el trabajo sobre el tipo est√° completo! </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | charAs:   ,    charAs :: Char -&gt; a -&gt; RegExp a charAs cx = liftAlt (Prim cx) -- liftAlt :: fa -&gt; Alt fa   --   Prim   RegExp -- | char:         char :: Char -&gt; RegExp Char char c = charAs cc -- | string:         string :: String -&gt; RegExp String string = traverse char -- , ?</span></span></code> </pre> <br><h1 id="primery">  Ejemplos </h1><br><p>  Bueno, vamos a intentarlo?  Construyamos la expresi√≥n <code>(a|b)(cd)*e</code> , que devuelve, en caso de una coincidencia exitosa, el tipo de unidad <code>()</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp_</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> () testRegExp_ = void $ (char 'a' &lt;|&gt; char 'b') *&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) *&gt; char 'e'</code> </pre> <br><p>  La funci√≥n <code>void :: Functor f =&gt; fa -&gt; f ()</code> del paquete <code>Data.Functor</code> descarta el resultado, lo usamos, ya que solo estamos interesados ‚Äã‚Äãen el √©xito de la comparaci√≥n.  Pero los operadores <code>&lt;|&gt;</code> , <code>*&gt;</code> y <code>many</code> utilizamos exactamente como se supone al concatenar o elegir una de las opciones. </p><br><p>  Aqu√≠ hay un ejemplo m√°s complicado e interesante: definamos la misma expresi√≥n regular, pero ahora, como resultado de la coincidencia, calculamos el n√∫mero de repeticiones del <code>cd</code> de la subcadena. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExp</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExp = (char 'a' &lt;|&gt; char 'b') *&gt; (length &lt;$&gt; many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>)) &lt;* char 'e'</code> </pre> <br><p>  Hay una sutileza en la operaci√≥n de los operadores <code>*&gt;</code> y <code>&lt;*</code> : las flechas indican el resultado que debe guardarse.  Y dado que <code>many (string "cd") :: RegExp [String]</code> devuelve una lista de elementos que se repiten, podemos, permaneciendo dentro del functor, calcular la longitud de esta lista obteniendo el n√∫mero de repeticiones. </p><br><p>  Adem√°s, la <code>-XApplicativeDo</code> compilador GHC <code>-XApplicativeDo</code> permite escribir nuestra expresi√≥n usando do-notation, que probablemente sea m√°s f√°cil de entender: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">testRegExpDo</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> testRegExpDo = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> char 'a' &lt;|&gt; char 'b' cds &lt;- many (string <span class="hljs-string"><span class="hljs-string">"cd"</span></span>) char 'e' pure (length cds)</code> </pre> <br><p>  Todo esto es algo similar a c√≥mo "capturamos" el resultado de analizar una cadena usando una expresi√≥n regular, obteniendo acceso a ella.  Aqu√≠ hay un ejemplo en Ruby: </p><br><pre> <code class="ruby hljs">irb&gt; <span class="hljs-regexp"><span class="hljs-regexp">/(a|b)((cd)*)e/</span></span>.match(<span class="hljs-string"><span class="hljs-string">"acdcdcdcde"</span></span>)[<span class="hljs-number"><span class="hljs-number">2</span></span>] =&gt; <span class="hljs-string"><span class="hljs-string">"cdcdcdcd"</span></span></code> </pre> <br><p>  La √∫nica diferencia es que agregamos algo de procesamiento posterior para calcular el n√∫mero de repeticiones. </p><br><p>  Aqu√≠ hay otra conveniente regular <code>\d</code> que coincide con un n√∫mero del 0 al 9 y devuelve un n√∫mero: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">digit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> digit = asum [ charAs (intToDigit i) i | i &lt;- [<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.9</span></span>] ]</code> </pre> <br><p>  Aqu√≠, la funci√≥n <code>asum</code> del paquete <code>Control.Applicative.Alternative</code> representa una selecci√≥n de los elementos de la lista <code>asum [x,y,z] = x &lt;|&gt; y &lt;|&gt; z</code> , y la funci√≥n <code>intToDigit</code> define en el paquete <code>Data.Char</code> .  Y, nuevamente, podemos crear cosas bastante elegantes, por ejemplo, la expresi√≥n <code>\[\d\]</code> , correspondiente al n√∫mero entre corchetes: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">bracketDigit</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> bracketDigit = char '[' *&gt; digit &lt;* char ']'</code> </pre> <br><h1 id="parsing">  Analizando </h1><br><p>  Bueno, bueno, todo lo que hicimos fue describir el tipo de datos para un literal con concatenaci√≥n, selecci√≥n y repetici√≥n.  Genial  Pero lo que realmente necesitamos es hacer coincidir una cadena con una expresi√≥n regular, ¬øverdad?  ¬øC√≥mo puede ayudarnos un functor alternativo gratuito con esto?  De hecho, ayudar√° mucho.  ¬°Veamos dos formas de hacer esto! </p><br><h2 id="razgruzhaem-alternativnyy-funktor">  Descargar el functor alternativo </h2><br><p>  <strong>¬øQu√© es la libertad?</strong> </p><br><p>  La forma can√≥nica de usar una estructura libre es doblarla en una estructura de concreto usando √°lgebra adecuada.  Por ejemplo, la transformaci√≥n <code>foldMap</code> convierte un monoide (lista) libre en el valor de cualquier instancia de la clase <code>Monoid</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldMap</span></span> :: <span class="hljs-type"><span class="hljs-type">Monoid</span></span> m =&gt; (a -&gt; m) -&gt; ([a] -&gt; m)</code> </pre> <br><p>  La funci√≥n <code>foldMap</code> convierte la transformaci√≥n <code>a -&gt; m</code> en la transformaci√≥n <code>[a] -&gt; m</code> (o, <code>FreeMonoid a -&gt; m</code> ), con un monoide espec√≠fico <code>m</code> .  La idea general es que el uso de una estructura libre le permite posponer su uso espec√≠fico "para m√°s adelante", separando el tiempo de creaci√≥n y el tiempo de uso de la estructura. </p><br><p>  Por ejemplo, podemos construir un monoide libre a partir de n√∫meros: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- |  "" `Int`     `Int`,  `liftAlt`. liftFM :: Int -&gt; [Int] liftFM x = [x] myMon :: [Int] myMon = liftFM 1 &lt;&gt; liftFM 2 &lt;&gt; liftFM 3 &lt;&gt; liftFM 4</span></span></code> </pre> <br><p>  Y ahora podemos decidir c√≥mo queremos interpretar la operaci√≥n <code>&lt;&gt;</code> : <br>  Tal vez esta adici√≥n? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Sum</span></span> myMon <span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 + 2 + 3 + 4</span></span></code> </pre> <br><p>  O la multiplicaci√≥n? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Product</span></span> myMon <span class="hljs-type"><span class="hljs-type">Product</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 * 2 * 3 * 4</span></span></code> </pre> <br><p>  ¬øO tal vez el c√°lculo del n√∫mero m√°ximo? </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; foldMap <span class="hljs-type"><span class="hljs-type">Max</span></span> myMon <span class="hljs-type"><span class="hljs-type">Max</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">-- 1 `max` 2 `max` 3 `max` 4</span></span></code> </pre> <br><p>  La idea es posponer la selecci√≥n de un monoide en particular mediante la construcci√≥n de una colecci√≥n gratuita de n√∫meros 1, 2, 3 y 4. Un monoide libre sobre los n√∫meros determina la estructura sobre ellos que necesita, ni m√°s ni menos.  Para usar <code>foldMap</code> especificamos "c√≥mo percibir el tipo base" pasando el operador <code>&lt;&gt;</code> a un monoide en particular. </p><br><p>  <strong>Interpretaci√≥n en un Fundador del <code>State</code></strong> </p><br><p>  En la pr√°ctica, obtener un resultado de una estructura libre consiste en encontrar (o crear) un functor adecuado que nos proporcione el comportamiento deseado.  En nuestro caso, tenemos la suerte de que haya una implementaci√≥n espec√≠fica de la clase <code>Alternative</code> que funcione exactamente como la necesitamos: <code>StateT String Maybe</code> . </p><br><p>  El producto <code>&lt;*&gt;</code> para este functor consiste en organizar una secuencia de cambios de estado.  En nuestro caso, bajo el estado, consideraremos el resto de la cadena analizada, por lo que el an√°lisis secuencial es la mejor coincidencia para la operaci√≥n <code>&lt;*&gt;</code> . </p><br><p>  Y su suma <code>&lt;|&gt;</code> funciona como retroceso, una b√∫squeda con un retorno a la alternativa en caso de falla.  Conserva el estado desde la √∫ltima ejecuci√≥n exitosa del an√°lisis y vuelve a √©l si la alternativa se selecciona sin √©xito.  Este es exactamente el comportamiento que esperamos de la expresi√≥n <code>R|S</code> </p><br><p>  Finalmente, una transformaci√≥n natural para un functor alternativo gratuito se llama <code>runAlt</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. pb -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">Alt</span></span> pa -&gt; fa</code> </pre> <br><p>  O, para el tipo RegExp: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runAlt</span></span> :: <span class="hljs-type"><span class="hljs-type">Alternative</span></span> f =&gt; (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> b. <span class="hljs-type"><span class="hljs-type">Prim</span></span> b -&gt; fb) -&gt; <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; fa</code> </pre> <br><p>  Si no est√° familiarizado con los tipos de <code>RankN</code> (con una construcci√≥n completa), puede ver una buena introducci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> .  El punto aqu√≠ es que debe proporcionar una funci√≥n <code>runAlt</code> que funcione con <code>Prim b</code> para absolutamente cualquier <code>b</code> , y no de ning√∫n tipo en particular, como <code>Int</code> y <code>Bool</code> , por ejemplo.  Es decir, como con <code>foldMap</code> solo necesitamos especificar qu√© hacer con el tipo base.  En nuestro caso, responda la pregunta: "¬øQu√© se debe hacer con el tipo <code>Prim</code> ?" </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">processPrim</span></span> :: <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">StateT</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> d:ds &lt;- get guard (c == d) put ds pure x</code> </pre> <br><p>  Esta es una interpretaci√≥n de <code>Prim</code> como una acci√≥n en el contexto de la <code>StateT String Maybe</code> , donde el estado es una cadena <code>StateT String Maybe</code> .  Perm√≠teme recordarte que <code>Prim</code> contiene informaci√≥n sobre el car√°cter coincidente <code>c</code> su interpretaci√≥n en forma de alg√∫n valor de <code>x</code> .  <code>Prim</code> procesamiento <code>Prim</code> consta de los siguientes pasos: </p><br><ul><li>  Usando <code>get</code> estado (parte a√∫n no analizada de la cadena) e imprimimos inmediatamente su primer car√°cter y el resto.  Si la l√≠nea est√° vac√≠a, volver√° una alternativa.  ( <em>El transformador <code>StateT</code> act√∫a dentro del functor Maybe, y si es imposible hacer coincidir el patr√≥n en el lado derecho del operador <code>&lt;-</code> dentro del bloque do, los c√°lculos terminar√°n con el resultado <code>empty</code> , es decir, <code>Nothing</code> . Approx. Trans.</em> ). </li><li>  Usamos la expresi√≥n de guardia para unir el car√°cter actual con el car√°cter dado.  En caso de falla, <code>empty</code> devuelve el <code>empty</code> y pasamos a la opci√≥n alternativa. </li><li>  Cambiamos el estado reemplazando la cadena analizada con su "cola", ya que en este momento el car√°cter actual ya puede considerarse analizado con √©xito. </li><li>  Devolvemos lo que la primitiva primitiva deber√≠a devolver. </li></ul><br><p>  Ya puede usar esta funci√≥n para asignar RegEx a un prefijo de cadena.  Para hacer esto, debe comenzar los c√°lculos usando <code>runAlt</code> y <code>runStateT</code> , pasando la cadena analizada a la √∫ltima funci√≥n como argumento: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchPrefix</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchPrefix re = evalStateT (runAlt processPrim re)</code> </pre> <br><p>  Eso es todo!  Veamos c√≥mo funciona nuestra primera soluci√≥n: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchPrefix testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchPrefix testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchPrefix digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchPrefix bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchPrefix (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchPrefix (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><p>  <strong>Espera, que fue eso?</strong> </p><br><p>  Parece que todo sucedi√≥ un poco m√°s r√°pido de lo que esperabas.  Hace un minuto escribimos nuestro primitivo, ¬°y luego otra vez!  y el analizador de trabajo est√° listo.  Aqu√≠, de hecho, todo el c√≥digo clave, algunas l√≠neas en Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Trans.State (<span class="hljs-title"><span class="hljs-title">evalStateT</span></span>, <span class="hljs-title"><span class="hljs-title">put</span></span>, <span class="hljs-title"><span class="hljs-title">get</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Alternative.Free (<span class="hljs-title"><span class="hljs-title">runAlt</span></span>, <span class="hljs-type"><span class="hljs-type">Alt</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Applicative <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">guard</span></span>) data Prim a = Prim Char a deriving Functor type RegExp = Alt Prim matchPrefix :: RegExp a -&gt; String -&gt; Maybe a matchPrefix re = evalStateT (<span class="hljs-title"><span class="hljs-title">runAlt</span></span> <span class="hljs-title"><span class="hljs-title">processPrim</span></span> <span class="hljs-title"><span class="hljs-title">re</span></span>) where processPrim (<span class="hljs-type"><span class="hljs-type">Prim</span></span> <span class="hljs-title"><span class="hljs-title">cx</span></span>) = do d:ds &lt;- get guard (<span class="hljs-title"><span class="hljs-title">c</span></span> == <span class="hljs-title"><span class="hljs-title">d</span></span>) put ds pure x</code> </pre> <br><p>  ¬øY tenemos un analizador de expresiones regulares completamente funcional?  Que paso </p><br><p>  Recuerde que a un alto nivel de abstracci√≥n, <code>Alt Prim</code> ya contiene <code>pure</code> , <code>empty</code> , <code>Prim</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> , y <code>many</code> en su estructura (hay una sutileza desagradable con este operador, pero m√°s sobre eso m√°s adelante).  Lo que <code>runAlt</code> hace <code>runAlt</code> es usar el comportamiento de un functor alternativo particular (en nuestro caso, <code>StateT String Maybe</code> ) para controlar el comportamiento de los operadores <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> y <code>many</code> .  Sin embargo, <code>StateT</code> no tiene un operador incorporado similar a <code>Prim</code> , y para esto necesit√°bamos escribir <code>processPrim</code> . </p><br><p>  Entonces, para el tipo <code>Prim</code> , la funci√≥n <code>runAlt</code> usa <code>runAlt</code> , y para <code>pure</code> , <code>empty</code> , <code>&lt;*&gt;</code> , <code>&lt;|&gt;</code> y <code>many</code> , se usa una instancia adecuada de la clase <code>Alternative</code> .  Por lo tanto, el 83% del trabajo lo realiza para nosotros el functor <code>StateT</code> , y el 17% restante lo realiza <code>StateT</code> .  En verdad, esto es algo decepcionante.  Uno puede preguntarse: ¬øpor qu√© fue necesario comenzar con el envoltorio <code>Alt</code> ?  ¬øPor qu√© no definir inmediatamente el tipo <code>RegExp = StateT String Maybe</code> y la primitiva apropiada <code>char :: Char -&gt; StateT String Maybe Char</code> ?  Si todo se hace en el <code>StateT</code> StateT, ¬øpor qu√© molestarse con <code>Alt</code> , un functor alternativo gratuito? </p><br><p>  <code>Alt</code> principal ventaja de <code>Alt</code> sobre <code>StateT</code> es que <code>StateT</code> es ... una herramienta bastante poderosa.  Pero, de hecho, es poderoso, hasta el punto del absurdo.  Se puede usar para representar una gran cantidad de los c√°lculos y estructuras m√°s diversos, y, desafortunadamente, es f√°cil imaginar algo que no sea una expresi√≥n regular.  Digamos algo b√°sico como <code>put "hello" :: StateT String Maybe ()</code> no coincide con ninguna expresi√≥n regular v√°lida, pero es del mismo tipo que <code>RegExp ()</code> .  Por lo tanto, mientras decimos que <code>Alt Prim</code> coincide con una expresi√≥n regular, no m√°s, pero no menos, no podemos decir lo mismo con <code>StateT String Maybe</code> .  El tipo <code>Alt Prim</code> es la representaci√≥n perfecta de una expresi√≥n regular.  Todo lo que se puede expresar con su ayuda es una expresi√≥n regular, pero cualquier cosa que no sea tal expresi√≥n no se puede expresar con su ayuda.  Aqu√≠, sin embargo, tambi√©n hay algunas sutilezas desagradables asociadas con la pereza de Haskell, m√°s sobre esto m√°s adelante. </p><br><p>  Aqu√≠ podemos considerar <code>StateT</code> solo como un contexto utilizado para uno <br>  interpretaciones de expresiones regulares - como un analizador sint√°ctico.  Pero puedes imaginar otras formas de usar <code>RegExp</code> .  Por ejemplo, podemos necesitar su representaci√≥n textual, que es lo que <code>StateT</code> no permitir√°. </p><br><p>  No podemos decir que <code>StateT String Maybe</code> es una expresi√≥n regular, solo que este functor puede representar un analizador basado en gram√°ticas regulares.  Pero sobre <code>Alt Prim</code> podemos decir con certeza que esta es una expresi√≥n regular ( <em>como dicen los matem√°ticos, son iguales al isomorfismo, aprox. Trans.</em> ). </p><br><h2 id="neposredstvennoe-ispolzovanie-svobodnoy-struktury">  Uso directo de estructura libre. </h2><br><p>  Todo esto, por supuesto, es muy bueno, pero ¬øqu√© pasa si no queremos cambiar el 83% del trabajo para codificar un tipo que fue escrito por alguien para nosotros?  ¬øEs posible usar la estructura <code>Alt</code> libre directamente para escribir un analizador?  Esta pregunta es similar a esta: ¬øc√≥mo escribir una funci√≥n que procese listas (haciendo coincidir los constructores <code>(:)</code> y <code>[]</code> ) en lugar de usar solo <code>foldMap</code> ?  ¬øC√≥mo operar directamente con esta estructura en lugar de delegar el trabajo a un monoide espec√≠fico? </p><br><p>  Me alegra que hayas preguntado!  Echemos un vistazo a la definici√≥n de un functor alternativo gratuito: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> fa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alternatives</span></span></span><span class="hljs-class"> :: [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">] } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AltF</span></span></span><span class="hljs-class"> fa = forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ap</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fr</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alt</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br><p>  Este es un tipo inusual definido a trav√©s de la recursividad mutua, por lo que puede parecer muy confuso.  Una forma de entenderlo es imaginar que <code>Alt xs</code> contiene una cadena de alternativas formadas usando el operador <code>&lt;|&gt;</code> .       <code>AltF</code> ,     <code>f</code> ,     <code>&lt;*&gt;</code> (   ). </p><br><p>   <code>AltF fa</code>    <code>[fr]</code> ,   <code>r</code>   . <code>Ap</code>   <code>(:)</code> ,  <code>fr</code> ,  <code>Pure</code> ‚Äî   <code>[]</code> .  <code>forall r.</code>       <code>-XExistentialQuantification</code>         . </p><br><p>   , <code>Alt f</code>   ,      .     ,      ( )  <code>&lt;*&gt;</code>  <code>&lt;|&gt;</code> ,  ,   <code>[a]</code>      <code>&lt;&gt;</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>       ,     : </p><br><ul><li>   () ‚Äî ,   <code>&lt;&gt;</code> : <br><pre> <code class="haskell hljs">[a,b,c,d] = [a]&lt;&gt;[b]&lt;&gt;[c]&lt;&gt;[d]</code> </pre> </li><li>   () ‚Äî  ,   <code>+</code> ,   ‚Äî ,   <code>*</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">a</span></span>*(b+c)+d*(x+y+z)*h</code> </pre> </li><li>    (Alt f) ‚Äî  ,   <code>&lt;|&gt;</code> ,   ‚Äî ,   <code>&lt;*&gt;</code> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fa</span></span> &lt;*&gt; (fb &lt;|&gt; fc) &lt;|&gt; fd &lt;*&gt; (fx &lt;|&gt; fy &lt;|&gt; fz) &lt;*&gt; fh</code> </pre> </li></ul></div></div><br><p>   ,       <code>RegExp a -&gt; String -&gt; Maybe a</code> ,   ,     .          :         . </p><br><p>  ,   <code>Alt</code> .   ,           ,     . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchAlts</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchAlts (<span class="hljs-type"><span class="hljs-type">Alt</span></span> res) xs = asum [ matchChain re xs | re &lt;- res ]</code> </pre> <br><p>   <code>asum :: [Maybe a] -&gt; Maybe a</code>   ,   <code>Just</code> . ( <em>   ,   <code>Maybe a</code>       <code>Alternative</code> ‚Äî   <code>Nothing</code> ,   <code>&lt;|&gt;</code>    . . .</em> ) </p><br><p>     .       <code>AltF</code> ,   <code>Ap</code>  <code>Pure</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = _ matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) cs = _</code> </pre> <br><p>      "  ":     GHC   "",   ,    ,   . ( <em> Haskell "" (holes)     ,   <code>_</code> ,      . . .</em> )        : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matchChain</span></span> :: <span class="hljs-type"><span class="hljs-type">AltF</span></span> <span class="hljs-type"><span class="hljs-type">Prim</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a matchChain (<span class="hljs-type"><span class="hljs-type">Ap</span></span> (<span class="hljs-type"><span class="hljs-type">Prim</span></span> cx) next) cs = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cs <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [] -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> d:ds | c == d -&gt; matchAlts (($ x) &lt;$&gt; next) ds | otherwise -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span> matchChain (<span class="hljs-type"><span class="hljs-type">Pure</span></span> x) _ = <span class="hljs-type"><span class="hljs-type">Just</span></span> x</code> </pre><br><p>   <code>Ap</code> (  <code>(:)</code> ),  ,  -    .         ,       .    <code>Prim r</code> ,   ,           <code>next :: RegExp (r -&gt; a)</code> .    ,       <code>next</code> .   , ""  ,  <code>Nothing</code> . ,     <code>Pure x</code> (   <code>[]</code> ), ,  ,      . </p><br><p> ,        ,    .  ,  ,  " "    <code>Ap</code> , <code>Pure</code> , <code>AltF</code>  ..,            . </p><br><p>          : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> () ghci&gt; matchAlts testRegexp_ <span class="hljs-string"><span class="hljs-string">"acdcdcdx"</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"acdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> ghci&gt; matchAlts testRegexp <span class="hljs-string"><span class="hljs-string">"bcdcdcdcdcdcdcde"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> ghci&gt; matchAlts digit <span class="hljs-string"><span class="hljs-string">"9"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> ghci&gt; matchAlts bracketDigit <span class="hljs-string"><span class="hljs-string">"[2]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> ghci&gt; matchAlts (many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ghci&gt; matchAlts (sum &lt;$&gt; many bracketDigit) <span class="hljs-string"><span class="hljs-string">"[2][3][4][5]"</span></span> <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p>              . ,      () ,            .    ,  ,   . </p></div></div><br><h1 id="chto-zhe-imenno-my-sdelali">     ? </h1><br><p>                <code>foldMap</code>     .    ,   ,         foldMap,     ,     ,    ,   ! ,   ‚Äî    ,           ‚Äî    <code>(:)</code>  <code>[]</code> . </p><br><p>  ,   ,    : ,   ,    ,  <code>(:)</code> ,  <code>[]</code> .  ,     .  ,  <code>[1,2,3] &lt;&gt; [4]</code>      ,   <code>[1] &lt;&gt; [2,3] &lt;&gt; [4]</code> .  ,    ,      . </p><br><p>        .  ,     : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Empty</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a | forall r. </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Seq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">r</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Union</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Many</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RegExp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>       <code>RegExp</code> ,        .      . ,      <code>RegExp</code>       : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | a|(b|c) abc1 :: RegExp Int abc1 = Prim 'a' 1 `Union` (Prim 'b' 2 `Union` Prim 'c' 3) -- | (a|b)|c abc2 :: RegExp Int abc2 = (Prim 'a' 1 `Union` Prim 'b' 2) `Union` Prim 'c' 3</span></span></code> </pre> <br><p>  ,             . </p><br><p>    <code>Alt Prim</code> ,       ,        ,       .  ,       <code>matchAlts</code> ,            .     <code>(a|b)|c</code>  <code>a|(b|c)</code> .     <code>Alt</code>        . ,     ,    . </p><br><p>    ,    ,       <code>(a|b)|c</code>  ,  <code>(a|b)|c</code> , , ,       <code>RegExp</code> .  <code>Alt</code>       ,       . </p><br><p> ,  ,    <code>Alt</code>    , <code>Alt Prim</code>       . , <code>Alt Prim</code>       <code>a|a</code>  <code>a</code> .    ,   <code>Alt f</code>       <code>f</code> .        ,   :      .        , ,  ,     . </p><br><h1 id="nekotorye-dosadnye-tonkosti">    </h1><br><p>     ,     .      ,      ,            .        <code>RegExp</code>  ,            ,    ‚Äî . </p><br><p>    ,          Haskell. ,  -  <code>[a]</code>      . ( <em>       ,       -  ,   "" </em> <math> </math><em><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi mathvariant=&quot;normal&quot;>&amp;#x22A5;</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.808ex" height="1.937ex" viewBox="0 -728.2 778.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://habr.com/ru/post/448644/&amp;usg=ALkJrhh4vOR4LnHllbYzJwQ2jOe4vYXzVg#MJMAIN-22A5" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">‚ä•</mi></math></span></span><script type="math/tex" id="MathJax-Element-1">\bot</script></em>  <em>,      - "" . . .</em>  ) </p><br><p>       : <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,              ( <em>,    ,       ,      . . .</em> ).  ,  Haskell     .   ,    <code>Alt</code>   <code>many</code> .  , <code>a*</code>   <code>a|aa|aaa|aaaa|aaaaa|aaaaaa|...</code> ,             .     -    <code>many (char 'a')</code> ,    . Haskell       <code>Alt</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ,      . </p><br><p>  ,    ,   ,      ,           (),         .        ,     <code>many</code>    . </p><br><p> ,   !    ""   <code>Alt</code> ,    <code>Control.Alternative.Free.Final</code> ,     <code>many</code> (,    ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ). </p><br><p>           ,    ,  <code>runAlt</code> . ,        <code>Alternative</code> ,     <code>many</code> (  <code>RE</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">regex-applicative</a> )       .      ,  Haskell      , ,   , <code>many</code>       . </p><br><p>    ,   .          (       ),          ( <em>,        , . .</em> ).    <code>matchPrefix</code> ,        ,   ,        .  ,   ,    ,      ,       .      ,   GHC        . </p><br><h1 id="poslednie-shtrihi">   </h1><br><p>         ,       ,   <code>tails</code> (   )  <code>mapMaybe</code> (           ).    ,     ,    <code>listToMaybe</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">matches</span></span> :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [a] matches re = mapMaybe (matchPrefix re) . tails firstMatch :: <span class="hljs-type"><span class="hljs-type">RegExp</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a firstMatch re = listToMaybe . matches re</code> </pre> <br><p>    ,   ,   <code>matchPrefix</code>   <code>Nothing</code>      ,  <code>listToMaybe</code>      ,   <code>Nothing</code> ( <em>      ,      . . .</em> ). </p><br><p> ,        .    ,       ,     ‚Äî  ,    .       ,         .    ,     ,    ,      . </p><br><p>        <code>Alt Prim</code>         ,    :   ,  ,  ,    . </p><br><p>       ?        .      : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Prim</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Only</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> a </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    | Letter a --     | Digit (Int -&gt; a) --    , | Wildcard (Char -&gt; a) --    , | Satisfy (Char -&gt; Maybe a) --    , --  </span></span></span></span></code> </pre> <br><p>       ,      .      . </p><br><p>      ,   ,   .      <code>runAlt</code>      <code>Alt</code> . </p><br><p>                (). ,    ,        ,    ,    .       <code>|</code>      . ( <em>         ,        . . .</em> ).     ,  -     .  ,   <code>MonadPlus</code>     -   ,        ,     .     ,      . </p><br><p> ,   ,         .  ,   ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448644/">https://habr.com/ru/post/448644/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448634/index.html">Lecciones ucranianas</a></li>
<li><a href="../448636/index.html">Hackaday Retro Computer Case</a></li>
<li><a href="../448638/index.html">Buildroot - Parte 1. Informaci√≥n general, construcci√≥n de un sistema m√≠nimo, configuraci√≥n a trav√©s del men√∫</a></li>
<li><a href="../448640/index.html">SSD GIGABYTE Aorus RGB M.2: peque√±o, incluso remoto para LED RGB (2 partes)</a></li>
<li><a href="../448642/index.html">Modelo obligatorio de distribuci√≥n de derechos en FreeBSD</a></li>
<li><a href="../448648/index.html">C√≥mo sentar a todos en la ciencia y no convertir la oficina en un hervidero de odio</a></li>
<li><a href="../448652/index.html">Mozilla WebThings en Raspberry Pi: c√≥mo empezar</a></li>
<li><a href="../448654/index.html">Mozilla WebThings - Configuraci√≥n de la puerta de enlace</a></li>
<li><a href="../448656/index.html">Gran hermano est√° mirando ... a s√≠ mismo o un mapa con la historia de los movimientos en HomeAssistant</a></li>
<li><a href="../448658/index.html">¬øQu√© se puede hacer a trav√©s del conector OBD en el autom√≥vil?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>