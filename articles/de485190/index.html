<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧚🏼 👨🏾‍🚒 🏂🏽 Andrew Eun "Leidenschaft für maschinelles Lernen." Übersetzung der Kapitel 47-58 🍿 🐸 🕵🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist der zweite Artikel mit einer Übersetzung einzelner Kapitel von Andrew Un's Buch Passion for Machine Learning. Sie können die Übersetzung der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Andrew Eun "Leidenschaft für maschinelles Lernen." Übersetzung der Kapitel 47-58</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485190/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/87/qr/4t87qrmbsuxfltahjbm9iunonx4.png"></div><br><br>  Dies ist der zweite Artikel mit einer Übersetzung einzelner Kapitel von Andrew Un's Buch Passion for Machine Learning.  Sie können die Übersetzung der vorherigen Kapitel <a href="https://habr.com/ru/post/485070/">hier</a> lesen. <br><br>  Dieser Artikel wird sich auf das durchgängige vertiefte Lernen konzentrieren, und der Autor des Buches wird einige Methoden zur Analyse der Fehler des Lernalgorithmus vorstellen. <br><a name="habracut"></a><br><h1>  End-to-End-Deep-Learning </h1><br><hr><h3>  <font color="#548dd4">Kapitel 47. Das Wachstum des End-to-End-Lernens</font> </h3><hr><br>  Angenommen, Sie möchten ein System zum Überprüfen von Produktbewertungen im Internet erstellen, mit dem Sie automatisch wissen, ob der Verfasser der Bewertung dieses Produkt gefällt oder nicht.  Sie hoffen beispielsweise, die folgende Bewertung als sehr positiv zu bewerten: <br><br><ul><li>  "Das ist ein toller Mopp!" </li></ul><br>  und das folgende ist extrem negativ: <br><br><ul><li>  "Dieser Mopp ist von schlechter Qualität, sorry für den Kauf" </li></ul><br>  Das Problem des Erkennens positiver und negativer Meinungen wird als „Klassifizierung von Stimmungen“ bezeichnet.  Um dieses System zu erstellen, können Sie eine "Pipeline" aus zwei Komponenten erstellen: <br><br><ol><li>  <b>Parser</b> : <b>Ein</b> System, das Text mit Informationen beschriftet und die wichtigsten Wörter identifiziert.  <sup>1 Mit</sup> dem Parser können Sie beispielsweise alle Adjektive und Substantive bezeichnen.  Sie erhalten daher folgenden kommentierten Text: <br><br><ul><li>  Das ist ein toller Mopp! </li></ul><br><blockquote>  <sup>1</sup> Tatsächlich kommentiert der Parser den Text viel umfangreicher als beschrieben, aber diese vereinfachte Beschreibung wird ausreichen, um das durchgängige tiefe Lernen zu erklären. </blockquote><br></li><li>  <b>Sentiment Classifier</b> : Ein Lernalgorithmus, der die Eingabe von kommentiertem Text übernimmt und dessen allgemeine Stimmung vorhersagt.  Parser-Annotationen können für diesen Algorithmus eine große Hilfe sein: Indem Sie Adjektiven mehr Gewicht beimessen, können Sie schnell an Ihren Algorithmus denken, indem Sie wichtige Wörter wie "ausgezeichnet" verarbeiten und weniger wichtige Wörter wie "dies" ignorieren. </li></ol><br>  Wir können diese Pipeline aus zwei Komponenten wie folgt darstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/3f/wy/zt3fwy4_ibclomuquousi_mxe4m.png"></div><br><br>  In letzter Zeit hat es eine Tendenz gegeben, Pipelines durch einen einzigen Lernalgorithmus zu ersetzen.  Ein End-to-End-Lernalgorithmus für diese Aufgabe würde einfach den rohen Originaltext "Dies ist ein großartiger Mopp!" Als Eingabe verwenden und versuchen, seine Stimmung direkt zu erkennen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5l/eo/qv/5leoqvedvmnp8dr7fab15gz3n_e.png"></div><br><br>  Neuronale Netze werden üblicherweise in End-to-End-Lernsystemen verwendet.  Der Begriff „Pass-Through“ bezieht sich auf die Tatsache, dass wir den Lernalgorithmus auffordern, direkt von der Eingabe zum gewünschten Ergebnis zu gelangen.  Das heißt, der Lernalgorithmus verbindet das "Eingabeende" des Systems direkt mit dem "Ausgabeende". <br><br>  Bei Aufgaben mit vielen Daten waren End-to-End-Systeme äußerst erfolgreich.  Aber sie sind nicht immer eine gute Wahl.  In den nächsten Kapiteln finden Sie weitere Beispiele für Querschnittsysteme sowie Tipps, wann und wann Sie diese nicht verwenden sollten. <br><br><hr><h3>  <font color="#548dd4">Kapitel 48. Weitere Beispiele für bereichsübergreifendes Lernen</font> </h3><hr><br>  Stellen Sie sich vor, Sie möchten ein Spracherkennungssystem erstellen.  Sie können ein System aus drei Komponenten erstellen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Komponenten arbeiten wie folgt: <br><br><ol><li>  Computerfunktionen: Rufen Sie manuell erstellte Features wie MFCC ( <a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">Mel-Frequenz-Cepstrum-Koeffizienten</a> ) auf, die versuchen, den Inhalt einer Anweisung zu erfassen, während weniger wichtige Eigenschaften wie die Tonhöhe in der Dynamik ignoriert werden. </li><li>  Phonemerkennung: Einige Linguisten glauben, dass es grundlegende Toneinheiten gibt, die als "Phoneme" bezeichnet werden.  Zum Beispiel ist der Anfangston "k" in "keep" dasselbe Phonem wie der Ton "c" in "cake".  Dieses System versucht, einzelne Phoneme in Audioaufnahmen zu erkennen. </li><li>  End Recognizer: Nimmt eine Folge von erkannten Phonemen und versucht, sie zu einem Ausgabedatensatz zusammenzufügen. </li></ol><br>  Im Gegensatz zu dieser „Pipeline“ kann das End-to-End-System am Eingang eine Audioaufnahme empfangen und versucht, diese direkt auf die Ausgangsaufnahme zu übertragen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Bisher haben wir nur vollständig lineare „Förderer“ des maschinellen Lernens beschrieben: Die Ausgabe wird sequentiell von einer Stufe zur anderen übertragen.  Förderer können jedoch komplexer sein.  Zum Beispiel ist hier eine einfache Architektur für ein unbemanntes Fahrzeug: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Dieser Förderer besteht aus drei Komponenten: Eine erkennt andere Autos anhand des Kamerabilds, die zweite erkennt Fußgänger und schließlich berechnet die letzte Komponente den Weg unseres Autos, um Kollisionen mit anderen Autos und Fußgängern zu vermeiden. <br><br>  Nicht jede Komponente in dieser Pipeline wird geschult.  Zum Beispiel beschreibt die Literatur über "Planung der Bewegung von Robotern" viele Algorithmen für die endgültige Berechnung der Fahrbahn eines Autos.  Viele dieser Algorithmen erfordern kein Training. <br><br>  Im Gegenteil, bei der End-to-End-Methode wird möglicherweise versucht, Sensorwerte zu empfangen und das Lenkrad direkt in die richtige Richtung zu drehen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Obwohl durchgängiges Training zu vielen Erfolgen geführt hat, ist dies nicht immer der beste Ansatz.  Beispielsweise funktioniert die Ende-zu-Ende-Spracherkennung gut.  Ich bin jedoch skeptisch gegenüber dem Querschnittstraining des autonomen Fahrens für unbemannte Systeme.  In den nächsten Kapiteln wird erklärt, warum. <br><br><hr><h3>  <font color="#548dd4">Kapitel 49. Querschnittstraining: Vor- und Nachteile</font> </h3><hr><br>  Betrachten Sie das vorherige Beispiel der Spracherkennungs-Pipeline: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/ja/3g/txja3gpoqs8svx3z_roiwe6800g.png"></div><br><br>  Viele seiner Teile sind "manuell" entworfen: <br><br><ul><li>  MFCC ist eine Reihe von speziell entwickelten Audiofunktionen.  Und obwohl sie eine vernünftige Zusammenfassung aller am Eingang empfangenen Audiodaten liefern, vereinfachen sie das eingehende Signal auch, indem sie einige Informationen verwerfen. </li><li>  Phoneme sind eine Erfindung von Linguisten.  Sie sind eine unvollständige Darstellung der Sprachlaute.  Da Phoneme eine schlechte Annäherung an die Realität darstellen, wird ein Algorithmus, der Phoneme zur Darstellung von Sprache verwendet, die Wirksamkeit des gesamten Spracherkennungssystems einschränken. </li></ul><br><ul><li>  Anzeichen von MFCC sind gegenüber bestimmten Spracheigenschaften, die den Inhalt nicht beeinflussen, wie z. B. der Tonhöhe des Sprechers, robust.  Auf diese Weise vereinfachen sie die Aufgabe für den Lernalgorithmus. </li><li>  In dem Maße, in dem Phoneme eine vernünftige Repräsentation von Sprache darstellen, können sie dem Lernalgorithmus auch dabei helfen, die grundlegenden Klangkomponenten zu verstehen und somit seine Wirksamkeit zu erhöhen. </li></ul><br>  Mit mehr handgefertigten Komponenten kann ein Spracherkennungssystem am häufigsten aus weniger Daten lernen.  Das mit MFCC und Phonemen „manuell“ erlangte Wissen „ergänzt“ das Wissen, das unser Algorithmus aus den Daten gewinnt.  Wenn wir wenig Daten haben, ist dieses Wissen nützlich. <br><br>  Betrachten Sie nun das End-to-End-System: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/eh/kp/xpehkpiky2bfr3fhrxsfvveefpc.png"></div><br><br>  Dieses System verfügt nicht über genügend Kenntnisse, die "manuell" erworben wurden.  Wenn der Trainingssatz klein ist, funktioniert dieses System möglicherweise schlechter als ein manuell konstruierter Förderer. <br><br>  Wenn der Trainingssatz jedoch groß ist, gibt es keine Einschränkungen aufgrund der Verwendung von MFCC oder Phonemen.  Wenn der Lernalgorithmus ein ausreichend großes neuronales Netzwerk ist und auf einem ausreichend großen Trainingssatz trainiert wird, hat er ein großes Potenzial und nähert sich möglicherweise sogar der optimalen Fehlerrate. <br><br>  Ende-zu-Ende-Systeme sind in der Regel erfolgreich, wenn für beide Enden viele markierte Daten vorhanden sind - das „Eingabeende“ und das „Ausgabeende“.  In diesem Beispiel benötigen wir eine große Anzahl solcher Paare (Audio und Transkription).  Wenn Ihnen solche Daten nicht zur Verfügung stehen, lernen Sie mit größter Sorgfalt. <br><br>  Wenn Sie an einer maschinellen Lernaufgabe arbeiten, bei der der Trainingssatz sehr klein ist, werden die meisten Informationen, die für Ihren Algorithmus verfügbar sind, dank Ihres menschlichen Verständnisses erhalten, d. H.  aus manuell gestalteten Bauteilen. <br><br>  Wenn Sie kein End-to-End-System verwenden möchten, müssen Sie entscheiden, welche Schritte sich in Ihrer Pipeline befinden und wie sie zusammenpassen sollen.  Im nächsten Kapitel werden wir einige Ideen für den Entwurf solcher Systeme vorstellen. <br><br><hr><h3>  <font color="#548dd4">Kapitel 50. Auswahl der Pipeline-Komponenten: Datenverfügbarkeit</font> </h3><hr><br>  Wenn Sie einen Förderer bauen, der kein End-to-End-System ist, welche Komponenten dieses Förderers sind eine gute Wahl?  Die Art und Weise, wie Sie den Förderer konstruieren, wirkt sich stark auf die Gesamtsystemleistung aus.  Ein wichtiger Faktor ist die einfache Erfassung von Daten für das Training der einzelnen Komponenten. <br><br>  Betrachten Sie zum Beispiel diese autonome Fahrarchitektur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Sie können Algorithmen zum maschinellen Lernen verwenden, um Autos und Fußgänger zu erkennen.  Darüber hinaus ist es für sie nicht schwierig, Daten zu sammeln: Es gibt viele vorgefertigte Computer-Vision-Datensätze mit einer großen Anzahl gekennzeichneter Autos und Fußgänger.  Sie können auch Crowdsourcing (wie Amazon Mechanical Turk) verwenden, um noch größere Datensätze zu erhalten.  Daher ist es relativ einfach, Trainingsdaten zu sammeln, um einen Autodetektor und einen Fußgängerdetektor zu erstellen. <br><br>  Betrachten Sie im Gegenteil ein sauberes End-to-End-System: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/5x/rw/iy5xrwykphbakzznhiqd0la0mzw.png"></div><br><br>  Um dieses System zu trainieren, benötigen wir einen großen Satz bereits zugeordneter Elemente (Bild = Lenkrad in die richtige Richtung drehen).  Dies ist eine sehr zeitaufwendige und teure Aufgabe.  Um solche Daten zu sammeln, ist es notwendig, dass Menschen Autos fahren und Daten über jede Umdrehung des Lenkrads aufzeichnen.  Sie benötigen eine ganze Flotte speziell ausgestatteter Autos und eine Vielzahl von Arbeitsstunden, um die unterschiedlichsten Situationen abzudecken.  Dies macht es sehr schwierig, das End-to-End-System zu erlernen.  Es ist viel einfacher, eine große Anzahl von etikettierten Bildern von Autos und Fußgängern aufzunehmen. <br><br>  Im Allgemeinen sollten Sie über die Verwendung eines Förderers nachdenken, der aus mehreren Komponenten besteht, wenn viele Daten für die Schulung von „Zwischen“ -Fördermodulen (z. B. einem Fahrzeugdetektor oder einem Fußgängerdetektor) verfügbar sind.  Diese Methode könnte besser funktionieren, weil  Sie können alle verfügbaren Daten für das Training von Zwischenmodulen verwenden. <br><br>  Bis es mehr Daten für End-to-End-Modelle gibt, halte ich den traditionellen Ansatz für vielversprechender für autonomes Fahren: Die Architektur entspricht besser der aktuellen Datenverfügbarkeit. <br><br><hr><h3>  <font color="#548dd4">Kapitel 51. Fördererkomponenten auswählen: Einfache Aufgabe</font> </h3><hr><br>  Bei der Auswahl der Pipeline-Komponenten sollten Sie neben der Datenverfügbarkeit auch den zweiten Faktor berücksichtigen: Wie einfach sind die Aufgaben, die einzelne Komponenten lösen?  Sie sollten versuchen, Fördererkomponenten so auszuwählen, dass sie einfach zu bauen oder zu erlernen sind.  Aber was bedeutet es, dass eine Komponente leicht zu erlernen ist? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fc/bg/fy/fcbgfyb4ggr4u6m79xy01h6gtqa.png"></div><br><br>  Betrachten Sie die folgenden maschinellen Lernaufgaben, die in aufsteigender Reihenfolge der Komplexität aufgeführt sind: <br><br><ol><li>  Die Definition überbelichtet das dargestellte Bild (wie im obigen Beispiel). </li><li>  Bestimmen, ob ein Bild in Innenräumen oder im Freien aufgenommen wird. </li><li>  Bestimmen, ob das Bild eine Katze enthält. </li><li>  Feststellen, ob das Bild eine Katze mit schwarz-weißem Fell enthält. </li><li>  Feststellung, ob das Bild eine siamesische Katze enthält (eine bestimmte Katzenrasse). </li></ol><br>  Für jedes dieser Probleme der binären Klassifizierung müssen Sie ein Bild am Ein- und Ausgang 0 oder 1 erhalten. Die zuvor in der Liste aufgeführten Aufgaben scheinen jedoch für neuronale Netze „einfacher“ zu erlernen zu sein.  Sie können den Algorithmus für einfachere Aufgaben mit weniger Trainingsbeispielen trainieren. <br><br>  Zum gegenwärtigen Zeitpunkt des maschinellen Lernens gibt es keine gute formale Definition dafür, was eine einzelne Aufgabe einfach oder schwierig macht.  <sup>2</sup> Mit dem Wachstum von Deep Learning und mehrschichtigen neuronalen Netzen wird das Problem manchmal als einfach bezeichnet, wenn es mit weniger Berechnungsschritten gelöst werden kann (z. B. mit neuronalen Netzen mit einer kleinen Anzahl von Schichten), und wenn es mehr Schritte erfordert, wird die Aufgabe als schwierig bezeichnet Computing (was einem tiefen neuronalen Netzwerk entspricht).  Dies ist jedoch eine informelle Definition. <br><blockquote>  <sup>2</sup> In der algorithmischen Informationstheorie gibt es das Konzept der Kolmogorov-Komplexität, wonach die Komplexität der untersuchten Funktion die Länge des kürzesten Computerprogramms ist, das diese Funktion erzeugen kann.  Dieses theoretische Konzept hat in der KI mehrere praktische Anwendungen gefunden. </blockquote><br>  Wenn Sie die Möglichkeit haben, eine komplexe Aufgabe in einfachere Unteraufgaben aufzuteilen, können Sie durch genaues Codieren jeder Unteraufgabe dem Algorithmus wichtige Kenntnisse vermitteln, mit denen das gesamte Problem effizienter gelöst werden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cm/cm/so/cmcmsoncvrly_eqnmdswoqxyqcc.png"></div><br><br>  Stellen Sie sich vor, Sie entwerfen einen Detektor für siamesische Katzen.  Hier ist eine saubere End-to-End-Architektur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3g/ex/em/3gexemhnlou8qon3qwpprhtcidm.png"></div><br><br>  Im Gegenteil, Sie können einen Förderer aus zwei Komponenten verwenden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  Im ersten Schritt (Katzendetektor) werden alle Katzen im Bild erkannt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9q/a4/wu/9qa4wugiqcvqysomntw52alpy8q.png"></div><br><br>  Anschließend werden im zweiten Schritt zugeschnittene Bilder jeder der nachgewiesenen Katzen einzeln an den Rassenklassifikator übertragen.  Und schließlich, wenn eine der erkannten Katzen eine siamesische Katze ist, erhalten wir "1" am Ausgang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ns/oj/ii/nsojiirbbbuni7qkmrokqmuksfm.png"></div><br><br>  Verglichen mit dem Unterrichten eines reinen Pass-Through-Klassifikators, der nur 0/1 Tags verwendet, scheint jede der beiden Komponenten in der Pipeline (Cat Detector und Breed Classifier) ​​einfacher zu erlernen zu sein und erfordert deutlich weniger Daten.  <sup>3</sup> <br><blockquote>  <sup>3</sup> Wenn Sie mit den tatsächlich in der Praxis verwendeten Objekterkennungsalgorithmen vertraut sind, werden Sie verstehen, dass diese nicht nur mit Bildbezeichnungen 0/1 trainiert werden.  Stattdessen werden sie unter Verwendung des restriktiven Rahmens trainiert, der als Teil der Trainingsdaten bereitgestellt wird.  Ihre Erörterung würde den Rahmen dieses Kapitels sprengen. </blockquote><br>  Lassen Sie uns als letztes Beispiel noch einmal die Pipeline für die autonome Fahraufgabe in Erinnerung rufen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br>  Mit diesem Förderer teilen Sie dem Algorithmus mit, dass es beim Autofahren drei wichtige Schritte gibt: <br><br><ul><li>  Erkennen Sie andere Autos. </li><li>  Fußgänger erkennen. </li><li>  Planen Sie die Richtung der weiteren Bewegung. </li></ul><br>  Jeder dieser Schritte ist eine einfachere Aufgabe und kann mit weniger Daten trainiert werden als mit einem rein bereichsübergreifenden Ansatz. <br><br>  Versuchen Sie daher bei der Entscheidung, welche Komponenten der Pipeline verwendet werden sollen, eine Pipeline zu erstellen, bei der jede Komponente eine relativ „einfache“ Funktion ist, die nur mit einer kleinen Datenmenge trainiert werden kann. <br><br><hr><h3>  <font color="#548dd4">Kapitel 52. Lernen mit umfassenden Informationen</font> </h3><hr><br>  Der Bildklassifizierungsalgorithmus nimmt ein Eingabebild X auf und erzeugt eine Ganzzahl, die eine Bezeichnung für die Kategorie des Objekts darstellt.  Kann der Algorithmus stattdessen einen ganzen Satz ausgeben, der das Bild beschreibt? <br><br>  Zum Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/12/z6/-v/12z6-votwnq7mu2j9rwukqce52k.png"></div><br><br>  Y = "Ein gelber Bus fährt zwischen Bäumen und grünem Gras die Straße hinunter." <br><br>  Die traditionelle Anwendung des Unterrichts mit einem Lehrer beinhaltet das Vorhandensein einer trainierten Funktion h: X → Y, wobei die Ausgabe (y) normalerweise durch eine ganze Zahl oder eine natürliche Zahl dargestellt wird.  Zum Beispiel: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Herausforderung </th><th>  X </th><th>  Y. </th></tr><tr><td>  <b>Antispam</b> </td><td>  E-Mail </td><td>  Spam / kein Spam (0/1) </td></tr><tr><td>  <b>Bilderkennung</b> </td><td>  Bild </td><td>  Ganzzahlige Bezeichnung </td></tr><tr><td>  <b>Immobilienpreisprognose</b> </td><td>  Hausmerkmale </td><td>  Preis in Dollar </td></tr><tr><td>  <b>Produktempfehlung</b> </td><td>  Produkt- und Kundenspezifikationen </td><td>  Kaufwahrscheinlichkeit </td></tr></tbody></table></div><br><br>  Eines der aufregendsten Dinge beim Querschnittstiefenlernen ist, dass es uns ermöglicht, Y direkt zu lernen, was viel komplizierter als Zahlen ist.  In dem oben erwähnten Beispiel mit der Bildbeschreibungsaufgabe können Sie ein Bild (x) auf den Eingang des neuronalen Netzwerks anwenden und am Ausgang eine sofortige Beschreibung (y) erhalten. <br><br>  Hier einige Beispiele: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Herausforderung </th><th>  X </th><th>  Y. </th><th>  Zitat aus der Arbeit </th></tr><tr><td>  <b>Beschreibung der Bilder</b> </td><td>  Bild </td><td>  Text </td><td>  Mao und andere, 2014 </td></tr><tr><td>  <b>Maschinelle Übersetzung</b> </td><td>  Englischer Text </td><td>  Französischer Text </td><td>  Suskever und andere, 2014 </td></tr><tr><td>  <b>Antworten auf Fragen</b> </td><td>  Paar (Text + Frage) </td><td>  Antwort auf die Frage </td><td>  Bordes und andere, 2015 </td></tr><tr><td>  <b>Spracherkennung</b> </td><td>  Audio </td><td>  Transkription </td><td>  Hannun und andere, 2015 </td></tr><tr><td>  <b>Text-to-Speech</b> </td><td>  Text-Tags </td><td>  Audio </td><td>  Van der Oord et al., 2016 </td></tr></tbody></table></div><br><br>  Dies ist ein zunehmender Trend im Deep Learning: Wenn Sie die richtigen (Eingabe-, Ausgabe-) gekennzeichneten Paare haben, können Sie manchmal ein End-to-End-Training wählen, selbst wenn die Ausgabe ein Satz, ein Bild, ein Audio oder eine andere Ausgabe ist, die viel mehr Informationen enthält. als nur einzelne Tag-Nummern. <br><br><h1>  Teilfehleranalyse </h1><hr><h3>  <font color="#548dd4">Kapitel 53. Fehleranalyse in Teilen</font> </h3><hr><br>  Angenommen, Ihr System basiert auf einer ausgeklügelten Pipeline für maschinelles Lernen und Sie möchten die Effizienz des Systems verbessern.  Welchen Teil des Förderers sollten Sie verbessern?  Indem Sie bestimmten Teilen der Pipeline Fehler zuweisen, können Sie entscheiden, wie Sie Ihre Arbeit priorisieren möchten. <br><br>  Verwenden wir unser Siamkatze-Klassifikator-Beispiel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br>  Der erste Teil, ein Katzendetektor, erkennt Katzen und schneidet sie aus dem gesamten Bild aus.  Der zweite Teil, der Klassifikator für Katzenrassen, entscheidet, ob es sich bei dieser Katze um eine siamesische Katze handelt.  Sie können jahrelang daran arbeiten, eine dieser beiden Komponenten des Förderers zu verbessern.  Wie entscheiden Sie, auf welche Komponente Sie sich konzentrieren möchten? <br><br>  Bei der Analyse von Fehlern in Teilen können Sie versuchen, jeden Fehler des Algorithmus einem der beiden Teile der Pipeline (und manchmal beiden gleichzeitig) zuzuordnen.  Beispielsweise klassifiziert der Algorithmus dieses Bild fälschlicherweise so, dass es keine siamesische Katze enthält (y = 0), obwohl die korrekte Bezeichnung y = 1 ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/ju/2g/hjju2gw3fble1fcgc8fblrenkms.png"></div><br><br>  Lassen Sie uns manuell überprüfen, was der Algorithmus in jedem der beiden Schritte tut.  Angenommen, ein Detektor für siamesische Katzen hat eine Katze wie folgt erkannt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oe/0l/rx/oe0lrx5ysvmznqkmbl83m_k_46g.png"></div><br><br>  Dies bedeutet, dass der Klassifikator der Katzenrasse das folgende Bild erhält: <br><br><img src="https://habrastorage.org/webt/ft/wm/vs/ftwmvsdrnvpp2f9vrds36flldzo.png"><br><br>  Der Zuchtklassifikator klassifiziert dieses Bild korrekt als keine siamesische Katze enthaltend.  ,    :             = 0.  , ,    ,     = 0.  ,         . <br><br>   ,       : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/qu/no/ozqunon7ny51kw1ukglsfl3hjj8.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann würden Sie schließen, dass der Katzendetektor seine Arbeit korrekt erledigt hat und der Fehler aufgrund des Zuchtklassifikators aufgetreten ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sie haben 100 falsch klassifizierte Bilder einer Validierungsprobe durchgesehen und festgestellt, dass sich 90 Fehler auf einen Katzendetektor und nur 10 Fehler auf einen Klassifikator für Katzenrassen beziehen. Sie können sicher schließen, dass Sie sich mehr auf die Verbesserung Ihres Katzendetektors konzentrieren sollten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darüber hinaus haben Sie erfolgreich 90 Beispiele gefunden, bei denen der Katzendetektor den falschen Begrenzungsrahmen angezeigt hat. Anhand dieser 90 Beispiele können Sie die </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler von Katzendetektoren genauer analysieren, um herauszufinden, wie Sie sie verbessern können.</font></font><br><br>   ,      ,     :          ,    ,     .      .            . <br><br><hr><h3> <font color="#548dd4"> 54.    </font> </h3><hr><br>    : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k7/uj/oa/k7ujoa1l7cdhtrc809rhrqixfxa.png"></div><br><br> ,        : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bc/_d/8k/bc_d8kmcijt314qterhumctdyyq.png"></div><br><br>  ,  ,     ,      y = 0, ..     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/71/mu/ld/71muldvuqnfx0cd_a6bpo41xzvc.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Katzendetektor hat schlechte Arbeit geleistet. </font><font style="vertical-align: inherit;">Während eine ausgebildete Person zweifellos in der Lage sein wird, die siamesische Katze in diesem beschnittenen Bild zu erkennen. </font><font style="vertical-align: inherit;">Daher führen wir diesen Fehler auf einen Katzendetektor oder einen Zuchtklassifikator oder beides zurück? </font><font style="vertical-align: inherit;">Nicht klar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Anzahl solcher kontroversen Fälle gering ist, können wir eine Entscheidung treffen und ein ähnliches Ergebnis erzielen. </font><font style="vertical-align: inherit;">Hier ist jedoch ein formaler Test, mit dem wir den Fehler genauer einem Teil zuordnen können:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ersetzen Sie den Ausgang des Katzendetektors durch einen manuell markierten Rahmen. </font></font><br><img src="https://habrastorage.org/webt/np/8f/zy/np8fzyx2lfbh1cdbd-o7iiykpvq.png"></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führen Sie das entsprechende zugeschnittene Bild durch den Rassenklassifikator. </font><font style="vertical-align: inherit;">Wenn der Rassenklassifizierer das Bild immer noch nicht richtig klassifiziert, führen Sie den Fehler auf den Rassenklassifizierer zurück. </font><font style="vertical-align: inherit;">Andernfalls führen Sie den Fehler auf den Katzendetektor zurück.</font></font></li></ol><br>    ,          .     2 : <br><br><ol><li>         y = 0.       . </li><li>          y = 1.  ,           ,       .  ,     . </li></ol><br>         ,         .     ,     , , , ,     . <br><br><hr><h3> <font color="#548dd4"> 55.    </font> </h3><hr><br>      . ,      A, B  C,  A    B,  B    C. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ok/tz/0i/oktz0iqvw81g6gbnxdwvehsmo50.png"></div><br><br>   ,      : <br><br><ol><li>      A  “”  (.. “”    )       B, C   .      ,    ,    A    ,        .  ,       A.     2. </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versuchen Sie, den Ausgang von Stufe B manuell durch den „perfekten“ Ausgang zu ersetzen. </font><font style="vertical-align: inherit;">Wenn der gesamte Algorithmus ordnungsgemäß funktioniert, schreiben Sie den Fehler der Komponente B zu. Andernfalls fahren Sie mit Schritt 3 fort.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordnen Sie den Fehler der Komponente C zu. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schauen Sie sich ein komplexeres Beispiel an: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ihre Drohne benutzt diesen Förderer. </font><font style="vertical-align: inherit;">Wie können Sie mithilfe der Stückchenfehleranalyse bestimmen, auf welche Komponente Sie sich konzentrieren möchten? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können die Komponenten wie folgt markieren:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A. Erkennen Sie Autos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> B. Erkennen Sie Fußgänger. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C. Planen Sie den Weg. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehen Sie wie oben beschrieben vor, und testen Sie Ihr Auto auf einem geschlossenen Trainingsgelände. Suchen Sie einen Fall, in dem das Auto ein Manöver in eine schärfere Richtung wählt, als dies ein erfahrener Fahrer tun würde. </font><font style="vertical-align: inherit;">In der Welt des unbemannten Fahrens wird ein solches Ereignis üblicherweise als Drehbuch bezeichnet. </font><font style="vertical-align: inherit;">In diesem Fall:</font></font><br><br><ol><li>      A ( )  «»  (..     ).     B  C   ,    C ( )  «»   A.        ,    ,     A   ,     .        A.     2. </li><li>      B ( )  «» .      ,      B.     3. </li><li>    C. </li></ol><br>             (DAG),  ,             ,            .   ,  <br>     A→B→C   DAG,     . <br><br>      ,      : <br><br><ul><li> A.   (   ) </li><li> B.   (   ) </li><li> C.    </li></ul><br>            ,      . <br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapitel 56. Fehleranalyse in Teilen und Vergleich mit der Effizienz auf menschlicher Ebene</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Durchführen einer Fehleranalyse in einem Lernalgorithmus ähnelt der Verwendung von Data Science zur Analyse von ML-Systemfehlern, um eine Vorstellung davon zu bekommen, was als Nächstes zu tun ist. </font><font style="vertical-align: inherit;">In den meisten Fällen zeigt eine stückweise Fehleranalyse, welche Komponente es wert ist, vor allem verbessert zu werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sie haben einen Datensatz über Kunden, die Dinge auf einer Website kaufen. Ein Datenwissenschaftler kann Daten auf viele verschiedene Arten analysieren. Er kann viele verschiedene Schlussfolgerungen darüber ziehen, ob die Website die Preise erhöhen sollte, über den Wert der Kunden, die durch verschiedene Marketingkampagnen gewonnen wurden und so weiter. Es gibt keinen „richtigen“ Weg, einen Datensatz zu analysieren, es können viele nützliche Ideen entstehen. Ebenso gibt es keinen "richtigen" Weg, um Fehler zu analysieren. In diesen Kapiteln haben Sie einige der gebräuchlichsten Entwurfsmuster kennengelernt, um nützliche Informationen über Ihr ML-System zu erhalten. Sie können jedoch auch frei mit anderen Methoden der Fehleranalyse experimentieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zurück zu der unbemannten Fahrzeuganwendung, in der der Autoerkennungsalgorithmus den Standort (und möglicherweise die Geschwindigkeit) von Autos in der Nähe anzeigt, zeigt der Fußgängererkennungsalgorithmus den Standort der nächsten Fußgänger an, und diese beiden Ausgaben werden schließlich verwendet, um den Weg für das Auto zu planen. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um diese Pipeline zu debuggen und nicht genau nach dem im vorherigen Kapitel beschriebenen Verfahren vorzugehen, können Sie die folgenden Fragen stellen: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie weit ist der Autoerkennungsalgorithmus von der menschlichen Effizienz bei der Lösung eines ähnlichen Problems entfernt? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wie weit ist der Fußgängererkennungsalgorithmus von der menschlichen Leistung entfernt, um ein ähnliches Problem zu lösen? </font></font></li><li>         ?      ,       ,          (      ).  ,    « »    ,        ? </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie feststellen, dass eine der Komponenten des Systems weit von der menschlichen Leistungsfähigkeit entfernt ist, haben Sie eine gute Gelegenheit, sich auf die Verbesserung der Wirksamkeit dieser Komponente zu konzentrieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viele Fehleranalyseprozesse funktionieren besser, wenn wir versuchen, etwas zu automatisieren, das eine Person tun kann. Daher vergleichen wir die Ergebnisse mit den Ergebnissen einer Person. Die meisten unserer vorherigen Beispiele hatten diese implizite Annahme. Wenn Sie ein ML-System erstellen, in dem der endgültige Ausgang oder einige der Zwischenkomponenten Dinge tun, die selbst eine Person nicht gut kann, gelten einige dieser Verfahren nicht.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist ein weiterer Vorteil der Arbeit an Problemen, die von Menschen gelöst werden können. Sie verfügen über leistungsfähigere Tools zur Fehleranalyse und können daher die Arbeit Ihres Teams effizienter priorisieren. </font></font><br><br><hr><h3> <font color="#548dd4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapitel 57. Fehlererkennung in der ML-Pipeline</font></font></font> </h3><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist, wenn jede einzelne Komponente Ihres ML-Förderers auf menschlicher Ebene oder etwas weniger effizient ist, der allgemeine Förderer jedoch nicht der menschlichen Ebene entspricht? </font><font style="vertical-align: inherit;">Normalerweise bedeutet dies, dass der Förderer Mängel aufweist und neu gestaltet werden muss. </font><font style="vertical-align: inherit;">Mithilfe der Fehleranalyse können Sie auch herausfinden, ob Ihre Pipeline neu gestaltet werden muss.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/gf/zq/wdgfzqzrwvhrhebzqvtx1fih-gu.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im vorigen Kapitel haben wir die Frage gestellt: Zeigt jede der drei Komponenten Effizienz auf menschlicher Ebene? </font><font style="vertical-align: inherit;">Angenommen, die Antwort auf alle drei Fragen lautet Ja.</font></font> Dann: <br><br><ol><li> ,  ,   ()           . </li><li> ,  ,   ()           . </li><li> ,   ,     ,    ,      ,                (     ). </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotzdem meistert Ihr unbemanntes Fahrzeug das Fahren deutlich schlechter als eine Person. Das heißt, Menschen, die Zugriff auf Bilder von der Kamera haben, können den Weg des Autos viel besser planen. Welche Schlussfolgerung können Sie ziehen? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einzig mögliche Schlussfolgerung ist, dass Ihre ML-Pipeline nicht richtig ausgelegt ist. In diesem Fall funktioniert die Komponente, die den Fahrzeugpfad plant, genauso gut wie eingehende Daten, die nicht genügend Informationen enthalten. Sie sollten sich fragen, welche anderen Informationen, die nicht in der Ausgabe der beiden vorherigen Komponenten enthalten sind, für eine hervorragende Planung der Fahrzeugbahn erforderlich sind. Mit anderen Worten, welche anderen Informationen werden von einem erfahrenen Fahrer verwendet?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angenommen, Sie verstehen, dass ein menschlicher Fahrer auch Straßenmarkierungen sehen muss. Dies schlägt vor, dass Sie die Pipeline wie folgt zurückentwickeln: </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/qa/wy/msqawygb_nyn4twj9cnbbiqlad0.png"></div><br><blockquote> <sup>4</sup>       ,     ,         .       «Task simplicity»,    51,            ,          .     «  »    —               ,        /  . </blockquote><br>   ,   ,          ,           (,     ,      ,    ),         . <br><br><h1>  Fazit </h1><hr><h3> <font color="#548dd4"> 58.  ,     </font> </h3><hr><br>  Herzlichen Glückwunsch zum Abschluss dieses Buches! <br>  In Kapitel 2 haben wir darüber gesprochen, wie dieses Buch Ihnen helfen kann, ein Superheld in Ihrem Team zu werden. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/8d/ta/ms8dta_asiaioa6tttb3dsl4syo.png"></div><br><br>  Das einzige, was besser sein kann als ein Superheld zu sein, ist, Teil eines Teams von Superhelden zu sein.  Ich hoffe, du teilst Kopien dieses Buches mit deinen Freunden und Teamkollegen und hilfst dabei, andere Superhelden zu erschaffen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485190/">https://habr.com/ru/post/de485190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485178/index.html">Methode zur Rekonstruktion von verlorenen Gebäuden aus Fotografien</a></li>
<li><a href="../de485180/index.html">Benötigen wir einen Datensee? Was tun mit dem Data Warehouse?</a></li>
<li><a href="../de485182/index.html">Sennheiser im Jahr 2020 - aktualisierte Funkkopfhörer zum Jubiläum</a></li>
<li><a href="../de485184/index.html">Umfrageergebnisse mit Registerkarten</a></li>
<li><a href="../de485186/index.html">Billionen-Dollar-Startup oder wie die erfolgreichsten Valley-Unternehmen geboren wurden</a></li>
<li><a href="../de485194/index.html">Segmentbaum: schnell und einfach</a></li>
<li><a href="../de485196/index.html">AvitoTech On Tour: Besuchen Sie Frontend-Meetings in Kasan</a></li>
<li><a href="../de485198/index.html">Eine andere Möglichkeit, die Leistung von .NET-Anwendungsmethoden zu messen</a></li>
<li><a href="../de485200/index.html">Mess am Start: Post-Mortem zur Startgeschwindigkeit einer iOS-Anwendung</a></li>
<li><a href="../de485202/index.html">Unterdrückungssystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>