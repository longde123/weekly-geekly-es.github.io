<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♉️ 🍺 😁 Lo que se congeló en Feature Freeze 2019. Parte I. JSONPath ✏️ 🤶🏼 🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Después del ajuste del comité 2019-03 , se llevó a cabo la congelación de características. Aquí tenemos una columna casi tradicional: ya escribimos so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo que se congeló en Feature Freeze 2019. Parte I. JSONPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448612/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/kw/ra/ylkwraooftas8s1ft0ik4pgn5tc.jpeg"></div><br>  Después del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>ajuste del comité 2019-03</b></a> , se llevó a cabo la congelación de características.  Aquí tenemos una columna casi tradicional: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya escribimos</a> sobre la congelación del año pasado.  Ahora, los resultados de 2019: cuál de los nuevos se incluirá en PostgreSQL 12. En esta parte de la revisión de JSONPath, se utilizan ejemplos y fragmentos del informe "Postgres 12 in Etudes", que Oleg Bartunov leyó en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Saint Highload ++</a> en San Petersburgo el 9 de abril de este año. <br><a name="habracut"></a><br><h2>  Jsonpath </h2><br>  Todo lo relacionado con JSON (B) es relevante, tiene una gran demanda en el mundo, en Rusia, y esta es una de las áreas más importantes de desarrollo en Postgres Professional.  El tipo jsonb, las funciones y los operadores para trabajar con JSON / JSONB aparecieron en PostgreSQL versión 9.4, fueron creados por un equipo dirigido por Oleg Bartunov. <br><br>  El estándar SQL / 2016 permite trabajar con JSON: allí se menciona JSONPath: un conjunto de herramientas de direccionamiento de datos dentro de JSON;  JSONTABLE: medio de convertir JSON en tablas normales;  Una gran familia de funciones y operadores.  A pesar de que JSON en Postgres ha sido compatible durante mucho tiempo, en 2017 Oleg Bartunov y sus colegas comenzaron a trabajar para admitir el estándar.  Cumplir con el estándar siempre es bueno.  De todo lo que se describe en el estándar, solo uno, pero el parche más importante es JSONPath en la versión 12, por lo que hablaremos de ello en primer lugar. <br><br>  En la antigüedad, la gente usaba JSON y lo almacenaba en campos de texto.  En 9.3, apareció un tipo de datos especial para JSON, pero la funcionalidad asociada con él no era rica, y las solicitudes con este tipo funcionaron lentamente debido al tiempo dedicado a analizar la representación de texto de JSON.  Esto detuvo a muchos usuarios potenciales de Postgres que preferían las bases de datos NoSQL.  La productividad de Postgres aumentó en 9.4 cuando, gracias a O. Bartunov, A. Korotkov y F. Sigaev, Postgres introdujo una versión binaria de JSON, el tipo jsonb. <br>  No es necesario analizar jsonb cada vez, por lo que trabajar con él es mucho más rápido.  De las nuevas funciones y operadores que surgieron al mismo tiempo, algunos funcionan solo con un nuevo tipo binario, como el operador importante de ocurrencia <b>@&gt;</b> , que verifica si un elemento o matriz está incluido en un JSONB dado: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, 3]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  da VERDADERO, ya que la matriz del lado derecho ingresa a la matriz de la izquierda.  Pero <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, [1, 3]]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  dará FALSO, ya que el nivel de anidamiento es diferente, debe establecerse explícitamente.  ¿Se introdujo el operador de existencia para el tipo jsonb <b>?</b>  (un signo de interrogación) que comprueba si una cadena es una clave de objeto o un elemento de una matriz en el nivel superior de los valores JSONB, así como dos operadores similares más (detalles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> ).  Son compatibles con los índices GIN con dos clases de operadores GIN.  El operador <b>-&gt;</b> (flecha) le permite "navegar" a través de JSONB, devuelve un valor por clave o, si es una matriz, por índice.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varios</a> operadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">más</a> para mudarse.  Pero no hay forma de organizar filtros que funcionen de manera similar a WHERE.  Fue un gran avance: gracias a jsonb, Postgres comenzó a crecer en popularidad como RDBMS con funciones NoSQL. <br><br>  En 2014, A. Korotkov, O. Bartunov y F. Sigaev desarrollaron la extensión jsquery, que se incluyó como resultado en Postgres Pro Standard 9.5 (y en versiones posteriores de Standard y Enterprise).  Proporciona características adicionales muy amplias para trabajar con json (b).  Esta extensión define el lenguaje de consulta para extraer datos de json (b) e índices para acelerar estas consultas.  Los usuarios requerían esta funcionalidad, no estaban listos para esperar el estándar y la inclusión de nuevas características en la versión estándar.  El valor práctico también se evidencia por el hecho de que el desarrollo fue patrocinado por Wargaming.net.  La extensión implementa un tipo especial: jsquery. <br><br>  Una consulta en este idioma es compacta y se ve, por ejemplo, así: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'{"apt":[{"no": 1, "rooms":2}, {"no": 2, "rooms":3}, {"no": 3, "rooms":2}]}'</span></span>::jsonb @@ <span class="hljs-string"><span class="hljs-string">'apt.#.rooms=3'</span></span>::jsquery;</code> </pre> <br>  Estamos preguntando aquí si hay "tres rublos" en el edificio de apartamentos.  El tipo jsquery debe especificarse porque el operador @@ ahora también está en el tipo jsonb.  La descripción está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> , y la presentación con muchos ejemplos está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  Total: Postgres ya tenía todo para trabajar con JSON, y luego apareció el estándar SQL: 2016.  Resultó que su semántica no es tan diferente de la nuestra en la extensión jsquery.  Es posible que los autores del estándar incluso hayan mirado a jsquery, inventando JSONPath.  Nuestro equipo tuvo que implementar un poco diferente de lo que ya teníamos y, por supuesto, muchas cosas nuevas también. <br><br>  Hace más de un año, en el commitfest de marzo, los frutos de nuestros esfuerzos de programación se ofrecieron a la comunidad en forma de 3 parches grandes con soporte para el estándar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SQL: 2016</a> : <br><br>  SQL / JSON: JSONPath; <br>  SQL / JSON: funciones; <br>  SQL / JSON: JSON_TABLE. <br><br>  Pero desarrollar un parche no es todo el negocio, promocionarlos tampoco es fácil, especialmente si los parches son grandes y afectan a muchos módulos.  Se requieren muchas iteraciones de revisión, revisión, el parche debe promoverse, como lo hacen las empresas comerciales, invirtiendo muchos recursos (horas-hombre).  El arquitecto jefe de Postgres Professional, Alexander Korotkov, asumió la responsabilidad (ya que ahora tiene el estado de un committer) y aseguró la adopción del parche JSONPath, el principal en esta serie de parches.  El segundo y el tercero ahora están en el estado de Revisión de necesidades.  JSONPath enfocado le permite trabajar con la estructura JSON (B) y es lo suficientemente flexible como para resaltar sus fragmentos.  De los 15 puntos prescritos en el estándar, 14 están implementados, y esto es más que en Oracle, MySQL y MS SQL. <br><br>  La notación JSONPath difiere de las declaraciones de Postgres para trabajar con notación JSON y JSQuery.  La jerarquía se indica mediante puntos: <br><br>  $ .abc (en notación postgres 11, tendría que escribir 'a' -&gt; 'b' -&gt; 'c'); <br>  $ - el contexto actual del elemento - de hecho, la expresión con $ define la región json (b) que se va a procesar, incluida la del filtro, el resto no está disponible para trabajar; <br>  @ - el contexto actual en la expresión del filtro - itera sobre las rutas disponibles en la expresión con $; <br>  [*] - una matriz; <br>  * - comodín, en la expresión con $ o @ significa cualquier valor del segmento de ruta, pero teniendo en cuenta la jerarquía; <br>  ** - como parte de la expresión con $ o @ puede significar cualquier valor del segmento de ruta sin tener en cuenta la jerarquía; es conveniente usarlo si no conoce el nivel de anidamiento de elementos; <br>  operador "?"  le permite organizar un filtro similar a DONDE: <br>  $ .abc?  (@ .x&gt; 10); <br>  $ .abcxtype (), así como size (), double (), ceiling (), floor (), abs (), datetime (), keyvalue () son métodos. <br>  Una consulta con la función jsonb_path_query (sobre las funciones a continuación) podría verse así: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; 3)'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [4, 5] (1 row)</span></span></code> </pre> <br>  Aunque no se ha comprometido un parche especial con funciones, el parche JSONPath ya tiene funciones clave para trabajar con JSON (B): <br><br><br><pre> <code class="sql hljs">jsonb_path_exists('{"a": 1}', '$.a')  true (  "?") jsonb_path_exists('{"a": 1}', '$.b')  false jsonb_path_match('{"a": 1}', '$.a == 1')  true (  "@&gt;") jsonb_path_match('{"a": 1}', '$.a &gt;= 2')  false jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3, 4, 5 jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  0  jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  [3, 4, 5] jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  [] jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3 jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  NULL</code> </pre> <br>  Tenga en cuenta que la igualdad en las expresiones JSONPath es un solo "=", mientras que en jsquery es doble: "==". <br><br>  Para ilustraciones más elegantes, generaremos JSONB en una placa de una sola columna: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> house(js jsonb); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'{ "address": { "city":"Moscow", "street": "Ulyanova, 7A" }, "lift": false, "floor": [ { "level": 1, "apt": [ {"no": 1, "area": 40, "rooms": 1}, {"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2} ] }, { "level": 2, "apt": [ {"no": 4, "area": 100, "rooms": 3}, {"no": 5, "area": 60, "rooms": 2} ] } ] }'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/u6/ob/nb/u6obnbokethtz5gatlcbdtvhjyi.png"><br>  <i>Fig. 1 Vivienda del árbol JSON con apartamentos de hoja asignados.</i> <br><br>  Este es un JSON extraño: tiene una jerarquía confusa, pero está tomado de la vida, y en la vida a menudo es necesario trabajar con lo que es y no con lo que debería ser.  Armados con las capacidades de la nueva versión, encontraremos apartamentos en el primer y segundo piso, pero no en el primero de la lista de apartamentos del piso (en el árbol están resaltados en verde): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(js, <span class="hljs-string"><span class="hljs-string">'$.floor[0, 1].apt[1 to last]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; <span class="hljs-comment"><span class="hljs-comment">--------------------- [{"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2}, {"no": 5, "area": 60, "rooms": 2}]</span></span></code> </pre><br>  En PostgreSQL 11, debe preguntar esto: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_agg(apt) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> apt-&gt;generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, jsonb_array_length(apt) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> js-&gt;<span class="hljs-string"><span class="hljs-string">'floor'</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])-&gt;<span class="hljs-string"><span class="hljs-string">'apt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house ) apts(apt) ) apts(apt);</code> </pre> <br>  Ahora una pregunta muy simple: ¿hay líneas que contengan (en cualquier lugar) el valor "Moscú"?  Muy simple: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_exists(js, <span class="hljs-string"><span class="hljs-string">'$.** ? (@ == "Moscow")'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house;</code> </pre> <br>  En la versión 11, tendrías que escribir un gran script: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RECURSIVE</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(kv.value, e.value) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_each ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) kv <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_array_elements ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'array'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) e <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> kv.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> e.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'"Moscow"'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/1k/uv/go/1kuvgo4f2bnjj_aylnvej76gltc.png"><br>  <i>Fig. 2 Árbol de la Vivienda JSON, ¡se encontró Moscú!</i> <br><br>  Estamos buscando cualquier apartamento en cualquier piso con un área de 40 a 90 metros cuadrados: <br><br><pre> <code class="plaintext hljs">select jsonb_path_query(js, '$.floor[*].apt[*] ? (@.area &gt; 40 &amp;&amp; @.area &lt; 90)') FROM house; jsonb_path_query ----------------------------------- {"no": 2, "area": 80, "rooms": 3} {"no": 3, "area": 50, "rooms": 2} {"no": 5, "area": 60, "rooms": 2} (3 rows)</code> </pre><br>  Estamos buscando apartamentos con habitaciones después del 3, utilizando nuestro alojamiento Jason: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 4 5 (2 rows)</span></span></code> </pre> <br>  Y así es como funciona jsonb_path_query_first: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_first(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query_first <span class="hljs-comment"><span class="hljs-comment">------------------------ 4 (1 row)</span></span></code> </pre> <br>  Vemos que solo se selecciona el primer valor que satisface la condición del filtro. <br><br>  El operador booleano JSONPath para JSONB @@ se denomina operador coincidente.  Calcula el predicado JSONPath llamando a la función jsonb_path_match_opr. <br><br>  Otro operador booleano es @?  - esta es una prueba de existencia, responde a la pregunta de si la expresión JSONPath devolverá objetos SQL / JSON, llama a la función jsonb_path_exists_opr: <br><br><pre> <code class="sql hljs"> '[1,2,3]' @@ '$[*] == 3'  true;  '[1,2,3]' @? '$[*] @? (@ == 3)' -  true</code> </pre> <br>  Se puede lograr el mismo resultado utilizando diferentes operadores: <br><br><pre> <code class="sql hljs">js @? '$.a'  js @@ 'exists($.a)' js @@ '$.a == 1'  js @? '$ ? ($.a == 1)'</code> </pre> <br>  La belleza de los operadores booleanos JSONPath es que son compatibles, acelerados por los índices GIN.  jsonb_ops y jsonb_path_ops son las clases de operador correspondientes.  En el ejemplo, deshabilitamos SEQSCAN, ya que tenemos un microtable, en tablas grandes, el optimizador mismo seleccionará el Índice de mapa de bits: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ENABLE_SEQSCAN <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gin (js); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (COSTS <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> js @? <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.rooms == 3)'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on house Recheck Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) -&gt; Bitmap Index Scan on house_js_idx Index Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) (4 rows)</span></span></code> </pre> <br>  Todas las funciones de la forma jsonb_path_xxx () tienen la misma firma: <br><br><pre> <code class="sql hljs">jsonb_path_xxx( js jsonb, jsp jsonpath, vars jsonb DEFAULT '{}', silent boolean DEFAULT false )</code> </pre> <br>  vars es un objeto JSONB para pasar variables JSONPath: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; $x)'</span></span>, vars =&gt; <span class="hljs-string"><span class="hljs-string">'{"x": 2}'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [3, 4, 5]</span></span></code> </pre> <br>  Es difícil prescindir de vars cuando hacemos una unión que involucra un campo de tipo jsonb en una de las tablas.  Digamos que hacemos una aplicación que busca apartamentos adecuados para los empleados en esa misma casa que han escrito sus requisitos para el área mínima en el cuestionario: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> demands(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">position</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">demand</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> demands <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">85</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.area &gt;= $min)'</span></span>, vars =&gt; jsonb_build_object(<span class="hljs-string"><span class="hljs-string">'min'</span></span>, demands.demand)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house, demands <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----+----------------------------------- jsonb_path_query | {"no": 2, "area": 80, "rooms": 3} -[ RECORD 2 ]----+----------------------------------- jsonb_path_query | {"no": 3, "area": 50, "rooms": 2} -[ RECORD 3 ]----+----------------------------------- jsonb_path_query | {"no": 4, "area": 100, "rooms": 3} -[ RECORD 4 ]----+----------------------------------- jsonb_path_query | {"no": 5, "area": 60, "rooms": 2}</span></span></code> </pre> <br>  Lucky Pasha puede elegir entre 4 apartamentos.  Pero vale la pena cambiar 1 letra en la solicitud, de "P" a "C", ¡y no habrá elección!  Solo 1 apartamento servirá. <br><br><br>  Queda una palabra clave más: el silencio es una bandera que suprime el manejo de errores; están en la conciencia del programador. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>); ERROR: SQL/JSON member not found DETAIL: jsonpath member accessor can only be applied to an object</code> </pre> <br>  El error  Pero esto no será un error: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>, silent =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ (0 rows)</span></span></code> </pre> <br>  Por cierto, acerca de los errores: de acuerdo con el estándar, los errores aritméticos en las expresiones no dan mensajes de error, están en la conciencia del programador: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[1,0,2]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (1/ @ &gt;= 1)'</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 1 (1 row)</span></span></code> </pre> <br>  Al calcular la expresión en el filtro, se buscan los valores de la matriz, entre los cuales hay 0, pero dividir por 0 no genera un error. <br><br>  Las funciones funcionarán de manera diferente según el modo seleccionado: estricto o laxo (en la traducción "no estricto" o incluso "suelto", se selecciona de forma predeterminada).  Supongamos que estamos buscando una clave en modo Lax en JSON, donde obviamente no es: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- f (1 row)</span></span></code> </pre> <br>  Ahora en modo estricto: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- (null) (1 row)</span></span></code> </pre> <br>  Es decir, donde en modo liberal recibimos FALSO, con estricto obtuvimos NULL. <br><br>  En el modo Lax, una matriz con una jerarquía compleja [1,2, [3,4,5]] siempre se expande a [1,2,3,4,5]: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $[*] ? (@ == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  En modo estricto, el número "5" no se encontrará, ya que no se encuentra en la parte inferior de la jerarquía.  Para encontrarlo, debe modificar la consulta, reemplazando "@" con "@ [*]": <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $[*] ? (@[*] == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  En PostgreSQL 12, JSONPath es un tipo de datos.  El estándar no dice nada sobre la necesidad de un nuevo tipo, es una propiedad de implementación.  Con el nuevo tipo, obtenemos trabajo completo con jsonpath con la ayuda de operadores e índices que aceleran su trabajo, que ya existe para JSONB.  De lo contrario, JSONPath tendría que integrarse a nivel del código de ejecutor y optimizador. <br><br>  Puede leer sobre la sintaxis de SQL / JSON, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  La publicación de blog de Oleg Bartunov trata sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conformidad SQL / JSON estándar-2016</a> para PostgreSQL, Oracle, SQL Server y MySQL. <br><br>  Aquí hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentación</a> sobre SQL / JSON. <br><br>  Y aquí hay una <a href="">introducción</a> a SQL / JSON. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448612/">https://habr.com/ru/post/448612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448602/index.html">¿El monitoreo está muerto? - Larga vida al monitoreo</a></li>
<li><a href="../448604/index.html">Gameboy en C #</a></li>
<li><a href="../448606/index.html">Sidorin: KnowledgeConf trata sobre cómo mantener el conocimiento con una duración promedio de trabajo en un lugar en 2-3 años</a></li>
<li><a href="../448608/index.html">¿Cómo dar los primeros pasos en robótica?</a></li>
<li><a href="../448610/index.html">Bricolaje: cómo hicimos un calendario en vivo para Codefest X</a></li>
<li><a href="../448618/index.html">Algoritmo Douglas-Pecker</a></li>
<li><a href="../448622/index.html">PHP GR8: JIT mejorará el rendimiento de PHP 8</a></li>
<li><a href="../448624/index.html">Ver los datos? No Entonces no lo veo, pero lo son. Destruimos datos en unidades SSD e incluso restauramos la velocidad</a></li>
<li><a href="../448626/index.html">DDoS para ayudar: cómo realizamos pruebas de estrés y estrés</a></li>
<li><a href="../448628/index.html">Estética técnica y tecnología soviéticas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>