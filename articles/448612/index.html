<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>鮫괦잺 游꽄 游때 Lo que se congel칩 en Feature Freeze 2019. Parte I. JSONPath 九勇 游뱠游낖 游낆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despu칠s del ajuste del comit칠 2019-03 , se llev칩 a cabo la congelaci칩n de caracter칤sticas. Aqu칤 tenemos una columna casi tradicional: ya escribimos so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lo que se congel칩 en Feature Freeze 2019. Parte I. JSONPath</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/448612/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/kw/ra/ylkwraooftas8s1ft0ik4pgn5tc.jpeg"></div><br>  Despu칠s del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><b>ajuste del comit칠 2019-03</b></a> , se llev칩 a cabo la congelaci칩n de caracter칤sticas.  Aqu칤 tenemos una columna casi tradicional: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya escribimos</a> sobre la congelaci칩n del a침o pasado.  Ahora, los resultados de 2019: cu치l de los nuevos se incluir치 en PostgreSQL 12. En esta parte de la revisi칩n de JSONPath, se utilizan ejemplos y fragmentos del informe "Postgres 12 in Etudes", que Oleg Bartunov ley칩 en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Saint Highload ++</a> en San Petersburgo el 9 de abril de este a침o. <br><a name="habracut"></a><br><h2>  Jsonpath </h2><br>  Todo lo relacionado con JSON (B) es relevante, tiene una gran demanda en el mundo, en Rusia, y esta es una de las 치reas m치s importantes de desarrollo en Postgres Professional.  El tipo jsonb, las funciones y los operadores para trabajar con JSON / JSONB aparecieron en PostgreSQL versi칩n 9.4, fueron creados por un equipo dirigido por Oleg Bartunov. <br><br>  El est치ndar SQL / 2016 permite trabajar con JSON: all칤 se menciona JSONPath: un conjunto de herramientas de direccionamiento de datos dentro de JSON;  JSONTABLE: medio de convertir JSON en tablas normales;  Una gran familia de funciones y operadores.  A pesar de que JSON en Postgres ha sido compatible durante mucho tiempo, en 2017 Oleg Bartunov y sus colegas comenzaron a trabajar para admitir el est치ndar.  Cumplir con el est치ndar siempre es bueno.  De todo lo que se describe en el est치ndar, solo uno, pero el parche m치s importante es JSONPath en la versi칩n 12, por lo que hablaremos de ello en primer lugar. <br><br>  En la antig칲edad, la gente usaba JSON y lo almacenaba en campos de texto.  En 9.3, apareci칩 un tipo de datos especial para JSON, pero la funcionalidad asociada con 칠l no era rica, y las solicitudes con este tipo funcionaron lentamente debido al tiempo dedicado a analizar la representaci칩n de texto de JSON.  Esto detuvo a muchos usuarios potenciales de Postgres que prefer칤an las bases de datos NoSQL.  La productividad de Postgres aument칩 en 9.4 cuando, gracias a O. Bartunov, A. Korotkov y F. Sigaev, Postgres introdujo una versi칩n binaria de JSON, el tipo jsonb. <br>  No es necesario analizar jsonb cada vez, por lo que trabajar con 칠l es mucho m치s r치pido.  De las nuevas funciones y operadores que surgieron al mismo tiempo, algunos funcionan solo con un nuevo tipo binario, como el operador importante de ocurrencia <b>@&gt;</b> , que verifica si un elemento o matriz est치 incluido en un JSONB dado: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, 3]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  da VERDADERO, ya que la matriz del lado derecho ingresa a la matriz de la izquierda.  Pero <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'[1, 2, [1, 3]]'</span></span>::jsonb @&gt; <span class="hljs-string"><span class="hljs-string">'[1, 3]'</span></span>::jsonb;</code> </pre> <br>  dar치 FALSO, ya que el nivel de anidamiento es diferente, debe establecerse expl칤citamente.  쯉e introdujo el operador de existencia para el tipo jsonb <b>?</b>  (un signo de interrogaci칩n) que comprueba si una cadena es una clave de objeto o un elemento de una matriz en el nivel superior de los valores JSONB, as칤 como dos operadores similares m치s (detalles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> ).  Son compatibles con los 칤ndices GIN con dos clases de operadores GIN.  El operador <b>-&gt;</b> (flecha) le permite "navegar" a trav칠s de JSONB, devuelve un valor por clave o, si es una matriz, por 칤ndice.  Hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varios</a> operadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m치s</a> para mudarse.  Pero no hay forma de organizar filtros que funcionen de manera similar a WHERE.  Fue un gran avance: gracias a jsonb, Postgres comenz칩 a crecer en popularidad como RDBMS con funciones NoSQL. <br><br>  En 2014, A. Korotkov, O. Bartunov y F. Sigaev desarrollaron la extensi칩n jsquery, que se incluy칩 como resultado en Postgres Pro Standard 9.5 (y en versiones posteriores de Standard y Enterprise).  Proporciona caracter칤sticas adicionales muy amplias para trabajar con json (b).  Esta extensi칩n define el lenguaje de consulta para extraer datos de json (b) e 칤ndices para acelerar estas consultas.  Los usuarios requer칤an esta funcionalidad, no estaban listos para esperar el est치ndar y la inclusi칩n de nuevas caracter칤sticas en la versi칩n est치ndar.  El valor pr치ctico tambi칠n se evidencia por el hecho de que el desarrollo fue patrocinado por Wargaming.net.  La extensi칩n implementa un tipo especial: jsquery. <br><br>  Una consulta en este idioma es compacta y se ve, por ejemplo, as칤: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'{"apt":[{"no": 1, "rooms":2}, {"no": 2, "rooms":3}, {"no": 3, "rooms":2}]}'</span></span>::jsonb @@ <span class="hljs-string"><span class="hljs-string">'apt.#.rooms=3'</span></span>::jsquery;</code> </pre> <br>  Estamos preguntando aqu칤 si hay "tres rublos" en el edificio de apartamentos.  El tipo jsquery debe especificarse porque el operador @@ ahora tambi칠n est치 en el tipo jsonb.  La descripci칩n est치 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> , y la presentaci칩n con muchos ejemplos est치 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . <br><br>  Total: Postgres ya ten칤a todo para trabajar con JSON, y luego apareci칩 el est치ndar SQL: 2016.  Result칩 que su sem치ntica no es tan diferente de la nuestra en la extensi칩n jsquery.  Es posible que los autores del est치ndar incluso hayan mirado a jsquery, inventando JSONPath.  Nuestro equipo tuvo que implementar un poco diferente de lo que ya ten칤amos y, por supuesto, muchas cosas nuevas tambi칠n. <br><br>  Hace m치s de un a침o, en el commitfest de marzo, los frutos de nuestros esfuerzos de programaci칩n se ofrecieron a la comunidad en forma de 3 parches grandes con soporte para el est치ndar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SQL: 2016</a> : <br><br>  SQL / JSON: JSONPath; <br>  SQL / JSON: funciones; <br>  SQL / JSON: JSON_TABLE. <br><br>  Pero desarrollar un parche no es todo el negocio, promocionarlos tampoco es f치cil, especialmente si los parches son grandes y afectan a muchos m칩dulos.  Se requieren muchas iteraciones de revisi칩n, revisi칩n, el parche debe promoverse, como lo hacen las empresas comerciales, invirtiendo muchos recursos (horas-hombre).  El arquitecto jefe de Postgres Professional, Alexander Korotkov, asumi칩 la responsabilidad (ya que ahora tiene el estado de un committer) y asegur칩 la adopci칩n del parche JSONPath, el principal en esta serie de parches.  El segundo y el tercero ahora est치n en el estado de Revisi칩n de necesidades.  JSONPath enfocado le permite trabajar con la estructura JSON (B) y es lo suficientemente flexible como para resaltar sus fragmentos.  De los 15 puntos prescritos en el est치ndar, 14 est치n implementados, y esto es m치s que en Oracle, MySQL y MS SQL. <br><br>  La notaci칩n JSONPath difiere de las declaraciones de Postgres para trabajar con notaci칩n JSON y JSQuery.  La jerarqu칤a se indica mediante puntos: <br><br>  $ .abc (en notaci칩n postgres 11, tendr칤a que escribir 'a' -&gt; 'b' -&gt; 'c'); <br>  $ - el contexto actual del elemento - de hecho, la expresi칩n con $ define la regi칩n json (b) que se va a procesar, incluida la del filtro, el resto no est치 disponible para trabajar; <br>  @ - el contexto actual en la expresi칩n del filtro - itera sobre las rutas disponibles en la expresi칩n con $; <br>  [*] - una matriz; <br>  * - comod칤n, en la expresi칩n con $ o @ significa cualquier valor del segmento de ruta, pero teniendo en cuenta la jerarqu칤a; <br>  ** - como parte de la expresi칩n con $ o @ puede significar cualquier valor del segmento de ruta sin tener en cuenta la jerarqu칤a; es conveniente usarlo si no conoce el nivel de anidamiento de elementos; <br>  operador "?"  le permite organizar un filtro similar a DONDE: <br>  $ .abc?  (@ .x&gt; 10); <br>  $ .abcxtype (), as칤 como size (), double (), ceiling (), floor (), abs (), datetime (), keyvalue () son m칠todos. <br>  Una consulta con la funci칩n jsonb_path_query (sobre las funciones a continuaci칩n) podr칤a verse as칤: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; 3)'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [4, 5] (1 row)</span></span></code> </pre> <br>  Aunque no se ha comprometido un parche especial con funciones, el parche JSONPath ya tiene funciones clave para trabajar con JSON (B): <br><br><br><pre> <code class="sql hljs">jsonb_path_exists('{"a": 1}', '$.a')  true (  "?") jsonb_path_exists('{"a": 1}', '$.b')  false jsonb_path_match('{"a": 1}', '$.a == 1')  true (  "@&gt;") jsonb_path_match('{"a": 1}', '$.a &gt;= 2')  false jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3, 4, 5 jsonb_path_query('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  0  jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  [3, 4, 5] jsonb_path_query_array('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  [] jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 2)')  3 jsonb_path_query_first('{"a": [1,2,3,4,5]}', '$.a[*] ? (@ &gt; 5)')  NULL</code> </pre> <br>  Tenga en cuenta que la igualdad en las expresiones JSONPath es un solo "=", mientras que en jsquery es doble: "==". <br><br>  Para ilustraciones m치s elegantes, generaremos JSONB en una placa de una sola columna: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> house(js jsonb); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'{ "address": { "city":"Moscow", "street": "Ulyanova, 7A" }, "lift": false, "floor": [ { "level": 1, "apt": [ {"no": 1, "area": 40, "rooms": 1}, {"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2} ] }, { "level": 2, "apt": [ {"no": 4, "area": 100, "rooms": 3}, {"no": 5, "area": 60, "rooms": 2} ] } ] }'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/u6/ob/nb/u6obnbokethtz5gatlcbdtvhjyi.png"><br>  <i>Fig. 1 Vivienda del 치rbol JSON con apartamentos de hoja asignados.</i> <br><br>  Este es un JSON extra침o: tiene una jerarqu칤a confusa, pero est치 tomado de la vida, y en la vida a menudo es necesario trabajar con lo que es y no con lo que deber칤a ser.  Armados con las capacidades de la nueva versi칩n, encontraremos apartamentos en el primer y segundo piso, pero no en el primero de la lista de apartamentos del piso (en el 치rbol est치n resaltados en verde): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(js, <span class="hljs-string"><span class="hljs-string">'$.floor[0, 1].apt[1 to last]'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; <span class="hljs-comment"><span class="hljs-comment">--------------------- [{"no": 2, "area": 80, "rooms": 3}, {"no": 3, "area": 50, "rooms": 2}, {"no": 5, "area": 60, "rooms": 2}]</span></span></code> </pre><br>  En PostgreSQL 11, debe preguntar esto: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_agg(apt) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> apt-&gt;generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>, jsonb_array_length(apt) - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> js-&gt;<span class="hljs-string"><span class="hljs-string">'floor'</span></span>-&gt;<span class="hljs-keyword"><span class="hljs-keyword">unnest</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])-&gt;<span class="hljs-string"><span class="hljs-string">'apt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house ) apts(apt) ) apts(apt);</code> </pre> <br>  Ahora una pregunta muy simple: 쯛ay l칤neas que contengan (en cualquier lugar) el valor "Mosc칰"?  Muy simple: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_exists(js, <span class="hljs-string"><span class="hljs-string">'$.** ? (@ == "Moscow")'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house;</code> </pre> <br>  En la versi칩n 11, tendr칤as que escribir un gran script: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RECURSIVE</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(kv.value, e.value) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_each ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'object'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) kv <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> LATERAL jsonb_array_elements ( <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> jsonb_typeof(t.value) = <span class="hljs-string"><span class="hljs-string">'array'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> t.value <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> ) e <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> kv.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> e.value <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">'"Moscow"'</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/1k/uv/go/1kuvgo4f2bnjj_aylnvej76gltc.png"><br>  <i>Fig. 2 츼rbol de la Vivienda JSON, 춰se encontr칩 Mosc칰!</i> <br><br>  Estamos buscando cualquier apartamento en cualquier piso con un 치rea de 40 a 90 metros cuadrados: <br><br><pre> <code class="plaintext hljs">select jsonb_path_query(js, '$.floor[*].apt[*] ? (@.area &gt; 40 &amp;&amp; @.area &lt; 90)') FROM house; jsonb_path_query ----------------------------------- {"no": 2, "area": 80, "rooms": 3} {"no": 3, "area": 50, "rooms": 2} {"no": 5, "area": 60, "rooms": 2} (3 rows)</code> </pre><br>  Estamos buscando apartamentos con habitaciones despu칠s del 3, utilizando nuestro alojamiento Jason: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 4 5 (2 rows)</span></span></code> </pre> <br>  Y as칤 es como funciona jsonb_path_query_first: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_first(js, <span class="hljs-string"><span class="hljs-string">'$.floor.apt.no ? (@&gt;3)'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house; jsonb_path_query_first <span class="hljs-comment"><span class="hljs-comment">------------------------ 4 (1 row)</span></span></code> </pre> <br>  Vemos que solo se selecciona el primer valor que satisface la condici칩n del filtro. <br><br>  El operador booleano JSONPath para JSONB @@ se denomina operador coincidente.  Calcula el predicado JSONPath llamando a la funci칩n jsonb_path_match_opr. <br><br>  Otro operador booleano es @?  - esta es una prueba de existencia, responde a la pregunta de si la expresi칩n JSONPath devolver치 objetos SQL / JSON, llama a la funci칩n jsonb_path_exists_opr: <br><br><pre> <code class="sql hljs"> '[1,2,3]' @@ '$[*] == 3'  true;  '[1,2,3]' @? '$[*] @? (@ == 3)' -  true</code> </pre> <br>  Se puede lograr el mismo resultado utilizando diferentes operadores: <br><br><pre> <code class="sql hljs">js @? '$.a'  js @@ 'exists($.a)' js @@ '$.a == 1'  js @? '$ ? ($.a == 1)'</code> </pre> <br>  La belleza de los operadores booleanos JSONPath es que son compatibles, acelerados por los 칤ndices GIN.  jsonb_ops y jsonb_path_ops son las clases de operador correspondientes.  En el ejemplo, deshabilitamos SEQSCAN, ya que tenemos un microtable, en tablas grandes, el optimizador mismo seleccionar치 el 칈ndice de mapa de bits: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> ENABLE_SEQSCAN <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> gin (js); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (COSTS <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> js @? <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.rooms == 3)'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">-------------------------------------------------------------------------------- Bitmap Heap Scan on house Recheck Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) -&gt; Bitmap Index Scan on house_js_idx Index Cond: (js @? '$."floor"[*]."apt"[*]?(@."rooms" == 3)'::jsonpath) (4 rows)</span></span></code> </pre> <br>  Todas las funciones de la forma jsonb_path_xxx () tienen la misma firma: <br><br><pre> <code class="sql hljs">jsonb_path_xxx( js jsonb, jsp jsonpath, vars jsonb DEFAULT '{}', silent boolean DEFAULT false )</code> </pre> <br>  vars es un objeto JSONB para pasar variables JSONPath: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query_array(<span class="hljs-string"><span class="hljs-string">'[1,2,3,4,5]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (@ &gt; $x)'</span></span>, vars =&gt; <span class="hljs-string"><span class="hljs-string">'{"x": 2}'</span></span>); jsonb_path_query_array <span class="hljs-comment"><span class="hljs-comment">------------------------ [3, 4, 5]</span></span></code> </pre> <br>  Es dif칤cil prescindir de vars cuando hacemos una uni칩n que involucra un campo de tipo jsonb en una de las tablas.  Digamos que hacemos una aplicaci칩n que busca apartamentos adecuados para los empleados en esa misma casa que han escrito sus requisitos para el 치rea m칤nima en el cuestionario: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> demands(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">position</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">demand</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> demands <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">85</span></span>), (<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(js, <span class="hljs-string"><span class="hljs-string">'$.floor[*].apt[*] ? (@.area &gt;= $min)'</span></span>, vars =&gt; jsonb_build_object(<span class="hljs-string"><span class="hljs-string">'min'</span></span>, demands.demand)) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> house, demands <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; -[ RECORD 1 ]<span class="hljs-comment"><span class="hljs-comment">----+----------------------------------- jsonb_path_query | {"no": 2, "area": 80, "rooms": 3} -[ RECORD 2 ]----+----------------------------------- jsonb_path_query | {"no": 3, "area": 50, "rooms": 2} -[ RECORD 3 ]----+----------------------------------- jsonb_path_query | {"no": 4, "area": 100, "rooms": 3} -[ RECORD 4 ]----+----------------------------------- jsonb_path_query | {"no": 5, "area": 60, "rooms": 2}</span></span></code> </pre> <br>  Lucky Pasha puede elegir entre 4 apartamentos.  Pero vale la pena cambiar 1 letra en la solicitud, de "P" a "C", 춰y no habr치 elecci칩n!  Solo 1 apartamento servir치. <br><br><br>  Queda una palabra clave m치s: el silencio es una bandera que suprime el manejo de errores; est치n en la conciencia del programador. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>); ERROR: SQL/JSON member not found DETAIL: jsonpath member accessor can only be applied to an object</code> </pre> <br>  El error  Pero esto no ser치 un error: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[]'</span></span>, <span class="hljs-string"><span class="hljs-string">'strict $.a'</span></span>, silent =&gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ (0 rows)</span></span></code> </pre> <br>  Por cierto, acerca de los errores: de acuerdo con el est치ndar, los errores aritm칠ticos en las expresiones no dan mensajes de error, est치n en la conciencia del programador: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb_path_query(<span class="hljs-string"><span class="hljs-string">'[1,0,2]'</span></span>, <span class="hljs-string"><span class="hljs-string">'$[*] ? (1/ @ &gt;= 1)'</span></span>); jsonb_path_query <span class="hljs-comment"><span class="hljs-comment">------------------ 1 (1 row)</span></span></code> </pre> <br>  Al calcular la expresi칩n en el filtro, se buscan los valores de la matriz, entre los cuales hay 0, pero dividir por 0 no genera un error. <br><br>  Las funciones funcionar치n de manera diferente seg칰n el modo seleccionado: estricto o laxo (en la traducci칩n "no estricto" o incluso "suelto", se selecciona de forma predeterminada).  Supongamos que estamos buscando una clave en modo Lax en JSON, donde obviamente no es: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- f (1 row)</span></span></code> </pre> <br>  Ahora en modo estricto: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'{"a":1}'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $.b ? (@ &gt; 1)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- (null) (1 row)</span></span></code> </pre> <br>  Es decir, donde en modo liberal recibimos FALSO, con estricto obtuvimos NULL. <br><br>  En el modo Lax, una matriz con una jerarqu칤a compleja [1,2, [3,4,5]] siempre se expande a [1,2,3,4,5]: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'lax $[*] ? (@ == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  En modo estricto, el n칰mero "5" no se encontrar치, ya que no se encuentra en la parte inferior de la jerarqu칤a.  Para encontrarlo, debe modificar la consulta, reemplazando "@" con "@ [*]": <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> jsonb <span class="hljs-string"><span class="hljs-string">'[1,2,[3,4,5]]'</span></span> @? <span class="hljs-string"><span class="hljs-string">'strict $[*] ? (@[*] == 5)'</span></span>; ?column? <span class="hljs-comment"><span class="hljs-comment">---------- t (1 row)</span></span></code> </pre> <br>  En PostgreSQL 12, JSONPath es un tipo de datos.  El est치ndar no dice nada sobre la necesidad de un nuevo tipo, es una propiedad de implementaci칩n.  Con el nuevo tipo, obtenemos trabajo completo con jsonpath con la ayuda de operadores e 칤ndices que aceleran su trabajo, que ya existe para JSONB.  De lo contrario, JSONPath tendr칤a que integrarse a nivel del c칩digo de ejecutor y optimizador. <br><br>  Puede leer sobre la sintaxis de SQL / JSON, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> . <br><br>  La publicaci칩n de blog de Oleg Bartunov trata sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">conformidad SQL / JSON est치ndar-2016</a> para PostgreSQL, Oracle, SQL Server y MySQL. <br><br>  Aqu칤 hay una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentaci칩n</a> sobre SQL / JSON. <br><br>  Y aqu칤 hay una <a href="">introducci칩n</a> a SQL / JSON. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/448612/">https://habr.com/ru/post/448612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../448602/index.html">쮼l monitoreo est치 muerto? - Larga vida al monitoreo</a></li>
<li><a href="../448604/index.html">Gameboy en C #</a></li>
<li><a href="../448606/index.html">Sidorin: KnowledgeConf trata sobre c칩mo mantener el conocimiento con una duraci칩n promedio de trabajo en un lugar en 2-3 a침os</a></li>
<li><a href="../448608/index.html">쮺칩mo dar los primeros pasos en rob칩tica?</a></li>
<li><a href="../448610/index.html">Bricolaje: c칩mo hicimos un calendario en vivo para Codefest X</a></li>
<li><a href="../448618/index.html">Algoritmo Douglas-Pecker</a></li>
<li><a href="../448622/index.html">PHP GR8: JIT mejorar치 el rendimiento de PHP 8</a></li>
<li><a href="../448624/index.html">Ver los datos? No Entonces no lo veo, pero lo son. Destruimos datos en unidades SSD e incluso restauramos la velocidad</a></li>
<li><a href="../448626/index.html">DDoS para ayudar: c칩mo realizamos pruebas de estr칠s y estr칠s</a></li>
<li><a href="../448628/index.html">Est칠tica t칠cnica y tecnolog칤a sovi칠ticas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>