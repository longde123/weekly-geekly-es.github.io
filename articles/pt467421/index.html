<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∑ üõ£Ô∏è üï£ Crie ponteiros inteligentes expressivos para mem√≥ria remota em C ++ üë©‚Äçüë¶ üõåüèª üé¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 Hoje estamos publicando uma tradu√ß√£o de um estudo interessante sobre como trabalhar com mem√≥ria e ponteiros em C ++. O material √© um pouc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crie ponteiros inteligentes expressivos para mem√≥ria remota em C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/467421/">  Ol√° Habr! <br><br>  Hoje estamos publicando uma tradu√ß√£o de um estudo interessante sobre como trabalhar com mem√≥ria e ponteiros em C ++.  O material √© um pouco acad√™mico, mas obviamente ser√° de interesse dos leitores dos livros de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Galowitz</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Williams</a> . <br><br>  Siga o an√∫ncio! <br><a name="habracut"></a><br>  Na faculdade, estou envolvido na constru√ß√£o de estruturas de dados distribu√≠dos.  Portanto, a abstra√ß√£o que representa o ponteiro remoto √© extremamente importante no meu trabalho para criar c√≥digo limpo e organizado.  Neste artigo, explicarei por que ponteiros inteligentes s√£o necess√°rios, contarei como escrevi objetos de ponteiro remoto para minha biblioteca em C ++, verifique se eles funcionam exatamente como ponteiros regulares de C ++;  isso √© feito usando objetos de link remoto.  Al√©m disso, explicarei em que casos essa abstra√ß√£o falha pela simples raz√£o de que meu pr√≥prio ponteiro (at√© agora) n√£o lida com as tarefas que os ponteiros comuns podem executar.  Espero que este artigo interesse os leitores envolvidos no desenvolvimento de abstra√ß√µes de alto n√≠vel. <br><br><h3>  APIs de baixo n√≠vel </h3><br>  Ao trabalhar com computadores distribu√≠dos ou com hardware de rede, geralmente voc√™ tem acesso de leitura e grava√ß√£o a uma parte da mem√≥ria por meio da API C. Um exemplo desse tipo √© a API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MPI</a> para comunica√ß√£o unidirecional.  Essa API usa fun√ß√µes que abrem o acesso direto √† leitura e grava√ß√£o da mem√≥ria de outros n√≥s localizados em um cluster distribu√≠do.  Veja como fica de uma maneira um pouco simplificada. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remote_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target_node, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>;</code> </pre> <br>  No <i>deslocamento</i> indicado no segmento de mem√≥ria compartilhada do n√≥ de destino, o <code>remote_read</code> um certo n√∫mero de bytes e o <code>remote_write</code> grava um certo n√∫mero de bytes. <br><br>  Essas APIs s√£o √≥timas porque nos d√£o acesso a primitivas importantes que s√£o √∫teis para implementar programas em execu√ß√£o em um cluster de computadores.  Eles tamb√©m s√£o muito bons porque trabalham muito r√°pido e refletem com precis√£o os recursos oferecidos no n√≠vel do hardware: acesso direto √† mem√≥ria remota (RDMA).  Redes modernas de supercomputadores, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cray Aries</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mellanox EDR</a> , permitem calcular que o atraso na leitura / grava√ß√£o n√£o exceder√° 1-2 Œºs.  Esse indicador pode ser alcan√ßado devido ao fato de que a placa de rede (NIC) pode ler e gravar diretamente na RAM, sem esperar que a CPU remota ative e responda √† sua solicita√ß√£o de rede. <br><br>  No entanto, essas APIs n√£o s√£o t√£o boas em termos de programa√ß√£o de aplicativos.  Mesmo no caso de APIs simples, como descrito acima, n√£o custa nada apagar dados acidentalmente, pois n√£o h√° nome separado para cada objeto espec√≠fico armazenado na mem√≥ria, apenas um grande buffer cont√≠guo.  Al√©m disso, a interface n√£o √© digitada, ou seja, voc√™ √© privado de outra ajuda tang√≠vel: quando o compilador jura, se voc√™ anotar o valor do tipo errado no lugar errado.  Seu c√≥digo simplesmente estar√° errado e os erros ser√£o da natureza mais misteriosa e catastr√≥fica.  A situa√ß√£o √© ainda mais complicada porque, na realidade, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">essas APIs</a> s√£o um pouco mais complicadas e, ao trabalhar com elas, √© bem poss√≠vel reorganizar por engano dois ou mais par√¢metros. <br><br><h3>  Ponteiros exclu√≠dos </h3><br>  Os ponteiros s√£o um n√≠vel importante e necess√°rio de abstra√ß√£o necess√°rio ao criar ferramentas de programa√ß√£o de alto n√≠vel.  √Äs vezes, usar ponteiros diretamente √© dif√≠cil, e voc√™ pode fazer muitos bugs, mas os ponteiros s√£o os blocos de constru√ß√£o fundamentais do c√≥digo.  Estruturas de dados e at√© links C ++ costumam usar ponteiros ocultos. <br><br>  Se assumirmos que teremos uma API semelhante √†s descritas acima, um local exclusivo na mem√≥ria ser√° indicado por duas "coordenadas": (1) a <i>classifica√ß√£o</i> ou o ID do processo e (2) o deslocamento feito na parte compartilhada da mem√≥ria remota ocupada pelo processo com essa classifica√ß√£o .  Voc√™ n√£o pode parar por a√≠ e criar uma estrutura completa. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> rank_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset_; };</code> </pre> <br>  Nesse est√°gio, j√° √© poss√≠vel projetar uma API para leitura e grava√ß√£o em ponteiros remotos, e essa API ser√° mais segura do que a que usamos originalmente. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remote_ptr&lt;T&gt; src)</span></span></span><span class="hljs-function"> </span></span>{ T rv; remote_read(&amp;rv, src.rank_, src.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; dst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; src)</span></span></span><span class="hljs-function"> </span></span>{ remote_write(&amp;src, dst.rank_, dst.offset_, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)); }</code> </pre> <br>  As transfer√™ncias de blocos s√£o muito parecidas, e aqui eu as omito por brevidade.  Agora, para ler e escrever valores, voc√™ pode escrever o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs"> remote_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ptr = ...; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval = rget(ptr); rval++; rput(ptr, rval);</code> </pre> <br>  J√° √© melhor que a API original, pois aqui trabalhamos com objetos digitados.  Agora n√£o √© t√£o f√°cil escrever ou ler um valor do tipo errado ou gravar apenas uma parte de um objeto. <br><br><h3>  Aritm√©tica do ponteiro </h3><br>  A aritm√©tica de ponteiro √© a t√©cnica mais importante que permite ao programador gerenciar cole√ß√µes de valores na mem√≥ria;  se estamos escrevendo um programa para trabalho distribu√≠do na mem√≥ria, presumivelmente vamos operar com grandes cole√ß√µes de valores. <br>  O que significa aumentar ou diminuir um ponteiro exclu√≠do em um?  A op√ß√£o mais simples √© considerar a aritm√©tica dos ponteiros exclu√≠dos como a aritm√©tica dos ponteiros comuns: p + 1 simplesmente aponta para o pr√≥ximo tamanho de mem√≥ria alinhada por <code>sizeof(T)</code> depois de p no segmento compartilhado da classifica√ß√£o original. <br><br>  Embora essa n√£o seja a √∫nica defini√ß√£o poss√≠vel da aritm√©tica de ponteiros remotos, ela foi adotada mais ativamente recentemente, e os ponteiros remotos usados ‚Äã‚Äãdessa maneira est√£o contidos em bibliotecas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UPC ++</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DASH</a> e BCL.  No entanto, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linguagem Unified Parallel C</a> (UPC), que deixou um legado rico na comunidade de especialistas em computa√ß√£o de alto desempenho (HPC), cont√©m uma defini√ß√£o mais elaborada da aritm√©tica dos ponteiros [1]. <br><br>  A implementa√ß√£o da aritm√©tica do ponteiro √© simples e envolve apenas a altera√ß√£o do deslocamento do ponteiro. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ptr&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> diff) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> new_offset = offset_ + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)*diff; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ptr&lt;T&gt;{rank_, new_offset}; }</code> </pre> <br>  Nesse caso, temos a oportunidade de acessar matrizes de dados na mem√≥ria distribu√≠da.  Assim, poder√≠amos conseguir que cada processo no programa SPMD realizasse uma opera√ß√£o de grava√ß√£o ou leitura em sua vari√°vel na matriz para a qual o ponteiro remoto √© direcionado [2]. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { rput(ptr + my_rank(), my_rank()); } }</code> </pre> <br>  Tamb√©m √© f√°cil implementar outros operadores, fornecendo suporte para o conjunto completo de opera√ß√µes aritm√©ticas realizadas na aritm√©tica comum dos ponteiros. <br><br><h3>  Selecionar nullptr </h3><br>  Para ponteiros regulares, o valor <code>nullptr</code> √© <code>NULL</code> , o que geralmente significa reduzir <code>#define</code> para 0x0, pois √© improv√°vel que esta se√ß√£o na mem√≥ria seja usada.  Em nosso esquema com ponteiros remotos, podemos selecionar um valor de ponteiro espec√≠fico como <code>nullptr</code> , tornando esse local na mem√≥ria n√£o utilizado, ou incluir um membro booleano especial que indicar√° se o ponteiro √© nulo.  Apesar de n√£o usar a melhor maneira de usar um determinado local na mem√≥ria, tamb√©m consideraremos que, ao adicionar apenas um valor booleano, o tamanho do ponteiro remoto dobrar√° do ponto de vista da maioria dos compiladores e aumentar√° de 128 para 256 bits para manter o alinhamento.  Isso √© especialmente indesej√°vel.  Na minha biblioteca, escolhi <code>{0, 0}</code> , ou seja, um deslocamento de 0 com uma classifica√ß√£o de 0, como o valor <code>nullptr</code> . <br><br>  Pode ser poss√≠vel escolher outras op√ß√µes para o <code>nullptr</code> que tamb√©m funcionar√£o.  Al√©m disso, em alguns ambientes de programa√ß√£o, como UPC, s√£o implementados indicadores estreitos que cabem em 64 bits cada.  Assim, eles podem ser usados ‚Äã‚Äãem opera√ß√µes de compara√ß√£o at√¥mica com troca.  Ao trabalhar com um ponteiro estreito, √© necess√°rio comprometer: o identificador de deslocamento ou o identificador de classifica√ß√£o devem caber em 32 bits ou menos, e isso limita a escalabilidade. <br><br><h3>  Links exclu√≠dos </h3><br>  Em linguagens como Python, a instru√ß√£o bracket serve como a√ß√∫car sint√°tico para chamar os <code>__getitem__</code> e <code>__getitem__</code> , dependendo se voc√™ l√™ o objeto ou escreve nele.  No C ++, o <code>operator[]</code> n√£o distingue a qual das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">categorias de valor</a> um objeto pertence e se o valor retornado cair√° imediatamente em leitura ou grava√ß√£o.  Para resolver esse problema, as estruturas de dados C ++ retornam links apontando para a mem√≥ria contida no cont√™iner, que pode ser gravada ou lida.  A implementa√ß√£o do <code>operator[]</code> para <code>std::vector</code> pode se parecer com isso. <br><br><pre> <code class="cpp hljs"> T&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data_[idx]; }</code> </pre><br>  O fato mais significativo aqui √© que retornamos uma entidade do tipo <code>T&amp;</code> , que √© um link C ++ bruto pelo qual voc√™ pode escrever, e n√£o uma entidade do tipo <code>T</code> , que apenas representa o valor dos dados de origem. <br><br>  No nosso caso, n√£o podemos retornar um link C ++ bruto, pois estamos nos referindo √† mem√≥ria localizada em outro n√≥ e n√£o representada em nosso espa√ßo de endere√ßo virtual.  √â verdade que podemos criar nossos pr√≥prios objetos de refer√™ncia personalizados. <br>  Um link √© um objeto que serve como inv√≥lucro ao redor de um ponteiro e executa duas fun√ß√µes importantes: pode ser convertido em um valor do tipo <code>T</code> e voc√™ tamb√©m pode atribu√≠-lo a um valor do tipo <code>T</code>  Portanto, no caso de uma refer√™ncia remota, precisamos apenas implementar um operador de convers√£o impl√≠cita que leia o valor e tamb√©m criar um operador de atribui√ß√£o que escreva no valor. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remote_ref</span></span></span><span class="hljs-class"> {</span></span> remote_ptr&lt;T&gt; ptr_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rget(ptr_); } remote_ref&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; value) { rput(ptr_, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } };</code> </pre><br>  Assim, podemos enriquecer nosso ponteiro remoto com novos recursos poderosos, na presen√ßa dos quais ele pode ser desreferenciado exatamente como ponteiros comuns. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>}; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; remote_ref&lt;T&gt; remote_ptr&lt;T&gt;::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span> idx) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> remote_ref&lt;T&gt;{*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + idx}; }</code> </pre> <br>  Portanto, agora restauramos a imagem inteira, mostrando como voc√™ pode usar ponteiros remotos normalmente.  Podemos reescrever o programa simples acima. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ptr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; len) { ptr[my_rank()] = my_rank(); } }</code> </pre> <br>  Obviamente, nossa nova API de ponteiros nos permite escrever programas mais complexos, por exemplo, uma fun√ß√£o para realizar redu√ß√£o paralela com base em uma √°rvore [3].  As implementa√ß√µes que usam nossa classe de ponteiro remoto s√£o mais seguras e limpas do que aquelas normalmente obtidas usando a API C descrita acima. <br><br><h3>  Custos decorrentes do tempo de execu√ß√£o (ou falta dele!) </h3><br>  No entanto, quanto nos custaria usar uma abstra√ß√£o de alto n√≠vel?  Cada vez que acessamos a mem√≥ria, chamamos o m√©todo de desreferencia√ß√£o, retornamos o objeto intermedi√°rio que envolve o ponteiro e, em seguida, chamamos o operador de convers√£o ou o operador de atribui√ß√£o que afeta o objeto intermedi√°rio.  Quanto nos custar√° em tempo de execu√ß√£o? <br><br>  Acontece que, se voc√™ designar cuidadosamente o ponteiro e as classes de refer√™ncia, n√£o haver√° sobrecarga para essa abstra√ß√£o em tempo de execu√ß√£o - os compiladores C ++ modernos lidam com esses objetos intermedi√°rios e chamadas de m√©todo por incorpora√ß√£o agressiva.  Para avaliar quanto essa abstra√ß√£o nos custar√°, podemos compilar um programa de exemplo simples e verificar como a montagem ir√° ver quais objetos e m√©todos existir√£o em tempo de execu√ß√£o.  No exemplo descrito aqui com redu√ß√£o baseada em √°rvore compilada com classes de ponteiros remotos e refer√™ncias, os compiladores modernos reduzem a redu√ß√£o baseada em √°rvore a v√°rias <code>remote_write</code> e <code>remote_write</code> [4].  Nenhum m√©todo de classe √© chamado, nenhum objeto de refer√™ncia existe no tempo de execu√ß√£o. <br><br><h3>  Intera√ß√£o com bibliotecas de estrutura de dados </h3><br>  Programadores experientes em C ++ lembram que a biblioteca de modelos C ++ padr√£o declara: Os cont√™ineres STL devem suportar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">alocadores C ++ personalizados</a> .  Alocadores permitem que voc√™ aloque mem√≥ria e, em seguida, essa mem√≥ria pode ser referenciada usando os tipos de ponteiros feitos por n√≥s.  Isso significa que voc√™ pode simplesmente criar um "alocador remoto" e conect√°-lo para armazenar dados na mem√≥ria remota usando cont√™ineres STL? <br><br>  Infelizmente n√£o.  Presumivelmente, por motivos de desempenho, o padr√£o C ++ n√£o requer mais suporte para tipos de refer√™ncia personalizados e, na maioria das implementa√ß√µes da biblioteca padr√£o C ++, eles realmente n√£o s√£o suportados.  Portanto, por exemplo, se voc√™ usa o libstdc ++ do GCC, pode recorrer a ponteiros personalizados, mas ao mesmo tempo pode usar apenas links C ++ normais, o que n√£o permite o uso de cont√™ineres STL na mem√≥ria remota.  Algumas bibliotecas de modelos C ++ de alto n√≠vel, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Agency</a> , que usam tipos de ponteiros e tipos de refer√™ncia personalizados, cont√™m suas pr√≥prias implementa√ß√µes de algumas estruturas de dados do STL que realmente permitem trabalhar com tipos de refer√™ncia remota.  Nesse caso, o programador obt√©m mais liberdade em uma abordagem criativa para criar tipos de alocadores, ponteiros e links e, al√©m disso, obt√©m uma cole√ß√£o de estruturas de dados que podem ser usadas automaticamente com eles. <br><br><h3>  Contexto amplo </h3><br>  Neste artigo, abordamos v√°rios problemas mais amplos e ainda n√£o resolvidos. <br><br><ul><li>  <b>Aloca√ß√£o de mem√≥ria</b> .  Agora que podemos fazer refer√™ncia a objetos na mem√≥ria remota, como reservamos ou alocamos essa mem√≥ria remota? </li><li>  <b>Suporte para objetos</b> .  E o armazenamento na mem√≥ria remota de objetos que s√£o do tipo mais complicado que o int?  √â poss√≠vel um suporte puro para tipos complexos?  Tipos simples podem ser suportados ao mesmo tempo sem desperdi√ßar recursos na serializa√ß√£o? </li><li>  <b>Projetando estruturas de dados distribu√≠dos</b> .  Agora que voc√™ tem essas abstra√ß√µes, quais estruturas e aplicativos de dados voc√™ pode construir com eles?  Quais abstra√ß√µes devem ser usadas para distribui√ß√£o de dados? </li></ul><br><h3>  Anota√ß√µes </h3><br>  [1] No UPC, os ponteiros t√™m uma fase que determina qual classifica√ß√£o o ponteiro ser√° direcionado ap√≥s aumentar um.  Devido √†s fases, as matrizes distribu√≠das podem ser encapsuladas em ponteiros e os padr√µes de distribui√ß√£o podem ser muito diferentes.  Esses recursos s√£o muito poderosos, mas podem parecer m√°gicos para um usu√°rio iniciante.  Embora alguns ases do UPC realmente prefiram essa abordagem, uma abordagem orientada a objetos mais razo√°vel √© escrever uma classe simples de ponteiro remoto primeiro e depois garantir que os dados sejam alocados com base nas estruturas de dados projetadas especificamente para isso. <br><br>  [2] A maioria dos aplicativos no HPC √© escrita no estilo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SPMD</a> , esse nome significa "um programa, dados diferentes".  A API do SPMD oferece uma fun√ß√£o ou vari√°vel <code>my_rank()</code> que informa ao processo que est√° executando o programa uma classifica√ß√£o ou ID exclusivo, com base no qual ele pode ramificar do programa principal. <br><br>  [3] Aqui est√° uma simples redu√ß√£o de √°rvore escrita no estilo SPMD usando a classe de ponteiro remoto.  O c√≥digo √© adaptado com base em um programa originalmente escrito pelo meu colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Andrew Belt</a> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(remote_ptr&lt;T&gt; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> k = len; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { k = (k + <span class="hljs-number"><span class="hljs-number">1</span></span>) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (my_rank() &lt; k &amp;&amp; my_rank() + k &lt; len) { a[my_rank()] += a[my_rank() + k]; } len = k; barrier(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre><br>  [4] O resultado compilado do c√≥digo acima <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode ser encontrado aqui</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467421/">https://habr.com/ru/post/pt467421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467407/index.html">Trabalhamos com o cobot Dobot M1</a></li>
<li><a href="../pt467409/index.html">Para fazer neg√≥cios no Vale do Sil√≠cio, voc√™ precisa se comportar</a></li>
<li><a href="../pt467413/index.html">Estrutura de microsservi√ßo PHP - `Hello world` do Swoft</a></li>
<li><a href="../pt467415/index.html">Mercado de c√¢mbio moderno</a></li>
<li><a href="../pt467419/index.html">Lan√ßamento final do Jakarta EE 8</a></li>
<li><a href="../pt467423/index.html">Xamarin.Forms - uso conveniente de fontes de √≠cone no aplicativo</a></li>
<li><a href="../pt467425/index.html">Abordagem intensiva de aprendizagem STEM</a></li>
<li><a href="../pt467427/index.html">BudgetTracker - outra ferramenta de c√≥digo aberto para contabilidade de finan√ßas pessoais</a></li>
<li><a href="../pt467429/index.html">Habrastatistics: explorando as se√ß√µes mais e menos visitadas do site</a></li>
<li><a href="../pt467435/index.html">Enviamos relat√≥rios do agente Veeam Linux para o correio ou no Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>