<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🍳 👁‍🗨 😕 Serverless and React 2: Handfertigkeit und kein Betrug 🛄 🚴🏿 🐫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kann ich Front-End-Entwicklern auf einfache Weise Informationen über die Cloudless Serverless-Architektur in AWS (Amazon Web Services) geben? Warum ni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serverless and React 2: Handfertigkeit und kein Betrug</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/417943/"> Kann ich Front-End-Entwicklern auf einfache Weise Informationen über die Cloudless Serverless-Architektur in AWS (Amazon Web Services) geben?  Warum nicht.  Lassen Sie uns die AWS React / Redux-Anwendung rendern und dann über die Vor- und Nachteile von AWS Lambdas sprechen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wJcXVjemrEY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Das Material basiert auf der Abschrift des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Berichts</a> von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Marina Mironovich</a> von unserer Frühjahrskonferenz HolyJS 2018 in St. Petersburg.</i> <br><a name="habracut"></a><br>  Offiziell ist Marina ein führender Entwickler von EPAM.  Jetzt arbeitet sie in einer Lösungsarchitektengruppe für einen Kunden und nimmt deshalb an einer Vielzahl von Projekten teil.  Daher wird es für uns einfacher sein, den Kreis ihrer aktuellen Interessen zu skizzieren, als alle Technologien aufzulisten, mit denen sie arbeitet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e6/caf/b0d/0e6cafb0de05d040b8b7bc30ab969b34.jpg" align="left">  <i>Zunächst interessiere ich mich für alle Cloud-Technologien, insbesondere für AWS, weil ich in der Produktion viel damit arbeite.</i>  <i>Aber ich versuche mit allem anderen Schritt zu halten.</i> <i><br><br></i>  <i>Frontend ist meine erste Liebe und scheint für immer.</i>  <i>Insbesondere arbeite ich derzeit mit React und React Native, daher weiß ich etwas mehr darüber.</i>  <i>Ich versuche auch, alles andere im Auge zu behalten.</i>  <i>Ich interessiere mich für alles, was mit Projektdokumentation zu tun hat, zum Beispiel für UML-Diagramme.</i>  <i>Da ich Mitglied der Solution Architect Group bin, muss ich viel tun.</i> <i><br><br></i> <br><br><h2>  Teil 1. Hintergrund </h2><br>  Die Idee, über Serverless zu sprechen, kam mir vor ungefähr einem Jahr.  Ich wollte einfach und natürlich über Serverless für Front-End-Entwickler sprechen.  Damit Sie kein zusätzliches Wissen benötigen, um es zu verwenden, können Sie dies jetzt mit mehr Technologien tun. <br><br>  Bis zu einem gewissen Grad wurde die Idee verwirklicht - ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habe</a> auf FrontTalks 2017 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">über Serverless</a> gesprochen. Es stellte sich jedoch heraus, dass 45 Minuten für eine einfache und verständliche Geschichte nicht ausreichen.  Daher wurde der Bericht in zwei Teile geteilt, und jetzt vor Ihnen ist die zweite "Serie".  Wer das erste nicht gesehen hat - keine Sorge, es wird nicht schaden zu verstehen, was unten geschrieben steht.  Wie in anständigen Fernsehsendungen werde ich mit einer Zusammenfassung des vorherigen Teils beginnen.  Dann gehe ich zum Saft selbst über - wir rendern die React / Redux-Anwendung.  Und schließlich werde ich über die Vor- und Nachteile von Cloud-Funktionen im Prinzip (insbesondere AWS Lambdas) sprechen und darüber, was mit ihnen sonst noch getan werden kann.  Ich hoffe, dass dieser Teil für alle nützlich sein wird, die bereits mit dem AWS Lambda vertraut sind.  Am wichtigsten ist, dass die Welt nicht mit Amazon endet. Sprechen wir also darüber, was es sonst noch im Bereich der Cloud-Funktionen gibt. <br><br><h3>  Was ich verwenden werde </h3><br>  Zum Rendern der Anwendung werde ich viele Amazon-Dienste verwenden: <br><br><ol><li>  S3 ist ein Dateisystem in den Clouds.  Dort speichern wir statische Assets. <br></li><li>  IAM (Zugriffsrechte für Benutzer und Dienste) - implizit, wird jedoch im Hintergrund verwendet, damit die Dienste miteinander kommunizieren. <br></li><li>  API-Gateway (URL für den Zugriff auf die Site) - Sie sehen die URL, unter der wir unser Lambda aufrufen können. <br></li><li>  CloudFormation (für die Bereitstellung) - wird implizit im Hintergrund verwendet. <br></li><li>  AWS Lambda - dafür sind wir hergekommen. <br></li></ol><br><h3>  Was ist serverlos und was ist AWS Lambda? </h3><br>  Eigentlich ist Serverless ein großer Betrug, denn natürlich gibt es Server: Irgendwo fängt alles an.  Aber was ist dort los? <br><br>  Wir schreiben eine Funktion, die auf den Servern ausgeführt wird.  Natürlich fängt es nicht nur so an, sondern in einer Art Behälter.  Tatsächlich wird diese Funktion im Container auf dem Server als Lambda bezeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ad/2c6/ff1/6ad2c6ff181236d39a29121e8b607a96.png"></div><br>  Im Falle von Lambda können wir die Server vergessen.  Ich würde sogar folgendes sagen: Wenn Sie die Lambda-Funktion schreiben, ist es schädlich, über sie nachzudenken.  Wir arbeiten mit Lambda nicht so wie mit einem Server. <br><br><h3>  So setzen Sie Lambda ein </h3><br>  Es stellt sich eine logische Frage: Wenn wir keinen Server haben, wie stellen wir ihn bereit?  Es gibt SSH auf dem Server, wir haben den Code hochgeladen, ihn gestartet - alles ist in Ordnung.  Was tun mit Lambda? <br><br>  <b>Option 1. Wir können es nicht bereitstellen.</b> <br><br>  AWS in der Konsole hat eine nette und sanfte IDE für uns erstellt, in der wir genau dort eine Funktion schreiben können. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/08e/1cd/f73/08e1cdf73c5d5fec2c6315e0207e51ed.png"><br><br>  Es ist schön, aber nicht sehr erweiterbar. <br><br>  <b>Option 2. Wir können eine Zip-Datei erstellen und von der Befehlszeile herunterladen</b> <br><br>  Wie erstellen wir eine Zip-Datei? <br><br> <code>zip -r build/lambda.zip index.js [node_modules/] [package.json] <br></code> <br>  Wenn Sie node_modules verwenden, wird dies alles in einem Archiv komprimiert. <br>  Je nachdem, ob Sie eine neue Funktion erstellen oder ob Sie bereits über eine solche Funktion verfügen, können Sie dies auch tun <br><br> <code>aws lambda create-function... <br></code> <br>  entweder <br><br> <code>aws lambda update-function-code... <br></code> <br>  Was ist das Problem?  Zunächst möchte die AWS-CLI wissen, ob eine Funktion erstellt wird oder ob Sie bereits eine haben.  Dies sind zwei verschiedene Teams.  Wenn Sie nicht nur den Code, sondern auch einige Attribute dieser Funktion aktualisieren möchten, treten Probleme auf.  Die Anzahl dieser Befehle nimmt zu, und Sie müssen sich in ein Verzeichnis setzen und überlegen, welchen Befehl Sie verwenden möchten. <br><br>  Wir können es besser und einfacher machen.  Dafür haben wir Rahmenbedingungen. <br><br><h3>  AWS Lambda Frameworks </h3><br>  Es gibt viele solcher Rahmenbedingungen.  Dies ist in erster Linie AWS CloudFormation, die in Verbindung mit der AWS CLI funktioniert.  CloudFormation ist eine Json-Datei, die Ihre Dienste beschreibt.  Sie beschreiben sie in einer Json-Datei, sagen dann über die AWS-CLI "Ausführen" und es wird automatisch alles für Sie im AWS-Service erstellt. <br><br>  Für eine so einfache Aufgabe wie das Rendern ist es jedoch immer noch schwierig.  Hier ist die Eintrittsschwelle zu groß - Sie müssen lesen, welche Struktur CloudFormation usw. hat. <br><br>  Versuchen wir es zu vereinfachen.  Und hier erscheinen verschiedene Frameworks: APEX, Zappa (nur für Python), Claudia.js.  Ich habe nur wenige zufällig aufgelistet. <br><br>  Das Problem und die Stärke dieser Frameworks besteht darin, dass sie hoch spezialisiert sind.  Sie sind also sehr gut darin, einfache Aufgaben zu erledigen.  Zum Beispiel ist Claudia.js sehr gut zum Erstellen einer REST-API geeignet.  Sie wird das AWS-Aufruf-API-Gateway erstellen, sie wird ein Lambda für Sie erstellen, alles wird wunderschön gesperrt sein.  Wenn Sie jedoch etwas mehr bereitstellen müssen, treten Probleme auf - Sie müssen etwas hinzufügen, helfen, schauen usw. <br><br>  Zappa wurde nur für Python geschrieben.  Und ich möchte etwas ehrgeizigeres.  Und hier kommt Terraform und meine Serverless Liebe. <br><br>  Serverless liegt irgendwo in der Mitte zwischen der sehr großen CloudFormation, die fast alles kann, und diesen hochspezialisierten Frameworks.  Fast alles kann darin bereitgestellt werden, aber alles zu tun ist immer noch recht einfach.  Es hat auch eine sehr leichte Syntax. <br><br>  Terraform ist bis zu einem gewissen Grad ein Analogon zu CloudFormation.  Terraform ist Open Source, darin können Sie alles bereitstellen - gut oder fast alles.  Und wenn AWS die Services erstellt, können Sie dort etwas Neues hinzufügen.  Aber es ist groß und kompliziert. <br><br>  Um ehrlich zu sein, verwenden wir in der Produktion Terraform, weil mit Terraform alles, was wir haben, einfacher wird - Serverless wird dies alles nicht beschreiben.  Aber Terraform ist sehr komplex.  Und wenn ich etwas für die Arbeit schreibe, schreibe ich es zuerst auf Serverless, teste es auf Leistung und erst nachdem meine Konfiguration getestet und ausgearbeitet wurde, schreibe ich es auf Terraform neu (das macht noch ein paar Tage „Spaß“). <br><br><h3>  Serverlos </h3><br>  Warum liebe ich Serverless? <br><br><ol><li>  Serverless verfügt über ein System, mit dem Sie Plugins erstellen können.  Meiner Meinung nach ist dies eine Rettung von allem.  Serverlos - Open Source.  Das Hinzufügen von Open Source ist jedoch nicht immer einfach.  Sie müssen verstehen, was im vorhandenen Code passiert, Richtlinien beachten, zumindest den Codestil einhalten, eine PR einreichen, diese PR vergessen und sie drei Jahre lang verstauben.  Entsprechend den Ergebnissen gabelst du, und dies wird irgendwo für dich separat sein.  Das alles ist nicht sehr gesund.  Aber wenn es Plugins gibt, wird alles vereinfacht.  Sie müssen etwas hinzufügen - Sie sind auf dem Knie und erstellen Ihr eigenes kleines Plugin.  Dazu müssen Sie nicht mehr verstehen, was in Serverless geschieht (wenn dies keine benutzerdefinierte Frage ist).  Sie verwenden einfach die verfügbare API, speichern das Plugin irgendwo oder stellen es für alle bereit.  Und alles funktioniert für Sie.  Darüber hinaus gibt es bereits einen großen Zoo von Plugins und Leuten, die diese Plugins schreiben.  Das heißt, vielleicht wurde bereits etwas für Sie entschieden. <br></li><li>  Serverless hilft dabei, Lambda lokal auszuführen.  Das ausreichend große Minus des Lambda ist, dass AWS nicht darüber nachgedacht hat, wie wir es debuggen und testen werden.  Mit Serverless können Sie jedoch alles lokal ausführen und sehen, was passiert (er tut dies sogar in Verbindung mit der Gateway-API). <br></li></ol><br><h3>  Demonstration </h3><br>  Jetzt werde ich zeigen, wie das alles wirklich funktioniert.  In den nächsten anderthalb bis zwei Minuten können wir einen Dienst erstellen, der unsere HTML-Seite rendert. <br>  Zuerst führe ich in einem neuen Ordner die SLS Create-Vorlage aus: <br><br> <code><br> mkdir sls-holyjs <br> cd sls-holyjs <br> sls create --template aws-nodejs-ecma-script <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/4d2/620/2e5/4d26202e5337684014e9f43fb25771d3.png"><br><br> <code>npm install <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/bee/67c/81f/bee67c81fbb0b19e21432a73b69751dc.png"><br><br>  Serverlose Entwickler haben sich um uns gekümmert - es ist möglich geworden, Services aus Vorlagen zu erstellen.  In diesem Fall verwende ich die Vorlage <code>nodejs-ecma-script</code> , mit der einige Dateien für mich erstellt werden, z. B. die Webpack-Konfiguration, package.json, einige Funktionen und serverless.yml: <br><br> <code>ls <br></code> <br><img src="https://habrastorage.org/getpro/habr/post_images/35b/6c6/86a/35b6c686a1fbe3e323ddb939147d1b3d.png"><br><br>  Ich brauche nicht alle Funktionen.  Ich werde die erste, zweite Umbenennung in Holyjs entfernen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/030/599/ae0/030599ae094881637ae09ee3daf33ffd.png"><br><br>  Ich werde serveless.yml ein wenig optimieren, wo ich eine Beschreibung aller erforderlichen Dienste habe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85d/0ba/f9b/85d0baf9bad8e2918866f5a97c096017.png"><br><br>  Nun, dann werde ich die Antwort korrigieren, die die Funktion zurückgibt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e13/07a/d85/e1307ad8550ea44532f79e6db27d561c.png"><br><br>  Ich mache den HTML-Code "Hello HolyJS" und füge ein Handle zum Rendern hinzu. <br><br>  Weiter: <br><br> <code>sls deploy <br></code> <br>  Und voila!  Es gibt eine URL, über die ich im öffentlichen Zugriff sehen kann, was gerendert wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/228/4f3/b94/2284f3b9487a8d70a9244652d99874ff.png"><br><br>  Vertrauen, aber überprüfen.  Ich gehe zur AWS-Konsole und überprüfe, ob ich eine HolyJS-Funktion erstellt habe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e62/458/e98/e62458e98369c7022c280c419f79be55.png"><br><br>  Wie Sie sehen können, erstellt Serverless es vor der Bereitstellung mithilfe von Webpack.  Außerdem wird der Rest der dort beschriebenen Infrastruktur erstellt - API-Gateway usw. <br><br>  Wenn ich dies entfernen möchte: <br><br> <code>sls remove <br></code> <br>  Alle in serverless.yml beschriebenen Infrastrukturen werden gelöscht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad7/8fb/f2d/ad78fbf2d65cbcaef9094673bcca4026.png"><br><br>  Wenn jemand hinter dem hier beschriebenen Prozess steht, lade ich Sie ein, einfach meinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Bericht</a> zu überprüfen. <br><br><h3>  Führen Sie Lambda lokal aus </h3><br>  Ich erwähnte, dass Lambda lokal betrieben werden kann.  Hier gibt es zwei Startoptionen. <br><br>  <b>Option 1. Wir führen einfach alles im Terminal aus</b> <br><br>  Wir bekommen, was unsere Funktion zurückgibt. <br><br> <code><br> sls invoke local -f [fn_name] <br></code> <br>  <b>Option 2. Starten Sie Lambda lokal serverlos-offline</b> <br><br>  Vergessen Sie nicht, wir machen eine isomorphe Anwendung, es wird HTML und CSS sein, daher ist es im Terminal irgendwie nicht sehr interessant, lange HTML-Zeilen zu betrachten.  Dort können Sie überprüfen, ob die Funktion funktioniert.  Aber ich möchte dies ausführen und im Browser rendern.  Dementsprechend brauche ich ein paar API-Gateways mit Lambda. <br><br>  Zu diesem Zweck gibt es ein separates Plugin ohne Server und Offline, das Ihr Lambda an einem Port startet (dies ist geschrieben). Anschließend wird im Terminal eine URL angezeigt, über die Sie darauf zugreifen können. <br><br> <code>sls offline --port 8000 start <br></code> <br>  Das Beste daran ist, dass es heißes Nachladen gibt.  Das heißt, Sie schreiben den Funktionscode, aktualisieren Ihren Browser und Sie werden aktualisiert, was die Funktion zurückgibt.  Sie müssen nicht alles neu starten. <br><br>  Dies war eine Zusammenfassung des ersten Teils des Berichts.  Nun gehen wir zum Hauptteil über. <br><br><h2>  Teil 2. Rendern mit AWS </h2><br>  Das unten beschriebene Projekt ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits</a> auf GitHub.  Wenn Sie interessiert sind, können Sie den Code dort herunterladen. <br><br>  Beginnen wir damit, wie alles funktioniert. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/f9d/a97/f03f9da976ac1723c15aad19dd631689.png"><br><br>  Angenommen, es gibt einen Benutzer - mich. <br><br><ul><li>  Ich öffne die Seite. <br></li><li>  Unter einer bestimmten URL greifen wir auf die Gateway-API zu.  Ich möchte darauf hinweisen, dass die Gateway-API bereits ein AWS-Service ist, wir befinden uns bereits in den Clouds. <br></li><li>  Die Gateway-API ruft Lambda auf. <br></li><li>  Das Lambda rendert die Site und all dies kehrt zum Browser zurück. <br></li><li>  Der Browser beginnt zu rendern und stellt fest, dass einige statische Dateien fehlen.  Dann wendet er sich dem S3-Bucket zu (unserem Dateisystem, in dem wir alle statischen Daten speichern; im S3-Bucket können Sie alles einfügen - Schriftarten, Bilder, CSS, JS). <br></li><li>  Daten aus dem S3-Bucket werden an den Browser zurückgegeben. <br></li><li>  Der Browser rendert die Seite. <br></li><li>  Jeder ist glücklich. <br></li></ul><br>  Lassen Sie uns einen kleinen Codeüberblick über das machen, was ich geschrieben habe. <br><br>  Wenn Sie zu GitHub gehen, sehen Sie die folgende Dateistruktur: <br><br> <code><b>lambda-react</b> <br> README.md <br> <b>config <br> package.json</b> <br> public <br> scripts <br> <b>serverless.yml <br> src</b> <br> yarn.lock <br></code> <br>  All dies wird automatisch im React / Redux-Toolkit generiert.  In der Tat werden wir hier nur an ein paar Dateien interessiert sein und sie müssen leicht korrigiert werden: <br><br><ul><li>  config <br></li><li>  package.json <br></li><li>  serverless.yml - weil wir bereitstellen werden, <br></li><li>  src - nirgendwo ohne. <br></li></ul><br><h3>  Beginnen wir mit der Konfiguration </h3><br>  Um alles auf dem Server zusammenzubringen, müssen wir eine weitere webpack.config hinzufügen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c0/990/786/6c099078652d80adcdcb70518187644f.png"><br><br>  Diese webpack.config wird bereits für Sie generiert, wenn Sie eine Vorlage verwenden.  Und dort wird die Variable <code>slsw.lib.entries</code> automatisch ersetzt, die auf Ihre Lambda-Handler <code>slsw.lib.entries</code> .  Wenn Sie möchten, können Sie es selbst ändern, indem Sie etwas anderes angeben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/535/90e/c6a/53590ec6ae4247d42bab7deca58a0b62.png"><br><br>  Wir müssen alles für den Knoten rendern ( <code>target: 'node'</code> ).  Grundsätzlich bleiben alle anderen Lader die gleichen wie bei einer regulären React-Anwendung. <br><br><h3>  Weiter zu package.json </h3><br>  Wir werden nur ein paar Skripte hinzufügen - Start und Build wurden bereits mit React / Redux generiert - nichts ändert sich.  Fügen Sie ein Skript zum Starten des Lambda und ein Skript zum Bereitstellen des Lambda hinzu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e2/822/8c4/4e28228c43ebd1548ff77f0f2d3421a2.png"><br><br><h3>  serverless.yml </h3><br>  Eine sehr kleine Datei - nur 17 Zeilen, alle unten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c5/404/6fa/0c54046fa5a2461532d6f7638aaf650b.png"><br><br>  Was interessiert uns daran?  Zuallererst Handler.  Dort wird der vollständige Pfad zur Datei <code>src/lambda/handler</code> ( <code>src/lambda/handler</code> ) und die Handlerfunktion wird durch den Punkt angegeben. <br><br>  Wenn Sie wirklich möchten, können Sie mehrere Handler in einer Datei registrieren.  Auch hier ist der Weg zum Webpack, der all dies sammeln soll.  Grundsätzlich alles: Der Rest wird bereits automatisch generiert. <br><br><h3>  Das interessanteste ist src </h3><br>  Hier ist eine riesige React / Redux-Anwendung (in meinem Fall ist sie nicht riesig - auf die Seite).  Im zusätzlichen Lambda-Ordner finden Sie alles, was wir zum Rendern des Lambda benötigen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f4/b29/61a/3f4b2961a0c6f9218b715d6f013c53bf.png"><br><br>  Dies sind 2 Dateien: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f10/df3/485/f10df348528805e990f1d781a2406226.png"><br><br>  Beginnen wir mit dem Handler.  Das wichtigste ist Zeile 13.  Dies ist der Renderer, der genau das Lambda ist, das in den Wolken genannt wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3dd/d02/4a2/3ddd024a27fe4ccd1d919885f56f1009.png"><br><br>  Wie Sie sehen können, gibt die Funktion <code>render ()</code> ein Versprechen zurück, von dem alle Ausnahmen abgefangen werden müssen.  Dies ist die Besonderheit des Lambda, andernfalls endet das Lambda nicht sofort, sondern funktioniert bis zum Timeout.  Sie müssen zusätzliches Geld für einen Code bezahlen, der bereits gefallen ist.  Um dies zu verhindern, müssen Sie das Lambda so früh wie möglich beenden - zunächst alle Ausnahmen abfangen und behandeln.  Wir werden später darauf zurückkommen. <br><br>  Wenn wir keine Fehler oder Ausnahmen haben, rufen wir die Funktion <code>createResponse</code> , die buchstäblich fünf Zeilen umfasst.  Wir fügen einfach alle Header hinzu, damit sie im Browser korrekt gerendert werden: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c3/15c/025/1c315c025f85e3d63a70a9843cb0a8d3.png"><br><br>  Das Interessanteste hier ist die <code>render</code> , mit der unsere Seite gerendert wird: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3d/336/0b8/d3d3360b83d7d5c329c5177719029ba8.png"><br><br>  Diese Funktion kommt von renderer.js zu uns.  Mal sehen, was da ist. <br><br>  Dort wird eine isomorphe Anwendung gerendert.  Darüber hinaus wird es auf jedem Server gerendert - es spielt keine Rolle, ob es sich um Lambda handelt oder nicht. <br><br>  Ich werde Ihnen nicht im Detail sagen, was eine isomorphe Anwendung ist, wie man sie rendert, da dies ein völlig anderes Thema ist und es Leute gibt, die es besser gesagt haben als ich.  Hier sind einige Tutorials, die ich durch Googeln in nur wenigen Minuten gefunden habe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e3/366/3d0/1e33663d08624d7649ae4cb084571b98.png"><br><br>  Wenn Sie andere Berichte kennen, können Sie raten, ich werde auf meinem Twitter Links zu ihnen geben. <br><br>  Um niemanden zu verlieren, gehe ich einfach nach oben und erzähle, was dort passiert. <br>  Zunächst müssen wir dies mit HTML / React / Redux rendern. <br><br>  Dies erfolgt über die Standardmethode React - <code>renderToString</code> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/69f/3e8/81f69f3e89005f3ff76e389a65a6d731.png"><br><br>  Als nächstes müssen wir Stile rendern, damit unser Inhalt nicht blinkt.  Dies ist keine sehr triviale Aufgabe.  Es gibt mehrere npm-Pakete, die das Problem lösen.  Zum Beispiel habe ich <code>node-style-loader</code> , der alles in <code>styleTag</code> , und dann können Sie es in HTML einfügen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/509/827/653/509827653575b822318cc8746c893b1b.png"><br><br>  Wenn es bessere Pakete gibt, liegt es in Ihrem Ermessen. <br><br>  Als nächstes müssen wir den Redux-Status übergeben.  Da Sie auf dem Server rendern, möchten Sie wahrscheinlich einige Daten abrufen, und Sie möchten nicht, dass Redux sie erneut fragt und erneut rendert.  Dies ist eine ziemlich normale Aufgabe.  Auf der Redux-Hauptwebsite finden Sie Beispiele dazu: Wir erstellen ein Objekt und übergeben es dann über eine globale Variable: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/732/726/151/7327261516c4747f0994c83f5237668b.png"><br>  Jetzt etwas näher am Lambda. <br><br>  Es ist notwendig, eine Fehlerbehandlung durchzuführen.  Wir wollen alles fangen und etwas mit ihnen machen, zumindest die Entwicklung von Lambda stoppen.  Zum Beispiel habe ich dies durch <code>promise</code> getan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe4/eb4/827/fe4eb4827fd43e48c17a84767612da2d.png"><br><br>  Als nächstes müssen wir unsere URLs durch statische Dateien ersetzen.  Und dafür müssen wir herausfinden, wo das Lambda läuft - lokal oder irgendwo in den Wolken.  Wie finde ich es heraus? <br><br>  Wir werden dies durch Umgebungsvariablen tun: <br><br> <code><br> <br> … <br> const bundleUrl = process.env.NODE_ENV === 'AWS' ? <br> AWS_URL : LOCAL_URL; <br></code> <br>  Eine interessante Frage: Wie kommen Umgebungsvariablen in einem Lambda zusammen?  Eigentlich einfach genug.  In yml können Sie beliebige Variablen an die <code>environment</code> .  Wenn es gesperrt ist, sind sie verfügbar: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bf/a6d/083/6bfa6d083ab79f39cf033342e7e1cec6.png"><br><br>  Nun, ein Bonus - nachdem wir ein Lambda bereitgestellt haben, möchten wir alle statischen Assets bereitstellen.  Zu diesem Zweck haben wir bereits ein Plugin geschrieben, in dem Sie den S3-Warenkorb festlegen können, in dem Sie etwas bereitstellen möchten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/784/43d/2a3/78443d2a3bcfbf351429efa9f98e9965.png"><br>  Insgesamt haben wir in etwa fünf Minuten eine isomorphe Anwendung durchgeführt, um zu zeigen, dass dies alles einfach ist. <br><br>  Lassen Sie uns nun ein wenig über die Theorie sprechen - die Vor- und Nachteile von Lambda. <br><br>  Beginnen wir mit dem Bösen. <br><br><h3>  Nachteile Lambda-Funktionen </h3><br>  Die Minuspunkte können die Zeit eines Kaltstarts enthalten (oder auch nicht).  Für das Lambda auf Node.js, das wir gerade schreiben, bedeutet die Kaltstartzeit beispielsweise nicht viel. <br><br>  Die folgende Grafik zeigt die Kaltstartzeit.  Dies kann eine große Sache sein, insbesondere für Java und C # (achten Sie auf die orangefarbenen Punkte). Sie möchten nicht, dass die Ausführung des Codes nur fünf bis sechs Sekunden dauert. <br><br>  Für Node.js beträgt die Startzeit fast Null - 30 - 50 ms.  Für einige kann dies natürlich auch ein Problem sein.  Die Funktionen können jedoch aufgewärmt werden (obwohl dies nicht das Thema dieses Berichts ist).  Wenn jemand daran interessiert ist, wie diese Tests durchgeführt wurden, willkommen bei acloud.guru, wird er Ihnen alles erzählen ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Artikel</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/11b/185/cb711b1856839c3b9ee9d0a268e0b4cc.png"><br><br>  Was sind die Nachteile? <br><br><h3>  Größenbeschränkungen des Funktionscodes </h3><br>  Der Code muss kleiner als 50 MB sein.  Ist es möglich, eine so große Funktion zu schreiben?  Bitte vergessen Sie nicht node_modules.  Wenn Sie etwas verbinden, insbesondere wenn dort Binärdateien vorhanden sind, können Sie selbst bei Zip-Dateien problemlos über 50 MB übertragen.  Ich habe solche Fälle gehabt.  Dies ist jedoch ein zusätzlicher Grund, um zu sehen, was Sie mit node_modules verbinden. <br><br><h3>  Laufzeitbeschränkungen </h3><br>  Standardmäßig wird die Funktion für eine Sekunde ausgeführt.  Wenn es nicht nach einer Sekunde endet, haben Sie eine Zeitüberschreitung.  Diese Zeit kann jedoch in den Einstellungen erhöht werden.  Beim Erstellen einer Funktion können Sie den Wert auf fünf Minuten einstellen.  Fünf Minuten sind eine harte Frist.  Dies ist kein Problem für die Website.  Wenn Sie jedoch etwas Interessanteres an Lambdas tun möchten, z. B. Bilder verarbeiten, Text in Ton oder Ton in Text konvertieren usw., können solche Berechnungen leicht mehr als fünf Minuten dauern.  Und das wird ein Problem sein.  Was tun?  Lambda optimieren oder nicht verwenden. <br><br>  Eine weitere interessante Sache, die sich im Zusammenhang mit der Frist für die Ausführung von Lambda ergibt.  Erinnern Sie sich an das Layout unserer Website.  Alles funktionierte perfekt, bis das Produkt kam und auf der Website Echtzeit-Feeds wünschte - um Nachrichten in Echtzeit anzuzeigen.  Wir wissen, dass dies mit WebSockets implementiert wird.  WebSockets funktionieren jedoch fünf Minuten lang nicht. Sie müssen länger aufbewahrt werden.  Und hier wird das Fünf-Minuten-Limit zum Problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a3/baa/e78/4a3baae784a50a373e56e5e3652187c9.png"><br><br>  Eine kleine Bemerkung.  Für AWS ist dies kein Problem mehr.  Sie fanden heraus, wie sie das umgehen konnten.  Aber im Allgemeinen ist Lambda keine Lösung für Sie, sobald Web-Sockets erscheinen.  Sie müssen wieder zu den guten alten Servern wechseln. <br><br><h3>  Die Anzahl der parallelen Funktionen pro Minute </h3><br>  Oben ist ein Limit von 500 bis 3.000, abhängig von der Region, in der Sie sich befinden.  Meiner Meinung nach werden in Europa fast 500. 3000 in den USA unterstützt. <br><br>  Wenn Sie eine ausgelastete Site haben und mehr als dreitausend Anfragen pro Minute erwarten (was leicht vorstellbar ist), wird dies zu einem Problem.  Aber bevor wir über dieses Minus sprechen, lassen Sie uns ein wenig darüber sprechen, wie Lambda skaliert. <br><br>  Eine Anfrage kommt zu uns und wir bekommen ein Lambda.  Während dieses Lambda ausgeführt wird, kommen zwei weitere Anfragen zu uns - wir starten zwei weitere Lambdas.  Die Leute kommen auf unsere Seite, Anfragen erscheinen und Lambdas werden immer mehr gestartet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a1/58e/a49/4a158ea4922c44333fbe590440dde1b3.png"><br><br>  Dabei zahlen Sie für die Zeit, in der das Lambda läuft.  Angenommen, Sie zahlen einen Cent für eine Sekunde Lambda-Ausführung.  Wenn Sie 10 Lambdas pro Sekunde haben, zahlen Sie 10 Cent für diese Sekunde.  Wenn Sie eine Million Lambdas pro Sekunde haben, sind das ungefähr 10 Tausend Dollar.  Unangenehme Figur. <br><br>  Aus diesem Grund hat AWS entschieden, dass Ihre Brieftasche nicht in einer Sekunde geleert werden soll, wenn Sie Ihre Tests falsch durchgeführt haben und DDOS selbst gestartet haben, was zu Lambdas geführt hat, oder wenn jemand anderes gekommen ist, um DDOS auszuführen.  Daher wurde ein Limit von dreitausend festgelegt, damit Sie die Möglichkeit haben, auf die Situation zu reagieren. <br><br>  Wenn Sie regelmäßig 3000 Anforderungen laden, können Sie in AWS schreiben, wodurch das Limit erhöht wird. <br><br><h3>  Staatenlos </h3><br>  Dies ist wieder das letzte umstrittene Minus. <br><br>  Was ist staatenlos?  Hier kommt ein Witz über Goldfische auf - sie halten einfach nicht den Kontext: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b03/c26/620/b03c26620417a57fec13f48b896c7ef9.png"><br><br>  Das Lambda, das zum zweiten Mal angerufen wird, weiß nichts über den ersten Anruf. <br><br>  Lassen Sie mich Ihnen ein Beispiel zeigen.  Nehmen wir an, ich habe ein System - eine große Black Box.  Und dieses System kann unter anderem SMS senden. <br><br>  Der Benutzer kommt und sagt: SMS-Vorlage Nummer 1 senden. Und das System sendet sie an ein reales Gerät. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad0/1e9/dea/ad01e9dead7ca1c6a23788c5179f1b3f.png"><br><br>  Irgendwann drückt das Produkt den Wunsch aus, herauszufinden, was dort hingehen wird, und zu überprüfen, ob in diesem System nirgendwo etwas kaputt gegangen ist.  Dazu ersetzen wir das reale Gerät durch eine Testnummer - beispielsweise kann Twilio dies tun.  Er wird Webhook anrufen, den SMS-Text senden, wir werden diesen SMS-Text in der Anwendung verarbeiten (wir müssen überprüfen, ob unsere Vorlage die richtige SMS geworden ist). <br><br>  Um dies zu überprüfen, müssen wir wissen, was gesendet wurde - wir werden dies über eine Testanwendung tun.  Es bleibt zu vergleichen und die Ergebnisse anzuzeigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5be/881/81f/5be88181fc05100d0f9000d2eb3be124.png"><br><br>  Versuchen wir, dasselbe mit Lambda zu tun. <br><br>  Lambda wird SMS senden, SMS wird zu Twilio kommen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bce/e3d/499/bcee3d4993dc73090829810748f97ea4.png"><br><br>  Ich habe die gestrichelte Linie nicht zufällig gezogen, da SMS in Minuten, Stunden oder Tagen zurückgehen können - dies hängt von Ihrem Netzbetreiber ab, dh, dies ist kein synchroner Anruf.  Zu diesem Zeitpunkt wird das Lambda alles vergessen und wir können keine SMS mehr abrufen. <br><br>  Ich würde sagen, dass dies kein Minus ist, sondern ein Feature.  Das Schema kann wiederholt werden.  Es gibt verschiedene Möglichkeiten, dies zu tun, ich werde meine eigenen anbieten.  Wenn wir zustandslos sind und etwas speichern möchten, müssen wir definitiv Speicher verwenden, zum Beispiel eine Datenbank, S3, aber alles, was unseren Kontext speichert. <br><br>  Im Schema mit dem SMS-Speicher wird es an die Testnummer gesendet.  Und wenn Webhook es aufruft - ich schlage vor, zum Beispiel das zweite Lambda aufzurufen, da dies eine etwas andere Funktion ist.  Und das zweite Lambda kann bereits das SMS-ku, das aus der Datenbank stammt, abholen, überprüfen und die Ergebnisse anzeigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/fdc/2c3/d7ffdc2c3761dbadd4d2500daadd68db.png"><br><br>  Bingo! <br><br>     ,     ,   .   ,    node.js    express-.     ,     .  ,   ,   ,   — .   ? <br><br> ,    ,     .   —    . , -,   .   ,    ,        .      ,   ,   AWS ,       . AWS   ,     ,   .   . -,  node   ,  Java     12-15 .   ,      ,           .   -  node cache —     .. —     ,    .      ,      ,      .   . <br><br><h3>  - </h3><br>  ,      . <br><br><ul><li>      ,   .  ,     javascript,  .  ,        javascript-,        . <br></li><li>      ,   ,   . ,   ,  .   ,             . <br></li><li>    AWS- —            (DynamoDB, Alexa, API Gateway,  . .). <br></li></ul><br><h3>      ? </h3><br>      —      ,       ,   REST API.        ,     ,         . <br><br>  ,     ,  …  . <br><br><ul><li> HTTP Services —     . REST API,  API endpoint —  .   .    ,   enterprise   node.js   middleware.    java,    ,     js ,     .         . <br></li><li> IoT — ,   Alexa      - -,         ,  . <br></li><li> Chat Bots —    ,   IoT. <br></li><li> Image/Video conversions. <br></li><li> Machine learning. <br></li><li> Batch Jobs — -  ,  Batch Job     . <br></li></ul><br>   Amazon, Google, Azure, IBM, Twillio —         cloud functions.     ,               .     open source (      ,  open source — ).  open source    .        .         — Docker Swarm, Kubernetes —    . <br><br>  , , -,      .       AWS   ,    open source    . <br><br>      .      .   :         : <br><br><ul><li> Iron functions <br></li><li> Fnproject <br></li><li> Openfaas <br></li><li> Apache OpenWhisk <br></li><li> Kubeless <br></li><li> Fission <br></li><li> Funktion <br></li></ul><br>   Fnproject     ,       Fnproject       Kubernetes-. <br><br>     .     API Gateway (,   ),     URL,   .          ,   ,   ,          Kubernetes,       . <br><br><blockquote>  .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>  HolyJS 2018 Moscow,   24-25   .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>      ,     Early Bird-. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417943/">https://habr.com/ru/post/de417943/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417933/index.html">Sicherheitswoche 27: Gefälschtes iPhone und Sicherheitspreis</a></li>
<li><a href="../de417935/index.html">Memos zu künstlicher Intelligenz, maschinellem Lernen, Deep Learning und Big Data</a></li>
<li><a href="../de417937/index.html">Machen "eiserne" Leute Software?</a></li>
<li><a href="../de417939/index.html">Optimierung des Renderns einer Szene aus dem Disney-Cartoon "Moana". Teile 4 und 5</a></li>
<li><a href="../de417941/index.html">Wo verschwindet das Wasser im Wasserkocher?</a></li>
<li><a href="../de417945/index.html">Welche Werkzeuge hat die Parker-Sonde?</a></li>
<li><a href="../de417947/index.html">Datenvisualisierung für Ihr Webprojekt</a></li>
<li><a href="../de417949/index.html">Wie habe ich die Standard-C ++ 11-Bibliothek geschrieben oder warum ist Boost so beängstigend? Kapitel 4.2</a></li>
<li><a href="../de417951/index.html">Schreiben von Java-freundlichem Kotlin-Code</a></li>
<li><a href="../de417953/index.html">Trends beim Design von FPGAs. Übersetzung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>