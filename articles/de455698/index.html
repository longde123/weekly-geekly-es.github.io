<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧝🏾 ⏰ 👩🏽‍🔧 Das Buch "Wie JavaScript funktioniert" 🧛🏻 👨🏻‍🎨 🅰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die meisten Programmiersprachen sind aus einem alten Paradigma hervorgegangen, das zu Fortrans Zeiten stammt. Der JavaScript-Guru Douglas Crockford en...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Wie JavaScript funktioniert"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/455698/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/9u/n9/3z/9un93z79xbk2sybh806isswhjxw.jpeg" align="left" alt="Bild"></a>  Die meisten Programmiersprachen sind aus einem alten Paradigma hervorgegangen, das zu Fortrans Zeiten stammt.  Der JavaScript-Guru Douglas Crockford entwurzelt diese getrockneten Wurzeln und ermöglicht es uns, über die Zukunft der Programmierung nachzudenken und die Anforderungen für die nächste Sprache auf eine neue Ebene zu verstehen. <br><br>  Der Autor beginnt mit den Grundlagen: Namen, Zahlen, logische Werte, Zeichen und andere grundlegende Informationen.  Sie lernen nicht nur die Probleme und Schwierigkeiten bei der Arbeit mit Typen in JavaScript kennen, sondern auch, wie Sie diese umgehen können.  Anschließend lernen Sie Datenstrukturen und -funktionen kennen, um die ihnen zugrunde liegenden Mechanismen zu verstehen, und lernen, wie Sie Funktionen höherer Ordnung und einen objektorientierten Programmierstil ohne Klassen verwenden. <br><a name="habracut"></a><br><h3>  Auszug <br>  Wie Code ohne Klassen funktioniert </h3><br>  Und du denkst, dass du außerhalb aller Klassen klug und frei bist. <br>  <i>John Lennon</i> <br><br>  Eine der Schlüsselideen bei der Entwicklung der objektorientierten Programmierung war ein Modell für den Datenaustausch zwischen Programmteilen.  Der Name der Methode und ihre Argumente müssen in Form von Nachrichten dargestellt werden.  Ein Methodenaufruf sendet eine Nachricht an das Objekt.  Jedes Objekt zeichnet sich durch ein eigenes Verhalten aus, das sich beim Empfang bestimmter Nachrichten manifestiert.  Der Absender glaubt, dass der Empfänger weiß, was mit der Nachricht zu tun ist. <br><br>  Ein zusätzlicher Vorteil ist der Polymorphismus.  Jedes Objekt, das eine bestimmte Nachricht erkennt, hat das Recht, sie zu empfangen.  Was als nächstes passiert, hängt von der Spezialisierung des Objekts ab.  Und das ist ein sehr produktiver Gedanke. <br><br>  Leider wurden wir durch die Vererbung abgelenkt - ein sehr effektives Schema für die Wiederverwendung von Code.  Ihre Bedeutung hängt mit der Fähigkeit zusammen, die Arbeitskosten bei der Entwicklung eines Programms zu senken.  Die Vererbung basiert auf einem ähnlichen Plan, mit Ausnahme einiger Nuancen.  Wir können sagen, dass ein Objekt oder eine Klasse von Objekten einem anderen Objekt oder einer anderen Klasse von Objekten ähnlich ist, aber es gibt einige wichtige Unterschiede.  In einer einfachen Situation funktioniert alles super.  Es sei daran erinnert, dass das moderne OOP mit Smalltalk begann, einer Programmiersprache für Kinder.  Wenn die Situation komplizierter wird, wird die Vererbung problematisch.  Es entsteht ein starker Zusammenhalt der Klassen.  Das Ändern einer Klasse kann in den davon abhängigen Klassen zu Fehlern führen.  Module aus Klassen sind einfach nutzlos. <br><br>  Darüber hinaus beobachten wir eine erhöhte Aufmerksamkeit für Eigenschaften und nicht für Objekte.  Besonderes Augenmerk wird auf die Methoden zum Abrufen (get-Methoden) und Zuweisen (set-Methoden) von Werten zu jeder einzelnen Eigenschaft gelegt. In noch weniger erfolgreichen Projekten sind die Eigenschaften offen und können ohne Kenntnis des Objekts geändert werden.  Es ist möglich, ein erfolgreicheres Projekt einzuführen, bei dem Eigenschaften ausgeblendet werden und Methoden Transaktionen verarbeiten, die sich nicht nur mit Eigenschaftsänderungen befassen.  Dieser Ansatz wird jedoch nicht oft angewendet. <br><br>  Darüber hinaus besteht eine zu große Typabhängigkeit.  Typen wurden zu einem Merkmal von Fortran und späteren Sprachen, da sie für die Compiler-Ersteller praktisch waren.  Seitdem ist die Mythologie um Typen gewachsen und hat extravagante Behauptungen aufgestellt, dass Typen das Programm vor Fehlern schützen.  Trotz der Hingabe an Typen verließen Fehler nicht die tägliche Praxis. <br><br>  Typen werden respektiert und für die Früherkennung von Fehlkalkulationen in der Kompilierungsphase gelobt.  Je früher ein Versehen entdeckt wird, desto geringer sind die Kosten, um es zu beseitigen.  Bei ordnungsgemäßem Testen des Programms werden all diese Fehlkalkulationen jedoch sehr schnell erkannt.  Daher werden Typidentifikationsfehler als kostengünstig eingestuft. <br><br>  Typen sind nicht für das Auftreten schwer zu erkennender und kostspieliger Fehler verantwortlich.  Ihr Fehler liegt nicht im Auftreten von Problemen, die durch solche Fehler verursacht werden und einige Tricks erfordern.  Typen können uns dazu bringen, obskure, verwirrende und zweifelhafte Programmiermethoden zu verwenden. <br><br>  Typen sind wie eine Diät zur Gewichtsreduktion.  Diät wird nicht der Rückkehr und Gewichtszunahme beschuldigt.  Sie wird auch nicht als Ursache des Leidens oder der von ihr verursachten Gesundheitsprobleme angesehen.  Diäten geben Hoffnung, dass das Gewicht zu einer gesunden Norm zurückkehren wird und wir weiterhin Junk Food essen werden. <br><br>  Die klassische Vererbung lässt uns glauben, dass wir qualitativ hochwertige Programme erstellen, während wir mehr Fehler machen und immer ineffizientere Vererbungen anwenden.  Wenn Sie die negativen Manifestationen ignorieren, scheinen die Typen ein großer Sieg zu sein.  Die Vorteile liegen auf der Hand.  Wenn Sie sich die Typen jedoch genauer ansehen, werden Sie feststellen, dass die Kosten den Nutzen übersteigen. <br><br><h3>  Konstruktor </h3><br>  In Kapitel 13 haben wir mit Fabriken gearbeitet - Funktionen, die Funktionen zurückgeben.  Jetzt können wir mit Konstruktoren etwas Ähnliches tun - Funktionen, die Objekte zurückgeben, die Funktionen enthalten. <br><br>  Beginnen wir mit der Erstellung von counter_constructor, ähnlich dem Zählergenerator.  Es gibt zwei Methoden: Auf und Ab: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counter_constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ counter += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">down</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ counter -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze({ up, down }); }</code> </pre> <br>  Das zurückgegebene Objekt wird eingefroren.  Es kann nicht beschädigt oder beschädigt werden.  Das Objekt hat einen Zustand.  Der variable Zähler ist eine private Eigenschaft des Objekts.  Sie können nur über Methoden darauf zugreifen.  Und das brauchen wir nicht zu benutzen. <br><br>  Dies ist ein sehr wichtiger Umstand.  Die Objektschnittstelle besteht ausschließlich aus Methoden.  Er hat eine sehr starke Schale.  Wir bekommen die beste Kapselung.  Es gibt keinen direkten Zugriff auf Daten.  Dies ist ein sehr hochwertiger modularer Aufbau. <br><br>  Ein Konstruktor ist eine Funktion, die ein Objekt zurückgibt.  Die Parameter und Konstruktorvariablen werden zu privaten Eigenschaften des Objekts.  Es hat keine öffentlichen Eigenschaften, die aus Daten bestehen.  Interne Funktionen werden zu Objektmethoden.  Sie verwandeln Eigenschaften in geschlossene.  Methoden, die in ein eingefrorenes Objekt fallen, sind offen. <br><br>  Methoden müssen Transaktionen implementieren.  Nehmen wir zum Beispiel an, wir haben ein Personenobjekt.  Möglicherweise müssen Sie die Adresse der Person ändern, deren Daten darin gespeichert sind.  Dazu benötigen Sie keine separaten Funktionen zum Ändern jedes einzelnen Adresselements.  Wir benötigen eine Methode, die ein Objektliteral empfängt und alle Teile der Adresse beschreiben kann, die geändert werden müssen. <br><br>  Eine der brillanten Ideen in JavaScript ist das Objektliteral.  Dies ist eine nette und ausdrucksstarke Syntax zum Clustering von Informationen.  Durch das Erstellen von Methoden, die Datenobjekte verbrauchen und erstellen, können Sie die Anzahl der Methoden reduzieren und dadurch die Integrität des Objekts erhöhen. <br><br>  Es stellt sich heraus, dass wir zwei Arten von Objekten haben. <br><br><ul><li>  Harte Objekte enthalten nur Methoden.  Diese Objekte schützen die Integrität der im Abschluss enthaltenen Daten.  Sie versorgen uns mit Polymorphismus und Einkapselung. </li><li>  Soft Data-Objekte enthalten nur Daten.  Sie haben kein Verhalten.  Dies ist nur eine praktische Sammlung, mit der Funktionen arbeiten können. </li></ul><br>  Es wird angenommen, dass OOP zunächst Verfahren zu Datensätzen in der Kobol-Sprache hinzufügte, um so ein Verhalten sicherzustellen.  Ich glaube, dass die Kombination von Datenmethoden und Eigenschaften ein wichtiger Schritt nach vorne war, aber nicht der letzte Schritt sein sollte. <br><br>  Wenn das harte Objekt in eine Zeichenfolge konvertiert werden muss, muss die toJSON-Methode aktiviert sein.  Andernfalls sieht JSON.stringify es als leeres Objekt an und ignoriert Methoden und versteckte Daten (siehe Kapitel 22). <br><br><h3>  Konstruktoroptionen </h3><br>  Einmal habe ich einen Konstruktor erstellt, der zehn Argumente akzeptiert.  Es war sehr schwierig zu verwenden, da sich niemand an die Reihenfolge der Argumente erinnern konnte.  Später wurde bemerkt, dass niemand das zweite Argument verwendete. Ich wollte es aus der Liste der Parameter entfernen, aber das würde den gesamten bereits entwickelten Code beschädigen. <br><br>  Wenn ich umsichtig wäre, hätte ich einen Konstruktor, der ein Objekt als Parameter verwendet.  Es stammt normalerweise aus einem Objektliteral, kann aber auch aus anderen Quellen stammen, z. B. aus JSON-Inhalten. <br><br>  Dies würde viele Vorteile bieten. <br><br><ul><li>  Schlüsselzeilen geben dem Code ein dokumentiertes Aussehen.  Der Code ist einfacher zu lesen, da er Ihnen sagt, was jedes Argument für den Aufrufer ist. </li><li>  Argumente können in beliebiger Reihenfolge angeordnet werden. </li><li>  In Zukunft können Sie neue Argumente hinzufügen, ohne den vorhandenen Code zu beschädigen. </li><li>  Irrelevante Parameter können ignoriert werden. </li></ul><br>  Am häufigsten wird ein Parameter verwendet, um eine private Eigenschaft zu initialisieren.  Dies geschieht wie folgt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_little_constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spec</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> { name, mana_cost, colors, type, supertypes, types, subtypes, text, flavor, power, toughness, loyalty, timeshifted, hand, life } = spec;</code> </pre> <br>  Dieser Code erstellt und initialisiert 15 private Variablen unter Verwendung von Eigenschaften mit denselben Namen aus spec.  Wenn spec keine entsprechende Eigenschaft hat, wird eine neue Variable initialisiert, der der undefinierte Wert zugewiesen wird.  Auf diese Weise können Sie alle fehlenden Werte mit Standardwerten füllen. <br><br><h3>  Zusammensetzung </h3><br>  Die lebendige Ausdruckskraft und Effektivität von JavaScript ermöglicht es Ihnen, Programme im klassischen Paradigma zu erstellen, obwohl diese Sprache nicht für die klassischen gilt.  JavaScript ermöglicht auch Verbesserungen.  Wir können mit einer funktionalen Zusammensetzung arbeiten.  Anstatt also ausnahmsweise etwas hinzuzufügen, können Sie ein wenig von diesem und jenem bekommen.  Der Konstruktor hat das folgende allgemeine Erscheinungsbild: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_little_constructor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spec</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {} = spec; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _ = other_constructor(spec); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>  = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   spec, , _,  }; return Object.freeze({ , _. }); }</span></span></code> </pre> <br>  Ihr Konstruktor kann beliebig viele andere Konstruktoren aufrufen, um Zugriff auf die Statusverwaltung und das von ihnen bereitgestellte Verhalten zu erhalten.  Sie können ihm sogar genau das gleiche Spezifikationsobjekt übergeben.  Durch die Dokumentation der Spezifikationsparameter listen wir die Eigenschaften auf, die von my_little_constructor benötigt werden, und die Eigenschaften, die von anderen Konstruktoren benötigt werden. <br><br>  Manchmal können Sie die resultierenden Methoden einfach einem eingefrorenen Objekt hinzufügen.  In anderen Fällen haben wir neue Methoden, die die empfangenen Methoden aufrufen.  Dies stellt sicher, dass Code ähnlich wie bei der Vererbung wiederverwendet wird, jedoch ohne starken Zusammenhalt.  Ein Funktionsaufruf ist das ursprüngliche Schema für die Wiederverwendung von Code, und es wurde nichts Besseres erfunden. <br><br><h3>  Größe </h3><br>  Bei diesem Ansatz zum Erstellen eines Objekts ist mehr Speicher erforderlich als bei der Verwendung von Prototypen, da jedes starre Objekt alle Methoden des Objekts enthält und das Prototypobjekt eine Verknüpfung zu dem Prototyp enthält, der die Methoden enthält.  Ist der Unterschied im Speicherverbrauch signifikant?  Wenn wir den Unterschied mit den neuesten Errungenschaften bei der Erhöhung der Speicherkapazität vergleichen, können wir sagen: Nein.  Wir sind es gewohnt, Speicher in Kilobyte zu lesen.  Und jetzt betrachten wir es in Gigabyte.  Vor diesem Hintergrund ist der Unterschied überhaupt nicht zu spüren. <br><br>  Der Unterschied kann durch Verbesserung der Modularität verringert werden.  Durch die Betonung auf Transaktionen und nicht auf Eigenschaften können Sie die Anzahl der Methoden reduzieren und gleichzeitig die Konnektivität verbessern. <br><br>  Das klassische Modell zeichnet sich durch Einheitlichkeit aus.  Jedes Objekt muss eine Instanz einer Klasse sein.  JavaScript hebt diese Einschränkungen auf.  Nicht alle Objekte müssen solch strengen Regeln entsprechen. <br><br>  Zum Beispiel glaube ich, dass es keinen Sinn macht, dass Punkte notwendigerweise starre Objekte mit Methoden sind.  Ein Punkt kann ein einfacher Container für zwei oder drei Zahlen sein.  Punkte werden an Funktionen übergeben, die projiziert oder interpoliert werden können, oder an etwas anderes, das mit Punkten ausgeführt werden kann.  Dies kann viel produktiver sein als Unterklassenpunkte, um ihnen ein besonderes Verhalten zu verleihen.  Lass die Funktionen funktionieren. <br><br>  »Weitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  25% Rabatt auf Gutschein für Händler - <b>JavaScript</b> <br><br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455698/">https://habr.com/ru/post/de455698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455684/index.html">Warum haben wir einen Hackathon für Tester durchgeführt?</a></li>
<li><a href="../de455686/index.html">Wie wähle ich das beste Projektmanagement-Tool aus, wenn Sie ein Millennial sind?</a></li>
<li><a href="../de455692/index.html">ASZP: Restyling oder Theater beginnen mit einem Kleiderbügel</a></li>
<li><a href="../de455694/index.html">Abrechnungsarchitektur der nächsten Generation: Übergang zu Tarantool</a></li>
<li><a href="../de455696/index.html">Der elektronische Zustand der Zukunft. Teil 2</a></li>
<li><a href="../de455700/index.html">4 Tricks, die uns geholfen haben, das Frontend zu optimieren</a></li>
<li><a href="../de455702/index.html">Effektive Zahlengenerierung in einem bestimmten Intervall</a></li>
<li><a href="../de455710/index.html">Warum brauchen wir bei Leroy Merlin eine eigene russische Entwicklungsabteilung für 200 Mitarbeiter?</a></li>
<li><a href="../de455714/index.html">Exportieren Sie Google Forms automatisch mit IFTTT und Django nach Notion</a></li>
<li><a href="../de455716/index.html">15 Best Practices für die Bereitstellung von Business Intelligence-Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>