<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë¶üèΩ üêç üèÄ Unreal Engine 4 - brennender Shader üê§ üêÉ üê£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dies ist ein kleiner Shader, der auftauchte, als ich √ºber verschiedene Methoden zum Anwenden von Flowmap nachdachte. Es gibt viele √úbergangs- / Aufl√∂s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unreal Engine 4 - brennender Shader</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435174/">  Dies ist ein kleiner Shader, der auftauchte, als ich √ºber verschiedene Methoden zum Anwenden von Flowmap nachdachte.  Es gibt viele √úbergangs- / Aufl√∂sungseffekte, aber die meisten sehen ziemlich statisch aus, da sie statische Texturen verwenden.  Dieser Shader ist alles andere als perfekt, aber die sanfte Bewegung macht ihn als sanften Brandeffekt optisch attraktiv. <br><br>  Der Shader selbst ist extrem einfach. Im Folgenden werde ich den Prozess der Erstellung beschreiben.  Wie bei den meisten meiner Shader habe ich es in eine Materialfunktion eingewickelt, damit es mit allen vorhandenen Materialien verwendet werden kann. <br><a name="habracut"></a><br><blockquote>  Hinweis  Sie k√∂nnen Bilder in einer neuen Registerkarte √∂ffnen, um sie in h√∂herer Aufl√∂sung anzuzeigen. </blockquote><br><h2>  Texturen </h2><br>  Ich habe die folgenden Texturen im Shader verwendet, die erste ist ein einfaches Rauschen, das im Substanz-Designer erzeugt wird, die zweite ist die Flowmap, die ich mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FlowMap Painter gezeichnet habe</a> . <br><br><img src="https://habrastorage.org/webt/jx/uf/wl/jxufwls-fngk7cs33ak2d2w_ygs.png" width="250"><img src="https://habrastorage.org/webt/ez/7k/dx/ez7kdxvp1psdefjmuup807zicj8.png" width="250"><br><br><h2>  Konfigurieren Sie FlowMap </h2><br>  Flowmapping ist eine Methode, mit der wir als Texturen gespeicherte 2D-Vektoren verwenden, um UV-Texturen im Laufe der Zeit zu verzerren.  Diese Animation wird dann wiederholt, um die Illusion eines Flusses zu erzeugen.  Normalerweise wird dies in Wasserstr√∂men verwendet, um den Eindruck zu erwecken, dass Wasser um Steine ‚Äã‚Äãusw. flie√üt.  Aber nat√ºrlich kann es f√ºr viele andere Dinge verwendet werden.  In meinem Shader verwende ich es, um den Effekt des Brennens von Material zu erzeugen.  Wenn Sie mehr √ºber Flowmap erfahren m√∂chten, empfehle ich, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel √ºber Polycount zu lesen</a> und eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lektion von Simonschreibt</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzusehen</a> , in der er die Arbeit mit Flowmap perfekt erkl√§rt. <br><br>  Meine Einstellungsoption unten <br><br><img src="https://habrastorage.org/webt/s8/es/ds/s8esds_dw0igfmuhfk-yhxhjrhu.png"><br><br>  Wie Sie sehen k√∂nnen, haben wir Optionen zur Steuerung der St√§rke der Verzerrung, der Texturkacheln und auch der Flie√ürichtung. <br><br>  Um den Effekt zu steuern, verwende ich die Ausgabe des roten Kanals aus der Rauschkarte. Wenn Sie sich den Lerp-Knoten ansehen, sehen Sie das folgende Ergebnis: <br><br><img src="https://habrastorage.org/webt/pq/dh/bl/pqdhblmhltr4zvipglbfaenbrcm.gif"><br><br><h2>  Spheremask </h2><br>  Dieser Schritt kann auf verschiedene Arten implementiert werden. Am Ende ben√∂tigt er lediglich einen Gradientenskalenwert, um unseren Effekt zu steuern.  In diesem Fall verwende ich SphereMask, die von der Position des Bauplans gesteuert wird, um unsere Maske zu bewegen.  Durch Verschieben der Blaupause kann ich beeinflussen, welche Bereiche verbrannt werden, und den Radius der Kugel animieren, um einen Verbrennungseffekt zu erzielen.  Wenn Sie lernen m√∂chten, wie Sie eine Reihe von Materialparametern konfigurieren, um die Position von BP auf einen Shader zu √ºbertragen, empfehle ich, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wormhole-Shader zu</a> lesen, in dem ich dies ausf√ºhrlich beschreibe. <br><br>  Das Erstellen von SphereMask ist einfach, da UE4 bereits √ºber eine integrierte Funktion verf√ºgt. <br><br><img src="https://habrastorage.org/webt/ms/qg/q4/msqgq4gyx104d_ycrzgxpyn-gwi.png"><br><br>  In diesem Fall wird der Radius in Weltkoordinaten (Weltraum) angegeben. Um dies zu sehen, versuchen Sie, den Radiuswert zu √§ndern.  Standardm√§√üig ist die Position von SphereMask {0, 0, 0}, sodass Sie feststellen werden, dass die Kugel in der Mitte des Netzes angezeigt wird. <br><br><img src="https://habrastorage.org/webt/cv/_v/ht/cv_vht1pmfsgeorfl0b3jofwili.gif"><br><br>  Der n√§chste Schritt besteht darin, das Ergebnis des Flowmap-Rauschens von SphereMask zu subtrahieren, sodass wir beim Skalieren der Maske ein brennendes Muster erhalten. <br><br><img src="https://habrastorage.org/webt/3l/se/ru/3lserusy-y_3sdo9ewkbwlbtyf4.png"><br><br>  Bitte beachten Sie, dass Sie den Parameter H√§rte von SphereMask konfigurieren k√∂nnen, um die Streuung w√§hrend des √úbergangs zu steuern. <br><table><tbody><tr><th>  H√§rte: 0,2 </th><th>  H√§rte: 0,5 </th></tr><tr><td><img src="https://habrastorage.org/webt/l5/xj/y7/l5xjy7efbd9atagm9jfrv0_psj0.gif"></td><td><img src="https://habrastorage.org/webt/tj/ub/ua/tjubua7ja3lebyil3rqi3feq7yo.gif"></td></tr></tbody></table><br>  Jetzt k√∂nnen wir das Ergebnis nehmen und es mit der Opacity_Mask multiplizieren und die Opacity des Materials an unseren Kanal zur√ºckgeben, um die endg√ºltige Maske zu erhalten. <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/v5/mr/ku/v5mrkut12mm6wc895ia-fqjcemy.png"></td><td><img src="https://habrastorage.org/webt/bp/pu/at/bppuatttd0hjydyckfxaccf-vko.png"></td></tr></tbody></table><br>  Sie k√∂nnen dies auch tun, ohne die Flowmap nur mit einer statischen Textur anzupassen.  Der einzige Unterschied besteht darin, dass Sie mit Flowmap eine fl√ºssigere Animation erzielen.  Unten sehen Sie den Unterschied. <br><table><tbody><tr><th>  mit Flowmap </th><th>  ohne Flowmap </th></tr><tr><td><img src="https://habrastorage.org/webt/to/ta/kb/totakbfj_bsrq_i-i1hbxdewuru.gif"></td><td><img src="https://habrastorage.org/webt/0r/rj/hu/0rrjhuvw8y8rulivh7dswht_6f8.gif"></td></tr></tbody></table><br><h2>  Kantengl√ºhen und Verkohlung </h2><br>  Um brennende Kanten zu erzeugen und einen verkohlten schw√§rzlichen Umriss zu erhalten, verwenden wir die Technik, die ich in vielen meiner Shader verwendet habe, wobei wir den Maskenverlauf auf 0 setzen und mithilfe der Distanzfunktion eine Kantenmaske erstellen. <br><br>  Unten sehen Sie diese Einstellungen.  Das einzige, was hier zu beachten ist, ist, dass wir 0,45 f√ºr die Gl√ºhkontur und 0,5 f√ºr die Karbonisierungskontur w√§hlen, so dass sie relativ zueinander versetzt sind und Karbonisierung um das Gl√ºhen herum auftritt.  Dann erstellen wir einen Parameter aus der Breite, um die Streuung nach Bedarf zu steuern. <br><br><img src="https://habrastorage.org/webt/wd/ew/_w/wdew_wyosh-ozhqfq8wkte7jgau.png"><br><br>  Wenn Sie jedem dieser Knoten eine Vorschau hinzuf√ºgen, wird Folgendes angezeigt <br><table><tbody><tr><th>  Emberglow </th><th>  Verkohlung </th></tr><tr><td><img src="https://habrastorage.org/webt/xt/nm/lz/xtnmlzq_gxtrjeduwdoyprgnlne.gif"></td><td><img src="https://habrastorage.org/webt/hg/zp/fa/hgzpfaddnifikij4buaj1rkkkpo.gif"></td></tr></tbody></table><br>  Jetzt nehmen wir das Ergebnis von EmberGlow und multiplizieren es mit der Farbe der Flamme, f√ºgen es dann der Emissionsfarbe hinzu und geben es an die Eingabe unseres Materials zur√ºck. <br><br><img src="https://habrastorage.org/webt/sn/91/ja/sn91jayhn55dcrqblvuzaz4byoe.png"><br><br>  Alternativ k√∂nnen Sie das Ergebnis aus dem EmberGlow-Abschnitt als diffuse Daten verwenden, um Farben basierend auf dem Verlauf anzuzeigen.  Diese Technik wird als Gradienten-Rendering bezeichnet. UE4 verf√ºgt jetzt √ºber eine CurveAtlass-Funktion, mit der Sie Farbkurven definieren und im Shader darauf zugreifen k√∂nnen.  Denken Sie daran, dass dies eine experimentelle Funktion ist und ich bei dem Versuch, sie in meinen Shadern zu verwenden, auf mehrere Abst√ºrze gesto√üen bin. Ich rate Ihnen daher, sie vorerst nicht zu verwenden. <br><br><img src="https://habrastorage.org/webt/c-/6f/b8/c-6fb8xuf1hmldj09yxs37s03ie.gif"><br><br>  Dann nehmen wir das Ergebnis aus dem Abschnitt Verkohlung und multiplizieren es mit Basecolor aus der Eingabe der Funktion, um den Wert von Final Basecolor zu erhalten. <br><br><img src="https://habrastorage.org/webt/_l/vl/pj/_lvlpjg2t9b4kbuhl8fe6s6u11u.png"><br><br>  Jetzt k√∂nnen Sie sehen, wie die Kanten vor dem Brennen schwarz werden <br><br><img src="https://habrastorage.org/webt/ip/ts/f-/iptsf-gnxzpmw3qv0yhnddirbnq.gif"><br><br>  Hier sind wir fertig. <br><br>  Jetzt der coolste Teil - wir k√∂nnen unsere Blaupause verschieben, um den Brennbereich zu √§ndern.  In einem Spiel k√∂nnen wir beispielsweise die Fackelposition des Spielers verwenden, um diesen Effekt zu steuern.  Infolgedessen sieht es so aus, als w√ºrde etwas verbrannt.  Und wir k√∂nnen den SphereMask-H√§rteparameter und den Radius steuern, um das gew√ºnschte Aussehen zu erhalten.  So sieht es mit verschiedenen Einstellungen aus. <br><br><img src="https://habrastorage.org/webt/6f/hh/s6/6fhhs6ccrzpebja9l7du3lwneyw.gif"><br><br>  Au√üerdem k√∂nnen Sie den Radius so animieren, dass er mit der Zeit ausbrennt. <br><br>  Mit diesem Shader k√∂nnen Sie ein Beispielprojekt aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dem Github-Repository √ºbernehmen</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435174/">https://habr.com/ru/post/de435174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435164/index.html">K√∂nnen Big Data und KI die globale Wasserkrise l√∂sen?</a></li>
<li><a href="../de435166/index.html">Azure-Pr√ºfungen</a></li>
<li><a href="../de435168/index.html">Blutsauger. Programmierer-Klassifizierung</a></li>
<li><a href="../de435170/index.html">Ein Blick auf das Apple Watch EKG f√ºr jemanden, der sich interessiert</a></li>
<li><a href="../de435172/index.html">Oculus GoBlack - wie man Oculus Go verbessert</a></li>
<li><a href="../de435176/index.html">DEFCON 21. Passw√∂rter allein reichen nicht aus, oder warum wird die Festplattenverschl√ºsselung unterbrochen und wie kann dies behoben werden? Teil 1</a></li>
<li><a href="../de435178/index.html">DEFCON 21. Passw√∂rter allein reichen nicht aus, oder warum wird die Festplattenverschl√ºsselung unterbrochen und wie kann dies behoben werden? Teil 2</a></li>
<li><a href="../de435180/index.html">Serverlose REST-API "auf dem Knie in 5 Minuten"</a></li>
<li><a href="../de435182/index.html">Studie: Der HDD-Markt wird bis 2021 um ein Drittel schrumpfen</a></li>
<li><a href="../de435184/index.html">K√ºnstliche Intelligenz lernte 6 Jahre vor der Diagnose, die Alzheimer-Krankheit im Gehirn zu finden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>