<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äç‚öñÔ∏è ‚õ≥Ô∏è üïπÔ∏è Comment ajouter un codec √† FFmpeg üë®üèæ‚Äçüî¨ üìù üé±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="FFmpeg est un grand projet Open Source, une sorte d'encyclop√©die multim√©dia. Avec FFmpeg, vous pouvez r√©soudre un grand nombre de t√¢ches multim√©dia in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment ajouter un codec √† FFmpeg</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480714/"><hr><p>  FFmpeg est un grand projet Open Source, une sorte d'encyclop√©die multim√©dia.  Avec FFmpeg, vous pouvez r√©soudre un grand nombre de t√¢ches multim√©dia informatiques.  Mais encore, il est parfois n√©cessaire d'√©tendre FFmpeg.  La m√©thode standard consiste √† apporter des modifications au code du projet, puis √† compiler la nouvelle version.  L'article d√©taille comment ajouter un nouveau codec.  Certaines fonctionnalit√©s permettant de connecter des fonctions externes √† FFmpeg sont √©galement prises en compte.  Si vous n'avez pas besoin d'ajouter un codec, l'article peut √™tre utile pour mieux comprendre l'architecture des codecs FFmpeg et leurs param√®tres.  Il est suppos√© que le lecteur est familier avec l'architecture de FFmpeg, le processus de compilation de FFmpeg, et a √©galement une exp√©rience de programmation en utilisant l'API FFmpeg.  La description est valable pour FFmpeg 4.2 "Ada", ao√ªt 2019. <br></p><hr><a name="habracut"></a><br><h1>  Table des mati√®res </h1><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text"><p> <a href="https://habr.com/ru/post/480714/">Pr√©sentation</a> <br>  <a href="https://habr.com/ru/post/480714/">1. Identification du codec</a> <br>  <a href="https://habr.com/ru/post/480714/">1.1.</a>  <a href="https://habr.com/ru/post/480714/">Identifiant du codec</a> <br>  <a href="https://habr.com/ru/post/480714/">1.2.</a>  <a href="https://habr.com/ru/post/480714/">Codec</a> <br>  <a href="https://habr.com/ru/post/480714/">2. Ajout d'un nouveau codec √† FFmpeg</a> <br>  <a href="https://habr.com/ru/post/480714/">3. Description d√©taill√©e du contexte et des fonctions requises</a> <br>  <a href="https://habr.com/ru/post/480714/">3.1.</a>  <a href="https://habr.com/ru/post/480714/">Contexte du codec</a> <br>  <a href="https://habr.com/ru/post/480714/">3.2.</a>  <a href="https://habr.com/ru/post/480714/">Les fonctions</a> <br>  <a href="https://habr.com/ru/post/480714/">3.3.</a>  <a href="https://habr.com/ru/post/480714/">Horodatages</a> <br>  <a href="https://habr.com/ru/post/480714/">3.4.</a>  <a href="https://habr.com/ru/post/480714/">Autres fonctions utilis√©es par le codec</a> <br>  <a href="https://habr.com/ru/post/480714/">4. Impl√©mentation externe du codec</a> <br>  <a href="https://habr.com/ru/post/480714/">4.1.</a>  <a href="https://habr.com/ru/post/480714/">Connexion de fonction externe</a> <br>  <a href="https://habr.com/ru/post/480714/">4.2.</a>  <a href="https://habr.com/ru/post/480714/">D√©codeur externe</a> <br>  <a href="https://habr.com/ru/post/480714/">Conclusion</a> <br>  <a href="https://habr.com/ru/post/480714/">Les ressources</a> <br></p><br></div></div><br><a name="id-introdaction"></a><h1>  Pr√©sentation </h1><br><p>  Le codec (codec, provient de la combinaison des termes COder et DECoder) est un terme tr√®s courant et, comme cela arrive souvent dans de tels cas, sa signification varie l√©g√®rement selon le contexte.  La signification principale est le logiciel ou le mat√©riel de compression / d√©compression des donn√©es multim√©dias.  Au lieu des termes compression / d√©compression, les termes codage / d√©codage sont souvent utilis√©s.  Mais dans certains cas, un codec signifie simplement un format de compression (ils disent aussi le format du codec), quels que soient les moyens utilis√©s pour la compression / d√©compression.  Voyons comment le terme codec est utilis√© dans FFmpeg. <br></p><br><a name="id-1"></a><br><h1>  1. Identification du codec </h1><br><p>  Les codecs FFmpeg sont compil√©s dans la biblioth√®que <b>libavcodec</b> . <br></p><br><a name="id-1-1"></a><br><h2>  1.1.  Identifiant du codec </h2><br><p> L' <code>enum AVCodecID</code> d√©finie dans le <code>enum AVCodecID</code> <code>libavcodec/avcodec.h</code> .  Chaque √©l√©ment de cette √©num√©ration identifie le format de compression.  Les √©l√©ments de cette √©num√©ration doivent √™tre de la forme <code>AV_CODEC_ID_XXX</code> , o√π <code>XXX</code> unique de l'identificateur de codec en majuscules.  Voici des exemples d'identificateurs de codec: <code>AV_CODEC_ID_H264</code> , <code>AV_CODEC_ID_AAC</code> .  Pour une description plus d√©taill√©e de l'identifiant du codec, utilisez la structure <code>AVCodecDescriptor</code> (d√©clar√©e sous <code>libavcodec/avcodec.h</code> , donn√©e sous forme abr√©g√©e): <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodecDescriptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVCodecID id; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVMediaType type; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *long_name; <span class="hljs-comment"><span class="hljs-comment">// ... } AVCodecDescriptor;</span></span></code> </pre> <br><p>  Le membre cl√© de cette structure est <code>id</code> , les autres membres fournissent des informations suppl√©mentaires sur l'identifiant du codec.  Chaque identifiant de codec est associ√© de mani√®re unique √† un type de m√©dia (membre de <code>type</code> ) et poss√®de un nom unique (membre de <code>name</code> ), √©crit en minuscules.  Un tableau de type <code>AVCodecDescriptor</code> d√©fini dans le fichier <code>libavcodec/codec_desc.c</code> <code>AVCodecDescriptor</code> .  Pour chaque identifiant de codec, il existe un √©l√©ment de tableau correspondant.  Les √©l√©ments de ce tableau doivent √™tre class√©s par valeurs <code>id</code> , car la recherche binaire est utilis√©e pour rechercher des √©l√©ments.  Pour obtenir des informations sur l'identifiant du codec, vous pouvez utiliser les fonctions: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVCodecDescriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_descriptor_get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVCodecDescriptor* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_descriptor_get_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">enum</span></span></span><span class="hljs-function"> AVMediaType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_get_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID codec_id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_get_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>;</code> </pre> <br><a name="id-1-2"></a><br><h2>  1.2.  Codec </h2><br><p>  Le codec lui-m√™me - un ensemble d'outils n√©cessaires pour effectuer le codage / d√©codage des donn√©es multim√©dias, combine la structure <code>AVCodec</code> (d√©clar√©e dans <code>libavcodec/avcodec.h</code> ).  Voici sa version abr√©g√©e, plus compl√®te sera discut√©e ci-dessous. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *long_name; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVMediaType type; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AVCodecID id; <span class="hljs-comment"><span class="hljs-comment">// ... } AVCodec;</span></span></code> </pre> <br><p>  Le membre le plus important de cette structure est <code>id</code> , l'identifiant du codec, il existe √©galement un membre d√©finissant le type de m√©dia ( <code>type</code> ), mais sa valeur doit correspondre √† la valeur du m√™me membre d' <code>AVCodecDescriptor</code> .  Les codecs sont divis√©s en deux cat√©gories: les encodeurs, qui compressent ou encodent les supports, et les d√©codeurs, qui effectuent l'op√©ration inverse - d√©compresser ou d√©coder.  (Parfois, dans les textes russes, au lieu du terme, l'encodeur utilise du papier calque de l'anglais - l'encodeur.) Il n'y a pas de membre sp√©cial dans <code>AVCodec</code> d√©finissant la cat√©gorie de codec (bien que la cat√©gorie puisse √™tre d√©termin√©e indirectement en utilisant les fonctions <code>av_codec_is_encoder()</code> et <code>av_codec_is_decoder()</code> , cette cat√©gorie est d√©termin√©e lors de l'enregistrement. Voici comment proc√©der: Plusieurs codecs peuvent avoir le m√™me identifiant de codec. S'ils ont la m√™me cat√©gorie, ils doivent diff√©rer par leur nom ( <code>name</code> membre). Un codeur et un d√©codeur ayant le m√™me identifiant de codec peuvent en avoir un  le m√™me nom, qui peut √©galement co√Øncider avec le nom de l'identifiant du codec (mais ces correspondances sont facultatives). Une telle situation peut cr√©er une certaine confusion, mais il n'y a rien √† faire, vous devez bien comprendre √† quelle entit√© appartient le nom. Dans une cat√©gorie, le nom Le codec doit √™tre unique. Pour rechercher des codecs enregistr√©s, il existe des fonctions: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_encoder_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_decoder_by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_encoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AVCodec* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_find_decoder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">enum</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodecID id)</span></span></span></span>;</code> </pre> <br><p>  √âtant donn√© que plusieurs codecs peuvent avoir le m√™me identifiant, les deux derni√®res fonctions renvoient l'une d'entre elles, qui peut √™tre consid√©r√©e comme le codec par d√©faut pour un identifiant de codec donn√©. <br></p><br><p>  Une liste de tous les codecs enregistr√©s peut √™tre demand√©e avec la commande <br></p><br><p> <code>ffmpeg -codecs &gt;codecs.txt</code> <br> </p><br><p>  Apr√®s avoir ex√©cut√© la commande, le fichier <code>codecs.txt</code> contiendra cette liste.  Chaque identifiant de codec sera repr√©sent√© par un enregistrement distinct (ligne).  Voici, par exemple, l'entr√©e pour l'identifiant de codec <code>AV_CODEC_ID_H264</code> : <br></p><br><p> <code>DEV.LS <br> h264 <br> H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 <br> (decoders: h264 h264_qsv h264_cuvid) <br> (encoders: libx264 libx264rgb h264_amf h264_nvenc h264_qsv nvenc nvenc_h264) <br></code> <br></p><br><p>  Au d√©but de l'enregistrement, des caract√®res sp√©ciaux d√©terminent les caract√©ristiques communes disponibles pour cet identifiant de codec: <code>D</code> - les d√©codeurs sont enregistr√©s, <code>E</code> - les encodeurs sont enregistr√©s, <code>V</code> - est utilis√© pour la vid√©o, <code>L</code> - il y a la possibilit√© d'une compression avec perte, <code>S</code> - il y a la possibilit√© d'une compression sans perte.  Vient ensuite le nom de l'identificateur de codec ( <code>h264</code> ), suivi d'un nom d'identification de codec long ( <code>H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10</code> ), puis une liste de noms de d√©codeurs et encodeurs enregistr√©s. <br></p><br><a name="id-2"></a><br><h1>  2. Ajout d'un nouveau codec √† FFmpeg </h1><br><p>  Nous consid√©rerons la proc√©dure pour ajouter un nouveau codec √† FFmpeg en utilisant un exemple de codec audio, que nous appellerons <code>FROX</code> . <br></p><br><p>  <b>√âtape 1. Ajoutez un nouvel √©l√©ment √† l' <code>enum AVCodecID</code> .</b> <br></p><br><p>  Cette liste se trouve dans le <code>libavcodec/avcodec.h</code> .  Lors de l'ajout, vous devez suivre les r√®gles: <br></p><br><ol><li>  La valeur d'un √©l√©ment ne doit pas co√Øncider avec les valeurs des √©l√©ments d'√©num√©ration existants; </li><li>  Ne modifiez pas les valeurs des √©l√©ments d'√©num√©ration existants; </li><li>  Publiez une nouvelle valeur dans un groupe de codecs similaires. </li></ol><br><p>  Selon le mod√®le, l'identifiant de cet √©l√©ment devrait √™tre <code>AV_CODEC_ID_FROX</code> .  Placez-le avant <code>AV_CODEC_ID_PCM_S64LE</code> et donnez la valeur <code>0x10700</code> . <br></p><br><p>  <b>√âtape 2. Ajoutez l'√©l√©ment au tableau <code>codec_descriptors</code> (fichier <code>libavcodec/codec_desc.c</code> ).</b> <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodecDescriptor codec_descriptors[] = { <span class="hljs-comment"><span class="hljs-comment">// ... { .id = AV_CODEC_ID_FROX, .type = AVMEDIA_TYPE_AUDIO, .name = "frox", .long_name = NULL_IF_CONFIG_SMALL("FROX audio"), .props = AV_CODEC_PROP_LOSSLESS, }, // ... };</span></span></code> </pre> <br><p>  Vous devez ajouter l'√©l√©ment √† la ¬´bonne¬ª place, la monotonie des √©l√©ments du tableau par la valeur <code>id</code> ne doit pas √™tre viol√©e. <br></p><br><p>  <b>√âtape 3. D√©finissez s√©par√©ment les instances d' <code>AVCodec</code> pour l'encodeur et le d√©codeur.</b> <br></p><br><p>  Pour ce faire, vous devez d'abord d√©terminer la structure du contexte du codec et plusieurs fonctions qui effectueront le codage / d√©codage r√©el et certaines autres op√©rations n√©cessaires.  Dans cette section, ces d√©finitions seront faites de fa√ßon extr√™mement sch√©matique; une description plus d√©taill√©e sera faite plus tard.  Nous <code>libavcodec/frox.c</code> le code dans le fichier <code>libavcodec/frox.c</code> <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"avcodec.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// context typedef struct FroxContext { // ... } FroxContext; // decoder static int frox_decode_init(AVCodecContext *codec_ctx) { return -1; } static int frox_decode_close(AVCodecContext *codec_ctx) { return -1; } static int frox_decode(AVCodecContext *codec_ctx, void* outdata, int *outdata_size, AVPacket *pkt) { return -1; } AVCodec ff_frox_decoder = { .name = "frox_dec", .long_name = NULL_IF_CONFIG_SMALL("FROX audio decoder"), .type = AVMEDIA_TYPE_AUDIO, .id = AV_CODEC_ID_FROX, .priv_data_size = sizeof(FroxContext), .init = frox_decode_init, .close = frox_decode_close, .decode = frox_decode, .capabilities = AV_CODEC_CAP_LOSSLESS, .sample_fmts = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_FLT, AV_SAMPLE_FMT_NONE}, .channel_layouts = (const int64_t[]) {AV_CH_LAYOUT_MONO, 0 }, }; // encoder static int frox_encode_init(AVCodecContext *codec_ctx) { return -1; } static int frox_encode_close(AVCodecContext *codec_ctx) { return -1; } static int frox_encode(AVCodecContext *codec_ctx, AVPacket *pkt, const AVFrame *frame, int *got_pkt_ptr) { return -1; } AVCodec ff_frox_encoder = { .name = "frox_enc", .long_name = NULL_IF_CONFIG_SMALL("FROX audio encoder"), .type = AVMEDIA_TYPE_AUDIO, .id = AV_CODEC_ID_FROX, .priv_data_size = sizeof(FroxContext), .init = frox_encode_init, .close = frox_encode_close, .encode2 = frox_encode, .sample_fmts = (const enum AVSampleFormat[]) {AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE}, .channel_layouts = (const int64_t[]) {AV_CH_LAYOUT_MONO, 0 }, };</span></span></span></span></code> </pre> <br><p>  Pour simplifier, dans cet exemple, l'encodeur et le d√©codeur ont le m√™me contexte - <code>FroxContext</code> , mais le plus souvent l'encodeur et le d√©codeur ont des contextes diff√©rents.  Notez √©galement que les <code>AVCodec</code> instance <code>AVCodec</code> doivent suivre un mod√®le sp√©cial. <br></p><br><p>  <b>√âtape 4. Ajoutez des instances d' <code>AVCodec</code> √† la liste d'enregistrement.</b> <br></p><br><p>  Acc√©dez au fichier <code>libavcodec/allcodecs.c</code> .  Au d√©but de ce fichier se trouve une liste des d√©clarations de tous les codecs enregistr√©s.  Ajoutez nos codecs √† cette liste: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> AVCodec ff_frox_decoder; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> AVCodec ff_frox_encoder;</code> </pre> <br><p>  Pendant l'ex√©cution, le script <code>configure</code> trouve toutes ces d√©clarations et g√©n√®re le <code>libavcodec/codec_list.c</code> , qui contient un tableau de pointeurs vers les codecs d√©clar√©s dans <code>libavcodec/allcodecs.c</code> .  Apr√®s avoir ex√©cut√© le script dans le fichier <code>libavcodec/codec_list.c</code> nous verrons: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodec * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> codec_list[] = { <span class="hljs-comment"><span class="hljs-comment">// ... &amp;ff_frox_encoder, // ... &amp;ff_frox_decoder, // ... NULL };</span></span></code> </pre> <br><p>  Aussi, lors de l'ex√©cution du script <code>configure</code> , le fichier <code>config.h</code> est <code>config.h</code> , dans lequel on retrouve les d√©clarations <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONFIG_FROX_DECODER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONFIG_FROX_ENCODER 1</span></span></code> </pre> <br><p>  <b>√âtape 5. Modifier <code>libavcodec/Makefile</code></b> <br></p><br><p>  Ouvrez <code>libavcodec/Makefile</code> .  Nous trouvons la section <code># decoders/encoders</code> , et y ajoutons <br></p><br><pre> <code class="cpp hljs">OBJS-$(CONFIG_FROX_DECODER) += frox.o OBJS-$(CONFIG_FROX_ENCODER) += frox.o</code> </pre> <br><p>  <b>√âtape 6. Modifiez le code du multiplexeur et du d√©multiplexeur.</b> <br></p><br><p>  Le multiplexeur (muxer) et le d√©multiplexeur (demuxer) doivent ¬´conna√Ætre¬ª le nouveau codec.  Lors de l'enregistrement, il est n√©cessaire d'enregistrer les informations d'identification de ce codec, tout en lisant, d√©terminer l'identifiant du codec √† partir des informations d'identification.  Voici ce que vous devez faire pour le format <code>matroska</code> ( <code>*.mkv</code> ). <br></p><br><p>  1. Dans le fichier <code>libavformat/matroska.c</code> , ajoutez un √©l√©ment pour le nouveau codec au tableau <code>libavformat/matroska.c</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CodecTags ff_mkv_codec_tags[] = { <span class="hljs-comment"><span class="hljs-comment">// ... {"A_FROX", AV_CODEC_ID_FROX}, // ... };</span></span></code> </pre> <br><p>  Cha√Æne <code>"A_FROX"</code> et sera √©crite par le multiplexeur dans le fichier comme information d'identification.  Dans ce tableau, il est associ√© √† l'identifiant du codec, donc lors de la lecture, le d√©multiplexeur peut facilement le d√©terminer.  Le d√©multiplexeur √©crit l'identifiant du codec dans le membre <code>codec_id</code> de la structure <code>codec_id</code> .  Un pointeur vers cette structure est membre de la structure <code>AVStream</code> . <br></p><br><p>  2. Dans le fichier <code>libavformat/matroskaenc.c</code> , ajoutez l'√©l√©ment au tableau <code>additional_audio_tags</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodecTag additional_audio_tags[] = { <span class="hljs-comment"><span class="hljs-comment">// ... { AV_CODEC_ID_FROX, 0XFFFFFFFF }, // ... };</span></span></code> </pre> <br><p>  Donc tout est pr√™t.  Tout d'abord, ex√©cutez le script de <code>configure</code> .  Apr√®s cela, vous devez vous assurer que les modifications d√©crites ci-dessus dans les fichiers <code>libavcodec/codec_list.c</code> et <code>config.h</code> sont effectu√©es.  Ensuite, vous pouvez ex√©cuter la compilation: <br></p><br><p> <code>make clean <br> make <br></code> <br></p><br><p>  Si la compilation s'est <code>ffmpeg.exe</code> , l'ex√©cutable <code>ffmpeg</code> (ou <code>ffmpeg.exe</code> , si le syst√®me d'exploitation cible est Windows) appara√Æt.  Ex√©cutez la commande <br></p><br><p> <code>./ffmpeg -codecs &gt;codecs.txt <br></code> <br></p><br><p>  et assurez-vous que FFmpeg "voit" nos nouveaux codecs, nous trouvons l'entr√©e dans le fichier <code>codecs.txt</code> <br></p><br><p> <code>DEA..S frox FROX audio (decoders: frox_dec) (encoders: frox_enc) <br></code> <br></p><br><a name="id-3"></a><br><h1>  3. Description d√©taill√©e du contexte et des fonctions requises </h1><br><p>  Dans cette section, nous d√©crivons plus en d√©tail √† quoi peut ressembler la structure du contexte du codec et les fonctions n√©cessaires. <br></p><br><a name="id-3-1"></a><br><h2>  3.1.  Contexte du codec </h2><br><p>  Le contexte du codec peut prendre en charge l'installation d'options.  Pour les encodeurs, ce support est utilis√© assez souvent, pour les d√©codeurs moins souvent.  La structure prenant en charge l'installation d'options doit avoir un pointeur vers la structure <code>AVClass</code> tant que premier membre, puis les options elles-m√™mes. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"libavutil/opt.h"</span></span></span><span class="hljs-meta"> typedef struct FroxContext { const AVClass *av_class; int frox_int; char *frox_str; uint8_t *frox_bin; int bin_size; } FroxContext;</span></span></code> </pre> <br><p>  Ensuite, vous devez d√©finir un tableau de type <code>AVOption</code> , dont chaque √©l√©ment d√©crit une option sp√©cifique. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVOption frox_options[] = { { <span class="hljs-string"><span class="hljs-string">"frox_int"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of int type."</span></span>, offsetof(FroxContext, frox_int), AV_OPT_TYPE_INT, { .i64 = <span class="hljs-number"><span class="hljs-number">-1</span></span> }, <span class="hljs-number"><span class="hljs-number">1</span></span>, SHRT_MAX }, { <span class="hljs-string"><span class="hljs-string">"frox_str"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of string type."</span></span>, offsetof(FroxContext, frox_str), AV_OPT_TYPE_STRING }, { <span class="hljs-string"><span class="hljs-string">"frox_bin"</span></span>, <span class="hljs-string"><span class="hljs-string">"This is a demo option of binary type."</span></span>, offsetof(FroxContext, frox_bin), AV_OPT_TYPE_BINARY }, { <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> }, };</code> </pre> <br><p>  Pour chaque option, vous devez d√©finir un nom, une description, un d√©calage dans la structure, un type.  Vous pouvez √©galement d√©finir une valeur par d√©faut et pour les options enti√®res une plage de valeurs valides. <br></p><br><p>  Ensuite, vous devez d√©finir une instance de type <code>AVClass</code> . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVClass frox_class = { .class_name = <span class="hljs-string"><span class="hljs-string">"FroxContext"</span></span>, .item_name = av_default_item_name, .option = frox_options, .version = LIBAVUTIL_VERSION_INT, };</code> </pre> <br><p>  Un pointeur vers cette instance doit √™tre utilis√© pour initialiser le membre <code>AVCodec</code> correspondant. <br></p><br><pre> <code class="cpp hljs">AVCodec ff_frox_decoder = { <span class="hljs-comment"><span class="hljs-comment">// ... .priv_data_size = sizeof(FroxContext), .priv_class = &amp;frox_class, // ... }; AVCodec ff_frox_encoder = { // ... .priv_data_size = sizeof(FroxContext), .priv_class = &amp;frox_class, // ... };</span></span></code> </pre> <br><p>  Maintenant lors de l'ex√©cution de la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">AVCodecContext *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_alloc_context3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodec *codec)</span></span></span></span>;</code> </pre> <br><p>  une instance de la structure <code>AVCodecContext</code> est <code>AVCodecContext</code> et le membre du <code>codec</code> est initialis√©.  Ensuite, en fonction de la <code>codec-&gt;priv_data_size</code> , la m√©moire n√©cessaire sera allou√©e pour l'instance <code>FroxContext</code> , en utilisant la <code>codec-&gt;priv_class</code> premier membre de cette instance sera initialis√© puis la fonction <code>av_opt_set_defaults()</code> sera appel√©e, ce qui d√©finira les valeurs par d√©faut pour les options.  Un pointeur vers une instance de <code>FroxContext</code> sera disponible via le membre <code>priv_data</code> de la structure <code>priv_data</code> . <br></p><br><p>  Lorsque vous travaillez avec l'API FFmpeg, les valeurs des options peuvent √™tre d√©finies directement. <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AVCodec *codec; <span class="hljs-comment"><span class="hljs-comment">// ... AVCodecContext *codec_ctx = avcodec_alloc_context3(codec); // ... av_opt_set(codec_ctx-&gt;priv_data, "frox_str", "meow", 0); av_opt_set_int(codec_ctx-&gt;priv_data, "frox_int", 42, 0);</span></span></code> </pre> <br><p>  Une autre fa√ßon consiste √† utiliser le dictionnaire d'options, qui sera pass√© comme troisi√®me argument lors de l'appel √† <code>avcodec_open2()</code> (voir ci-dessous). <br></p><br><p>  Utilisation de la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> AVOption* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_opt_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVOption* prev)</span></span></span></span>;</code> </pre> <br><p>  Vous pouvez obtenir une liste de toutes les options prises en charge par le contexte du codec.  Ceci est utile lors de l'examen d'un codec.  Mais avant cela, vous devez vous assurer que <code>codec_ctx-&gt;codec-&gt;priv_class</code> d√©fini sur une valeur non nulle, sinon le contexte ne prend pas en charge les options et toute op√©ration avec des options plantera le programme. <br></p><br><a name="id-3-2"></a><br><h2>  3.2.  Les fonctions </h2><br><p>  Examinons maintenant plus en d√©tail comment les fonctions utilis√©es dans l'initialisation du codec et l'encodage / d√©codage proprement dit sont organis√©es.  Ils ont g√©n√©ralement toujours besoin d'obtenir un pointeur sur un <code>FroxContext</code> . <br></p><br><pre> <code class="cpp hljs">AVCodecContext *codec_ctx; <span class="hljs-comment"><span class="hljs-comment">// ... FroxContext* frox_ctx = codec_ctx-&gt;priv_data;</span></span></code> </pre> <br><p>  Les fonctions <code>frox_decode_init()</code> et <code>frox_encode_init()</code> seront appel√©es lors de l'ex√©cution de la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_open2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVCodec *codec, AVDictionary **options)</span></span></span></span>;</code> </pre> <br><p>  Ils doivent allouer les ressources n√©cessaires au fonctionnement du codec et, si n√©cessaire, initialiser certains membres de la structure <code>AVCodecContext</code> , par exemple <code>frame_size</code> pour un <code>frame_size</code> audio. <br></p><br><p>  Les fonctions <code>frox_decode_close()</code> et <code>frox_encode_close()</code> seront appel√©es lors de leur ex√©cution <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span></span>;</code> </pre> <br><p>  Ils doivent lib√©rer les ressources allou√©es. <br></p><br><p>  Consid√©rons une fonction pour impl√©menter le d√©codage <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata_size, AVPacket *pkt)</span></span></span></span>;</code> </pre> <br><p>  Elle doit mettre en ≈ìuvre les op√©rations suivantes: <br></p><br><ol><li>  D√©codage r√©el; </li><li>  Allocation du tampon n√©cessaire pour la trame de sortie; </li><li>  Copiez les donn√©es d√©cod√©es dans le tampon de trame. </li></ol><br><p>  Consid√©rez comment allouer le tampon n√©cessaire √† la trame de sortie.  Le param√®tre <code>outdata</code> pointe en fait vers un <code>AVFrame</code> , vous devez donc d'abord effectuer une conversion de type: <br></p><br><pre> <code class="cpp hljs">AVFrame* frm = outdata;</code> </pre> <br><p>  Ensuite, vous devez allouer un tampon pour stocker les donn√©es de trame.  Pour ce faire, initialisez les membres <code>AVFrame</code> qui d√©terminent la taille du tampon de trame.  Pour l'audio, il s'agit de <code>nb_samples</code> , <code>channel_layout</code> , <code>format</code> (pour la <code>width</code> , la <code>height</code> et le <code>format</code> vid√©o). <br></p><br><p>  Apr√®s cela, vous devez appeler la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_frame_get_buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVFrame* frm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alignment)</span></span></span></span>;</code> </pre> <br><p>  Le pointeur sur la trame, qui est le param√®tre converti des donn√©es <code>outdata</code> , est utilis√© comme premier argument; il est recommand√© de passer z√©ro comme deuxi√®me argument.  Apr√®s avoir utilis√© le cadre (cela se produit d√©j√† en dehors du codec), le tampon allou√© par cette fonction est lib√©r√© par la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_frame_unref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVFrame* frm)</span></span></span></span>;</code> </pre> <br><p>  La fonction <code>frox_decode()</code> doit renvoyer le nombre d'octets utilis√©s pour le d√©codage du paquet point√© par <code>pkt</code> .  Si la formation de trame est termin√©e, la variable point√©e par <code>outdata_size</code> attribuer une valeur non nulle, sinon cette variable obtient la valeur <code>0</code> . <br></p><br><p>  Consid√©rons une fonction pour impl√©menter le codage <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext *codec_ctx, AVPacket *pkt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AVFrame *frame, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *got_pkt_ptr)</span></span></span></span>;</code> </pre> <br><p>  Elle doit mettre en ≈ìuvre les op√©rations suivantes: <br></p><br><ol><li>  Codage r√©el; </li><li>  Allocation de la m√©moire tampon n√©cessaire pour le paquet de sortie; </li><li>  Copiez les donn√©es encod√©es dans le tampon de paquets. </li></ol><br><p>  Pour s√©lectionner le tampon requis, utilisez la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_new_packet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVPacket *pkt, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pack_size)</span></span></span></span>;</code> </pre> <br><p>  Le param√®tre <code>pkt</code> utilis√© comme premier argument et la taille des donn√©es cod√©es est le second.  Apr√®s avoir utilis√© le package (cela se produit d√©j√† en dehors du codec), les tampons allou√©s par cette fonction sont lib√©r√©s par la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_packet_unref</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVPacket *pkt)</span></span></span></span>;</code> </pre> <br><p>  Si le package est termin√©, la variable point√©e par <code>got_pkt_ptr</code> attribuer une valeur non nulle, sinon cette variable obtient la valeur <code>0</code> .  S'il n'y a pas d'erreur, la fonction renvoie z√©ro, sinon un code d'erreur. <br></p><br><p>  Lors de la mise en ≈ìuvre du codec, la journalisation est g√©n√©ralement utilis√©e (pour les erreurs, cela peut √™tre consid√©r√© comme une exigence obligatoire).  Voici un exemple: <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode_close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span><span class="hljs-function"> </span></span>{ av_log(codec_ctx, AV_LOG_INFO, <span class="hljs-string"><span class="hljs-string">"FROX decode close\n"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Dans ce cas, lors de la sortie dans le journal, le nom du codec sera utilis√© comme nom de contexte. <br></p><br><a name="id-3-3"></a><br><h2>  3.3.  Horodatages </h2><br><p>  Pour d√©finir l'heure dans FFmpeg, une base de temps est utilis√©e, sp√©cifi√©e en secondes √† l'aide du nombre rationnel repr√©sent√© par le type <code>AVRational</code> .  (Une approche similaire est utilis√©e en C ++ 11. Par exemple, 1/1000 d√©finit la milliseconde.) Les trames et les paquets ont des horodatages de type <code>int64_t</code> , leurs valeurs contiennent le temps dans les unit√©s de temps correspondantes.  Une image, c'est-√†-dire une structure <code>AVFrame</code> , a un <code>pts</code> membre (horodatage de pr√©sentation), dont la valeur d√©termine l'heure relative de la sc√®ne captur√©e dans l'image.  Un package, c'est-√†-dire une structure <code>AVPacket</code> , a des membres <code>pts</code> (horodatage de pr√©sentation) et <code>dts</code> (horodatage de d√©compression).  La valeur <code>dts</code> d√©termine le temps relatif de transmission du paquet pour le d√©codage.  Pour les codecs simples, c'est la m√™me chose que les <code>pts</code> , mais pour les codecs complexes, cela peut √™tre diff√©rent (par exemple, pour <code>h264</code> lors de l'utilisation de trames B), c'est-√†-dire que les paquets peuvent √™tre d√©cod√©s dans le mauvais ordre dans lequel les trames doivent √™tre utilis√©es. <br></p><br><p>  L'unit√© de temps est d√©finie pour le flux et le codec, la structure <code>AVStream</code> a un membre correspondant - <code>time_base</code> , le m√™me membre a la structure <code>AVCodecContext</code> . <br></p><br><p>  Les horodatages du paquet extrait du flux √† l'aide de <code>av_read_frame()</code> seront sp√©cifi√©s en unit√©s de temps de ce flux.  Lors du d√©codage, l'unit√© de temps du codec n'est pas utilis√©e.  Pour un d√©codeur vid√©o, il n'est g√©n√©ralement pas d√©fini, pour un d√©codeur audio, il a une valeur standard - l'inverse de la fr√©quence d'√©chantillonnage.  Le d√©codeur doit d√©finir un horodatage pour la trame de sortie en fonction de l'horodatage du paquet.  FFmpeg d√©finit ind√©pendamment une telle √©tiquette et l'√©crit dans le membre <code>best_effort_timestamp</code> de la structure <code>best_effort_timestamp</code> .  Tous ces horodatages utiliseront l'unit√© de temps du flux dont le paquet est extrait. <br></p><br><p>  Pour l'encodeur, vous devez sp√©cifier l'unit√© de temps.  Dans le code client qui organise le d√©codage, vous devez d√©finir la valeur du membre <code>time_base</code> de la structure <code>time_base</code> avant d'appeler <code>avcodec_open2()</code> .  Prenez g√©n√©ralement l'unit√© de temps utilis√©e pour les horodatages de la trame cod√©e.  Si cela n'est pas fait, les encodeurs vid√©o donnent g√©n√©ralement une erreur, les encodeurs audio d√©finissent la valeur par d√©faut - l'inverse de la fr√©quence d'√©chantillonnage.  Il n'est pas tout √† fait clair si un codec peut changer une unit√© de temps donn√©e.  Au cas o√π, il est pr√©f√©rable de toujours v√©rifier la valeur <code>time_base</code> apr√®s avoir appel√© <code>avcodec_open2()</code> et, si elle a chang√©, recalculer les horodatages des trames d'entr√©e par unit√© de temps du codec.  Dans le processus d'encodage, vous devez installer les <code>pts</code> et <code>dts</code> package.  Apr√®s le codage, avant d'√©crire un paquet dans le flux de sortie, il est n√©cessaire de recalculer les horodatages des paquets de l'unit√© de temps du codec vers l'unit√© de temps du flux.  Pour ce faire, utilisez la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">av_packet_rescale_ts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVPacket *pkt, AVRational tb_src, AVRational tb_dst)</span></span></span></span>;</code> </pre> <br><p>  Lors de l'√©criture de paquets dans le flux, il est n√©cessaire de s'assurer que les valeurs <code>dts</code> augmentent strictement, sinon le multiplexeur g√©n√©rera une erreur.  (Pour plus d'informations, consultez la documentation de la fonction <code>av_interleaved_write_frame()</code> .) <br></p><br><a name="id-3-4"></a><br><h2>  3.4.  Autres fonctions utilis√©es par le codec </h2><br><p>  Lorsque vous initialisez une instance <code>AVCodec</code> , deux fonctions suppl√©mentaires peuvent √™tre enregistr√©es.  Voici les membres concern√©s d' <code>AVCodec</code> : <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AVCodec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... void (*init_static_data)(AVCodec *codec); void (*flush)(AVCodecContext *codec_ctx); // ... } AVCodec;</span></span></code> </pre> <br><p>  Le premier d'entre eux est appel√© une fois lors de l'enregistrement du codec. <br></p><br><p>  Le second r√©initialise l'√©tat interne du codec, il sera appel√© lors de l'ex√©cution de la fonction <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">avcodec_flush_buffers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AVCodecContext *codec_ctx)</span></span></span></span>;</code> </pre> <br><p>  Cet appel est n√©cessaire, par exemple, lorsque vous changez de force la position de lecture actuelle. <br></p><br><a name="id-4"></a><br><h1>  4. Impl√©mentation externe du codec </h1><br><a name="id-4-1"></a><br><h2>  4.1.  Connexion de fonction externe </h2><br><p>  Consid√©rons l'organisation suivante du codec: le codec enregistr√© dans FFmpeg joue le r√¥le d'un framework et d√©l√®gue la proc√©dure de codage / d√©codage r√©elle √† des fonctions externes (une sorte de plugins) impl√©ment√©es en dehors de FFmpeg. <br></p><br><p>  Une telle solution peut √™tre souhaitable pour de nombreuses raisons.  En voici quelques uns: <br></p><br><ol><li>       ,   FFmpeg    ; </li><li>     C,    ,   C++; </li><li>     framework,     FFmpeg. </li></ol><br><p>    ,   FFmpeg       ¬´¬ª,         FFmpeg API.             ¬´¬ª FFmpeg       (  ,     ),     .    ‚Äî     .         . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dec_extern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">frox_decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AVCodecContext* codec_ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outdata, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *outdata_size, AVPacket* pkt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* out_buff; <span class="hljs-comment"><span class="hljs-comment">//      out_buff FroxContext *fc = codec_ctx-&gt;priv_data; if (fc-&gt;bin_size &gt; 0) { if (fc-&gt;bin_size == sizeof(dec_extern_t)) { dec_extern_t edec; memcpy(&amp;edec, fc-&gt;frox_bin, fc-&gt;bin_size); ret = (*edec)(pkt-&gt;data, pkt-&gt;size, out_buff); if (ret &gt;= 0) { //     out_buff   } } else { /*  */ } } else { /*    */ } // ... return ret; }</span></span></code> </pre> <br><p>    FFmpeg API (     C++)    . <br></p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeFroxData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* outBuff)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dec_extern_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt; #include &lt;libavutil/opt.h&gt; } // ... AVCodecContext* ctx; // ... dec_extern_t dec = DecodeFroxData; void* pv = &amp;dec; auto pb = static_cast&lt;const uint8_t*&gt;(pv); auto sz = sizeof(dec); av_opt_set_bin(ctx-&gt;priv_data, "frox_bin", pb, sz, 0);</span></span></span></span></code> </pre> <br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><p>       ‚Äî     .        ,   . ,      .  ,   ,  FFmpeg     ,   ¬´¬ª ,        .         .     ,   .   FFmpeg API  -       ,   ,      .     .        ,        .     PC (Windows)      DirectShow  AVI .  PC             -   DirectShow.     32- FourCC. (   <code>biCompression</code>  <code>BITMAPINFOHEADER</code> .)  ,      DirectShow   ,   PC    -.        FFmpeg  , ,   ,   <code>codec_tag</code>  <code>AVCodecParameters</code>   FourCC,     .       FFmpeg API    ,    .             FFmpeg   FFmpeg API. <br></p><br><p>          ,   <code>*.mkv</code>  FFmpeg     ( <code>ENCODER</code> ). <br></p><br><a name="id-concl"></a><br><h1>  Conclusion </h1><br><p>        ,   ,       FFmpeg: , changelog,     ..     ¬´¬ª  FFmpeg,     ,     . <br></p><br><a name="id-refs"></a><br><h1>  Les ressources </h1><br><p> <b>   FFmpeg</b> </p><br><p> [1] <a href="https://ffmpeg.org/" rel="nofollow">FFmpeg ‚Äî  </a> <br> [2] <a href="https://ffmpeg.org/documentation.html" rel="nofollow">FFmpeg ‚Äî </a> <br> [3] <a href="https://ru.wikipedia.org/wiki/FFmpeg" rel="nofollow">FFmpeg ‚Äî </a> <br> [4] <a href="https://help.ubuntu.ru/wiki/ffmpeg" rel="nofollow">FFmpeg ‚Äî    Ubuntu</a> <br></p><br><p> <b></b> </p><br><p> [5] <a href="https://trac.ffmpeg.org/wiki/CompilationGuide" rel="nofollow">FFmpeg Compilation Guide</a> <br> [6] Compilation of FFmpeg 4.0 in Windows 10 <br></p><br><p> <b>   FFmpeg API</b> </p><br><p> [7] <a href="https://habr.com/ru/post/137793/">   ffmpeg</a> <br></p><br><p> <b> </b> </p><br><p> [8] <a href="https://wiki.multimedia.cx/index.php/FFmpeg_codec_HOWTO" rel="nofollow">FFmpeg codec HOWTO</a> <br> [9] <a href="http://ogorkis.net/ffmpeg" rel="nofollow">FFmpeg video codec tutorial</a> <br></p><br><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr480714/">https://habr.com/ru/post/fr480714/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr480702/index.html">RH et talents, experts et cr√©atifs: comment s'est pass√© le huiti√®me Habraseminar</a></li>
<li><a href="../fr480704/index.html">Rendre le chargement de contenu r√©actif sur le site</a></li>
<li><a href="../fr480708/index.html">Les d√©cennies touchent √† leur fin. Quelles applications sur Google Play ont √©t√© les plus t√©l√©charg√©es au cours des 10 derni√®res ann√©es?</a></li>
<li><a href="../fr480710/index.html">Refactorisation des jeux SFML</a></li>
<li><a href="../fr480712/index.html">Le vol avec un dosim√®tre dans la poche</a></li>
<li><a href="../fr480716/index.html">Matlab vs. Julia vs. Python</a></li>
<li><a href="../fr480718/index.html">6 conseils pour une revue de code r√©ussie</a></li>
<li><a href="../fr480724/index.html">Langues transcompil√©es: projets de conversion de code en code</a></li>
<li><a href="../fr480730/index.html">D√©veloppement Auto-Moto et Nginx</a></li>
<li><a href="../fr480736/index.html">Pourquoi pas toutes les erreurs doivent √™tre corrig√©es pour am√©liorer un produit informatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>