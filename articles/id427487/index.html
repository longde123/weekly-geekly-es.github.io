<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖖🏾 🙍🏻 🛤️ Pengujian Konfigurasi untuk Pengembang Java: Pengalaman Praktis 🆖 ♌️ 👩🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dengan tes untuk kode, semuanya jelas (well, setidaknya fakta bahwa mereka perlu ditulis). Dengan tes untuk konfigurasi, semuanya menjadi kurang jelas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengujian Konfigurasi untuk Pengembang Java: Pengalaman Praktis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/427487/"><img src="https://habrastorage.org/webt/9o/r3/24/9or324raqccmfaeghrlyaagxmja.jpeg"><br><br>  Dengan tes untuk kode, semuanya jelas (well, setidaknya fakta bahwa mereka perlu ditulis).  Dengan tes untuk konfigurasi, semuanya menjadi kurang jelas, dimulai dengan keberadaannya.  Apakah ada yang menulisnya?  Apakah ini penting?  Apakah ini sulit?  Hasil apa yang bisa dicapai dengan bantuan mereka? <br><br>  Ternyata ini juga sangat berguna, mulai melakukannya sangat sederhana, dan pada saat yang sama ada banyak nuansa dalam menguji konfigurasi.  Yang mana - dilukis di bawah potongan berdasarkan pengalaman praktis. <br><a name="habracut"></a><br>  <i>Materi ini didasarkan pada transkrip laporan oleh <b>Ruslan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">cheremin</a> Cheremin</b> (pengembang Java di Deutsche Bank).</i>  <i>Berikutnya adalah pidato orang pertama.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Tk_nmV-mWOA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nama saya Ruslan, saya bekerja untuk Deutsche Bank.  Kita mulai dengan ini: <br><br><img src="https://habrastorage.org/webt/vg/xr/rq/vgxrrqh1taa98cujjske1r5usa4.jpeg"><br><br>  Ada banyak teks, dari kejauhan sepertinya teks itu berbahasa Rusia.  Tetapi ini tidak benar.  Ini adalah bahasa yang sangat kuno dan berbahaya.  Saya menerjemahkan ke dalam bahasa Rusia sederhana: <br><br><ul><li>  Semua karakter dibuat </li><li>  Gunakan dengan hati-hati </li><li>  Pemakaman dengan biaya sendiri </li></ul><br><br>  Saya akan menjelaskan secara singkat apa yang akan saya bicarakan hari ini.  Misalkan kita memiliki kode: <br><br><img src="https://habrastorage.org/webt/qv/ip/gd/qvipgdp4a8n1bjo79z29aicqmik.jpeg"><br><br>  Artinya, pada awalnya kami memiliki semacam tugas, kami menulis kode untuk menyelesaikannya, dan itu seharusnya menghasilkan uang bagi kami.  Jika karena alasan tertentu kode ini tidak berfungsi dengan benar, ini memecahkan tugas yang salah dan menghasilkan uang yang salah.  Bisnis tidak menyukai uang sebanyak itu - mereka terlihat buruk dalam laporan keuangan. <br><br>  Karena itu, untuk kode penting kami, kami memiliki tes: <br><br><img src="https://habrastorage.org/webt/0e/9g/-k/0e9g-klbunmtoyvlhf9q0-vl-4o.jpeg"><br><br>  Biasanya disana.  Sekarang, mungkin, hampir semua orang memilikinya.  Tes memverifikasi bahwa kode memecahkan masalah yang tepat dan menghasilkan uang yang tepat.  Tetapi layanan tidak terbatas pada kode, dan di samping kode ada juga konfigurasi: <br><br><img src="https://habrastorage.org/webt/z7/75/sq/z775sqxlsy1nha5hrclznn6biq0.jpeg"><br><br>  Setidaknya di hampir semua proyek tempat saya berpartisipasi, konfigurasi ini adalah, dalam satu atau lain bentuk.  (Saya hanya dapat mengingat beberapa kasus dari tahun-tahun awal UI saya, di mana tidak ada file konfigurasi, tetapi semuanya dikonfigurasi melalui UI) Dalam konfigurasi ini, ada port, alamat, dan parameter algoritma. <br><br><h2>  Mengapa konfigurasi penting untuk diuji? </h2><br>  Inilah triknya: kesalahan dalam eksekusi program kerusakan tidak kurang dari kesalahan dalam kode.  Mereka juga dapat menyebabkan kode melakukan tugas yang salah - dan lihat di atas. <br><br>  Dan menemukan kesalahan dalam konfigurasi bahkan lebih sulit daripada dalam kode, karena konfigurasi biasanya tidak dikompilasi.  Saya mengutip properti-file sebagai contoh, secara umum ada opsi yang berbeda (JSON, XML, seseorang menyimpan di YAML), tetapi penting bahwa tidak ada kompilasi ini dan, karenanya, tidak dicentang.  Jika Anda secara tidak sengaja disegel dalam file Java - kemungkinan besar, itu tidak akan lulus kompilasi.  Kesalahan ketik acak di properti tidak akan merangsang siapa pun, ini akan berfungsi. <br><br>  Dan IDE juga tidak menyoroti kesalahan dalam konfigurasi, karena hanya mengetahui yang paling primitif tentang format (misalnya) file properti: bahwa harus ada kunci dan nilai, dan "sama dengan", titik dua atau spasi di antara keduanya.  Tetapi fakta bahwa nilainya harus berupa angka, port jaringan atau alamat - IDE tidak tahu apa-apa. <br><br>  Dan bahkan jika Anda menguji aplikasi dalam UAT atau dalam lingkungan Pementasan, ini juga tidak menjamin apa pun.  Karena konfigurasi, sebagai suatu peraturan, di setiap lingkungan berbeda, dan di UAT Anda hanya menguji konfigurasi UAT. <br><br>  Kehalusan lain adalah bahwa bahkan dalam produksi, kesalahan konfigurasi terkadang tidak segera muncul.  Layanan mungkin tidak memulai sama sekali - dan ini adalah skenario yang bagus.  Tapi itu bisa mulai, dan bekerja untuk waktu yang sangat lama - sampai saat X, ketika akan diperlukan parameter di mana kesalahan terjadi.  Dan di sini Anda menemukan bahwa layanan yang bahkan belum berubah banyak baru-baru ini tiba-tiba berhenti berfungsi. <br><br>  Setelah semua yang saya katakan - tampaknya pengujian konfigurasi harus menjadi topik hangat.  Tetapi dalam praktiknya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/9o/r3/24/9or324raqccmfaeghrlyaagxmja.jpeg"><br><br>  Setidaknya itulah yang terjadi dengan kami - sampai titik tertentu.  Dan salah satu tugas laporan saya adalah untuk berhenti terlihat seperti ini untuk Anda juga.  Saya harap saya bisa mendorong Anda untuk ini. <br><br>  Tiga tahun lalu di Deutsche Bank kami, di tim saya, Andrei Satarin bekerja sebagai pemimpin QA.  Dialah yang membawa ide pengujian konfigurasi - yaitu, ia hanya mengambil dan melakukan tes pertama seperti itu.  Enam bulan lalu, di Heisenbug sebelumnya, dia memberi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ceramah</a> tentang pengujian konfigurasi saat dia melihatnya.  Saya sarankan agar Anda melihat, karena di sana ia memberikan pandangan luas pada masalah: baik dari sisi artikel ilmiah dan dari pengalaman perusahaan besar yang telah mengalami kesalahan konfigurasi dan konsekuensinya. <br><br>  Laporan saya akan lebih sempit - tentang pengalaman praktis.  Saya akan berbicara tentang masalah apa, sebagai pengembang, yang saya temui ketika saya menulis tes konfigurasi, dan bagaimana saya memecahkan masalah ini.  Keputusan saya mungkin bukan keputusan terbaik, ini bukan praktik terbaik - ini adalah pengalaman pribadi saya, saya berusaha untuk tidak membuat generalisasi yang luas. <br><br>  Garis besar umum laporan: <br><br><ul><li>  "Yang Dapat Anda Lakukan Sebelum Senin Sore": Contoh-contoh Sederhana dan Berguna. </li><li>  "Senin, dua tahun kemudian": di mana dan bagaimana melakukan lebih baik. </li><li>  Dukungan untuk refactoring konfigurasi: bagaimana mencapai cakupan yang padat;  model konfigurasi perangkat lunak. </li></ul><br><br>  Bagian pertama adalah motivasi: Saya akan menjelaskan tes paling sederhana yang semuanya dimulai dengan kita.  Akan ada berbagai macam contoh.  Saya harap setidaknya satu dari mereka beresonansi dengan Anda, yaitu, Anda akan melihat beberapa jenis masalah yang serupa dan solusinya. <br><br>  Tes sendiri pada bagian pertama adalah sederhana, bahkan primitif - dari sudut pandang teknik tidak ada ilmu roket.  Tetapi hal itu dapat dilakukan dengan cepat adalah sangat berharga.  Ini adalah "entri mudah" ke dalam pengujian konfigurasi, dan ini penting karena ada hambatan psikologis untuk menulis tes ini.  Dan saya ingin menunjukkan bahwa "Anda bisa melakukan ini": sekarang, kami berhasil, itu berhasil dengan baik bagi kami, dan sementara tidak ada yang meninggal, kami sudah hidup selama tiga tahun sekarang. <br><br>  Bagian kedua adalah tentang apa yang harus dilakukan setelahnya.  Ketika Anda menulis banyak tes sederhana, pertanyaan tentang dukungan muncul.  Beberapa dari mereka mulai jatuh, Anda memahami kesalahan yang seharusnya disorot.  Ternyata ini tidak selalu nyaman.  Dan muncul pertanyaan untuk menulis tes yang lebih kompleks - lagi pula, Anda sudah membahas kasus-kasus sederhana, saya ingin sesuatu yang lebih menarik.  Dan di sini lagi tidak ada praktik terbaik, saya hanya akan menjelaskan beberapa solusi yang bekerja untuk kita. <br><br>  Bagian ketiga adalah tentang bagaimana pengujian dapat mendukung refactoring dari konfigurasi yang agak rumit dan membingungkan.  Lagi studi kasus - bagaimana kami melakukannya.  Dari sudut pandang saya, ini adalah contoh bagaimana pengujian konfigurasi dapat ditingkatkan untuk menyelesaikan tugas yang lebih besar, dan bukan hanya untuk menyumbat lubang kecil. <br><br><h2>  Bagian 1. "Kamu bisa melakukannya seperti itu" </h2><br>  Sekarang sulit untuk memahami apa tes konfigurasi pertama dengan kami.  Andrei duduk di aula, dia bisa mengatakan bahwa aku berbohong.  Tetapi bagi saya tampaknya semuanya dimulai dengan ini: <br><br><img src="https://habrastorage.org/webt/6t/dr/d8/6tdrd8-mwyj8otcngbcjsjqi3ge.jpeg"><br><br>  Situasinya adalah ini: kami memiliki layanan di host yang sama, masing-masing dari mereka meningkatkan server JMX di port-nya, mengekspor beberapa JMX pemantauan.  Port untuk semua layanan dikonfigurasikan dalam file.  Tetapi file tersebut menempati beberapa halaman, dan ada banyak properti lainnya - seringkali ternyata port-port dari layanan yang berbeda saling bertentangan.  Mudah membuat kesalahan.  Maka semuanya sepele: beberapa layanan tidak naik, setelah itu mereka tidak naik untuk mereka yang bergantung padanya - penguji sangat marah. <br><br>  Masalah ini diselesaikan dalam beberapa baris.  Tes ini, yang (menurut saya) adalah yang pertama bagi kami, terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ka/ln/51/kaln51onx8-1yzdr2vq0ltcmegq.jpeg"><br><br>  Tidak ada yang rumit: kita pergi melalui folder di mana file konfigurasi berada, memuatnya, mem-parsingnya sebagai properti, menyaring nilai-nilai yang namanya berisi "jmx.port", dan memeriksa bahwa semua nilainya unik.  Bahkan tidak perlu mengkonversi nilai menjadi integer.  Agaknya, hanya ada porta. <br><br>  Reaksi pertama saya ketika saya melihat ini beragam: <br><br><img src="https://habrastorage.org/webt/ka/ln/51/kaln51onx8-1yzdr2vq0ltcmegq.jpeg"><br><br>  Kesan pertama: apa yang ada di unit test saya yang cantik?  Mengapa kami naik ke sistem file? <br><br>  Dan kemudian kejutan datang: "Apa, mungkinkah itu?" <br><br>  Saya membicarakan hal ini karena sepertinya ada semacam penghalang psikologis yang membuatnya sulit untuk menulis tes semacam itu.  Tiga tahun telah berlalu sejak itu, proyek ini penuh dengan tes seperti itu, tetapi saya sering melihat bahwa rekan-rekan saya, menabrak kesalahan yang dibuat dalam konfigurasi, jangan menulis tes di atasnya.  Untuk kode, semua orang sudah terbiasa menulis tes regresi - sehingga kesalahan yang ditemukan tidak lagi direproduksi.  Tetapi mereka tidak melakukannya untuk konfigurasi, ada sesuatu yang mengganggu.  Ada semacam penghalang psikologis yang perlu ditangani - itu sebabnya saya menyebutkan reaksi sedemikian rupa sehingga Anda akan mengenalinya dari diri sendiri jika itu muncul. <br><br><img src="https://habrastorage.org/webt/ka/ln/51/kaln51onx8-1yzdr2vq0ltcmegq.jpeg"><br><br>  Contoh berikut hampir sama, tetapi sedikit dimodifikasi - saya menghapus semua "jmx".  Kali ini kami memeriksa semua properti yang disebut sesuatu di sana port.  Mereka harus berupa nilai integer, dan menjadi port jaringan yang valid.  Matcher validNetworkPort () menyembunyikan Pencocokan hamcrest kustom kami, yang memeriksa bahwa nilainya berada di atas kisaran port sistem, di bawah kisaran port fana, yah, kami tahu bahwa beberapa port di server kami sudah dikuasai sebelumnya - inilah daftar keseluruhan dari mereka yang disembunyikan di ini adalah matcher. <br><br>  Tes ini masih sangat primitif.  Perhatikan bahwa tidak ada indikasi di dalamnya properti spesifik apa yang kami periksa - properti ini masif.  Satu pengujian semacam itu dapat memeriksa 500 properti dengan nama "... port", dan memverifikasi bahwa semuanya adalah bilangan bulat dalam kisaran yang diinginkan, dengan semua kondisi yang diperlukan.  Setelah mereka menulis, selusin baris - dan hanya itu.  Ini adalah fitur yang sangat nyaman, ini muncul karena konfigurasi memiliki format sederhana: dua kolom, satu kunci dan satu nilai.  Karena itu, bisa jadi diproses secara massal. <br><br>  Contoh tes lain.  Apa yang kita periksa di sini? <br><br><img src="https://habrastorage.org/webt/7j/wt/wr/7jwtwr0zn93gy0fhfaqykbeyeyy.jpeg"><br><br>  Ia memeriksa bahwa kata sandi asli tidak bocor ke dalam produksi.  Semua kata sandi akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/yg/4_/ft/yg4_ftjvkm_bhqqzmdxppafoaii.jpeg"><br><br>  Anda dapat menulis banyak tes untuk file properti.  Saya tidak akan memberikan lebih banyak contoh - saya tidak ingin mengulang sendiri, idenya sangat sederhana, maka semuanya harus jelas. <br><br>  ... dan setelah cukup menulis tes ini, sebuah pertanyaan menarik muncul: apa yang kita maksud dengan konfigurasi, di mana perbatasannya?  Kami menganggap file properti sebagai konfigurasi, kami menutupinya - dan apa lagi yang bisa dicakup dengan gaya yang sama? <br><br><h2>  Apa yang harus dipertimbangkan konfigurasi </h2><br>  Ternyata ada banyak file teks dalam proyek yang tidak dikompilasi - setidaknya dalam proses pembangunan normal.  Mereka tidak diverifikasi dengan cara apa pun sampai mereka dieksekusi di server, yaitu, kesalahan di dalamnya tampak terlambat.  Semua file ini - dengan sedikit peregangan - dapat disebut konfigurasi.  Paling tidak, mereka akan diuji kira-kira sama. <br><br>  Sebagai contoh, kami memiliki sistem tambalan SQL yang digulirkan ke database selama proses penyebaran. <br><br><img src="https://habrastorage.org/webt/jz/bk/c7/jzbkc7m5zo0k6phy-9kuzvkqkam.jpeg"><br><br>  Mereka ditulis untuk SQL * Plus.  SQL * Plus adalah alat dari tahun 60-an, dan itu membutuhkan segala macam hal aneh: misalnya, untuk memastikan akhir file berada pada baris baru.  Tentu saja, orang secara teratur lupa untuk meletakkan ujung garis di sana, karena mereka tidak dilahirkan di tahun 60an. <br><br><img src="https://habrastorage.org/webt/nr/oj/3w/nroj3wxkhriqqeqa-iwxwus0a0a.jpeg"><br><br>  Dan lagi itu dipecahkan oleh selusin baris yang sama: kita memilih semua file SQL, periksa apakah ada garis miring di akhir.  Sederhana, mudah, cepat. <br><br>  Contoh lain dari “like a text file” adalah crontab.  Layanan crontab kami mulai dan berhenti.  Mereka paling sering menyebabkan dua kesalahan: <br><br><img src="https://habrastorage.org/webt/02/i0/ch/02i0chpobgao-lexobckwr5ffd4.jpeg"><br><br>  Pertama, format ekspresi jadwal.  Ini tidak rumit, tetapi tidak ada yang memeriksanya sebelum diluncurkan, jadi mudah untuk menempatkan ruang ekstra, koma, dan sejenisnya. <br><br>  Kedua, seperti pada contoh sebelumnya, akhir file juga harus berada pada baris baru. <br><br>  Dan semua ini cukup mudah diverifikasi.  Akhir file dapat dimengerti, tetapi untuk memeriksa jadwal, Anda dapat menemukan pustaka siap pakai yang menguraikan ekspresi cron.  Sebelum laporan, saya mencari di Google: setidaknya ada enam.  Saya menemukan enam, tetapi secara umum mungkin ada lebih banyak.  Ketika kami menulis, kami mengambil yang paling sederhana dari yang ditemukan, karena kami tidak perlu memeriksa isi ekspresi, tetapi hanya kebenaran sintaksisnya, sehingga cron berhasil memuatnya. <br><br>  Pada prinsipnya, Anda dapat menyelesaikan lebih banyak cek - periksa apakah Anda memulai pada hari yang tepat dalam seminggu, bahwa Anda tidak menghentikan layanan di tengah hari kerja.  Tapi ini ternyata tidak begitu berguna bagi kami, dan kami tidak repot-repot. <br><br>  Gagasan lain yang bekerja sangat baik adalah skrip shell.  Tentu saja, menulis di Jawa parser lengkap dari skrip bash adalah kesenangan bagi yang berani.  Tetapi intinya adalah bahwa sejumlah besar skrip ini bukan bash lengkap.  Ya, ada skrip bash di mana kode itu langsung, neraka dan neraka, di mana mereka jatuh setahun sekali dan, bersumpah, lari.  Tetapi banyak skrip bash yang memiliki konfigurasi yang sama.  Ada sejumlah variabel sistem dan variabel lingkungan yang diatur ke nilai yang diinginkan, sehingga mengkonfigurasi skrip lain yang menggunakan variabel-variabel ini.  Dan variabel-variabel semacam itu mudah diperoleh dari file bash ini dan memeriksa sesuatu tentangnya. <br><br><img src="https://habrastorage.org/webt/5s/4d/z_/5s4dz_wtejguewyqrat5ipxa7by.jpeg"><br><br>  Misalnya, periksa apakah JAVA_HOME diinstal pada setiap lingkungan, atau bahwa beberapa perpustakaan jni yang kami gunakan terletak di LD_LIBRARY_PATH.  Entah bagaimana kami pindah dari satu versi Java ke yang lain, dan memperluas tes: kami memeriksa bahwa JAVA_HOME berisi "1.8" pada lingkungan yang sangat kecil itu, yang secara bertahap kami transfer ke versi yang baru. <br><br>  Berikut ini beberapa contohnya.  Biarkan saya meringkas bagian pertama dari kesimpulan: <br><br><ul><li>  Tes konfigurasi pada awalnya membingungkan, ada hambatan psikologis.  Tetapi setelah mengatasinya, ada banyak tempat dalam aplikasi yang tidak tercakup oleh cek dan dapat ditanggung. </li><li>  Kemudian mereka ditulis <b>dengan mudah dan riang</b> : ada banyak "buah tergantung rendah" yang dengan cepat memberi manfaat besar). </li><li>  Mengurangi <b>biaya untuk</b> mendeteksi dan memperbaiki kesalahan konfigurasi.  Karena ini, pada kenyataannya, pengujian unit, Anda dapat menjalankannya di komputer Anda, bahkan sebelum melakukan - ini sangat mengurangi Loop Umpan Balik.  Banyak dari mereka, tentu saja, akan diuji pada tahap penerapan uji, misalnya.  Dan banyak yang tidak akan diuji - jika ini adalah konfigurasi produksi.  Dan mereka diperiksa langsung di komputer lokal. </li><li>  Mereka memberi pemuda kedua.  Dalam arti ada perasaan bahwa Anda masih bisa menguji banyak hal menarik.  Memang, dalam kode itu tidak lagi begitu mudah untuk menemukan apa yang dapat Anda uji. </li></ul><br><br><h2>  Bagian 2. Kasus yang lebih kompleks </h2><br>  Mari kita beralih ke tes yang lebih kompleks.  Setelah membahas sebagian besar pemeriksaan sepele, seperti yang ditunjukkan di sini, muncul pertanyaan: apakah mungkin untuk memeriksa sesuatu yang lebih rumit? <br><br>  Apa artinya "lebih keras"?  Tes yang baru saja saya jelaskan memiliki sekitar struktur berikut: <br><br><img src="https://habrastorage.org/webt/er/an/sx/eransxujnuprewkr1lcrk1nweui.jpeg"><br><br>  Mereka memeriksa sesuatu terhadap satu file tertentu.  Yaitu, kita pergi melalui file, menerapkan pemeriksaan kondisi tertentu untuk masing-masing.  Dengan demikian, banyak yang dapat diverifikasi, tetapi ada skenario yang lebih berguna: <br><br><ul><li>  Aplikasi UI terhubung ke server lingkungannya. </li><li>  Semua layanan dari lingkungan yang sama terhubung ke server manajemen yang <b>sama</b> . </li><li>  Semua layanan di lingkungan yang sama menggunakan database yang <b>sama</b> . </li></ul><br><br>  Misalnya, aplikasi UI terhubung ke server lingkungannya.  Kemungkinan besar, UI dan server adalah modul yang berbeda, jika bukan proyek sama sekali, dan mereka memiliki konfigurasi yang berbeda, mereka tidak mungkin menggunakan file konfigurasi yang sama.  Oleh karena itu, Anda harus menautkannya sehingga semua layanan dari satu lingkungan terhubung ke satu server manajemen utama yang melaluinya perintah didistribusikan.  Sekali lagi, kemungkinan besar, ini adalah modul yang berbeda, layanan yang berbeda dan umumnya tim yang berbeda mengembangkannya. <br><br>  Atau semua layanan menggunakan database yang sama, hal yang sama - layanan dalam modul yang berbeda. <br><br>  Bahkan, ada gambar seperti itu: banyak layanan, masing-masing memiliki struktur konfigurasi sendiri, Anda perlu mengurangi beberapa dari mereka dan memeriksa sesuatu di persimpangan: <br><br><img src="https://habrastorage.org/webt/tw/et/op/twetop-jheecrf02felhlhchnvi.jpeg"><br><br>  Tentu saja, Anda dapat melakukan hal itu: muat satu, yang kedua, tarik sesuatu di suatu tempat, rekatkan dalam kode uji.  Tapi Anda bisa bayangkan seberapa besar kodenya dan seberapa mudah dibaca.  Kami mulai dari ini, tetapi kemudian kami menyadari betapa sulitnya itu.  Bagaimana melakukan yang lebih baik? <br><br>  Jika Anda bermimpi, itu akan lebih mudah, maka saya bermimpi bahwa ujian akan terlihat seperti saya jelaskan dalam bahasa manusia: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachEnvironmentIsXXX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Environment environment )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( Server server : environment.servers() ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( Service service : server.services() ) { Properties config = buildConfigFor( environment, server, service ); <span class="hljs-comment"><span class="hljs-comment">//… check {something} about config } } }</span></span></code> </pre> <br>  Untuk setiap lingkungan, suatu kondisi terpenuhi.  Untuk memeriksanya, Anda perlu dari lingkungan untuk menemukan daftar server, daftar layanan.  Kemudian muat konfigurasi dan periksa sesuatu di persimpangan.  Karena itu, saya memerlukan hal seperti itu, saya menyebutnya Layout Penempatan. <br><br><img src="https://habrastorage.org/webt/cs/um/3u/csum3u7sucokbnlydgulc18cdhs.jpeg"><br><br>  Kami membutuhkan peluang dari kode untuk mendapatkan akses ke bagaimana aplikasi dikerahkan: di server mana layanan ditempatkan, di mana Lingkungan - untuk mendapatkan struktur data ini.  Dan mulai dari itu, saya mulai memuat konfigurasi dan memprosesnya. <br><br>  Layout Penerapan khusus untuk setiap tim dan setiap proyek.  Saya telah menggambar - ini adalah kasus umum: biasanya ada beberapa set server, layanan, layanan kadang-kadang memiliki satu set file konfigurasi, dan bukan hanya satu.  Terkadang diperlukan parameter tambahan yang berguna untuk pengujian, mereka harus ditambahkan.  Misalnya, rak tempat server berada mungkin penting.  Andrey dalam laporannya memberikan contoh ketika penting bagi layanan mereka bahwa layanan Cadangan / Utama harus berada di rak yang berbeda - untuk kasusnya, dia perlu menyimpan indikasi rak dalam tata letak penempatan: <br><br><img src="https://habrastorage.org/webt/gj/oh/ip/gjohipszob-edpgkekfr1zvdfp0.jpeg"><br><br>  Untuk tujuan kami, wilayah server penting, pusat data spesifik, pada prinsipnya, juga, sehingga Cadangan / Utama berada di pusat data yang berbeda.  Ini semua adalah properti server tambahan, khusus untuk proyek tersebut, tetapi pada slide itu adalah penyebut yang umum. <br><br>  Di mana mendapatkan tata letak penempatan?  Tampaknya di perusahaan besar mana pun ada sistem Manajemen Infrastruktur, semuanya dijelaskan di sana, dapat diandalkan, andal, dan semua yang ... sebenarnya tidak. <br><br>  Paling tidak, praktik saya di dua proyek telah menunjukkan bahwa lebih mudah untuk melakukan hardcode terlebih dahulu, dan kemudian, setelah tiga tahun ... pergi berkulit keras. <br><br>  Kami telah hidup dengan proyek ini selama tiga tahun sekarang.  Yang kedua, sepertinya, kami masih berintegrasi dengan Manajemen Infrastruktur dalam setahun, tetapi selama ini kami hidup seperti ini.  Dari pengalaman, masuk akal untuk menunda tugas integrasi dengan IM untuk mendapatkan tes siap pakai sesegera mungkin, yang akan menunjukkan bahwa mereka bekerja dan bermanfaat.  Dan kemudian mungkin ternyata integrasi ini mungkin tidak begitu diperlukan, karena distribusi layanan di seluruh server tidak begitu sering diubah. <br><br>  Hardcode secara harfiah dapat seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Environment { PROD( PROD_UK_PRIMARY, PROD_UK_BACKUP, PROD_US_PRIMARY, PROD_US_BACKUP, PROD_SG_PRIMARY, PROD_SG_BACKUP ) … <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Server[] servers() {…} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Server { PROD_UK_PRIMARY(“rflx-ldn-<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">"), PROD_UK_BACKUP("</span></span>rflx-ldn-<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">"), PROD_US_PRIMARY(“rflx-nyc-1"</span></span>), PROD_US_BACKUP(<span class="hljs-string"><span class="hljs-string">"rflx-nyc-2"</span></span>), PROD_SG_PRIMARY(“rflx-sng-<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">"), PROD_SG_BACKUP("</span></span>rflx-sng-<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">"), public Service[] services() {…} }</span></span></code> </pre><br>  Cara termudah yang kami gunakan dalam proyek pertama kami adalah menghitung Lingkungan dengan daftar server di masing-masing.  Ada daftar server dan, tampaknya, harus ada daftar layanan, tetapi kami curang: kami telah memulai skrip (yang juga merupakan bagian dari konfigurasi). <br><br><img src="https://habrastorage.org/webt/m0/ww/jw/m0wwjwoo1xhqahbdppfbf8q5rno.jpeg"><br><br>  Mereka menjalankan layanan untuk setiap Lingkungan.  Dan metode services () hanya mengambil semua layanan dari file servernya.  Ini dilakukan karena tidak begitu banyak Lingkungan, dan server juga jarang ditambahkan atau dihapus - tetapi ada banyak layanan, dan mereka sering dikocok.  Masuk akal untuk memuat tata letak layanan yang sebenarnya dari skrip agar tidak mengubah tata letak hardcode terlalu sering. <br><br>  Setelah membuat model konfigurasi perangkat lunak seperti itu, bonus yang menyenangkan muncul.  Misalnya, Anda dapat menulis tes seperti ini: <br><br><img src="https://habrastorage.org/webt/ht/-o/lk/ht-olkpuql9rl2jhdkpm23yfnlm.jpeg"><br><br>  Tesnya adalah bahwa pada setiap Lingkungan semua layanan utama hadir.  Misalkan ada empat layanan utama, dan sisanya mungkin atau mungkin tidak, tetapi tanpa keempat ini tidak masuk akal.  Anda dapat memverifikasi bahwa Anda tidak melupakannya di mana pun, bahwa mereka semua memiliki cadangan dalam Lingkungan yang sama.  Paling sering, kesalahan seperti itu terjadi ketika mengkonfigurasi UAT dari contoh ini, tetapi juga bisa bocor ke PROD.  Pada akhirnya, kesalahan dalam UAT juga membuang-buang waktu dan saraf penguji. <br><br>  Muncul pertanyaan tentang mempertahankan relevansi model konfigurasi.  Anda juga dapat menulis tes untuk ini. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HardCodedLayoutConsistencyTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> eachHardCodedEnvironmentHasConfigFiles(Environment env){ … } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> eachConfigFileHasHardCodedEnvironment(File configFile){ … } }</code> </pre><br>  Ada file konfigurasi, dan ada tata letak penyebaran dalam kode.  Dan Anda dapat memverifikasi itu untuk setiap Lingkungan / server / dll.  ada file konfigurasi yang sesuai, dan untuk setiap file format yang diperlukan - Lingkungan yang sesuai.  Segera setelah Anda lupa menambahkan sesuatu ke satu tempat, tes akan jatuh. <br><br>  Intinya adalah tata letak penempatan: <br><br><ul><li>  Menyederhanakan penulisan tes kompleks yang menyatukan konfigurasi dari berbagai bagian aplikasi. </li><li>  Membuatnya lebih jelas dan lebih mudah dibaca.  Mereka melihat cara Anda berpikir tentang mereka pada tingkat tinggi, dan bukan cara mereka melalui konfigurasi. </li><li>  Selama pembuatannya, ketika orang mengajukan pertanyaan, ternyata banyak hal menarik tentang penyebaran.  Keterbatasan, pengetahuan suci implisit, muncul, misalnya, mengenai kemungkinan hosting dua Lingkungan pada satu server.  Ternyata para pengembang berpikir secara berbeda dan menulis layanan mereka sesuai.  Dan momen seperti itu berguna untuk diselesaikan di antara para pengembang. </li><li>  Nah melengkapi dokumentasi (terutama jika tidak).  Bahkan jika ada, lebih menyenangkan bagi saya, sebagai pengembang, untuk melihat ini dalam kode.  Selain itu, di sana Anda dapat menulis komentar yang penting bagi saya, dan bukan kepada orang lain.  Dan Anda juga bisa hardcode.  Artinya, jika Anda memutuskan bahwa tidak ada dua Lingkungan di server yang sama, Anda dapat memasukkan cek, dan sekarang tidak akan.  Setidaknya Anda akan mengetahui jika seseorang mencoba.  Artinya, ini adalah dokumentasi dengan kemampuan untuk menegakkannya.  Ini sangat membantu. </li></ul><br>  Mari kita lanjutkan.  Setelah tes ditulis, mereka "menetap" selama satu tahun, beberapa mulai jatuh.  Beberapa mulai jatuh lebih awal, tetapi tidak begitu menakutkan.  Menakutkan ketika tes yang ditulis setahun yang lalu jatuh, Anda melihat pesan kesalahannya, dan Anda tidak mengerti. <br><img src="https://habrastorage.org/webt/gm/e1/kb/gme1kb6jzdvbvfpfxlxydbxbktw.jpeg"><br><br>  Misalkan saya mengerti dan setuju bahwa ini adalah port jaringan yang tidak valid - tetapi di mana itu?  Sebelum ceramah, saya melihat fakta bahwa kami memiliki 1.200 file properti di proyek, yang tersebar di 90 modul, dengan total 24.000 baris di dalamnya.  (Meskipun saya terkejut, tetapi jika Anda menghitung, maka ini bukan jumlah yang besar - untuk satu layanan untuk 4 file.) Di mana port ini? <br><br>  Jelas bahwa assertThat () memiliki argumen pesan, Anda dapat memasukkan sesuatu di dalamnya yang akan membantu mengidentifikasi tempat.  Tetapi ketika Anda menulis tes, Anda tidak memikirkannya.  Dan bahkan jika Anda berpikir, Anda masih harus menebak deskripsi mana yang akan cukup rinci untuk dipahami dalam setahun.  Saya ingin mengotomatisasi momen ini, sehingga ada cara untuk menulis tes dengan generasi otomatis dengan deskripsi yang kurang lebih jelas, yang dengannya Anda dapat menemukan kesalahan. <br><br>  Sekali lagi, saya bermimpi dan memimpikan sesuatu seperti ini: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> environment, <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, component, configLocation, propertyName, propertyValue <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> configuration(environment, <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, component) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> propertyName <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> “%.port%” <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> propertyValue <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> validNetworkPort()</code> </pre><br>  Ini seperti pseudo-SQL - well, saya hanya tahu SQL, dan otak mengeluarkan solusi dari apa yang sudah dikenal.  Idenya adalah bahwa sebagian besar tes konfigurasi terdiri dari beberapa bagian dari tipe yang sama.  Pertama, subset parameter dipilih oleh kondisi: <br><br><img src="https://habrastorage.org/webt/ig/om/g_/igomg_lacmbr2w7xdnuqtxgrnoc.jpeg"><br><br>  Kemudian, mengenai subset ini, kami memeriksa sesuatu sehubungan dengan nilainya: <br><br><img src="https://habrastorage.org/webt/xm/zr/1p/xmzr1p3brb_ixbgiafqteeiltgg.jpeg"><br><br>  Dan kemudian, jika ada properti yang nilainya tidak memuaskan keinginan, ini adalah "lembar" yang ingin kita terima dalam pesan kesalahan: <br><br><img src="https://habrastorage.org/webt/6d/ci/jr/6dcijrp9yesvndnn6hq2udo5fw8.jpeg"><br><br>  Pada suatu waktu saya bahkan berpikir jika saya bisa menulis parser seperti SQL, karena sekarang tidak sulit.  Tapi kemudian saya menyadari bahwa IDE tidak akan mendukungnya dan menyarankannya, jadi orang harus menulis secara membabi buta tentang "SQL" buatan sendiri ini, tanpa dorongan IDE, tanpa kompilasi, tanpa memeriksa - ini tidak terlalu nyaman.  Karena itu, saya harus mencari solusi yang didukung oleh bahasa pemrograman kami.  Jika kita punya .NET, LINQ akan membantu, itu hampir seperti SQL. <br><br>  Tidak ada LINQ di Jawa, sedekat mungkin adalah stream.  Beginilah tes ini akan terlihat di aliran: <br><br><pre> <code class="java hljs">ValueWithContext[] incorrectPorts = flattenedProperties( environment ) .filter( propertyNameContains( <span class="hljs-string"><span class="hljs-string">".port"</span></span> ) ) .filter( !isInteger( propertyValue ) || !isValidNetworkPort( propertyValue ) ) .toArray(); assertThat( incorrectPorts, emptyArray() );</code> </pre><br>  flattenedProperties () mengambil semua konfigurasi lingkungan ini, semua file untuk semua server, layanan dan memperluasnya ke tabel besar.  Ini pada dasarnya adalah tabel seperti SQL, tetapi dalam bentuk seperangkat objek Java.  Dan flattenedProperties () mengembalikan rangkaian string ini sebagai aliran. <br><br><img src="https://habrastorage.org/webt/8b/ep/jb/8bepjbpkln50gcn1hlgdizwxkxe.jpeg"><br><br>  Kemudian Anda menambahkan beberapa kondisi pada set objek Java ini.  Dalam contoh ini: kami memilih yang mengandung "port" di propertyName dan memfilter nilai yang tidak dikonversi ke Integer, atau tidak dari rentang yang valid.  Ini adalah nilai-nilai yang salah, dan secara teori, itu harus menjadi set kosong. <br><br><img src="https://habrastorage.org/webt/4z/8i/db/4z8idb1t_vtoprcjg3f23ct0aeq.jpeg"><br><br>  Jika itu bukan set kosong, kami membuat kesalahan yang akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/ia/wq/wy/iawqwytklkjtldsc-afzmw7-cui.jpeg"><br><br><h2>  Bagian 3. Pengujian sebagai dukungan untuk refactoring </h2><br>  Biasanya, pengujian kode adalah salah satu dukungan refactoring paling kuat.  Refactoring adalah proses berbahaya, banyak pengulangan, dan saya ingin memastikan bahwa setelah itu aplikasi masih layak.  Salah satu cara untuk memastikan ini adalah pertama-tama overlay semuanya dengan tes di semua sisi, dan kemudian refactor dengannya. <br><br>  Dan sekarang, sebelum saya adalah tugas refactoring konfigurasi.  Ada aplikasi yang ditulis tujuh tahun lalu oleh satu orang pintar.  Konfigurasi aplikasi ini terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/d4/vc/wz/d4vcwzxtgvecd-be0n51ysi9mho.jpeg"><br><br>  Ini adalah contoh, masih banyak lagi.  Permutasi bertiga tripel, dan ini digunakan di seluruh konfigurasi: <br><br><img src="https://habrastorage.org/webt/ua/gt/t7/uagtt7xt289h6xfpc0swrmfztca.jpeg"><br><br>  Ada beberapa file dalam konfigurasi itu sendiri, tetapi mereka disertakan satu sama lain.  Ia menggunakan ekstensi kecil Properti iu - Konfigurasi Apache Commons, yang hanya mendukung inklusi dan izin dalam kawat gigi. <br><br>  Dan penulis melakukan pekerjaan yang fantastis hanya dengan menggunakan dua hal ini.  Saya pikir dia membangun mesin Turing di sana.  Di beberapa tempat, sepertinya dia mencoba melakukan perhitungan menggunakan inklusi dan substitusi.  Saya tidak tahu apakah sistem Turing ini selesai, tetapi dia, menurut saya, mencoba membuktikan bahwa memang demikian. <br><br>  Dan pria itu pergi.  Menulis, aplikasi berfungsi, dan dia meninggalkan bank.  Semuanya berfungsi, hanya tidak ada yang sepenuhnya memahami konfigurasi. <br><br>  Jika kita mengambil layanan terpisah, maka ternyata 10 inklusi, menjadi tiga kedalaman, dan secara total, jika semuanya diperluas, 450 parameter.  Bahkan, layanan ini menggunakan 10-15% dari mereka, sisanya parameter untuk layanan lain, karena file tersebut dibagikan, mereka digunakan oleh beberapa layanan.  Tapi apa yang tepatnya 10-15% menggunakan layanan khusus ini tidak begitu mudah dimengerti.  Penulis tampaknya mengerti.  Orang yang sangat pintar, sangat. <br><br>  Tugasnya masing-masing adalah menyederhanakan konfigurasi, yaitu refactoring.  Pada saat yang sama, saya ingin aplikasi tetap berfungsi, karena dalam situasi ini kemungkinannya rendah.  Saya ingin: <br><br><ul><li>  Sederhanakan konfigurasinya. </li><li>  Sehingga setelah refactoring, setiap layanan masih memiliki semua parameter yang diperlukan. </li><li>  Sehingga dia tidak memiliki parameter tambahan.  85% dari mereka yang tidak terkait dengannya tidak boleh mengacaukan halaman. </li><li>  Layanan itu masih berhasil terkoneksi dalam cluster dan melakukan kolaborasi. </li></ul><br>  Masalahnya adalah tidak diketahui seberapa baik mereka terhubung sekarang, karena sistemnya sangat redundan.  Sebagai contoh, melihat ke depan: selama refactoring, ternyata di salah satu konfigurasi produksi harus ada empat server di klip cadangan, tetapi sebenarnya ada dua.  Karena tingginya tingkat redundansi, tidak ada yang memperhatikan ini - kesalahan muncul secara tidak sengaja, tetapi sebenarnya tingkat redundansi untuk waktu yang lama lebih rendah dari yang kami harapkan.  Intinya adalah bahwa kita tidak dapat mengandalkan kenyataan bahwa konfigurasi saat ini benar di mana-mana. <br><br>  Saya mengarah pada fakta bahwa Anda tidak bisa hanya membandingkan konfigurasi baru dengan yang lama.  Ini mungkin setara, tetapi tetap pada saat yang sama di tempat yang salah.  Diperlukan untuk memeriksa konten logis. <br><br>  Program minimum: mengisolasi setiap parameter terpisah dari setiap layanan yang dibutuhkan dan memeriksa kebenarannya, bahwa port adalah port, alamat adalah alamat, TTL adalah angka positif, dll.  Dan periksa hubungan kunci bahwa layanan pada dasarnya terhubung pada titik akhir utama.  Saya ingin mencapai ini, setidaknya.  Artinya, tidak seperti contoh sebelumnya, tugas di sini bukan untuk memverifikasi parameter individual, tetapi untuk mencakup seluruh konfigurasi dengan jaringan pemeriksaan lengkap. <br><br>  Bagaimana cara mengujinya? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleComponent</span></span></span><span class="hljs-class"> </span></span>{ … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Configuration conf )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = conf.getInt( <span class="hljs-string"><span class="hljs-string">"Port"</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( port &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationException(); String ip = conf.getString( <span class="hljs-string"><span class="hljs-string">"Address"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ip == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationException(); … } … }</code> </pre><br>  Bagaimana saya mengatasi masalah ini?  Ada beberapa komponen sederhana, dalam contoh ini disederhanakan secara maksimal.  (Bagi mereka yang belum menemukan Konfigurasi Apache Commons: objek Konfigurasi seperti Properti, hanya saja ia masih memiliki metode yang diketik getInt (), getLong (), dll.; Kita dapat berasumsi bahwa ini adalah juProperties pada steroid kecil.) Misalkan komponen membutuhkan dua parameter: misalnya, alamat TCP dan port TCP.  Kami menarik mereka dan memeriksa.  Apa empat bagian umum di sini? <br><br><img src="https://habrastorage.org/webt/ou/s0/0k/ous00k4owrh8kqvf20fqqpzrfg0.jpeg"><br><br>  Ini adalah nama parameter, tipe, nilai default (di sini sepele: nol dan -1, kadang-kadang ada nilai waras) dan beberapa validasi.  Port di sini divalidasi terlalu sederhana, tidak lengkap - Anda dapat menentukan port yang akan melewatinya, tetapi tidak akan menjadi port jaringan yang valid.  Karena itu, saya ingin meningkatkan momen ini juga.  Tetapi pertama-tama, saya ingin mengubah keempat hal ini menjadi satu hal.  Sebagai contoh, ini: <br><br><pre> <code class="java hljs">IProperty&lt;Integer&gt; PORT_PROPERTY = intProperty( <span class="hljs-string"><span class="hljs-string">"Port"</span></span> ) .withDefaultValue( -<span class="hljs-number"><span class="hljs-number">1</span></span> ) .matchedWith( validNetworkPort() ); IProperty&lt;String&gt; ADDRESS_PROPERTY = stringProperty( <span class="hljs-string"><span class="hljs-string">"Address"</span></span> ) .withDefaultValue( <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ) .matchedWith( validIPAddress() );</code> </pre><br>  Objek komposit semacam itu adalah deskripsi properti yang mengetahui namanya, nilai default, dapat melakukan validasi (di sini saya menggunakan pencocokan hamcrest lagi).  Dan objek ini memiliki sesuatu seperti antarmuka ini: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IProperty</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* (name, defaultValue, matcher…) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** lookup (or use default), * convert type, * validate value against matcher */</span></span> <span class="hljs-function"><span class="hljs-function">FetchedValue&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Configuration config )</span></span></span><span class="hljs-function"> } class FetchedValue&lt;T&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String propertyName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> T propertyValue; … }</code> </pre><br>  Artinya, setelah membuat objek spesifik untuk implementasi tertentu, Anda dapat memintanya untuk mengekstrak parameter yang diwakilinya dari konfigurasi.  Dan dia akan mengeluarkan parameter ini, memeriksa prosesnya, jika tidak ada parameter, dia akan memberikan nilai default, mengarahkan ke tipe yang diinginkan, dan mengembalikannya segera dengan namanya. <br><br>  Artinya, di sini adalah nama parameter dan nilai aktual sehingga layanan akan melihat apakah permintaan dari konfigurasi ini.  Ini memungkinkan Anda untuk membungkus beberapa baris kode dalam satu entitas, ini adalah penyederhanaan pertama yang saya butuhkan. <br><br>  Penyederhanaan kedua yang saya butuhkan untuk menyelesaikan masalah adalah memperkenalkan komponen yang membutuhkan beberapa properti untuk konfigurasinya.  Model konfigurasi komponen: <br><br><img src="https://habrastorage.org/webt/gf/rr/ku/gfrrkugkjdimk8kcunvu4vijrsu.jpeg"><br><br>  Kami memiliki komponen yang menggunakan dua properti ini, ada model untuk konfigurasinya - antarmuka IConfigurationModel, yang diterapkan oleh kelas ini.  IConfigurationModel melakukan semua yang dilakukan komponen, tetapi hanya bagian yang berhubungan dengan konfigurasi.  Jika komponen memerlukan parameter dalam urutan tertentu dengan nilai default tertentu - IConfigurationModel menggabungkan informasi ini dengan sendirinya, merangkumnya.  Semua tindakan lain dari komponen tidak penting baginya.  Ini adalah model komponen dalam hal akses konfigurasi. <br><br><img src="https://habrastorage.org/webt/1v/-b/0d/1v-b0dpycb6qscw_n5sul8tbzec.jpeg"><br><br>  Trik dari pandangan ini adalah bahwa model dapat dikombinasikan.  Jika ada komponen yang menggunakan komponen lain, dan mereka digabungkan di sana, maka dengan cara yang sama model komponen kompleks ini dapat menggabungkan hasil panggilan dari dua subkomponen. <br><br>  Artinya, dimungkinkan untuk membangun hierarki model konfigurasi yang sejajar dengan hierarki komponen itu sendiri.  Pada model atas, panggil fetch (), yang akan mengembalikan lembar dari parameter yang ia tarik dari konfigurasi dengan nama mereka - persis yang dibutuhkan komponen terkait secara real time.  Jika kami menulis semua model dengan benar, tentu saja. <br><br>  Artinya, tugasnya adalah menulis model seperti itu untuk setiap komponen dalam aplikasi yang memiliki akses ke konfigurasi.  Dalam aplikasi saya, ada beberapa komponen seperti itu: aplikasi itu sendiri cukup banyak, tetapi aktif menggunakan kembali kode, sehingga hanya 70 kelas utama yang dikonfigurasi.  Bagi mereka, saya harus menulis 70 model. <br><br>  Berapa biayanya: <br><br><ul><li>  12 layanan </li><li>  70 kelas yang dapat dikonfigurasi </li><li>  =&gt; 70 ConfigurationModels (~ 60 adalah sepele); </li><li>  1-2 orang minggu. </li></ul><br>  Saya hanya membuka layar dengan kode komponen yang mengkonfigurasi sendiri, dan pada layar berikutnya saya menulis kode untuk ConfigurationModel yang sesuai.  Kebanyakan dari mereka sepele, seperti contoh yang ditunjukkan.  Dalam beberapa kasus, ada cabang dan transisi kondisional - ada kode menjadi lebih bercabang, tetapi semuanya juga diselesaikan.  Dalam satu setengah hingga dua minggu saya memecahkan masalah ini, untuk semua 70 komponen saya menggambarkan model. <br><br>  Alhasil, ketika kami menggabungkan semuanya, kami mendapatkan kode berikut: <br><br><img src="https://habrastorage.org/webt/dq/ab/vf/dqabvfz99qwfnortpempmtvaalm.jpeg"><br><br>  Untuk setiap layanan / lingkungan / dll.  kami mengambil model konfigurasi, yaitu, simpul teratas dari pohon ini, dan meminta untuk mendapatkan semuanya dari konfigurasi.  Pada titik ini, semua validasi masuk ke dalam, masing-masing properti, ketika menarik diri dari konfigurasi, memeriksa nilainya untuk kebenaran.  Jika setidaknya satu tidak lulus, pengecualian akan terbang keluar.  Semua kode diperoleh dengan memeriksa bahwa semua nilai valid dalam isolasi. <br><br><h2>  Saling Ketergantungan Layanan </h2><br>  Kami masih memiliki pertanyaan bagaimana cara memeriksa saling ketergantungan layanan.  Ini sedikit lebih rumit, Anda perlu melihat saling ketergantungan seperti apa.  Ternyata bagi saya bahwa saling ketergantungan bermuara pada kenyataan bahwa layanan harus "bertemu" pada titik akhir jaringan.  Layanan A harus mendengarkan dengan tepat alamat tempat layanan B mengirim paket, dan sebaliknya.  Dalam contoh saya, semua dependensi antara konfigurasi berbagai layanan datang ke ini.  Dimungkinkan untuk menyelesaikan masalah ini dengan cara yang sangat mudah: dapatkan port dan alamat dari berbagai layanan dan periksa.  Akan ada banyak tes, mereka akan menjadi besar.  Saya orang yang malas dan saya tidak menginginkan ini.  Karena itu, saya melakukan sebaliknya. <br><br>  Pertama, saya ingin mengabstraksi titik akhir jaringan ini sendiri.  Misalnya, untuk koneksi TCP Anda hanya perlu dua parameter: alamat dan port.  Untuk koneksi multicast, empat parameter.  Saya ingin memecahnya menjadi semacam objek.  Saya melakukan ini pada objek Endpoint, yang di dalamnya menyembunyikan semua yang Anda butuhkan.  Slide adalah contoh dari OutcomingTCPEndpoint, koneksi jaringan TCP keluar. <br><br><pre> <code class="java hljs">IProperty&lt;IEndpoint&gt; TCP_REQUEST = outcomingTCP( <span class="hljs-comment"><span class="hljs-comment">// (+matchers, +default values) “TCP.Request.Address”, “TCP.Request.Port» ); class OutcomingTCPEndpoint implements IEndpoint { //(localInterface, localAddress, multicastGroup, port) @Override boolean matches( IEndpoint other); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di luar, antarmuka Endpoint dikeluarkan oleh metode satunya pertandingan (), di mana Anda dapat memberikan Endpoint lain, dan mencari tahu apakah pasangan ini mirip dengan bagian server dan klien dari satu koneksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa "seperti"? Karena kami tidak tahu apa yang akan terjadi dalam kenyataan: mungkin, secara formal, itu harus terhubung ke alamat port, tetapi pada jaringan nyata ada firewall di antara node-node ini - kami tidak dapat memeriksanya hanya dengan konfigurasi. Tapi kita bisa mencari tahu apakah mereka sudah secara resmi tidak cocok dengan port / alamat. Kemudian, kemungkinan besar, dan pada kenyataannya mereka juga tidak akan terhubung satu sama lain.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan demikian, alih-alih nilai properti primitif, grup port-address-multicast, kami sekarang memiliki properti kompleks yang mengembalikan Endpoint. Dan di semua ConfigurationModels, alih-alih properti terpisah, ada yang kompleks. Apa yang ini berikan pada kita? Ini memberi kami semacam ini pemeriksaan konektivitas cluster:</font></font><br><br><pre> <code class="java hljs">ValueWithContext[] allEndpoints = flattenedConfigurationValues(environment) .filter( valueIsEndpoint() ) .toArray(); ValueWithContext[] unpairedEndpoints = Arrays.stream( allEndpoints ) .filter( e -&gt; !hasMatchedEndpoint(e, allEndpoints) ) .toArray(); assertThat( unpairedEndpoints, emptyArray() );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari semua properti dari lingkungan ini, kami memilih titik akhir, dan kemudian kami hanya menentukan apakah ada yang tidak terhubung dengan siapa pun dan tidak terhubung dengan siapa pun. Semua mesin sebelumnya memungkinkan Anda melakukan pemeriksaan ini dalam beberapa baris. Di sini, khususnya, kompleksitas memeriksa "semua orang dengan semua orang" akan menjadi O (n ^ 2), tetapi ini tidak begitu penting, karena ada sekitar seratus titik akhir, Anda bahkan tidak dapat mengoptimalkannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yaitu, untuk setiap Titik Akhir, kami melewati semua hal lain dan mencari tahu, jika setidaknya satu, yang terhubung dengannya. Jika tidak ada yang ditemukan, kemungkinan besar dia seharusnya ada di sana, tetapi karena kesalahan dia pergi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, mungkin layanan memiliki lubang yang menonjol "keluar" - yaitu, untuk layanan eksternal, di luar aplikasi saat ini. </font><font style="vertical-align: inherit;">Lubang seperti itu perlu disaring secara eksplisit. </font><font style="vertical-align: inherit;">Saya beruntung, dalam kasus saya, klien eksternal terhubung melalui lubang yang sama yang digunakan oleh layanan itu sendiri. </font><font style="vertical-align: inherit;">Ini sangat tertutup dan ekonomis dalam arti koneksi jaringan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah solusi untuk masalah pengujian. </font><font style="vertical-align: inherit;">Dan saya ingat, tugas utama adalah refactoring. </font><font style="vertical-align: inherit;">Dan saya siap untuk melakukan refactoring dengan tangan saya, tetapi ketika saya melakukan semua tes ini dan mereka mulai bekerja, saya menyadari bahwa saya dapat melakukan refactoring secara otomatis untuk perubahan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua hierarki ConfigurationModel ini memungkinkan Anda untuk:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konversikan ke format lain </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lakukan permintaan konfigurasi ("semua port udp digunakan oleh layanan di server ini") </font></font></li><li>        . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya dapat menyeret seluruh konfigurasi ke dalam memori sedemikian rupa sehingga setiap properti melacak asalnya. Setelah itu, saya dapat mengubah konfigurasi ini dalam memori, dan menuangkannya ke file lain, dalam urutan berbeda, dalam format yang berbeda - seperti yang cocok untuk saya. Jadi saya lakukan: Saya menulis kode kecil untuk mengubah lembar itu ke dalam bentuk di mana saya ingin mengubahnya. Sebenarnya, saya harus melakukan ini beberapa kali, karena pada awalnya tidak jelas format mana yang nyaman dan mudah dimengerti, dan saya harus melakukan beberapa kunjungan untuk mencobanya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi ini tidak cukup. Dengan konstruksi ini, menggunakan ConfigurationModels, saya dapat menjalankan permintaan konfigurasi. Angkat ke dalam memori dan cari tahu port UDP spesifik apa yang digunakan pada server ini oleh layanan yang berbeda, mintalah daftar port yang digunakan, dengan instruksi layanan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, saya dapat menghubungkan layanan pada titik akhir dan menampilkannya dalam bentuk diagram, ekspor ke .dot. </font><font style="vertical-align: inherit;">Dan permintaan serupa lainnya mudah dibuat. </font><font style="vertical-align: inherit;">Hasilnya adalah pisau Swiss - biaya konstruksi terbayar dengan cukup baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sinilah saya berakhir.</font></font> Kesimpulan: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menurut pendapat saya, dalam pengalaman saya, menguji konfigurasi itu penting dan menyenangkan. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak buah yang menggantung rendah, ambang entri untuk memulai rendah. </font><font style="vertical-align: inherit;">Anda dapat memecahkan masalah yang rumit, tetapi ada juga banyak masalah sederhana.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika Anda menggunakan sedikit otak, Anda bisa mendapatkan alat canggih yang memungkinkan Anda untuk tidak hanya menguji, tetapi masih ada banyak hubungannya dengan konfigurasi. </font></font></li></ul><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menyukai laporan ini dari Heisenbug 2018 Piter, harap dicatat: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada 6-7 Desember, </font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heisenbug</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berikutnya akan diadakan </font><b><font style="vertical-align: inherit;">di Moskow</font></b><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sebagian besar deskripsi laporan baru sudah tersedia </font><font style="vertical-align: inherit;">di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situs web konferensi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dan mulai 1 November, harga tiket naik - jadi masuk akal untuk mengambil keputusan sekarang.</font></font></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427487/">https://habr.com/ru/post/id427487/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427477/index.html">Kami sedang mempersiapkan pengelompokan hierarkis, atau bagaimana saya mengidentifikasi spesialisasi dalam resume</a></li>
<li><a href="../id427479/index.html">Penggunaan data pengguna dan penjualan data besar diusulkan untuk melegitimasi</a></li>
<li><a href="../id427481/index.html">Fitur membangun jaringan Wi-Fi dalam produksi makanan inovatif</a></li>
<li><a href="../id427483/index.html">Sekolah Kecerdasan Buatan di Distrik Biner</a></li>
<li><a href="../id427485/index.html">Masalah dengan Windows bukanlah laju pembaruan, tetapi proses pengembangan</a></li>
<li><a href="../id427489/index.html">HomeData: bagaimana analisis data digunakan dalam arsitektur dan urbanisme</a></li>
<li><a href="../id427491/index.html">vDud dalam bahasa Inggris: 7 pewawancara Barat, yang darinya setiap orang mengambil contoh</a></li>
<li><a href="../id427493/index.html">Amplifier kelas frekuensi rendah: A, B, AB, D, G, H</a></li>
<li><a href="../id427495/index.html">Berapa instruksi Habr + bagaimana mengetahui berapa banyak perusahaan lain menghasilkan</a></li>
<li><a href="../id427499/index.html">Apa yang mereka tulis tentang dukungan teknis streamer video?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>