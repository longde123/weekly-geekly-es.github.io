<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî¥ üò∞ ü•ê Technik zum Vermeiden von undefiniertem Verhalten beim Zugriff auf einen Singleton üëáüèΩ ‚ÜîÔ∏è ‚èÆÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel beschreibt die Ursachen und Methoden zur Vermeidung von undefiniertem Verhalten beim Zugriff auf einen Singleton in modernem C ++. Beispie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Technik zum Vermeiden von undefiniertem Verhalten beim Zugriff auf einen Singleton</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/">  Der Artikel beschreibt die Ursachen und Methoden zur Vermeidung von undefiniertem Verhalten beim Zugriff auf einen Singleton in modernem C ++.  Beispiele f√ºr Single-Threaded-Code werden bereitgestellt.  Nichts compilerspezifisches, alles in √úbereinstimmung mit dem Standard. <br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  Zu Beginn empfehle ich Ihnen, andere Artikel √ºber Singleton auf Habr√© zu lesen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drei Zeitalter des Singleton-Musters</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singleton und allgemeine Instanzen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3 M√∂glichkeiten, das Prinzip der Einzelverantwortung zu brechen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singleton - Muster oder Antimuster?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden des Singleton-Musters</a> <br><br>  Und schlie√ülich ein Artikel, der das gleiche Thema ber√ºhrte, aber durchrutschte (schon allein deshalb, weil die Nachteile und Einschr√§nkungen nicht ber√ºcksichtigt wurden): <br>  tialisierte Objekte (dh Objekte <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singleton und Objektlebensdauer</a> <br><br>  Weiter: <br><br><ul><li>  Dies ist <b>kein</b> Artikel √ºber die architektonischen Eigenschaften von Singleton. </li><li>  Dies ist <b>kein</b> Artikel, ‚Äûwie man aus einem schrecklichen und schrecklichen Singleton einen wei√üen und flauschigen Singleton macht‚Äú; </li><li>  Dies ist <b>keine</b> Singleton-Kampagne. </li><li>  es ist <b>kein</b> Kreuzzug gegen Singleton; </li><li>  Dies ist <b>kein</b> Happy-End-Artikel. </li></ul><br>  In diesem Artikel geht es um einen sehr wichtigen, aber immer noch technischen Aspekt der Verwendung von Singleton in modernem C ++.  Das Hauptaugenmerk in dem Artikel liegt auf dem Moment der Zerst√∂rung des Singletons.  In den meisten Quellen ist das Thema Zerst√∂rung nur unzureichend bekannt.  Normalerweise liegt der Schwerpunkt auf dem Moment, in dem der Singleton erstellt wurde, und √ºber Zerst√∂rung sagt er bestenfalls etwas wie "in umgekehrter Reihenfolge zerst√∂rt". <br><br>  <b>Ich bitte Sie, den Umfang des Artikels in den Kommentaren zu befolgen, insbesondere das Singleton-Muster nicht gegen das Singleton-Antipattern-Holivar anzuordnen.</b> <br><br>  Also lass uns gehen. <br><br><h3>  Was der Standard sagt </h3><br>  Die Zitate stammen aus dem endg√ºltigen Entwurf von C ++ 14, N3936, as  verf√ºgbare C ++ 17-Entw√ºrfe werden nicht als "endg√ºltig" markiert. <br>  Ich gebe den wichtigsten Abschnitt in seiner Gesamtheit.  Wichtige Orte werden von mir hervorgehoben. <br><br><blockquote>  3.6.3 K√ºndigung [basic.start.term] <br><br>  1. Destruktoren (12.4) f√ºr initialisierte Objekte (dh Objekte, deren Lebensdauer (3.8) begonnen hat) mit statischer Speicherdauer werden als Ergebnis der R√ºckkehr von main und als Ergebnis des Aufrufs von std :: exit (18.5) aufgerufen.  Destruktoren f√ºr initialisierte Objekte mit Thread-Speicherdauer innerhalb eines bestimmten Threads werden als Ergebnis der R√ºckkehr von der Anfangsfunktion dieses Threads und als Ergebnis des Aufrufs von std :: exit durch diesen Thread aufgerufen.  <b>Die Vervollst√§ndigungen der Destruktoren f√ºr alle initialisierten Objekte mit Thread-Speicherdauer innerhalb dieses Threads werden vor der Initiierung der Destruktoren eines Objekts mit statischer Speicherdauer sequenziert.</b>  <b>Wenn der Abschluss des Konstruktors oder die dynamische Initialisierung eines Objekts mit Thread-Speicherdauer vor dem eines anderen sequenziert wird, wird der Abschluss des Destruktors des zweiten vor der Initiierung des Destruktors des ersten sequenziert.</b>  <b>Wenn der Abschluss des Konstruktors oder die dynamische Initialisierung eines Objekts mit statischer Speicherdauer vor dem eines anderen sequenziert wird, wird der Abschluss des Destruktors des zweiten vor der Initiierung des Destruktors des ersten sequenziert.</b>  [Hinweis: Diese Definition erm√∂glicht die gleichzeitige Zerst√∂rung.  ‚ÄìEnde Hinweis] Wenn ein Objekt statisch initialisiert wird, wird das Objekt in derselben Reihenfolge zerst√∂rt, als ob das Objekt dynamisch initialisiert worden w√§re.  Bei einem Objekt vom Typ Array oder Klasse werden alle Unterobjekte dieses Objekts zerst√∂rt, bevor ein Blockbereichsobjekt mit statischer Speicherdauer, das w√§hrend der Erstellung der Unterobjekte initialisiert wurde, zerst√∂rt wird.  Wenn die Zerst√∂rung eines Objekts mit statischer oder Thread-Speicherdauer √ºber eine Ausnahme beendet wird, wird std :: terminate (15.5.1) aufgerufen. <br><br>  2. <b>Wenn eine Funktion ein Block-Scope-Objekt mit statischer oder Thread-Speicherdauer enth√§lt, das zerst√∂rt wurde, und die Funktion w√§hrend der Zerst√∂rung eines Objekts mit statischer oder Thread-Speicherdauer aufgerufen wird, hat das Programm ein undefiniertes Verhalten, wenn der Steuerungsfluss erfolgreich ist durch die Definition des zuvor zerst√∂rten Blockscope-Objekts.</b>  Ebenso ist das Verhalten undefiniert, wenn das Block-Scope-Objekt nach seiner Zerst√∂rung indirekt (dh √ºber einen Zeiger) verwendet wird. <br><br>  <b>3. Wenn der Abschluss der Initialisierung eines Objekts mit statischer Speicherdauer vor einem Aufruf von std :: atexit (siehe "cstdlib", 18.5) sequenziert wird, wird der Aufruf der an std :: atexit √ºbergebenen Funktion vor dem Aufruf sequenziert an den Destruktor f√ºr das Objekt.</b>  <b>Wenn ein Aufruf von std :: atexit vor Abschluss der Initialisierung eines Objekts mit statischer Speicherdauer sequenziert wird, wird der Aufruf des Destruktors f√ºr das Objekt vor dem Aufruf der an std :: atexit √ºbergebenen Funktion sequenziert.</b>  <b>Wenn ein Aufruf von std :: atexit vor einem weiteren Aufruf von std :: atexit sequenziert wird, wird der Aufruf der an den zweiten std :: atexit-Aufruf √ºbergebenen Funktion vor dem Aufruf der an den ersten std :: atexit-Aufruf √ºbergebenen Funktion sequenziert .</b> <br><br>  4. Wenn ein Standardbibliotheksobjekt oder eine Standardbibliotheksfunktion innerhalb der Signalhandler (18.10) nicht zul√§ssig ist, erfolgt dies nicht vor (1.10) Abschluss der Zerst√∂rung von Objekten mit statischer Speicherdauer und Ausf√ºhrung der registrierten std :: atexit-Funktionen (18.5) ) hat das Programm ein undefiniertes Verhalten.  [Hinweis: Wenn ein Objekt mit statischer Speicherdauer verwendet wird, das nicht vor der Zerst√∂rung des Objekts auftritt, weist das Programm ein undefiniertes Verhalten auf.  Das Beenden jedes Threads vor einem Aufruf von std :: exit oder dem Beenden von main ist ausreichend, aber nicht erforderlich, um diese Anforderungen zu erf√ºllen.  Diese Anforderungen erm√∂glichen Thread-Manager als Objekte mit statischer Speicherdauer.  - Endnote] <br><br>  5. Durch Aufrufen der in ‚Äûcstdlib‚Äú deklarierten Funktion std :: abort () wird das Programm beendet, ohne Destruktoren auszuf√ºhren und ohne die an std :: atexit () oder std :: at_quick_exit () √ºbergebenen Funktionen aufzurufen. </blockquote>  Interpretation: <br><br><ul><li>  Die Zerst√∂rung von Objekten mit Thread-Speicherdauer erfolgt in umgekehrter Reihenfolge ihrer Erstellung. </li><li>  Unmittelbar danach werden Objekte mit statischer Speicherdauer zerst√∂rt und Funktionen, die bei std :: atexit registriert sind, in umgekehrter Reihenfolge aufgerufen, in der solche Objekte erstellt und solche Funktionen registriert werden. </li><li>  Ein Versuch, auf ein zerst√∂rtes Objekt mit Thread-Speicherdauer oder statischer Speicherdauer zuzugreifen, enth√§lt undefiniertes Verhalten.  Eine Neuinitialisierung solcher Objekte ist nicht vorgesehen. </li></ul><br>  Hinweis: Globale Variablen im Standard werden als "nicht lokale Variable mit statischer Speicherdauer" bezeichnet.  Als Ergebnis stellt sich heraus, dass alle globalen Variablen, alle Singletones (lokale Statik) und alle Aufrufe von std :: atexit beim Erstellen / Registrieren in eine einzige LIFO-Warteschlange fallen. <br><br>  Informationen, die f√ºr den Artikel n√ºtzlich sind, finden Sie auch in Abschnitt <b>3.6.2 Initialisierung nicht lokaler Variablen [basic.start.init]</b> .  Ich bringe nur das Wichtigste mit: <br><blockquote>  Die dynamische Initialisierung einer nicht lokalen Variablen mit statischer Speicherdauer ist entweder geordnet oder ungeordnet.  [...] Variablen mit geordneter Initialisierung, die in einer einzelnen √úbersetzungseinheit definiert sind, werden in der Reihenfolge ihrer Definitionen in der √úbersetzungseinheit initialisiert. </blockquote>  Interpretation (unter Ber√ºcksichtigung des vollst√§ndigen Textes des Abschnitts): Globale Variablen innerhalb einer √úbersetzungseinheit werden in der Deklarationsreihenfolge initialisiert. <br><br><h3>  Was wird im Code sein </h3><br>  Alle im Artikel bereitgestellten Codebeispiele werden auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github ver√∂ffentlicht</a> . <br><br>  Der Code besteht aus drei Ebenen, als ob er von verschiedenen Personen geschrieben wurde: <br><br><ul><li>  Singleton; </li><li>  Dienstprogramm (Klasse mit Singleton); </li><li>  Benutzer (globale Variablen und main). </li></ul><br>  Singleton und das Dienstprogramm sind wie eine Bibliothek eines Drittanbieters, und der Benutzer ist der Benutzer. <br>  Die Utility-Schicht dient dazu, die Benutzerschicht von der Singleton-Schicht zu isolieren.  In den Beispielen hat der Benutzer die M√∂glichkeit, auf den Singleton zuzugreifen, aber wir werden so tun, als ob dies unm√∂glich w√§re. <br><br>  Der Benutzer macht zuerst alles richtig und dann bricht mit einem Handgriff alles.  Zuerst versuchen wir, es in der Utility-Schicht zu beheben, und wenn es nicht funktioniert, dann in der Singleton-Schicht. <br><br>  Im Code werden wir st√§ndig am Rand entlang gehen - jetzt auf der hellen Seite, dann auf der dunklen Seite.  Um den Wechsel zur dunklen Seite zu erleichtern, wurde der schwierigste Fall ausgew√§hlt - der Zugriff auf einen Singleton √ºber den Utility-Destruktor. <br><br>  <b>Warum ist der Anruf vom Destruktor am schwierigsten?</b>  Da der Utility-Destruktor beim Minimieren der Anwendung aufgerufen werden kann, wird die Frage "Wurde der Singleton zerst√∂rt oder noch nicht" relevant. <br><br>  <b>Der Fall ist eine Art synthetischer.</b>  <b>In der Praxis sind Aufrufe eines Singletons vom Destruktor nicht erforderlich.</b>  Auch nach Bedarf.  Zum Beispiel, um die Zerst√∂rung von Objekten zu protokollieren. <br><br>  Es werden drei Klassen von Singleton verwendet: <br><br><ul><li>  SingletonClassic - keine intelligenten Zeiger.  Tats√§chlich ist es nicht direkt ganz klassisch, aber definitiv das klassischste unter den drei betrachteten; </li><li>  SingletonShared - mit std :: shared_ptr; </li><li>  SingletonWeak - mit std :: schwach_ptr. </li></ul><br>  Alle Singletones sind Vorlagen.  Der Template-Parameter wird verwendet, um davon zu erben.  In den meisten Beispielen werden sie von der Payload-Klasse parametrisiert, die eine √∂ffentliche Funktion zum Hinzuf√ºgen von Daten zu std :: set bereitstellt. <br><br>  In den meisten Beispielen versucht der Utility-Destruktor, dort hundert Werte einzugeben.  Die Diagnoseausgabe an die Konsole wird auch vom Singleton-Konstruktor, dem Singleton-Destruktor und instance () verwendet. <br><br>  <b>Warum so schwer?</b>  Um leichter zu verstehen, dass wir auf der dunklen Seite sind.  Der Appell an den zerst√∂rten Singleton ist ein undefiniertes Verhalten, das sich jedoch m√∂glicherweise nicht extern manifestiert.  Das Einf√ºgen von Werten in das zerst√∂rte std :: set garantiert sicherlich auch keine externen Manifestationen, aber es gibt keinen zuverl√§ssigeren Weg (tats√§chlich wird in GCC unter Linux in falschen Beispielen mit dem klassischen Singleton das zerst√∂rte std :: set erfolgreich gestopft und in MSVS unter Windows - h√§ngt).  Bei undefiniertem Verhalten erfolgt die Ausgabe an die Konsole m√∂glicherweise <b>nicht</b> .  In den richtigen Beispielen erwarten wir also das Fehlen eines Zugriffs auf instance () nach dem Destruktor sowie das Fehlen eines Absturzes und das Fehlen eines Hangs und in den falschen entweder das Vorhandensein eines solchen Aufrufs oder eines Absturzes oder eines H√§ngens oder alles auf einmal in einer beliebigen Kombination oder was auch immer. <br><br><h3>  Klassischer Singleton </h3><br><div class="spoiler">  <b class="spoiler_title">Payload.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; class Payload { public: Payload() = default; ~Payload() = default; Payload(const Payload &amp;) = delete; Payload(Payload &amp;&amp;) = delete; Payload&amp; operator=(const Payload &amp;) = delete; Payload&amp; operator=(Payload &amp;&amp;) = delete; void add(int value) { m_data.emplace(value); } private: std::set&lt;int&gt; m_data; };</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">SingletonClassic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T&gt; class SingletonClassic : public T { public: ~SingletonClassic() { std::cout &lt;&lt; "~SingletonClassic()" &lt;&lt; std::endl; } SingletonClassic(const SingletonClassic &amp;) = delete; SingletonClassic(SingletonClassic &amp;&amp;) = delete; SingletonClassic&amp; operator=(const SingletonClassic &amp;) = delete; SingletonClassic&amp; operator=(SingletonClassic &amp;&amp;) = delete; static SingletonClassic&amp; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; static SingletonClassic inst; return inst; } private: SingletonClassic() { std::cout &lt;&lt; "SingletonClassic()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br><h3>  SingletonClassic Beispiel 1 </h3><br><div class="spoiler">  <b class="spoiler_title">Classic_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br>  Das Dienstprogramm ruft den Singleton im Konstruktor auf, um sicherzustellen, dass der Singleton erstellt wird, bevor das Dienstprogramm erstellt wird. <br><br>  Der Benutzer erstellt zwei std :: unique_ptr: eine leere, die zweite enth√§lt das Dienstprogramm. <br><br>  Die Reihenfolge der Sch√∂pfung: <br><br>  - leer std :: unique_ptr. <br>  - Singleton; <br>  - Dienstprogramm. <br><br>  Und dementsprechend die Reihenfolge der Zerst√∂rung: <br><br>  - Dienstprogramm; <br>  - Singleton; <br>  - leer std :: unique_ptr. <br><br>  Der Aufruf vom Utility-Destruktor an den Singleton ist korrekt. <br><br><h3>  SingletonClassic Beispiel 2 </h3><br>  Alles ist gleich, aber der Benutzer hat es genommen und alles mit einer Zeile ruiniert. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  ~ SingletonClassic () <br>  instance () <br></div></div><br>  Die Ordnung der Sch√∂pfung und Zerst√∂rung bleibt erhalten.  Es scheint, dass alles still ist.  Aber nein.  Durch Aufrufen von emptyUnique.swap (UtilityUnique) hat der Benutzer ein undefiniertes Verhalten begangen. <br><br>  <b>Warum hat der Benutzer so dumme Dinge getan?</b>  Weil er nichts √ºber die interne Struktur der Bibliothek wei√ü, die ihm einen Singleton und ein Dienstprogramm verschaffte. <br><br>  <b>Und wenn Sie die interne Struktur der Bibliothek kennen?</b>  ... dann ist es in echtem Code sehr einfach, sich zu engagieren.  Und du musst durch schmerzhaftes Debag raus, weil  zu verstehen, was genau passiert ist, wird nicht einfach sein. <br><br>  <b>Warum muss die Bibliothek nicht korrekt verwendet werden?</b>  <b>Nun, es gibt alle Arten von Docks zu schreiben, Beispiele ...</b> Und warum nicht eine Bibliothek erstellen, die nicht so einfach zu verderben ist? <br><br><h3>  SingletonClassic Beispiel 3 </h3><br>  W√§hrend der Vorbereitung des Artikels f√ºr mehrere Tage glaubte ich, dass es unm√∂glich war, unbestimmtes Verhalten aus dem vorherigen Beispiel in der Utility-Schicht zu entfernen, und die L√∂sung war nur in der Singleton-Schicht verf√ºgbar.  Im Laufe der Zeit wurde jedoch eine L√∂sung gefunden. <br><br>  Bevor Sie die Spoiler mit dem Code und der Erkl√§rung √∂ffnen, empfehle ich dem Leser, selbst einen Ausweg aus der Situation zu finden (nur in der Utility-Schicht!).  Ich schlie√üe nicht aus, dass es bessere L√∂sungen gibt. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { thread_local auto flag_strong = std::make_shared&lt;char&gt;(0); m_flag_weak = flag_strong; SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { if ( !m_flag_weak.expired() ) { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } } private: std::weak_ptr&lt;char&gt; m_flag_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); { // To demonstrate normal processing before application ends auto utility = ClassicSingleThreadedUtility(); } // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect ... // ... but utility uses a variable with thread storage duration to detect thread termination. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Erkl√§rung</b> <div class="spoiler_text">  Das Problem tritt nur auf, wenn die Anwendung minimiert wird.  Undefiniertes Verhalten kann beseitigt werden, indem dem Dienstprogramm beigebracht wird, zu erkennen, wann die Anwendung minimiert wird.  Zu diesem Zweck haben wir eine Variable flag_strong vom Typ std :: shared_ptr verwendet, die √ºber ein Qualifikationsmerkmal f√ºr die Thread-Speicherdauer verf√ºgt (siehe Ausz√ºge aus dem Standard im obigen Artikel). Dies ist wie eine statische Variable, wird jedoch nur zerst√∂rt, wenn der aktuelle Thread endet, <b>bevor eine der Statiken zerst√∂rt wird</b> , auch vor der Zerst√∂rung Singleton.  Die Variable flag_strong ist eine f√ºr den gesamten Stream, und jede Instanz des Dienstprogramms speichert ihre schwache Kopie. <br><br>  Im engeren Sinne kann die L√∂sung als Hack bezeichnet werden, weil  es ist indirekt und nicht offensichtlich.  Au√üerdem warnt es zu fr√ºh und manchmal (in einer Multithread-Anwendung) warnt es im Allgemeinen falsch.  Im weitesten Sinne ist dies jedoch kein Hack, sondern eine L√∂sung, die vollst√§ndig durch die Standardeigenschaften definiert ist - sowohl Nachteile als auch Vorteile. <br></div></div><br><h3>  Singletonshared </h3><br>  Fahren wir mit einem modifizierten Singleton fort, der auf std :: shared_ptr basiert. <br><br><div class="spoiler">  <b class="spoiler_title">SingletonShared.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonShared : public T { public: ~SingletonShared() { std::cout &lt;&lt; "~SingletonShared()" &lt;&lt; std::endl; } SingletonShared(const SingletonShared &amp;) = delete; SingletonShared(SingletonShared &amp;&amp;) = delete; SingletonShared&amp; operator=(const SingletonShared &amp;) = delete; SingletonShared&amp; operator=(SingletonShared &amp;&amp;) = delete; static std::shared_ptr&lt;SingletonShared&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonShared&gt;(new SingletonShared); return inst; } private: SingletonShared() { std::cout &lt;&lt; "SingletonShared()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  <b>Ai-ai-ai, der neue Operator sollte nicht in modernem Code verwendet werden, stattdessen wird std :: make_shared ben√∂tigt!</b>  Und dies wird durch den privaten Konstruktor des Singletons verhindert. <br><br>  <b>Ha!</b>  <b>Ich habe auch ein Problem!</b>  <b>Erkl√§re std :: make_shared als Singleton-Freund!</b>  ... und erhalten Sie eine Variation des Antipatterns PublicMorozov: Mit demselben std :: make_shared k√∂nnen zus√§tzliche Instanzen des Singletons erstellt werden, die von der Architektur nicht bereitgestellt werden. <br><br><h3>  SingletonShared-Beispiele 1 und 2 </h3><br>  Entsprechen vollst√§ndig den Beispielen Nr. 1 und 2 f√ºr die klassische Version.  Wesentliche √Ñnderungen wurden nur an der Singleton-Schicht vorgenommen, das Dienstprogramm blieb im Wesentlichen gleich.  Genau wie in den Beispielen mit dem klassischen Singleton ist Beispiel 1 korrekt und Beispiel 2 zeigt undefiniertes Verhalten. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Payload.h&gt; #include &lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { if ( auto instance = SingletonShared&lt;Payload&gt;::instance() ) for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  instance () <br>  ~ SingletonShared () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( auto instance = SingletonShared::instance() ) // for ( int i = 0; i &lt; 100; ++i ) // instance-&gt;add(i); // ... so this code will demonstrate UB in colour auto instance = SingletonShared&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><h3>  SingletonShared-Beispiel 3 </h3><br>  Und jetzt werden wir versuchen, dieses Problem besser zu beheben als im Beispiel Nummer 3 der Klassiker. <br>  Die L√∂sung liegt auf der Hand: Sie m√ºssen lediglich die Lebensdauer des Singletons verl√§ngern, indem Sie eine vom Singleton zur√ºckgegebene Kopie von std :: shared_ptr im Dienstprogramm speichern.  Und diese L√∂sung, zusammen mit SingletonShared, wurde in Open Source weitgehend repliziert. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br></div></div><br>  Und nun, Aufmerksamkeit, die Frage ist: <b>Wollten Sie wirklich das Leben eines Singletons verl√§ngern?</b> <br>  Oder wollten Sie unbestimmtes Verhalten loswerden und die Verl√§ngerung des Lebens als einen Weg w√§hlen, der an der Oberfl√§che liegt? <br><br>  Theoretische Unkorrektheit in Form der Substitution von Zielen durch Mittel f√ºhrt zum Risiko eines Deadlocks (oder einer zyklischen Referenz - nennen Sie es so, wie Sie es wollen). <br><br>  <b>Ja nuuuuuu, so musst du es versuchen !?</b>  <b>Sie m√ºssen sich so viel Zeit einfallen lassen, und Sie werden es sicherlich nicht zuf√§llig tun!</b> <br><br><div class="spoiler">  <b class="spoiler_title">CallbackPayload.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; class CallbackPayload { public: CallbackPayload() = default; ~CallbackPayload() = default; CallbackPayload(const CallbackPayload &amp;) = delete; CallbackPayload(CallbackPayload &amp;&amp;) = delete; CallbackPayload&amp; operator=(const CallbackPayload &amp;) = delete; CallbackPayload&amp; operator=(CallbackPayload &amp;&amp;) = delete; void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { m_callbackFn = std::move(fn); } private: std::function&lt;void()&gt; m_callbackFn; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SomethingWithVeryImportantDestructor.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class SomethingWithVeryImportantDestructor { public: SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } ~SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "~SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } SomethingWithVeryImportantDestructor(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example4_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "SharedSingleThreadedUtility()" &lt;&lt; std::endl; } ~SharedSingleThreadedUtility() { std::cout &lt;&lt; "~SharedSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( m_singleton ) m_singleton-&gt;setCallback(std::move(fn)); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton; }; int main() { auto utility = std::make_shared&lt;SharedSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  SharedSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br></div></div><br>  Ein Singleton wurde erstellt. <br><br>  Ein Dienstprogramm wurde erstellt. <br><br>  <b>Es wurde etwas S-Very-Important-Destructor erstellt</b> (ich habe dies zur Einsch√ºchterung hinzugef√ºgt, da es im Internet Beitr√§ge wie "Nun, der Singleton-Destruktor wird nicht aufgerufen, also was ist, er muss die ganze Zeit existieren." Programme ‚Äù). <br><br>  Aber f√ºr keines dieser Objekte wurde ein Zerst√∂rer gerufen! <br><br>  Wegen was?  Aufgrund der Substitution von Toren durch Mittel. <br><br><h3>  Singletonweak </h3><br><div class="spoiler">  <b class="spoiler_title">SingletonWeak.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonWeak : public T { public: ~SingletonWeak() { std::cout &lt;&lt; "~SingletonWeak()" &lt;&lt; std::endl; } SingletonWeak(const SingletonWeak &amp;) = delete; SingletonWeak(SingletonWeak &amp;&amp;) = delete; SingletonWeak&amp; operator=(const SingletonWeak &amp;) = delete; SingletonWeak&amp; operator=(SingletonWeak &amp;&amp;) = delete; static std::weak_ptr&lt;SingletonWeak&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonWeak&gt;(new SingletonWeak); return inst; } private: SingletonWeak() { std::cout &lt;&lt; "SingletonWeak()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  Eine solche Modifikation des Singletons in Open Source ist, wenn gegeben, sicherlich nicht oft.  Ich bin auf einige seltsame Optionen gesto√üen, die mit einem std :: schwach_ptr auf den Kopf gestellt wurden, der anscheinend verwendet wird und dem Dienstprogramm anscheinend nichts weiter bietet, als die Lebensdauer eines Singletons zu verl√§ngern: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singletons mit std :: schwach_ptr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ist es der richtige Weg, eine sinlgeton-Klasse mit schwachem_ptr zu erstellen?</a> </li></ul><br>  Die von mir vorgeschlagene Option bei korrekter Anwendung in Singleton- und Utility-Ebenen: <br><br><ul><li>  sch√ºtzt vor Aktionen in der in den obigen Beispielen beschriebenen Benutzerebene, einschlie√ülich Verhinderung von Deadlocks; </li><li>  bestimmt den Moment der Anwendungsfaltung genauer als die thread_local-Anwendung in Classic_Example3_correct, d.h.  erm√∂glicht es Ihnen, n√§her an den Rand zu kommen; </li><li>  Ich leide nicht unter dem theoretischen Problem, Ziele durch Mittel zu ersetzen (ich wei√ü nicht, ob aus diesem theoretischen Problem etwas anderes als ein Deadlock hervorgehen kann). </li></ul><br>  Es gibt jedoch einen Nachteil: Wenn Sie die Lebensdauer eines Singletons verl√§ngern, kann er <b>immer noch n√§her</b> an den Rand kommen. <br><br><h3>  SingletonWeak Beispiel 1 </h3><br>  √Ñhnlich wie bei Shared_Example3_correct.cpp. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of WeakSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;WeakSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;WeakSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a weak copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br></div></div><br>  <b>Warum brauchen wir SingletonWeak, weil niemand das Dienstprogramm st√∂rt, SingletonShared als SingletonWeak zu verwenden?</b>  Ja, niemand st√∂rt.  Und selbst niemand st√∂rt das Dienstprogramm, SingletonWeak als SingletonShared zu verwenden.  Die Verwendung f√ºr den beabsichtigten Zweck ist jedoch etwas einfacher als die Verwendung f√ºr andere Zwecke. <br><br><h3>  SingletonWeak Beispiel 2 </h3><br>  √Ñhnlich wie Shared_Example4_incorrect, aber in diesem Fall tritt nur kein Deadlock auf. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example2_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "WeakSingleThreadedUtility()" &lt;&lt; std::endl; } ~WeakSingleThreadedUtility() { std::cout &lt;&lt; "~WeakSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( auto strong = m_weak.lock() ) strong-&gt;setCallback(std::move(fn)); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak; }; int main() { auto utility = std::make_shared&lt;WeakSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  WeakSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br>  ~ SingletonWeak () <br>  ~ SomethingWithVeryImportantDestructor () <br>  ~ WeakSingleThreadedUtility () <br></div></div><br><h3>  Anstelle einer Schlussfolgerung </h3><br>  <b>Und was, eine solche Modifikation eines Singletons wird undefiniertes Verhalten beseitigen?</b>  Ich habe versprochen, dass es kein Happy End geben wird.  Die folgenden Beispiele zeigen, dass geschickte Sabotage in der Benutzerebene sogar die richtige durchdachte Bibliothek mit einem Singleton zerst√∂ren kann (aber wir m√ºssen zugeben, dass <b>dies</b> kaum zuf√§llig m√∂glich ist). <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example5_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; void cracker() { SharedSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = SharedSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Weak_Example3_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; void cracker() { WeakSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = WeakSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br>  instance () <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455848/">https://habr.com/ru/post/de455848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455834/index.html">Benchmarks f√ºr Linux-Server: 5 offene Tools</a></li>
<li><a href="../de455840/index.html">So arbeiten Sie mit mehreren Abfragen. Zusammensetzung, Reduzierer, FP</a></li>
<li><a href="../de455842/index.html">Verbreiten Sie eine einfach verkn√ºpfte Liste. Schnelle Ausgabe</a></li>
<li><a href="../de455844/index.html">Erstellen eines Roslyn-Analysators am Beispiel eines Kapselungstests</a></li>
<li><a href="../de455846/index.html">Distributed Computing in Julia</a></li>
<li><a href="../de455850/index.html">Toolbox f√ºr Forscher - Dritte Ausgabe: Finden und Arbeiten mit Quellen</a></li>
<li><a href="../de455852/index.html">Sinuslifting und gleichzeitige Implantation</a></li>
<li><a href="../de455854/index.html">So implementieren Sie Kontextmen√ºs in iOS 13</a></li>
<li><a href="../de455856/index.html">Drahtloser Temperatur-, Feuchtigkeits- und Atmosph√§rendrucksensor am nRF52832</a></li>
<li><a href="../de455858/index.html">Kabelfernsehnetze f√ºr die Kleinsten. Teil 9: Kopfstelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>