<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 😰 🥐 Technik zum Vermeiden von undefiniertem Verhalten beim Zugriff auf einen Singleton 👇🏽 ↔️ ⏮️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Artikel beschreibt die Ursachen und Methoden zur Vermeidung von undefiniertem Verhalten beim Zugriff auf einen Singleton in modernem C ++. Beispie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Technik zum Vermeiden von undefiniertem Verhalten beim Zugriff auf einen Singleton</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/">  Der Artikel beschreibt die Ursachen und Methoden zur Vermeidung von undefiniertem Verhalten beim Zugriff auf einen Singleton in modernem C ++.  Beispiele für Single-Threaded-Code werden bereitgestellt.  Nichts compilerspezifisches, alles in Übereinstimmung mit dem Standard. <br><a name="habracut"></a><br><h3>  Einführung </h3><br>  Zu Beginn empfehle ich Ihnen, andere Artikel über Singleton auf Habré zu lesen: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drei Zeitalter des Singleton-Musters</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singleton und allgemeine Instanzen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3 Möglichkeiten, das Prinzip der Einzelverantwortung zu brechen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singleton - Muster oder Antimuster?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwenden des Singleton-Musters</a> <br><br>  Und schließlich ein Artikel, der das gleiche Thema berührte, aber durchrutschte (schon allein deshalb, weil die Nachteile und Einschränkungen nicht berücksichtigt wurden): <br>  tialisierte Objekte (dh Objekte <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singleton und Objektlebensdauer</a> <br><br>  Weiter: <br><br><ul><li>  Dies ist <b>kein</b> Artikel über die architektonischen Eigenschaften von Singleton. </li><li>  Dies ist <b>kein</b> Artikel, „wie man aus einem schrecklichen und schrecklichen Singleton einen weißen und flauschigen Singleton macht“; </li><li>  Dies ist <b>keine</b> Singleton-Kampagne. </li><li>  es ist <b>kein</b> Kreuzzug gegen Singleton; </li><li>  Dies ist <b>kein</b> Happy-End-Artikel. </li></ul><br>  In diesem Artikel geht es um einen sehr wichtigen, aber immer noch technischen Aspekt der Verwendung von Singleton in modernem C ++.  Das Hauptaugenmerk in dem Artikel liegt auf dem Moment der Zerstörung des Singletons.  In den meisten Quellen ist das Thema Zerstörung nur unzureichend bekannt.  Normalerweise liegt der Schwerpunkt auf dem Moment, in dem der Singleton erstellt wurde, und über Zerstörung sagt er bestenfalls etwas wie "in umgekehrter Reihenfolge zerstört". <br><br>  <b>Ich bitte Sie, den Umfang des Artikels in den Kommentaren zu befolgen, insbesondere das Singleton-Muster nicht gegen das Singleton-Antipattern-Holivar anzuordnen.</b> <br><br>  Also lass uns gehen. <br><br><h3>  Was der Standard sagt </h3><br>  Die Zitate stammen aus dem endgültigen Entwurf von C ++ 14, N3936, as  verfügbare C ++ 17-Entwürfe werden nicht als "endgültig" markiert. <br>  Ich gebe den wichtigsten Abschnitt in seiner Gesamtheit.  Wichtige Orte werden von mir hervorgehoben. <br><br><blockquote>  3.6.3 Kündigung [basic.start.term] <br><br>  1. Destruktoren (12.4) für initialisierte Objekte (dh Objekte, deren Lebensdauer (3.8) begonnen hat) mit statischer Speicherdauer werden als Ergebnis der Rückkehr von main und als Ergebnis des Aufrufs von std :: exit (18.5) aufgerufen.  Destruktoren für initialisierte Objekte mit Thread-Speicherdauer innerhalb eines bestimmten Threads werden als Ergebnis der Rückkehr von der Anfangsfunktion dieses Threads und als Ergebnis des Aufrufs von std :: exit durch diesen Thread aufgerufen.  <b>Die Vervollständigungen der Destruktoren für alle initialisierten Objekte mit Thread-Speicherdauer innerhalb dieses Threads werden vor der Initiierung der Destruktoren eines Objekts mit statischer Speicherdauer sequenziert.</b>  <b>Wenn der Abschluss des Konstruktors oder die dynamische Initialisierung eines Objekts mit Thread-Speicherdauer vor dem eines anderen sequenziert wird, wird der Abschluss des Destruktors des zweiten vor der Initiierung des Destruktors des ersten sequenziert.</b>  <b>Wenn der Abschluss des Konstruktors oder die dynamische Initialisierung eines Objekts mit statischer Speicherdauer vor dem eines anderen sequenziert wird, wird der Abschluss des Destruktors des zweiten vor der Initiierung des Destruktors des ersten sequenziert.</b>  [Hinweis: Diese Definition ermöglicht die gleichzeitige Zerstörung.  –Ende Hinweis] Wenn ein Objekt statisch initialisiert wird, wird das Objekt in derselben Reihenfolge zerstört, als ob das Objekt dynamisch initialisiert worden wäre.  Bei einem Objekt vom Typ Array oder Klasse werden alle Unterobjekte dieses Objekts zerstört, bevor ein Blockbereichsobjekt mit statischer Speicherdauer, das während der Erstellung der Unterobjekte initialisiert wurde, zerstört wird.  Wenn die Zerstörung eines Objekts mit statischer oder Thread-Speicherdauer über eine Ausnahme beendet wird, wird std :: terminate (15.5.1) aufgerufen. <br><br>  2. <b>Wenn eine Funktion ein Block-Scope-Objekt mit statischer oder Thread-Speicherdauer enthält, das zerstört wurde, und die Funktion während der Zerstörung eines Objekts mit statischer oder Thread-Speicherdauer aufgerufen wird, hat das Programm ein undefiniertes Verhalten, wenn der Steuerungsfluss erfolgreich ist durch die Definition des zuvor zerstörten Blockscope-Objekts.</b>  Ebenso ist das Verhalten undefiniert, wenn das Block-Scope-Objekt nach seiner Zerstörung indirekt (dh über einen Zeiger) verwendet wird. <br><br>  <b>3. Wenn der Abschluss der Initialisierung eines Objekts mit statischer Speicherdauer vor einem Aufruf von std :: atexit (siehe "cstdlib", 18.5) sequenziert wird, wird der Aufruf der an std :: atexit übergebenen Funktion vor dem Aufruf sequenziert an den Destruktor für das Objekt.</b>  <b>Wenn ein Aufruf von std :: atexit vor Abschluss der Initialisierung eines Objekts mit statischer Speicherdauer sequenziert wird, wird der Aufruf des Destruktors für das Objekt vor dem Aufruf der an std :: atexit übergebenen Funktion sequenziert.</b>  <b>Wenn ein Aufruf von std :: atexit vor einem weiteren Aufruf von std :: atexit sequenziert wird, wird der Aufruf der an den zweiten std :: atexit-Aufruf übergebenen Funktion vor dem Aufruf der an den ersten std :: atexit-Aufruf übergebenen Funktion sequenziert .</b> <br><br>  4. Wenn ein Standardbibliotheksobjekt oder eine Standardbibliotheksfunktion innerhalb der Signalhandler (18.10) nicht zulässig ist, erfolgt dies nicht vor (1.10) Abschluss der Zerstörung von Objekten mit statischer Speicherdauer und Ausführung der registrierten std :: atexit-Funktionen (18.5) ) hat das Programm ein undefiniertes Verhalten.  [Hinweis: Wenn ein Objekt mit statischer Speicherdauer verwendet wird, das nicht vor der Zerstörung des Objekts auftritt, weist das Programm ein undefiniertes Verhalten auf.  Das Beenden jedes Threads vor einem Aufruf von std :: exit oder dem Beenden von main ist ausreichend, aber nicht erforderlich, um diese Anforderungen zu erfüllen.  Diese Anforderungen ermöglichen Thread-Manager als Objekte mit statischer Speicherdauer.  - Endnote] <br><br>  5. Durch Aufrufen der in „cstdlib“ deklarierten Funktion std :: abort () wird das Programm beendet, ohne Destruktoren auszuführen und ohne die an std :: atexit () oder std :: at_quick_exit () übergebenen Funktionen aufzurufen. </blockquote>  Interpretation: <br><br><ul><li>  Die Zerstörung von Objekten mit Thread-Speicherdauer erfolgt in umgekehrter Reihenfolge ihrer Erstellung. </li><li>  Unmittelbar danach werden Objekte mit statischer Speicherdauer zerstört und Funktionen, die bei std :: atexit registriert sind, in umgekehrter Reihenfolge aufgerufen, in der solche Objekte erstellt und solche Funktionen registriert werden. </li><li>  Ein Versuch, auf ein zerstörtes Objekt mit Thread-Speicherdauer oder statischer Speicherdauer zuzugreifen, enthält undefiniertes Verhalten.  Eine Neuinitialisierung solcher Objekte ist nicht vorgesehen. </li></ul><br>  Hinweis: Globale Variablen im Standard werden als "nicht lokale Variable mit statischer Speicherdauer" bezeichnet.  Als Ergebnis stellt sich heraus, dass alle globalen Variablen, alle Singletones (lokale Statik) und alle Aufrufe von std :: atexit beim Erstellen / Registrieren in eine einzige LIFO-Warteschlange fallen. <br><br>  Informationen, die für den Artikel nützlich sind, finden Sie auch in Abschnitt <b>3.6.2 Initialisierung nicht lokaler Variablen [basic.start.init]</b> .  Ich bringe nur das Wichtigste mit: <br><blockquote>  Die dynamische Initialisierung einer nicht lokalen Variablen mit statischer Speicherdauer ist entweder geordnet oder ungeordnet.  [...] Variablen mit geordneter Initialisierung, die in einer einzelnen Übersetzungseinheit definiert sind, werden in der Reihenfolge ihrer Definitionen in der Übersetzungseinheit initialisiert. </blockquote>  Interpretation (unter Berücksichtigung des vollständigen Textes des Abschnitts): Globale Variablen innerhalb einer Übersetzungseinheit werden in der Deklarationsreihenfolge initialisiert. <br><br><h3>  Was wird im Code sein </h3><br>  Alle im Artikel bereitgestellten Codebeispiele werden auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github veröffentlicht</a> . <br><br>  Der Code besteht aus drei Ebenen, als ob er von verschiedenen Personen geschrieben wurde: <br><br><ul><li>  Singleton; </li><li>  Dienstprogramm (Klasse mit Singleton); </li><li>  Benutzer (globale Variablen und main). </li></ul><br>  Singleton und das Dienstprogramm sind wie eine Bibliothek eines Drittanbieters, und der Benutzer ist der Benutzer. <br>  Die Utility-Schicht dient dazu, die Benutzerschicht von der Singleton-Schicht zu isolieren.  In den Beispielen hat der Benutzer die Möglichkeit, auf den Singleton zuzugreifen, aber wir werden so tun, als ob dies unmöglich wäre. <br><br>  Der Benutzer macht zuerst alles richtig und dann bricht mit einem Handgriff alles.  Zuerst versuchen wir, es in der Utility-Schicht zu beheben, und wenn es nicht funktioniert, dann in der Singleton-Schicht. <br><br>  Im Code werden wir ständig am Rand entlang gehen - jetzt auf der hellen Seite, dann auf der dunklen Seite.  Um den Wechsel zur dunklen Seite zu erleichtern, wurde der schwierigste Fall ausgewählt - der Zugriff auf einen Singleton über den Utility-Destruktor. <br><br>  <b>Warum ist der Anruf vom Destruktor am schwierigsten?</b>  Da der Utility-Destruktor beim Minimieren der Anwendung aufgerufen werden kann, wird die Frage "Wurde der Singleton zerstört oder noch nicht" relevant. <br><br>  <b>Der Fall ist eine Art synthetischer.</b>  <b>In der Praxis sind Aufrufe eines Singletons vom Destruktor nicht erforderlich.</b>  Auch nach Bedarf.  Zum Beispiel, um die Zerstörung von Objekten zu protokollieren. <br><br>  Es werden drei Klassen von Singleton verwendet: <br><br><ul><li>  SingletonClassic - keine intelligenten Zeiger.  Tatsächlich ist es nicht direkt ganz klassisch, aber definitiv das klassischste unter den drei betrachteten; </li><li>  SingletonShared - mit std :: shared_ptr; </li><li>  SingletonWeak - mit std :: schwach_ptr. </li></ul><br>  Alle Singletones sind Vorlagen.  Der Template-Parameter wird verwendet, um davon zu erben.  In den meisten Beispielen werden sie von der Payload-Klasse parametrisiert, die eine öffentliche Funktion zum Hinzufügen von Daten zu std :: set bereitstellt. <br><br>  In den meisten Beispielen versucht der Utility-Destruktor, dort hundert Werte einzugeben.  Die Diagnoseausgabe an die Konsole wird auch vom Singleton-Konstruktor, dem Singleton-Destruktor und instance () verwendet. <br><br>  <b>Warum so schwer?</b>  Um leichter zu verstehen, dass wir auf der dunklen Seite sind.  Der Appell an den zerstörten Singleton ist ein undefiniertes Verhalten, das sich jedoch möglicherweise nicht extern manifestiert.  Das Einfügen von Werten in das zerstörte std :: set garantiert sicherlich auch keine externen Manifestationen, aber es gibt keinen zuverlässigeren Weg (tatsächlich wird in GCC unter Linux in falschen Beispielen mit dem klassischen Singleton das zerstörte std :: set erfolgreich gestopft und in MSVS unter Windows - hängt).  Bei undefiniertem Verhalten erfolgt die Ausgabe an die Konsole möglicherweise <b>nicht</b> .  In den richtigen Beispielen erwarten wir also das Fehlen eines Zugriffs auf instance () nach dem Destruktor sowie das Fehlen eines Absturzes und das Fehlen eines Hangs und in den falschen entweder das Vorhandensein eines solchen Aufrufs oder eines Absturzes oder eines Hängens oder alles auf einmal in einer beliebigen Kombination oder was auch immer. <br><br><h3>  Klassischer Singleton </h3><br><div class="spoiler">  <b class="spoiler_title">Payload.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; class Payload { public: Payload() = default; ~Payload() = default; Payload(const Payload &amp;) = delete; Payload(Payload &amp;&amp;) = delete; Payload&amp; operator=(const Payload &amp;) = delete; Payload&amp; operator=(Payload &amp;&amp;) = delete; void add(int value) { m_data.emplace(value); } private: std::set&lt;int&gt; m_data; };</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">SingletonClassic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T&gt; class SingletonClassic : public T { public: ~SingletonClassic() { std::cout &lt;&lt; "~SingletonClassic()" &lt;&lt; std::endl; } SingletonClassic(const SingletonClassic &amp;) = delete; SingletonClassic(SingletonClassic &amp;&amp;) = delete; SingletonClassic&amp; operator=(const SingletonClassic &amp;) = delete; SingletonClassic&amp; operator=(SingletonClassic &amp;&amp;) = delete; static SingletonClassic&amp; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; static SingletonClassic inst; return inst; } private: SingletonClassic() { std::cout &lt;&lt; "SingletonClassic()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br><h3>  SingletonClassic Beispiel 1 </h3><br><div class="spoiler">  <b class="spoiler_title">Classic_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br>  Das Dienstprogramm ruft den Singleton im Konstruktor auf, um sicherzustellen, dass der Singleton erstellt wird, bevor das Dienstprogramm erstellt wird. <br><br>  Der Benutzer erstellt zwei std :: unique_ptr: eine leere, die zweite enthält das Dienstprogramm. <br><br>  Die Reihenfolge der Schöpfung: <br><br>  - leer std :: unique_ptr. <br>  - Singleton; <br>  - Dienstprogramm. <br><br>  Und dementsprechend die Reihenfolge der Zerstörung: <br><br>  - Dienstprogramm; <br>  - Singleton; <br>  - leer std :: unique_ptr. <br><br>  Der Aufruf vom Utility-Destruktor an den Singleton ist korrekt. <br><br><h3>  SingletonClassic Beispiel 2 </h3><br>  Alles ist gleich, aber der Benutzer hat es genommen und alles mit einer Zeile ruiniert. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  ~ SingletonClassic () <br>  instance () <br></div></div><br>  Die Ordnung der Schöpfung und Zerstörung bleibt erhalten.  Es scheint, dass alles still ist.  Aber nein.  Durch Aufrufen von emptyUnique.swap (UtilityUnique) hat der Benutzer ein undefiniertes Verhalten begangen. <br><br>  <b>Warum hat der Benutzer so dumme Dinge getan?</b>  Weil er nichts über die interne Struktur der Bibliothek weiß, die ihm einen Singleton und ein Dienstprogramm verschaffte. <br><br>  <b>Und wenn Sie die interne Struktur der Bibliothek kennen?</b>  ... dann ist es in echtem Code sehr einfach, sich zu engagieren.  Und du musst durch schmerzhaftes Debag raus, weil  zu verstehen, was genau passiert ist, wird nicht einfach sein. <br><br>  <b>Warum muss die Bibliothek nicht korrekt verwendet werden?</b>  <b>Nun, es gibt alle Arten von Docks zu schreiben, Beispiele ...</b> Und warum nicht eine Bibliothek erstellen, die nicht so einfach zu verderben ist? <br><br><h3>  SingletonClassic Beispiel 3 </h3><br>  Während der Vorbereitung des Artikels für mehrere Tage glaubte ich, dass es unmöglich war, unbestimmtes Verhalten aus dem vorherigen Beispiel in der Utility-Schicht zu entfernen, und die Lösung war nur in der Singleton-Schicht verfügbar.  Im Laufe der Zeit wurde jedoch eine Lösung gefunden. <br><br>  Bevor Sie die Spoiler mit dem Code und der Erklärung öffnen, empfehle ich dem Leser, selbst einen Ausweg aus der Situation zu finden (nur in der Utility-Schicht!).  Ich schließe nicht aus, dass es bessere Lösungen gibt. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { thread_local auto flag_strong = std::make_shared&lt;char&gt;(0); m_flag_weak = flag_strong; SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { if ( !m_flag_weak.expired() ) { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } } private: std::weak_ptr&lt;char&gt; m_flag_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); { // To demonstrate normal processing before application ends auto utility = ClassicSingleThreadedUtility(); } // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect ... // ... but utility uses a variable with thread storage duration to detect thread termination. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Erklärung</b> <div class="spoiler_text">  Das Problem tritt nur auf, wenn die Anwendung minimiert wird.  Undefiniertes Verhalten kann beseitigt werden, indem dem Dienstprogramm beigebracht wird, zu erkennen, wann die Anwendung minimiert wird.  Zu diesem Zweck haben wir eine Variable flag_strong vom Typ std :: shared_ptr verwendet, die über ein Qualifikationsmerkmal für die Thread-Speicherdauer verfügt (siehe Auszüge aus dem Standard im obigen Artikel). Dies ist wie eine statische Variable, wird jedoch nur zerstört, wenn der aktuelle Thread endet, <b>bevor eine der Statiken zerstört wird</b> , auch vor der Zerstörung Singleton.  Die Variable flag_strong ist eine für den gesamten Stream, und jede Instanz des Dienstprogramms speichert ihre schwache Kopie. <br><br>  Im engeren Sinne kann die Lösung als Hack bezeichnet werden, weil  es ist indirekt und nicht offensichtlich.  Außerdem warnt es zu früh und manchmal (in einer Multithread-Anwendung) warnt es im Allgemeinen falsch.  Im weitesten Sinne ist dies jedoch kein Hack, sondern eine Lösung, die vollständig durch die Standardeigenschaften definiert ist - sowohl Nachteile als auch Vorteile. <br></div></div><br><h3>  Singletonshared </h3><br>  Fahren wir mit einem modifizierten Singleton fort, der auf std :: shared_ptr basiert. <br><br><div class="spoiler">  <b class="spoiler_title">SingletonShared.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonShared : public T { public: ~SingletonShared() { std::cout &lt;&lt; "~SingletonShared()" &lt;&lt; std::endl; } SingletonShared(const SingletonShared &amp;) = delete; SingletonShared(SingletonShared &amp;&amp;) = delete; SingletonShared&amp; operator=(const SingletonShared &amp;) = delete; SingletonShared&amp; operator=(SingletonShared &amp;&amp;) = delete; static std::shared_ptr&lt;SingletonShared&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonShared&gt;(new SingletonShared); return inst; } private: SingletonShared() { std::cout &lt;&lt; "SingletonShared()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  <b>Ai-ai-ai, der neue Operator sollte nicht in modernem Code verwendet werden, stattdessen wird std :: make_shared benötigt!</b>  Und dies wird durch den privaten Konstruktor des Singletons verhindert. <br><br>  <b>Ha!</b>  <b>Ich habe auch ein Problem!</b>  <b>Erkläre std :: make_shared als Singleton-Freund!</b>  ... und erhalten Sie eine Variation des Antipatterns PublicMorozov: Mit demselben std :: make_shared können zusätzliche Instanzen des Singletons erstellt werden, die von der Architektur nicht bereitgestellt werden. <br><br><h3>  SingletonShared-Beispiele 1 und 2 </h3><br>  Entsprechen vollständig den Beispielen Nr. 1 und 2 für die klassische Version.  Wesentliche Änderungen wurden nur an der Singleton-Schicht vorgenommen, das Dienstprogramm blieb im Wesentlichen gleich.  Genau wie in den Beispielen mit dem klassischen Singleton ist Beispiel 1 korrekt und Beispiel 2 zeigt undefiniertes Verhalten. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Payload.h&gt; #include &lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { if ( auto instance = SingletonShared&lt;Payload&gt;::instance() ) for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  instance () <br>  ~ SingletonShared () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( auto instance = SingletonShared::instance() ) // for ( int i = 0; i &lt; 100; ++i ) // instance-&gt;add(i); // ... so this code will demonstrate UB in colour auto instance = SingletonShared&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><h3>  SingletonShared-Beispiel 3 </h3><br>  Und jetzt werden wir versuchen, dieses Problem besser zu beheben als im Beispiel Nummer 3 der Klassiker. <br>  Die Lösung liegt auf der Hand: Sie müssen lediglich die Lebensdauer des Singletons verlängern, indem Sie eine vom Singleton zurückgegebene Kopie von std :: shared_ptr im Dienstprogramm speichern.  Und diese Lösung, zusammen mit SingletonShared, wurde in Open Source weitgehend repliziert. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br></div></div><br>  Und nun, Aufmerksamkeit, die Frage ist: <b>Wollten Sie wirklich das Leben eines Singletons verlängern?</b> <br>  Oder wollten Sie unbestimmtes Verhalten loswerden und die Verlängerung des Lebens als einen Weg wählen, der an der Oberfläche liegt? <br><br>  Theoretische Unkorrektheit in Form der Substitution von Zielen durch Mittel führt zum Risiko eines Deadlocks (oder einer zyklischen Referenz - nennen Sie es so, wie Sie es wollen). <br><br>  <b>Ja nuuuuuu, so musst du es versuchen !?</b>  <b>Sie müssen sich so viel Zeit einfallen lassen, und Sie werden es sicherlich nicht zufällig tun!</b> <br><br><div class="spoiler">  <b class="spoiler_title">CallbackPayload.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; class CallbackPayload { public: CallbackPayload() = default; ~CallbackPayload() = default; CallbackPayload(const CallbackPayload &amp;) = delete; CallbackPayload(CallbackPayload &amp;&amp;) = delete; CallbackPayload&amp; operator=(const CallbackPayload &amp;) = delete; CallbackPayload&amp; operator=(CallbackPayload &amp;&amp;) = delete; void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { m_callbackFn = std::move(fn); } private: std::function&lt;void()&gt; m_callbackFn; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SomethingWithVeryImportantDestructor.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class SomethingWithVeryImportantDestructor { public: SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } ~SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "~SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } SomethingWithVeryImportantDestructor(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example4_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "SharedSingleThreadedUtility()" &lt;&lt; std::endl; } ~SharedSingleThreadedUtility() { std::cout &lt;&lt; "~SharedSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( m_singleton ) m_singleton-&gt;setCallback(std::move(fn)); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton; }; int main() { auto utility = std::make_shared&lt;SharedSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  SharedSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br></div></div><br>  Ein Singleton wurde erstellt. <br><br>  Ein Dienstprogramm wurde erstellt. <br><br>  <b>Es wurde etwas S-Very-Important-Destructor erstellt</b> (ich habe dies zur Einschüchterung hinzugefügt, da es im Internet Beiträge wie "Nun, der Singleton-Destruktor wird nicht aufgerufen, also was ist, er muss die ganze Zeit existieren." Programme ”). <br><br>  Aber für keines dieser Objekte wurde ein Zerstörer gerufen! <br><br>  Wegen was?  Aufgrund der Substitution von Toren durch Mittel. <br><br><h3>  Singletonweak </h3><br><div class="spoiler">  <b class="spoiler_title">SingletonWeak.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonWeak : public T { public: ~SingletonWeak() { std::cout &lt;&lt; "~SingletonWeak()" &lt;&lt; std::endl; } SingletonWeak(const SingletonWeak &amp;) = delete; SingletonWeak(SingletonWeak &amp;&amp;) = delete; SingletonWeak&amp; operator=(const SingletonWeak &amp;) = delete; SingletonWeak&amp; operator=(SingletonWeak &amp;&amp;) = delete; static std::weak_ptr&lt;SingletonWeak&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonWeak&gt;(new SingletonWeak); return inst; } private: SingletonWeak() { std::cout &lt;&lt; "SingletonWeak()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  Eine solche Modifikation des Singletons in Open Source ist, wenn gegeben, sicherlich nicht oft.  Ich bin auf einige seltsame Optionen gestoßen, die mit einem std :: schwach_ptr auf den Kopf gestellt wurden, der anscheinend verwendet wird und dem Dienstprogramm anscheinend nichts weiter bietet, als die Lebensdauer eines Singletons zu verlängern: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Singletons mit std :: schwach_ptr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ist es der richtige Weg, eine sinlgeton-Klasse mit schwachem_ptr zu erstellen?</a> </li></ul><br>  Die von mir vorgeschlagene Option bei korrekter Anwendung in Singleton- und Utility-Ebenen: <br><br><ul><li>  schützt vor Aktionen in der in den obigen Beispielen beschriebenen Benutzerebene, einschließlich Verhinderung von Deadlocks; </li><li>  bestimmt den Moment der Anwendungsfaltung genauer als die thread_local-Anwendung in Classic_Example3_correct, d.h.  ermöglicht es Ihnen, näher an den Rand zu kommen; </li><li>  Ich leide nicht unter dem theoretischen Problem, Ziele durch Mittel zu ersetzen (ich weiß nicht, ob aus diesem theoretischen Problem etwas anderes als ein Deadlock hervorgehen kann). </li></ul><br>  Es gibt jedoch einen Nachteil: Wenn Sie die Lebensdauer eines Singletons verlängern, kann er <b>immer noch näher</b> an den Rand kommen. <br><br><h3>  SingletonWeak Beispiel 1 </h3><br>  Ähnlich wie bei Shared_Example3_correct.cpp. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of WeakSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;WeakSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;WeakSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a weak copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br></div></div><br>  <b>Warum brauchen wir SingletonWeak, weil niemand das Dienstprogramm stört, SingletonShared als SingletonWeak zu verwenden?</b>  Ja, niemand stört.  Und selbst niemand stört das Dienstprogramm, SingletonWeak als SingletonShared zu verwenden.  Die Verwendung für den beabsichtigten Zweck ist jedoch etwas einfacher als die Verwendung für andere Zwecke. <br><br><h3>  SingletonWeak Beispiel 2 </h3><br>  Ähnlich wie Shared_Example4_incorrect, aber in diesem Fall tritt nur kein Deadlock auf. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example2_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "WeakSingleThreadedUtility()" &lt;&lt; std::endl; } ~WeakSingleThreadedUtility() { std::cout &lt;&lt; "~WeakSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( auto strong = m_weak.lock() ) strong-&gt;setCallback(std::move(fn)); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak; }; int main() { auto utility = std::make_shared&lt;WeakSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  WeakSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br>  ~ SingletonWeak () <br>  ~ SomethingWithVeryImportantDestructor () <br>  ~ WeakSingleThreadedUtility () <br></div></div><br><h3>  Anstelle einer Schlussfolgerung </h3><br>  <b>Und was, eine solche Modifikation eines Singletons wird undefiniertes Verhalten beseitigen?</b>  Ich habe versprochen, dass es kein Happy End geben wird.  Die folgenden Beispiele zeigen, dass geschickte Sabotage in der Benutzerebene sogar die richtige durchdachte Bibliothek mit einem Singleton zerstören kann (aber wir müssen zugeben, dass <b>dies</b> kaum zufällig möglich ist). <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example5_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; void cracker() { SharedSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = SharedSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Weak_Example3_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; void cracker() { WeakSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = WeakSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Konsolenausgabe</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br>  instance () <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de455848/">https://habr.com/ru/post/de455848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de455834/index.html">Benchmarks für Linux-Server: 5 offene Tools</a></li>
<li><a href="../de455840/index.html">So arbeiten Sie mit mehreren Abfragen. Zusammensetzung, Reduzierer, FP</a></li>
<li><a href="../de455842/index.html">Verbreiten Sie eine einfach verknüpfte Liste. Schnelle Ausgabe</a></li>
<li><a href="../de455844/index.html">Erstellen eines Roslyn-Analysators am Beispiel eines Kapselungstests</a></li>
<li><a href="../de455846/index.html">Distributed Computing in Julia</a></li>
<li><a href="../de455850/index.html">Toolbox für Forscher - Dritte Ausgabe: Finden und Arbeiten mit Quellen</a></li>
<li><a href="../de455852/index.html">Sinuslifting und gleichzeitige Implantation</a></li>
<li><a href="../de455854/index.html">So implementieren Sie Kontextmenüs in iOS 13</a></li>
<li><a href="../de455856/index.html">Drahtloser Temperatur-, Feuchtigkeits- und Atmosphärendrucksensor am nRF52832</a></li>
<li><a href="../de455858/index.html">Kabelfernsehnetze für die Kleinsten. Teil 9: Kopfstelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>