<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌵 🔜 🎛️ Technique pour éviter un comportement indéfini lors de l'accès à un singleton ⛄️ 🎫 📢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article décrit les causes et les méthodes permettant d'éviter un comportement indéfini lors de l'accès à un singleton en c ++ moderne. Des exemples ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Technique pour éviter un comportement indéfini lors de l'accès à un singleton</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/">  L'article décrit les causes et les méthodes permettant d'éviter un comportement indéfini lors de l'accès à un singleton en c ++ moderne.  Des exemples de code à thread unique sont fournis.  Rien de spécifique au compilateur, tout est conforme à la norme. <br><a name="habracut"></a><br><h3>  Présentation </h3><br>  Pour commencer, je vous recommande de lire d'autres articles sur singleton sur Habré: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trois âges de motif Singleton</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singleton et instances communes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3 façons de briser le principe de responsabilité unique</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singleton - motif ou antipattern?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation du motif singleton</a> <br><br>  Et, enfin, un article qui a abordé le même sujet, mais qui s'est glissé (ne serait-ce que parce que les inconvénients et les limites n'ont pas été pris en compte): <br>  des objets spécialisés (c'est-à-dire des objets <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singleton et durée de vie des objets</a> <br><br>  Suivant: <br><br><ul><li>  ce n'est <b>pas</b> un article sur les propriétés architecturales de singleton; </li><li>  ce n'est <b>pas</b> un article «comment faire un singleton blanc et moelleux d'un singleton terrible et terrible»; </li><li>  ce n'est <b>pas une</b> campagne singleton; </li><li>  ce n'est <b>pas</b> une croisade contre singleton; </li><li>  ce n'est <b>pas un</b> article de fin heureuse. </li></ul><br>  Cet article traite d'un aspect très important, mais toujours technique, de l'utilisation de singleton dans le C ++ moderne.  La principale attention de l'article est accordée au moment de la destruction du singleton, comme  dans la plupart des sources, le problème de la destruction est mal divulgué.  Habituellement, l'accent est mis sur le moment où le singleton a été créé, et sur la destruction, au mieux, il dit quelque chose comme «détruit dans l'ordre inverse». <br><br>  <b>Je vous demanderai de suivre la portée de l'article dans les commentaires, en particulier de ne pas organiser l'holivar "modèle singleton vs singleton-antipattern".</b> <br><br>  Alors allons-y. <br><br><h3>  Ce que dit la norme </h3><br>  Les citations sont tirées du projet final N3936 de C ++ 14, comme  les versions C ++ 17 disponibles ne sont pas marquées comme «finales». <br>  Je donne la section la plus importante dans son intégralité.  Des endroits importants sont mis en évidence par moi. <br><br><blockquote>  3.6.3 Résiliation [basic.start.term] <br><br>  1. Les destructeurs (12.4) pour les objets initialisés (c'est-à-dire les objets dont la durée de vie (3.8) a commencé) avec une durée de stockage statique sont appelés suite au retour de main et suite à l'appel à std :: exit (18.5).  Les destructeurs pour les objets initialisés avec une durée de stockage de thread dans un thread donné sont appelés suite au retour de la fonction initiale de ce thread et suite à l'appel de std :: exit par ce thread.  <b>La fin des destructeurs pour tous les objets initialisés avec une durée de stockage de thread dans ce thread est séquencée avant le lancement des destructeurs de tout objet avec une durée de stockage statique.</b>  <b>Si l'achèvement du constructeur ou l'initialisation dynamique d'un objet avec la durée de stockage des threads est séquencé avant celui d'un autre, l'achèvement du destructeur du second est séquencé avant l'initiation du destructeur du premier.</b>  <b>Si l'achèvement du constructeur ou l'initialisation dynamique d'un objet avec une durée de stockage statique est séquencé avant celui d'un autre, l'achèvement du destructeur du second est séquencé avant l'initiation du destructeur du premier.</b>  [Remarque: Cette définition permet la destruction simultanée.  –Fin note] Si un objet est initialisé statiquement, l'objet est détruit dans le même ordre que si l'objet était initialisé dynamiquement.  Pour un objet de type tableau ou classe, tous les sous-objets de cet objet sont détruits avant la destruction de tout objet de portée de bloc avec une durée de stockage statique initialisée lors de la construction des sous-objets.  Si la destruction d'un objet avec une durée de stockage statique ou de thread se termine via une exception, std :: terminate est appelée (15.5.1). <br><br>  2. <b>Si une fonction contient un objet de portée de bloc de durée de stockage statique ou de thread qui a été détruit et que la fonction est appelée pendant la destruction d'un objet avec une durée de stockage statique ou de thread, le programme a un comportement indéfini si le flux de contrôle passe à travers la définition de l'objet blockscope précédemment détruit.</b>  De même, le comportement n'est pas défini si l'objet de portée de bloc est utilisé indirectement (c'est-à-dire via un pointeur) après sa destruction. <br><br>  <b>3. Si l'achèvement de l'initialisation d'un objet avec une durée de stockage statique est séquencé avant un appel à std :: atexit (voir «cstdlib», 18.5), l'appel à la fonction passée à std :: atexit est séquencé avant l'appel au destructeur de l'objet.</b>  <b>Si un appel à std :: atexit est séquencé avant la fin de l'initialisation d'un objet avec une durée de stockage statique, l'appel au destructeur de l'objet est séquencé avant l'appel à la fonction passé à std :: atexit.</b>  <b>Si un appel à std :: atexit est séquencé avant un autre appel à std :: atexit, l'appel à la fonction passé au deuxième appel std :: atexit est séquencé avant l'appel à la fonction passé au premier appel std :: atexit .</b> <br><br>  4. S'il y a une utilisation d'un objet ou d'une fonction de bibliothèque standard non autorisée dans les gestionnaires de signaux (18.10) qui ne se produit pas avant (1.10) la fin de la destruction des objets avec une durée de stockage statique et l'exécution des fonctions enregistrées std :: atexit (18.5 ), le programme a un comportement indéfini.  [Remarque: S'il y a une utilisation d'un objet avec une durée de stockage statique qui ne se produit pas avant la destruction de l'objet, le programme a un comportement indéfini.  Terminer chaque thread avant un appel à std :: exit ou la sortie de main est suffisant, mais pas nécessaire, pour satisfaire ces exigences.  Ces exigences autorisent les gestionnaires de threads en tant qu'objets de durée de stockage statique.  —Fin note] <br><br>  5. L'appel de la fonction std :: abort () déclarée dans "cstdlib" termine le programme sans exécuter aucun destructeur et sans appeler les fonctions passées à std :: atexit () ou std :: at_quick_exit (). </blockquote>  Interprétation: <br><br><ul><li>  la destruction d'objets dont la durée de stockage des threads est effectuée dans l'ordre inverse de leur création; </li><li>  strictement après cela, les objets avec une durée de stockage statique sont détruits et des appels sont effectués vers des fonctions enregistrées avec std :: atexit dans l'ordre inverse de la création de ces objets et de l'enregistrement de ces fonctions; </li><li>  Une tentative d'accès à un objet détruit avec une durée de stockage de thread ou une durée de stockage statique contient un comportement non défini.  La réinitialisation de ces objets n'est pas fournie. </li></ul><br>  Remarque: les variables globales dans la norme sont appelées "variable non locale avec une durée de stockage statique".  En conséquence, il s'avère que toutes les variables globales, tous les singletones (statiques locales) et tous les appels à std :: atexit tombent dans une seule file d'attente LIFO lorsqu'ils sont créés / enregistrés. <br><br>  Les informations utiles pour l'article sont également contenues dans la section <b>3.6.2 Initialisation des variables non locales [basic.start.init]</b> .  J'apporte seulement les plus importants: <br><blockquote>  L'initialisation dynamique d'une variable non locale avec une durée de stockage statique est ordonnée ou non ordonnée.  [...] Les variables à initialisation ordonnée définies au sein d'une même unité de traduction doivent être initialisées dans l'ordre de leurs définitions dans l'unité de traduction. </blockquote>  Interprétation (en tenant compte du texte intégral de la section): les variables globales au sein d'une unité de traduction sont initialisées dans l'ordre de déclaration. <br><br><h3>  Ce qui sera dans le code </h3><br>  Tous les exemples de code fournis dans l'article sont publiés sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br><br>  Le code se compose de trois couches, comme s'il était écrit par des personnes différentes: <br><br><ul><li>  singleton; </li><li>  utilitaire (classe utilisant singleton); </li><li>  utilisateur (variables globales et principales). </li></ul><br>  Singleton et l'utilitaire sont comme une bibliothèque tierce et l'utilisateur est l'utilisateur. <br>  La couche utilitaire est conçue pour isoler la couche utilisateur de la couche singleton.  Dans les exemples, l'utilisateur a la possibilité d'accéder au singleton, mais nous agirons comme si c'était impossible. <br><br>  L'utilisateur fait d'abord tout correctement, puis d'un coup de poignet, tout se casse.  Nous essayons d'abord de le corriger dans la couche utilitaire, et si cela ne fonctionne pas, puis dans la couche singleton. <br><br>  Dans le code, nous marcherons constamment le long du bord - maintenant du côté clair, puis du noir.  Pour faciliter le passage du côté obscur, le cas le plus difficile a été choisi: accéder à un singleton à partir du destructeur d'utilitaires. <br><br>  <b>Pourquoi le cas de l'appel du destructeur est-il le plus difficile?</b>  Parce que le destructeur d'utilitaires peut être appelé dans le processus de minimisation de l'application, lorsque la question «le singleton a-t-il été détruit ou pas encore» devient pertinente. <br><br>  <b>L'affaire est une sorte de synthétique.</b>  <b>En pratique, les appels à un singleton depuis le destructeur ne sont pas nécessaires.</b>  Même au besoin.  Par exemple, pour consigner la destruction d'objets. <br><br>  Trois classes de singleton sont utilisées: <br><br><ul><li>  SingletonClassic - pas de pointeurs intelligents.  En fait, ce n'est pas directement tout à fait classique, mais certainement le plus classique parmi les trois considérés; </li><li>  SingletonShared - avec std :: shared_ptr; </li><li>  SingletonWeak - avec std :: faible_ptr. </li></ul><br>  Tous les singletones sont des modèles.  Le paramètre de modèle est utilisé pour en hériter.  Dans la plupart des exemples, ils sont paramétrés par la classe Payload, qui fournit une fonction publique pour ajouter des données à std :: set. <br><br>  Dans la plupart des exemples, le destructeur d'utilitaires essaie de remplir une centaine de valeurs.  La sortie de diagnostic vers la console est également utilisée à partir du constructeur singleton, du destructeur singleton et de instance (). <br><br>  <b>Pourquoi si dur?</b>  Pour qu'il soit plus facile de comprendre que nous sommes du côté obscur.  L'appel au singleton détruit est un comportement indéfini, mais il ne peut se manifester d'aucune façon en externe.  Le bourrage de valeurs dans le std :: set détruit ne garantit pas non plus les manifestations externes, mais il n'y a pas de moyen plus fiable (en fait, dans GCC sous Linux dans des exemples incorrects avec le singleton classique, le std :: set détruit est correctement bourré, et dans MSVS sous Windows - se bloque).  Avec un comportement non défini, la sortie vers la console peut <b>ne pas</b> se produire.  Ainsi, dans les exemples corrects, nous nous attendons à l'absence d'accès à l'instance () après le destructeur, ainsi qu'à l'absence d'un crash et de l'absence d'un blocage, et dans les mauvais, soit la présence d'un tel appel, ou d'un crash, ou d'un blocage, ou tout d'un coup dans n'importe quelle combinaison, ou quoi que ce soit. <br><br><h3>  Singleton classique </h3><br><div class="spoiler">  <b class="spoiler_title">Payload.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; class Payload { public: Payload() = default; ~Payload() = default; Payload(const Payload &amp;) = delete; Payload(Payload &amp;&amp;) = delete; Payload&amp; operator=(const Payload &amp;) = delete; Payload&amp; operator=(Payload &amp;&amp;) = delete; void add(int value) { m_data.emplace(value); } private: std::set&lt;int&gt; m_data; };</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">SingletonClassic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T&gt; class SingletonClassic : public T { public: ~SingletonClassic() { std::cout &lt;&lt; "~SingletonClassic()" &lt;&lt; std::endl; } SingletonClassic(const SingletonClassic &amp;) = delete; SingletonClassic(SingletonClassic &amp;&amp;) = delete; SingletonClassic&amp; operator=(const SingletonClassic &amp;) = delete; SingletonClassic&amp; operator=(SingletonClassic &amp;&amp;) = delete; static SingletonClassic&amp; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; static SingletonClassic inst; return inst; } private: SingletonClassic() { std::cout &lt;&lt; "SingletonClassic()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br><h3>  Exemple 1 de SingletonClassic </h3><br><div class="spoiler">  <b class="spoiler_title">Classic_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br>  L'utilitaire appelle le singleton dans le constructeur pour s'assurer que le singleton est créé avant la création de l'utilitaire. <br><br>  L'utilisateur crée deux std :: unique_ptr: un vide, le second contenant l'utilitaire. <br><br>  L'ordre de création: <br><br>  - vide std :: unique_ptr. <br>  - singleton; <br>  - utilité. <br><br>  Et en conséquence, l'ordre de destruction: <br><br>  - utilité; <br>  - singleton; <br>  - vide std :: unique_ptr. <br><br>  L'appel du destructeur d'utilitaires au singleton est correct. <br><br><h3>  Exemple 2 de SingletonClassic </h3><br>  Tout est pareil, mais l'utilisateur l'a pris et a tout gâché avec une seule ligne. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  ~ SingletonClassic () <br>  instance () <br></div></div><br>  L'ordre de création et de destruction est préservé.  Il semblerait que tout soit encore.  Mais non.  En appelant emptyUnique.swap (utilityUnique), l'utilisateur a commis un comportement non défini. <br><br>  <b>Pourquoi l'utilisateur a-t-il fait des choses aussi stupides?</b>  Parce qu'il ne sait rien de la structure interne de la bibliothèque, qui lui a fourni un singleton et une utilité. <br><br>  <b>Et si vous connaissez la structure interne de la bibliothèque?</b>  ... de toute façon, dans le vrai code, il est très facile de s’impliquer.  Et vous devez sortir par un débagage douloureux, car  comprendre ce qui s'est exactement passé ne sera pas facile. <br><br>  <b>Pourquoi ne pas exiger que la bibliothèque soit utilisée correctement?</b>  <b>Eh bien, il y a toutes sortes de quais à écrire, des exemples ...</b> Et pourquoi ne pas faire une bibliothèque pas si facile à gâcher? <br><br><h3>  Exemple 3 de SingletonClassic </h3><br>  Au cours de la préparation de l'article pendant plusieurs jours, j'ai cru qu'il était impossible d'éliminer le comportement indéfini de l'exemple précédent dans la couche utilitaire, et la solution n'était disponible que dans la couche singleton.  Mais au fil du temps, une solution a néanmoins été trouvée. <br><br>  Avant d'ouvrir les spoilers avec le code et l'explication, je suggère au lecteur d'essayer de trouver un moyen de sortir de la situation par lui-même (uniquement dans la couche utilitaire!).  Je n'exclus pas qu'il existe de meilleures solutions. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { thread_local auto flag_strong = std::make_shared&lt;char&gt;(0); m_flag_weak = flag_strong; SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { if ( !m_flag_weak.expired() ) { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } } private: std::weak_ptr&lt;char&gt; m_flag_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); { // To demonstrate normal processing before application ends auto utility = ClassicSingleThreadedUtility(); } // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect ... // ... but utility uses a variable with thread storage duration to detect thread termination. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Explication</b> <div class="spoiler_text">  Le problème se produit uniquement lors de la réduction de l'application.  Un comportement indéfini peut être éliminé en apprenant à l'utilitaire à reconnaître lorsque l'application est minimisée.  Pour ce faire, nous avons utilisé une variable flag_strong du type std :: shared_ptr, qui a un qualificatif de durée de stockage des threads (voir des extraits de la norme dans l'article ci-dessus) - c'est comme une statique, mais elle n'est détruite que lorsque le thread actuel se termine <b>avant que toute statique ne soit détruite</b> , y compris avant la destruction singleton.  La variable flag_strong est une pour l'ensemble du flux, et chaque instance de l'utilitaire stocke sa copie faible. <br><br>  Dans un sens étroit, la solution peut être appelée un hack, car  elle est indirecte et non évidente.  De plus, il avertit trop tôt et parfois (dans une application multithread) avertit généralement faux.  Mais au sens large, ce n'est pas un hack, mais une solution complètement définie par les propriétés standard - à la fois des inconvénients et des avantages. <br></div></div><br><h3>  Singletonshared </h3><br>  Passons à un singleton modifié basé sur std :: shared_ptr. <br><br><div class="spoiler">  <b class="spoiler_title">SingletonShared.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonShared : public T { public: ~SingletonShared() { std::cout &lt;&lt; "~SingletonShared()" &lt;&lt; std::endl; } SingletonShared(const SingletonShared &amp;) = delete; SingletonShared(SingletonShared &amp;&amp;) = delete; SingletonShared&amp; operator=(const SingletonShared &amp;) = delete; SingletonShared&amp; operator=(SingletonShared &amp;&amp;) = delete; static std::shared_ptr&lt;SingletonShared&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonShared&gt;(new SingletonShared); return inst; } private: SingletonShared() { std::cout &lt;&lt; "SingletonShared()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  <b>Ai-ai-ai, le nouvel opérateur ne doit pas être utilisé dans le code moderne, à la place std :: make_shared est nécessaire!</b>  Et cela est empêché par le constructeur privé du singleton. <br><br>  <b>Ha!</b>  <b>J'ai aussi un problème!</b>  <b>Déclarez std :: make_shared un ami singleton!</b>  ... et obtenez une variante de l'anti-modèle PublicMorozov: en utilisant le même std :: make_shared, il sera possible de créer des instances supplémentaires du singleton non fournies par l'architecture. <br><br><h3>  Exemples 1 et 2 de SingletonShared </h3><br>  Correspond entièrement aux exemples n ° 1 et 2 pour la version classique.  Des modifications importantes n'ont été apportées qu'à la couche singleton, l'utilité est restée essentiellement la même.  Tout comme dans les exemples avec le singleton classique, l'exemple-1 est correct et l'exemple-2 montre un comportement indéfini. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Payload.h&gt; #include &lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { if ( auto instance = SingletonShared&lt;Payload&gt;::instance() ) for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  instance () <br>  ~ SingletonShared () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( auto instance = SingletonShared::instance() ) // for ( int i = 0; i &lt; 100; ++i ) // instance-&gt;add(i); // ... so this code will demonstrate UB in colour auto instance = SingletonShared&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><h3>  Exemple 3 de SingletonShared </h3><br>  Et maintenant, nous allons essayer de résoudre ce problème mieux que dans l'exemple numéro 3 des classiques. <br>  La solution est évidente: il vous suffit de prolonger la durée de vie du singleton en stockant une copie de std :: shared_ptr retournée par le singleton dans l'utilitaire.  Et cette solution, complète avec SingletonShared, a été largement répliquée dans des sources ouvertes. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br></div></div><br>  Et maintenant, attention, la question est: <b>vouliez-vous vraiment prolonger la vie d'un singleton?</b> <br>  Ou vouliez-vous vous débarrasser d'un comportement indéfini et choisir la prolongation de la vie comme un chemin à la surface? <br><br>  L'inexactitude théorique sous la forme d'une substitution d'objectifs conduit à un risque de blocage (ou de référence cyclique - appelez-le comme vous voulez). <br><br>  <b>Oui nuuuuuu, c'est comme ça qu'il faut essayer si fort!?</b>  <b>Vous devrez trouver si longtemps, et vous ne le ferez certainement pas par accident!</b> <br><br><div class="spoiler">  <b class="spoiler_title">CallbackPayload.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; class CallbackPayload { public: CallbackPayload() = default; ~CallbackPayload() = default; CallbackPayload(const CallbackPayload &amp;) = delete; CallbackPayload(CallbackPayload &amp;&amp;) = delete; CallbackPayload&amp; operator=(const CallbackPayload &amp;) = delete; CallbackPayload&amp; operator=(CallbackPayload &amp;&amp;) = delete; void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { m_callbackFn = std::move(fn); } private: std::function&lt;void()&gt; m_callbackFn; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SomethingWithVeryImportantDestructor.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class SomethingWithVeryImportantDestructor { public: SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } ~SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "~SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } SomethingWithVeryImportantDestructor(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example4_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "SharedSingleThreadedUtility()" &lt;&lt; std::endl; } ~SharedSingleThreadedUtility() { std::cout &lt;&lt; "~SharedSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( m_singleton ) m_singleton-&gt;setCallback(std::move(fn)); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton; }; int main() { auto utility = std::make_shared&lt;SharedSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  SharedSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br></div></div><br>  Un singleton a été créé. <br><br>  Un utilitaire a été créé. <br><br>  <b>Quelque chose de S-Very-Important-Destructor a été créé</b> (j'ai ajouté cela pour l'intimidation, car sur Internet il y a des messages comme "eh bien, le destructeur singleton ne sera pas appelé, alors quoi de cela, il doit exister tout le temps programmes "). <br><br>  Mais aucun destructeur n'a été appelé pour aucun de ces objets! <br><br>  À cause de quoi?  En raison de la substitution des buts par des moyens. <br><br><h3>  Singletonweak </h3><br><div class="spoiler">  <b class="spoiler_title">SingletonWeak.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonWeak : public T { public: ~SingletonWeak() { std::cout &lt;&lt; "~SingletonWeak()" &lt;&lt; std::endl; } SingletonWeak(const SingletonWeak &amp;) = delete; SingletonWeak(SingletonWeak &amp;&amp;) = delete; SingletonWeak&amp; operator=(const SingletonWeak &amp;) = delete; SingletonWeak&amp; operator=(SingletonWeak &amp;&amp;) = delete; static std::weak_ptr&lt;SingletonWeak&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonWeak&gt;(new SingletonWeak); return inst; } private: SingletonWeak() { std::cout &lt;&lt; "SingletonWeak()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  Une telle modification du singleton dans les sources ouvertes, si elle est donnée, n'est certainement pas souvent.  Je suis tombé sur d'étranges options tournées à l'envers avec un std :: faible_ptr, qui semble être utilisé, qui, semble-t-il, n'offre rien de plus que de prolonger la vie d'un singleton: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singletons utilisant std :: faible_ptr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Est-ce la bonne façon de créer la classe sinlgeton par faiblesse_ptr</a> </li></ul><br>  L'option que je propose, lorsqu'elle est appliquée correctement dans les couches singleton et utilitaires: <br><br><ul><li>  protège contre les actions dans la couche utilisateur décrite dans les exemples ci-dessus, y compris empêche l'impasse; </li><li>  détermine le moment du pliage de l'application plus précisément que l'application thread_local dans Classic_Example3_correct, c'est-à-dire  vous permet de vous rapprocher du bord; </li><li>  Je ne souffre pas du problème théorique de substitution d'objectifs par des moyens (je ne sais pas si quelque chose de tangible autre que l'impasse peut apparaître de ce problème théorique). </li></ul><br>  Cependant, il y a un inconvénient: prolonger la durée de vie d'un singleton peut <b>encore lui</b> permettre <b>de</b> se <b>rapprocher encore plus</b> du bord. <br><br><h3>  Exemple 1 de SingletonWeak </h3><br>  Similaire à Shared_Example3_correct.cpp. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of WeakSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;WeakSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;WeakSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a weak copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br></div></div><br>  <b>Pourquoi avons-nous besoin de SingletonWeak, car personne ne dérange l'utilitaire pour utiliser SingletonShared comme SingletonWeak?</b>  Oui, personne ne dérange.  Et même personne ne dérange l'utilitaire pour utiliser SingletonWeak comme SingletonShared.  Mais les utiliser à leur destination est légèrement plus facile que de les utiliser à d'autres fins. <br><br><h3>  Exemple 2 de SingletonWeak </h3><br>  Similaire à Shared_Example4_incorrect, mais seul un blocage ne se produit pas dans ce cas. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example2_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "WeakSingleThreadedUtility()" &lt;&lt; std::endl; } ~WeakSingleThreadedUtility() { std::cout &lt;&lt; "~WeakSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( auto strong = m_weak.lock() ) strong-&gt;setCallback(std::move(fn)); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak; }; int main() { auto utility = std::make_shared&lt;WeakSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  WeakSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br>  ~ SingletonWeak () <br>  ~ SomethingWithVeryImportantDestructor () <br>  ~ WeakSingleThreadedUtility () <br></div></div><br><h3>  Au lieu d'une conclusion </h3><br>  <b>Et quoi, une telle modification d'un singleton éliminera un comportement indéfini?</b>  J'ai promis qu'il n'y aurait pas de fin heureuse.  Les exemples suivants montrent que des actions de sabotage habiles dans la couche utilisateur peuvent détruire même la bibliothèque réfléchie correcte avec un singleton (mais nous devons admettre que <b>cela</b> ne peut guère être fait par accident). <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example5_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; void cracker() { SharedSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = SharedSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Weak_Example3_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; void cracker() { WeakSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = WeakSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br>  instance () <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455848/">https://habr.com/ru/post/fr455848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455834/index.html">Benchmarks pour les serveurs Linux: 5 outils ouverts</a></li>
<li><a href="../fr455840/index.html">Comment travailler avec plusieurs requêtes. Composition, réducteur, FP</a></li>
<li><a href="../fr455842/index.html">Répartissez une liste liée individuellement. Édition Swift</a></li>
<li><a href="../fr455844/index.html">Création d'un analyseur Roslyn en utilisant les tests d'encapsulation comme exemple</a></li>
<li><a href="../fr455846/index.html">Informatique distribuée dans Julia</a></li>
<li><a href="../fr455850/index.html">Boîte à outils pour les chercheurs - Troisième édition: recherche et utilisation de sources</a></li>
<li><a href="../fr455852/index.html">Levée de sinus et implantation simultanée</a></li>
<li><a href="../fr455854/index.html">Comment implémenter les menus contextuels dans iOS 13</a></li>
<li><a href="../fr455856/index.html">Capteur de température, d'humidité et de pression atmosphérique sans fil sur nRF52832</a></li>
<li><a href="../fr455858/index.html">Réseaux de télévision par câble pour les plus petits. Partie 9: Headend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>