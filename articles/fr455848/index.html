<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåµ üîú üéõÔ∏è Technique pour √©viter un comportement ind√©fini lors de l'acc√®s √† un singleton ‚õÑÔ∏è üé´ üì¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article d√©crit les causes et les m√©thodes permettant d'√©viter un comportement ind√©fini lors de l'acc√®s √† un singleton en c ++ moderne. Des exemples ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Technique pour √©viter un comportement ind√©fini lors de l'acc√®s √† un singleton</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455848/">  L'article d√©crit les causes et les m√©thodes permettant d'√©viter un comportement ind√©fini lors de l'acc√®s √† un singleton en c ++ moderne.  Des exemples de code √† thread unique sont fournis.  Rien de sp√©cifique au compilateur, tout est conforme √† la norme. <br><a name="habracut"></a><br><h3>  Pr√©sentation </h3><br>  Pour commencer, je vous recommande de lire d'autres articles sur singleton sur Habr√©: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trois √¢ges de motif Singleton</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singleton et instances communes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">3 fa√ßons de briser le principe de responsabilit√© unique</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singleton - motif ou antipattern?</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation du motif singleton</a> <br><br>  Et, enfin, un article qui a abord√© le m√™me sujet, mais qui s'est gliss√© (ne serait-ce que parce que les inconv√©nients et les limites n'ont pas √©t√© pris en compte): <br>  des objets sp√©cialis√©s (c'est-√†-dire des objets <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singleton et dur√©e de vie des objets</a> <br><br>  Suivant: <br><br><ul><li>  ce n'est <b>pas</b> un article sur les propri√©t√©s architecturales de singleton; </li><li>  ce n'est <b>pas</b> un article ¬´comment faire un singleton blanc et moelleux d'un singleton terrible et terrible¬ª; </li><li>  ce n'est <b>pas une</b> campagne singleton; </li><li>  ce n'est <b>pas</b> une croisade contre singleton; </li><li>  ce n'est <b>pas un</b> article de fin heureuse. </li></ul><br>  Cet article traite d'un aspect tr√®s important, mais toujours technique, de l'utilisation de singleton dans le C ++ moderne.  La principale attention de l'article est accord√©e au moment de la destruction du singleton, comme  dans la plupart des sources, le probl√®me de la destruction est mal divulgu√©.  Habituellement, l'accent est mis sur le moment o√π le singleton a √©t√© cr√©√©, et sur la destruction, au mieux, il dit quelque chose comme ¬´d√©truit dans l'ordre inverse¬ª. <br><br>  <b>Je vous demanderai de suivre la port√©e de l'article dans les commentaires, en particulier de ne pas organiser l'holivar "mod√®le singleton vs singleton-antipattern".</b> <br><br>  Alors allons-y. <br><br><h3>  Ce que dit la norme </h3><br>  Les citations sont tir√©es du projet final N3936 de C ++ 14, comme  les versions C ++ 17 disponibles ne sont pas marqu√©es comme ¬´finales¬ª. <br>  Je donne la section la plus importante dans son int√©gralit√©.  Des endroits importants sont mis en √©vidence par moi. <br><br><blockquote>  3.6.3 R√©siliation [basic.start.term] <br><br>  1. Les destructeurs (12.4) pour les objets initialis√©s (c'est-√†-dire les objets dont la dur√©e de vie (3.8) a commenc√©) avec une dur√©e de stockage statique sont appel√©s suite au retour de main et suite √† l'appel √† std :: exit (18.5).  Les destructeurs pour les objets initialis√©s avec une dur√©e de stockage de thread dans un thread donn√© sont appel√©s suite au retour de la fonction initiale de ce thread et suite √† l'appel de std :: exit par ce thread.  <b>La fin des destructeurs pour tous les objets initialis√©s avec une dur√©e de stockage de thread dans ce thread est s√©quenc√©e avant le lancement des destructeurs de tout objet avec une dur√©e de stockage statique.</b>  <b>Si l'ach√®vement du constructeur ou l'initialisation dynamique d'un objet avec la dur√©e de stockage des threads est s√©quenc√© avant celui d'un autre, l'ach√®vement du destructeur du second est s√©quenc√© avant l'initiation du destructeur du premier.</b>  <b>Si l'ach√®vement du constructeur ou l'initialisation dynamique d'un objet avec une dur√©e de stockage statique est s√©quenc√© avant celui d'un autre, l'ach√®vement du destructeur du second est s√©quenc√© avant l'initiation du destructeur du premier.</b>  [Remarque: Cette d√©finition permet la destruction simultan√©e.  ‚ÄìFin note] Si un objet est initialis√© statiquement, l'objet est d√©truit dans le m√™me ordre que si l'objet √©tait initialis√© dynamiquement.  Pour un objet de type tableau ou classe, tous les sous-objets de cet objet sont d√©truits avant la destruction de tout objet de port√©e de bloc avec une dur√©e de stockage statique initialis√©e lors de la construction des sous-objets.  Si la destruction d'un objet avec une dur√©e de stockage statique ou de thread se termine via une exception, std :: terminate est appel√©e (15.5.1). <br><br>  2. <b>Si une fonction contient un objet de port√©e de bloc de dur√©e de stockage statique ou de thread qui a √©t√© d√©truit et que la fonction est appel√©e pendant la destruction d'un objet avec une dur√©e de stockage statique ou de thread, le programme a un comportement ind√©fini si le flux de contr√¥le passe √† travers la d√©finition de l'objet blockscope pr√©c√©demment d√©truit.</b>  De m√™me, le comportement n'est pas d√©fini si l'objet de port√©e de bloc est utilis√© indirectement (c'est-√†-dire via un pointeur) apr√®s sa destruction. <br><br>  <b>3. Si l'ach√®vement de l'initialisation d'un objet avec une dur√©e de stockage statique est s√©quenc√© avant un appel √† std :: atexit (voir ¬´cstdlib¬ª, 18.5), l'appel √† la fonction pass√©e √† std :: atexit est s√©quenc√© avant l'appel au destructeur de l'objet.</b>  <b>Si un appel √† std :: atexit est s√©quenc√© avant la fin de l'initialisation d'un objet avec une dur√©e de stockage statique, l'appel au destructeur de l'objet est s√©quenc√© avant l'appel √† la fonction pass√© √† std :: atexit.</b>  <b>Si un appel √† std :: atexit est s√©quenc√© avant un autre appel √† std :: atexit, l'appel √† la fonction pass√© au deuxi√®me appel std :: atexit est s√©quenc√© avant l'appel √† la fonction pass√© au premier appel std :: atexit .</b> <br><br>  4. S'il y a une utilisation d'un objet ou d'une fonction de biblioth√®que standard non autoris√©e dans les gestionnaires de signaux (18.10) qui ne se produit pas avant (1.10) la fin de la destruction des objets avec une dur√©e de stockage statique et l'ex√©cution des fonctions enregistr√©es std :: atexit (18.5 ), le programme a un comportement ind√©fini.  [Remarque: S'il y a une utilisation d'un objet avec une dur√©e de stockage statique qui ne se produit pas avant la destruction de l'objet, le programme a un comportement ind√©fini.  Terminer chaque thread avant un appel √† std :: exit ou la sortie de main est suffisant, mais pas n√©cessaire, pour satisfaire ces exigences.  Ces exigences autorisent les gestionnaires de threads en tant qu'objets de dur√©e de stockage statique.  ‚ÄîFin note] <br><br>  5. L'appel de la fonction std :: abort () d√©clar√©e dans "cstdlib" termine le programme sans ex√©cuter aucun destructeur et sans appeler les fonctions pass√©es √† std :: atexit () ou std :: at_quick_exit (). </blockquote>  Interpr√©tation: <br><br><ul><li>  la destruction d'objets dont la dur√©e de stockage des threads est effectu√©e dans l'ordre inverse de leur cr√©ation; </li><li>  strictement apr√®s cela, les objets avec une dur√©e de stockage statique sont d√©truits et des appels sont effectu√©s vers des fonctions enregistr√©es avec std :: atexit dans l'ordre inverse de la cr√©ation de ces objets et de l'enregistrement de ces fonctions; </li><li>  Une tentative d'acc√®s √† un objet d√©truit avec une dur√©e de stockage de thread ou une dur√©e de stockage statique contient un comportement non d√©fini.  La r√©initialisation de ces objets n'est pas fournie. </li></ul><br>  Remarque: les variables globales dans la norme sont appel√©es "variable non locale avec une dur√©e de stockage statique".  En cons√©quence, il s'av√®re que toutes les variables globales, tous les singletones (statiques locales) et tous les appels √† std :: atexit tombent dans une seule file d'attente LIFO lorsqu'ils sont cr√©√©s / enregistr√©s. <br><br>  Les informations utiles pour l'article sont √©galement contenues dans la section <b>3.6.2 Initialisation des variables non locales [basic.start.init]</b> .  J'apporte seulement les plus importants: <br><blockquote>  L'initialisation dynamique d'une variable non locale avec une dur√©e de stockage statique est ordonn√©e ou non ordonn√©e.  [...] Les variables √† initialisation ordonn√©e d√©finies au sein d'une m√™me unit√© de traduction doivent √™tre initialis√©es dans l'ordre de leurs d√©finitions dans l'unit√© de traduction. </blockquote>  Interpr√©tation (en tenant compte du texte int√©gral de la section): les variables globales au sein d'une unit√© de traduction sont initialis√©es dans l'ordre de d√©claration. <br><br><h3>  Ce qui sera dans le code </h3><br>  Tous les exemples de code fournis dans l'article sont publi√©s sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br><br>  Le code se compose de trois couches, comme s'il √©tait √©crit par des personnes diff√©rentes: <br><br><ul><li>  singleton; </li><li>  utilitaire (classe utilisant singleton); </li><li>  utilisateur (variables globales et principales). </li></ul><br>  Singleton et l'utilitaire sont comme une biblioth√®que tierce et l'utilisateur est l'utilisateur. <br>  La couche utilitaire est con√ßue pour isoler la couche utilisateur de la couche singleton.  Dans les exemples, l'utilisateur a la possibilit√© d'acc√©der au singleton, mais nous agirons comme si c'√©tait impossible. <br><br>  L'utilisateur fait d'abord tout correctement, puis d'un coup de poignet, tout se casse.  Nous essayons d'abord de le corriger dans la couche utilitaire, et si cela ne fonctionne pas, puis dans la couche singleton. <br><br>  Dans le code, nous marcherons constamment le long du bord - maintenant du c√¥t√© clair, puis du noir.  Pour faciliter le passage du c√¥t√© obscur, le cas le plus difficile a √©t√© choisi: acc√©der √† un singleton √† partir du destructeur d'utilitaires. <br><br>  <b>Pourquoi le cas de l'appel du destructeur est-il le plus difficile?</b>  Parce que le destructeur d'utilitaires peut √™tre appel√© dans le processus de minimisation de l'application, lorsque la question ¬´le singleton a-t-il √©t√© d√©truit ou pas encore¬ª devient pertinente. <br><br>  <b>L'affaire est une sorte de synth√©tique.</b>  <b>En pratique, les appels √† un singleton depuis le destructeur ne sont pas n√©cessaires.</b>  M√™me au besoin.  Par exemple, pour consigner la destruction d'objets. <br><br>  Trois classes de singleton sont utilis√©es: <br><br><ul><li>  SingletonClassic - pas de pointeurs intelligents.  En fait, ce n'est pas directement tout √† fait classique, mais certainement le plus classique parmi les trois consid√©r√©s; </li><li>  SingletonShared - avec std :: shared_ptr; </li><li>  SingletonWeak - avec std :: faible_ptr. </li></ul><br>  Tous les singletones sont des mod√®les.  Le param√®tre de mod√®le est utilis√© pour en h√©riter.  Dans la plupart des exemples, ils sont param√©tr√©s par la classe Payload, qui fournit une fonction publique pour ajouter des donn√©es √† std :: set. <br><br>  Dans la plupart des exemples, le destructeur d'utilitaires essaie de remplir une centaine de valeurs.  La sortie de diagnostic vers la console est √©galement utilis√©e √† partir du constructeur singleton, du destructeur singleton et de instance (). <br><br>  <b>Pourquoi si dur?</b>  Pour qu'il soit plus facile de comprendre que nous sommes du c√¥t√© obscur.  L'appel au singleton d√©truit est un comportement ind√©fini, mais il ne peut se manifester d'aucune fa√ßon en externe.  Le bourrage de valeurs dans le std :: set d√©truit ne garantit pas non plus les manifestations externes, mais il n'y a pas de moyen plus fiable (en fait, dans GCC sous Linux dans des exemples incorrects avec le singleton classique, le std :: set d√©truit est correctement bourr√©, et dans MSVS sous Windows - se bloque).  Avec un comportement non d√©fini, la sortie vers la console peut <b>ne pas</b> se produire.  Ainsi, dans les exemples corrects, nous nous attendons √† l'absence d'acc√®s √† l'instance () apr√®s le destructeur, ainsi qu'√† l'absence d'un crash et de l'absence d'un blocage, et dans les mauvais, soit la pr√©sence d'un tel appel, ou d'un crash, ou d'un blocage, ou tout d'un coup dans n'importe quelle combinaison, ou quoi que ce soit. <br><br><h3>  Singleton classique </h3><br><div class="spoiler">  <b class="spoiler_title">Payload.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;set&gt; class Payload { public: Payload() = default; ~Payload() = default; Payload(const Payload &amp;) = delete; Payload(Payload &amp;&amp;) = delete; Payload&amp; operator=(const Payload &amp;) = delete; Payload&amp; operator=(Payload &amp;&amp;) = delete; void add(int value) { m_data.emplace(value); } private: std::set&lt;int&gt; m_data; };</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">SingletonClassic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; template&lt;typename T&gt; class SingletonClassic : public T { public: ~SingletonClassic() { std::cout &lt;&lt; "~SingletonClassic()" &lt;&lt; std::endl; } SingletonClassic(const SingletonClassic &amp;) = delete; SingletonClassic(SingletonClassic &amp;&amp;) = delete; SingletonClassic&amp; operator=(const SingletonClassic &amp;) = delete; SingletonClassic&amp; operator=(SingletonClassic &amp;&amp;) = delete; static SingletonClassic&amp; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; static SingletonClassic inst; return inst; } private: SingletonClassic() { std::cout &lt;&lt; "SingletonClassic()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br><h3>  Exemple 1 de SingletonClassic </h3><br><div class="spoiler">  <b class="spoiler_title">Classic_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br>  L'utilitaire appelle le singleton dans le constructeur pour s'assurer que le singleton est cr√©√© avant la cr√©ation de l'utilitaire. <br><br>  L'utilisateur cr√©e deux std :: unique_ptr: un vide, le second contenant l'utilitaire. <br><br>  L'ordre de cr√©ation: <br><br>  - vide std :: unique_ptr. <br>  - singleton; <br>  - utilit√©. <br><br>  Et en cons√©quence, l'ordre de destruction: <br><br>  - utilit√©; <br>  - singleton; <br>  - vide std :: unique_ptr. <br><br>  L'appel du destructeur d'utilitaires au singleton est correct. <br><br><h3>  Exemple 2 de SingletonClassic </h3><br>  Tout est pareil, mais l'utilisateur l'a pris et a tout g√¢ch√© avec une seule ligne. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  ~ SingletonClassic () <br>  instance () <br></div></div><br>  L'ordre de cr√©ation et de destruction est pr√©serv√©.  Il semblerait que tout soit encore.  Mais non.  En appelant emptyUnique.swap (utilityUnique), l'utilisateur a commis un comportement non d√©fini. <br><br>  <b>Pourquoi l'utilisateur a-t-il fait des choses aussi stupides?</b>  Parce qu'il ne sait rien de la structure interne de la biblioth√®que, qui lui a fourni un singleton et une utilit√©. <br><br>  <b>Et si vous connaissez la structure interne de la biblioth√®que?</b>  ... de toute fa√ßon, dans le vrai code, il est tr√®s facile de s‚Äôimpliquer.  Et vous devez sortir par un d√©bagage douloureux, car  comprendre ce qui s'est exactement pass√© ne sera pas facile. <br><br>  <b>Pourquoi ne pas exiger que la biblioth√®que soit utilis√©e correctement?</b>  <b>Eh bien, il y a toutes sortes de quais √† √©crire, des exemples ...</b> Et pourquoi ne pas faire une biblioth√®que pas si facile √† g√¢cher? <br><br><h3>  Exemple 3 de SingletonClassic </h3><br>  Au cours de la pr√©paration de l'article pendant plusieurs jours, j'ai cru qu'il √©tait impossible d'√©liminer le comportement ind√©fini de l'exemple pr√©c√©dent dans la couche utilitaire, et la solution n'√©tait disponible que dans la couche singleton.  Mais au fil du temps, une solution a n√©anmoins √©t√© trouv√©e. <br><br>  Avant d'ouvrir les spoilers avec le code et l'explication, je sugg√®re au lecteur d'essayer de trouver un moyen de sortir de la situation par lui-m√™me (uniquement dans la couche utilitaire!).  Je n'exclus pas qu'il existe de meilleures solutions. <br><br><div class="spoiler">  <b class="spoiler_title">Classic_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonClassic.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; class ClassicSingleThreadedUtility { public: ClassicSingleThreadedUtility() { thread_local auto flag_strong = std::make_shared&lt;char&gt;(0); m_flag_weak = flag_strong; SingletonClassic&lt;Payload&gt;::instance(); } ~ClassicSingleThreadedUtility() { if ( !m_flag_weak.expired() ) { auto &amp;instance = SingletonClassic&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance.add(i); } } private: std::weak_ptr&lt;char&gt; m_flag_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified ClassicSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;ClassicSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;ClassicSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); { // To demonstrate normal processing before application ends auto utility = ClassicSingleThreadedUtility(); } // Guaranteed destruction order is still the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect ... // ... but utility uses a variable with thread storage duration to detect thread termination. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonClassic () <br>  instance () <br>  instance () <br>  ~ SingletonClassic () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Explication</b> <div class="spoiler_text">  Le probl√®me se produit uniquement lors de la r√©duction de l'application.  Un comportement ind√©fini peut √™tre √©limin√© en apprenant √† l'utilitaire √† reconna√Ætre lorsque l'application est minimis√©e.  Pour ce faire, nous avons utilis√© une variable flag_strong du type std :: shared_ptr, qui a un qualificatif de dur√©e de stockage des threads (voir des extraits de la norme dans l'article ci-dessus) - c'est comme une statique, mais elle n'est d√©truite que lorsque le thread actuel se termine <b>avant que toute statique ne soit d√©truite</b> , y compris avant la destruction singleton.  La variable flag_strong est une pour l'ensemble du flux, et chaque instance de l'utilitaire stocke sa copie faible. <br><br>  Dans un sens √©troit, la solution peut √™tre appel√©e un hack, car  elle est indirecte et non √©vidente.  De plus, il avertit trop t√¥t et parfois (dans une application multithread) avertit g√©n√©ralement faux.  Mais au sens large, ce n'est pas un hack, mais une solution compl√®tement d√©finie par les propri√©t√©s standard - √† la fois des inconv√©nients et des avantages. <br></div></div><br><h3>  Singletonshared </h3><br>  Passons √† un singleton modifi√© bas√© sur std :: shared_ptr. <br><br><div class="spoiler">  <b class="spoiler_title">SingletonShared.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonShared : public T { public: ~SingletonShared() { std::cout &lt;&lt; "~SingletonShared()" &lt;&lt; std::endl; } SingletonShared(const SingletonShared &amp;) = delete; SingletonShared(SingletonShared &amp;&amp;) = delete; SingletonShared&amp; operator=(const SingletonShared &amp;) = delete; SingletonShared&amp; operator=(SingletonShared &amp;&amp;) = delete; static std::shared_ptr&lt;SingletonShared&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonShared&gt;(new SingletonShared); return inst; } private: SingletonShared() { std::cout &lt;&lt; "SingletonShared()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  <b>Ai-ai-ai, le nouvel op√©rateur ne doit pas √™tre utilis√© dans le code moderne, √† la place std :: make_shared est n√©cessaire!</b>  Et cela est emp√™ch√© par le constructeur priv√© du singleton. <br><br>  <b>Ha!</b>  <b>J'ai aussi un probl√®me!</b>  <b>D√©clarez std :: make_shared un ami singleton!</b>  ... et obtenez une variante de l'anti-mod√®le PublicMorozov: en utilisant le m√™me std :: make_shared, il sera possible de cr√©er des instances suppl√©mentaires du singleton non fournies par l'architecture. <br><br><h3>  Exemples 1 et 2 de SingletonShared </h3><br>  Correspond enti√®rement aux exemples n ¬∞ 1 et 2 pour la version classique.  Des modifications importantes n'ont √©t√© apport√©es qu'√† la couche singleton, l'utilit√© est rest√©e essentiellement la m√™me.  Tout comme dans les exemples avec le singleton classique, l'exemple-1 est correct et l'exemple-2 montre un comportement ind√©fini. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Payload.h&gt; #include &lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { if ( auto instance = SingletonShared&lt;Payload&gt;::instance() ) for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  instance () <br>  ~ SingletonShared () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example2_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() { // To ensure that singleton will be constucted before utility SingletonShared&lt;Payload&gt;::instance(); } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( auto instance = SingletonShared::instance() ) // for ( int i = 0; i &lt; 100; ++i ) // instance-&gt;add(i); // ... so this code will demonstrate UB in colour auto instance = SingletonShared&lt;Payload&gt;::instance(); for ( int i = 0; i &lt; 100; ++i ) instance-&gt;add(i); } }; // 1. Create an empty unique_ptr // 2. Create singleton (because of modified SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order seems to be correct ... int main() { // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><h3>  Exemple 3 de SingletonShared </h3><br>  Et maintenant, nous allons essayer de r√©soudre ce probl√®me mieux que dans l'exemple num√©ro 3 des classiques. <br>  La solution est √©vidente: il vous suffit de prolonger la dur√©e de vie du singleton en stockant une copie de std :: shared_ptr retourn√©e par le singleton dans l'utilitaire.  Et cette solution, compl√®te avec SingletonShared, a √©t√© largement r√©pliqu√©e dans des sources ouvertes. <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example3_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of SharedSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;SharedSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;SharedSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br></div></div><br>  Et maintenant, attention, la question est: <b>vouliez-vous vraiment prolonger la vie d'un singleton?</b> <br>  Ou vouliez-vous vous d√©barrasser d'un comportement ind√©fini et choisir la prolongation de la vie comme un chemin √† la surface? <br><br>  L'inexactitude th√©orique sous la forme d'une substitution d'objectifs conduit √† un risque de blocage (ou de r√©f√©rence cyclique - appelez-le comme vous voulez). <br><br>  <b>Oui nuuuuuu, c'est comme √ßa qu'il faut essayer si fort!?</b>  <b>Vous devrez trouver si longtemps, et vous ne le ferez certainement pas par accident!</b> <br><br><div class="spoiler">  <b class="spoiler_title">CallbackPayload.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; class CallbackPayload { public: CallbackPayload() = default; ~CallbackPayload() = default; CallbackPayload(const CallbackPayload &amp;) = delete; CallbackPayload(CallbackPayload &amp;&amp;) = delete; CallbackPayload&amp; operator=(const CallbackPayload &amp;) = delete; CallbackPayload&amp; operator=(CallbackPayload &amp;&amp;) = delete; void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { m_callbackFn = std::move(fn); } private: std::function&lt;void()&gt; m_callbackFn; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SomethingWithVeryImportantDestructor.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; class SomethingWithVeryImportantDestructor { public: SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } ~SomethingWithVeryImportantDestructor() { std::cout &lt;&lt; "~SomethingWithVeryImportantDestructor()" &lt;&lt; std::endl; } SomethingWithVeryImportantDestructor(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(const SomethingWithVeryImportantDestructor &amp;) = delete; SomethingWithVeryImportantDestructor&amp; operator=(SomethingWithVeryImportantDestructor &amp;&amp;) = delete; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shared_Example4_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "SharedSingleThreadedUtility()" &lt;&lt; std::endl; } ~SharedSingleThreadedUtility() { std::cout &lt;&lt; "~SharedSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( m_singleton ) m_singleton-&gt;setCallback(std::move(fn)); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;CallbackPayload&gt;&gt; m_singleton; }; int main() { auto utility = std::make_shared&lt;SharedSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  SharedSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br></div></div><br>  Un singleton a √©t√© cr√©√©. <br><br>  Un utilitaire a √©t√© cr√©√©. <br><br>  <b>Quelque chose de S-Very-Important-Destructor a √©t√© cr√©√©</b> (j'ai ajout√© cela pour l'intimidation, car sur Internet il y a des messages comme "eh bien, le destructeur singleton ne sera pas appel√©, alors quoi de cela, il doit exister tout le temps programmes "). <br><br>  Mais aucun destructeur n'a √©t√© appel√© pour aucun de ces objets! <br><br>  √Ä cause de quoi?  En raison de la substitution des buts par des moyens. <br><br><h3>  Singletonweak </h3><br><div class="spoiler">  <b class="spoiler_title">SingletonWeak.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;iostream&gt; template&lt;typename T&gt; class SingletonWeak : public T { public: ~SingletonWeak() { std::cout &lt;&lt; "~SingletonWeak()" &lt;&lt; std::endl; } SingletonWeak(const SingletonWeak &amp;) = delete; SingletonWeak(SingletonWeak &amp;&amp;) = delete; SingletonWeak&amp; operator=(const SingletonWeak &amp;) = delete; SingletonWeak&amp; operator=(SingletonWeak &amp;&amp;) = delete; static std::weak_ptr&lt;SingletonWeak&gt; instance() { std::cout &lt;&lt; "instance()" &lt;&lt; std::endl; // "new" and no std::make_shared because of private c-tor static auto inst = std::shared_ptr&lt;SingletonWeak&gt;(new SingletonWeak); return inst; } private: SingletonWeak() { std::cout &lt;&lt; "SingletonWeak()" &lt;&lt; std::endl; } };</span></span></span></span></code> </pre><br></div></div><br>  Une telle modification du singleton dans les sources ouvertes, si elle est donn√©e, n'est certainement pas souvent.  Je suis tomb√© sur d'√©tranges options tourn√©es √† l'envers avec un std :: faible_ptr, qui semble √™tre utilis√©, qui, semble-t-il, n'offre rien de plus que de prolonger la vie d'un singleton: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Singletons utilisant std :: faible_ptr</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Est-ce la bonne fa√ßon de cr√©er la classe sinlgeton par faiblesse_ptr</a> </li></ul><br>  L'option que je propose, lorsqu'elle est appliqu√©e correctement dans les couches singleton et utilitaires: <br><br><ul><li>  prot√®ge contre les actions dans la couche utilisateur d√©crite dans les exemples ci-dessus, y compris emp√™che l'impasse; </li><li>  d√©termine le moment du pliage de l'application plus pr√©cis√©ment que l'application thread_local dans Classic_Example3_correct, c'est-√†-dire  vous permet de vous rapprocher du bord; </li><li>  Je ne souffre pas du probl√®me th√©orique de substitution d'objectifs par des moyens (je ne sais pas si quelque chose de tangible autre que l'impasse peut appara√Ætre de ce probl√®me th√©orique). </li></ul><br>  Cependant, il y a un inconv√©nient: prolonger la dur√©e de vie d'un singleton peut <b>encore lui</b> permettre <b>de</b> se <b>rapprocher encore plus</b> du bord. <br><br><h3>  Exemple 1 de SingletonWeak </h3><br>  Similaire √† Shared_Example3_correct.cpp. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example1_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; // 1. Create an empty unique_ptr // 2. Create singleton (because of WeakSingleThreadedUtility c-tor) // 3. Create utility std::unique_ptr&lt;WeakSingleThreadedUtility&gt; emptyUnique; auto utilityUnique = std::make_unique&lt;WeakSingleThreadedUtility&gt;(); int main() { // This guarantee destruction in order: // - utilityUnique; // - singleton; // - emptyUnique. // This order is correct ... // ... but user swaps unique_ptrs emptyUnique.swap(utilityUnique); // Guaranteed destruction order is the same: // - utilityUnique; // - singleton; // - emptyUnique, // but now utilityUnique is empty, and emptyUnique is filled, // so destruction order is incorrect... // ... but utility have made a weak copy of shared_ptr when it was available, // so it's correct again. return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br></div></div><br>  <b>Pourquoi avons-nous besoin de SingletonWeak, car personne ne d√©range l'utilitaire pour utiliser SingletonShared comme SingletonWeak?</b>  Oui, personne ne d√©range.  Et m√™me personne ne d√©range l'utilitaire pour utiliser SingletonWeak comme SingletonShared.  Mais les utiliser √† leur destination est l√©g√®rement plus facile que de les utiliser √† d'autres fins. <br><br><h3>  Exemple 2 de SingletonWeak </h3><br>  Similaire √† Shared_Example4_incorrect, mais seul un blocage ne se produit pas dans ce cas. <br><br><div class="spoiler">  <b class="spoiler_title">Weak_Example2_correct.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CallbackPayload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SomethingWithVeryImportantDestructor.h"</span></span></span><span class="hljs-meta"> class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;CallbackPayload&gt;::instance()) { std::cout &lt;&lt; "WeakSingleThreadedUtility()" &lt;&lt; std::endl; } ~WeakSingleThreadedUtility() { std::cout &lt;&lt; "~WeakSingleThreadedUtility()" &lt;&lt; std::endl; } void setCallback(std::function&lt;void()&gt; &amp;&amp;fn) { if ( auto strong = m_weak.lock() ) strong-&gt;setCallback(std::move(fn)); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;CallbackPayload&gt;&gt; m_weak; }; int main() { auto utility = std::make_shared&lt;WeakSingleThreadedUtility&gt;(); auto something = std::make_shared&lt;SomethingWithVeryImportantDestructor&gt;(); // lambda with "utility" and "something" captured utility-&gt;setCallback( [utility, something](){} ); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  WeakSingleThreadedUtility () <br>  SomethingWithVeryImportantDestructor () <br>  ~ SingletonWeak () <br>  ~ SomethingWithVeryImportantDestructor () <br>  ~ WeakSingleThreadedUtility () <br></div></div><br><h3>  Au lieu d'une conclusion </h3><br>  <b>Et quoi, une telle modification d'un singleton √©liminera un comportement ind√©fini?</b>  J'ai promis qu'il n'y aurait pas de fin heureuse.  Les exemples suivants montrent que des actions de sabotage habiles dans la couche utilisateur peuvent d√©truire m√™me la biblioth√®que r√©fl√©chie correcte avec un singleton (mais nous devons admettre que <b>cela</b> ne peut gu√®re √™tre fait par accident). <br><br><div class="spoiler">  <b class="spoiler_title">Shared_Example5_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonShared.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class SharedSingleThreadedUtility { public: SharedSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_singleton(SingletonShared&lt;Payload&gt;::instance()) { } ~SharedSingleThreadedUtility() { // Sometimes this check may result as "false" even for destroyed singleton // preventing from visual effects of undefined behaviour ... //if ( m_singleton ) // for ( int i = 0; i &lt; 100; ++i ) // m_singleton-&gt;add(i); // ... so this code will allow to demonstrate UB in colour for ( int i = 0; i &lt; 100; ++i ) m_singleton-&gt;add(i); } private: // A copy of smart pointer, not a reference std::shared_ptr&lt;SingletonShared&lt;Payload&gt;&gt; m_singleton; }; void cracker() { SharedSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = SharedSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonShared () <br>  ~ SingletonShared () <br>  instance () <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Weak_Example3_incorrect.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SingletonWeak.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Payload.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;cstdlib&gt; class WeakSingleThreadedUtility { public: WeakSingleThreadedUtility() // To ensure that singleton will be constucted before utility : m_weak(SingletonWeak&lt;Payload&gt;::instance()) { } ~WeakSingleThreadedUtility() { // Sometimes this check may result as "false" even in case of incorrect usage, // and there's no way to guarantee a demonstration of undefined behaviour in colour if ( auto strong = m_weak.lock() ) for ( int i = 0; i &lt; 100; ++i ) strong-&gt;add(i); } private: // A weak copy of smart pointer, not a reference std::weak_ptr&lt;SingletonWeak&lt;Payload&gt;&gt; m_weak; }; void cracker() { WeakSingleThreadedUtility(); } // 1. Register cracker() using std::atexit // 2. Create singleton // 3. Create utility auto reg = [](){ std::atexit(&amp;cracker); return 0; }(); auto utility = WeakSingleThreadedUtility(); // This guarantee destruction in order: // - utility; // - singleton. // This order is correct. // Additionally, there's a copy of shared_ptr in the class instance... // ... but there was std::atexit registered before singleton, // so cracker() will be invoked after destruction of utility and singleton. // There's second try to create a singleton - and it's incorrect. int main() { return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text">  instance () <br>  SingletonWeak () <br>  ~ SingletonWeak () <br>  instance () <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr455848/">https://habr.com/ru/post/fr455848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr455834/index.html">Benchmarks pour les serveurs Linux: 5 outils ouverts</a></li>
<li><a href="../fr455840/index.html">Comment travailler avec plusieurs requ√™tes. Composition, r√©ducteur, FP</a></li>
<li><a href="../fr455842/index.html">R√©partissez une liste li√©e individuellement. √âdition Swift</a></li>
<li><a href="../fr455844/index.html">Cr√©ation d'un analyseur Roslyn en utilisant les tests d'encapsulation comme exemple</a></li>
<li><a href="../fr455846/index.html">Informatique distribu√©e dans Julia</a></li>
<li><a href="../fr455850/index.html">Bo√Æte √† outils pour les chercheurs - Troisi√®me √©dition: recherche et utilisation de sources</a></li>
<li><a href="../fr455852/index.html">Lev√©e de sinus et implantation simultan√©e</a></li>
<li><a href="../fr455854/index.html">Comment impl√©menter les menus contextuels dans iOS 13</a></li>
<li><a href="../fr455856/index.html">Capteur de temp√©rature, d'humidit√© et de pression atmosph√©rique sans fil sur nRF52832</a></li>
<li><a href="../fr455858/index.html">R√©seaux de t√©l√©vision par c√¢ble pour les plus petits. Partie 9: Headend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>