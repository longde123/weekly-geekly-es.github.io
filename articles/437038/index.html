<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóø üë´ üôÖüèæ Traducci√≥n de la gu√≠a API de Benjamin Winterberg Stream ü§õüèæ üëµüèø üë®üèø‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr! Le presento la traducci√≥n del art√≠culo " Java 8 Stream Tutorial ". 

 Este tutorial, basado en ejemplos de c√≥digo, proporciona una descripc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Traducci√≥n de la gu√≠a API de Benjamin Winterberg Stream</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437038/">  Hola Habr!  Le presento la traducci√≥n del art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Java 8 Stream Tutorial</a> ". <br><br>  Este tutorial, basado en ejemplos de c√≥digo, proporciona una descripci√≥n general completa de las secuencias en Java 8. Cuando present√© por primera vez la API de Stream, me sorprendi√≥ el nombre porque es muy acorde con InputStream y OutputStream del paquete java.io;  Sin embargo, los hilos en Java 8 son algo completamente diferente. <a name="habracut"></a>  Los hilos son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√≥nadas</a> que juegan un papel importante en el desarrollo de la programaci√≥n funcional en Java. <br><blockquote>  En la programaci√≥n funcional, una m√≥nada es una estructura que representa un c√°lculo en forma de una cadena de pasos sucesivos.  El tipo y la estructura de la m√≥nada determinan la cadena de operaciones, en nuestro caso, una secuencia de m√©todos con funciones integradas de un tipo dado. </blockquote>  Este tutorial le ense√±ar√° c√≥mo trabajar con transmisiones y le mostrar√° c√≥mo manejar los diversos m√©todos disponibles en la API de transmisiones.  Analizaremos el orden de las operaciones y veremos c√≥mo la secuencia de m√©todos en la cadena afecta el rendimiento.  Conozca <code>flatMap</code> potentes m√©todos de Stream API, como <code>reduce</code> , <code>collect</code> y <code>flatMap</code> .  Al final del manual, prestaremos atenci√≥n al trabajo paralelo con flujos. <br><br>  Si no se siente libre de trabajar con expresiones lambda, interfaces funcionales y m√©todos de referencia, ser√° √∫til que se familiarice con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mi gu√≠a de innovaciones en Java 8</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> en Habr√©), y luego vuelva a estudiar los flujos. <br><br><h3>  C√≥mo funcionan los hilos </h3><br>  Una secuencia representa una secuencia de elementos y proporciona varios m√©todos para realizar c√°lculos en estos elementos: <br><br><pre> <code class="java hljs">List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>); myList .stream() .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"c"</span></span>)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// C1 // C2</span></span></code> </pre> <br>  Los m√©todos de flujo son <i>intermedios</i> (intermedios) y <i>terminales</i> (terminales).  Los m√©todos intermedios devuelven una secuencia, lo que permite que muchos de estos m√©todos se llamen secuencialmente.  Los m√©todos de terminal no devuelven un valor (vac√≠o) o devuelven un resultado de un tipo que no sea una secuencia.  En el ejemplo anterior, el <code>filter</code> , el <code>map</code> y los <code>sorted</code> son intermedios y <code>forEach</code> son terminales.  Para obtener una lista completa de los m√©todos de flujo disponibles, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> .  Tal cadena de operaciones de flujo tambi√©n se conoce como una tuber√≠a de operaci√≥n. <br><br>  La mayor√≠a de los m√©todos de Stream API aceptan como par√°metros expresiones lambda, una interfaz funcional que describe el comportamiento espec√≠fico del m√©todo.  La mayor√≠a de ellos deben ser simult√°neamente no interferentes y ap√°tridas.  ¬øQu√© significa esto? <br><br>  Un m√©todo no interfiere si no modifica los datos subyacentes subyacentes a la secuencia.  Por ejemplo, en el ejemplo anterior, ninguna expresi√≥n lambda modifica la matriz de lista myList. <br><br>  Un m√©todo no tiene estado si se especifica el orden en que se realiza la operaci√≥n.  Por ejemplo, ni una sola expresi√≥n lambda del ejemplo depende de variables mutables o estados de espacio externo que podr√≠an cambiar en tiempo de ejecuci√≥n. <br><br><h3>  Diferentes tipos de hilos </h3><br>  Las secuencias se pueden crear a partir de varios datos de origen, principalmente de colecciones.  Las listas y conjuntos admiten los nuevos m√©todos <code>stream()</code> y <code>parllelStream()</code> para crear secuencias secuenciales y paralelas.  Los subprocesos paralelos pueden funcionar en modo de subprocesos m√∫ltiples (en subprocesos m√∫ltiples) y se analizar√°n al final del manual.  Mientras tanto, considere hilos secuenciales: <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .stream() .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Aqu√≠, llamar al m√©todo <code>stream()</code> en una lista devuelve un objeto stream normal. <br>  Sin embargo, para trabajar con una secuencia, no es necesario crear una colecci√≥n: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Simplemente use <code>Stream.of()</code> para crear una secuencia a partir de m√∫ltiples referencias de objeto. <br><br>  Adem√°s de las secuencias de objetos normales, Java 8 tiene tipos especiales de secuencias para trabajar con tipos primitivos: int, long, double.  Como puede suponer, esto es <code>IntStream</code> , <code>LongStream</code> , <code>DoubleStream</code> . <br><br>  Las secuencias IntStream pueden reemplazar los <code>IntStream.range()</code> regulares para (;;) usando <code>IntStream.range()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 1 // 2 // 3</span></span></code> </pre><br>  Todos estos flujos para trabajar con tipos primitivos funcionan igual que los flujos de objetos normales, excepto los siguientes: <br><br><ul><li>  Las secuencias primitivas usan expresiones lambda especiales.  Por ejemplo, IntFunction en lugar de Function, o IntPredicate en lugar de Predicate. </li><li>  Los flujos primitivos admiten m√©todos terminales adicionales: <code>sum()</code> y <code>average()</code> <br><br><pre> <code class="java hljs">Arrays.stream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}) .map(n -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n + <span class="hljs-number"><span class="hljs-number">1</span></span>) .average() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 5.0</span></span></code> </pre><br></li></ul><br>  A veces es √∫til convertir un flujo de objetos en un flujo de primitivas o viceversa.  Para este prop√≥sito, los flujos de objetos admiten m√©todos especiales: <code>mapToInt()</code> , <code>mapToLong()</code> , <code>mapToDouble()</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .map(s -&gt; s.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>  Las secuencias de primitivas se pueden convertir en secuencias de objetos llamando a <code>mapToObj()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br>  En el siguiente ejemplo, una secuencia de n√∫meros de punto flotante se asigna a una secuencia de enteros y luego se asigna a una secuencia de objetos: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>) .mapToInt(Double::intValue) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br><h3>  Orden de ejecuci√≥n </h3><br>  Ahora que hemos aprendido c√≥mo crear varias transmisiones y c√≥mo trabajar con ellas, profundizaremos y consideraremos c√≥mo se ven las operaciones de transmisi√≥n bajo el cap√≥. <br><br>  Una caracter√≠stica importante de los m√©todos intermedios es su <i>pereza</i> .  No hay un m√©todo terminal en este ejemplo: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; });</code> </pre><br>  Cuando se ejecuta este fragmento de c√≥digo, no se enviar√° nada a la consola.  Y todo porque los m√©todos intermedios se ejecutan solo si hay un m√©todo terminal.  <code>forEach</code> el ejemplo agregando el m√©todo de terminal <code>forEach</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  La ejecuci√≥n de este fragmento de c√≥digo conduce a la salida a la consola del siguiente resultado: <br><br><pre> <code class="java hljs">filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c</code> </pre><br>  El orden en que se organizan los resultados puede sorprender.  Uno puede esperar ingenuamente que los m√©todos se ejecutar√°n "horizontalmente": uno tras otro para todos los elementos de la secuencia.  Sin embargo, en cambio, el elemento se mueve a lo largo de la cadena "verticalmente".  Primero, la primera l√≠nea de "d2" pasa por el m√©todo de <code>filter</code> , luego por <code>forEach</code> y solo entonces, despu√©s de pasar el primer elemento por toda la cadena de m√©todos, el siguiente elemento comienza a procesarse. <br><br>  Dado este comportamiento, puede reducir el n√∫mero real de operaciones: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .anyMatch(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"anyMatch: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2</span></span></code> </pre><br>  El m√©todo <code>anyMatch</code> devolver√° <i>verdadero</i> tan pronto como el predicado se aplique al elemento entrante.  En este caso, este es el segundo elemento de la secuencia: "A2".  En consecuencia, debido a la ejecuci√≥n "vertical" de la cadena de subprocesos, el <code>map</code> se llamar√° solo dos veces.  Por lo tanto, en lugar de mostrar todos los elementos de la secuencia, se llamar√° a <code>map</code> lo menos posible. <br><br><h3>  Por qu√© la secuencia importa </h3><br>  El siguiente ejemplo consta de dos m√©todos intermedios de <code>map</code> y <code>filter</code> y un m√©todo terminal para cada <code>forEach</code> .  Considere c√≥mo se realizan estos m√©todos: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C</span></span></code> </pre> <br>  Es f√°cil adivinar que tanto el <code>map</code> como <code>filter</code> m√©todos de <code>filter</code> se llaman 5 veces en tiempo de ejecuci√≥n, una vez para cada elemento de la colecci√≥n de origen, mientras que <code>forEach</code> se llama solo una vez, para el elemento que pas√≥ el filtro. <br><br>  Puede reducir significativamente el n√∫mero de operaciones cambiando el orden de las llamadas a m√©todos colocando el <code>filter</code> en primer lugar: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c</span></span></code> </pre><br>  Ahora el mapa se llama solo una vez.  Con una gran cantidad de elementos de entrada, observaremos un notable aumento en la productividad.  Tenga esto en cuenta al componer cadenas de m√©todos complejos. <br><br>  Ampliamos el ejemplo anterior agregando una operaci√≥n de ordenaci√≥n adicional: el m√©todo ordenado: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  La clasificaci√≥n es un tipo especial de operaci√≥n intermedia.  Esta es la llamada operaci√≥n con estado, porque para ordenar una colecci√≥n, su estado debe tenerse en cuenta durante toda la operaci√≥n. <br><br>  Como resultado de la ejecuci√≥n de este c√≥digo, obtenemos el siguiente resultado en la consola: <br><br><pre> <code class="java hljs">sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2</code> </pre><br>  Primero, se ordena toda la colecci√≥n.  En otras palabras, el m√©todo <code>sorted</code> se ejecuta horizontalmente.  En este caso, <code>sorted</code> se llama 8 veces para varias combinaciones de los elementos en la colecci√≥n entrante. <br><br>  Una vez m√°s, optimizamos la ejecuci√≥n de este c√≥digo cambiando el orden de las llamadas a m√©todos en la cadena: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2</span></span></code> </pre><br>  En este ejemplo, <code>sorted</code> no se llama en absoluto.  <code>filter</code> reduce la colecci√≥n de entrada a un elemento.  En el caso de grandes datos de entrada, el rendimiento se beneficiar√° significativamente. <br><br><h3>  Reutilizar transmisiones </h3><br>  En Java 8, los hilos no se pueden reutilizar.  Despu√©s de llamar a cualquier m√©todo de terminal, el hilo termina: <br><br><pre> <code class="java hljs">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); stream.anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok stream.noneMatch(s -&gt; true); // exception</span></span></code> </pre><br>  Llamar a <code>noneMatch</code> despu√©s de <code>anyMatch</code> en un hilo da como resultado la siguiente excepci√≥n: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="hljs-number"><span class="hljs-number">229</span></span>) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="hljs-number"><span class="hljs-number">459</span></span>) at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="hljs-number"><span class="hljs-number">38</span></span>) at com.winterbe.java8.Streams5.main(Streams5.java:<span class="hljs-number"><span class="hljs-number">28</span></span>)</code> </pre><br>  Para superar esta limitaci√≥n, se debe crear un nuevo hilo para cada m√©todo de terminal. <br><br>  Por ejemplo, puede crear un <i>proveedor</i> para un nuevo constructor de hilos en el que se instalar√°n todos los m√©todos intermedios: <br><br><pre> <code class="java hljs">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); streamSupplier.get().anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok streamSupplier.get().noneMatch(s -&gt; true); // ok</span></span></code> </pre><br>  Cada llamada al m√©todo <code>get</code> crea un nuevo hilo en el que puede llamar de forma segura al m√©todo de terminal deseado. <br><br><h3>  M√©todos avanzados </h3><br>  Los hilos admiten una gran cantidad de m√©todos diferentes.  Ya nos hemos familiarizado con los m√©todos m√°s importantes.  Para familiarizarse con el resto, consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> .  Y ahora sum√©rgete a√∫n m√°s en m√©todos m√°s complejos: <code>collect</code> , <code>flatMap</code> y <code>reduce</code> . <br><br>  La mayor√≠a de los ejemplos de c√≥digo en esta secci√≥n se refieren al siguiente fragmento de c√≥digo para demostrar la operaci√≥n: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; Person(String name, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } } List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>));</code> </pre><br><h4>  Recoger </h4><br>  <code>Collect</code> m√©todo de terminal muy √∫til, que se utiliza para convertir elementos de flujo a un resultado de un tipo diferente, por ejemplo, Lista, Conjunto o Mapa. <br><br>  <code>Collect</code> acepta un <code>Collector</code> que contiene cuatro m√©todos diferentes: un proveedor.  acumulador, combinador, finalizador.  A primera vista, esto parece muy complicado, pero Java 8 admite varios recopiladores integrados a trav√©s de la clase <code>Collectors</code> , donde se implementan los m√©todos m√°s utilizados. <br><br>  Caso popular: <br><br><pre> <code class="java hljs">List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(<span class="hljs-string"><span class="hljs-string">"P"</span></span>)) .collect(Collectors.toList()); System.out.println(filtered); <span class="hljs-comment"><span class="hljs-comment">// [Peter, Pamela]</span></span></code> </pre> <br>  Como puede ver, crear una lista a partir de elementos de transmisi√≥n es muy simple.  ¬øNo necesitas una lista sino mucho?  Use <code>Collectors.toSet()</code> . <br><br>  En el siguiente ejemplo, las personas se agrupan por edad: <br><br><pre> <code class="java hljs">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age)); personsByAge .forEach((age, p) -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"age %s: %s\n"</span></span>, age, p)); <span class="hljs-comment"><span class="hljs-comment">// age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David]</span></span></code> </pre><br>  Los coleccionistas son incre√≠blemente diversos.  Tambi√©n puede agregar elementos de la colecci√≥n, por ejemplo, determinar la edad promedio: <br><br><pre> <code class="java hljs">Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -&gt; p.age)); System.out.println(averageAge); <span class="hljs-comment"><span class="hljs-comment">// 19.0</span></span></code> </pre><br>  Para obtener estad√≠sticas m√°s completas, utilizamos un recopilador de resumen que devuelve un objeto especial con informaci√≥n: valores m√≠nimos, m√°ximos y promedio, la suma de los valores y el n√∫mero de elementos: <br><br><pre> <code class="java hljs">IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age)); System.out.println(ageSummary); <span class="hljs-comment"><span class="hljs-comment">// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}</span></span></code> </pre><br>  El siguiente ejemplo combina todos los nombres en una l√≠nea: <br><br><pre> <code class="java hljs">String phrase = persons .stream() .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(p -&gt; p.name) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">" and "</span></span>, <span class="hljs-string"><span class="hljs-string">"In Germany "</span></span>, <span class="hljs-string"><span class="hljs-string">" are of legal age."</span></span>)); System.out.println(phrase); <span class="hljs-comment"><span class="hljs-comment">// In Germany Max and Peter and Pamela are of legal age.</span></span></code> </pre><br>  El recopilador de conexi√≥n acepta un separador, as√≠ como un prefijo y sufijo opcionales. <br><br>  Para convertir los elementos de una secuencia en una pantalla, debe determinar c√≥mo se deben mostrar las claves y los valores.  Recuerde que las claves en el mapeo deben ser √∫nicas.  De lo contrario, obtenemos una <code>IllegalStateException</code> .  Opcionalmente, puede agregar una funci√≥n de fusi√≥n para evitar la excepci√≥n: <br><br><pre> <code class="java hljs">Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> + name2)); System.out.println(map); <span class="hljs-comment"><span class="hljs-comment">// {18=Max, 23=Peter;Pamela, 12=David}</span></span></code> </pre><br>  Entonces, nos familiarizamos con algunos de los colectores integrados m√°s potentes.  Tratemos de construir el suyo propio.  Queremos convertir todos los elementos de la secuencia en una sola l√≠nea, que consiste en nombres en may√∫sculas separados por una barra vertical |.  Para hacer esto, cree un nuevo recopilador utilizando <code>Collector.of()</code> .  Necesitamos los cuatro componentes de nuestro colector: proveedor, bater√≠a, conector, finalizador. <br><br><pre> <code class="java hljs">Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJoiner(<span class="hljs-string"><span class="hljs-string">" | "</span></span>), <span class="hljs-comment"><span class="hljs-comment">// supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisher String names = persons .stream() .collect(personNameCollector); System.out.println(names); // MAX | PETER | PAMELA | DAVID</span></span></code> </pre> <br>  Como las cadenas en Java son inmutables, necesitamos una clase auxiliar como <code>StringJoiner</code> que permita al recopilador construir una cadena para nosotros.  En el primer paso, el proveedor construye un <code>StringJoiner</code> con un delimitador asignado.  La bater√≠a se usa para agregar cada nombre a <code>StringJoiner</code> . <br><br>  El conector sabe c√≥mo conectar dos <code>StringJoiner</code> en uno.  Y al final, el finalizador construye la cadena deseada a partir de <code>StringJoiner</code> s. <br><br><h4>  Mapa plano </h4><br>  Entonces, aprendimos c√≥mo convertir objetos de flujo en otros tipos de objetos usando el m√©todo de <code>map</code> .  <code>Map</code> es un tipo de m√©todo limitado, ya que cada objeto se puede asignar a otro solo.  Pero, ¬øqu√© sucede si desea asignar un objeto a muchos otros, o no mostrarlo en absoluto?  Aqu√≠ es donde ayuda el m√©todo <code>flatMap</code> .  <code>FlatMap</code> convierte cada objeto de flujo en un flujo de otros objetos.  El contenido de estos subprocesos se empaqueta en la secuencia devuelta del m√©todo <code>flatMap</code> . <br><br>  Para ver <code>flatMap</code> en acci√≥n, construyamos una jerarqu√≠a de tipos adecuada para un ejemplo: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ String name; List&lt;Bar&gt; bars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Foo(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ String name; Bar(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre><br>  Vamos a crear algunos objetos: <br><br><pre> <code class="java hljs">List&lt;Foo&gt; foos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// create foos IntStream .range(1, 4) .forEach(i -&gt; foos.add(new Foo("Foo" + i))); // create bars foos.forEach(f -&gt; IntStream .range(1, 4) .forEach(i -&gt; f.bars.add(new Bar("Bar" + i + " &lt;- " + f.name))));</span></span></code> </pre><br>  Ahora tenemos una lista de tres <i>foo</i> , cada uno de los cuales contiene tres <i>barras</i> . <br><br>  <code>FlatMap</code> acepta una funci√≥n que deber√≠a devolver una secuencia de objetos.  Por lo tanto, para acceder a los objetos de <i>barra</i> de cada <i>foo</i> , solo necesitamos encontrar la funci√≥n adecuada: <br><br><pre> <code class="java hljs">foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); <span class="hljs-comment"><span class="hljs-comment">// Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3</span></span></code> </pre><br>  Por lo tanto, hemos convertido con √©xito una secuencia de tres objetos <i>foo</i> en una secuencia de 9 objetos de <i>barra</i> . <br><br>  Finalmente, todo el c√≥digo anterior se puede reducir a una simple tuber√≠a de operaciones: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span> + i)) .peek(f -&gt; IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span> + i + <span class="hljs-string"><span class="hljs-string">" &lt;- "</span></span> f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name));</code> </pre><br>  <code>FlatMap</code> tambi√©n <code>FlatMap</code> disponible en la clase <code>Optional</code> introducida en Java 8. <code>FlatMap</code> de la clase <code>Optional</code> devuelve un objeto opcional de otra clase.  Esto se puede usar para evitar un mont√≥n de comprobaciones <code>null</code> . <br><br>  Imagine una estructura jer√°rquica como esta: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Nested nested; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ Inner inner; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ String foo; }</code> </pre><br>  Para obtener la cadena anidada de un objeto externo, debe agregar varias comprobaciones <code>null</code> para evitar una <code>NullPointException</code> : <br><br><pre> <code class="java hljs">Outer outer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested.inner != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(outer.nested.inner.foo); }</code> </pre><br>  Lo mismo se puede lograr usando el flatMap de la clase Opcional: <br><br><pre> <code class="java hljs">Optional.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println);</code> </pre><br>  Cada llamada a <code>flatMap</code> devuelve un contenedor <code>Optional</code> para el objeto deseado, si est√° presente, o para <code>null</code> si falta el objeto. <br><br><h4>  Reducir </h4><br>  La operaci√≥n de simplificaci√≥n combina todos los elementos de una secuencia en un solo resultado.  Java 8 admite tres tipos diferentes de m√©todos de reducci√≥n. <br><br>  El primero reduce el flujo de elementos a un solo elemento de flujo.  Utilizamos este m√©todo para determinar el elemento con mayor edad: <br><br><pre> <code class="java hljs">persons .stream() .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2) .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// Pamela</span></span></code> </pre> <br>  El m√©todo <code>reduce</code> toma una funci√≥n acumulativa con un <i>operador binario</i> (BinaryOperator).  Aqu√≠ <code>reduce</code> es una <i>bi-funci√≥n</i> (BiFunction), donde ambos argumentos pertenecen al mismo tipo.  En nuestro caso, al tipo <i>Persona</i> .  Una bi-funci√≥n es casi lo mismo que una <code></code> , pero requiere 2 argumentos.  En nuestro ejemplo, la funci√≥n compara la edad de dos personas y devuelve un elemento con una edad mayor. <br><br>  La siguiente forma del m√©todo de <code>reduce</code> toma tanto un valor inicial como una bater√≠a con un operador binario.  Este m√©todo se puede usar para crear un nuevo elemento.  Tenemos - <i>Persona</i> con nombre y edad, que consiste en agregar todos los nombres y la suma de a√±os vividos: <br><br><pre> <code class="java hljs">Person result = persons .stream() .reduce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (p1, p2) -&gt; { p1.age += p2.age; p1.name += p2.name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }); System.out.format(<span class="hljs-string"><span class="hljs-string">"name=%s; age=%s"</span></span>, result.name, result.age); <span class="hljs-comment"><span class="hljs-comment">// name=MaxPeterPamelaDavid; age=76</span></span></code> </pre><br>  El tercer m√©todo de <code>reduce</code> toma tres par√°metros: el valor inicial, el acumulador con una funci√≥n bi y una funci√≥n de combinaci√≥n como un operador binario.  Como el valor inicial del tipo no se limita al tipo Persona, puede usar la reducci√≥n para determinar el total de a√±os vividos de cada persona: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2); System.out.println(ageSum); <span class="hljs-comment"><span class="hljs-comment">// 76</span></span></code> </pre><br>  Como puede ver, obtuvimos el resultado 76, pero ¬øqu√© sucede realmente bajo el cap√≥? <br><br>  Expandimos el fragmento de c√≥digo anterior con la salida del texto para la depuraci√≥n: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Max // accumulator: sum=18; person=Peter // accumulator: sum=41; person=Pamela // accumulator: sum=64; person=David</span></span></code> </pre><br>  Como puede ver, la funci√≥n de acumulaci√≥n realiza todo el trabajo.  Primero se llama con un valor inicial de 0 y la primera persona Max.  En los siguientes tres pasos, la suma aumenta constantemente seg√∫n la edad de la persona desde el √∫ltimo paso hasta que alcanza los 76 a√±os. <br><br>  Entonces, ¬øqu√© sigue?  ¬øNunca se llama al combinador?  Considere la ejecuci√≥n paralela de este hilo: <br><br><pre> <code class="java hljs">Integer ageSum = persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35</span></span></code> </pre><br>  Con ejecuci√≥n paralela, obtenemos una salida de consola completamente diferente.  Ahora se llama realmente al combinador.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como la bater√≠a se llam√≥ en paralelo, el combinador tuvo que resumir los valores almacenados por separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el pr√≥ximo cap√≠tulo, examinaremos con m√°s detalle la ejecuci√≥n paralela de hilos.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hilos paralelos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los subprocesos pueden ejecutarse en paralelo para mejorar el rendimiento cuando se trata con un gran n√∫mero de elementos entrantes. </font><font style="vertical-align: inherit;">Los subprocesos paralelos utilizan el habitual </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disponible a trav√©s de una llamada al m√©todo est√°tico </font></font><code>ForkJoinPool.commonPool()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El tama√±o del grupo de subprocesos principales puede alcanzar los 5 subprocesos de ejecuci√≥n: el n√∫mero exacto depende del n√∫mero de n√∫cleos de procesadores f√≠sicos disponibles.</font></font><br><br><pre> <code class="java hljs">ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En mi computadora, un grupo de subprocesos regulares se inicializa de forma predeterminada con paralelizaci√≥n en 3 subprocesos. </font><font style="vertical-align: inherit;">Este valor se puede aumentar o disminuir configurando el siguiente par√°metro JVM:</font></font><br><br><pre> <code class="bash hljs">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las colecciones admiten un m√©todo </font></font><code>parallelStream()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para crear flujos de datos paralelos. </font><font style="vertical-align: inherit;">Tambi√©n puede llamar a un m√©todo intermedio </font></font><code>parallel()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para convertir un flujo en serie en uno paralelo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para comprender el comportamiento de un subproceso en ejecuci√≥n paralela, el siguiente ejemplo imprime informaci√≥n sobre cada subproceso actual (subproceso) en </font></font><code>System.out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considere las conclusiones con las entradas de depuraci√≥n para comprender mejor qu√© hilo se utiliza para ejecutar m√©todos de flujo espec√≠ficos: </font></font><br><br><pre> <code class="java hljs">filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como puede ver, en la ejecuci√≥n paralela del flujo de datos, se utilizan todos los subprocesos disponibles del actual </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La secuencia de salida puede diferir, ya que la secuencia de ejecuci√≥n de cada subproceso espec√≠fico no est√° definida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Expandamos el ejemplo agregando un m√©todo </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .sorted((s1, s2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"sort: %s &lt;&gt; %s [%s]\n"</span></span>, s1, s2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A primera vista, el resultado puede parecer extra√±o: </font></font><br><br><pre> <code class="java hljs">filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: b1 [main] map: b1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] sort: A2 &lt;&gt; A1 [main] sort: B1 &lt;&gt; A2 [main] sort: C2 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] sort: C1 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: B1 [main] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecutarse secuencialmente y solo en el hilo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De hecho, cuando la transmisi√≥n se ejecuta en paralelo bajo el cap√≥ del m√©todo </font></font><code>sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desde la API de </font><font style="vertical-align: inherit;">transmisi√≥n </font></font><code>Arrays</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, el </font><font style="vertical-align: inherit;">m√©todo de clasificaci√≥n de clase </font><font style="vertical-align: inherit;">, agregado en Java 8, est√° </font><font style="vertical-align: inherit;">oculto </font></font><code>Arrays.parallelSort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Como se indica en la documentaci√≥n, este m√©todo, basado en la longitud de la colecci√≥n entrante, determina c√≥mo se ordenar√° en paralelo o secuencialmente:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si la longitud de una matriz particular es menor que el "grano" m√≠nimo, la clasificaci√≥n se realiza ejecutando el m√©todo Arrays.sort. </font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volvamos al ejemplo con el m√©todo </font></font><code>reduce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del cap√≠tulo anterior. </font><font style="vertical-align: inherit;">Ya hemos descubierto que la funci√≥n unificadora solo se llama cuando se trabaja con el hilo en paralelo. </font><font style="vertical-align: inherit;">Considere qu√© hilos est√°n involucrados:</font></font><br><br><pre> <code class="java hljs">List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)); persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s [%s]\n"</span></span>, sum, p, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s [%s]\n"</span></span>, sum1, sum2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; });</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La salida de la consola muestra que ambas funciones: acumulaci√≥n y combinaci√≥n, se realizan en paralelo, utilizando todos los flujos posibles: </font></font><br><br><pre> <code class="java hljs">accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Pamela; [main] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Max; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=David; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Peter; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">18</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">23</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">23</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">12</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">41</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">35</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se puede argumentar que la ejecuci√≥n paralela del flujo contribuye a un aumento significativo en la eficiencia cuando se trabaja con grandes cantidades de elementos entrantes. </font><font style="vertical-align: inherit;">Sin embargo, debe recordarse que algunos m√©todos en ejecuci√≥n paralela requieren c√°lculos adicionales (operaciones de combinaci√≥n), que no son necesarios en la ejecuci√≥n secuencial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, para la ejecuci√≥n paralela del hilo, </font></font><code>ForkJoinPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se usa </font><font style="vertical-align: inherit;">el mismo </font><font style="vertical-align: inherit;">, tan ampliamente utilizado en la JVM. </font><font style="vertical-align: inherit;">Por lo tanto, el uso de m√©todos de bloqueo lento del flujo puede afectar negativamente el rendimiento de todo el programa, debido al bloqueo de los hilos utilizados para el procesamiento en otras tareas.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eso es todo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mi tutorial sobre el uso de hilos en Java 8 ha terminado. Para un estudio m√°s detallado del trabajo con transmisiones, puede consultar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentaci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si desea profundizar y aprender m√°s sobre los mecanismos que subyacen a los hilos, podr√≠a estar interesado en leer un art√≠culo de Martin Fowler </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Collection Pipelines</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tambi√©n est√° interesado en JavaScript, puede echarle un vistazo a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , la implementaci√≥n de JavaScript de la API Java 8 Streams. Tambi√©n es posible que desee leer mis art√≠culos sobre el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial Java 8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traducci√≥n al ruso</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en Habr√©) y el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tutorial Nashorn Java 8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espero que esta gu√≠a te haya sido √∫til e interesante, y que hayas disfrutado el proceso de lectura. </font><font style="vertical-align: inherit;">El c√≥digo completo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se almacena en GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si√©ntase libre de crear una rama en el repositorio.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437038/">https://habr.com/ru/post/437038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437026/index.html">Google en Francia mult√≥ 50 millones de euros por GDPR por mal uso de datos personales</a></li>
<li><a href="../437030/index.html">Automatizaci√≥n de la infraestructura de una oficina de lujo: c√≥mo se ve</a></li>
<li><a href="../437032/index.html">Instrucciones de instalaci√≥n de NGINX ModSecurity</a></li>
<li><a href="../437034/index.html">Silbatos universales: revisi√≥n de dongle USB Snom A230 y A210</a></li>
<li><a href="../437036/index.html">SAPUI5 para dummies parte 2: un ejercicio completo paso a paso</a></li>
<li><a href="../437040/index.html">En Rusia, comenz√≥ a probar la interfaz neuronal dom√©stica "Neurochat"</a></li>
<li><a href="../437044/index.html">C√≥mo derrotar al drag√≥n: reescribe tu programa en Golang</a></li>
<li><a href="../437050/index.html">El libro "Python. Curso expreso 3ra ed.</a></li>
<li><a href="../437052/index.html">No te pierdas de aprender: ¬ønecesita un especialista universitario en TI?</a></li>
<li><a href="../437054/index.html">Nuevos procesadores Intel de novena generaci√≥n: Core menos GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>