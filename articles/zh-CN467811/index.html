<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☄️ 🈲 🎿 架构和编程Fairchild Channel F 👨🏾‍🤝‍👨🏽 👨🏿‍🎤 👩‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“ F通道的自制程序就像通过硬件跳线编程精灵...” 
 / chadtower，ariariage论坛/ 



 Fairchild Channel F游戏机，也称为VES，于1976年11月问世。 与以前的乒乓球，网球（在同一行中，前苏联称为“视频体育”）不同，它具有非常重要的区别-微处理器和...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>架构和编程Fairchild Channel F</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467811/">  <i>“ F通道的自制程序就像通过硬件跳线编程精灵...”</i> <i><br></i>  <i>/ chadtower，ariariage论坛/</i> <br><br><img src="https://habrastorage.org/webt/o6/vk/fx/o6vkfxmjtwb1atq-tuv08b9smxg.jpeg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Fairchild Channel F</a>游戏机，也称为VES，于1976年11月问世。 与以前的乒乓球，网球（在同一行中，前苏联称为“视频体育”）不同，它具有非常重要的区别-微处理器和带有程序的盒带。 在此之前，游戏机中的游戏是按照严格的逻辑实现的-在现代意义上，该程序是不存在的。 <br><br>  Fairchild Channel F发行至1983年。 在这段时间内，这些游戏机的销量超过了百万分之一， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发行了</a>大约30-40 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">款游戏</a> ，其中有些已经在2000年代了。 <br><br> 说到使用微处理器的优越性，值得注意的是，我在上一篇文章中谈到的RCA Studio II仅晚了几个月，但事实证明它比Channel F弱得多，这就是为什么它销售失败。 然而，不到一年后，Atari VCS出现了，并从市场上取代了Channel F.。 <br><br> 这样，Fairchild_Channel_F的开发就没有了。 在System II和几个克隆版本中，例如Saba Videoplay 2（1979），区别主要在于机身，操纵杆（顺便说一下，除了通常的位置，旋钮的旋转之外，他们都知道）和筹码数量。 在架构上，一切都几乎相同。 <br><br> 什么是F频道？ <br><a name="habracut"></a><br><h1> 中央处理器 </h1><br> 该处理器在那个时代的传统中，是由同一家Fairchild公司生产的，与游戏机本身相同，被称为F8 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">en.wikipedia.org/wiki/Fairchild_F8</a> 。 这是1974年的8位处理器，工作频率为1.8 MHz（一条指令占用1到6个时钟周期）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hj/5n/6k/hj5n6kqky_84xnkbm3v7vdry-we.jpeg"></div><br><br> 但是，它只能称为扩展微处理器，因为该处理器由两块芯片组成-包含ALU的3850CPU计算设备，电池，64字节SRAM，执行指令所需的逻辑，两个端口（没有地址总线！）和3851PSU（可编程）存储单元），其中包含1kb的ROM（用于BIOS），指令指针，存储器寻址方案，中断，计时器（通道F中未专门使用中断和计时器）。 <br><br> 后来出现了F3859芯片，该芯片将CPU和PSU集成在同一芯片上，并在1990年代发布了Mostek 3870（稍有改进的版本）。 但是，这是另一个故事。 有趣的是，有时F8被称为微控制器（特别是由于存在计时器和端口），并且被称为Intel MCS-48家族（8048）的祖先。 <br><br> 除F通道外，F8处理器还用于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VideoBrain</a>计算机和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CompuChess</a>国际象棋计算机中。 通常，令人惊讶的是，关于该处理器的信息很少。 除了Fairchild的一些说明以及一些专门针对Channel F的游戏的源代码和示例外，仅此而已。 似乎该处理器尚未在其他任何地方使用，这似乎令人难以置信（鉴于其高级版本已经发布了相当长的时间）。 我将假定所有其他用于军事目的的设备。 <br><br> 现在介绍一下处理器的功能。 反思其寄存器的设置和功能。 我认为这是当时存在的最混乱的体系结构之一（现代的体系结构可能会扩展，但是这种比较是不正确的，因为它们是为编译器设计的。正在使用F8的人们在工作）。 <br><br> 处理器中有很多寄存器。 除了8位电池A和标志寄存器W（I，O，Z，C，S）之外，还有一个“便签本”-64个具有各种功能的8位单元。 <br><br> 前九个单元在诸如“ lr a，7”之类的命令中用作通用寄存器R0-R8（将寄存器R7的内容加载到电池中）。请注意，未显示字母R-仅写入了寄存器编号。确切的含义是，编号或例如，对于lr指令，根本就不可能有数字，例如，如果“ li 7”（将常数加载到电池中），则它就是数字，而不是寄存器。 <br><br> 单元9、10-11（H），12-13（K），14-15（Q）旨在在不同情况下保存其他寄存器，例如调用子程序。 <br><br> 只能通过特殊的ISAR索引寄存器（间接Scratchpad地址寄存器）访问寄存器R16-R63，这是由单元格16-23、24-31、32-39、40-47、48-55、56-63形成的六个八字节缓冲区。 <br><br> 六位ISAR被分为3位的两个部分。 当将ISAR增加或减少1时，仅影响低3位-即 寻址是在上述六个八个字节的缓冲区之一中进行的（同时，可以通过特殊的br7条件分支指令来跟踪缓冲区的末尾）。 <br><br><pre><code class="plaintext hljs">clr ; 0 -&gt; A ; set ISAR to full address Ox27 (octal 27) lisu 2 ; buffer N2 lisl 7 ; index within buffer N2 loop: lr d,a ; A-&gt; buffer N2[index], than decrement ISAR (27, 26, 25, ... ) br7 loop ; go further if low part of ISAR contains 7 (end of buffer N2). if not, go loop again</code> </pre> <br> 在这种情况下，指令“ lr d，a”中的“ d”不是寄存器的名称，而是需要减少ISAR的标志（“ i”-增加，“ s”-保持不变）。 <br><br> 间接寻址的另一种方式是通过DC0寄存器（数据计数器）： <br><br><pre> <code class="plaintext hljs"> dci data_addr ; data_addr -&gt; DC0 lm ; [data_addr] -&gt; A, DC0 + 1 -&gt; DC0 ... data_addr: db 0,1,2,3,...</code> </pre><br> 如果需要将数据从一个存储区传输到另一个存储区，则还可以使用xdc命令，该命令交换寄存器DC0和DC1的内容。 即 我们从DC0指向的地址读取，然后执行xdc并写入DC1现在指向的地址。 然后再次xdc等 即  DC1是一种影子寄存器，用于存储DC0的副本。 无法直接访问它（命令xdc除外）。 <br><br> 上面的例子仅说明了部分可能性，实际上，还有更多的可能性。 <br><br> 同样在F8中，有四个端口-0、1、4、5，您可以使用out命令将其写入并使用in命令来进行读取。 在通道F中，端口用于输出图形，声音和读取操纵杆状态。 <br><br> 我不会再讨论其他指令，例如算术，转换等-它们是相当标准的。 我只注意到，可以在其上执行操作的寄存器的选择非常有限，因此由于需要不断地来回移动值，因此代码迅速增长。 <br><br> 没有减法（只有加法）。 每单位的减量（ds）和增量（inc）指令是不对称的。  ds仅适用于寄存器r0-r8，inc-仅适用于电池。 <br><br> 无条件跳变会损坏电池。 <br><br> 常规循环的示例： <br><br><pre> <code class="plaintext hljs"> li 25 ; (r4) number of iterations lr 4,a next: ds 4 ; r4-- bnz next ; until r4 == 0</code> </pre><br><h1> 例行程序 </h1><br> 由于F8没有硬件堆栈，因此嵌套子程序调用会遇到困难。 正常的调用和返回如下所示： <br><br><pre> <code class="plaintext hljs"> ; ...code pi sub ; Pushes address of next instruction to PC1 ; address of sub is stored in PC0 (jump to subroutine) ; ...code continues sub: ; ... often used code pop ; Move return address from PC1 to PC0</code> </pre><br>  PC0是常规指令指针。  PC1-所谓的“堆栈寄存器”。 它与堆栈无关，仅在调用子例程时将PC0保存在堆栈中。 <br><br> 如果从sub调用另一个子例程，则返回地址将被覆盖并且需要复杂（将第一个返回地址保存在寄存器K中）： <br><br><pre> <code class="plaintext hljs"> prog: ; ...do something... pi sub1 ; Address of next instruction stored in PC1 ; sub1 is stored in PC0 (jump to subroutine) ; ...do more... sub1: lr k,p ; Copy PC1 to K, original jump address to K ; ...do something... pi sub2 ; Pushes address of next instruction to PC1 ; sub1 is stored in PC0 (jump to subroutine) ; ...do more... pk ; Store address of next instruction in PC1 ; Copy value in K to PC0 (jump back to main) sub2: ; ...do something... pop ; Move return address from PC1 to PC0</code> </pre><br> 如果您还需要第三层嵌套，那么一切都会变得很难过（为此，在BIOS中甚至有两个特殊的例程-pushk和popk）。 <br><br> 一般建议是尝试用宏替换子例程调用。 当然，如果对代码的大小没有严格的限制。 <br><br>  F8中没有硬件堆栈。 如有必要，可以通过ISAR和缓冲区以编程方式实现。 <br><br> 写入RAM并不是很相关（因为缺少一个），但是看起来像这样： <br><br><pre> <code class="plaintext hljs"> li $FF ; set value dci $3800 ; set target address st ; write</code> </pre><br><h1> 记忆 </h1><br> 尽管这听起来有些奇怪，但是仙童频道F中没有RAM。 现有的2 KB视频内存（MK4027）不会显示在地址空间中，并且实际上是不可读的，它们是通过端口写入的。 微处理器的寄存器，即使多达64个，也几乎不认为是RAM正确的。 <br><br> 可执行程序存储在可移动ROM盒式磁带中，通常容量为2kb（某些现代游戏使用3k，4k和5k盒式磁带）。 此外，还有一个内置的处理器芯片1KB ROM ROM，其中包含一个简单的游戏，例如网球，几个有用的例程和几个字符的图像。 <br><br> 在地址空间中，BIOS的位置从$ 0000到$ 07ff，盒式ROM从$ 0800开始。 <br><br><h1> 图形 </h1><br> 通道F的图形功能非常原始，因为那里根本就没有单独芯片形式的视频控制器-一切都以常规逻辑实现，例如移位寄存器，门和运算放大器。 不同的来源提到不同的分辨率是很不寻常的，并且有很多选择。 事实是，可用的2 KB视频内存意味着128 x 64的分辨率，但实际上这远非如此。 首先，很大程度上取决于在此特定电视上形成的图像的哪个区域可见（因为前4列根本没有正式使用）。 其次，在面板下方使用最后几列。 第三，部分存储器根本不使用。 <br><br> 结果，实际分辨率可以大致估计为具有8种颜色的95 x 58像素（但是，其分辨率比RCA Studio II的黑白64x32好得多）。 <br><br> 大多数控制台以NTSC版本发布，但也存在PAL。 正如他们所说（行数相同），没有实际差异。 <br><br> 本质上，这种简单的熨斗仅允许您在屏幕上绘制点。 尽管显示的颜色总数为8，但是一行中只能显示4种颜色（您可以随意将其称为调色板）。 调色板是为每行单独设置的，并且存储在一个相当奇怪的地方-每行的列125和126（无论如何在可见区域之外）。 分别通过在这两列中绘制像素来更改调色板。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fv/pe/47/fvpe47hy-sthzozlebbknihe4qg.png"></div><br>  （屏幕上实际可见的视频存储区域和设置调色板的区域以黄色突出显示） <br><br> 如上所述，只有一种方法可以通过端口将数据写入VRAM。 这表示颜色，列，行： <br><br>  X写入端口4，Y写入端口5，颜色写入端口1，之后通过将常量写入端口0来传输数据： <br><br><pre> <code class="plaintext hljs"> ; set color (2 bit per pixel) li $00 ; color ($00 = green, $40 = red, $80 = blue, $C0 = background) outs 1 li 104 ; X com outs 4 ; set the row li 61 ; Y com outs 5 ; transfer data to VRAM li $60 outs 0 li $50 outs 0 ; wait for update lis 6 delay: ai $ff bnz delay</code> </pre><br> 需要延迟才能记录所有内容，否则可能无法画出下一点。 在正式版中，列和行中仍添加了4（为简化起见，省略了） <br><br> 因此，用点（循环）填充整个屏幕大约需要一秒钟。 重要的是要注意，除了屏幕更新非常慢之外，还存在这样的事实，即没有办法等待光束返回通过框架。 因此，即使是小的重画也不可避免地伴随有闪烁。 <br><br> 现在介绍调色板。 严格来说，每行都有两种模式-黑色和白色（无论绘制的是什么像素，背景都是黑色，前景只有白色）。 <br><br> 在前景色模式下，总是有三个-红色，绿色，蓝色（rgb）。 加上三种背景颜色之一-灰色，浅蓝色，浅绿色。 <br><br> 要在第125和126列中设置调色板，请输入以下值： <br><br><pre> <code class="plaintext hljs">x=125 x=126 palette --------------------------------------------------------------------- 00 00 COLOR: rgb, light green bg 00 ff COLOR: rgb, light blue bg ff 00 COLOR: rgb, gray bg ff ff B/W: www, black bg</code> </pre><br> 在典型的游戏中，他们通常这样做：首先，他们设置一定的一般背景，为此您可以使用现成的BIOS过程： <br><pre> <code class="plaintext hljs"> li $c6 ; $21 - b/w palette, fill with black. $c6 - color palette, fill with gray lr 3, A pi clrscrn ; clrscrn BIOS call</code> </pre><br> 然后，如有必要，用黑白调色板划出一条带（例如，在黑色背景上显示带有白色数字的游戏分数） <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o6/rv/bu/o6rvbu8ifhlp3l5o01jnjhcktpk.jpeg"></div><br> 然后，他们将像素设置为三种颜色之一（如果背景分别为灰色，则分别为r，g，b）。 结果，当然有8种颜色，但是在特定位置放置任意颜色的点非常容易-这是不可能的。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是一组图片</a> ，提供了一些颜色及其组合的概念。 <br><br> 实际上，就此而言，所有这些图形最终都将结束-您想要做的所有事情都是通过手动绘制像素来完成的。 通过有用的例程，BIOS具有字符输出。 但是，出于节省空间的原因，ROM中仅包含数字和单个字符的图像，大小为5x8像素： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/7y/ot/n77yotdf_sdeu8qng3mk76jmeua.png"></div><br> 但是，撤回它们的过程很有用，可以按以下方式使用： <br><br><pre> <code class="plaintext hljs"> li 25 ; column lr 1,a li 25 ; row lr 2,a li %11000000 ; eg $c0 - green "0" lr 0,a ; a -&gt; r0 pi drawchar ; call subroutine</code> </pre><br> 在上述版本中，寄存器r0中的高两位数字确定颜色（10-红色，11-绿色，01-蓝色，00-透明），其余-字符的序列号（0 1 2 3 4 5 6 7 8 9 G？T SPACE MX块：-中心||左||`），从零开始。 寄存器r1和r2分别放置在列和行中。 <br><br> 一个更实际的选择是不考虑位： <br><br><pre> <code class="plaintext hljs"> li 20 ; x lr 1,a ; a -&gt; r1 li 10 ; y lr 2,a ; a -&gt; r2 li $40 ; char color in bits 6,7: $80 (%10000000) - red, $c0 (%11000000) - green, $40 (%01000000) - blue, $00 (%00000000) - transparent oi 1 ; index of char ( eg 3 for "3" ) lr 0,a ; combined color + char index -&gt; r0 pi drawchar ; call subroutine</code> </pre><br> 为了了解该平台，我为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Chaos Constructions'2019</a>的小型介绍比赛编写了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">256字节的介绍</a> 。 没什么特别的，但是请注意为什么在那里使用逐行调色板更改。 沿水平方向爬行的条纹会突出显示其下方的线条，用黑色临时替换整个背景，用白色替换所有像素。 由于您不需要覆盖像素本身（并且以后也不需要还原它们），因此可以非常快速且无闪烁地制作这样的“背光”。 <br><br> 第二点是字母“ CC”。 由于字母“ C”不在BIOS中，因此字母GG与数字1的重叠用于获得反“ CC”。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/X0mVxEY4aD0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1> 声音 </h1><br> 声音不好。 正式地，有三种声音-120Hz，500 Hz和1 KHz。 实际上，要获得除咔嗒声和嘎吱嘎吱声以外的其他东西是有问题的。 此外，他们说在PAL和NTSC机器之间以及旧版本和新版本之间，声音也有所不同。 但是，对于典型的游戏-足够了。 通过端口打开和关闭声音： <br><br><pre> <code class="plaintext hljs"> li %01000000 ; 1khz beep $40 outs 5 li %10000000 ; 500hz beep $80 outs 5 li %11000000 ; 120hz beep $c0 outs 5 ; some pause clr outs 5 ; turn off sound</code> </pre><br> 人们甚至玩音乐都很开心。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最好的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">样本在</a>远程上类似于PC扬声器。 确实，无论如何都没有实际意义-所有处理器资源都用于音乐，没有什么特别的事情可以做。 <br><br><h1> 开发工具 </h1><br> 当前，有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">现成的</a>必要软件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择，</a>称为“ Development Pack”。 <br><br> 这包括DASM汇编程序，反汇编程序，MESS仿真器（带有调试器）。 所有这些都至少在Windows 7下可以正常工作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/zy/kv/fgzykvvz7qwxpwpxwhrkpjnl6ue.png"></div><br> 组装和启动参数： <br><br><pre> <code class="plaintext hljs">dasm.exe test.asm -f3 -otest.bin messd channelf -cartridge %cartPath%\test.bin -w -effect sharp -r 640x480 -ka</code> </pre> <br> 该模拟器非常好，尽管那里的调试器非常奇怪。 我无法立即配置新版本的MAME / MESS（我注意到，每次为据说不支持的不受欢迎的平台设置MAME都是不平凡的任务）。 <br><br> 仿真器假定可见区域的分辨率对应于minx = 5，minY = 5，maxX = 105，maxY = 61 <br><br> 由于没有在没有实时测试结果的情况下在模拟器下编写某些东西的乐趣，因此我不得不解决ROM模拟器的问题。 应我的要求， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">tnt23</a>制造了一个特殊的盒式磁带（亚历山大· <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">诺沃基洛夫</a> （Alexander Novozhilov）打印了一个盒子），其中插入了EEPROM 28C16A。 由于F8寻址的特殊性，我仍然不得不在eBay上购买一个古老的Fairchild 3853芯片，结果，通过对EEPROM编程，可以看到代码在带电机器上的外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7y/1b/ba/7y1bbagbzaam_bcm_kttnv_2juo.jpeg"></div><br> 此外，tnt23附加了Channel F S-Video输出（通常只能通过天线输入连接到电视），从而大大改善了图像质量和色彩再现。 <br><br> 有关Fairchild Channel F的故事： <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Fid3KhEaFJY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h1> 资源资源 </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">VES维基</a> </li><li> 方案<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[1]</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[2]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F8的历史</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编程F8</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">专利</a> （运作方式） </li><li>  XM的音乐播放器/转换器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[1]</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[2]</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">图片</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">滚动介绍</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467811/">https://habr.com/ru/post/zh-CN467811/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467795/index.html">关于加密货币和国家法规的说明</a></li>
<li><a href="../zh-CN467797/index.html">“为……而笑”：为什么您需要没有“战斗”应用程序的软件工具</a></li>
<li><a href="../zh-CN467801/index.html">最小的自动化。 第1.1部分。 虚拟化基础</a></li>
<li><a href="../zh-CN467803/index.html">python + matplotlib中的自定义物理交互的基本模拟</a></li>
<li><a href="../zh-CN467807/index.html">在俄罗斯买卖加密货币：方法，合法化，风险</a></li>
<li><a href="../zh-CN467813/index.html">审查FSTEC第17阶的变更</a></li>
<li><a href="../zh-CN467817/index.html">关于生成设计模式的一些知识</a></li>
<li><a href="../zh-CN467821/index.html">简化并削减需求：Doom的创建者John Romero访谈</a></li>
<li><a href="../zh-CN467823/index.html">解析：Kubernetes上的OOM</a></li>
<li><a href="../zh-CN467825/index.html">必备的机器学习算法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>