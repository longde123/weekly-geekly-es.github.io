<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ö∞Ô∏è üïë ü§ôüèº Statische Verteilung von FreeRTOS-Objekten üï§ üßõüèº üì¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Standardm√§√üig werden alle Objekte im FreeRTOS-System dynamisch verteilt - Warteschlangen, Semaphoren, Timer, Aufgaben (Threads) und Mutexe. Der Progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Statische Verteilung von FreeRTOS-Objekten</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459086/">  Standardm√§√üig werden alle Objekte im FreeRTOS-System dynamisch verteilt - Warteschlangen, Semaphoren, Timer, Aufgaben (Threads) und Mutexe.  Der Programmierer sieht nur den "Heap" - den Bereich, in dem Speicher auf Anforderung eines Programms oder Systems dynamisch zugewiesen wird und in dem nicht klar ist, was im Inneren geschieht.  Wie viel ist noch √ºbrig?  Unbekannt  Nimmt etwas mehr als Sie brauchen?  Wer wei√ü?  Pers√∂nlich ziehe ich es vor, die Probleme beim Organisieren des Speichers bereits beim Schreiben der Firmware zu l√∂sen, ohne Laufzeitfehler zu verursachen, wenn der Speicher unerwartet beendet wird. <br><br>  Dieser Artikel ist eine logische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung von gestern</a> √ºber die statische Verteilung von Objekten im Speicher des Mikrocontrollers, nur jetzt in Bezug auf FreeRTOS-Objekte.  Heute lernen wir, wie man FreeRTOS-Objekte statisch platziert, um besser zu verstehen, was im RAM des Mikrocontrollers geschieht, wie genau sich unsere Objekte befinden und wie viel sie belegen. <br><br>  Das statische Aufnehmen und Starten von FreeRTOS-Objekten erfordert jedoch nicht viel Intelligenz. Ab Version 9.0 bietet FreeRTOS Funktionen zum Erstellen statisch platzierter Objekte.  Solche Funktionen haben ein statisches Suffix im Namen und diese Funktionen haben eine ausgezeichnete Dokumentation mit Beispielen.  Wir werden praktische und sch√∂ne C ++ - Wrapper √ºber FreeRTOS-Funktionen schreiben, die nicht nur Objekte statisch platzieren, sondern auch alle Innereien verbergen und eine bequemere Oberfl√§che bieten. <br><br>  Dieser Artikel richtet sich an Programmierer f√ºr Anf√§nger, die jedoch bereits mit den Grundlagen von FreeRTOS und den Grundelementen der Synchronisierung von Multithread-Programmen vertraut sind.  Lass uns gehen. <br><a name="habracut"></a><br>  FreeRTOS ist ein Betriebssystem f√ºr Mikrocontroller.  Okay, kein vollst√§ndiges Betriebssystem, sondern eine Bibliothek, mit der Sie mehrere Aufgaben parallel ausf√ºhren k√∂nnen.  Mit FreeRTOS k√∂nnen Aufgaben auch Nachrichten √ºber Nachrichtenwarteschlangen austauschen, Zeitgeber verwenden und Aufgaben mithilfe von Semaphoren und Mutexen synchronisieren. <br><br>  Meiner Meinung nach kann jede Firmware, bei der Sie zwei (oder mehr) Aufgaben gleichzeitig ausf√ºhren m√ºssen, viel einfacher und eleganter gel√∂st werden, wenn Sie FreeRTOS verwenden.  Lesen Sie beispielsweise die Messwerte von langsamen Sensoren und bedienen Sie gleichzeitig das Display.  Nur so, dass ohne Bremsen, w√§hrend die Sensoren gelesen werden.  Im Allgemeinen muss haben!  Ich empfehle dringend f√ºr das Studium. <br><br>  Wie ich bereits in einem fr√ºheren Artikel sagte und schrieb, mag ich den Ansatz, Objekte dynamisch zu erstellen, nicht wirklich, wenn wir ihre Anzahl und Gr√∂√üe bei der Kompilierung kennen.  Wenn solche Objekte statisch platziert werden, erhalten wir ein klareres und verst√§ndlicheres Bild der Speicherzuordnung im Mikrocontroller und vermeiden daher √úberraschungen, wenn der Speicher pl√∂tzlich endet. <br><br>  Wir werden Probleme mit der FreeRTOS-Speicherorganisation anhand der BluePill-Karte auf dem STM32F103C8T6-Mikrocontroller als Beispiel betrachten.  Um sich keine Sorgen um den Compiler und das Build-System zu machen, werden wir in der ArduinoIDE-Umgebung arbeiten und die Unterst√ºtzung f√ºr dieses Board installieren.  Es gibt mehrere Implementierungen von Arduino f√ºr STM32 - im Prinzip reicht jede aus.  Ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stm32duino</a> gem√§√ü den Anweisungen aus dem Readme.md-Projekt installiert, einem Bootloader, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel erw√§hnt</a> .  FreeRTOS Version 10.0 wird √ºber den ArduinoIDE-Bibliotheksmanager installiert.  Compiler - gcc 8.2 <br><br>  Wir werden uns eine kleine experimentelle Aufgabe einfallen lassen.  Diese Aufgabe hat m√∂glicherweise nicht viel praktischen Sinn, aber alle in FreeRTOS enthaltenen Synchronisationsprimitive werden verwendet.  So etwas wie das: <br><br><ul><li>  2 Aufgaben (Threads) arbeiten parallel </li><li>  Es funktioniert auch ein Timer, der von Zeit zu Zeit eine Benachrichtigung an die erste Aufgabe sendet, indem er ein Semaphor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Signal-Wartemodus verwendet</a> </li><li>  Die erste Aufgabe, die eine Benachrichtigung vom Zeitgeber erhalten hat, sendet eine Nachricht (Zufallszahl) √ºber die Warteschlange an die zweite Aufgabe </li><li>  Der zweite, der die Nachricht erhalten hat, druckt sie auf der Konsole aus </li><li>  Lassen Sie die erste Aufgabe auch etwas auf die Konsole drucken, und damit sie nicht k√§mpfen, wird die Konsole durch den Mutex gesch√ºtzt. </li><li>  Die Warteschlangengr√∂√üe k√∂nnte auf ein Element begrenzt sein, aber um es interessanter zu machen, setzen wir 1000 </li></ul><br>  Die Standardimplementierung (gem√§√ü Dokumentation und Tutorials) sieht m√∂glicherweise so aus. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;STM32FreeRTOS.h&gt; TimerHandle_t xTimer; xSemaphoreHandle xSemaphore; xSemaphoreHandle xMutex; xQueueHandle xQueue; void vTimerCallback(TimerHandle_t pxTimer) { xSemaphoreGive(xSemaphore); } void vTask1(void *) { while(1) { xSemaphoreTake(xSemaphore, portMAX_DELAY); int value = random(1000); xQueueSend(xQueue, &amp;value, portMAX_DELAY); xSemaphoreTake(xMutex, portMAX_DELAY); Serial.println("Test"); xSemaphoreGive(xMutex); } } void vTask2(void *) { while(1) { int value; xQueueReceive(xQueue, &amp;value, portMAX_DELAY); xSemaphoreTake(xMutex, portMAX_DELAY); Serial.println(value); xSemaphoreGive(xMutex); } } void setup() { Serial.begin(9600); vSemaphoreCreateBinary(xSemaphore); xQueue = xQueueCreate(1000, sizeof(int)); xMutex = xSemaphoreCreateMutex(); xTimer = xTimerCreate("Timer", 1000, pdTRUE, NULL, vTimerCallback); xTimerStart(xTimer, 0); xTaskCreate(vTask1, "Task 1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL); xTaskCreate(vTask2, "Task 2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL); vTaskStartScheduler(); } void loop() {}</span></span></span></span></code> </pre> <br>  Mal sehen, was im Speicher des Mikrocontrollers passiert, wenn Sie solchen Code kompilieren.  Standardm√§√üig werden alle FreeRTOS-Objekte im dynamischen Speicher abgelegt.  FreeRTOS bietet bis zu 5 Implementierungen von Speichermanagern, die schwer zu implementieren sind, aber im Allgemeinen die gleiche Aufgabe haben - Speicherteile f√ºr die Anforderungen von FreeRTOS und des Benutzers zu schneiden.  St√ºcke werden entweder aus dem allgemeinen Haufen des Mikrocontrollers (unter Verwendung von Malloc) geschnitten oder verwenden ihren eigenen separaten Haufen.  Welche Art von Heap f√ºr uns verwendet wird, ist nicht wichtig - wir k√∂nnen sowieso nicht in den Heap schauen. <br><br>  F√ºr einen Heap mit dem Namen FreeRTOS sieht es beispielsweise so aus (Ausgabe des Dienstprogramms objdump). <br><br><pre> <code class="plaintext hljs">... 200009dc l O .bss 00002000 ucHeap ...</code> </pre><br>  Das hei√üt,  Wir sehen ein gro√ües St√ºck, in das alle FreeRTOS-Objekte geschnitten sind - Semaphoren, Mutexe, Timer, Warteschlangen und sogar die Aufgaben selbst.  Die letzten 2 Punkte sind sehr wichtig.  Abh√§ngig von der Anzahl der Elemente kann die Warteschlange sehr gro√ü sein, und Aufgaben nehmen aufgrund des Stapels, der auch zusammen mit der Aufgabe zugewiesen wird, garantiert viel Platz ein. <br><br>  Ja, dies ist ein Minus des Multitasking - jede Aufgabe hat ihren eigenen Stapel.  Dar√ºber hinaus muss der Stapel gro√ü genug sein, damit er nicht nur die Aufrufe und lokalen Variablen der Aufgabe selbst enth√§lt, sondern auch den Interrupt-Stapel, falls dies auftritt.  Nun, da ein Interrupt jederzeit auftreten kann, sollte jede Aufgabe im Falle einer Unterbrechung eine Reserve auf dem Stapel haben.  Dar√ºber hinaus k√∂nnen CortexM-Mikrocontroller verschachtelte Interrupts aufweisen, sodass der Stapel gro√ü genug sein muss, um alle Interrupts aufzunehmen, wenn sie gleichzeitig auftreten. <br><br>  Die Gr√∂√üe des Aufgabenstapels wird festgelegt, wenn die Aufgabe durch den Parameter der Funktion xTaskCreate erstellt wird.  Die Stapelgr√∂√üe darf nicht kleiner sein als der Parameter configMINIMAL_STACK_SIZE (in der Konfigurationsdatei FreeRTOSConfig.h angegeben) - dies ist dieselbe Reserve f√ºr Interrupts.  Die Heap-Gr√∂√üe wird durch den Parameter configTOTAL_HEAP_SIZE festgelegt und betr√§gt in diesem Fall 8 KB. <br><br><div class="spoiler">  <b class="spoiler_title">Versuchen Sie nun zu erraten, ob alle unsere Objekte in einen 8-KB-Haufen passen.</b>  <b class="spoiler_title">Und ein paar Gegenst√§nde?</b>  <b class="spoiler_title">Und noch ein paar Aufgaben?</b> <div class="spoiler_text">  Bei bestimmten FreeRTOS-Einstellungen passten nicht alle Objekte in den Heap.  Und es sieht so aus: Das Programm funktioniert einfach nicht.  Das hei√üt,  alles wird kompiliert, gegossen, aber dann h√§ngt der Mikrocontroller einfach und das wars.  Und raten Sie mal, dass das Problem genau die Gr√∂√üe des Haufens ist.  Ich musste ein paar auf 12kb erh√∂hen. <br></div></div><br>  Stop, was sind die Variablen xTimer, xQueue, xSemaphore und xMutex?  Beschreiben sie nicht die Objekte, die wir brauchen?  Nein, dies sind nur Handles - Zeiger auf eine bestimmte (undurchsichtige) Struktur, die die Synchronisationsobjekte selbst beschreibt <br><br><pre> <code class="plaintext hljs">200009cc g O .bss 00000004 xTimer 200009d0 g O .bss 00000004 xSemaphore 200009cc g O .bss 00000004 xQueue 200009d4 g O .bss 00000004 xMutex</code> </pre><br>  Wie ich bereits erw√§hnt habe, schlage ich vor, all dieses Durcheinander auf die gleiche Weise wie im vorherigen Artikel zu reparieren - wir werden alle unsere Objekte in der Kompilierungsphase statisch verteilen.  Die statischen Verteilungsfunktionen werden verf√ºgbar, wenn der Parameter configSUPPORT_STATIC_ALLOCATION in der FreeRTOS-Konfigurationsdatei auf 1 gesetzt ist. <br><br>  Beginnen wir mit den Zeilen.  Hier erfahren Sie, wie die Dokumentation zu FreeRTOS das Zuweisen von Warteschlangen bietet <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMessage</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ucMessageID; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ucData[ <span class="hljs-number"><span class="hljs-number">20</span></span> ]; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QUEUE_LENGTH 10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ITEM_SIZE sizeof( uint32_t ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// xQueueBuffer will hold the queue structure. StaticQueue_t xQueueBuffer; // ucQueueStorage will hold the items posted to the queue. Must be at least // [(queue length) * ( queue item size)] bytes long. uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ]; void vATask( void *pvParameters ) { QueueHandle_t xQueue1; // Create a queue capable of containing 10 uint32_t values. xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold. ITEM_SIZE // The size of each item in the queue &amp;( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue. &amp;xQueueBuffer ); // The buffer that will hold the queue structure. // The queue is guaranteed to be created successfully as no dynamic memory // allocation is used. Therefore xQueue1 is now a handle to a valid queue. // ... Rest of task code. }</span></span></span></span></code> </pre> <br>  In diesem Beispiel wird die Warteschlange durch drei Variablen beschrieben: <br><br><ul><li>  Im Array ucQueueStorage werden die Warteschlangenelemente platziert.  Die Warteschlangengr√∂√üe wird vom Benutzer f√ºr jede Warteschlange einzeln festgelegt. </li><li>  Die xQueueBuffer-Struktur - hier werden die Beschreibung und der Status der Warteschlange, die aktuelle Gr√∂√üe, Listen ausstehender Aufgaben sowie andere Attribute und Felder aufgef√ºhrt, die FreeRTOS f√ºr die Arbeit mit der Warteschlange ben√∂tigt.  Der Name f√ºr die Variable ist meiner Meinung nach nicht ganz erfolgreich, in FreeRTOS selbst hei√üt dieses Ding QueueDefinition (Beschreibung der Warteschlange). </li><li>  Die Variable xQueue1 ist die Kennung der Warteschlange (Handle).  Alle Warteschlangenverwaltungsfunktionen sowie einige andere (z. B. interne Funktionen zum Arbeiten mit Timern, Semaphoren und Mutexen) akzeptieren ein solches Handle.  Tats√§chlich ist dies nur ein Zeiger auf QueueDefinition, aber wir wissen dies nicht (sozusagen), und daher muss der Griff separat gezogen werden. </li></ul><br>  Wie im Beispiel zu tun, ist nat√ºrlich kein Problem.  Ich pers√∂nlich m√∂chte jedoch nicht bis zu 3 Variablen pro Entit√§t haben.  Eine Klasse, die es kapseln kann, fragt bereits danach.  Nur ein Problem - die Gr√∂√üe jeder Warteschlange kann variieren.  An einem Ort ben√∂tigen Sie eine gr√∂√üere Warteschlange, an einem anderen reichen ein paar Elemente aus.  Da wir statisch anstehen m√∂chten, m√ºssen wir diese Gr√∂√üe beim Kompilieren irgendwie angeben.  Hierf√ºr k√∂nnen Sie die Vorlage verwenden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> QueueHandle_t xHandle; StaticQueue_t x QueueDefinition; T xStorage[size]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue() { xHandle = xQueueCreateStatic(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(xStorage), &amp;xQueueDefinition); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueReceive(xHandle, val, xTicksToWait); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueSend(xHandle, &amp;val, xTicksToWait); } };</code> </pre> <br>  Gleichzeitig wurden in dieser Klasse auch die Funktionen des Sendens und Empfangens von Nachrichten festgelegt, die f√ºr uns unmittelbar g√ºnstig waren. <br><br>  Die Warteschlange wird als globale Variable deklariert <br><br><pre> <code class="cpp hljs">Queue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>&gt; xQueue;</code> </pre> <br>  Nachrichten senden <br><br><pre> <code class="cpp hljs"> xQueue.send(value);</code> </pre> <br>  Nachricht empfangen <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; xQueue.receive(&amp;value);</code> </pre><br>  Nun besch√§ftigen wir uns mit Semaphoren.  Und obwohl technisch (innerhalb von FreeRTOS) Semaphoren und Mutexe durch Warteschlangen implementiert werden, sind dies semantisch 3 verschiedene Grundelemente.  Daher werden wir sie in separaten Klassen implementieren. <br><br>  Die Implementierung der Semaphorklasse ist recht trivial - sie speichert einfach mehrere Variablen und deklariert mehrere Funktionen. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sema</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xSema; StaticSemaphore_t xSemaControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sema() { xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xSema); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xSema, xTicksToWait); } };</code> </pre> <br>  Semaphor-Deklaration <br><br><pre> <code class="cpp hljs">Sema xSema;</code> </pre> <br>  Semaphor-Erfassung <br><br><pre> <code class="cpp hljs"> xSema.take();</code> </pre> <br>  Semaphor-Ver√∂ffentlichung <br><br><pre> <code class="cpp hljs"> xSema.give();</code> </pre> <br>  Jetzt Mutex <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xMutex; StaticSemaphore_t xMutexControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() { xMutex = xSemaphoreCreateMutexStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xMutex, xTicksToWait); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xMutex); } };</code> </pre> <br>  Wie Sie sehen k√∂nnen, ist die Mutex-Klasse fast identisch mit der Semaphor-Klasse.  Aber wie ich semantisch sagte, sind dies verschiedene Entit√§ten.  Dar√ºber hinaus sind die Schnittstellen dieser Klassen nicht vollst√§ndig und werden in v√∂llig unterschiedliche Richtungen erweitert.  Daher k√∂nnen die Methoden giveFromISR () und takeFromISR () zum Semaphor hinzugef√ºgt werden, um mit dem Semaphor im Interrupt zu arbeiten, w√§hrend dem Mutex nur die Methode tryLock () hinzugef√ºgt wird - es gibt keine anderen semantischen Operationen. <br><br><div class="spoiler">  <b class="spoiler_title">Ich hoffe, Sie kennen den Unterschied zwischen einem bin√§ren Semaphor und einem Mutex.</b> <div class="spoiler_text">  Ich stelle diese Frage immer bei Interviews und leider verstehen 90% der Kandidaten diesen Unterschied nicht.  Tats√§chlich kann ein Semaphor von verschiedenen Threads erfasst und freigegeben werden.  Oben habe ich den Signal-Warte-Semaphor-Modus erw√§hnt, wenn ein Thread ein Signal sendet (Aufrufe give ()) und der andere auf ein Signal wartet (mit der Funktion take ()). <br><br>  Im Gegenteil, Mutex kann nur von demselben Stream (Aufgabe) freigegeben werden, der es erfasst hat.  Ich bin nicht sicher, ob FreeRTOS dies √ºberwacht, aber einige Betriebssysteme (z. B. Linux) halten sich strikt daran. </div></div><br>  Mutex kann in Stil C verwendet werden, d.h.  Rufen Sie direkt lock () / entsperren () auf.  Da wir jedoch in C ++ schreiben, k√∂nnen wir die Reize von RAII nutzen und einen bequemeren Wrapper schreiben, der den Mutex selbst erfasst und freigibt. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> Mutex &amp; mtx; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(Mutex &amp; mutex) : mtx(mutex) { mtx.lock(); } ~MutexLocker() { mtx.unlock(); } };</code> </pre> <br>  Beim Verlassen des Bereichs wird der Mutex automatisch freigegeben. <br><br>  Dies ist besonders praktisch, wenn die Funktion mehrere Exits enth√§lt und Sie sich nicht st√§ndig an die Notwendigkeit erinnern m√ºssen, Ressourcen freizugeben. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(value); } <span class="hljs-comment"><span class="hljs-comment">// mutex will be unlocked here</span></span></code> </pre> <br>  Jetzt sind die Timer an der Reihe. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> TimerHandle_t xTimer; StaticTimer_t xTimerControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Timer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcTimerName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TickType_t xTimerPeriodInTicks, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UBaseType_t uxAutoReload, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvTimerID, TimerCallbackFunction_t pxCallbackFunction) { xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ xTimerStart(xTimer, xTicksToWait); } };</code> </pre> <br>  Im Allgemeinen ist hier alles √§hnlich wie in den vorherigen Klassen, ich werde nicht im Detail darauf eingehen.  Vielleicht l√§sst die API zu w√ºnschen √ºbrig oder erfordert zumindest eine Erweiterung.  Mein Ziel ist es jedoch, das Prinzip zu zeigen und es nicht produktionsbereit zu machen. <br><br>  Und schlie√ülich die Aufgaben.  Jede Aufgabe hat einen Stapel und muss vorab im Speicher abgelegt werden.  Wir werden die gleiche Technik wie bei Warteschlangen verwenden - wir werden eine Vorlagenklasse schreiben <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStackDepth&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: StaticTask_t xTaskControlBlock; StackType_t xStack[ ulStackDepth ]; TaskHandle_t xTask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Task(TaskFunction_t pxTaskCode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvParameters, UBaseType_t uxPriority) { xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock); } };</code> </pre> <br>  Da Aufgabenobjekte jetzt als globale Variablen deklariert werden, werden sie vor dem Aufruf von main () als globale Variablen initialisiert.  Dies bedeutet, dass zu diesem Zeitpunkt auch die Parameter bekannt sein sollten, die auf die Aufgaben √ºbertragen werden.  Diese Nuance sollte ber√ºcksichtigt werden, wenn in Ihrem Fall etwas √ºbergeben wird, das vor dem Erstellen der Aufgabe berechnet werden muss (ich habe dort nur NULL).  Wenn dies immer noch nicht zu Ihnen passt, ziehen Sie die Option mit lokalen statischen Variablen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aus dem vorherigen Artikel in</a> Betracht. <br><br>  Kompilieren Sie und erhalten Sie den Fehler: <br><br><pre> <code class="plaintext hljs">tasks.c:(.text.vTaskStartScheduler+0x10): undefined reference to `vApplicationGetIdleTaskMemory' timers.c:(.text.xTimerCreateTimerTask+0x1a): undefined reference to `vApplicationGetTimerTaskMemory'</code> </pre> <br>  Hier ist das Ding.  Jedes Betriebssystem hat eine spezielle Aufgabe - Leerlaufaufgabe (die Standardaufgabe, die Aufgabe, nichts zu tun).  Das Betriebssystem f√ºhrt diese Aufgabe aus, wenn nicht alle anderen Aufgaben ausgef√ºhrt werden k√∂nnen (z. B. Schlafen oder Warten auf etwas).  Im Allgemeinen ist dies die h√§ufigste Aufgabe, nur mit der niedrigsten Priorit√§t.  Aber hier wird es im FreeRTOS-Kernel erstellt und wir k√∂nnen seine Erstellung nicht beeinflussen.  Da wir jedoch damit begonnen haben, Aufgaben statisch zu platzieren, m√ºssen wir dem Betriebssystem irgendwie mitteilen, wo Sie die Steuereinheit und den Stapel dieser Aufgabe platzieren m√∂chten.  Daf√ºr ist FreeRTOS gedacht und fordert uns auf, eine spezielle Funktion vApplicationGetIdleTaskMemory () zu definieren. <br><br>  Eine √§hnliche Situation besteht bei Timern.  Timer im FreeRTOS-System leben nicht von alleine - eine besondere Aufgabe ist das Drehen im Betriebssystem, das diese Timer bedient.  Und diese Aufgabe erfordert auch einen Steuerblock und einen Stapel.  Und einfach so fordert uns das Betriebssystem auf, anzugeben, wo sie die Funktion vApplicationGetTimerTaskMemory () verwenden. <br><br>  Die Funktionen selbst sind trivial und geben einfach die entsprechenden Zeiger auf statisch zugewiesene Objekte zur√ºck. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetIdleTaskMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulIdleTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Idle_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Idle_Stack[configMINIMAL_STACK_SIZE]; *ppxIdleTaskTCBBuffer = &amp;Idle_TCB; *ppxIdleTaskStackBuffer = Idle_Stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetTimerTaskMemory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulTimerTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Timer_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Timer_Stack[configTIMER_TASK_STACK_DEPTH]; *ppxTimerTaskTCBBuffer = &amp;Timer_TCB; *ppxTimerTaskStackBuffer = Timer_Stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; }</code> </pre> <br>  Mal sehen, was wir haben. <br><br><div class="spoiler">  <b class="spoiler_title">Ich werde den Code der Helfer unter dem Spoiler verstecken, du hast ihn gerade gesehen</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Queue</span></span></span><span class="hljs-class"> {</span></span> QueueHandle_t xHandle; StaticQueue_t xQueueDefinition; T xStorage[size]; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Queue() { xHandle = xQueueCreateStatic(size, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T), <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>*&gt;(xStorage), &amp;xQueueDefinition); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T * val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueReceive(xHandle, val, xTicksToWait); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T &amp; val, TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xQueueSend(xHandle, &amp;val, xTicksToWait); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sema</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xSema; StaticSemaphore_t xSemaControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Sema() { xSema = xSemaphoreCreateBinaryStatic(&amp;xSemaControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">give</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xSema); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xSema, xTicksToWait); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mutex</span></span></span><span class="hljs-class"> {</span></span> SemaphoreHandle_t xMutex; StaticSemaphore_t xMutexControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Mutex() { xMutex = xSemaphoreCreateMutexStatic(&amp;xMutexControlBlock); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = portMAX_DELAY)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreTake(xMutex, xTicksToWait); } <span class="hljs-function"><span class="hljs-function">BaseType_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xSemaphoreGive(xMutex); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutexLocker</span></span></span><span class="hljs-class"> {</span></span> Mutex &amp; mtx; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MutexLocker(Mutex &amp; mutex) : mtx(mutex) { mtx.lock(); } ~MutexLocker() { mtx.unlock(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timer</span></span></span><span class="hljs-class"> {</span></span> TimerHandle_t xTimer; StaticTimer_t xTimerControlBlock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Timer(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcTimerName, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TickType_t xTimerPeriodInTicks, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UBaseType_t uxAutoReload, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvTimerID, TimerCallbackFunction_t pxCallbackFunction) { xTimer = xTimerCreateStatic(pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, &amp;xTimerControlBlock); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TickType_t xTicksToWait = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ xTimerStart(xTimer, xTicksToWait); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> ulStackDepth&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Task</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: StaticTask_t xTaskControlBlock; StackType_t xStack[ ulStackDepth ]; TaskHandle_t xTask; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Task(TaskFunction_t pxTaskCode, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pcName, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pvParameters, UBaseType_t uxPriority) { xTask = xTaskCreateStatic(pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, xStack, &amp;xTaskControlBlock); } }; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetIdleTaskMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulIdleTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Idle_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Idle_Stack[configMINIMAL_STACK_SIZE]; *ppxIdleTaskTCBBuffer = &amp;Idle_TCB; *ppxIdleTaskStackBuffer = Idle_Stack; *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE; } <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vApplicationGetTimerTaskMemory</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pulTimerTaskStackSize)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticTask_t Timer_TCB; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StackType_t Timer_Stack[configTIMER_TASK_STACK_DEPTH]; *ppxTimerTaskTCBBuffer = &amp;Timer_TCB; *ppxTimerTaskStackBuffer = Timer_Stack; *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH; }</code> </pre> </div></div><br><br>  Der Code f√ºr das gesamte Programm. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Timer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Timer"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1000</span></span></span></span><span class="hljs-function"><span class="hljs-params">, pdTRUE, </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params">, vTimerCallback)</span></span></span></span>; Sema xSema; Mutex xMutex; Queue&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>&gt; xQueue; Task&lt;configMINIMAL_STACK_SIZE&gt; task1(vTask1, <span class="hljs-string"><span class="hljs-string">"Task 1"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY); Task&lt;configMINIMAL_STACK_SIZE&gt; task2(vTask2, <span class="hljs-string"><span class="hljs-string">"Task 2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, tskIDLE_PRIORITY); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTimerCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TimerHandle_t pxTimer)</span></span></span><span class="hljs-function"> </span></span>{ xSema.give(); <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { xSema.take(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = random(<span class="hljs-number"><span class="hljs-number">1000</span></span>); xQueue.send(value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTask2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; xQueue.receive(&amp;value); <span class="hljs-function"><span class="hljs-function">MutexLocker </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(xMutex)</span></span></span></span>; Serial.println(value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); xTimer.start(); vTaskStartScheduler(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br>  Sie k√∂nnen die resultierende Bin√§rdatei zerlegen und sehen, was und wie sie sich befindet (die Ausgabe von objdump ist zur besseren Lesbarkeit leicht get√∂nt): <br><br><pre> <code class="plaintext hljs">0x200000b0 .bss 512 vApplicationGetIdleTaskMemory::Idle_Stack 0x200002b0 .bss 92 vApplicationGetIdleTaskMemory::Idle_TCB 0x2000030c .bss 1024 vApplicationGetTimerTaskMemory::Timer_Stack 0x2000070c .bss 92 vApplicationGetTimerTaskMemory::Timer_TCB 0x200009c8 .bss 608 task1 0x20000c28 .bss 608 task2 0x20000e88 .bss 84 xMutex 0x20000edc .bss 4084 xQueue 0x20001ed0 .bss 84 xSema 0x20001f24 .bss 48 xTimer</code> </pre> <br>  Das Ziel ist erreicht - jetzt ist alles im Blick.  Jedes Objekt ist sichtbar und seine Gr√∂√üe ist verst√§ndlich (au√üer dass zusammengesetzte Objekte des Aufgabentyps alle ihre Ersatzteile in einem St√ºck betrachten).  Compiler-Statistiken sind ebenfalls √§u√üerst genau und diesmal sehr n√ºtzlich. <br><br><pre> <code class="plaintext hljs">Sketch uses 20,800 bytes (15%) of program storage space. Maximum is 131,072 bytes. Global variables use 9,332 bytes (45%) of dynamic memory, leaving 11,148 bytes for local variables. Maximum is 20,480 bytes.</code> </pre> <br><h2>  Fazit </h2><br>  Mit FreeRTOS k√∂nnen Sie zwar Aufgaben, Warteschlangen, Semaphoren und Mutexe im laufenden Betrieb erstellen und l√∂schen, dies ist jedoch in vielen F√§llen nicht erforderlich.  In der Regel reicht es aus, alle Objekte beim Start einmal zu erstellen und sie funktionieren bis zum n√§chsten Neustart.  Dies ist ein guter Grund, solche Objekte in der Kompilierungsphase statisch zu verteilen.  Als Ergebnis erhalten wir ein klares Verst√§ndnis des Ged√§chtnisses unserer Objekte, wo was liegt und wie viel freies Ged√§chtnis √ºbrig bleibt. <br><br>  Es ist offensichtlich, dass das vorgeschlagene Verfahren nur zum Platzieren von Objekten geeignet ist, deren Lebensdauer mit der Lebensdauer der gesamten Anwendung vergleichbar ist.  Andernfalls sollten Sie dynamischen Speicher verwenden. <br><br>  Zus√§tzlich zur statischen Platzierung von FreeRTOS-Objekten haben wir auch praktische Wrapper √ºber die FreeRTOS-Grundelemente geschrieben, wodurch wir den Client-Code etwas vereinfachen und auch kapseln konnten <br><br>  Die Schnittstelle kann bei Bedarf vereinfacht werden (z. B. ohne √úberpr√ºfung des R√ºckkehrcodes oder ohne Verwendung von Zeit√ºberschreitungen).  Es ist auch erw√§hnenswert, dass die Implementierung unvollst√§ndig ist. Ich habe mich nicht mit der Implementierung aller m√∂glichen Methoden zum Senden und Empfangen von Nachrichten √ºber die Warteschlange befasst (z. B. von einem Interrupt √ºber das Senden an den Anfang oder das Ende der Warteschlange). Ich habe keine Synchronisationsprimitive aus Interrupts implementiert und (nicht-bin√§re) Semaphoren gez√§hlt. und vieles mehr. <br><br>  Ich war zu faul, um diesen Code in den Zustand "Nehmen und Verwenden" zu bringen. Ich wollte nur die Idee zeigen.  Aber wer eine fertige Bibliothek braucht, der ist gerade auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek gesto√üen</a> .  Alles darin ist praktisch gleich, nur in Erinnerung gerufen.  Nun, die Oberfl√§che ist etwas anders. <br><br>  Ein Beispiel aus dem Artikel finden Sie <a href="">hier</a> . <br><br>  Vielen Dank, dass Sie diesen Artikel bis zum Ende gelesen haben.  Ich werde mich √ºber konstruktive Kritik freuen.  Es wird f√ºr mich auch interessant sein, die Nuancen in den Kommentaren zu diskutieren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459086/">https://habr.com/ru/post/de459086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459074/index.html">Kleine Freude # 7: Drei zum Preis von One-Console-Animation, Algorithmen und Debugging</a></li>
<li><a href="../de459078/index.html">CERN wechselt zu Open Source Software - warum?</a></li>
<li><a href="../de459080/index.html">Features HttpUrlConnection von java.net</a></li>
<li><a href="../de459082/index.html">Wer sind Eidetiker, wie falsche Erinnerungen funktionieren und drei popul√§re Mythen √ºber das Ged√§chtnis</a></li>
<li><a href="../de459084/index.html">Ein wenig √ºber Google Home Hub oder wie ich einen Fotorahmen f√ºr 130 Euro gekauft habe</a></li>
<li><a href="../de459088/index.html">Punktsegmentierungsmethoden in Punktwolken</a></li>
<li><a href="../de459090/index.html">Bringen Sie Ihre Linux-Entwicklungserfahrung in Windows mit WSL und Visual Studio Code Remote auf die n√§chste Stufe</a></li>
<li><a href="../de459092/index.html">X.Spectator - Status√ºberwachung in .NET</a></li>
<li><a href="../de459094/index.html">C # oder Java? TypeScript oder JavaScript? Auf maschinellem Lernen basierende Klassifizierung von Programmiersprachen</a></li>
<li><a href="../de459098/index.html">GitHub Package Registry unterst√ºtzt Swift-Pakete</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>