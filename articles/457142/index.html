<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👼🏼 🤛 🏬 RectTransformUtility, o cómo hacer un componente que anima los elementos de la interfaz de usuario detrás de la pantalla 🦕 🕖 🤕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En el último artículo: Variedades de coordenadas utilizadas en la GUI de Unity3d, traté de hablar brevemente sobre las variedades de coordenadas en Un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RectTransformUtility, o cómo hacer un componente que anima los elementos de la interfaz de usuario detrás de la pantalla</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457142/">  En el último artículo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Variedades de coordenadas utilizadas en la GUI de Unity3d,</a> traté de hablar brevemente sobre las variedades de coordenadas en Unity UI / RectTransform.  Ahora quiero resaltar algo tan útil para la interfaz de usuario como RectTransformUtility.  Cuál es una de las principales herramientas para calcular algo en la interfaz de usuario en relación con otra cosa. <br><br><h3>  Desafío simple </h3><br>  Hay una tarea: necesita un componente que elimine animadamente el elemento de la IU más allá del borde seleccionado de la pantalla.  El componente debe ser morado donde está ubicado jerárquicamente, en qué lugares están los anclajes, qué tamaño de pantalla y en qué lugar de la pantalla se encuentra.  El componente debe poder limpiar el objeto en 4 lados (arriba, abajo, izquierda, derecha) durante un tiempo determinado. <br><a name="habracut"></a><br>  <b>Reflexiones</b> <br><br>  En principio, ¿cómo se puede hacer esto?  Descubra el tamaño de la pantalla en las coordenadas del objeto, mueva el objeto a la coordenada más allá del borde de la pantalla, y parece que el asunto está en el sombrero.  Pero hay una pareja pero: <br><br>  <b>¿Cómo encontrar las coordenadas de la pantalla en relación con la interfaz de usuario?</b> <br><br>  Si busca en Google en la frente, busque en Google algunas cosas sin sentido o que no sean útiles, o incluso preguntas sin respuesta.  Lo más cercano que le conviene es cuando algún elemento de la IU sigue al cursor, que solo existe en las coordenadas de la pantalla. <br><br><pre><code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Input.mousePosition), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, out topRightLocalCoord);</code> </pre> <br>  Estos son RectTransformUtility y ScreenPointToLocalPointInRectangle directamente.  Aquí obtenemos las coordenadas locales dentro del rect (RectTransform), en función de la posición del punto en la pantalla. <br>  En el ejemplo actual, encontramos las coordenadas locales del cursor del mouse, necesitamos reemplazarlas con el borde de la pantalla: <br><br><pre> <code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Screen.width, Screen.height), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, out topRightLocalCoord);</code> </pre> <br>  Y así obtuvimos la coordenada del punto superior derecho de la pantalla para que el objeto salga de la pantalla a la derecha, nuestro objeto debería estar más lejos que este punto + digamos el ancho del rect o la sangría especificada. <br><br>  <b>Entonces, la primera advertencia</b> <br><br>  Obtuvimos coordenadas locales que son adecuadas para los objetos directamente dentro del lienzo, si el río a desplazar se encuentra en otro rectángulo, entonces sus coordenadas locales se considerarán en relación con el padre, no el lienzo.  Es decir, estas coordenadas en sí mismas no nos convienen. <br><br>  <b>Hay dos formas</b> , la primera es usar coordenadas globales, para eso son globales.  O calcule las coordenadas de la pantalla en las coordenadas locales de cada rect por separado. <br><br>  <b>Considere el primer caso</b> : cómo convertir coordenadas locales en globales. <br><br>  La mayoría de los métodos buscados en Google usan TransformPoint. <br><br><pre> <code class="java hljs">transform.position = myCanvas.transform.TransformPoint(pos);</code> </pre> <br>  Por lo tanto, convertimos coordenadas locales a globales. <br><br>  En mi opinión, este es generalmente un paso adicional, ya que RectTransformUtility tiene un método ScreenPointToWorldPointInRectangle que devuelve inmediatamente la posición global. <br><br>  Necesitamos mover el rect más allá del borde derecho de la pantalla, para esto tomamos la coordenada X desde la posición encontrada, y Y dejamos el rect que nos movemos para que simplemente se mueva hacia la derecha. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(topRightCoord.x+offset, rectTransform.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  La coordenada resultante es alimentada por DoTween. <br><br><pre> <code class="java hljs">rectTransform.DOMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(correctedTargetRight.x, rectTransform.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding);</code> </pre> <br>  Y hurra, el objeto sale a la derecha.  Pero ... <br><br>  <b>Segundo matiz</b> <br><br>  Aquí descubrimos que, de hecho, el posicionamiento del rect depende del pivote del rect. <br><br><img src="https://habrastorage.org/webt/bf/5p/6_/bf5p6_dcykozhdxi21bfc0y8lxi.png"><br><br>  Por lo tanto, el objeto puede bailar con el posicionamiento dependiendo del pivote, además el objeto puede ser muy grande y el desplazamiento no lo empujará completamente detrás de la pantalla, siempre habrá una posibilidad de que la pieza sobresalga. <br><br>  Es decir, necesitamos atornillar la compensación para compensar, lo que tendrá en cuenta el tamaño de rect + pivot. <br><br>  El segundo matiz es mover el objeto por el tamaño del rectángulo, necesita conocer las coordenadas locales o de anclaje, y obtenemos las coordenadas globales.  Debo decir de inmediato que las coordenadas globales no se pueden tomar y convertir en coordenadas locales de la interfaz de usuario o anclar. <br>  Se me ocurrió la siguiente muleta, recordamos la posición inicial del rectángulo, lo movemos a la posición global final, desplazamos la posición del ancla por el tamaño del rectángulo a la derecha, recordamos la posición global que tiene en cuenta el desplazamiento, teniendo en cuenta el tamaño del objeto, y lo alimentamos con un hueco, sin olvidar volver al original posición. <br><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de código</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetRight = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(topRightLocalCoord.x, rectTransform.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>); rectTransform.position = targetRight; rectTransform.anchoredPosition += rectTransform.sizeDelta; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> correctedTargetRight = rectTransform.position; rectTransform.localPosition = startPoint; rectTransform.DOMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(correctedTargetRight.x, rectTransform.position.y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding);</code> </pre> <br></div></div><br>  Parece una muleta gigante, pero esta muleta le permite sincronizar coordenadas globales y otras.  Esto ayuda cuando hay objetos en la interfaz que se mueven uno con respecto al otro, y están en diferentes jerarquías.  Bueno, además, hasta ahora, esta es la única forma en que he encontrado para obtener coordenadas rect de global. <br><br>  En este punto, diremos no a las muletas y volveremos a la idea de obtener el tamaño de la pantalla en coordenadas locales. <br><br><h3>  Segunda forma </h3><br>  La segunda forma es obtener los tamaños de pantalla para cada rect individualmente, por lo que conoceremos las coordenadas locales de los bordes de la pantalla, independientemente del lienzo o la jerarquía. <br><br>  <b>Tercer matiz</b> <br><br><pre> <code class="java hljs">RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Screen.width, Screen.height), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, out topRightCoord); RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, out bottomScreenCoord);</code> </pre> <br>  Los objetos se pueden ubicar en cualquier lugar de la pantalla, a diferencia del lienzo que cubre toda la pantalla.  Por lo tanto, las distancias a los bordes izquierdo y derecho de la pantalla pueden diferir significativamente.  En el caso del lienzo, habríamos tenido solo el borde superior derecho, y menos el superior derecho sería el superior izquierdo.  En este caso, debe obtener los puntos inferior izquierdo y superior derecho por separado, como se muestra en el ejemplo de código. <br><br>  <b>Cuarto matiz</b> <br><br>  La coordenada local es el desplazamiento relativo al centro del padre, cuando el rect está incrustado en otro rect, que ocupa una pequeña parte del lienzo, entonces necesitamos una coordenada que tenga en cuenta ambos desplazamientos, bueno, todo es simple. <br><br><pre> <code class="java hljs">((Vector3)bottomLeftCoord + rectTransform.localPosition)</code> </pre> <br>  agregue los vectores y obtenga la coordenada que necesitamos.  Resulta más confuso que con las coordenadas globales, pero ahora podemos realizar cualquier cálculo relacionado con el tamaño del rect.  Y finalmente, con calma, agregue una compensación sin muletas. <br><br><pre> <code class="java hljs"> (Vector3)topRightCoord + rectTransform.localPosition + (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3((rectTransform.sizeDelta.x * rectTransform.pivot.x) + rectTransform.sizeDelta.x, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br>  Así es como se ve la coordenada para desplazarse hacia la derecha con compensación por el ancho del rectángulo y desplazarse más allá de la pantalla al ancho del rectángulo, no hay forma de establecer el desplazamiento, planeo agregarlo un poco más tarde, pero creo que alguien estará interesado en intentar escribir esto yo mismo. <br><br><h2>  Conclusiones </h2><br><ol><li>  Para los elementos de la interfaz de usuario, es mejor usar coordenadas locales o de anclaje, y debe intentar comprenderlas.  Las coordenadas globales se pueden usar para casos especiales, pero no permiten trabajar convenientemente, por ejemplo, con el tamaño de los rectos y en muchos otros micro episodios. </li><li>  Debe mirar RectTransformUtility, tiene muchas funciones útiles para la interfaz de usuario, todos los cálculos relacionados con la posición de algo dentro y alrededor del rectángulo se realizan a través de él. </li></ol><br>  Bueno, el componente en sí, si alguien quiere jugar con él, se necesitará DoTween para esto: <br><br><div class="spoiler">  <b class="spoiler_title">Componente</b> <div class="spoiler_text"><pre> <code class="java hljs">using DG.Tweening; using UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { DEFAULT, RIGHT, LEFT, TOP, BOTTOM } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CanvasType {OVERLAY, CAMERATYPE} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HideBeyondScreenComponent</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Direction direction; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CanvasType canvasType; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> timeForHiding = <span class="hljs-number"><span class="hljs-number">1</span></span>; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 startPoint; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RectTransform rectTransform; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 topRightCoord; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 bottomLeftCoord; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ rectTransform = transform as RectTransform; startPoint = rectTransform.localPosition; Camera camera = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (canvasType == CanvasType.CAMERATYPE) camera = Camera.main; RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(Screen.width, Screen.height), camera, out topRightCoord); RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), camera, out bottomLeftCoord); Hide(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ rectTransform.DOLocalMove(startPoint, timeForHiding); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (direction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.LEFT: rectTransform.DOLocalMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(EndPosition(Direction.LEFT).x, rectTransform.localPosition.y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.RIGHT: rectTransform.DOLocalMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(EndPosition(Direction.RIGHT).x, rectTransform.localPosition.y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.TOP: rectTransform.DOLocalMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(rectTransform.localPosition.x, EndPosition(Direction.TOP).y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.BOTTOM: rectTransform.DOLocalMove(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(rectTransform.localPosition.x, EndPosition(Direction.BOTTOM).y, <span class="hljs-number"><span class="hljs-number">0</span></span>), timeForHiding); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NegativeCompensation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((-rectTransform.sizeDelta.x - offset) + rectTransform.sizeDelta.x * rectTransform.pivot.x, (-rectTransform.sizeDelta.y - offset) + rectTransform.sizeDelta.y * rectTransform.pivot.y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PositiveCompensation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2((rectTransform.sizeDelta.x * rectTransform.pivot.x) + offset, (rectTransform.sizeDelta.y * rectTransform.pivot.y) + offset); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Direction direction)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (direction) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.LEFT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Vector3)bottomLeftCoord + rectTransform.localPosition) + NegativeCompensation(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.RIGHT: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (Vector3)topRightCoord + rectTransform.localPosition + PositiveCompensation(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.TOP: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Vector3)topRightCoord + rectTransform.localPosition) + PositiveCompensation(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Direction.BOTTOM: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Vector3)bottomLeftCoord + rectTransform.localPosition) + NegativeCompensation(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> startPoint; } }</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/457142/">https://habr.com/ru/post/457142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../457132/index.html">Sustitución de importaciones en la práctica. Parte 3.1. "QP OS". La primera revisión de este tipo del sistema operativo</a></li>
<li><a href="../457134/index.html">El cerebro acelera la percepción, adivinando lo que sucederá después</a></li>
<li><a href="../457136/index.html">Factores clave de una habilitación exitosa del equipo</a></li>
<li><a href="../457138/index.html">Friday Post: Preguntas que aman las chicas</a></li>
<li><a href="../457140/index.html">Como descubrí accidentalmente una posible reposición interminable de una cuenta con mi operador móvil estadounidense</a></li>
<li><a href="../457144/index.html">Escribimos un emulador que nadie necesita</a></li>
<li><a href="../457150/index.html">Nuevo terminal de Windows ahora disponible en Microsoft Store</a></li>
<li><a href="../457152/index.html">Conferencia DEFCON 25. Garry Kasparov. "La última batalla del cerebro". Parte 1</a></li>
<li><a href="../457154/index.html">Diseño de aplicación receptiva para cada usuario</a></li>
<li><a href="../457156/index.html">¿Cuáles pueden ser los sistemas informáticos del futuro?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>