<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüé§ üöµüèΩ üå¥ Tetris como uma impressora üì≤ üöà üë∂üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Girando, reorganizando e abaixando uma sequ√™ncia predeterminada de formas, o Tetris Printer Algorithm usa a mec√¢nica do Tetris para gerar bitmaps arbi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tetris como uma impressora</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474848/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/az/2c/saaz2chpnuatbjn-rdg3zcryjwo.png"></div><br>  Girando, reorganizando e abaixando uma sequ√™ncia predeterminada de formas, o Tetris Printer Algorithm usa a mec√¢nica do Tetris para gerar bitmaps arbitr√°rios. <br><br><h2>  Descri√ß√£o do algoritmo </h2><br>  O algoritmo converte os pixels da imagem de origem nos quadrados do campo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tetris</a> linha por linha, movendo-se de baixo para cima.  Para gerar um √∫nico quadrado, o algoritmo monta uma estrutura que consiste em uma √°rea retangular que √© completamente suportada por um quadrado abaixo dele.  Ap√≥s a montagem da regi√£o retangular, suas linhas s√£o limpas, deixando um quadrado embaixo dela.  Aqui est√£o tr√™s exemplos desse comportamento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/c80/be8/895c80be864793bcd951c4edb6943f19.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c6/cdf/615/3c6cdf6159a7bbb9dd2dc95e87374055.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/104/674/951/104674951b666a97f36c4d069006df5d.gif"></div><br>  Como mostrado abaixo, o algoritmo tamb√©m pode gerar v√°rios quadrados com uma estrutura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caa/aef/04b/caaaef04b763c02d872079282d3b57d5.gif"></div><br>  No processo de constru√ß√£o de uma linha, todos os quadrados criados dessa maneira devem se basear em algo.  Nas imagens mostradas acima, os quadrados gerados est√£o no ch√£o do campo de jogo.  No entanto, se uma linha arbitr√°ria contiver furos, ela n√£o poder√° fornecer o suporte necess√°rio para construir uma linha acima dela.  O algoritmo resolve esse problema criando uma plataforma plana no topo da string com furos.  Na anima√ß√£o abaixo, uma plataforma constru√≠da em cima de uma linha consiste em um quadrado vermelho.  Uma plataforma √© uma estrutura tempor√°ria e a inser√ß√£o da √∫ltima forma a remove. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acf/f14/c6d/acff14c6d078f15cc01523e4c24389cb.gif"></div><br>  A linha de 5 quadrados vermelhos mostrada abaixo est√° no topo da linha de 3 quadrados vermelhos.  Isso √© realizado atrav√©s da constru√ß√£o de uma plataforma plana no topo da linha de fundo.  A plataforma fornece o suporte necess√°rio para gerar 5 quadrados vermelhos.  No final, a plataforma √© exclu√≠da inserindo a √∫ltima forma e a nova linha se encaixa.  Observe que, se o algoritmo precisar gerar linhas na ordem inversa (uma linha de 3 quadrados vermelhos acima de uma linha de 5 quadrados vermelhos), a plataforma n√£o ser√° necess√°ria. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/0ad/35c/8510ad35cdbf5639b06b5f17957eec79.gif"></div><br><h2>  Padr√µes de um quadrado </h2><br>  Para refer√™ncia, darei os nomes de 7 tetramino (pe√ßas do jogo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/817/4aa/cef8174aa74b378cb17af2fe0c6f1c7b.png"></div><br>  A vers√£o do algoritmo de impressora Tetris apresentada no artigo foi projetada especificamente para renderizar sprites de videogames antigos.  Esses jogos inclu√≠am gr√°ficos em blocos 8 √ó 8 e 2 bytes foram alocados para cada pixel.  Portanto, os sprites geralmente continham apenas 3 cores mais √°reas transparentes e, na maioria das vezes, tinham um tamanho de 16 √ó 16 ou 16 √ó 32 pixels. <br><br>  A anima√ß√£o abaixo mostra todos os padr√µes usados ‚Äã‚Äãpara criar quadrados individuais.  Cada padr√£o usa o tetramino intercambi√°vel J, T e L, criando um √∫nico quadrado na parte inferior.  O algoritmo atribui esse tetramino a uma das tr√™s cores presentes no sprite.  O restante do tetramino recebe cores arbitr√°rias.  Durante a jogabilidade, todas as cores permanecem constantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/b1f/efc/dfab1fefc65efed365513213cdf5ad12.gif"></div><br>  Devido √† forma dos tr√™s tetraminos, √© imposs√≠vel criar um quadrado a partir das tr√™s cores nas duas primeiras e nas duas √∫ltimas colunas.  Portanto, a largura m√≠nima do campo de jogo para renderizar um sprite com uma largura de 16 pixels √© 2 + 16 + 2 = 20 quadrados.  No entanto, descobriu-se que 20 √© muito pouco. <br><br>  Como mostrado abaixo, a √°rea acima do quadrado inferior √∫nico n√£o pode consistir em apenas uma linha, porque as √∫nicas figuras que podem caber nele (tetramino I) n√£o t√™m suporte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/1e5/645/87f1e56455f90295b076e72296cc58c1.gif"></div><br>  Com duas linhas, a √∫nica maneira de ampliar todo o campo de jogo para que ele tenha suporte √© usar o tetramino S e Z. Mas, neste caso, os furos permanecer√£o na linha superior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58c/ea6/8ef/58cea68ef0e7d83c102402e9ed0255fb.gif"></div><br>  O n√∫mero m√≠nimo de linhas necess√°rias acima do quadrado inferior √© 3 e, como mostrado v√°rias vezes acima, esses padr√µes existem.  20 quadrados √© a largura m√≠nima necess√°ria para colocar um sprite com uma largura de 16 pixels.  Mas 20 √ó 3 + 1 = 61, e esse n√∫mero n√£o √© divis√≠vel por 4, o que significa que n√£o pode ser constru√≠do a partir do tetramino.  No entanto, uma largura de 21 nos d√° 21 √ó 3 + 1 = 64, e pode ser constru√≠da a partir de 16 tetramino.  De fato, essa largura permite ao algoritmo renderizar sprites com at√© 17 pixels de largura. <br><br>  O campo de jogo do Tetris original tem um tamanho de 10 √ó 20 quadrados (propor√ß√£o 1: 2).  Nesta vers√£o do algoritmo, essa propor√ß√£o √© preservada - o campo de jogo tem um tamanho de 21 √ó 42 quadrados. <br><br>  Como o tetramino J, T e L s√£o intercambi√°veis ‚Äã‚Äãao criar um quadrado, e 3 quadrados desses tetraminos est√£o envolvidos na cria√ß√£o de uma linha acima dele, existem 21 - 3 = 18 padr√µes para criar um √∫nico quadrado.  No entanto, devido √† simetria espelhada, existem apenas 9. Existem tr√™s linhas que funcionam para a maioria delas 9. No entanto, um estudo aprofundado em computador mostrou que os dois padr√µes precisavam de mais.  A pr√≥xima op√ß√£o poss√≠vel √© 7 linhas, porque 21 √ó 7 + 1 = 148, o que requer 37 tetraminos.  Como mostrado nas imagens abaixo, esses padr√µes existem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/643/2ca/7a26432ca3f6e11d43f134057f3bfa73.gif"></div><br><h2>  V√°rios padr√µes quadrados </h2><br>  Os padr√µes para criar v√°rios quadrados s√£o limitados √†s mesmas tr√™s cores criadas pelos padr√µes de um √∫nico quadrado.  Os quadrados resultantes s√£o criados a partir do tetramino J, T e L, cada um dos quais ocupa 3 quadrados em uma linha acima da linha de cria√ß√£o.  O n√∫mero m√°ximo de quadrados que podem ser potencialmente criados com um √∫nico padr√£o √© 21/3 = 7. No entanto, para sprites com uma largura de 16 pixels, o tetramino mais √† direita n√£o pode criar um quadrado.  Mesmo no caso de sprites com uma largura de 17 pixels, ele pode criar um quadrado de apenas uma cor.  Portanto, o padr√£o de cria√ß√£o de 7 quadrados raramente √© usado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/9cc/957/e019cc9577348937886f2f160fd8ad1b.gif"></div><br>  O n√∫mero de padr√µes para criar um n√∫mero arbitr√°rio de quadrados pode ser determinado usando a combina√ß√£o de enumera√ß√µes.  Considere o padr√£o abaixo, representando uma linha acima de uma linha de tr√™s quadrados.  Cada bloco de tr√™s quadrados brancos adjacentes designa uma parte do tetramino;  quadrados criados n√£o s√£o mostrados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/b6d/fe5/cefb6dfe5d0c9c3b644189dc13901e63.gif"></div><br>  Tr√™s tetraminos criam 4 espa√ßos vazios.  Existem 21 - 3 √ó 3 = 12 quadrados escuros que podem ser arbitrariamente inseridos nesses espa√ßos vazios para formar um padr√£o espec√≠fico.  O n√∫mero de maneiras de distribuir esses quadrados escuros pode ser calculado colocando-os em uma linha na qual quadrados brancos √∫nicos s√£o tratados como divisores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/160/0fb/3731600fb90642ff32fa58ee059cf4c3.gif"></div><br>  Portanto, a tarefa foi reduzida ao c√°lculo do valor do coeficiente do polin√¥mio.  Observando esses quadrados em branco, voc√™ pode entender que essa √© uma quest√£o de v√°rias maneiras de escolher 3 de 15. <img src="https://habrastorage.org/getpro/habr/post_images/5d4/344/bdb/5d4344bdb66112361fa655447baff0a3.png">  = 455 <br><br>  No caso geral, para <i>n</i> √© igual a <img src="https://habrastorage.org/getpro/habr/post_images/f0d/252/47d/f0d25247d7defed1af6417ed76660ba6.png">  .  Mas, devido √† simetria espelhada, de fato, s√£o metade disso;  se a quantidade for √≠mpar, dividindo por dois, arredondamos para o n√∫mero inteiro mais pr√≥ximo para incluir nele um padr√£o perfeitamente sim√©trico que deveria existir nesse conjunto, como, por exemplo, mostrado abaixo para o caso 455. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/093/98d/5e609398dfe585680459774fc3b96cdc.gif"></div><br>  Aplicando esta f√≥rmula ao 7 tetramino, confirmamos o √≥bvio: existe apenas um padr√£o para criar 7 quadrados. <br><br>  O padr√£o de cria√ß√£o de 6 quadrados pode ser constru√≠do de duas maneiras: duas linhas preenchidas (2 √ó 21 + 6 = 48) e seis linhas preenchidas (6 √ó 21 + 6 = 132), o que requer 12 e 33 tetramino.  A f√≥rmula acima mostra que existem 84 padr√µes para a cria√ß√£o de 6 quadrados, mas apenas 35 deles podem ser constru√≠dos a partir de 2 linhas completas.  49 padr√µes requerem 6 linhas.  Os n√∫meros s√£o √≠mpares devido aos padr√µes sim√©tricos mostrados abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c07/fe9/a24/c07fe9a243e3cdfe37103d4f16d01024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/8c5/91b/8a98c591b95b4fc8a533e67adead58ad.gif"></div><br>  Tamb√©m √© importante notar que duas linhas s√£o poss√≠veis aqui, porque, ao contr√°rio do padr√£o de cria√ß√£o de um quadrado que exigia o tetramino S e Z, 6 figuras s√£o usadas nesses padr√µes. <br><br>  A tabela abaixo mostra o n√∫mero de quadrados criados por cada tipo de padr√£o, o n√∫mero de linhas completas, o n√∫mero de tetramino usado e o n√∫mero de padr√µes. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Quadrados Criados </th><th>  Linhas completas </th><th>  Tetramino </th><th>  Padr√µes </th></tr><tr><td>  1 </td><td>  7 e 3 </td><td>  37 e 16 </td><td>  19 (4 e 15) </td></tr><tr><td>  2 </td><td>  6 </td><td>  32. </td><td>  136 </td></tr><tr><td>  3 </td><td>  5 </td><td>  27 </td><td>  455 </td></tr><tr><td>  4 </td><td>  4 </td><td>  22 </td><td>  715 </td></tr><tr><td>  5 </td><td>  3 </td><td>  17 </td><td>  462 </td></tr><tr><td>  6 </td><td>  2 e 6 </td><td>  12 e 33 </td><td>  84 (35 e 49) </td></tr><tr><td>  7 </td><td>  1 </td><td>  7 </td><td>  1 </td></tr></tbody></table></div><br>  Exemplos de padr√µes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/9dc/055/5699dc0558af1a833b43b57defdefbf7.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/b83/682/1d1b83682d599094bcb138958706b8bf.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/510/bbb/efd510bbb099696e35b7e0b9156f35d4.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/079/bd5/d7a/079bd5d7a149568bda463270a5b3baaf.gif"></div><br><h2>  Plataformas </h2><br>  Antes de construir uma linha, o algoritmo examina a linha abaixo dela.  Se a linha inferior n√£o puder fornecer suporte para todos os quadrados acima dela, ser√° necess√°ria uma plataforma tempor√°ria.  Quando a plataforma √© removida, uma nova linha cai e, devido √† maneira como a gravidade √© implementada no Tetris original, alguns quadrados permanecem pairando no ar. <br><br>  A ilustra√ß√£o abaixo mostra 10 padr√µes de plataforma.  A constru√ß√£o da plataforma come√ßa baixando o tetramino T em cima de um dos quadrados da √∫ltima linha gerada.  Os tetraminos restantes dependem desse primeiro T. Ou seja, se a linha gerada anterior contiver pelo menos 1 quadrado, como o quadrado vermelho na imagem abaixo, podemos criar uma plataforma plana acima dela para gerar a pr√≥xima linha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/299/e1d/5b0299e1d7f2916a802a49ea11c4eb16.gif"></div><br>  No meio da constru√ß√£o da plataforma, a linha inferior √© conclu√≠da e exclu√≠da, deixando tr√™s linhas acima dela.  O √∫ltimo tetramino J ou L, que excluir√° essas linhas, n√£o ser√° inserido at√© que os padr√µes de cria√ß√£o gerem a pr√≥xima linha de sprite na parte superior da plataforma.  Esta √∫ltima figura impede a cria√ß√£o de quadrados na primeira e na √∫ltima duas linhas.  Mas, como mencionado acima, devido √† geometria dos tetraminos J, T e L usados ‚Äã‚Äãnesse processo, os padr√µes para a cria√ß√£o de quadrados s√£o limitados a 17 colunas internas. <br><br>  Al√©m disso, das 19 maneiras poss√≠veis de construir plataformas sobre o Tetramino T, apenas 10 s√£o mostradas acima. <br><br><h2>  Matrizes embaladas </h2><br>  Como mencionado acima, um subconjunto dos 6 padr√µes de cria√ß√£o de quadrados envolve a limpeza de apenas duas linhas.  Todos os outros padr√µes requerem 6 linhas.  Para entender por que esse √© o caso, considere o padr√£o abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/9bf/3aa/3709bf3aa8fd860b3dbcc04014dfef8b.gif"></div><br>  Esses tetraminos s√£o intercambi√°veis ‚Äã‚Äãcom os tetraminos J e L, e cada um deles adiciona 3 quadrados adjacentes √† linha comum.  As linhas a serem preenchidas s√£o representadas pela matriz mostrada abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ed/532/67a/3ed53267a1b216691289f68439470301.gif"></div><br>  Agora tudo est√° empacotando espa√ßo vazio com tetramino.  Come√ßando √† esquerda, a √∫nica op√ß√£o √© usar a sequ√™ncia tetramino I. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/b54/9f5/779b549f51bef09e54217790f2110eb5.gif"></div><br>  A √∫nica maneira de preencher o espa√ßo restante √© usar J e O ou I e L. Ambas as op√ß√µes s√£o mostradas abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/08e/33a/de808e33aa8f69d807c60b798e8ed0c1.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/a24/be8/aeca24be817f0cc88dc0ef3175ada63c.gif"></div><br>  Infelizmente, o tetramino O e L n√£o s√£o suportados nas matrizes mostradas acima.  Esse padr√£o de 6 quadrados requer uma matriz maior. <br><br>  Um problema semelhante surge em dois padr√µes de cria√ß√£o de um quadrado.  Considere a matriz abaixo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fba/ec4/6ad/fbaec46ad778d94b5844c22d35ebc4ed.gif"></div><br>  A √∫nica maneira de preencher a linha inferior √† direita √© encadear a sequ√™ncia Z. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/3e1/5b2/5e83e15b210424010966f17b2ee1b72c.gif"></div><br>  Da mesma forma, a √∫nica maneira de obter 3 quadrados vazios no canto inferior esquerdo √© tetramino S. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/297/9ae/b51/2979aeb51a67c1c0a51c7e5105890744.gif"></div><br>  Na linha do meio, existe um quadrado vazio entre S e Z e a √∫nica maneira de preench√™-lo √© usar o tetramino J, T ou L, como mostrado nas figuras abaixo. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a0/364/433/2a036443351a7c1ec90fe0d534c38049.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/f88/7e8/8f3f887e84bcdbd7176b530af8757666.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3c/dc1/a0a/e3cdc1a0a243388524f4e5ffb8ac13d8.gif"></div><br>  Inserir qualquer uma dessas formas divide o espa√ßo em branco.  A √°rea vazia √† esquerda cont√©m 5, 6 e 7 espa√ßos vazios, respectivamente.  Como nenhum desses valores √© divis√≠vel por 4, √© imposs√≠vel continuar.  Uma matriz maior √© necess√°ria para esse padr√£o quadrado √∫nico. <br><br>  O mesmo se aplica a outro padr√£o para criar um quadrado, mostrado na matriz abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd3/c11/c6c/fd3c11c6ce8d7e4b60a257486caef4e2.gif"></div><br>  Depois de usar o tetramino S e Z para preencher a maior parte da linha inferior, h√° um espa√ßo vazio entre eles na linha do meio. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/e39/49c/3a6e3949c8f9f0849921a11ccf54596a.gif"></div><br>  Como mostrado nas imagens abaixo, a inser√ß√£o do furo divide o espa√ßo vazio e a √°rea vazia √† esquerda cont√©m 9, 10 ou 11 quadrados, respectivamente;  nenhum dos n√∫meros √© divis√≠vel por 4. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15d/d8b/9b2/15dd8b9b24d8054598665cbff061344e.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d6/928/f4d/6d6928f4d884b746af74059ec210b96d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c5/269/800/0c5269800d3ebdcb62e1131c03e32db0.gif"></div><br>  Mas as matrizes de empacotamento n√£o s√£o a √∫nica maneira de gerar um padr√£o de quadrados.  Por exemplo, d√™ uma olhada no criador de 4 quadrados abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fc/22b/653/4fc22b6538117dca3baff88c595337e4.gif"></div><br>  A seguir, √© apresentada uma tentativa de renderizar o padr√£o como um conjunto de tetraminos empacotados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f5/53f/bfc/3f553fbfc96ecfbbef8f7304c80a80fe.gif"></div><br>  O √∫ltimo L √© ignorado, porque o espa√ßo para ele √© formado somente ap√≥s a conclus√£o e remo√ß√£o da terceira linha. <br><br>  Mas, ap√≥s uma pesquisa minuciosa, descobriu-se que essa t√©cnica n√£o fornece os padr√µes de um quadrado acima mencionados com a capacidade de trabalhar com apenas tr√™s linhas.  Al√©m disso, ele n√£o permite implementar novos padr√µes de 6 quadrados em duas linhas.  N√£o h√° necessidade de procurar os padr√µes restantes fora das matrizes compactadas, porque eles j√° usam a menor quantidade poss√≠vel de tetramino.  E nos limitando a matrizes compactadas, encontraremos todos os padr√µes necess√°rios muito mais rapidamente. <br><br><h2>  Pesquisa de padr√µes </h2><br>  Para simplificar a sa√≠da de dados, o Tetris Printer Algorithm limita-se a criar o tetramino no ponto central superior do campo de jogo, girando-o, movendo-se horizontalmente e abaixando-o.  Ele nunca precisa mover a figura horizontalmente depois de passar alguma dist√¢ncia.  Essa restri√ß√£o reduz bastante o espa√ßo de busca, pois n√£o permite a forma√ß√£o de lacunas nas figuras adicionadas √† matriz.  Como exemplo, vejamos a seguinte matriz de 3 quadrados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/466/4d1/250/4664d1250708c9d9daeb800eb2ac7f47.gif"></div><br>  Se jogarmos J no centro da matriz, como mostrado acima, obteremos um espa√ßo de 2 quadrados vazios, que n√£o podem ser preenchidos com figuras subsequentes.  Portanto, a pesquisa n√£o seguir√° esse caminho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/934/866/56293486665cf1557d513f63fa700622.gif"></div><br>  Como as lacunas cobertas n√£o s√£o permitidas, cada coluna na matriz pode ser considerada como uma pilha de quadrados preenchidos e a altura dessas pilhas descreve completamente o conte√∫do de toda a matriz.  Independentemente do n√∫mero de linhas, uma matriz inteira unidimensional com 21 elementos ser√° suficiente para descrever uma matriz bidimensional. <br><br>  Quando uma figura cai na matriz, as alturas das pilhas das colunas correspondentes aumentam.  Para acelerar esse processo, todos os tetraminos s√£o analisados ‚Äã‚Äãpreviamente.  Existem 19 turnos tetraminos, e a pesquisa considera cada um deles como uma figura √∫nica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/d13/9e0/40ed139e0a5612cac1f5d074a0093d96.png"></div><br>  O Tetramino J no canto superior esquerdo da imagem ocupa 3 colunas.  Ao abaixar na matriz, as alturas de 3 pilhas adjacentes aumentam em 1, 1 e 2 quadrados, respectivamente.  Por√©m, antes que a figura possa ser baixada, o perfil inferior da figura deve corresponder ao perfil superior das respectivas pilhas.  Se este J estivesse no ch√£o do campo de jogo, em cada uma dessas colunas deveria haver intervalos de 1, 1 e 0 quadrados vazios.  Como as folgas s√£o proibidas, as alturas relativas de 3 pilhas ter√£o que corresponder totalmente ao padr√£o. <br><br>  Outra consequ√™ncia da falta de lacunas foi que, quando os n√∫meros caem na matriz, as linhas s√£o preenchidas de baixo para cima.  N√£o √© poss√≠vel preencher uma linha no meio de uma matriz antes ou simultaneamente n√£o concluir todas as linhas abaixo dela.  No processo de preenchimento da matriz, seu limite inferior realmente se move para cima.  Consequentemente, uma pilha de colunas da matriz pode fornecer suporte apenas se sua altura menos o n√∫mero de linhas conclu√≠das for maior que 0. Quando uma forma √© adicionada √† matriz, pelo menos uma das colunas correspondentes deve fornecer suporte. <br><br>  A pesquisa armazena uma segunda matriz unidimensional que cont√©m o n√∫mero de quadrados preenchidos em cada linha.  O J acima cont√©m nas linhas correspondentes 3 e 1 um quadrado.  Quando voc√™ o insere na matriz, esses valores s√£o adicionados aos elementos correspondentes da matriz.  O n√∫mero de linhas conclu√≠das √© o n√∫mero de elementos com um valor 21. <br><br>  Conforme indicado na se√ß√£o anterior, se a figura adicionada dividir a matriz, os tamanhos das √°reas resultantes dever√£o ser divididos por 4. Por exemplo, na imagem abaixo, a adi√ß√£o de I cria 2 √°reas, cada uma contendo 46 quadrados vazios.  Como 46 n√£o √© divis√≠vel por 4, n√£o h√° mais como preencher o restante da matriz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/c1e/91a/c0dc1e91a707d5b2fea279dd5c370ec4.gif"></div><br>  A separa√ß√£o aparece quando a altura da pilha √© igual √† altura da matriz.  Ap√≥s inserir a figura incrementando as alturas das respectivas pilhas, as dimens√µes de todas as √°reas divididas de espa√ßo vazio podem ser determinadas digitalizando a matriz de alturas e somando o espa√ßo restante em cada pilha.  Este n√∫mero √© verificado e redefinido quando uma divis√£o √© detectada. <br><br>  A pesquisa usada para gerar todos os padr√µes usa constru√ß√£o incremental aleat√≥ria, um algoritmo de retorno que verifica sistematicamente todas as combina√ß√µes em ordem aleat√≥ria.  A constru√ß√£o incremental de uma solu√ß√£o inserindo formas aleatoriamente faz com que ela cres√ßa como um cristal.  A aleatoriedade fornece uma irregularidade contendo faces quebradas que servem como base para as formas adicionadas subsequentes.  A maior parte da matriz √© empacotada aleatoriamente muito rapidamente e, quando o espa√ßo vazio se torna escasso, o retrocesso entra em a√ß√£o. <br><br>  Antes de realizar a pesquisa, s√£o executadas permuta√ß√µes aleat√≥rias de 371 maneiras de adicionar uma figura √† matriz.  O pseudo-c√≥digo da fun√ß√£o de pesquisa √© mostrado abaixo. <br><br><pre><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'pt', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix matrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remaining)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION } attempts := attempts + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attempts &gt;= MAX_ATTEMPTS) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (     S  Z) {        S  Z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (  ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } }          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(   ,    ) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (   ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NO_SOLUTION }</code> </pre> <br>  A matriz original transmitida para a fun√ß√£o de pesquisa est√° vazia, exceto a linha inferior que cont√©m blocos de 3 quadrados adjacentes.  √â transmitido junto com o n√∫mero de figuras restantes que precisam ser adicionadas.  Se o <code>remaining</code> for 0, a matriz cont√©m a solu√ß√£o e a fun√ß√£o retorna.  Cada chamada recursiva aumenta o n√∫mero global de <code>attempts</code> .  Se exceder <code>MAX_ATTEMPTS</code> , que tem um valor de 1000, a pesquisa ser√° iniciada novamente. <br><br>  A terceira <code>if</code> tenta adicionar o tetramino S ou Z √† parte inferior da matriz, se o espa√ßo permitir.  O significado disso √© evitar situa√ß√µes como a mostrada abaixo, quando o algoritmo gasta tempo preenchendo parte da matriz, n√£o podendo preencher o restante devido √† falta de suporte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/3f9/b81/36d3f9b81275718dccb5d40e70d7843b.gif"></div><br>  Gra√ßas √† <code>if</code> ele rapidamente forma uma plataforma na qual construir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/aa1/ed7/1d0aa1ed7c08ed07b3f31e22ab92ea42.gif"></div><br>  Para tentar adicionar uma figura √† matriz, as verifica√ß√µes acima s√£o necess√°rias.  O algoritmo verifica se a figura ter√° suporte, dadas as linhas conclu√≠das.  Ele tamb√©m verifica se divide por 4 o tamanho de cada espa√ßo vazio individual criado pela inser√ß√£o da forma. <br><br><h2>  Convers√£o de imagem </h2><br>  O algoritmo da impressora Tetris converte cada linha do bitmap em uma s√©rie de passes.  Movendo-se da esquerda para a direita, cada passagem de maneira "gananciosa" insere o tetramino J, T e L no local onde est√£o colocados.  Por exemplo, a imagem abaixo mostra uma linha de 16 pixels de um bitmap. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/4c5/b69/9c14c5b69ae9a4599ee0856a250256a8.gif"></div><br>  A imagem abaixo mostra as 5 passagens necess√°rias para cobrir esses 16 pixels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/f7d/760/989f7d76010dd0d7e523361148e0e323.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/920/25a/4c492025a6033a3eda85fd240118b657.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/44f/373/0f144f3734988b25dd231a1a445c52fd.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c1/e37/392/6c1e373927f4842ad379ff2b6c42b123.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/64b/222/a9a64b222baaf24ed13674bdac9b8d01.gif"></div><br>  A sequ√™ncia de formas que o algoritmo est√° tentando inserir √© determinada pelas cores dos pixels.  Para que as formas n√£o se sobreponham, √© usada uma matriz unidimensional de valores booleanos.  Para inserir uma figura, 3 elementos zero devem estar presentes na matriz.  Ap√≥s a inser√ß√£o bem-sucedida da figura 3, os elementos correspondentes da matriz assumem o valor 1. <br><br>  Para rastrear pixels completos entre v√°rias passagens, √© usada uma segunda matriz unidimensional de valores booleanos.  Quando cada item √© 1, a linha est√° completa. <br><br>  No final de cada passagem, o conversor de imagens pesquisa todos os padr√µes na tabela para criar um ou mais quadrados.  Na sa√≠da, ele passa o padr√£o correspondente com o tetramino J, T e L. inserido na parte inferior.Por exemplo, a primeira passagem mostrada acima √© exibida como o seguinte padr√£o para criar 5 quadrados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/b1b/377/c67b1b3778a37bf7008438052679942e.gif"></div><br><h2>  Pesquisa em tempo real </h2><br>  O conversor de imagem descrito na se√ß√£o anterior √© extremamente r√°pido, pois utiliza uma tabela constante contendo todos os padr√µes para a cria√ß√£o de quadrados e n√£o os pesquisa em tempo real.  No entanto, a pesquisa em tempo real pode usar padr√µes que n√£o est√£o na tabela e, portanto, reduzir bastante a quantidade de tetramino necess√°ria para gerar a imagem.  Ele usa os quadrados criados em passagens anteriores, usando-os como suportes adicionais.  Por exemplo, como mencionado acima, o padr√£o a seguir para criar um quadrado requer 7 linhas completas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br>  Mas um quadrado vermelho criado na passagem anterior no canto inferior esquerdo da imagem abaixo fornece suporte adicional, reduzindo o n√∫mero de linhas preenchidas para 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/d3e/271/dfad3e271c5623daedc462821b82b8af.gif"></div><br>  Al√©m disso, uma pesquisa em tempo real pode cobrir 3 pixels adjacentes da mesma cor, girando o tetramino J, T ou L. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/e09/776/a31e097766437cb13ebde1e35ee66453.gif"></div><br>  De fato, ele pode combinar tetramino invertido e invertido, cobrindo um grande n√∫mero de pixels em uma passagem.  Por exemplo, as 5 passagens acima necess√°rias para cobrir 16 pixels podem ser reduzidas √† passagem √∫nica mostrada abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/653/c31/64c653c31d38daeef85189e3b2eacaa8.gif"></div><br>  Para obter esse padr√£o, o conversor de imagem come√ßa empacotando avidamente os tetraminos J, T e L. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/e98/67e/e7ae9867e1419492f6f19f6816d18f04.gif"></div><br>  Em seguida, ele tenta ansiosamente adicionar as vers√µes n√£o-giradas e, nesse caso, ele consegue adicionar outro J. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/4f3/1d4/ba24f31d49baa855fc449c3cf98f09ca.gif"></div><br>  Em princ√≠pio, uma tabela de pesquisa pr√©-calculada tamb√©m pode ser usada nesse processo, mas o tamanho de uma tabela torna-a inaplic√°vel na pr√°tica. <br><br>  Neste exemplo, 8 quadrados em uma linha acima da linha a ser criada s√£o adicionados √† linha inferior da matriz vazia.  Para <i>n</i> quadrados em um campo de jogo de 21 quadrados, a altura da matriz <i>h</i> √© o menor n√∫mero inteiro positivo, de modo que <i>21h - n</i> √© divis√≠vel por 4. Nesse caso, √© necess√°ria uma matriz de altura 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/c2e/d2b/b2ac2ed2bc3a422d0d94fff2b10bf9e0.gif"></div><br>  A pesquisa em tempo real funciona exatamente da mesma maneira que o algoritmo de pesquisa descrito acima, mas possui pequenas melhorias.  Como antes, a pilha da coluna da matriz fornece suporte apenas se a altura da coluna menos o n√∫mero de linhas conclu√≠das for maior que zero.  Quando a diferen√ßa √© zero, a pilha da coluna n√£o deve fornecer suporte.  No entanto, nesta vers√£o, se for igual a zero, verifica os quadrados na linha criada gerada pelos passes anteriores.  Ou seja, quaisquer quadrados na linha abaixo da linha inferior da matriz fornecem suporte para colunas vazias. <br><br>  Al√©m disso, como a pesquisa √© realizada em tempo real, ser√° impratic√°vel torn√°-la exaustiva.  Se ele n√£o encontrou uma solu√ß√£o ap√≥s um determinado n√∫mero de tentativas, ele adiciona mais 4 linhas na parte superior da matriz e tenta novamente.  Depois disso, se ele ainda n√£o conseguiu encontrar uma solu√ß√£o ap√≥s um determinado n√∫mero de tentativas, na passagem atual ele volta ao m√©todo com tabelas de pesquisa pr√©-calculadas e convers√£o de imagens descritas na se√ß√£o anterior do artigo. <br><br><h2>  Impress√£o </h2><br>  Para imprimir, voc√™ deve seguir as instru√ß√µes exibidas pelo conversor de imagens no campo de reprodu√ß√£o Tetris.  A impressora cria um tetramino espec√≠fico no ponto central superior do campo de jogo em uma orienta√ß√£o padr√£o.  Em seguida, a impressora gira, move horizontalmente e abaixa.  Este processo √© mostrado no v√≠deo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PJkHwulsac4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  C√≥digo fonte </h2><br>  O c√≥digo fonte do projeto Java 7 est√° dispon√≠vel <a href="">aqui</a> . <br><br>  Os algoritmos de pesquisa para tabelas pr√©-preparadas e em tempo real est√£o nos pacotes <code>search.precomputed</code> e <code>search.realtime</code> .  Eles usam algumas classes comuns localizadas no pacote de <code>search</code> .  Os resultados de uma pesquisa pr√©-calculada s√£o armazenados no pacote de <code>patterns</code> como uma sequ√™ncia de arquivos de texto.  Os arquivos de texto armazenam matrizes compactadas como caracteres ASCII, come√ßando com <code>A</code>  Por exemplo, as 3 primeiras matrizes em <code>emitters1.txt</code> (o conjunto de padr√µes para criar um quadrado) s√£o assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/yo/mo/lvyomov6ld5rle3bqj1jnjegic4.png"></div><br>  Como indicado repetidamente no artigo, tr√™s s√≠mbolos <code>A</code> adjacentes nas matrizes acima podem ser substitu√≠dos pelos tetramino J, T ou L. Os s√≠mbolos <code>B</code> , <code>C</code> , <code>D</code> e assim por diante representam a sequ√™ncia de tetramino que voc√™ precisa criar. <br><br>  A classe <code>imageconverter.ImageConverter</code> cont√©m o m√©todo <code>main</code> , que recebe um √∫nico argumento de linha de comando: o nome do arquivo de imagem sprite.  Uma imagem n√£o pode ter mais que 17 √ó 32 pixels e n√£o pode conter mais de 3 cores opacas.  Todos os outros pixels devem ser transparentes. <br><br>  Curiosamente, em videogames antigos, os desenvolvedores costumavam usar o plano de fundo para obter cores extras.  Por exemplo, os alunos e a boca da bolha do Bubble bobble, os alunos do Donkey Kong do Donkey Kong e a sobrancelha com a toupeira da Srta.  Pac-Man √© realmente transparente.  O preto √© obtido de um fundo s√≥lido. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/67d/330/3fe67d330fce92bff0b4595902e5f5bb.png"></div><br>  O pano de fundo do campo de jogo do Tetris pode ser usado de maneira semelhante. <br><br>  <code>ImageConverter</code> sa√≠da do <code>ImageConverter</code> parece com este trecho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rs/vt/ms/rsvtmsq6olz9bm1huiqbqgbouj4.png"></div><br>  Os 3 valores hexadecimais da primeira linha s√£o 3 cores opacas extra√≠das do arquivo de imagem do sprite.  Eles correspondem √†s cores do tetramino J, T e L. As cores do outro tetramino n√£o afetam a imagem.  Os blocos restantes s√£o padr√µes empacotados executados no campo de jogo (para caracteres ap√≥s <code>Z</code> e at√© a <code>a</code> consulte a <a href="">tabela de caracteres ASCII</a> ).  Os blocos amarelos destacados comp√µem a plataforma.  O primeiro bloco adiciona a plataforma, o segundo a remove. <br><br>  A classe <code>printer.Printer</code> recebe um arquivo de texto nesse formato e gera um arquivo de imagem tocando no Tetris. <br><br>  O algoritmo da impressora usado para gerar um v√≠deo semelhante √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o NES do Tetris</a> define cada tipo de tetramino em cada bloco de um arquivo de texto.  Em seguida, ele se move na ordem oposta do ponto inicial e da orienta√ß√£o inicial at√© o √¢ngulo de rota√ß√£o e as coordenadas de abaixamento da figura indicada no arquivo.  Nota: devido √† velocidade extremamente alta dos n√∫meros decrescentes, √© imposs√≠vel ir al√©m do n√≠vel 30 na vers√£o real do NES do Tetris.  Sup√µe-se que a impressora transmita todos os seus comandos para o campo de jogo com rapidez suficiente.  para compensar isso. <br><br>  Para regenerar arquivos de padr√£o, use <code>search.precomputed.PatternSearcher</code> .  Pode ser personalizado alterando as constantes no in√≠cio do arquivo de c√≥digo-fonte. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_WIDTH = <span class="hljs-number"><span class="hljs-number">21</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_HEIGHT = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EMITTED_SQUARES = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RANDOM_SETS = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_ATTEMPTS = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br>  <code>RANDOM_SETS</code> √© o n√∫mero de permuta√ß√µes aleat√≥rias de 371 maneiras de adicionar uma figura √† matriz.  Quando definido como <code>100000</code> , leva alguns segundos para inicializar as permuta√ß√µes na inicializa√ß√£o.  Al√©m disso, seu armazenamento requer mais de um gigabyte de mem√≥ria. <br><br>  <code>MAX_ATTEMPTS</code> controla o tempo de execu√ß√£o de uma pesquisa.  Um valor relativamente pequeno de <code>1000</code> permite que a pesquisa descarte rapidamente come√ßos aleat√≥rios que n√£o conseguem se mostrar bem.  No entanto, para provar que, para um tamanho de matriz espec√≠fico e o n√∫mero de quadrados criados, n√£o h√° solu√ß√£o, √© necess√°rio explorar completamente todo o espa√ßo de pesquisa.  Para fazer isso, voc√™ pode definir <code>MAX_ATTEMPTS</code> como <code>Integer.MAX_VALUE</code> . <br><br>  Constantes semelhantes s√£o encontradas em <code>search.realtime.RealtimeSearcher</code> , que √© usado pelo conversor de imagem.  Como mencionado acima, um grande valor <code>RANDOM_SETS</code> requer um aumento na mem√≥ria m√°xima e leva a um in√≠cio mais longo.  <code>MAX_RETRIES</code> controla o n√∫mero de tentativas, ap√≥s as quais a pesquisa em tempo real √© <code>MAX_RETRIES</code> e retorna √† pesquisa com uma tabela pr√©-calculada. <br><br>  Lembre-se de que ambos os algoritmos de pesquisa usam 100% da CPU, criando muitos threads paralelos com tamanho igual ao n√∫mero de processadores dispon√≠veis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/8b9/bd5/c2d8b9bd50fd64a3a7e739d51201c880.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474848/">https://habr.com/ru/post/pt474848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474838/index.html">SIBUR Challenge 2019 - Concurso de An√°lise de Dados Industriais</a></li>
<li><a href="../pt474840/index.html">O que eles estudam na especialidade de Ci√™ncia de Dados em universidades estrangeiras</a></li>
<li><a href="../pt474842/index.html">Caso: Servi√ßo de carro. Desenvolvimento de campanhas publicit√°rias e implementa√ß√£o do Bitrix24</a></li>
<li><a href="../pt474844/index.html">Dell XPS 13 7390: um laptop muito compacto para quem costuma trabalhar fora do escrit√≥rio</a></li>
<li><a href="../pt474846/index.html">O programa de limpeza de rios do mundo</a></li>
<li><a href="../pt474850/index.html">A aposta qu√¢ntica do Google na IA - e o que isso significa para toda a humanidade</a></li>
<li><a href="../pt474852/index.html">Ambiente Lexical e fechamentos em EcmaScript</a></li>
<li><a href="../pt474854/index.html">Acionar e-mails - como envolver seu p√∫blico-alvo</a></li>
<li><a href="../pt474856/index.html">Estrat√©gias de localiza√ß√£o de conte√∫do</a></li>
<li><a href="../pt474858/index.html">O que voc√™ precisa saber sobre o Red Hat OpenShift Service Mesh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>