<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎤 🚵🏽 🌴 Tetris como uma impressora 📲 🚈 👶🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Girando, reorganizando e abaixando uma sequência predeterminada de formas, o Tetris Printer Algorithm usa a mecânica do Tetris para gerar bitmaps arbi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tetris como uma impressora</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474848/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/az/2c/saaz2chpnuatbjn-rdg3zcryjwo.png"></div><br>  Girando, reorganizando e abaixando uma sequência predeterminada de formas, o Tetris Printer Algorithm usa a mecânica do Tetris para gerar bitmaps arbitrários. <br><br><h2>  Descrição do algoritmo </h2><br>  O algoritmo converte os pixels da imagem de origem nos quadrados do campo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tetris</a> linha por linha, movendo-se de baixo para cima.  Para gerar um único quadrado, o algoritmo monta uma estrutura que consiste em uma área retangular que é completamente suportada por um quadrado abaixo dele.  Após a montagem da região retangular, suas linhas são limpas, deixando um quadrado embaixo dela.  Aqui estão três exemplos desse comportamento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/c80/be8/895c80be864793bcd951c4edb6943f19.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c6/cdf/615/3c6cdf6159a7bbb9dd2dc95e87374055.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/104/674/951/104674951b666a97f36c4d069006df5d.gif"></div><br>  Como mostrado abaixo, o algoritmo também pode gerar vários quadrados com uma estrutura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caa/aef/04b/caaaef04b763c02d872079282d3b57d5.gif"></div><br>  No processo de construção de uma linha, todos os quadrados criados dessa maneira devem se basear em algo.  Nas imagens mostradas acima, os quadrados gerados estão no chão do campo de jogo.  No entanto, se uma linha arbitrária contiver furos, ela não poderá fornecer o suporte necessário para construir uma linha acima dela.  O algoritmo resolve esse problema criando uma plataforma plana no topo da string com furos.  Na animação abaixo, uma plataforma construída em cima de uma linha consiste em um quadrado vermelho.  Uma plataforma é uma estrutura temporária e a inserção da última forma a remove. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acf/f14/c6d/acff14c6d078f15cc01523e4c24389cb.gif"></div><br>  A linha de 5 quadrados vermelhos mostrada abaixo está no topo da linha de 3 quadrados vermelhos.  Isso é realizado através da construção de uma plataforma plana no topo da linha de fundo.  A plataforma fornece o suporte necessário para gerar 5 quadrados vermelhos.  No final, a plataforma é excluída inserindo a última forma e a nova linha se encaixa.  Observe que, se o algoritmo precisar gerar linhas na ordem inversa (uma linha de 3 quadrados vermelhos acima de uma linha de 5 quadrados vermelhos), a plataforma não será necessária. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/0ad/35c/8510ad35cdbf5639b06b5f17957eec79.gif"></div><br><h2>  Padrões de um quadrado </h2><br>  Para referência, darei os nomes de 7 tetramino (peças do jogo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/817/4aa/cef8174aa74b378cb17af2fe0c6f1c7b.png"></div><br>  A versão do algoritmo de impressora Tetris apresentada no artigo foi projetada especificamente para renderizar sprites de videogames antigos.  Esses jogos incluíam gráficos em blocos 8 × 8 e 2 bytes foram alocados para cada pixel.  Portanto, os sprites geralmente continham apenas 3 cores mais áreas transparentes e, na maioria das vezes, tinham um tamanho de 16 × 16 ou 16 × 32 pixels. <br><br>  A animação abaixo mostra todos os padrões usados ​​para criar quadrados individuais.  Cada padrão usa o tetramino intercambiável J, T e L, criando um único quadrado na parte inferior.  O algoritmo atribui esse tetramino a uma das três cores presentes no sprite.  O restante do tetramino recebe cores arbitrárias.  Durante a jogabilidade, todas as cores permanecem constantes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/b1f/efc/dfab1fefc65efed365513213cdf5ad12.gif"></div><br>  Devido à forma dos três tetraminos, é impossível criar um quadrado a partir das três cores nas duas primeiras e nas duas últimas colunas.  Portanto, a largura mínima do campo de jogo para renderizar um sprite com uma largura de 16 pixels é 2 + 16 + 2 = 20 quadrados.  No entanto, descobriu-se que 20 é muito pouco. <br><br>  Como mostrado abaixo, a área acima do quadrado inferior único não pode consistir em apenas uma linha, porque as únicas figuras que podem caber nele (tetramino I) não têm suporte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/1e5/645/87f1e56455f90295b076e72296cc58c1.gif"></div><br>  Com duas linhas, a única maneira de ampliar todo o campo de jogo para que ele tenha suporte é usar o tetramino S e Z. Mas, neste caso, os furos permanecerão na linha superior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58c/ea6/8ef/58cea68ef0e7d83c102402e9ed0255fb.gif"></div><br>  O número mínimo de linhas necessárias acima do quadrado inferior é 3 e, como mostrado várias vezes acima, esses padrões existem.  20 quadrados é a largura mínima necessária para colocar um sprite com uma largura de 16 pixels.  Mas 20 × 3 + 1 = 61, e esse número não é divisível por 4, o que significa que não pode ser construído a partir do tetramino.  No entanto, uma largura de 21 nos dá 21 × 3 + 1 = 64, e pode ser construída a partir de 16 tetramino.  De fato, essa largura permite ao algoritmo renderizar sprites com até 17 pixels de largura. <br><br>  O campo de jogo do Tetris original tem um tamanho de 10 × 20 quadrados (proporção 1: 2).  Nesta versão do algoritmo, essa proporção é preservada - o campo de jogo tem um tamanho de 21 × 42 quadrados. <br><br>  Como o tetramino J, T e L são intercambiáveis ​​ao criar um quadrado, e 3 quadrados desses tetraminos estão envolvidos na criação de uma linha acima dele, existem 21 - 3 = 18 padrões para criar um único quadrado.  No entanto, devido à simetria espelhada, existem apenas 9. Existem três linhas que funcionam para a maioria delas 9. No entanto, um estudo aprofundado em computador mostrou que os dois padrões precisavam de mais.  A próxima opção possível é 7 linhas, porque 21 × 7 + 1 = 148, o que requer 37 tetraminos.  Como mostrado nas imagens abaixo, esses padrões existem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/643/2ca/7a26432ca3f6e11d43f134057f3bfa73.gif"></div><br><h2>  Vários padrões quadrados </h2><br>  Os padrões para criar vários quadrados são limitados às mesmas três cores criadas pelos padrões de um único quadrado.  Os quadrados resultantes são criados a partir do tetramino J, T e L, cada um dos quais ocupa 3 quadrados em uma linha acima da linha de criação.  O número máximo de quadrados que podem ser potencialmente criados com um único padrão é 21/3 = 7. No entanto, para sprites com uma largura de 16 pixels, o tetramino mais à direita não pode criar um quadrado.  Mesmo no caso de sprites com uma largura de 17 pixels, ele pode criar um quadrado de apenas uma cor.  Portanto, o padrão de criação de 7 quadrados raramente é usado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/9cc/957/e019cc9577348937886f2f160fd8ad1b.gif"></div><br>  O número de padrões para criar um número arbitrário de quadrados pode ser determinado usando a combinação de enumerações.  Considere o padrão abaixo, representando uma linha acima de uma linha de três quadrados.  Cada bloco de três quadrados brancos adjacentes designa uma parte do tetramino;  quadrados criados não são mostrados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/b6d/fe5/cefb6dfe5d0c9c3b644189dc13901e63.gif"></div><br>  Três tetraminos criam 4 espaços vazios.  Existem 21 - 3 × 3 = 12 quadrados escuros que podem ser arbitrariamente inseridos nesses espaços vazios para formar um padrão específico.  O número de maneiras de distribuir esses quadrados escuros pode ser calculado colocando-os em uma linha na qual quadrados brancos únicos são tratados como divisores. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/160/0fb/3731600fb90642ff32fa58ee059cf4c3.gif"></div><br>  Portanto, a tarefa foi reduzida ao cálculo do valor do coeficiente do polinômio.  Observando esses quadrados em branco, você pode entender que essa é uma questão de várias maneiras de escolher 3 de 15. <img src="https://habrastorage.org/getpro/habr/post_images/5d4/344/bdb/5d4344bdb66112361fa655447baff0a3.png">  = 455 <br><br>  No caso geral, para <i>n</i> é igual a <img src="https://habrastorage.org/getpro/habr/post_images/f0d/252/47d/f0d25247d7defed1af6417ed76660ba6.png">  .  Mas, devido à simetria espelhada, de fato, são metade disso;  se a quantidade for ímpar, dividindo por dois, arredondamos para o número inteiro mais próximo para incluir nele um padrão perfeitamente simétrico que deveria existir nesse conjunto, como, por exemplo, mostrado abaixo para o caso 455. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/093/98d/5e609398dfe585680459774fc3b96cdc.gif"></div><br>  Aplicando esta fórmula ao 7 tetramino, confirmamos o óbvio: existe apenas um padrão para criar 7 quadrados. <br><br>  O padrão de criação de 6 quadrados pode ser construído de duas maneiras: duas linhas preenchidas (2 × 21 + 6 = 48) e seis linhas preenchidas (6 × 21 + 6 = 132), o que requer 12 e 33 tetramino.  A fórmula acima mostra que existem 84 padrões para a criação de 6 quadrados, mas apenas 35 deles podem ser construídos a partir de 2 linhas completas.  49 padrões requerem 6 linhas.  Os números são ímpares devido aos padrões simétricos mostrados abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c07/fe9/a24/c07fe9a243e3cdfe37103d4f16d01024.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a9/8c5/91b/8a98c591b95b4fc8a533e67adead58ad.gif"></div><br>  Também é importante notar que duas linhas são possíveis aqui, porque, ao contrário do padrão de criação de um quadrado que exigia o tetramino S e Z, 6 figuras são usadas nesses padrões. <br><br>  A tabela abaixo mostra o número de quadrados criados por cada tipo de padrão, o número de linhas completas, o número de tetramino usado e o número de padrões. <br><br><div class="scrollable-table"><table><tbody><tr><th>  Quadrados Criados </th><th>  Linhas completas </th><th>  Tetramino </th><th>  Padrões </th></tr><tr><td>  1 </td><td>  7 e 3 </td><td>  37 e 16 </td><td>  19 (4 e 15) </td></tr><tr><td>  2 </td><td>  6 </td><td>  32. </td><td>  136 </td></tr><tr><td>  3 </td><td>  5 </td><td>  27 </td><td>  455 </td></tr><tr><td>  4 </td><td>  4 </td><td>  22 </td><td>  715 </td></tr><tr><td>  5 </td><td>  3 </td><td>  17 </td><td>  462 </td></tr><tr><td>  6 </td><td>  2 e 6 </td><td>  12 e 33 </td><td>  84 (35 e 49) </td></tr><tr><td>  7 </td><td>  1 </td><td>  7 </td><td>  1 </td></tr></tbody></table></div><br>  Exemplos de padrões. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/569/9dc/055/5699dc0558af1a833b43b57defdefbf7.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/b83/682/1d1b83682d599094bcb138958706b8bf.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/510/bbb/efd510bbb099696e35b7e0b9156f35d4.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/079/bd5/d7a/079bd5d7a149568bda463270a5b3baaf.gif"></div><br><h2>  Plataformas </h2><br>  Antes de construir uma linha, o algoritmo examina a linha abaixo dela.  Se a linha inferior não puder fornecer suporte para todos os quadrados acima dela, será necessária uma plataforma temporária.  Quando a plataforma é removida, uma nova linha cai e, devido à maneira como a gravidade é implementada no Tetris original, alguns quadrados permanecem pairando no ar. <br><br>  A ilustração abaixo mostra 10 padrões de plataforma.  A construção da plataforma começa baixando o tetramino T em cima de um dos quadrados da última linha gerada.  Os tetraminos restantes dependem desse primeiro T. Ou seja, se a linha gerada anterior contiver pelo menos 1 quadrado, como o quadrado vermelho na imagem abaixo, podemos criar uma plataforma plana acima dela para gerar a próxima linha. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/299/e1d/5b0299e1d7f2916a802a49ea11c4eb16.gif"></div><br>  No meio da construção da plataforma, a linha inferior é concluída e excluída, deixando três linhas acima dela.  O último tetramino J ou L, que excluirá essas linhas, não será inserido até que os padrões de criação gerem a próxima linha de sprite na parte superior da plataforma.  Esta última figura impede a criação de quadrados na primeira e na última duas linhas.  Mas, como mencionado acima, devido à geometria dos tetraminos J, T e L usados ​​nesse processo, os padrões para a criação de quadrados são limitados a 17 colunas internas. <br><br>  Além disso, das 19 maneiras possíveis de construir plataformas sobre o Tetramino T, apenas 10 são mostradas acima. <br><br><h2>  Matrizes embaladas </h2><br>  Como mencionado acima, um subconjunto dos 6 padrões de criação de quadrados envolve a limpeza de apenas duas linhas.  Todos os outros padrões requerem 6 linhas.  Para entender por que esse é o caso, considere o padrão abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/370/9bf/3aa/3709bf3aa8fd860b3dbcc04014dfef8b.gif"></div><br>  Esses tetraminos são intercambiáveis ​​com os tetraminos J e L, e cada um deles adiciona 3 quadrados adjacentes à linha comum.  As linhas a serem preenchidas são representadas pela matriz mostrada abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ed/532/67a/3ed53267a1b216691289f68439470301.gif"></div><br>  Agora tudo está empacotando espaço vazio com tetramino.  Começando à esquerda, a única opção é usar a sequência tetramino I. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/b54/9f5/779b549f51bef09e54217790f2110eb5.gif"></div><br>  A única maneira de preencher o espaço restante é usar J e O ou I e L. Ambas as opções são mostradas abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de8/08e/33a/de808e33aa8f69d807c60b798e8ed0c1.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/a24/be8/aeca24be817f0cc88dc0ef3175ada63c.gif"></div><br>  Infelizmente, o tetramino O e L não são suportados nas matrizes mostradas acima.  Esse padrão de 6 quadrados requer uma matriz maior. <br><br>  Um problema semelhante surge em dois padrões de criação de um quadrado.  Considere a matriz abaixo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fba/ec4/6ad/fbaec46ad778d94b5844c22d35ebc4ed.gif"></div><br>  A única maneira de preencher a linha inferior à direita é encadear a sequência Z. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/3e1/5b2/5e83e15b210424010966f17b2ee1b72c.gif"></div><br>  Da mesma forma, a única maneira de obter 3 quadrados vazios no canto inferior esquerdo é tetramino S. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/297/9ae/b51/2979aeb51a67c1c0a51c7e5105890744.gif"></div><br>  Na linha do meio, existe um quadrado vazio entre S e Z e a única maneira de preenchê-lo é usar o tetramino J, T ou L, como mostrado nas figuras abaixo. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a0/364/433/2a036443351a7c1ec90fe0d534c38049.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/f88/7e8/8f3f887e84bcdbd7176b530af8757666.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3c/dc1/a0a/e3cdc1a0a243388524f4e5ffb8ac13d8.gif"></div><br>  Inserir qualquer uma dessas formas divide o espaço em branco.  A área vazia à esquerda contém 5, 6 e 7 espaços vazios, respectivamente.  Como nenhum desses valores é divisível por 4, é impossível continuar.  Uma matriz maior é necessária para esse padrão quadrado único. <br><br>  O mesmo se aplica a outro padrão para criar um quadrado, mostrado na matriz abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fd3/c11/c6c/fd3c11c6ce8d7e4b60a257486caef4e2.gif"></div><br>  Depois de usar o tetramino S e Z para preencher a maior parte da linha inferior, há um espaço vazio entre eles na linha do meio. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/e39/49c/3a6e3949c8f9f0849921a11ccf54596a.gif"></div><br>  Como mostrado nas imagens abaixo, a inserção do furo divide o espaço vazio e a área vazia à esquerda contém 9, 10 ou 11 quadrados, respectivamente;  nenhum dos números é divisível por 4. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15d/d8b/9b2/15dd8b9b24d8054598665cbff061344e.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d6/928/f4d/6d6928f4d884b746af74059ec210b96d.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c5/269/800/0c5269800d3ebdcb62e1131c03e32db0.gif"></div><br>  Mas as matrizes de empacotamento não são a única maneira de gerar um padrão de quadrados.  Por exemplo, dê uma olhada no criador de 4 quadrados abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fc/22b/653/4fc22b6538117dca3baff88c595337e4.gif"></div><br>  A seguir, é apresentada uma tentativa de renderizar o padrão como um conjunto de tetraminos empacotados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f5/53f/bfc/3f553fbfc96ecfbbef8f7304c80a80fe.gif"></div><br>  O último L é ignorado, porque o espaço para ele é formado somente após a conclusão e remoção da terceira linha. <br><br>  Mas, após uma pesquisa minuciosa, descobriu-se que essa técnica não fornece os padrões de um quadrado acima mencionados com a capacidade de trabalhar com apenas três linhas.  Além disso, ele não permite implementar novos padrões de 6 quadrados em duas linhas.  Não há necessidade de procurar os padrões restantes fora das matrizes compactadas, porque eles já usam a menor quantidade possível de tetramino.  E nos limitando a matrizes compactadas, encontraremos todos os padrões necessários muito mais rapidamente. <br><br><h2>  Pesquisa de padrões </h2><br>  Para simplificar a saída de dados, o Tetris Printer Algorithm limita-se a criar o tetramino no ponto central superior do campo de jogo, girando-o, movendo-se horizontalmente e abaixando-o.  Ele nunca precisa mover a figura horizontalmente depois de passar alguma distância.  Essa restrição reduz bastante o espaço de busca, pois não permite a formação de lacunas nas figuras adicionadas à matriz.  Como exemplo, vejamos a seguinte matriz de 3 quadrados. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/466/4d1/250/4664d1250708c9d9daeb800eb2ac7f47.gif"></div><br>  Se jogarmos J no centro da matriz, como mostrado acima, obteremos um espaço de 2 quadrados vazios, que não podem ser preenchidos com figuras subsequentes.  Portanto, a pesquisa não seguirá esse caminho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/562/934/866/56293486665cf1557d513f63fa700622.gif"></div><br>  Como as lacunas cobertas não são permitidas, cada coluna na matriz pode ser considerada como uma pilha de quadrados preenchidos e a altura dessas pilhas descreve completamente o conteúdo de toda a matriz.  Independentemente do número de linhas, uma matriz inteira unidimensional com 21 elementos será suficiente para descrever uma matriz bidimensional. <br><br>  Quando uma figura cai na matriz, as alturas das pilhas das colunas correspondentes aumentam.  Para acelerar esse processo, todos os tetraminos são analisados ​​previamente.  Existem 19 turnos tetraminos, e a pesquisa considera cada um deles como uma figura única. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/40e/d13/9e0/40ed139e0a5612cac1f5d074a0093d96.png"></div><br>  O Tetramino J no canto superior esquerdo da imagem ocupa 3 colunas.  Ao abaixar na matriz, as alturas de 3 pilhas adjacentes aumentam em 1, 1 e 2 quadrados, respectivamente.  Porém, antes que a figura possa ser baixada, o perfil inferior da figura deve corresponder ao perfil superior das respectivas pilhas.  Se este J estivesse no chão do campo de jogo, em cada uma dessas colunas deveria haver intervalos de 1, 1 e 0 quadrados vazios.  Como as folgas são proibidas, as alturas relativas de 3 pilhas terão que corresponder totalmente ao padrão. <br><br>  Outra consequência da falta de lacunas foi que, quando os números caem na matriz, as linhas são preenchidas de baixo para cima.  Não é possível preencher uma linha no meio de uma matriz antes ou simultaneamente não concluir todas as linhas abaixo dela.  No processo de preenchimento da matriz, seu limite inferior realmente se move para cima.  Consequentemente, uma pilha de colunas da matriz pode fornecer suporte apenas se sua altura menos o número de linhas concluídas for maior que 0. Quando uma forma é adicionada à matriz, pelo menos uma das colunas correspondentes deve fornecer suporte. <br><br>  A pesquisa armazena uma segunda matriz unidimensional que contém o número de quadrados preenchidos em cada linha.  O J acima contém nas linhas correspondentes 3 e 1 um quadrado.  Quando você o insere na matriz, esses valores são adicionados aos elementos correspondentes da matriz.  O número de linhas concluídas é o número de elementos com um valor 21. <br><br>  Conforme indicado na seção anterior, se a figura adicionada dividir a matriz, os tamanhos das áreas resultantes deverão ser divididos por 4. Por exemplo, na imagem abaixo, a adição de I cria 2 áreas, cada uma contendo 46 quadrados vazios.  Como 46 não é divisível por 4, não há mais como preencher o restante da matriz. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0d/c1e/91a/c0dc1e91a707d5b2fea279dd5c370ec4.gif"></div><br>  A separação aparece quando a altura da pilha é igual à altura da matriz.  Após inserir a figura incrementando as alturas das respectivas pilhas, as dimensões de todas as áreas divididas de espaço vazio podem ser determinadas digitalizando a matriz de alturas e somando o espaço restante em cada pilha.  Este número é verificado e redefinido quando uma divisão é detectada. <br><br>  A pesquisa usada para gerar todos os padrões usa construção incremental aleatória, um algoritmo de retorno que verifica sistematicamente todas as combinações em ordem aleatória.  A construção incremental de uma solução inserindo formas aleatoriamente faz com que ela cresça como um cristal.  A aleatoriedade fornece uma irregularidade contendo faces quebradas que servem como base para as formas adicionadas subsequentes.  A maior parte da matriz é empacotada aleatoriamente muito rapidamente e, quando o espaço vazio se torna escasso, o retrocesso entra em ação. <br><br>  Antes de realizar a pesquisa, são executadas permutações aleatórias de 371 maneiras de adicionar uma figura à matriz.  O pseudo-código da função de pesquisa é mostrado abaixo. <br><br><pre><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'pt', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Matrix matrix, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> remaining)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION } attempts := attempts + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attempts &gt;= MAX_ATTEMPTS) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (     S  Z) {        S  Z <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (  ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } }          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(   ,    ) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (   ) { Result result := search(matrix, remaining - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == SOLUTION) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SOLUTION }       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == TIMEOUT) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TIMEOUT } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NO_SOLUTION }</code> </pre> <br>  A matriz original transmitida para a função de pesquisa está vazia, exceto a linha inferior que contém blocos de 3 quadrados adjacentes.  É transmitido junto com o número de figuras restantes que precisam ser adicionadas.  Se o <code>remaining</code> for 0, a matriz contém a solução e a função retorna.  Cada chamada recursiva aumenta o número global de <code>attempts</code> .  Se exceder <code>MAX_ATTEMPTS</code> , que tem um valor de 1000, a pesquisa será iniciada novamente. <br><br>  A terceira <code>if</code> tenta adicionar o tetramino S ou Z à parte inferior da matriz, se o espaço permitir.  O significado disso é evitar situações como a mostrada abaixo, quando o algoritmo gasta tempo preenchendo parte da matriz, não podendo preencher o restante devido à falta de suporte. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36d/3f9/b81/36d3f9b81275718dccb5d40e70d7843b.gif"></div><br>  Graças à <code>if</code> ele rapidamente forma uma plataforma na qual construir: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/aa1/ed7/1d0aa1ed7c08ed07b3f31e22ab92ea42.gif"></div><br>  Para tentar adicionar uma figura à matriz, as verificações acima são necessárias.  O algoritmo verifica se a figura terá suporte, dadas as linhas concluídas.  Ele também verifica se divide por 4 o tamanho de cada espaço vazio individual criado pela inserção da forma. <br><br><h2>  Conversão de imagem </h2><br>  O algoritmo da impressora Tetris converte cada linha do bitmap em uma série de passes.  Movendo-se da esquerda para a direita, cada passagem de maneira "gananciosa" insere o tetramino J, T e L no local onde estão colocados.  Por exemplo, a imagem abaixo mostra uma linha de 16 pixels de um bitmap. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c1/4c5/b69/9c14c5b69ae9a4599ee0856a250256a8.gif"></div><br>  A imagem abaixo mostra as 5 passagens necessárias para cobrir esses 16 pixels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/f7d/760/989f7d76010dd0d7e523361148e0e323.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/920/25a/4c492025a6033a3eda85fd240118b657.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f1/44f/373/0f144f3734988b25dd231a1a445c52fd.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c1/e37/392/6c1e373927f4842ad379ff2b6c42b123.gif"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/64b/222/a9a64b222baaf24ed13674bdac9b8d01.gif"></div><br>  A sequência de formas que o algoritmo está tentando inserir é determinada pelas cores dos pixels.  Para que as formas não se sobreponham, é usada uma matriz unidimensional de valores booleanos.  Para inserir uma figura, 3 elementos zero devem estar presentes na matriz.  Após a inserção bem-sucedida da figura 3, os elementos correspondentes da matriz assumem o valor 1. <br><br>  Para rastrear pixels completos entre várias passagens, é usada uma segunda matriz unidimensional de valores booleanos.  Quando cada item é 1, a linha está completa. <br><br>  No final de cada passagem, o conversor de imagens pesquisa todos os padrões na tabela para criar um ou mais quadrados.  Na saída, ele passa o padrão correspondente com o tetramino J, T e L. inserido na parte inferior.Por exemplo, a primeira passagem mostrada acima é exibida como o seguinte padrão para criar 5 quadrados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c67/b1b/377/c67b1b3778a37bf7008438052679942e.gif"></div><br><h2>  Pesquisa em tempo real </h2><br>  O conversor de imagem descrito na seção anterior é extremamente rápido, pois utiliza uma tabela constante contendo todos os padrões para a criação de quadrados e não os pesquisa em tempo real.  No entanto, a pesquisa em tempo real pode usar padrões que não estão na tabela e, portanto, reduzir bastante a quantidade de tetramino necessária para gerar a imagem.  Ele usa os quadrados criados em passagens anteriores, usando-os como suportes adicionais.  Por exemplo, como mencionado acima, o padrão a seguir para criar um quadrado requer 7 linhas completas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ee/0b4/889/9ee0b488962c79ad6c84255efd033b5d.gif"></div><br>  Mas um quadrado vermelho criado na passagem anterior no canto inferior esquerdo da imagem abaixo fornece suporte adicional, reduzindo o número de linhas preenchidas para 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfa/d3e/271/dfad3e271c5623daedc462821b82b8af.gif"></div><br>  Além disso, uma pesquisa em tempo real pode cobrir 3 pixels adjacentes da mesma cor, girando o tetramino J, T ou L. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/e09/776/a31e097766437cb13ebde1e35ee66453.gif"></div><br>  De fato, ele pode combinar tetramino invertido e invertido, cobrindo um grande número de pixels em uma passagem.  Por exemplo, as 5 passagens acima necessárias para cobrir 16 pixels podem ser reduzidas à passagem única mostrada abaixo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/653/c31/64c653c31d38daeef85189e3b2eacaa8.gif"></div><br>  Para obter esse padrão, o conversor de imagem começa empacotando avidamente os tetraminos J, T e L. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/e98/67e/e7ae9867e1419492f6f19f6816d18f04.gif"></div><br>  Em seguida, ele tenta ansiosamente adicionar as versões não-giradas e, nesse caso, ele consegue adicionar outro J. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/4f3/1d4/ba24f31d49baa855fc449c3cf98f09ca.gif"></div><br>  Em princípio, uma tabela de pesquisa pré-calculada também pode ser usada nesse processo, mas o tamanho de uma tabela torna-a inaplicável na prática. <br><br>  Neste exemplo, 8 quadrados em uma linha acima da linha a ser criada são adicionados à linha inferior da matriz vazia.  Para <i>n</i> quadrados em um campo de jogo de 21 quadrados, a altura da matriz <i>h</i> é o menor número inteiro positivo, de modo que <i>21h - n</i> é divisível por 4. Nesse caso, é necessária uma matriz de altura 4. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2a/c2e/d2b/b2ac2ed2bc3a422d0d94fff2b10bf9e0.gif"></div><br>  A pesquisa em tempo real funciona exatamente da mesma maneira que o algoritmo de pesquisa descrito acima, mas possui pequenas melhorias.  Como antes, a pilha da coluna da matriz fornece suporte apenas se a altura da coluna menos o número de linhas concluídas for maior que zero.  Quando a diferença é zero, a pilha da coluna não deve fornecer suporte.  No entanto, nesta versão, se for igual a zero, verifica os quadrados na linha criada gerada pelos passes anteriores.  Ou seja, quaisquer quadrados na linha abaixo da linha inferior da matriz fornecem suporte para colunas vazias. <br><br>  Além disso, como a pesquisa é realizada em tempo real, será impraticável torná-la exaustiva.  Se ele não encontrou uma solução após um determinado número de tentativas, ele adiciona mais 4 linhas na parte superior da matriz e tenta novamente.  Depois disso, se ele ainda não conseguiu encontrar uma solução após um determinado número de tentativas, na passagem atual ele volta ao método com tabelas de pesquisa pré-calculadas e conversão de imagens descritas na seção anterior do artigo. <br><br><h2>  Impressão </h2><br>  Para imprimir, você deve seguir as instruções exibidas pelo conversor de imagens no campo de reprodução Tetris.  A impressora cria um tetramino específico no ponto central superior do campo de jogo em uma orientação padrão.  Em seguida, a impressora gira, move horizontalmente e abaixa.  Este processo é mostrado no vídeo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PJkHwulsac4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Código fonte </h2><br>  O código fonte do projeto Java 7 está disponível <a href="">aqui</a> . <br><br>  Os algoritmos de pesquisa para tabelas pré-preparadas e em tempo real estão nos pacotes <code>search.precomputed</code> e <code>search.realtime</code> .  Eles usam algumas classes comuns localizadas no pacote de <code>search</code> .  Os resultados de uma pesquisa pré-calculada são armazenados no pacote de <code>patterns</code> como uma sequência de arquivos de texto.  Os arquivos de texto armazenam matrizes compactadas como caracteres ASCII, começando com <code>A</code>  Por exemplo, as 3 primeiras matrizes em <code>emitters1.txt</code> (o conjunto de padrões para criar um quadrado) são assim: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/yo/mo/lvyomov6ld5rle3bqj1jnjegic4.png"></div><br>  Como indicado repetidamente no artigo, três símbolos <code>A</code> adjacentes nas matrizes acima podem ser substituídos pelos tetramino J, T ou L. Os símbolos <code>B</code> , <code>C</code> , <code>D</code> e assim por diante representam a sequência de tetramino que você precisa criar. <br><br>  A classe <code>imageconverter.ImageConverter</code> contém o método <code>main</code> , que recebe um único argumento de linha de comando: o nome do arquivo de imagem sprite.  Uma imagem não pode ter mais que 17 × 32 pixels e não pode conter mais de 3 cores opacas.  Todos os outros pixels devem ser transparentes. <br><br>  Curiosamente, em videogames antigos, os desenvolvedores costumavam usar o plano de fundo para obter cores extras.  Por exemplo, os alunos e a boca da bolha do Bubble bobble, os alunos do Donkey Kong do Donkey Kong e a sobrancelha com a toupeira da Srta.  Pac-Man é realmente transparente.  O preto é obtido de um fundo sólido. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/67d/330/3fe67d330fce92bff0b4595902e5f5bb.png"></div><br>  O pano de fundo do campo de jogo do Tetris pode ser usado de maneira semelhante. <br><br>  <code>ImageConverter</code> saída do <code>ImageConverter</code> parece com este trecho: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rs/vt/ms/rsvtmsq6olz9bm1huiqbqgbouj4.png"></div><br>  Os 3 valores hexadecimais da primeira linha são 3 cores opacas extraídas do arquivo de imagem do sprite.  Eles correspondem às cores do tetramino J, T e L. As cores do outro tetramino não afetam a imagem.  Os blocos restantes são padrões empacotados executados no campo de jogo (para caracteres após <code>Z</code> e até a <code>a</code> consulte a <a href="">tabela de caracteres ASCII</a> ).  Os blocos amarelos destacados compõem a plataforma.  O primeiro bloco adiciona a plataforma, o segundo a remove. <br><br>  A classe <code>printer.Printer</code> recebe um arquivo de texto nesse formato e gera um arquivo de imagem tocando no Tetris. <br><br>  O algoritmo da impressora usado para gerar um vídeo semelhante à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versão NES do Tetris</a> define cada tipo de tetramino em cada bloco de um arquivo de texto.  Em seguida, ele se move na ordem oposta do ponto inicial e da orientação inicial até o ângulo de rotação e as coordenadas de abaixamento da figura indicada no arquivo.  Nota: devido à velocidade extremamente alta dos números decrescentes, é impossível ir além do nível 30 na versão real do NES do Tetris.  Supõe-se que a impressora transmita todos os seus comandos para o campo de jogo com rapidez suficiente.  para compensar isso. <br><br>  Para regenerar arquivos de padrão, use <code>search.precomputed.PatternSearcher</code> .  Pode ser personalizado alterando as constantes no início do arquivo de código-fonte. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_WIDTH = <span class="hljs-number"><span class="hljs-number">21</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MATRIX_HEIGHT = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EMITTED_SQUARES = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> RANDOM_SETS = <span class="hljs-number"><span class="hljs-number">100000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_ATTEMPTS = <span class="hljs-number"><span class="hljs-number">1000</span></span>;</code> </pre> <br>  <code>RANDOM_SETS</code> é o número de permutações aleatórias de 371 maneiras de adicionar uma figura à matriz.  Quando definido como <code>100000</code> , leva alguns segundos para inicializar as permutações na inicialização.  Além disso, seu armazenamento requer mais de um gigabyte de memória. <br><br>  <code>MAX_ATTEMPTS</code> controla o tempo de execução de uma pesquisa.  Um valor relativamente pequeno de <code>1000</code> permite que a pesquisa descarte rapidamente começos aleatórios que não conseguem se mostrar bem.  No entanto, para provar que, para um tamanho de matriz específico e o número de quadrados criados, não há solução, é necessário explorar completamente todo o espaço de pesquisa.  Para fazer isso, você pode definir <code>MAX_ATTEMPTS</code> como <code>Integer.MAX_VALUE</code> . <br><br>  Constantes semelhantes são encontradas em <code>search.realtime.RealtimeSearcher</code> , que é usado pelo conversor de imagem.  Como mencionado acima, um grande valor <code>RANDOM_SETS</code> requer um aumento na memória máxima e leva a um início mais longo.  <code>MAX_RETRIES</code> controla o número de tentativas, após as quais a pesquisa em tempo real é <code>MAX_RETRIES</code> e retorna à pesquisa com uma tabela pré-calculada. <br><br>  Lembre-se de que ambos os algoritmos de pesquisa usam 100% da CPU, criando muitos threads paralelos com tamanho igual ao número de processadores disponíveis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/8b9/bd5/c2d8b9bd50fd64a3a7e739d51201c880.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474848/">https://habr.com/ru/post/pt474848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474838/index.html">SIBUR Challenge 2019 - Concurso de Análise de Dados Industriais</a></li>
<li><a href="../pt474840/index.html">O que eles estudam na especialidade de Ciência de Dados em universidades estrangeiras</a></li>
<li><a href="../pt474842/index.html">Caso: Serviço de carro. Desenvolvimento de campanhas publicitárias e implementação do Bitrix24</a></li>
<li><a href="../pt474844/index.html">Dell XPS 13 7390: um laptop muito compacto para quem costuma trabalhar fora do escritório</a></li>
<li><a href="../pt474846/index.html">O programa de limpeza de rios do mundo</a></li>
<li><a href="../pt474850/index.html">A aposta quântica do Google na IA - e o que isso significa para toda a humanidade</a></li>
<li><a href="../pt474852/index.html">Ambiente Lexical e fechamentos em EcmaScript</a></li>
<li><a href="../pt474854/index.html">Acionar e-mails - como envolver seu público-alvo</a></li>
<li><a href="../pt474856/index.html">Estratégias de localização de conteúdo</a></li>
<li><a href="../pt474858/index.html">O que você precisa saber sobre o Red Hat OpenShift Service Mesh</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>