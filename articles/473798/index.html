<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèª üõÉ üèóÔ∏è Programaci√≥n orientada al protocolo. Parte 1 üí¥ üôà üë©üèæ‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Echemos un vistazo m√°s de cerca al tema de la programaci√≥n orientada al protocolo. Por conveniencia, el material se dividi√≥ en tres partes. 


 Este m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programaci√≥n orientada al protocolo. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473798/"><p>  Echemos un vistazo m√°s de cerca al tema de la programaci√≥n orientada al protocolo.  Por conveniencia, el material se dividi√≥ en tres partes. </p><br><p>  Este material es una traducci√≥n comentada de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">presentaci√≥n de WWDC 2016</a> .  Contrariamente a la creencia com√∫n de que las cosas "bajo el cap√≥" deben permanecer all√≠, a veces es extremadamente √∫til descubrir qu√© est√° sucediendo all√≠.  Esto ayudar√° a usar el art√≠culo correctamente y para el prop√≥sito para el que fue dise√±ado. </p><a name="habracut"></a><br><p>  Esta parte abordar√° problemas clave en la programaci√≥n orientada a objetos y c√≥mo POP los resuelve.  Todo se considerar√° en las realidades del lenguaje Swift, los detalles se considerar√°n "compartimento del motor" de los protocolos. </p><br><h2 id="problemy-oop-i-zachem-nam-nuzhno-pop">  Problemas de OOP y por qu√© necesitamos POP </h2><br><p>  Se sabe que en OOP hay una serie de debilidades que pueden "sobrecargar" la ejecuci√≥n del programa.  Considere lo m√°s expl√≠cito y com√∫n: </p><br><ol><li>  Asignaci√≥n: ¬øPila o mont√≥n? </li><li>  Recuento de referencias: ¬øm√°s o menos? </li><li>  Despacho de m√©todo: ¬øest√°tico o din√°mico? </li></ol><br><h3 id="11-allocation---stack">  1.1 Asignaci√≥n - Pila </h3><br><p> La pila es una estructura de datos bastante simple y primitiva.  Podemos poner en la parte superior de la pila (push), podemos tomar desde la parte superior de la pila (pop).  La simplicidad es que esto es todo lo que podemos hacer con √©l. </p><br><p>  Para simplificar, supongamos que cada pila tiene una variable (puntero de pila).  Se utiliza para rastrear la parte superior de la pila y almacena un n√∫mero entero (Entero).  De esto se deduce que la velocidad de las operaciones con la pila es igual a la velocidad de reescribir Integer en esta variable. </p><br><p>  Empujar: colocar en la parte superior de la pila, aumentar el puntero de la pila; </p><br><p>  pop: reduce el puntero de la pila. </p><br><h3 id="tipy-znacheniy">  Tipos de valor </h3><br><p>  Consideremos los principios de la operaci√≥n de pila en Swift usando estructuras (struct). </p><br><p>  En Swift, los tipos de valor son estructuras (estructura) y enumeraciones (enumeraci√≥n), y los tipos de referencia son clases (clase) y funciones / cierres (func).  Los tipos de valor se almacenan en la Pila, los tipos de referencia se almacenan en el Mont√≥n. </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/tq/vj/8y/tqvj8yfygyvbneaqfwwuiig8on0.png"></p><br><ol><li>  Colocamos la primera estructura en Stack </li><li>  Copie el contenido de la primera estructura. </li><li>  Cambiar la memoria de la segunda estructura (la primera permanece intacta) </li><li>  Fin de uso.  Memoria libre </li></ol><br><h3 id="12-allocation---heap">  1.2 Asignaci√≥n - Mont√≥n </h3><br><p>  El mont√≥n es una estructura de datos en forma de √°rbol.  El tema de implementaci√≥n del mont√≥n no se ver√° afectado aqu√≠, pero intentaremos compararlo con la pila. </p><br><p>  ¬øPor qu√©, si es posible, vale la pena usar Stack en lugar de Heap?  He aqu√≠ por qu√©: </p><br><ul><li>  recuento de referencia </li><li>  administraci√≥n de memoria libre y su b√∫squeda de asignaci√≥n </li><li>  reescritura de memoria para desasignaci√≥n </li></ul><br><p>  Todo esto es solo una peque√±a parte de lo que hace que Heap funcione y claramente lo sopesa en comparaci√≥n con Stack. </p><br><p>  Por ejemplo, cuando necesitamos memoria libre en Stack, simplemente tomamos el valor de stack-pointer y lo incrementamos (porque todo lo que est√° encima del stack-pointer en Stack es memoria libre): O (1) es una operaci√≥n que es constante en el tiempo. </p><br><p>  Cuando necesitamos memoria libre en el mont√≥n, comenzamos a buscarla usando el algoritmo de b√∫squeda apropiado en la estructura del √°rbol de datos; en el mejor de los casos, tenemos una operaci√≥n O (logn), que no es constante en el tiempo y depende de implementaciones espec√≠ficas. <br>  De hecho, Heap es mucho m√°s complicado: su trabajo es proporcionado por una serie de otros mecanismos que viven en las entra√±as de los sistemas operativos. </p><br><p>  Tambi√©n vale la pena se√±alar que el uso de Heap en modo de subprocesamiento m√∫ltiple agrava significativamente la situaci√≥n, ya que es necesario garantizar la sincronizaci√≥n del recurso compartido (memoria) para diferentes subprocesos.  Esto se logra mediante el uso de bloqueos (sem√°foros, spinlocks, etc.). </p><br><h3 id="ssylochnye-tipy">  Tipos de referencia </h3><br><p>  Veamos c√≥mo funciona Heap en Swift usando clases. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...) <span class="hljs-comment"><span class="hljs-comment">// (1) let point2 = point1 // (2) point2.x = 5 // (3) //  point1 //  point2 // (4)</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/o4/ct/y3/o4cty3n_4gizx4o0-amtg2f5tqm.png"></p><br><p>  1. Coloque el cuerpo de la clase en el mont√≥n.  Coloque el puntero a este cuerpo en la pila. </p><br><ol><li>  Copie el puntero que se refiere al cuerpo de la clase. </li><li>  Cambiamos un cuerpo de clase </li><li>  Fin de uso.  Memoria libre </li></ol><br><h3 id="13-allocation---nebolshoy-i-realnyy-primer">  1.3 Asignaci√≥n: un ejemplo peque√±o y "real" </h3><br><p>  En algunas situaciones, elegir Stack no solo simplifica el manejo de la memoria, sino que tambi√©n mejora la calidad del c√≥digo.  Considere un ejemplo: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> red, green, blue } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tail</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, tail, bubble } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeBalloon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color: Color, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> orientation: Orientation, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tail: Tail)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIImage</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-string"><span class="hljs-string">"\(color):\(orientation):\(tail)"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> image = cache[key] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> image } ... }</code> </pre> <br><p>  Si el diccionario de cach√© tiene un valor con la tecla clave, entonces la funci√≥n simplemente devolver√° el UIImage en cach√©. </p><br><h3 id="problemy-etogo-koda">  Los problemas de este c√≥digo son: </h3><br><p>  No es una buena pr√°ctica usar String como clave en la memoria cach√©, porque String al final "puede resultar ser cualquier cosa". </p><br><p>  String es una estructura de copia en escritura, para implementar su dinamismo, almacena todos sus Character-s en Heap.  Por lo tanto, String es una estructura y se almacena en Stack, pero almacena todo su contenido en Heap. </p><br><p>  Esto es necesario para proporcionar la posibilidad de cambiar la l√≠nea (eliminar parte de la l√≠nea, agregar una nueva l√≠nea a esta l√≠nea).  Si todos los caracteres de la cadena se almacenaran en la Pila, entonces tales manipulaciones ser√≠an imposibles.  Por ejemplo, en C, las cadenas son est√°ticas, lo que significa que el tama√±o de una cadena no se puede aumentar en tiempo de ejecuci√≥n ya que todo el contenido se almacena en la Pila.  Para copiar y escribir y analizar m√°s detalladamente las l√≠neas en Swift, haga clic <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . </p><br><h3 id="reshenie">  Soluci√≥n: </h3><br><ol><li><p>  Use la estructura bastante obvia aqu√≠ en lugar de la cadena: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attributes</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hashable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color: <span class="hljs-type"><span class="hljs-type">Color</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation: <span class="hljs-type"><span class="hljs-type">Orientation</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tail: <span class="hljs-type"><span class="hljs-type">Tail</span></span> }</code> </pre> <br></li><li><p>  Cambiar diccionario a: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache: [<span class="hljs-type"><span class="hljs-type">Attributes</span></span>: <span class="hljs-type"><span class="hljs-type">UIImage</span></span>] = []</code> </pre> <br></li><li><p>  Deshazte de String </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = <span class="hljs-type"><span class="hljs-type">Attributes</span></span>(color: color, orientation: orientation, tail: tail)</code> </pre> <br></li></ol><br><p>  En la estructura de Atributos, todas las propiedades se almacenan en la Pila, ya que la enumeraci√≥n se almacena en la Pila.  Esto significa que no hay un uso impl√≠cito de Heap aqu√≠, y ahora las claves para el diccionario de cach√© est√°n definidas con mucha precisi√≥n, lo que aument√≥ la seguridad y la claridad de este c√≥digo.  Tambi√©n nos deshicimos del uso impl√≠cito de Heap. </p><br><p>  <strong>Veredicto:</strong> Stack es mucho m√°s f√°cil y r√°pido que Heap: la elecci√≥n para la mayor√≠a de las situaciones es obvia. </p><br><h3 id="2-podschet-ssylok">  2. Recuento de referencias </h3><br><p>  Para que? </p><br><p>  Swift debe saber cu√°ndo es posible liberar un trozo de memoria en Heap, ocupado, por ejemplo, por una instancia de una clase o funci√≥n.  Esto se implementa a trav√©s de un mecanismo de conteo de enlaces: cada instancia (clase o funci√≥n) alojada en Heap tiene una variable que almacena el n√∫mero de enlaces.  Cuando no hay enlaces a una instancia, Swift decide liberar una pieza de memoria asignada para ello. </p><br><p>  Cabe se√±alar que para una implementaci√≥n de "alta calidad" de este mecanismo se necesitan muchos m√°s recursos que para aumentar y disminuir el puntero de pila.  Esto se debe al hecho de que el valor del n√∫mero de enlaces puede aumentar desde diferentes subprocesos (porque puede referirse a una clase o funci√≥n desde diferentes subprocesos).  Adem√°s, no olvide la necesidad de garantizar la sincronizaci√≥n de un recurso compartido (n√∫mero variable de enlaces) para diferentes subprocesos (spinlocks, sem√°foros, etc.). </p><br><p>  Pila: encontrar memoria libre y liberar memoria usada - operaci√≥n de puntero de pila </p><br><p>  Mont√≥n: b√∫squeda de memoria libre y liberaci√≥n de memoria usada: algoritmo de b√∫squeda de √°rbol y conteo de referencias. </p><br><p>  En la estructura de Atributos, todas las propiedades se almacenan en la Pila, ya que la enumeraci√≥n se almacena en la Pila.  Esto significa que no hay un uso impl√≠cito de Heap aqu√≠, y ahora las claves para el diccionario de cach√© est√°n definidas con mucha precisi√≥n, lo que aument√≥ la seguridad y la claridad de este c√≥digo.  Tambi√©n nos deshicimos del uso impl√≠cito de Heap. </p><br><h3 id="psevdokod">  Pseudoc√≥digo </h3><br><p>  Considere una peque√±a pieza de pseudoc√≥digo para demostrar c√≥mo funciona el conteo de enlaces: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refCount: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {...} <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(...) { ... <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point1 = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point2 = point1 retain(point2) <span class="hljs-comment"><span class="hljs-comment">// retain() -  refCount  1    point2.x = 5 //  `point1` release(point1) // release() -  refCount  1 //  `point2` release(point2)</span></span></code> </pre> <br><h3 id="struct">  Estructura </h3><br><p>  Cuando se trabaja con estructuras, simplemente no se necesita un mecanismo como el conteo de referencias: </p><br><ol><li>  estructura no almacenada en el mont√≥n </li><li>  struct - copiado en la asignaci√≥n, por lo tanto, no hay referencias </li></ol><br><h3 id="kopirovanie-ssylok">  Copiar enlaces </h3><br><p>  Una vez m√°s, la estructura y cualquier otro tipo de valor en Swift se copian en la asignaci√≥n.  Si la estructura almacena enlaces en s√≠ misma, tambi√©n se copiar√°n: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Label</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> font: <span class="hljs-type"><span class="hljs-type">UIFont</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { ... text.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> font.refCount = <span class="hljs-number"><span class="hljs-number">1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label = <span class="hljs-type"><span class="hljs-type">Label</span></span>(text: <span class="hljs-string"><span class="hljs-string">"Hi"</span></span>, font: font) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> label2 = label retain(label2.text._storage) <span class="hljs-comment"><span class="hljs-comment">//    `String`       Heap retain(label2.font) //  label release(label.text._storage) release(label.font) //  label2 release(label2.text._storage) release(label2.font)</span></span></code> </pre> <br><p>  label y label2 comparten instancias comunes alojadas en Heap: </p><br><ul><li>  contenido de texto </li><li>  y fuente </li></ul><br><p>  Por lo tanto, si la estructura almacena enlaces en s√≠ misma, al copiar esta estructura, el n√∫mero de enlaces se duplica, lo que, si no es necesario, afecta negativamente la "facilidad" del programa. </p><br><h3 id="i-snova-realnyy-primer">  Y de nuevo el ejemplo "real": </h3><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Attachment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fileUrl: <span class="hljs-type"><span class="hljs-type">URL</span></span> <span class="hljs-comment"><span class="hljs-comment">//   HEAP  let uuid: String //    HEAP  let mimeType: String //    HEAP  init?(fileUrl: URL, uuid: String, mimeType: String) { guard mimeType.isMimeType else { return nil } self.fileUrl = fileUrl self.uuid = uuid self.mimeType = mimeType } }</span></span></code> </pre> <br><p>  Los problemas de esta estructura son que tiene: </p><br><ol><li>  3 asignaci√≥n de mont√≥n </li><li>  Como String puede ser cualquier string, la seguridad y la claridad del c√≥digo se ven afectadas. </li></ol><br><p>  Al mismo tiempo, uuid y mimeType son cosas estrictamente definidas: </p><br><p>  uuid es una cadena de formato xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx <br>  mimeType es una cadena de formato de tipo / extensi√≥n. </p><br><h3 id="reshenie-1">  Soluci√≥n </h3><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> uuid: <span class="hljs-type"><span class="hljs-type">UUID</span></span> <span class="hljs-comment"><span class="hljs-comment">// UUID  ,    Foundation</span></span></code> </pre> <br><p>  En el caso de mimeType, enum funciona bien: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(rawValue: <span class="hljs-type"><span class="hljs-type">String</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> rawValue { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .jpeg <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/png"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .png <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = .gif <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg, png, gif }</code> </pre> <br><p>  O mejor y m√°s f√°cil: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MimeType</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> jpeg = <span class="hljs-string"><span class="hljs-string">"image/jpeg"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> png = <span class="hljs-string"><span class="hljs-string">"image/png"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> gif = <span class="hljs-string"><span class="hljs-string">"image/gif"</span></span> }</code> </pre> <br><p>  Y no olvides cambiar: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mimeType: <span class="hljs-type"><span class="hljs-type">MimeType</span></span></code> </pre> <br><h3 id="31-method-dispatch">  3.1 Despacho del m√©todo </h3><br><ul><li>  este es un algoritmo que busca el c√≥digo del m√©todo que se llam√≥ </li></ul><br><p>  Antes de hablar sobre la implementaci√≥n de este mecanismo, vale la pena determinar qu√© son un "mensaje" y un "m√©todo" en este contexto: </p><br><ul><li>  Un mensaje es el nombre que enviamos al objeto.  Todav√≠a se pueden enviar argumentos junto con el nombre. </li></ul><br><pre> <code class="swift hljs">circle.draw(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: origin)</code> </pre> <br><p>  El mensaje es dibujar: el nombre del m√©todo.  El objeto receptor es un c√≠rculo.  El origen tambi√©n es un argumento pasado. </p><br><ul><li>  El m√©todo es el c√≥digo que se devolver√° en respuesta al mensaje. </li></ul><br><p>  Luego, Method Dispatch es un algoritmo que decide qu√© m√©todo se debe dar a un mensaje en particular. </p><br><h2 id="bolee-konkretno-o-method-dispatch-v-swift">  M√°s espec√≠ficamente sobre Despacho de m√©todos en Swift </h2><br><p>  Como podemos heredar de la clase principal y anular sus m√©todos, Swift debe saber exactamente qu√© implementaci√≥n de este m√©todo debe llamarse en una situaci√≥n espec√≠fica. </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"parent"</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"child"</span></span>) } }</code> </pre> <br><p>  Cree un par de instancias y llame al m√©todo me: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> parent = <span class="hljs-type"><span class="hljs-type">Parent</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> child = <span class="hljs-type"><span class="hljs-type">Child</span></span>() parent.me() <span class="hljs-comment"><span class="hljs-comment">// "parent" child.me() // "child"</span></span></code> </pre> <br><p>  Un ejemplo bastante obvio y simple.  Y que pasa si: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> array: [<span class="hljs-type"><span class="hljs-type">Parent</span></span>] = [<span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>(), <span class="hljs-type"><span class="hljs-type">Parent</span></span>(), <span class="hljs-type"><span class="hljs-type">Child</span></span>()] array.forEach { $<span class="hljs-number"><span class="hljs-number">0</span></span>.me() <span class="hljs-comment"><span class="hljs-comment">// "child" "child" "parent" "child" }</span></span></code> </pre> <br><p>  Esto no es tan obvio y requiere recursos y un cierto mecanismo para determinar la implementaci√≥n correcta del m√©todo me.  Los recursos son el procesador y la RAM.  Un mecanismo es un m√©todo de env√≠o. </p><br><p>  En otras palabras, Method Dispatch es c√≥mo el programa determina qu√© implementaci√≥n de m√©todo invocar. </p><br><p>  Cuando se llama a un m√©todo en el c√≥digo, se debe conocer su implementaci√≥n.  Si ella es conocida por <br>  En el momento de la compilaci√≥n, este es el env√≠o est√°tico.  Si la implementaci√≥n se determina inmediatamente antes de la llamada (en tiempo de ejecuci√≥n, en el momento de la ejecuci√≥n del c√≥digo), esto es Dynamic Dispatch. </p><br><h3 id="32-method-dispatch---static-dispatch">  3.2 Despacho de m√©todo - Despacho est√°tico </h3><br><p>  El m√°s √≥ptimo, ya que: </p><br><ol><li>  El compilador sabe qu√© bloque de c√≥digo (implementaci√≥n del m√©todo) se llamar√°.  Gracias a esto, puede optimizar este c√≥digo tanto como sea posible y recurrir a un mecanismo como la inline. </li><li>  Adem√°s, en el momento de la ejecuci√≥n del c√≥digo, el programa simplemente ejecutar√° este bloque de c√≥digo conocido por el compilador.  No se emplear√°n recursos ni tiempo para determinar la implementaci√≥n correcta del m√©todo, lo que acelerar√° la ejecuci√≥n del programa. </li></ol><br><h3 id="33-method-dispatch---dynamic-dispatch">  3.3 Despacho de m√©todos - Despacho din√°mico </h3><br><p>  No es el m√°s √≥ptimo, ya que: </p><br><ol><li>  La implementaci√≥n correcta del m√©todo se determinar√° en el momento de la ejecuci√≥n del programa, lo que requiere recursos y tiempo </li><li>  No hay optimizaciones del compilador fuera de discusi√≥n </li></ol><br><h3 id="34-method-dispatch---inlining">  3.4 Despacho de m√©todo - En l√≠nea </h3><br><p>  Se mencion√≥ un mecanismo como la alineaci√≥n, pero ¬øqu√© es?  Considere un ejemplo: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation } } func drawAPoint(_ param: Point) { param.draw() } let point = Point(x: 0, y: 0) drawAPoint(point)</span></span></code> </pre> <br><ul><li>  El m√©todo point.draw () y la funci√≥n drawAPoint se procesar√°n a trav√©s del env√≠o est√°tico, ya que no hay dificultad para determinar la implementaci√≥n correcta para el compilador (ya que no hay herencia y la redefinici√≥n es imposible) </li><li>  Como el compilador sabe lo que se har√°, puede optimizar esto.  Primero optimiza drawAPoint, simplemente reemplazando la llamada de funci√≥n con su c√≥digo: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) point.draw()</code> </pre> <br><ul><li>  luego optimiza point.draw, ya que tambi√©n se conoce la implementaci√≥n de este m√©todo: </li></ul><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = <span class="hljs-type"><span class="hljs-type">Point</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Point.draw implementation</span></span></code> </pre> <br><p>  Creamos un punto, ejecutamos el c√≥digo del m√©todo de dibujo: el compilador simplemente sustituy√≥ el c√≥digo necesario para estas funciones en lugar de llamarlas.  En Dynamic Dispatch, esto ser√° un poco m√°s complicado. </p><br><h3 id="35-method-dispatch---inheritance-based-polymorphism">  3.5 Despacho de m√©todo: polimorfismo basado en herencia </h3><br><p>  ¬øPor qu√© necesito Dynamic Dispatch?  Sin ella, es imposible definir m√©todos anulados por clases secundarias.  El polimorfismo no ser√≠a posible.  Considere un ejemplo: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { d.draw() }</code> </pre> <br><ul><li>  La matriz de elementos dibujables puede contener Punto y L√≠nea </li><li>  intuitivamente, el env√≠o est√°tico no es posible aqu√≠.  d en el bucle for puede ser Line, o quiz√°s Point.  El compilador no puede determinar esto, y cada tipo tiene su propia implementaci√≥n de draw </li></ul><br><p>  Entonces, ¬øc√≥mo funciona Dynamic Dispatch?  Cada objeto tiene un campo de tipo.  Entonces Point (...). Type ser√° igual a Point, y Line (...). Type ser√° igual a Line.  Tambi√©n en alg√∫n lugar de la memoria (est√°tica) del programa hay una tabla (tabla virtual), donde para cada tipo hay una lista con sus implementaciones de m√©todos. </p><br><p>  En Objective-C, el campo de tipo se conoce como el campo isa.  Est√° presente en cada objeto Objective-C (NSObject). </p><br><p>  El m√©todo de clase se almacena en una tabla virtual y no tiene idea de s√≠ mismo.  Para usar self dentro de este m√©todo, debe pasarse all√≠ (self). </p><br><p>  Por lo tanto, el compilador cambiar√° este c√≥digo a: </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Point)</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">self</span></span></span></span><span class="hljs-function"><span class="hljs-params">: Line)</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawables: [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawables { vtable[d.type].draw(d) }</code> </pre> <br><p>  En el momento de la ejecuci√≥n del c√≥digo, debe buscar en la tabla virtual, encontrar la clase d all√≠, tomar el m√©todo de dibujo de la lista resultante y pasarle un objeto de tipo d como propio.  Este es un trabajo decente para una invocaci√≥n de m√©todo simple, pero es necesario asegurarse de que el polimorfismo funcione.  Se utilizan mecanismos similares en cualquier lenguaje OOP. </p><br><h2 id="method-dispatch---itog">  Despacho de m√©todo - Resumen </h2><br><ul><li>  Los m√©todos de clase se procesan de forma predeterminada a trav√©s de Dynamic Dispatch.  Pero no todos los m√©todos de clase deben manejarse a trav√©s de Dynamic Dispatch.  Si el m√©todo no se anula, puede encabezarlo con la palabra clave final, y luego el compilador sabr√° que este m√©todo no puede anularse y lo procesar√° a trav√©s del Despacho est√°tico </li><li>  los m√©todos que no son de clase no se pueden anular (ya que struct y enum no admiten herencia) y se procesan a trav√©s del env√≠o est√°tico </li></ul><br><h2 id="problemy-oop---itog">  Problemas OOP - Resumen </h2><br><p>  Es necesario prestar atenci√≥n a peque√±os detalles como: </p><br><ol><li>  Al crear una instancia: ¬ød√≥nde se ubicar√°? </li><li>  Al trabajar con esta instancia: ¬øc√≥mo funcionar√° el conteo de enlaces? </li><li>  Al llamar a un m√©todo: ¬øc√≥mo se procesar√°? </li></ol><br><p>  Si pagamos por el dinamismo sin darnos cuenta y sin necesidad de ello, esto afectar√° negativamente el programa que se est√° implementando. </p><br><p>  El polimorfismo es una cosa muy importante y √∫til.  Por el momento, todo lo que se sabe es que el polimorfismo en Swift est√° directamente relacionado con clases y tipos de referencia.  Nosotros, a su vez, decimos que las clases son lentas y pesadas, y la estructura es simple y f√°cil.  ¬øEs posible el polimorfismo a trav√©s de estructuras posibles?  La programaci√≥n orientada al protocolo puede proporcionar una respuesta a esta pregunta. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473798/">https://habr.com/ru/post/473798/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473786/index.html">La inscripci√≥n para el hackathon en Riga est√° terminando. Premio - entrenamiento a corto plazo en el PhysTech</a></li>
<li><a href="../473788/index.html">Las microprote√≠nas descubren aspectos desconocidos de la biolog√≠a moderna.</a></li>
<li><a href="../473790/index.html">Splines en gr√°ficos 3D, la opci√≥n m√°s automatizada</a></li>
<li><a href="../473794/index.html">Phishing m√≥vil: amenazas infinitas</a></li>
<li><a href="../473796/index.html">Extensor √≥ptico HDMI. 300 metros</a></li>
<li><a href="../473800/index.html">Bio radar, dron de cart√≥n y salchicha voladora - Nikita Kalinovsky sobre las buenas y malas tecnolog√≠as de b√∫squeda</a></li>
<li><a href="../473802/index.html">Alain Bombar - Ca√≠da despu√©s del triunfo</a></li>
<li><a href="../473804/index.html">¬øCu√°l es el salario de Junior QA?</a></li>
<li><a href="../473806/index.html">Este es el tipo de internet que queremos: c√≥mo las redes sociales se convirtieron en un arma mortal</a></li>
<li><a href="../473812/index.html">El resumen de eventos para profesionales de recursos humanos en el campo de TI en noviembre de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>