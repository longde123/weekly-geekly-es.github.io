<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♉️ 🙅🏿 👨🏻‍🎤 Verspätete Implementierung des Durchlaufens eines untergeordneten Baums der QObject-Klasse 🤘🏾 👚 👩🏽‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einleitung 


 Der Artikel beschreibt die verzögerte Implementierung von Tree Traversal in C ++ mithilfe von Coroutinen und Bereichen am Beispiel der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verspätete Implementierung des Durchlaufens eines untergeordneten Baums der QObject-Klasse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481402/"><h2 id="vvedenie">  Einleitung </h2><br><p> Der Artikel beschreibt die verzögerte Implementierung von Tree Traversal in C ++ mithilfe von Coroutinen und Bereichen am Beispiel der Verbesserung der Schnittstelle für die Arbeit mit <code>QObject</code> der <code>QObject</code> Klasse aus dem Qt-Framework.  Die Erstellung einer benutzerdefinierten Ansicht für die Arbeit mit untergeordneten Elementen wird detailliert betrachtet, und es werden verzögerte und klassische Implementierungen angegeben.  Am Ende des Artikels befindet sich ein Link zum Repository mit dem vollständigen Quellcode. </p><a name="habracut"></a><br><h2 id="ob-avtore">  Über den Autor </h2><br><p>  Ich arbeite als Senior Developer im norwegischen Büro von The Qt Company.  Ich habe Widgets und QtQuick-Elemente entwickelt, vor kurzem Qt Core.  Ich benutze C ++ und bin ein bisschen an funktionaler Programmierung interessiert.  Manchmal erstelle ich Berichte und schreibe Artikel. </p><br><h2 id="chto-takoe-qt">  Was ist Qt </h2><br><p>  <a href="https://wiki.qt.io/About_Qt">Qt</a> ist ein plattformübergreifendes Framework zum Erstellen grafischer Benutzeroberflächen (GUIs).  Neben Modulen zum Erstellen einer GUI enthält Qt viele Module zum Entwickeln von Anwendungssoftware.  Das Framework wurde hauptsächlich in der Programmiersprache C ++ entwickelt. Einige Komponenten verwenden <a href="https://doc.qt.io/qt-5/qmlapplications.html">QML</a> und <a href="https://doc.qt.io/qt-5/qtqml-javascript-expressions.html">JavaScript</a> . </p><br><h2 id="klass-qobject">  QObject-Klasse </h2><br><p>  <a href="https://doc.qt.io/qt-5/qobject.html">QObject</a> ist die Klasse, um die das Qt-Objektmodell aufgebaut ist.  Von <code>QObject</code> geerbte <code>QObject</code> können im Slot-Signalmodell und in der Ereignisschleife verwendet werden.  Darüber hinaus können Sie mit <code>QObject</code> auf Informationen zu <code>QObject</code> zugreifen und Objekte in Baumstrukturen organisieren. </p><br><h2 id="drevovidnaya-struktura-qobject">  QObject Baumstruktur </h2><br><p>  Die Verwendung einer <a href="https://doc.qt.io/qt-5/objecttrees.html">Baumstruktur</a> bedeutet, dass jedes <code>QObject</code> Objekt ein übergeordnetes Objekt und null oder mehr <code>QObject</code> Objekte haben kann.  Das übergeordnete Objekt steuert die Lebensdauer der untergeordneten Objekte.  Im folgenden Beispiel werden zwei untergeordnete Elemente automatisch gelöscht: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> parent = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;QObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> onDestroyed = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> obj){ qDebug(<span class="hljs-string"><span class="hljs-string">"Object %p destroyed."</span></span>, obj); }; QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QObject(parent.get()), &amp;QObject::destroyed, onDestroyed); QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QObject(parent.get()), &amp;QObject::destroyed, onDestroyed); <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre> <br><p>  Leider funktioniert der Großteil der Qt-API bisher nur mit rohen Zeigern.  Wir arbeiten daran, und vielleicht wird sich die Situation bald zumindest teilweise zum Besseren wenden. </p><br><p>  Über die <code>QObject</code> Klassenschnittstelle können Sie eine Liste aller <code>QObject</code> Objekte <code>QObject</code> und nach bestimmten Kriterien suchen.  Betrachten Sie das Beispiel zum Abrufen einer Liste aller untergeordneten Objekte: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> parent = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;QObject&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  10   for (std::size_t i = 0; i &lt; 10; ++i) { auto obj = new QObject(parent.get()); obj-&gt;setObjectName(QStringLiteral("Object %1").arg(i)); } const auto&amp; children = parent-&gt;children(); qDebug() &lt;&lt; children; // =&gt; (QObject(0x1f7ffa0, name = "Object 0"), ...) qDebug() &lt;&lt; children.count(); // =&gt; 10</span></span></code> </pre> <br><p>  Die <code>QObject::children</code> Methode gibt eine Liste aller <code>QObject::children</code> des angegebenen Objekts zurück.  Oft ist jedoch eine Suche innerhalb des gesamten Teilbaums von Objekten nach einem bestimmten Kriterium erforderlich: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = parent-&gt;findChildren&lt;QObject&gt;(QRegularExpression(<span class="hljs-string"><span class="hljs-string">"0$"</span></span>)); qDebug() &lt;&lt; children.count();</code> </pre> <br><p>  Das obige Beispiel zeigt, wie Sie eine Liste aller <code>QObject</code> Typs <code>QObject</code> deren Name auf 0 endet. Im Gegensatz zur Methode <code>findChildren</code> durchläuft die Methode <code>findChildren</code> den Baum rekursiv, <code>findChildren</code> wird die gesamte Hierarchie der Objekte durchsucht.  Dieses Verhalten kann durch Übergeben des <code>Qt::FindDirectChildrenOnly</code> geändert werden. </p><br><h2 id="nedostatki-interfeysa-raboty-s-dochernimi-elementami">  Nachteile der Schnittstelle für die Arbeit mit untergeordneten Elementen </h2><br><p>  Auf den ersten Blick scheint die Oberfläche für die Arbeit mit Kindern gut durchdacht und flexibel zu sein.  Er ist jedoch nicht ohne Mängel.  Betrachten wir einige davon: </p><br><ul><li>  Redundante Schnittstelle <br>  Es gibt zwei verschiedene <code>findChildren</code> Methoden (es gab drei vor nicht allzu langer Zeit): die <code>findChild</code> Methode zum Suchen eines Elements und die <code>findChild</code> Methode.  Sie alle überlappen sich teilweise. </li><li>  Die Schnittstelle ist schwer zu ändern <br>  Qt garantiert Binärkompatibilität und Kompatibilität auf Quellcodeebene in einer einzigen Hauptversion.  Daher können Sie nicht einfach die Signatur einer Methode ändern oder neue Methoden hinzufügen. </li><li>  Die Schnittstelle ist schwer zu erweitern <br>  Neben der Verletzung der Kompatibilität ist es beispielsweise unmöglich, eine Liste von untergeordneten Elementen nach einem bestimmten Kriterium zu erhalten.  Um diese Funktionalität hinzuzufügen, müssen Sie auf die nächste Version warten oder eine andere Methode erstellen. </li><li>  Kopieren Sie alle Elemente <br>  Oft müssen Sie nur die Liste aller untergeordneten Elemente durchgehen, die nach einem bestimmten Kriterium gefiltert wurden.  Zu diesem Zweck ist es nicht erforderlich, einen Container mit Zeigern auf alle diese Elemente zurückzugeben. </li><li>  Mögliche <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP-</a> Verletzung <br>  Dies ist ein ziemlich kontroverses Thema, aber die Notwendigkeit, die Klassenschnittstelle zu ändern, um beispielsweise eine Methode zum Überqueren von Kindern zu ändern, sieht seltsam aus. </li></ul><br><h2 id="ispolzovanie-range-v3-dlya-ustraneniya-nekotoryh-nedostatkov">  Verwenden Sie range-v3, um einige Fehler zu beheben </h2><br><p>  <a href="https://github.com/ericniebler/range-v3">range-v3</a> ist eine Bibliothek, die Komponenten zum Arbeiten mit Elementbereichen bereitstellt.  Tatsächlich ist dies eine zusätzliche Abstraktionsebene gegenüber klassischen Iteratoren, die es Ihnen ermöglicht, Operationen zu komponieren und von verzögerten Berechnungen zu profitieren. </p><br><p>  Es wird eine Bibliothek eines Drittanbieters verwendet, da dem Autor zum Zeitpunkt des Schreibens keine Compiler bekannt sind, die diese Funktionalität unterstützen.  Vielleicht ändert sich die Situation bald. </p><br><p>  Bei <code>QObject</code> mithilfe dieses Ansatzes die Operationen zum Durchlaufen des Baums der <code>QObject</code> Elemente von der Klasse trennen und eine flexible Schnittstelle zum Suchen von Objekten nach einem bestimmten Kriterium erstellen, die leicht geändert werden kann. </p><br><h3 id="primer-ispolzovaniya-ranges-v3">  Beispiel für Ranges-v3 </h3><br><p>  Betrachten Sie zunächst ein einfaches Beispiel für die Verwendung der Bibliothek.  Bevor wir mit dem Beispiel fortfahren, führen wir die Kurzschreibweise für Namespaces ein: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> r = ranges; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> v = r::views; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> a = r::actions;</code> </pre> <br><p>  Betrachten Sie nun ein Beispiel für ein Programm, das Würfel aller ungeraden Zahlen im Intervall [1, 10) in umgekehrter Reihenfolge ausgibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_odd = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pow3 = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(n, <span class="hljs-number"><span class="hljs-number">3</span></span>); }; <span class="hljs-comment"><span class="hljs-comment">//  [729,343,125,27,1] std::cout &lt;&lt; (v::ints(1, 10) | v::filter(is_odd) | v::transform(pow3) | v::reverse);</span></span></code> </pre> <br><p>  Es ist zu beachten, dass alle Berechnungen träge ablaufen, d.h.  Temporäre Datensätze werden nicht erstellt oder kopiert.  Das obige Programm entspricht dem, mit der Ausnahme, dass die Ausgabe formatiert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  729 343 125 27 1 for (int i = 9; i &gt; 0; --i) { if (i % 2 != 0) { std::cout &lt;&lt; std::pow(i, 3) &lt;&lt; " "; } }</span></span></code> </pre> <br><p>  Wie Sie dem obigen Beispiel entnehmen können, können Sie mit der Bibliothek verschiedene Operationen elegant zusammenstellen.  Weitere Verwendungsbeispiele finden Sie in den Verzeichnissen <code>tests</code> und <code>examples</code> des <a href="https://github.com/ericniebler/range-v3">range-v3-</a> Repository. </p><br><h3 id="klass-dlya-predstavleniya-posledovatelnosti-dochernih-elementov">  Klasse zur Darstellung einer Folge von Kindern </h3><br><p>  Die <code>range-v3</code> Bibliothek bietet Hilfsklassen zum Erstellen verschiedener benutzerdefinierter Wrapperklassen.  Darunter sind Klassen aus der Kategorie <code>view</code> .  Diese Klassen sollen eine Folge von Elementen auf eine bestimmte Weise darstellen, ohne die Folge selbst zu transformieren und zu kopieren.  Im vorherigen Beispiel wurde die <code>filter</code> verwendet, um nur die Elemente der Sequenz zu berücksichtigen, die den angegebenen Kriterien entsprechen. </p><br><p>  Um eine solche Klasse für die Arbeit mit untergeordneten QObject-Elementen zu erstellen, muss sie von den Hilfsklassenbereichen <code>ranges::view_facade</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt::detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">children_view</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> r::view_facade&lt;children_view&lt;T&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//   friend r::range_access; //   ,       T *obj; //    (  ) Qt::FindChildOptions opts; //  --    cursor begin_cursor() { return cursor(obj, opts); } public: //  }; } // namespace qt::detail</span></span></code> </pre> <br><p>  Es ist zu beachten, dass die Klasse automatisch die Methode <code>end_cursor</code> definiert, die das Vorzeichen des Endes der Sequenz zurückgibt.  Bei Bedarf kann diese Methode überschrieben werden. </p><br><p>  Als nächstes definieren wir die Cursorklasse selbst.  Dies kann sowohl in der Klasse <code>children_view</code> als auch darüber hinaus erfolgen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cursor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,      std::shared_ptr&lt;ObjectVector&gt; children; //    std::size_t current_index = 0; //       decltype(auto) read() const { return (*children)[current_index]; } //     void next() { ++current_index; } //     auto equal(ranges::default_sentinel_t) const { return current_index == children-&gt;size(); } //  };</span></span></code> </pre> <br><p>  Der oben definierte Cursor ist Single-Pass.  Dies bedeutet, dass sich die Sequenz nur in eine Richtung und nur einmal bewegen darf.  Für diese Implementierung ist dies nicht notwendig, weil  Wir speichern eine Sequenz aller untergeordneten Objekte und können sie beliebig oft durchlaufen.  Um anzuzeigen, dass Sie eine Sequenz mehrmals durchlaufen können, müssen Sie die folgende Methode in der Cursorklasse implementieren: </p><br><pre> <code class="plaintext hljs">auto equal(const cursor &amp;that) const { return current_index == that.current_index; }</code> </pre> <br><p>  Jetzt müssen Sie hinzufügen, um sicherzustellen, dass die erstellte Ansicht in die Komposition aufgenommen werden kann.  Verwenden Sie dazu die Hilfsfunktionsbereiche <code>ranges::make_pipeable</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = r::make_pipeable([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::children_view(o); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_children</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Qt::FindChildOptions opts = Qt::FindChildrenRecursively)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r::make_pipeable([opts](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::children_view(o, opts); }); } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt</span></span></code> </pre> <br><p>  Jetzt können Sie diesen Code schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;c : root | qt::children) { <span class="hljs-comment"><span class="hljs-comment">//     () } for (auto &amp;&amp;c : root | qt::find_children(Qt::FindDirectChildrenOnly)) { //     }</span></span></code> </pre> <br><h3 id="realizaciya-suschestvuyuschey-funkcionalnosti-klassa-qobject">  Implementieren der vorhandenen QObject-Klassenfunktionalität </h3><br><p>  Nach der Implementierung der Präsentationsklasse können Sie problemlos alle Funktionen für die Arbeit mit Kindern implementieren.  Dazu müssen Sie drei Funktionen implementieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with_type</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">:</span></span>:filter([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ObjType = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_cv_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_pointer_t</span></span>&lt;T&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjType::staticMetaObject.cast(o); }) | v::transform([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&gt;(o); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v::filter([name](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj-&gt;objectName() == name; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_re</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QRegularExpression &amp;re)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v::filter([re](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re.match(obj-&gt;objectName()).hasMatch(); }); } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt</span></span></code> </pre> <br><p>  Betrachten Sie als Verwendungsbeispiel den folgenden Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;c : root | qt::children | qt::with_type&lt;Foo*&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       Foo }</span></span></code> </pre> <br><h3 id="promezhutochnye-vyvody">  Zwischenfazit </h3><br><p>  Wie der Code erkennen lässt, ist es jetzt ganz einfach, die Funktionalität zu erweitern, ohne die Klassenschnittstelle zu ändern.  Darüber hinaus werden alle Operationen durch separate Funktionen dargestellt und können in der gewünschten Reihenfolge angeordnet werden.  Dies verbessert unter anderem die Lesbarkeit des Codes und vermeidet die Verwendung von Funktionen mit mehreren Parametern in der Klassenschnittstelle.  Erwähnenswert ist auch das Entladen der Klassenschnittstelle und die Reduzierung der Gründe für deren Änderung. </p><br><p>  Tatsächlich beseitigt diese Implementierung bereits fast alle aufgeführten Nachteile der Schnittstelle, mit der Ausnahme, dass noch alle untergeordneten Elemente in den Container kopiert werden müssen.  Eine Möglichkeit, dieses Problem zu lösen, ist die Verwendung von Coroutinen. </p><br><h2 id="lenivaya-realizaciya-obhoda-dereva-obektov-s-ispolzovaniem-soprogramm">  Verzögerte Implementierung der Objektbaumüberquerung mit Hilfe von Coroutinen </h2><br><p>  <a href="https://en.cppreference.com/w/cpp/language/coroutines">Mit</a> Coroutinen (Coroutinen) können Sie die Funktion <a href="https://en.cppreference.com/w/cpp/language/coroutines">anhalten</a> und später fortsetzen.  Sie können diese Technologie als eine Art Zustandsmaschine betrachten. </p><br><p>  Zum Zeitpunkt des Schreibens fehlen der Standardbibliothek viele wichtige Elemente, die für die komfortable Verwendung von Coroutinen erforderlich sind.  Daher wird vorgeschlagen, eine <a href="https://github.com/lewissbaker/cppcoro">cppcoro-</a> Bibliothek eines Drittanbieters zu verwenden, die wahrscheinlich in der einen oder anderen Form in den Standard aufgenommen wird. </p><br><p>  Zunächst werden wir Funktionen schreiben, die das nächste Kind auf Anfrage zurückgeben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt::detail { cppcoro::recursive_generator&lt;QObject*&gt; takeChildRecursivelyImpl( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QObjectList &amp;children, Qt::FindChildOptions opts) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (QObject *c : children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opts == Qt::FindChildrenRecursively) { <span class="hljs-function"><span class="hljs-function">co_yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeChildRecursivelyImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c-&gt;children(), opts)</span></span></span></span>; } co_yield c; } } cppcoro::recursive_generator&lt;QObject*&gt; takeChildRecursively( QObject *root, Qt::FindChildOptions opts = Qt::FindChildrenRecursively) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root) { <span class="hljs-function"><span class="hljs-function">co_yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeChildRecursivelyImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(root-&gt;children(), opts)</span></span></span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt::detail</span></span></code> </pre> <br><p>  Die Anweisung <code>co_yield</code> gibt den Wert an den aufrufenden Code zurück und hält die Coroutine an. </p><br><p>  Integrieren Sie nun diesen Code in die Klasse <code>children_view</code> .  Der folgende Code zeigt nur die Elemente an, die geändert wurden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   children_view //   Data{obj, takeChildRecursively(obj, opts)} struct Data { T *obj; cppcoro::recursive_generator&lt;QObject*&gt; gen; }; std::shared_ptr&lt;Data&gt; m_data; // ... cursor begin_cursor() { return cursor(m_data-&gt;gen.begin()); }</span></span></code> </pre> <br><p>  Der Cursor muss auch geändert werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">children_view</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:cursor { cppcoro::recursive_generator&lt;QObject*&gt;::iterator it; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) read() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *it; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ++it; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ranges::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default_sentinel_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it == cppcoro::recursive_generator&lt;QObject*&gt;::iterator(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cppcoro::recursive_generator&lt;QObject*&gt;::iterator it)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">it</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(it)</span></span></span><span class="hljs-function"> </span></span>{} cursor() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br><p>  Der Cursor fungiert hier einfach als Wrapper um einen regulären Iterator.  Der Rest des Codes kann unverändert verwendet werden, ohne dass zusätzliche Änderungen erforderlich sind. </p><br><h3 id="opasnosti-lenivogo-obhoda-dereva">  Die Gefahren fauler Baumspaziergänge </h3><br><p>  Es ist erwähnenswert, dass das träge Durchqueren des Kinderbaums nicht immer sicher ist.  Dies bezieht sich hauptsächlich auf die Umgehung komplexer Hierarchien von grafischen Elementen, z. B. Widgets.  Tatsache ist, dass beim Durchlaufen die Hierarchie neu aufgebaut werden kann und einige Elemente vollständig entfernt werden.  Wenn Sie in diesem Fall eine verzögerte Problemumgehung verwenden, können Sie sehr interessante und unvorhersehbare Ergebnisse des Programms erhalten. </p><br><p>  Dies bedeutet, dass es in einigen Fällen sinnvoll ist, alle Elemente in einen Container zu kopieren.  Dazu können Sie die folgende Hilfsfunktion verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = ranges::to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&gt;(root | qt::children);</code> </pre> <br><p>  Genau genommen müssen in diesem Fall keine Coroutinen verwendet werden, und Sie können die Ansicht ab der ersten Iteration verwenden. </p><br><h2 id="budet-li-eto-v-qt">  Wird es in Qt sein? </h2><br><p>  Vielleicht, aber nicht in der nächsten Version.  Dafür gibt es mehrere Gründe: </p><br><ul><li>  Die nächste Hauptversion, Qt 6, wird offiziell C ++ 17 erfordern und unterstützen, jedoch nicht höher. </li><li>  Ohne Bibliotheken von Drittanbietern ist eine Implementierung nicht möglich. </li><li>  Es wird relativ schwierig sein, die vorhandene Codebasis anzupassen. <br>  Höchstwahrscheinlich werden sie im Rahmen der Qt 7-Version zu diesem Problem zurückkehren. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die vorgeschlagene Implementierung des Durchlaufens des Baums untergeordneter Elemente erleichtert das Hinzufügen neuer Funktionen.  Durch die Trennung von Operationen wird das Schreiben von saubererem Code und das Entfernen unnötiger Elemente von der Klassenschnittstelle erreicht. </p><br><p>  Es ist anzumerken, dass beide verwendeten Bibliotheken (range-v3 und cpp-coro) als Header-Dateien geliefert werden, was den Erstellungsprozess vereinfacht.  Auf Fremdbibliotheken kann künftig überhaupt noch verzichtet werden. </p><br><p>  Der beschriebene Ansatz weist jedoch einige Nachteile auf.  Darunter ist die für viele Entwickler ungewöhnliche Syntax, die relative Komplexität der Implementierung und die Faulheit zu bemerken, die in einigen Fällen gefährlich sein können. </p><br><h2 id="dopolnitelno">  Optional </h2><br><p>  <a href="https://github.com/vt4a2h/qobject-with-ranges-mirror">Quellcode</a> </p><br><p>  Besonderer Dank geht an Misha Svetkin ( <a href="https://habr.com/ru/users/trilla/" class="user_link">Trilla</a> ) für seinen Beitrag zur Umsetzung und Diskussion des Projekts. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481402/">https://habr.com/ru/post/de481402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481388/index.html">Wie Kryptowährungsbörsen ihre Blockchains aufbauen, die DeFi trotzen</a></li>
<li><a href="../de481390/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 490 (12/03/2019 - 09/12/2019)</a></li>
<li><a href="../de481392/index.html">Da habe ich eine zentralisierte Kryptowährung in PHP geschrieben. (Teil 1 - Grundlegende Zusammenfassungen + Schnellstart)</a></li>
<li><a href="../de481394/index.html">Neuerstellung in einem neuen Spiel, was wir für das alte geliebt haben</a></li>
<li><a href="../de481398/index.html">Grundlegende Linux-Befehle für Tester und mehr</a></li>
<li><a href="../de481406/index.html">Tiefes Eintauchen in die Investition von Ilona Mask</a></li>
<li><a href="../de481416/index.html">Ankündigung des zweiten AWS Meetups in Minsk (13.02.2020)</a></li>
<li><a href="../de481418/index.html">Wie der Videocodec funktioniert. Teil 1. Grundlagen</a></li>
<li><a href="../de481420/index.html">15 besten und größten Icon-Bibliotheken</a></li>
<li><a href="../de481424/index.html">Benutzerdefinierte Steuerelemente im Winkel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>