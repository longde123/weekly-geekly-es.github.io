<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôâÔ∏è üôÖüèø üë®üèª‚Äçüé§ Versp√§tete Implementierung des Durchlaufens eines untergeordneten Baums der QObject-Klasse ü§òüèæ üëö üë©üèΩ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einleitung 


 Der Artikel beschreibt die verz√∂gerte Implementierung von Tree Traversal in C ++ mithilfe von Coroutinen und Bereichen am Beispiel der ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Versp√§tete Implementierung des Durchlaufens eines untergeordneten Baums der QObject-Klasse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481402/"><h2 id="vvedenie">  Einleitung </h2><br><p> Der Artikel beschreibt die verz√∂gerte Implementierung von Tree Traversal in C ++ mithilfe von Coroutinen und Bereichen am Beispiel der Verbesserung der Schnittstelle f√ºr die Arbeit mit <code>QObject</code> der <code>QObject</code> Klasse aus dem Qt-Framework.  Die Erstellung einer benutzerdefinierten Ansicht f√ºr die Arbeit mit untergeordneten Elementen wird detailliert betrachtet, und es werden verz√∂gerte und klassische Implementierungen angegeben.  Am Ende des Artikels befindet sich ein Link zum Repository mit dem vollst√§ndigen Quellcode. </p><a name="habracut"></a><br><h2 id="ob-avtore">  √úber den Autor </h2><br><p>  Ich arbeite als Senior Developer im norwegischen B√ºro von The Qt Company.  Ich habe Widgets und QtQuick-Elemente entwickelt, vor kurzem Qt Core.  Ich benutze C ++ und bin ein bisschen an funktionaler Programmierung interessiert.  Manchmal erstelle ich Berichte und schreibe Artikel. </p><br><h2 id="chto-takoe-qt">  Was ist Qt </h2><br><p>  <a href="https://wiki.qt.io/About_Qt">Qt</a> ist ein plattform√ºbergreifendes Framework zum Erstellen grafischer Benutzeroberfl√§chen (GUIs).  Neben Modulen zum Erstellen einer GUI enth√§lt Qt viele Module zum Entwickeln von Anwendungssoftware.  Das Framework wurde haupts√§chlich in der Programmiersprache C ++ entwickelt. Einige Komponenten verwenden <a href="https://doc.qt.io/qt-5/qmlapplications.html">QML</a> und <a href="https://doc.qt.io/qt-5/qtqml-javascript-expressions.html">JavaScript</a> . </p><br><h2 id="klass-qobject">  QObject-Klasse </h2><br><p>  <a href="https://doc.qt.io/qt-5/qobject.html">QObject</a> ist die Klasse, um die das Qt-Objektmodell aufgebaut ist.  Von <code>QObject</code> geerbte <code>QObject</code> k√∂nnen im Slot-Signalmodell und in der Ereignisschleife verwendet werden.  Dar√ºber hinaus k√∂nnen Sie mit <code>QObject</code> auf Informationen zu <code>QObject</code> zugreifen und Objekte in Baumstrukturen organisieren. </p><br><h2 id="drevovidnaya-struktura-qobject">  QObject Baumstruktur </h2><br><p>  Die Verwendung einer <a href="https://doc.qt.io/qt-5/objecttrees.html">Baumstruktur</a> bedeutet, dass jedes <code>QObject</code> Objekt ein √ºbergeordnetes Objekt und null oder mehr <code>QObject</code> Objekte haben kann.  Das √ºbergeordnete Objekt steuert die Lebensdauer der untergeordneten Objekte.  Im folgenden Beispiel werden zwei untergeordnete Elemente automatisch gel√∂scht: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> parent = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;QObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> onDestroyed = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> obj){ qDebug(<span class="hljs-string"><span class="hljs-string">"Object %p destroyed."</span></span>, obj); }; QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QObject(parent.get()), &amp;QObject::destroyed, onDestroyed); QObject::connect(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QObject(parent.get()), &amp;QObject::destroyed, onDestroyed); <span class="hljs-comment"><span class="hljs-comment">//      </span></span></code> </pre> <br><p>  Leider funktioniert der Gro√üteil der Qt-API bisher nur mit rohen Zeigern.  Wir arbeiten daran, und vielleicht wird sich die Situation bald zumindest teilweise zum Besseren wenden. </p><br><p>  √úber die <code>QObject</code> Klassenschnittstelle k√∂nnen Sie eine Liste aller <code>QObject</code> Objekte <code>QObject</code> und nach bestimmten Kriterien suchen.  Betrachten Sie das Beispiel zum Abrufen einer Liste aller untergeordneten Objekte: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> parent = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;QObject&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  10   for (std::size_t i = 0; i &lt; 10; ++i) { auto obj = new QObject(parent.get()); obj-&gt;setObjectName(QStringLiteral("Object %1").arg(i)); } const auto&amp; children = parent-&gt;children(); qDebug() &lt;&lt; children; // =&gt; (QObject(0x1f7ffa0, name = "Object 0"), ...) qDebug() &lt;&lt; children.count(); // =&gt; 10</span></span></code> </pre> <br><p>  Die <code>QObject::children</code> Methode gibt eine Liste aller <code>QObject::children</code> des angegebenen Objekts zur√ºck.  Oft ist jedoch eine Suche innerhalb des gesamten Teilbaums von Objekten nach einem bestimmten Kriterium erforderlich: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = parent-&gt;findChildren&lt;QObject&gt;(QRegularExpression(<span class="hljs-string"><span class="hljs-string">"0$"</span></span>)); qDebug() &lt;&lt; children.count();</code> </pre> <br><p>  Das obige Beispiel zeigt, wie Sie eine Liste aller <code>QObject</code> Typs <code>QObject</code> deren Name auf 0 endet. Im Gegensatz zur Methode <code>findChildren</code> durchl√§uft die Methode <code>findChildren</code> den Baum rekursiv, <code>findChildren</code> wird die gesamte Hierarchie der Objekte durchsucht.  Dieses Verhalten kann durch √úbergeben des <code>Qt::FindDirectChildrenOnly</code> ge√§ndert werden. </p><br><h2 id="nedostatki-interfeysa-raboty-s-dochernimi-elementami">  Nachteile der Schnittstelle f√ºr die Arbeit mit untergeordneten Elementen </h2><br><p>  Auf den ersten Blick scheint die Oberfl√§che f√ºr die Arbeit mit Kindern gut durchdacht und flexibel zu sein.  Er ist jedoch nicht ohne M√§ngel.  Betrachten wir einige davon: </p><br><ul><li>  Redundante Schnittstelle <br>  Es gibt zwei verschiedene <code>findChildren</code> Methoden (es gab drei vor nicht allzu langer Zeit): die <code>findChild</code> Methode zum Suchen eines Elements und die <code>findChild</code> Methode.  Sie alle √ºberlappen sich teilweise. </li><li>  Die Schnittstelle ist schwer zu √§ndern <br>  Qt garantiert Bin√§rkompatibilit√§t und Kompatibilit√§t auf Quellcodeebene in einer einzigen Hauptversion.  Daher k√∂nnen Sie nicht einfach die Signatur einer Methode √§ndern oder neue Methoden hinzuf√ºgen. </li><li>  Die Schnittstelle ist schwer zu erweitern <br>  Neben der Verletzung der Kompatibilit√§t ist es beispielsweise unm√∂glich, eine Liste von untergeordneten Elementen nach einem bestimmten Kriterium zu erhalten.  Um diese Funktionalit√§t hinzuzuf√ºgen, m√ºssen Sie auf die n√§chste Version warten oder eine andere Methode erstellen. </li><li>  Kopieren Sie alle Elemente <br>  Oft m√ºssen Sie nur die Liste aller untergeordneten Elemente durchgehen, die nach einem bestimmten Kriterium gefiltert wurden.  Zu diesem Zweck ist es nicht erforderlich, einen Container mit Zeigern auf alle diese Elemente zur√ºckzugeben. </li><li>  M√∂gliche <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP-</a> Verletzung <br>  Dies ist ein ziemlich kontroverses Thema, aber die Notwendigkeit, die Klassenschnittstelle zu √§ndern, um beispielsweise eine Methode zum √úberqueren von Kindern zu √§ndern, sieht seltsam aus. </li></ul><br><h2 id="ispolzovanie-range-v3-dlya-ustraneniya-nekotoryh-nedostatkov">  Verwenden Sie range-v3, um einige Fehler zu beheben </h2><br><p>  <a href="https://github.com/ericniebler/range-v3">range-v3</a> ist eine Bibliothek, die Komponenten zum Arbeiten mit Elementbereichen bereitstellt.  Tats√§chlich ist dies eine zus√§tzliche Abstraktionsebene gegen√ºber klassischen Iteratoren, die es Ihnen erm√∂glicht, Operationen zu komponieren und von verz√∂gerten Berechnungen zu profitieren. </p><br><p>  Es wird eine Bibliothek eines Drittanbieters verwendet, da dem Autor zum Zeitpunkt des Schreibens keine Compiler bekannt sind, die diese Funktionalit√§t unterst√ºtzen.  Vielleicht √§ndert sich die Situation bald. </p><br><p>  Bei <code>QObject</code> mithilfe dieses Ansatzes die Operationen zum Durchlaufen des Baums der <code>QObject</code> Elemente von der Klasse trennen und eine flexible Schnittstelle zum Suchen von Objekten nach einem bestimmten Kriterium erstellen, die leicht ge√§ndert werden kann. </p><br><h3 id="primer-ispolzovaniya-ranges-v3">  Beispiel f√ºr Ranges-v3 </h3><br><p>  Betrachten Sie zun√§chst ein einfaches Beispiel f√ºr die Verwendung der Bibliothek.  Bevor wir mit dem Beispiel fortfahren, f√ºhren wir die Kurzschreibweise f√ºr Namespaces ein: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> r = ranges; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> v = r::views; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> a = r::actions;</code> </pre> <br><p>  Betrachten Sie nun ein Beispiel f√ºr ein Programm, das W√ºrfel aller ungeraden Zahlen im Intervall [1, 10) in umgekehrter Reihenfolge ausgibt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> is_odd = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pow3 = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(n, <span class="hljs-number"><span class="hljs-number">3</span></span>); }; <span class="hljs-comment"><span class="hljs-comment">//  [729,343,125,27,1] std::cout &lt;&lt; (v::ints(1, 10) | v::filter(is_odd) | v::transform(pow3) | v::reverse);</span></span></code> </pre> <br><p>  Es ist zu beachten, dass alle Berechnungen tr√§ge ablaufen, d.h.  Tempor√§re Datens√§tze werden nicht erstellt oder kopiert.  Das obige Programm entspricht dem, mit der Ausnahme, dass die Ausgabe formatiert wird: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  729 343 125 27 1 for (int i = 9; i &gt; 0; --i) { if (i % 2 != 0) { std::cout &lt;&lt; std::pow(i, 3) &lt;&lt; " "; } }</span></span></code> </pre> <br><p>  Wie Sie dem obigen Beispiel entnehmen k√∂nnen, k√∂nnen Sie mit der Bibliothek verschiedene Operationen elegant zusammenstellen.  Weitere Verwendungsbeispiele finden Sie in den Verzeichnissen <code>tests</code> und <code>examples</code> des <a href="https://github.com/ericniebler/range-v3">range-v3-</a> Repository. </p><br><h3 id="klass-dlya-predstavleniya-posledovatelnosti-dochernih-elementov">  Klasse zur Darstellung einer Folge von Kindern </h3><br><p>  Die <code>range-v3</code> Bibliothek bietet Hilfsklassen zum Erstellen verschiedener benutzerdefinierter Wrapperklassen.  Darunter sind Klassen aus der Kategorie <code>view</code> .  Diese Klassen sollen eine Folge von Elementen auf eine bestimmte Weise darstellen, ohne die Folge selbst zu transformieren und zu kopieren.  Im vorherigen Beispiel wurde die <code>filter</code> verwendet, um nur die Elemente der Sequenz zu ber√ºcksichtigen, die den angegebenen Kriterien entsprechen. </p><br><p>  Um eine solche Klasse f√ºr die Arbeit mit untergeordneten QObject-Elementen zu erstellen, muss sie von den Hilfsklassenbereichen <code>ranges::view_facade</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt::detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">children_view</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> r::view_facade&lt;children_view&lt;T&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//   friend r::range_access; //   ,       T *obj; //    (  ) Qt::FindChildOptions opts; //  --    cursor begin_cursor() { return cursor(obj, opts); } public: //  }; } // namespace qt::detail</span></span></code> </pre> <br><p>  Es ist zu beachten, dass die Klasse automatisch die Methode <code>end_cursor</code> definiert, die das Vorzeichen des Endes der Sequenz zur√ºckgibt.  Bei Bedarf kann diese Methode √ºberschrieben werden. </p><br><p>  Als n√§chstes definieren wir die Cursorklasse selbst.  Dies kann sowohl in der Klasse <code>children_view</code> als auch dar√ºber hinaus erfolgen: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cursor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,      std::shared_ptr&lt;ObjectVector&gt; children; //    std::size_t current_index = 0; //       decltype(auto) read() const { return (*children)[current_index]; } //     void next() { ++current_index; } //     auto equal(ranges::default_sentinel_t) const { return current_index == children-&gt;size(); } //  };</span></span></code> </pre> <br><p>  Der oben definierte Cursor ist Single-Pass.  Dies bedeutet, dass sich die Sequenz nur in eine Richtung und nur einmal bewegen darf.  F√ºr diese Implementierung ist dies nicht notwendig, weil  Wir speichern eine Sequenz aller untergeordneten Objekte und k√∂nnen sie beliebig oft durchlaufen.  Um anzuzeigen, dass Sie eine Sequenz mehrmals durchlaufen k√∂nnen, m√ºssen Sie die folgende Methode in der Cursorklasse implementieren: </p><br><pre> <code class="plaintext hljs">auto equal(const cursor &amp;that) const { return current_index == that.current_index; }</code> </pre> <br><p>  Jetzt m√ºssen Sie hinzuf√ºgen, um sicherzustellen, dass die erstellte Ansicht in die Komposition aufgenommen werden kann.  Verwenden Sie dazu die Hilfsfunktionsbereiche <code>ranges::make_pipeable</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt { <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = r::make_pipeable([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::children_view(o); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_children</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Qt::FindChildOptions opts = Qt::FindChildrenRecursively)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r::make_pipeable([opts](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> detail::children_view(o, opts); }); } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt</span></span></code> </pre> <br><p>  Jetzt k√∂nnen Sie diesen Code schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;c : root | qt::children) { <span class="hljs-comment"><span class="hljs-comment">//     () } for (auto &amp;&amp;c : root | qt::find_children(Qt::FindDirectChildrenOnly)) { //     }</span></span></code> </pre> <br><h3 id="realizaciya-suschestvuyuschey-funkcionalnosti-klassa-qobject">  Implementieren der vorhandenen QObject-Klassenfunktionalit√§t </h3><br><p>  Nach der Implementierung der Pr√§sentationsklasse k√∂nnen Sie problemlos alle Funktionen f√ºr die Arbeit mit Kindern implementieren.  Dazu m√ºssen Sie drei Funktionen implementieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">with_type</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v</span></span></span><span class="hljs-class">:</span></span>:filter([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ObjType = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_cv_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">remove_pointer_t</span></span>&lt;T&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ObjType::staticMetaObject.cast(o); }) | v::transform([](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;o){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;T&gt;(o); }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v::filter([name](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj-&gt;objectName() == name; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">by_re</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QRegularExpression &amp;re)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v::filter([re](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re.match(obj-&gt;objectName()).hasMatch(); }); } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt</span></span></code> </pre> <br><p>  Betrachten Sie als Verwendungsbeispiel den folgenden Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;&amp;c : root | qt::children | qt::with_type&lt;Foo*&gt;) { <span class="hljs-comment"><span class="hljs-comment">//       Foo }</span></span></code> </pre> <br><h3 id="promezhutochnye-vyvody">  Zwischenfazit </h3><br><p>  Wie der Code erkennen l√§sst, ist es jetzt ganz einfach, die Funktionalit√§t zu erweitern, ohne die Klassenschnittstelle zu √§ndern.  Dar√ºber hinaus werden alle Operationen durch separate Funktionen dargestellt und k√∂nnen in der gew√ºnschten Reihenfolge angeordnet werden.  Dies verbessert unter anderem die Lesbarkeit des Codes und vermeidet die Verwendung von Funktionen mit mehreren Parametern in der Klassenschnittstelle.  Erw√§hnenswert ist auch das Entladen der Klassenschnittstelle und die Reduzierung der Gr√ºnde f√ºr deren √Ñnderung. </p><br><p>  Tats√§chlich beseitigt diese Implementierung bereits fast alle aufgef√ºhrten Nachteile der Schnittstelle, mit der Ausnahme, dass noch alle untergeordneten Elemente in den Container kopiert werden m√ºssen.  Eine M√∂glichkeit, dieses Problem zu l√∂sen, ist die Verwendung von Coroutinen. </p><br><h2 id="lenivaya-realizaciya-obhoda-dereva-obektov-s-ispolzovaniem-soprogramm">  Verz√∂gerte Implementierung der Objektbaum√ºberquerung mit Hilfe von Coroutinen </h2><br><p>  <a href="https://en.cppreference.com/w/cpp/language/coroutines">Mit</a> Coroutinen (Coroutinen) k√∂nnen Sie die Funktion <a href="https://en.cppreference.com/w/cpp/language/coroutines">anhalten</a> und sp√§ter fortsetzen.  Sie k√∂nnen diese Technologie als eine Art Zustandsmaschine betrachten. </p><br><p>  Zum Zeitpunkt des Schreibens fehlen der Standardbibliothek viele wichtige Elemente, die f√ºr die komfortable Verwendung von Coroutinen erforderlich sind.  Daher wird vorgeschlagen, eine <a href="https://github.com/lewissbaker/cppcoro">cppcoro-</a> Bibliothek eines Drittanbieters zu verwenden, die wahrscheinlich in der einen oder anderen Form in den Standard aufgenommen wird. </p><br><p>  Zun√§chst werden wir Funktionen schreiben, die das n√§chste Kind auf Anfrage zur√ºckgeben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> qt::detail { cppcoro::recursive_generator&lt;QObject*&gt; takeChildRecursivelyImpl( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QObjectList &amp;children, Qt::FindChildOptions opts) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (QObject *c : children) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opts == Qt::FindChildrenRecursively) { <span class="hljs-function"><span class="hljs-function">co_yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeChildRecursivelyImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c-&gt;children(), opts)</span></span></span></span>; } co_yield c; } } cppcoro::recursive_generator&lt;QObject*&gt; takeChildRecursively( QObject *root, Qt::FindChildOptions opts = Qt::FindChildrenRecursively) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (root) { <span class="hljs-function"><span class="hljs-function">co_yield </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">takeChildRecursivelyImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(root-&gt;children(), opts)</span></span></span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// namespace qt::detail</span></span></code> </pre> <br><p>  Die Anweisung <code>co_yield</code> gibt den Wert an den aufrufenden Code zur√ºck und h√§lt die Coroutine an. </p><br><p>  Integrieren Sie nun diesen Code in die Klasse <code>children_view</code> .  Der folgende Code zeigt nur die Elemente an, die ge√§ndert wurden: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   children_view //   Data{obj, takeChildRecursively(obj, opts)} struct Data { T *obj; cppcoro::recursive_generator&lt;QObject*&gt; gen; }; std::shared_ptr&lt;Data&gt; m_data; // ... cursor begin_cursor() { return cursor(m_data-&gt;gen.begin()); }</span></span></code> </pre> <br><p>  Der Cursor muss auch ge√§ndert werden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">children_view</span></span></span><span class="hljs-class">&lt;T&gt;:</span></span>:cursor { cppcoro::recursive_generator&lt;QObject*&gt;::iterator it; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) read() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *it; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ++it; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ranges::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">default_sentinel_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it == cppcoro::recursive_generator&lt;QObject*&gt;::iterator(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cppcoro::recursive_generator&lt;QObject*&gt;::iterator it)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">it</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(it)</span></span></span><span class="hljs-function"> </span></span>{} cursor() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; };</code> </pre> <br><p>  Der Cursor fungiert hier einfach als Wrapper um einen regul√§ren Iterator.  Der Rest des Codes kann unver√§ndert verwendet werden, ohne dass zus√§tzliche √Ñnderungen erforderlich sind. </p><br><h3 id="opasnosti-lenivogo-obhoda-dereva">  Die Gefahren fauler Baumspazierg√§nge </h3><br><p>  Es ist erw√§hnenswert, dass das tr√§ge Durchqueren des Kinderbaums nicht immer sicher ist.  Dies bezieht sich haupts√§chlich auf die Umgehung komplexer Hierarchien von grafischen Elementen, z. B. Widgets.  Tatsache ist, dass beim Durchlaufen die Hierarchie neu aufgebaut werden kann und einige Elemente vollst√§ndig entfernt werden.  Wenn Sie in diesem Fall eine verz√∂gerte Problemumgehung verwenden, k√∂nnen Sie sehr interessante und unvorhersehbare Ergebnisse des Programms erhalten. </p><br><p>  Dies bedeutet, dass es in einigen F√§llen sinnvoll ist, alle Elemente in einen Container zu kopieren.  Dazu k√∂nnen Sie die folgende Hilfsfunktion verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> children = ranges::to&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&gt;(root | qt::children);</code> </pre> <br><p>  Genau genommen m√ºssen in diesem Fall keine Coroutinen verwendet werden, und Sie k√∂nnen die Ansicht ab der ersten Iteration verwenden. </p><br><h2 id="budet-li-eto-v-qt">  Wird es in Qt sein? </h2><br><p>  Vielleicht, aber nicht in der n√§chsten Version.  Daf√ºr gibt es mehrere Gr√ºnde: </p><br><ul><li>  Die n√§chste Hauptversion, Qt 6, wird offiziell C ++ 17 erfordern und unterst√ºtzen, jedoch nicht h√∂her. </li><li>  Ohne Bibliotheken von Drittanbietern ist eine Implementierung nicht m√∂glich. </li><li>  Es wird relativ schwierig sein, die vorhandene Codebasis anzupassen. <br>  H√∂chstwahrscheinlich werden sie im Rahmen der Qt 7-Version zu diesem Problem zur√ºckkehren. </li></ul><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Die vorgeschlagene Implementierung des Durchlaufens des Baums untergeordneter Elemente erleichtert das Hinzuf√ºgen neuer Funktionen.  Durch die Trennung von Operationen wird das Schreiben von saubererem Code und das Entfernen unn√∂tiger Elemente von der Klassenschnittstelle erreicht. </p><br><p>  Es ist anzumerken, dass beide verwendeten Bibliotheken (range-v3 und cpp-coro) als Header-Dateien geliefert werden, was den Erstellungsprozess vereinfacht.  Auf Fremdbibliotheken kann k√ºnftig √ºberhaupt noch verzichtet werden. </p><br><p>  Der beschriebene Ansatz weist jedoch einige Nachteile auf.  Darunter ist die f√ºr viele Entwickler ungew√∂hnliche Syntax, die relative Komplexit√§t der Implementierung und die Faulheit zu bemerken, die in einigen F√§llen gef√§hrlich sein k√∂nnen. </p><br><h2 id="dopolnitelno">  Optional </h2><br><p>  <a href="https://github.com/vt4a2h/qobject-with-ranges-mirror">Quellcode</a> </p><br><p>  Besonderer Dank geht an Misha Svetkin ( <a href="https://habr.com/ru/users/trilla/" class="user_link">Trilla</a> ) f√ºr seinen Beitrag zur Umsetzung und Diskussion des Projekts. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481402/">https://habr.com/ru/post/de481402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481388/index.html">Wie Kryptow√§hrungsb√∂rsen ihre Blockchains aufbauen, die DeFi trotzen</a></li>
<li><a href="../de481390/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 490 (12/03/2019 - 09/12/2019)</a></li>
<li><a href="../de481392/index.html">Da habe ich eine zentralisierte Kryptow√§hrung in PHP geschrieben. (Teil 1 - Grundlegende Zusammenfassungen + Schnellstart)</a></li>
<li><a href="../de481394/index.html">Neuerstellung in einem neuen Spiel, was wir f√ºr das alte geliebt haben</a></li>
<li><a href="../de481398/index.html">Grundlegende Linux-Befehle f√ºr Tester und mehr</a></li>
<li><a href="../de481406/index.html">Tiefes Eintauchen in die Investition von Ilona Mask</a></li>
<li><a href="../de481416/index.html">Ank√ºndigung des zweiten AWS Meetups in Minsk (13.02.2020)</a></li>
<li><a href="../de481418/index.html">Wie der Videocodec funktioniert. Teil 1. Grundlagen</a></li>
<li><a href="../de481420/index.html">15 besten und gr√∂√üten Icon-Bibliotheken</a></li>
<li><a href="../de481424/index.html">Benutzerdefinierte Steuerelemente im Winkel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>