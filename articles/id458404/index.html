<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔁 🕷️ 😧 Transisi dari monolit ke layanan mikro: sejarah dan praktik 🤙🏾 🤦🏼 🤷🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam artikel ini saya akan berbicara tentang bagaimana proyek tempat saya bekerja berubah dari monolit besar menjadi seperangkat layanan mikro. 

 Pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transisi dari monolit ke layanan mikro: sejarah dan praktik</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/458404/"> Dalam artikel ini saya akan berbicara tentang bagaimana proyek tempat saya bekerja berubah dari monolit besar menjadi seperangkat layanan mikro. <br><br>  Proyek ini memulai sejarahnya sejak lama, pada awal tahun 2000. Versi pertama ditulis dalam Visual Basic 6. Seiring waktu, menjadi jelas bahwa pengembangan bahasa ini di masa depan akan sulit untuk didukung, karena IDE dan bahasa itu sendiri kurang berkembang.  Pada akhir 2000-an, diputuskan untuk beralih ke C # yang lebih menjanjikan.  Versi baru ditulis secara paralel dengan penyempurnaan dari yang lama, secara bertahap semakin banyak kode di .NET.  Backend di C # awalnya berfokus pada arsitektur layanan, namun, selama pengembangan, perpustakaan bersama dengan logika digunakan, dan layanan diluncurkan dalam satu proses tunggal.  Ternyata aplikasi tersebut, yang kami sebut "service monolith". <br><br>  Salah satu dari sedikit kelebihan bundel ini adalah kemampuan layanan untuk saling memanggil melalui API eksternal.  Ada prasyarat yang jelas untuk transisi ke layanan yang lebih benar, dan di masa depan, arsitektur layanan mikro. <br><br>  Kami memulai pekerjaan dekomposisi kami sekitar tahun 2015.  Kami belum mencapai kondisi ideal - ada bagian dari proyek besar yang sulit disebut monolit, tetapi mereka juga tidak terlihat seperti layanan mikro.  Namun, kemajuannya sangat besar. <br>  Saya akan berbicara tentang dia di artikel tersebut. <br><br><img src="https://habrastorage.org/webt/ha/af/ct/haafctbyxepfypvukpmypyt30ji.png"><br><a name="habracut"></a><br><h3>  Isi </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur dan masalah solusi yang ada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Harapan Layanan Mikro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah transisi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara beralih dari monolith ke layanan microser</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara pertama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara kedua</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara ketiga</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara keempat</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bekerja dengan DB</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cabang tabel yang ada</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Departemen pengolahan</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bekerja dengan kode sumber</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah infrastruktur</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Instalasi manual di lingkungan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Logging terpisah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menguji dan men-debug layanan terkait</a> </li></ul></li></ul><br><br><a name="1"></a><h3>  <b>Arsitektur dan masalah solusi yang ada</b> </h3><br>  Awalnya, arsitekturnya tampak sebagai berikut: UI adalah aplikasi terpisah, bagian monolitik ditulis dalam Visual Basic 6, aplikasi dalam .NET adalah seperangkat layanan terkait yang bekerja dengan database yang cukup besar. <br><br>  <b>Kekurangan dari solusi sebelumnya</b> <br><br>  <u>Satu titik kegagalan</u> <br>  Kami memiliki satu titik kegagalan: aplikasi .NET berjalan dalam satu proses.  Jika ada modul yang rusak, seluruh aplikasi gagal, dan Anda harus memulai ulang.  Karena kami mengotomatisasi sejumlah besar proses untuk pengguna yang berbeda, karena kegagalan pada salah satu dari mereka, beberapa tidak dapat bekerja selama beberapa waktu.  Dan dengan kesalahan perangkat lunak, redundansi juga tidak membantu. <br><br>  <u>Susunan perbaikan</u> <br>  Kelemahan ini agak bersifat organisasi.  Aplikasi kami memiliki banyak pelanggan, dan mereka semua ingin menyelesaikannya sesegera mungkin.  Sebelumnya, tidak mungkin melakukan hal ini secara paralel, dan semua pelanggan mengantri.  Proses ini menyebabkan efek negatif pada bisnis, karena mereka perlu membuktikan bahwa tugas mereka berharga.  Dan tim pengembangan menghabiskan waktu mengatur lineup ini.  Ini membutuhkan banyak waktu dan usaha, dan produk sebagai hasilnya tidak dapat berubah secepat dari dia. <br><br>  <u>Penggunaan sumber daya yang tidak pantas</u> <br>  Saat menempatkan layanan dalam satu proses, kami selalu sepenuhnya menyalin konfigurasi dari server ke server.  Kami ingin menempatkan layanan yang paling banyak dimuat secara terpisah agar tidak menyia-nyiakan sumber daya dan mendapatkan manajemen skema penempatan yang lebih fleksibel. <br><br>  <u>Sulit untuk memperkenalkan teknologi modern</u> <br>  Masalah yang umum bagi semua pengembang: ada keinginan untuk memperkenalkan teknologi modern ke dalam proyek, tetapi tidak ada kemungkinan.  Dengan solusi monolitik besar, setiap pembaruan perpustakaan saat ini, belum lagi transisi ke yang baru, berubah menjadi tugas yang agak sepele.  Butuh waktu lama untuk membuktikan kepada pemimpin tim bahwa itu akan membawa lebih banyak bonus daripada menghabiskan waktu. <br><br>  <u>Kesulitan mengeluarkan perubahan</u> <br>  Ini adalah masalah paling serius - kami mengeluarkan rilis setiap dua bulan. <br>  Setiap rilis berubah menjadi bencana nyata bagi bank, terlepas dari pengujian dan upaya pengembang.  Bisnis mengerti bahwa pada awal minggu beberapa fungsi tidak akan berfungsi untuknya.  Dan para pengembang mengerti bahwa mereka sedang menunggu satu minggu insiden serius. <br>  Setiap orang memiliki keinginan untuk mengubah situasi. <br><br><a name="2"></a><h3>  <b>Harapan Layanan Mikro</b> </h3><br>  <u>Pengiriman komponen berdasarkan ketersediaan.</u>  Pengiriman komponen begitu tersedia karena dekomposisi solusi dan pemisahan berbagai proses. <br><br>  <u>Tim makanan kecil.</u>  Ini penting karena tim besar yang mengerjakan monolit lama sulit dikelola.  Tim seperti itu dipaksa bekerja sesuai dengan proses yang ketat, tetapi saya menginginkan lebih banyak kreativitas dan kemandirian.  Hanya tim kecil yang mampu membelinya. <br><br>  <u>Isolasi layanan dalam proses terpisah.</u>  Idealnya, saya ingin mengisolasi dalam wadah, tetapi sejumlah besar layanan yang ditulis dalam .NET Framework hanya berjalan di bawah Windows.  Sekarang ada layanan di .NET Core, tetapi sejauh ini mereka sedikit. <br><br>  <u>Fleksibilitas Penempatan.</u>  Saya ingin menggabungkan layanan yang kami butuhkan, dan bukan sebagai kekuatan kode. <br><br>  <u>Penggunaan teknologi baru.</u>  Ini menarik bagi setiap programmer. <br><br><a name="3"></a><h3>  <b>Masalah transisi</b> </h3><br>  Tentu saja, jika itu sederhana untuk memecah monolith menjadi layanan microser, Anda tidak perlu membicarakannya di konferensi dan menulis artikel.  Dalam proses ini, ada banyak jebakan, saya akan menggambarkan yang utama yang mengganggu kita. <br><br>  <b>Masalah pertama</b> adalah tipikal kebanyakan monolit: koherensi logika bisnis.  Ketika kami menulis monolith, kami ingin menggunakan kembali kelas kami agar tidak menulis kode tambahan.  Dan ketika beralih ke layanan microser, ini menjadi masalah: semua kode terhubung cukup erat, dan sulit untuk memisahkan layanan. <br><br>  Pada saat awal pekerjaan, repositori memiliki lebih dari 500 proyek dan lebih dari 700 ribu baris kode.  Ini adalah solusi yang cukup besar dan <b>masalah kedua</b> .  Itu tidak mungkin untuk hanya mengambil dan membaginya menjadi layanan microser. <br><br>  <b>Masalah ketiga</b> adalah kurangnya infrastruktur yang diperlukan.  Bahkan, kami terlibat dalam menyalin kode sumber secara manual ke server. <br><br><a name="4"></a><h3>  <b>Cara beralih dari monolith ke layanan microser</b> </h3><br>  <u>Alokasi Layanan Mikro</u> <br><br>  Pertama, kami segera memutuskan untuk diri kami sendiri bahwa pemisahan layanan-layanan mikro adalah proses berulang.  Kami selalu diminta untuk melakukan pengembangan tugas bisnis secara paralel.  Bagaimana kita akan melakukan ini secara teknis sudah menjadi masalah kita.  Oleh karena itu, kami sedang mempersiapkan proses berulang.  Ini tidak akan bekerja secara berbeda jika Anda memiliki aplikasi besar, dan tidak siap untuk ditulis ulang dari awal. <br><br>  Metode apa yang kami gunakan untuk mengisolasi layanan mikro? <br><br><a name="5"></a>  <b>Cara pertama</b> adalah dengan mem-porting modul yang ada sebagai layanan.  Dalam hal ini, kami beruntung: sudah ada layanan formal yang bekerja pada protokol WCF.  Mereka diposting di majelis terpisah.  Kami memindahkannya secara terpisah, menambahkan peluncur kecil ke setiap unit.  Itu ditulis menggunakan perpustakaan Topshelf indah, yang memungkinkan Anda untuk menjalankan aplikasi baik sebagai layanan maupun sebagai konsol.  Ini nyaman untuk debugging, karena tidak ada proyek tambahan yang diperlukan dalam solusi. <br><br>  Layanan terhubung sesuai dengan logika bisnis, karena mereka menggunakan rakitan umum dan bekerja dengan database umum.  Sulit untuk memanggil mereka layanan mikro dalam bentuk murni mereka.  Namun demikian, kami dapat mengeluarkan layanan ini secara terpisah, dalam proses yang berbeda.  Ini sudah memungkinkan untuk mengurangi pengaruh mereka satu sama lain, mengurangi masalah dengan pengembangan paralel dan satu titik kegagalan. <br><br>  Membangun dengan host hanya satu baris kode di kelas Program.  Kami menyembunyikan Topshelf di kelas pembantu. <br><br><pre><code class="plaintext hljs">namespace RBA.Services.Accounts.Host { internal class Program { private static void Main(string[] args) { HostRunner&lt;Accounts&gt;.Run("RBA.Services.Accounts.Host"); } } }</code> </pre> <br><a name="6"></a>  <b>Cara kedua untuk mengisolasi layanan mikro:</b> buat mereka untuk memecahkan masalah baru.  Jika monolit tidak tumbuh pada saat yang sama, ini sudah sangat baik, yang berarti bahwa kita bergerak ke arah yang benar.  Untuk mengatasi masalah baru, kami mencoba melakukan layanan terpisah.  Jika ada peluang seperti itu, maka kami menciptakan lebih banyak layanan "kanonik" yang sepenuhnya mengendalikan model data mereka, sebuah basis data terpisah. <br><br>  Kami, seperti banyak orang, mulai dengan layanan otentikasi dan otorisasi.  Mereka sempurna untuk ini.  Mereka independen, sebagai suatu peraturan, mereka memiliki model data yang terpisah.  Mereka sendiri tidak berinteraksi dengan monolith, hanya dia berpaling kepada mereka untuk menyelesaikan beberapa masalah.  Pada layanan ini, Anda dapat memulai transisi ke arsitektur baru, men-debug infrastruktur pada mereka, mencoba beberapa pendekatan yang berkaitan dengan perpustakaan jaringan, dll.  Di organisasi kami, tidak ada tim yang tidak dapat membuat layanan otentikasi. <br><br><a name="7"></a>  <b>Cara ketiga untuk mengisolasi layanan microser</b> yang kami gunakan sedikit spesifik untuk kami.  Ini mengeluarkan logika bisnis dari lapisan UI.  Kami memiliki aplikasi UI desktop utama, seperti backend, ditulis dalam C #.  Pengembang secara berkala melakukan kesalahan dan dilakukan pada bagian UI dari logika yang seharusnya ada di backend dan digunakan kembali. <br><br>  Jika Anda melihat contoh nyata dari kode bagian UI, Anda dapat melihat bahwa sebagian besar solusi ini berisi logika bisnis nyata, yang berguna dalam proses lain, tidak hanya untuk membangun formulir UI. <br><br><img src="https://habrastorage.org/webt/7s/_e/rb/7s_erbatvtbzompywj94igyvwho.jpeg"><br><br>  Logika UI sebenarnya hanya ada beberapa baris terakhir.  Kami memindahkannya ke server sehingga kami dapat menggunakannya kembali, sehingga mengurangi UI dan mencapai arsitektur yang benar. <br><br><a name="8"></a>  <b>Cara keempat, yang paling penting untuk mengisolasi layanan mikro</b> , yang memungkinkan Anda mengurangi monolit, adalah menghapus layanan yang ada dengan pemrosesan.  Ketika kami mengeluarkan modul yang sudah ada, hasilnya tidak selalu menyenangkan bagi pengembang, dan proses bisnis sejak saat fungsi itu dibuat bisa menjadi usang.  Berkat refactoring, kami dapat mendukung proses bisnis baru karena persyaratan bisnis terus berubah.  Kami dapat meningkatkan kode sumber, menghapus cacat yang diketahui, membuat model data yang lebih baik.  Ada banyak keuntungan. <br><br>  Departemen layanan pemrosesan terkait erat dengan konsep konteks terbatas.  Ini adalah konsep dari desain berorientasi subjek.  Ini berarti bagian model domain di mana semua istilah dari satu bahasa didefinisikan secara unik.  Pertimbangkan konteks asuransi dan tagihan sebagai contoh.  Kami memiliki aplikasi monolitik, dan perlu untuk bekerja dengan akun di asuransi.  Kami mengharapkan pengembang untuk menemukan kelas "Akun" yang ada di majelis lain, membuat tautan ke sana dari kelas "Asuransi", dan kami akan mendapatkan kode kerja.  Prinsip KERING akan dihormati, tugas melalui penggunaan kode yang ada akan dilakukan lebih cepat. <br><br>  Akibatnya, ternyata konteks akun dan asuransi terhubung.  Ketika persyaratan baru muncul, koneksi ini akan mengganggu pengembangan, meningkatkan kompleksitas logika bisnis yang sudah kompleks.  Untuk mengatasi masalah ini, Anda perlu menemukan batasan antara konteks dalam kode dan menghapus pelanggarannya.  Misalnya, dalam konteks asuransi, sangat mungkin bahwa nomor rekening 20 digit dari Bank Sentral dan tanggal pembukaan rekening akan cukup. <br><br>  Untuk memisahkan konteks terbatas ini satu sama lain dan memulai proses ekstraksi layanan mikro dari solusi monolitik, kami menggunakan pendekatan seperti membuat API eksternal dalam aplikasi.  Jika kita tahu bahwa beberapa modul harus menjadi layanan mikro, entah bagaimana berubah dalam proses, maka kami segera membuat panggilan ke logika, yang termasuk dalam konteks terbatas lain, melalui panggilan eksternal.  Misalnya melalui REST atau WCF. <br><br>  Kami memutuskan sendiri bahwa kami tidak akan menghindari kode yang akan memerlukan transaksi terdistribusi.  Dalam kasus kami, ternyata cukup mudah untuk mematuhi aturan ini.  Kami masih belum menemukan situasi seperti itu ketika transaksi yang didistribusikan sangat dibutuhkan - konsistensi akhir antara modul cukup. <br><br>  Pertimbangkan contoh spesifik.  Kami memiliki konsep orkestra - konveyor, yang memproses esensi dari "aplikasi".  Dia bergantian menciptakan pelanggan, akun, dan kartu bank.  Jika klien dan akun berhasil dibuat, dan pembuatan kartu gagal, aplikasi tidak masuk ke status "berhasil" dan tetap dalam status "kartu tidak dibuat".  Di masa depan, aktivitas latar belakang akan mengambilnya dan mengakhirinya.  Sistem ini dalam keadaan tidak konsisten untuk beberapa waktu, tetapi ini, secara keseluruhan, cocok untuk kita. <br><br>  Namun, jika suatu situasi muncul ketika akan diperlukan untuk secara konsisten menyimpan bagian dari data, kami kemungkinan besar akan memperbesar layanan untuk memproses ini dalam satu proses. <br><br>  Mari kita perhatikan contoh alokasi layanan-mikro.  Bagaimana bisa relatif aman dibawa ke produksi?  Dalam contoh ini, kami memiliki bagian terpisah dari sistem - modul layanan gaji, salah satu bagian dari kode yang ingin kami buat layanan-mikro. <br><br><img src="https://habrastorage.org/webt/g2/kn/he/g2knhebep6zxxcl-14mfdxd6xow.jpeg"><br><br>  Pertama-tama, kami membuat microservice dengan menulis ulang kode.  Kami meningkatkan beberapa poin yang tidak sesuai dengan kami.  Kami menyadari persyaratan bisnis baru dari pelanggan.  Kami menambah bundel antara UI dan backend Gateway API, yang akan menyediakan penerusan panggilan. <br><br><img src="https://habrastorage.org/webt/g4/eo/sw/g4eoswb9nmxcoom9tbsug5quwsu.png"><br><br>  Selanjutnya, kami melepaskan konfigurasi ini ke dalam operasi, tetapi dalam keadaan pilot.  Sebagian besar pengguna kami masih bekerja dengan proses bisnis lama.  Untuk pengguna baru, kami sedang mengembangkan versi baru aplikasi monolitik yang proses ini tidak lagi mengandung.  Bahkan, kami memiliki banyak layanan monolith dan microser yang bekerja dalam bentuk pilot. <br><br><img src="https://habrastorage.org/webt/vw/hn/p3/vwhnp3x9xxb1qrnz9rqe-552mvs.jpeg"><br><br>  Dengan pilot yang sukses, kami memahami bahwa konfigurasi baru benar-benar operasional, kami dapat menghapus monolit lama dari persamaan dan meninggalkan konfigurasi baru di tempat solusi lama. <br><br><img src="https://habrastorage.org/webt/4w/pk/a3/4wpka3wcyexlk-ohyvab4vucbts.png"><br><br>  Secara total, kami menggunakan hampir semua metode yang ada untuk memisahkan kode sumber monolit.  Semuanya memungkinkan kita untuk mengurangi ukuran bagian aplikasi dan mentransfernya ke perpustakaan baru, membuat kode sumber yang lebih baik. <br><br><a name="9"></a><h3>  <b>Bekerja dengan DB</b> </h3><br>  Basis data dapat dibagi lebih buruk daripada kode sumber, karena mengandung tidak hanya skema saat ini, tetapi juga akumulasi data historis. <br><br>  Basis data kami, seperti banyak yang lainnya, memiliki kelemahan penting lainnya - ukurannya yang besar.  Basis data ini dirancang sesuai dengan logika bisnis monolit yang rumit, dan tautan telah terakumulasi di antara tabel dari berbagai konteks terbatas. <br><br>  Dalam kasus kami, untuk menyelesaikan semua masalah (database besar, banyak hubungan, kadang-kadang perbatasan tidak dapat dipahami antara tabel), masalah muncul di banyak proyek besar: menggunakan templat database bersama.  Data diambil dari tabel melalui tampilan, melalui replikasi, dan dikirim ke sistem lain di mana replikasi ini diperlukan.  Akibatnya, kami tidak dapat mengeluarkan tabel dalam skema terpisah, karena mereka digunakan secara aktif. <br><br>  Pemisahan membantu kita untuk memecah menjadi konteks terbatas dalam kode.  Ini biasanya memberi kita ide yang cukup bagus tentang bagaimana kita memecah data di tingkat basis data.  Kami memahami tabel mana yang terkait dengan satu konteks terbatas dan yang terkait dengan yang lain. <br><br>  Kami menerapkan dua cara global untuk mempartisi basis data: mempartisi tabel yang ada dan mempartisi dengan pemrosesan. <br><br>  Pemisahan tabel yang ada adalah metode yang baik untuk digunakan jika struktur data berkualitas tinggi, memenuhi persyaratan bisnis dan cocok untuk semua orang.  Dalam hal ini, kita bisa memilih tabel yang ada dalam skema terpisah. <br><br>  Departemen pemrosesan diperlukan ketika model bisnis telah banyak berubah dan tabel tidak lagi sepenuhnya memuaskan kita. <br><br><a name="10"></a>  <b>Pisahkan tabel yang ada.</b>  Kita perlu menentukan apa yang akan kita pisahkan.  Tanpa pengetahuan ini, tidak akan ada yang muncul darinya, dan di sini pemisahan konteks terbatas dalam kode akan membantu kita.  Sebagai aturan, jika dimungkinkan untuk memahami batas-batas konteks dalam kode sumber, menjadi jelas tabel mana yang harus dimasukkan dalam daftar untuk pemisahan. <br><br>  Bayangkan kita memiliki solusi di mana dua modul monolith berinteraksi dengan satu basis data.  Kita perlu memastikan bahwa hanya satu modul yang berinteraksi dengan bagian dari tabel yang terpisah, dan yang lainnya mulai berinteraksi dengannya melalui API.  Sebagai permulaan, cukup hanya entri yang dibuat melalui API.  Ini adalah kondisi yang diperlukan agar kita dapat berbicara tentang independensi layanan-layanan mikro.  Link membaca dapat tetap ada sampai ada masalah besar. <br><br><img src="https://habrastorage.org/webt/ed/tk/ea/edtkeafsmsewkmmwbaxh-nicpou.jpeg"><br><br>  Sebagai langkah selanjutnya, kita sudah dapat memilih bagian kode yang bekerja dengan tabel yang dapat dilepas dengan atau tanpa memproses ke dalam layanan mikro terpisah dan menjalankannya dalam proses terpisah, wadah.  Ini akan menjadi layanan terpisah dengan komunikasi dengan database monolith dan tabel-tabel yang tidak terkait langsung dengannya.  Monolith masih berinteraksi dengan bagian yang bisa dilepas untuk membaca. <br><br><img src="https://habrastorage.org/webt/39/xe/qp/39xeqpzjbsxcjtdxwh8_jgt4uxa.jpeg"><br><br>  Nanti kita akan menghapus koneksi ini, yaitu, membaca data aplikasi monolitik dari tabel yang terpisah juga akan ditransfer ke API. <br><br><img src="https://habrastorage.org/webt/qu/j9/hx/quj9hx6oj3ovg71xy_lge9ziovg.png"><br><br>  Selanjutnya, kami memilih dari database umum tabel yang hanya berfungsi dengan layanan microservice baru.  Kita dapat menempatkan tabel dalam skema terpisah atau bahkan dalam database fisik terpisah.  Ada koneksi untuk membaca antara microservice dan database monolith, tetapi tidak ada yang perlu dikhawatirkan, dalam konfigurasi ini dapat hidup untuk waktu yang lama. <br><br><img src="https://habrastorage.org/webt/os/uc/zq/osuczqkdtaoxzmdmii1oni3qhlm.png"><br><br>  Langkah terakhir adalah sepenuhnya menghapus semua koneksi.  Dalam hal ini, kami mungkin perlu memigrasikan data dari basis data utama.  Terkadang kami ingin menggunakan kembali dalam beberapa database beberapa data atau direktori yang direplikasi dari sistem eksternal.  Kami secara berkala bertemu ini. <br><br><img src="https://habrastorage.org/webt/9e/ws/m9/9ewsm976maj96yzqj_-atbml4ae.png"><br><br><a name="11"></a>  <b>Departemen pengolahan.</b>  Metode ini sangat mirip dengan yang pertama, hanya berjalan dalam urutan terbalik.  Kami segera memiliki database baru dan layanan microser baru yang berinteraksi dengan monolith melalui API.  Tetapi pada saat yang sama, masih ada satu set tabel database yang ingin kita hapus di masa depan.  Kami tidak lagi membutuhkannya, dalam model baru kami menggantinya. <br><br><img src="https://habrastorage.org/webt/fy/ic/jx/fyicjxxkjagnsd_acgimthenabs.png"><br><br>  Agar skema ini berfungsi, kemungkinan besar kita akan membutuhkan masa transisi. <br><br>  Ada dua pendekatan yang mungkin. <br><br>  <b>Pertama</b> : kami menduplikasi semua data dalam database baru dan lama.  Dalam hal ini, kami memiliki redundansi data, mungkin ada masalah dengan sinkronisasi.  Tetapi kemudian kita dapat mengambil dua pelanggan yang berbeda.  Satu akan bekerja dengan versi baru, yang lain dengan yang lama. <br><br>  <b>Kedua</b> : kami berbagi data sesuai dengan beberapa karakteristik bisnis.  Misalnya, dalam sistem kami ada 5 produk yang disimpan dalam database lama.  Keenam sebagai bagian dari tugas bisnis baru, kami memasukkan basis data baru.  Tetapi kami membutuhkan Gateway API, yang menyinkronkan data ini dan menunjukkan kepada klien ke mana dan apa yang harus diambil. <br><br>  Kedua pendekatan itu berfungsi, pilih sesuai situasi. <br><br>  Setelah kami memastikan bahwa semuanya berfungsi, bagian dari monolith yang berfungsi dengan struktur basis data lama dapat dinonaktifkan. <br><br><img src="https://habrastorage.org/webt/1j/tf/tg/1jtftgwoy_c-bcfa8yddp5whppc.png"><br><br>  Langkah terakhir adalah menghapus struktur data lama. <br><br><img src="https://habrastorage.org/webt/4r/4o/m_/4r4om_wgj3wwxi25mf45eg_umss.png"><br><br>  Kesimpulannya, kita dapat mengatakan bahwa kita memiliki masalah dengan database: sulit untuk bekerja dengannya dibandingkan dengan kode sumber, lebih sulit untuk dipisahkan, tetapi ini dapat dan harus dilakukan.  Kami menemukan beberapa cara yang memungkinkan ini dilakukan dengan cukup aman, namun lebih mudah untuk membuat kesalahan dengan data daripada dengan kode sumber. <br><br><a name="12"></a><h3>  <b>Bekerja dengan kode sumber</b> </h3><br>  Di sinilah diagram kode sumber terlihat ketika kami mulai menganalisis proyek monolitik. <br><br><img src="https://habrastorage.org/webt/wx/z2/2m/wxz22mn86ej9jfyhkjww7zmvnoe.png"><br><br>  Secara kondisional dapat dibagi menjadi tiga lapisan.  Ini adalah lapisan modul, plugin, layanan, dan aktivitas individual yang diluncurkan.  Bahkan, ini adalah titik masuk dalam solusi monolitik.  Mereka semua terikat erat dengan lapisan Common.  Itu logika bisnis yang dibagi antara layanan, dan banyak koneksi.  Setiap layanan dan plugin menggunakan hingga 10 atau lebih rakitan umum, tergantung pada ukuran dan hati nurani para pengembang. <br><br>  Kami beruntung, kami memiliki perpustakaan infrastruktur yang dapat digunakan secara terpisah. <br><br>  Kadang-kadang situasi muncul ketika beberapa objek umum tidak benar-benar milik lapisan ini, tetapi perpustakaan infrastruktur.  Ini diputuskan dengan mengganti nama. <br><br>  Paling prihatin dengan konteks terbatas.  Dulu bahwa 3-4 konteks dicampur bersama dalam satu perakitan umum dan digunakan satu sama lain dalam fungsi bisnis yang sama.  Itu perlu untuk memahami di mana ini dapat dibagi dan pada batas apa, dan apa yang harus dilakukan selanjutnya dengan memetakan pemisahan ini ke dalam kumpulan kode sumber. <br><br>  Kami telah merumuskan beberapa aturan untuk proses pemisahan kode. <br><br>  <b>Pertama</b> : kami tidak lagi ingin berbagi logika bisnis antara layanan, aktivitas, dan plugin.  Mereka ingin membuat logika bisnis independen dalam kerangka kerja layanan mikro.  Di sisi lain, layanan microser, dalam kasus ideal, dianggap sebagai layanan yang ada sepenuhnya secara independen.  Saya percaya bahwa pendekatan ini agak boros, dan sulit untuk mencapainya, karena, misalnya, layanan di C # dalam hal apapun akan dihubungkan oleh perpustakaan standar.  Sistem kami ditulis dalam C #, teknologi lain belum digunakan.  Oleh karena itu, kami memutuskan bahwa kami dapat menggunakan majelis teknis umum.  Yang utama adalah mereka tidak memiliki fragmen logika bisnis.  Jika Anda memiliki pembungkus yang nyaman untuk ORM yang Anda gunakan, maka menyalinnya dari layanan ke layanan sangat mahal. <br><br>  Tim kami adalah penggemar desain berorientasi subjek, sehingga "arsitektur bawang" sangat cocok untuk kami.  Dasar dalam layanan kami bukan lapisan akses data, tetapi perakitan dengan logika domain, yang hanya berisi logika bisnis dan tanpa koneksi infrastruktur.  Pada saat yang sama, kami dapat memodifikasi perakitan domain secara independen untuk menyelesaikan masalah yang terkait dengan kerangka kerja. <br><br>  Pada tahap ini, kami bertemu dengan masalah serius pertama.  Layanan ini seharusnya merujuk pada satu perakitan domain, kami ingin membuat logika independen, dan di sini prinsip KERING sangat mengganggu kami.  Untuk menghindari duplikasi, pengembang ingin menggunakan kembali kelas dari majelis tetangga, dan sebagai hasilnya, domain mulai berkomunikasi satu sama lain lagi.  Kami menganalisis hasilnya dan memutuskan bahwa mungkin masalahnya juga terletak pada area perangkat penyimpanan kode sumber.  Kami memiliki repositori besar tempat semua kode sumber diletakkan.  Solusi untuk seluruh proyek sangat sulit untuk dirakit pada mesin lokal.  Oleh karena itu, solusi kecil yang terpisah dibuat untuk bagian-bagian proyek, dan tidak ada yang melarang menambahkan perakitan umum atau domain untuk mereka dan menggunakannya kembali.  Satu-satunya alat yang tidak memungkinkan kami melakukan ini adalah kode ulasan.  Tapi terkadang dia juga jatuh. <br><br>  Kemudian kami mulai beralih ke model dengan repositori terpisah.  Logika bisnis telah berhenti mengalir dari layanan ke layanan, domain telah benar-benar menjadi mandiri.  Konteks terbatas didukung lebih jelas.  Bagaimana kami menggunakan kembali perpustakaan infrastruktur?  Kami mengalokasikannya ke repositori terpisah, lalu menempatkannya di paket Nuget yang kami masukkan ke Artifactory.  Dengan perubahan apa pun, perakitan dan publikasi terjadi secara otomatis. <br><br><img src="https://habrastorage.org/webt/so/tk/g_/sotkg_uskgxq41d3swhkewhkzcy.png"><br><br>  Layanan kami mulai merujuk pada paket infrastruktur internal dengan cara yang sama dengan yang eksternal.  Kami mengunduh perpustakaan eksternal dari Nuget.  Untuk bekerja dengan Artifactory, tempat kami meletakkan paket-paket ini, kami menggunakan dua manajer paket.  Di repositori kecil, kami juga menggunakan Nuget.  Dalam repositori dengan beberapa layanan, kami menggunakan Paket, yang menyediakan lebih banyak konsistensi versi antar modul. <br><br><img src="https://habrastorage.org/webt/dr/0g/qe/dr0gqecxnqni4wcer4m1ogw-x70.png"><br><br>  Dengan demikian, bekerja pada kode sumber, sedikit mengubah arsitektur dan berbagi repositori, kami membuat layanan kami lebih mandiri. <br><br><a name="13"></a><h3>  <b>Masalah infrastruktur</b> </h3><br>  Sebagian besar kerugian untuk beralih ke layanan-layanan mikro terkait dengan infrastruktur.  Anda akan membutuhkan penyebaran otomatis, Anda akan memerlukan perpustakaan baru untuk infrastruktur. <br><br><a name="16"></a>  <b>Instalasi manual di lingkungan</b> <br><br>  Awalnya, kami menginstal solusi pada lingkungan secara manual.  Untuk mengotomatiskan proses ini, kami membuat pipa CI / CD.  Kami memilih proses pengiriman berkelanjutan, karena penyebaran berkelanjutan bagi kami belum dapat diterima dari sudut pandang proses bisnis.  Oleh karena itu, pengiriman ke operasi dilakukan oleh tombol, dan untuk pengujian - secara otomatis. <br><br><img src="https://habrastorage.org/webt/vz/lp/yw/vzlpyw7h9ej1gdxvkzqwivl_gqu.png"><br><br>  Kami menggunakan Atlassian, Bitbucket untuk menyimpan kode sumber, dan Bamboo untuk perakitan.  Kami suka menulis skrip perakitan dalam Cake karena C # yang sama.  Paket yang sudah jadi datang ke Artifactory, dan Ansible secara otomatis sampai ke server pengujian, setelah itu mereka dapat segera diuji. <br><br><img src="https://habrastorage.org/webt/-g/5p/dn/-g5pdnzpev-odvgxu-woy7qtcny.png"><br><br><a name="14"></a><h3>  <b>Logging terpisah</b> </h3><br>  Pada suatu waktu, salah satu ide dari monolith adalah ketentuan penebangan bersama.  Kami juga perlu memahami apa yang harus dilakukan dengan log individual yang ada di disk.  Log ditulis kepada kami dalam file teks.  Kami memutuskan untuk menggunakan tumpukan ELK standar.  Kami tidak menulis langsung ke ELK melalui penyedia, tetapi memutuskan bahwa kami akan menyelesaikan log teks dan menuliskan ID jejak di dalamnya sebagai pengidentifikasi, menambahkan nama layanan sehingga log ini kemudian dapat diuraikan. <br><br><img src="https://habrastorage.org/webt/e5/pd/ws/e5pdwsgrrb-9cpjhxabejxqdpt8.png"><br><br>  Menggunakan Filebeat, kami mendapat kesempatan untuk mengumpulkan log dari server, lalu mengonversinya, menggunakan Kibana untuk membuat permintaan di UI dan menonton bagaimana panggilan antar layanan.  ID jejak sangat membantu dalam hal ini. <br><br><a name="15"></a><h3>  <b>Menguji dan men-debug layanan terkait</b> </h3><br>  Awalnya, kami tidak sepenuhnya memahami cara men-debug layanan yang dikembangkan.  Semuanya sederhana dengan monolith, kami menjalankannya di mesin lokal.  Pada awalnya, mereka mencoba melakukan hal yang sama dengan layanan microser, tetapi kadang-kadang untuk sepenuhnya meluncurkan satu layanan microser, Anda perlu memulai beberapa yang lain, yang tidak nyaman.  ,     ,          ,   .     ,     prod.  ,  ,          .  ,     ,        . <br><br>  ,     production- .      ,         . <br><br>           Specflow.      NUnit     Ansible.     ,      .   -    .  ,      ,     Jira. <br><br>      ,       .      JMeter,    — InfluxDB,      — Grafana. <br><br><h3> <b>  ?</b> </h3><br> -,     «».    ,      production-,    -.        1,5 ,  ,        . <br><br>      .      ,       ,      .     . <br><br>     .        ,     . <br><br>  ,        .      ,      .     Scrum-.        ,    . <br><br><h3> <b></b> </h3><br><ul><li>       .     ,     ,    ,    .            . </li><li>    .        ,        ,     .    ,         , ,     Scrum. </li><li>  —   .        .      .       legacy,      ,            . <br><br> <i> :</i>       .        . ,     ,     ,     ,        , , ,  —   ,    .   .     ,     ,          . <br><br> PS    (    ) –  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br>    . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458404/">https://habr.com/ru/post/id458404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458390/index.html">Ceph - dari "di lutut" ke "produksi" bagian 2</a></li>
<li><a href="../id458394/index.html">Mengamankan protokol nirkabel menggunakan LoRaWAN sebagai contoh</a></li>
<li><a href="../id458396/index.html">Bagaimana saya membuat pengembangan di Vue.js nyaman dengan rendering sisi server</a></li>
<li><a href="../id458398/index.html">Kebersihan pekerjaan jarak jauh atau manfaat telepati</a></li>
<li><a href="../id458400/index.html">Arsitektur & implementasi Microservices Langkah-demi-Langkah Bagian 1</a></li>
<li><a href="../id458406/index.html">30+ pertanyaan tentang program utilitas dan non-utilitas</a></li>
<li><a href="../id458408/index.html">Minggu Keamanan 27: kerentanan pompa insulin</a></li>
<li><a href="../id458412/index.html">Apakah blockchain di sini hanya untuk PR dan hype?</a></li>
<li><a href="../id458414/index.html">Bagaimana mengubah karir Anda, menjadi pengembang frontend pada usia 30 dan bekerja sesuka Anda</a></li>
<li><a href="../id458416/index.html">Dari mengeluarkan pinjaman ke backend: cara mengubah karier Anda pada usia 28 dan pindah ke St. Petersburg tanpa mengubah majikan Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>