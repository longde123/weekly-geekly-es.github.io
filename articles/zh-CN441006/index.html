<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛁 👸🏿 🙌 scikit-image库中的图像分割方法概述 🏮 👩‍👩‍👧‍👦 😩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="门槛 
 通过选择高于或低于某个阈值的像素，这是将对象与背景分离的最简单方法。 当我们要按对象背景分割对象时，这通常很有用。 您可以在此处阅读有关阈值的更多信息。 

 熟悉电影《终结者》的人可能会同意，这是该时代最伟大的科幻电影。 在影片中，詹姆斯·卡梅隆（James Cameron）提出了一个有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>scikit-image库中的图像分割方法概述</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441006/"><h2> 门槛 </h2><br> 通过选择高于或低于某个阈值的像素，这是将对象与背景分离的最简单方法。 当我们要按对象背景分割对象时，这通常很有用。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>阅读有关阈值的更多信息。 <br><br> 熟悉电影《终结者》的人可能会同意，这是该时代最伟大的科幻电影。 在影片中，詹姆斯·卡梅隆（James Cameron）提出了一个有趣的视觉效果概念，使观看者可以隐藏在名为终结者（Terminator）的电子人的眼睛后面。 这种效果已被称为“终结者视觉”（英语Terminator Vision）。 从某种意义上说，他将人物的轮廓与背景分离开来。 那时听起来可能完全不合适，但是图​​像分割是当今许多图像处理技术的重要组成部分。 <br><br><h2> 图像分割 </h2><br> 有许多用于图像分析的库。 在本文中，我们将详细讨论python图像处理库scikit-image。 <br><br><h2>  Scikit图片 </h2><br><img src="https://habrastorage.org/webt/g2/fm/vh/g2fmvhs1nha3wxsoofyblton3hq.png" alt="图片"><br><br>  Scikit-image是用于图像处理的Python库。 <br><br><h2> 安装方式 </h2><br>  scikit-image的安装如下： <br><br><pre><code class="python hljs">pip install -U scikit-image(Linux <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> OSX) pip install scikit-image(Windows) <span class="hljs-comment"><span class="hljs-comment"># For Conda-based distributions conda install scikit-image</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/hy/at/nt/hyatntvr-9i-awiwo2yxcvx_vym.png"><br><a name="habracut"></a><br><h2>  Python映像概述 </h2><br> 在深入了解图像分割的技术方面之前，一定要熟悉Scikit图像生态系统及其如何处理图像。 <br><br><h3> 从skimage库导入GrayScale图像 </h3><br>  skimage数据模块包含几个内置的数据集示例，这些示例通常以jpeg或png格式存储。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.binary_blobs() plt.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>)</code> </pre> <br><h3> 从skimage库导入彩色图像 </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> skimage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt image = data.astronaut() plt.imshow(image)</code> </pre> <br><img src="https://habrastorage.org/webt/j2/8b/x5/j28bx5eailfqsuainwhmyskx4ek.png"><br><br><h3> 从外部来源导入图像 </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># The I/O module is used for importing the image from skimage import data import numpy as np import matplotlib.pyplot as plt from skimage import io image = io.imread('skimage_logo.png') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/bx/ho/xe/bxhoxercb7yo1soyfgduy9asuwk.png"><br><br><h3> 下载多张图片 </h3><br><pre> <code class="python hljs">images = io.ImageCollection(<span class="hljs-string"><span class="hljs-string">'../images/*.png:../images/*.jpg'</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Type:'</span></span>, type(images)) images.files Out[]: Type: &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> '</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skimage</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageCollection</span></span></span><span class="hljs-class">'&gt;</span></span></code> </pre> <br><h3> 保存图像 </h3><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#Saving file as 'logo.png' io.imsave('logo.png', logo)</span></span></code> </pre> <br><h2> 图像分割 </h2><br> 现在我们有了scikit-image的概念，我们考虑图像分割的细节。 图像分割是将数字图像分为几个部分，以简化和/或将图像表示更改为更有意义且更易于分析的过程。 <br><br> 在本文中，我们将考虑在有老师（有监督）和没有老师（无监督）的情况下教授模型的算法。 <br><br><img src="https://habrastorage.org/webt/zi/93/f7/zi93f7mpnuzuyo_evzeu6jqzxgo.png"><br>  <i>scikit图像库中提供了一些分割算法。</i> <br><br> 与老师进行细分：一些初步的知识（可能来自人工输入）可用于指导算法。 <br><br> 在没有老师的情况下进行细分：不需要先验知识。 这些算法尝试将图像自动划分为重要区域。 用户仍然可以配置某些参数以获得所需的结果。 <br><br> 让我们在预定义的scikit-image数据集随附的教程图像上尝试一下。 <br><br><h3> 定期进口 </h3><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.data <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.segmentation <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> seg <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.filters <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> filters <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.draw <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> draw <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> skimage.color <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> color</code> </pre> <br> 简单的成像功能 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, nrows=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ncols=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, cmap=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'gray'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(<span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>)) ax.imshow(image, cmap=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>) ax.axis(<span class="hljs-string"><span class="hljs-string">'off'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fig, ax</code> </pre> <br><h3> 图片 </h3><br><pre> <code class="python hljs">text = data.page() image_show(text)</code> </pre> <br><img src="https://habrastorage.org/webt/hr/ci/ac/hrciacrdvu72qvq8yhivtvt1e78.png"><br><br> 该图像较暗，但也许我们仍然可以选择一个值，该值将为我们提供合理的分割，而无需任何复杂的算法。 现在，为了帮助我们选择此值，我们将使用直方图。 <br><br> 在这种情况下，直方图显示在此图像中发现的具有不同强度的图像中的像素数。 简而言之，直方图是一个图形，其中X轴显示图像中的所有值，Y轴显示这些值的频率。 <br><br><pre> <code class="python hljs">fig, ax = plt.subplots(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ax.hist(text.ravel(), bins=<span class="hljs-number"><span class="hljs-number">32</span></span>, range=[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>]) ax.set_xlim(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/8c/ha/nc/8chanc-jg5519ms6yk0w-h90lfc.png"><br><br> 我们的示例结果是一个8位图像，因此在X轴上有256个可能的值，直方图显示有相当亮的像素（0：黑色，255：白色）。 这很可能是我们漂亮的浅色文本背景，但其余部分有点模糊。 理想的分割直方图将是双峰的，因此我们可以在中间选择一个数字。 现在，让我们尝试基于简单的阈值创建一些分割的图像。 <br><br><h3> 受控阈值 </h3><br> 由于我们自己选择阈值，因此我们将其称为受控阈值。 <br><br><pre> <code class="python hljs">text_segmented = text &gt; (value concluded <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> histogram ie <span class="hljs-number"><span class="hljs-number">50</span></span>,<span class="hljs-number"><span class="hljs-number">70</span></span>,<span class="hljs-number"><span class="hljs-number">120</span></span> ) image_show(text_segmented);</code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/iv/2l/gr/iv2lgrmmcgef-0geutdoybn85t0.png"></td><td><img src="https://habrastorage.org/webt/rl/k3/on/rlk3oneyt6yvcuq9mqkwel7jg3k.png"></td><td><img src="https://habrastorage.org/webt/e5/o8/fw/e5o8fwm7cs7xzneo-v29k1_vf7e.png"></td></tr></tbody></table><br>  <i>左：文字&gt; 50 |</i>  <i>中：文字&gt; 70 |</i>  <i>右：文字&gt; 120</i> <br><br> 我们没有得到理想的结果，因为左侧的阴影会产生问题。 让我们尝试现在无人看管的阈值。 <br><br><h3> 阈值不受控制 </h3><br> 不受控制的阈值Scikit图像具有许多自动阈值确定方法，在选择最佳阈值时不需要输入。 以下是一些方法：otsu，li，local。 <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_ <span class="hljs-comment"><span class="hljs-comment"># Hit tab with the cursor after the underscore to get all the methods. image_show(text &lt; text_threshold);</span></span></code> </pre> <br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zo/zb/ne/zozbnecnzak8i_-chy9ghhwa7e0.png"></td><td><img src="https://habrastorage.org/webt/h0/ik/-m/h0ik-mxys3qwdruh-gefraebnto.png"></td></tr></tbody></table><br>  <i>左大津||</i>  <i>右：李</i> <br><br> 对于本地，我们还需要指定block_size。 偏移有助于调整图像以获得更好的效果。 <br><br><pre> <code class="python hljs">text_threshold = filters.threshold_local(text,block_size=<span class="hljs-number"><span class="hljs-number">51</span></span>, offset=<span class="hljs-number"><span class="hljs-number">10</span></span>) image_show(text &gt; text_threshold);</code> </pre> <br><img src="https://habrastorage.org/webt/en/ns/zp/ennszp_rpslshqnd0y78mqax76w.png"><br><br> 这种方法效果很好。 在很大程度上，可以摆脱嘈杂的区域。 <br><br><h2> 带有老师的模型的算法分割 </h2><br> 阈值化是一个非常简单的分割过程，在高对比度图像上无法正常使用，为此我们将需要更高级的工具。 <br><br> 在本节中，我们将使用免费提供的示例图像，并尝试使用与老师联系的方法对头部进行分割。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># import the image from skimage import io image = io.imread('girl.jpg') plt.imshow(image);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/g6/dw/ga/g6dwgagldj71bqemwgosylqkusw.png"><br><br>  <i>在进行任何图像分割之前，建议使用一些滤镜将其去除。</i> <br><br> 但是，在我们的情况下，图像没有明显的噪点，因此我们将按原样接受它。 下一步是使用rgb2gray将图像转换为灰度。 <br><br><pre> <code class="python hljs">image_gray = color.rgb2gray(image) image_show(image_gray);</code> </pre> <br><img src="https://habrastorage.org/webt/qx/jl/qs/qxjlqspqdsqiaxu6px23j4q7mvs.png"><br><br> 我们将使用两种基于完全不同原理的细分方法。 <br><br><h3> 主动轮廓分割 </h3><br> 活动路径的分段也称为蛇形，使用用户定义的感兴趣区域周围的路径或直线进行初始化，然后缓慢压缩该路径，并用光和边缘吸引或排斥该路径。 <br><br> 对于我们的示例图像，让我们在人头周围画一个圆以初始化蛇。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circle_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolution, center, radius)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Generate points which define a circle on an image.Centre refers to the centre of the circle """</span></span> radians = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*np.pi, resolution) c = center[<span class="hljs-number"><span class="hljs-number">1</span></span>] + radius*np.cos(radians)<span class="hljs-comment"><span class="hljs-comment">#polar co-ordinates r = center[0] + radius*np.sin(radians) return np.array([c, r]).T # Exclude last point because a closed path should not have duplicate points points = circle_points(200, [80, 250], 80)[:-1]</span></span></code> </pre> <br> 上面的计算将计算圆的圆周上的点的x和y坐标。 由于我们给出的分辨率为200，因此它将计算200个这样的点。 <br><br><pre> <code class="python hljs">fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/4o/f1/bu/4of1buz3h2boatz5lpfpnlogh6g.png"><br><br> 然后，该算法从图像的其余部分中分割出人的脸部，将闭合曲线拟合到脸部边缘。 <br><br><img src="https://habrastorage.org/webt/z_/o1/ep/z_o1epmu9zcrxuyju7tr85p9n1o.png"><br><br> 我们可以配置称为alpha和beta的参数。 较高的alpha值会使曲线收缩更快，而beta会使曲线更平滑。 <br><br><pre> <code class="python hljs">snake = seg.active_contour(image_gray, points,alpha=<span class="hljs-number"><span class="hljs-number">0.06</span></span>,beta=<span class="hljs-number"><span class="hljs-number">0.3</span></span>) fig, ax = image_show(image) ax.plot(points[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], points[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'--r'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>) ax.plot(snake[:, <span class="hljs-number"><span class="hljs-number">0</span></span>], snake[:, <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'-b'</span></span>, lw=<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><img src="https://habrastorage.org/webt/ne/pw/vw/nepwvw8xqanbj61fikjg6qorxq0.png"><br><br><h3> 随机沃克分割 </h3><br> 在这种方法中，使用交互式标签（称为标签）进行分段。 通过将每个像素绘制到计算出最高概率的标签上，可以获得高质量的图像分割。 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>工作中可以找到有关此方法的更多详细信息。 <br><br> 接下来，我们将再次使用示例中的先前值。 我们可以进行不同的初始化，但是为简单起见，我们坚持使用圆的原理。 <br><br><pre> <code class="python hljs">image_labels = np.zeros(image_gray.shape, dtype=np.uint8)</code> </pre> <br> 随机通过算法接受标签作为输入。 因此，我们将有一个大圆圈覆盖整个人脸，而另一个小圆圈则位于人脸中间。 <br><br><pre> <code class="python hljs">indices = draw.circle_perimeter(<span class="hljs-number"><span class="hljs-number">80</span></span>, <span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)<span class="hljs-comment"><span class="hljs-comment">#from here image_labels[indices] = 1 image_labels[points[:, 1].astype(np.int), points[:, 0].astype(np.int)] = 2 image_show(image_labels);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ol/2n/nw/ol2nnwq0un_qzngiv25atfh3d5g.png"><br> 现在，让我们使用Random Walker看看会发生什么。 <br><br><pre> <code class="python hljs">image_segmented = seg.random_walker(image_gray, image_labels) <span class="hljs-comment"><span class="hljs-comment"># Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/au/bs/jn/aubsjn1b1uedkiorghu5izwbbha.png"><br><br> 结果不是最好的，脸部边缘仍未触及。 为了纠正这种情况，我们可以调整通道参数，直到获得所需的结果。 经过几次尝试，我们将该值设置为3000，效果很好。 <br><br><pre> <code class="plaintext hljs">image_segmented = seg.random_walker(image_gray, image_labels, beta = 3000) # Check our results fig, ax = image_show(image_gray) ax.imshow(image_segmented == 1, alpha=0.3);</code> </pre><br><img src="https://habrastorage.org/webt/ii/4s/h1/ii4sh1n0rxcwgply9xmafyerk5a.png"><br><br> 这一切都是为了与老师进行细分，我们必须在其中提供某些输入数据并配置一些参数。 但是，一个人并不总是能够看到图像然后决定要做出什么贡献以及从哪里开始。 幸运的是，对于这种情况，我们拥有不受控制的分割方法。 <br><br><h2> 没有老师的细分 </h2><br> 在没有老师的情况下进行细分不需要先验知识。 考虑一个太大的图像，以至于不可能一次看到所有像素。 因此，在这种情况下，没有老师的分割可以将图像分成几个子区域，因此，您可以拥有数十个或数百个区域，而不是数百万个像素。 让我们看两个这样的算法： <br><br><h3> 简单线性迭代聚类 </h3><br> 该方法（英文简单线性迭代聚类或SLIC）使用一种称为K-Means的机器学习算法。 它获取图像的所有像素值，然后尝试将它们划分为给定数量的子域。 阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此</a>作品以获取详细信息。 <br><br>  SLIC使用不同的颜色，因此我们将使用原始图像。 <br><br><pre> <code class="python hljs">image_slic = seg.slic(image,n_segments=<span class="hljs-number"><span class="hljs-number">155</span></span>)</code> </pre> <br> 我们要做的只是为找到的每个片段设置一个平均值，这使其看起来更像图像。 <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># label2rgb replaces each discrete label with the average interior color image_show(color.label2rgb(image_slic, image, kind='avg'));</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/7_/kn/b4/7_knb4b5fgefv0vsg3bed3dtx3o.png"><br><br> 我们将此图片从512 * 512 = 262,000像素减少到155个细分。 <br><br><h3> 费尔岑施瓦布 </h3><br> 此方法还使用称为最小生成树聚类的机器学习算法。  Felzenszwaib没有告诉我们将图像划分为的确切簇数。 他将为此生成尽可能多的簇。 <br><br><pre> <code class="python hljs">image_felzenszwalb = seg.felzenszwalb(image) image_show(image_felzenszwalb);</code> </pre> <br><img src="https://habrastorage.org/webt/ht/bk/ao/htbkaotqhcgg_xlbys0_z_0bwie.png"><br><br> 图片中的区域过多。 让我们计算唯一细分的数量。 <br><br><pre> <code class="python hljs">np.unique(image_felzenszwalb).size <span class="hljs-number"><span class="hljs-number">3368</span></span></code> </pre> <br> 现在，像在SLIC算法中一样，使用段上的平均值为它们重新着色。 <br><br><pre> <code class="python hljs">image_felzenszwalb_colored = color.label2rgb(image_felzenszwalb, image, kind=<span class="hljs-string"><span class="hljs-string">'avg'</span></span>) image_show(image_felzenszwalb_colored);</code> </pre> <br> 现在我们得到的细分更少了。 如果我们想要更少的细分，则可以更改scale参数。 这种方法有时称为过度细分。 <br><br><img src="https://habrastorage.org/webt/dw/-2/3-/dw-23-xllphmwajmn1sg-sk-nws.png"><br><br> 这更像是海报图像，本质上只是减少了颜色数量。 重新组合它们（RAG）。 <br><br><h2> 结论 </h2><br> 图像分割是图像处理中非常重要的一步。 这是一个活跃的研究领域，具有各种应用程序，从计算机视觉到医学图像，交通和视频监控。  Python提供了一个强大的scikit-image库，其中包含大量的图像处理算法。 它是免费提供的，不受任何限制，并由活跃的社区提供支持。 我建议您阅读他们的文档。 原始文章可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441006/">https://habr.com/ru/post/zh-CN441006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN440994/index.html">从小就照顾您的业务或如何创建精益创业公司</a></li>
<li><a href="../zh-CN440998/index.html">OpenStack扩展产品组合并参与CI / CD</a></li>
<li><a href="../zh-CN441000/index.html">促销：携带纸质书并享受任何ONYX BOOX电子阅读器的折扣</a></li>
<li><a href="../zh-CN441002/index.html">第三届图灵测试的结局：统计数据，有趣的对话和总体印象</a></li>
<li><a href="../zh-CN441004/index.html">Splunk离开俄罗斯（完全）</a></li>
<li><a href="../zh-CN441008/index.html">Rabbit MQ在居民处理系统中</a></li>
<li><a href="../zh-CN441010/index.html">落在凡间...</a></li>
<li><a href="../zh-CN441012/index.html">有关中国登月计划和the娥四号太空飞行任务历史的有趣事实</a></li>
<li><a href="../zh-CN441014/index.html">几行代码（立体图，立体浮雕，立体镜）的低成本预算立体渲染</a></li>
<li><a href="../zh-CN441018/index.html">NanoCAD Mechanics程序开发和规范工具</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>