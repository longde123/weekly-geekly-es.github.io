<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‰ ğŸ™ˆ ğŸ˜¢ Pelatihan Cisco 200-125 CCNA v3.0. Hari 44. Pengantar OSPF ğŸ¤¤ ğŸ‘©ğŸ¾â€âš•ï¸ ğŸš </title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kita akan mulai mempelajari routing OSPF. Topik ini, serta pertimbangan protokol EIGRP, adalah yang paling penting selama kursus CCNA. Sepert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelatihan Cisco 200-125 CCNA v3.0. Hari 44. Pengantar OSPF</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/466449/"> Hari ini kita akan mulai mempelajari routing OSPF.  Topik ini, serta pertimbangan protokol EIGRP, adalah yang paling penting selama kursus CCNA.  Seperti yang Anda lihat, Bagian 2.4 disebut "Mengonfigurasi, Memverifikasi, dan Masalah dengan Zona Tunggal dan OSPFv2 Multizone untuk IPv4 (Kecuali untuk Otentikasi, Penyaringan, Penyusunan Rute Manual, Redistribusi, Area Jalan Buntu, Jaringan Virtual dan LSA)". <br><br><img src="https://habrastorage.org/webt/eh/eg/ly/eheglytkouujf35vnfqie-es6my.jpeg"><br><br>  Topik OSPF cukup luas, sehingga diperlukan 2, mungkin 3 tutorial video.  Pelajaran hari ini akan dikhususkan untuk sisi teoritis masalah ini, saya akan memberi tahu Anda apa protokol ini secara umum dan bagaimana cara kerjanya.  Dalam video berikutnya, kita akan beralih ke mode konfigurasi OSPF menggunakan Packet Tracer. <a name="habracut"></a><br><br>  Jadi, dalam pelajaran ini kita akan melihat tiga hal: apa itu OSPF, bagaimana cara kerjanya, dan apa zona OSPF.  Dalam pelajaran sebelumnya, kami mengatakan bahwa OSPF adalah protokol routing tipe Tautan Negara yang memeriksa saluran komunikasi antara router dan membuat keputusan berdasarkan kecepatan saluran ini.  Saluran panjang dengan kecepatan lebih tinggi, yaitu dengan bandwidth lebih tinggi, akan menjadi prioritas dibandingkan dengan saluran pendek dengan bandwidth lebih rendah. <br><br>  Protokol RIP, sebagai vektor jarak, akan memilih jalur dalam satu hop, bahkan jika saluran ini memiliki kecepatan rendah, dan OSPF akan memilih rute panjang dari beberapa harapan jika kecepatan total pada rute ini lebih tinggi daripada kecepatan lalu lintas pada rute pendek. <br><br><img src="https://habrastorage.org/webt/si/vu/ov/sivuovzoo80jcpepru30511r2lk.jpeg"><br><br>  Nanti kita akan melihat algoritma pengambilan keputusan, untuk sekarang Anda harus ingat bahwa OSPF adalah protokol status tautan Status Tautan.  Standar terbuka ini dibuat pada tahun 1988, sehingga setiap produsen peralatan jaringan dan penyedia jaringan apa pun dapat menggunakannya.  Oleh karena itu, OSPF jauh lebih populer daripada EIGRP. <br><br>  OSPF versi 2 hanya mendukung IPv4, dan setahun kemudian, pada tahun 1989, pengembang mengumumkan rilis versi 3, yang mendukung IPv6.  Namun, versi ketiga OSPF yang berfungsi penuh untuk IPv6 hanya muncul pada 2008.  Mengapa Anda memilih OSPF?  Dalam pelajaran terakhir, kami belajar bahwa protokol gateway internal ini melakukan konvergensi rute jauh lebih cepat daripada RIP.  Ini adalah protokol tanpa kelas. <br><br>  Jika Anda ingat, RIP adalah protokol kelas, artinya, ia tidak mengirim informasi tentang subnet mask, dan jika bertemu dengan alamat IP kelas A / 24, ia tidak akan menerimanya.  Misalnya, jika Anda memberinya alamat IP dari formulir 10.1.1.0/24, maka dia akan menganggapnya sebagai jaringan 10.0.0.0, karena dia tidak mengerti kapan jaringan dibagi menjadi subnet menggunakan lebih dari satu subnet mask. <br>  OSPF adalah protokol aman.  Misalnya, jika dua router bertukar informasi OSPF, Anda dapat mengonfigurasi otentikasi sehingga Anda dapat berbagi informasi dengan router tetangga hanya setelah memasukkan kata sandi.  Seperti yang kami katakan, ini adalah standar terbuka, itulah sebabnya OSPF digunakan oleh banyak produsen peralatan jaringan. <br><br>  Dalam arti global, OSPF adalah Link State Advertisemen, atau LSA, mekanisme pertukaran iklan state link.  Pesan LSA dihasilkan oleh router dan berisi banyak informasi: pengidentifikasi unik untuk router-id router, data pada jaringan yang dikenal oleh router, data tentang biayanya, dan sebagainya.  Router membutuhkan semua informasi ini untuk membuat keputusan tentang routing. <br><br><img src="https://habrastorage.org/webt/aj/nx/5-/ajnx5-u3bzlcoc3kjj0holdm9po.jpeg"><br><br>  Router R3 mengirimkan informasi LSA ke router R5, dan router R5 berbagi informasi LSA dengan R3.  LSA ini adalah struktur data yang membentuk Basis Data Tautan Negara, atau LSDB, basis data status tautan.  Router mengumpulkan semua LSA yang diterima dan menempatkannya di LSDB-nya.  Setelah kedua router membuat database mereka sendiri, mereka bertukar pesan Hello, yang digunakan untuk menemukan tetangga, dan memulai prosedur membandingkan LSDBs mereka. <br><br>  Router R3 mengirim pesan DBD, atau "deskripsi database," ke R5, dan R5 mengirimkan DBD ke R3.  Pesan-pesan ini berisi indeks LSA yang ditemukan di pangkalan masing-masing router.  Setelah menerima DBD, R3 mengirim permintaan status jaringan LSR ke R5, yang mengatakan: "Saya sudah punya pesan 3.4 dan 9, jadi kirim saya hanya 5 dan 7". <br><br>  R5 melakukan hal yang persis sama, memberi tahu router ketiga: "Saya punya informasi 3,4 dan 9, jadi kirim saya 1 dan 2".  Setelah menerima permintaan LSR, router mengirim kembali paket pembaruan status jaringan LSU, yaitu, sebagai tanggapan terhadap LSR mereka, router ketiga menerima LSU dari router R5.  Setelah router memperbarui database mereka, maka semuanya, bahkan jika Anda memiliki 100 router, akan memiliki LSDB yang sama.  Segera setelah basis data LSDB dibuat di router, masing-masing dari mereka akan tahu tentang keseluruhan jaringan secara keseluruhan.  Protokol OSPF menggunakan algoritma Shortest Path First untuk membuat tabel routing, sehingga kondisi yang paling penting untuk operasi yang benar adalah sinkronisasi LSDB dari semua perangkat di jaringan. <br><br><img src="https://habrastorage.org/webt/ci/dg/fs/cidgfs7bbtoycybdlbkuzet-uqe.jpeg"><br><br>  Diagram di atas berisi 9 router, yang masing-masing bertukar LSR, LSU, dan sebagainya pesan dengan tetangga.  Semuanya terhubung satu sama lain seperti p2p, atau antarmuka point-to-point yang mendukung protokol OSPF, dan berinteraksi satu sama lain untuk membuat LSDB yang sama. <br><br><img src="https://habrastorage.org/webt/z0/am/wv/z0amwvsbzhhwo3quwhqf9vypyk4.jpeg"><br><br>  Segera setelah basis data disinkronkan, setiap router, menggunakan algoritma jalur terpendek, membentuk tabel peruteannya sendiri.  Router yang berbeda akan memiliki tabel yang berbeda.  Artinya, semua router menggunakan LSDB yang sama, tetapi membuat tabel routing berdasarkan pertimbangan mereka sendiri tentang rute terpendek.  Untuk menggunakan algoritma ini, OSPF perlu pembaruan rutin ke basis data LSDB. <br><br>  Jadi, untuk fungsinya sendiri, OSPF harus terlebih dahulu menyediakan 3 kondisi: cari tetangga, buat dan perbarui LSDB, dan buat tabel routing.  Untuk memenuhi kondisi pertama, administrator jaringan mungkin perlu mengkonfigurasi router-id, timing, atau wildcard mask secara manual.  Dalam video berikutnya, kami akan mempertimbangkan cara mengkonfigurasi perangkat agar berfungsi dengan OSPF, sejauh ini Anda harus tahu bahwa protokol ini menggunakan masker terbalik, dan jika tidak cocok, jika subnet Anda tidak cocok atau autentikasi tidak cocok, lingkungan router tidak akan terbentuk.  Karena itu, ketika memecahkan masalah OSPF, Anda harus mencari tahu mengapa lingkungan ini tidak terbentuk, yaitu, periksa apakah parameter di atas cocok. <br><br>  Sebagai administrator jaringan, Anda tidak terlibat dalam proses pembuatan LSDB.  Database diperbarui secara otomatis setelah membuat lingkungan router, serta membangun tabel routing.  Semua ini dilakukan oleh perangkat itu sendiri, yang dikonfigurasi untuk bekerja dengan protokol OSPF. <br>  Mari kita lihat sebuah contoh.  Kami memiliki 2 router, di mana saya telah menetapkan pengidentifikasi RID 1.1.1.1 dan 2.2.2.2 untuk kesederhanaan.  Segera setelah kami menghubungkannya, saluran tautan akan segera masuk ke status naik, karena pertama-tama saya mengkonfigurasi router ini untuk bekerja dengan OSPF.  Segera setelah saluran komunikasi terbentuk, router A akan segera mengirim paket Hello kedua.  Paket ini akan berisi informasi bahwa router ini belum "melihat" siapa pun di saluran ini, karena ia mengirimkan Hello untuk pertama kalinya, serta pengidentifikasi sendiri, data tentang jaringan yang terhubung dengannya dan informasi lain yang dapat dibagikan dengan tetangga. <br><br><img src="https://habrastorage.org/webt/8y/h3/ee/8yh3eeidlszlok6i5nc6mk_pwu8.jpeg"><br><br>  Setelah menerima paket ini, router B akan mengatakan: "Saya melihat bahwa pada saluran komunikasi ini ada kandidat potensial untuk lingkungan OSPF" dan akan beralih ke status awal Init.  Paket Hello bukan pesan Unicast atau Broadcast, itu adalah paket multicast yang dikirim ke alamat IP multicast OSPF 224.0.0.5.  Beberapa orang bertanya apa subnet mask untuk multicast.  Faktanya adalah bahwa multicast tidak memiliki subnet mask, itu didistribusikan sebagai sinyal radio yang didengar oleh semua perangkat yang disetel ke frekuensinya.  Misalnya, jika Anda ingin mendengar siaran radio FM pada frekuensi 91.0, maka setel radio Anda ke frekuensi ini. <br><br>  Dengan cara yang sama, router B dikonfigurasi untuk menerima pesan untuk alamat multicast 224.0.0.5.  Mendengarkan saluran ini, ia menerima paket Hello yang dikirim oleh router A dan membalasnya dengan pesannya. <br><br><img src="https://habrastorage.org/webt/jz/3v/65/jz3v65x0bhyt3l7aulusvjqv_ns.jpeg"><br><br>  Selain itu, lingkungan hanya dapat dibangun jika jawaban B memenuhi seperangkat kriteria.  Kriteria pertama - frekuensi pengiriman pesan Hello dan interval menunggu jawaban untuk pesan Interval Mati ini harus bertepatan untuk kedua router.  Interval Biasanya Mati sama dengan beberapa nilai timer Hello.  Jadi, jika Hello Timer dari Router A adalah 10 s, dan Router B mengirimkan pesan setelah 30 detik dengan Dead Interval sama dengan 20 s, lingkungan tidak akan terjadi. <br><br>  Kriteria kedua adalah bahwa kedua router harus menggunakan jenis otentikasi yang sama.  Karenanya, kata sandi otentikasi juga harus cocok. <br><br>  Kriteria ketiga adalah kebetulan dari pengidentifikasi zona ID Arial, yang keempat adalah kebetulan panjang awalan jaringan.  Jika router A melaporkan awalan / 24, maka router B juga harus memiliki awalan jaringan / 24.  Dalam video berikutnya, kami akan mempertimbangkan ini secara lebih rinci, untuk saat ini saya akan perhatikan bahwa ini bukan subnet mask, di sini router menggunakan masker Wildcard terbalik.  Dan tentu saja, bendera zona rintisan area stub juga harus cocok jika router berada di zona ini. <br><br>  Setelah memeriksa kriteria ini, jika cocok, Router B mengirimkan paket Hello-nya ke Router A.  Tidak seperti pesan A, router B melaporkan bahwa ia melihat router A dan memperkenalkan dirinya. <br><br><img src="https://habrastorage.org/webt/6r/kn/vy/6rknvyrb_4jh5nhlv4qwio46zay.jpeg"><br><br>  Menanggapi pesan ini, router A kembali mengirimkan Hello ke router B, di mana ia mengkonfirmasi bahwa ia juga melihat router B, saluran komunikasi di antara mereka terdiri dari perangkat 1.1.1.1 dan 2.2.2.2, dan itu sendiri adalah perangkat 1.1.1.1.  Ini adalah tahap yang sangat penting dalam membangun lingkungan.  Dalam hal ini, koneksi dua arah 2-WAY digunakan, tetapi apa yang terjadi jika kita memiliki switch dengan jaringan terdistribusi 4 router?  Dalam lingkungan "bersama" seperti itu, salah satu router harus memainkan peran router khusus DR yang ditunjuk, dan yang kedua - router khusus yang dibuat cadangan <br><br><img src="https://habrastorage.org/webt/ly/gi/on/lygionmgdtv62_x7hibp9lc48xm.jpeg"><br><br>  Masing-masing perangkat ini akan membentuk koneksi penuh, atau keadaan adjacency penuh, nanti kita akan mempertimbangkan apa itu, namun koneksi jenis ini hanya akan dibuat dengan DR dan BDR, dua router D dan B yang lebih rendah masih akan berkomunikasi satu sama lain sesuai dengan skema koneksi dua arah Poin-ke-poin. <br><br>  Yaitu, dengan DR dan BDR, semua router membangun hubungan kedekatan penuh, dan koneksi point-to-point satu sama lain.  Ini sangat penting, karena ketika menghubungkan perangkat yang berdekatan dengan cara dua arah, semua parameter paket Hello harus cocok.  Dalam kasus kami, semuanya bertepatan, sehingga perangkat membentuk lingkungan tanpa masalah. <br><br>  Segera setelah komunikasi dua arah terbentuk, router A mengirim ke router B paket Deskripsi Basis Data, atau "deskripsi basis data", dan beralih ke keadaan ExStart - awal pertukaran, atau menunggu pengunduhan.  Database Descriptor adalah informasi yang mirip dengan daftar isi buku - ini adalah penghitungan semua yang tersedia dalam routing database.  Sebagai tanggapan, router B mengirimkan deskripsi databasenya ke router A dan memasuki kondisi pertukaran data pada saluran Exchange.  Jika dalam keadaan Exchange router mendeteksi bahwa ada beberapa informasi dalam databasenya, maka router akan masuk ke status boot LOADING dan mulai bertukar pesan LSR, LSU dan LSA dengan tetangga. <br><br><img src="https://habrastorage.org/webt/c2/0h/ix/c20hixd7ecp-7n0m1cjiwhsfzmm.jpeg"><br><br>  Jadi, router A mengirim LSR ke tetangga, ia akan membalas dengan paket LSU, ke mana router A akan membalas ke router B dengan pesan LSA.  Pertukaran ini akan terjadi sebanyak berapa kali perangkat ingin bertukar pesan LSA.  Status pemuatan berarti bahwa pemutakhiran basis data LSA lengkap belum terjadi.  Setelah mengunduh semua data, kedua perangkat akan memasuki status kedekatan FULL. <br><br>  Saya perhatikan bahwa dengan koneksi dua arah, perangkat ini hanya dalam keadaan kedekatan, dan keadaan adjacency penuh hanya mungkin antara router, DR dan BDR. Ini berarti bahwa setiap router menginformasikan DR tentang perubahan dalam jaringan, dan semua router belajar tentang perubahan ini dari DR <br><br>  Pilihan DR dan BDR adalah masalah penting.  Pertimbangkan bagaimana pemilihan DR di lingkungan umum.  Misalkan di sirkuit kita ada tiga router dan sebuah switch.  Pertama, perangkat OSPF membandingkan prioritas dalam pesan Hello, kemudian membandingkan ID Router. <br><br>  Perangkat dengan prioritas tertinggi menjadi DR. Jika prioritas kedua perangkat cocok, maka dari dua perangkat, perangkat dengan ID Router tertinggi dipilih, yang menjadi DR. <br><br>  Perangkat dengan prioritas tertinggi kedua atau Router ID terpenting kedua menjadi router BDR khusus cadangan. Jika DR gagal, segera akan diganti oleh BDR. Perangkat akan mulai memainkan peran DR dan sistem akan memilih BDR lain. <br><br><img src="https://habrastorage.org/webt/na/i3/ss/nai3ssrsisjj-sdy7hc0hxnp6cg.jpeg"><br><br>  Saya harap Anda menemukan pilihan DR dan BDR, jika tidak, maka saya akan kembali ke masalah ini di salah satu video berikut dan menjelaskan proses ini. <br><br>  Jadi, kami melihat apa Hello itu, deskripsi dari Database Descriptor dan pesan LSR, LSU dan LSA.  Sebelum beralih ke topik berikutnya, mari kita bicara sedikit tentang biaya OSPF. <br><br><img src="https://habrastorage.org/webt/ts/ma/ct/tsmact54hpjwyrgvpdot7xop_cu.jpeg"><br><br>  Di Cisco, biaya rute dihitung menggunakan rumus untuk rasio bandwidth Referensi bandwidth, yang secara default diasumsikan 100 Mbps, dengan biaya saluran.  Misalnya, saat menghubungkan perangkat melalui port serial, kecepatannya 1,544 Mb / s, dan biayanya 64. Saat menggunakan koneksi Ethernet dengan kecepatan 10 Mb / s, biayanya 10, dan biaya koneksi FastEthernet dengan kecepatan 100 Mb / s adalah 1. <br><br>  Saat menggunakan Gigabit Ethernet, kami memiliki kecepatan 1000 Mbps, tetapi dalam hal ini kecepatan selalu dianggap 1. Jadi, jika Anda memiliki Gigabit Ethernet di jaringan Anda, Anda harus mengubah nilai default Ref.  BW per 1000. Dalam hal ini, biayanya adalah 1, dan seluruh tabel akan dihitung ulang dengan peningkatan nilai 10 kali.  Setelah kami membentuk lingkungan dan membangun database LSDB, kami melanjutkan ke pembangunan tabel routing. <br><br><img src="https://habrastorage.org/webt/bh/_p/rt/bh_prtlzefjqlznmehubb6_ndnw.jpeg"><br><br>  Setelah menerima LSDB, masing-masing router secara independen melanjutkan untuk membentuk daftar rute menggunakan algoritma SPF.  Dalam skema kami, router A akan membuat tabel seperti itu untuk dirinya sendiri.  Misalnya, ia menghitung biaya rute A-R1 dan menentukannya sama dengan 10. Untuk menyederhanakan pemahaman skema, anggap bahwa router A menentukan rute optimal ke router B. Biaya koneksi A-R1 adalah 10, koneksi A-R2 adalah 100, dan biaya rute A-R3 adalah 11, yaitu jumlah rute A-R1 (10) dan R1-R3 (1). <br><br>  Jika router A ingin sampai ke router R4, ia dapat melakukan ini di sepanjang rute A-R1-R4 atau di sepanjang rute A-R2-R4, dan dalam kedua kasus biaya rute akan sama: 10 + 100 = 100 + 10 = 110.  Rute A-R6 akan dikenakan biaya 100 + 1 = 101, yang sudah lebih baik.  Berikutnya, kami mempertimbangkan jalur ke router R5 di sepanjang rute A-R1-R3-R5, yang biayanya 10 + 1 + 100 = 111. <br><br>  Jalur ke router R7 dapat diletakkan di sepanjang dua rute: A-R1-R4-R7 atau A-R2-R6-R7.  Biaya yang pertama adalah 210, yang kedua - 201, jadi Anda harus memilih 201. Jadi, untuk mencapai router B, router A dapat menggunakan 4 rute. <br><br><img src="https://habrastorage.org/webt/1r/uf/3p/1ruf3pxrl5k0fwwd6zdd2sm6b9w.jpeg"><br><br>  Biaya rute A-R1-R3-R5-B akan menjadi 121. Rute A-R1-R4-R7-B akan dikenakan biaya 220. Rute A-R2-R4-R7-B membutuhkan biaya 210, dan A-R2-R6-R7- B memiliki biaya 211. Berdasarkan ini, router A memilih rute dengan biaya terendah sama dengan 121 dan menempatkannya dalam tabel routing.  Ini adalah diagram yang sangat disederhanakan tentang bagaimana algoritma SPF bekerja.  Bahkan, tabel tersebut tidak hanya berisi peruntukan router yang melaluinya rute optimal berjalan, tetapi juga peruntukan port yang menghubungkannya dan semua informasi lain yang diperlukan. <br><br>  Pertimbangkan topik lain yang berhubungan dengan zona perutean.  Biasanya, ketika mengkonfigurasi perangkat OSPF suatu perusahaan, mereka semua berada dalam satu zona yang sama. <br><br><img src="https://habrastorage.org/webt/d3/5z/rq/d35zrq0teeueeyun9lmth9efqic.jpeg"><br><br>  Apa yang terjadi jika perangkat yang terhubung ke router R3 tiba-tiba gagal?  Router R3 akan segera mulai mengirim pesan ke router R5 dan R1 bahwa saluran dengan perangkat ini tidak lagi berfungsi, dan semua router akan mulai bertukar pembaruan tentang acara ini. <br><br><img src="https://habrastorage.org/webt/of/qn/ce/ofqnceag0vtmjmpd-dddu3vja_o.jpeg"><br><br>  Jika Anda memiliki 100 router, maka semuanya akan memperbarui informasi tentang status saluran, karena mereka berada di zona bersama yang sama.  Hal yang sama akan terjadi jika salah satu router tetangga gagal - semua perangkat di zona akan bertukar pembaruan LSA.  Setelah bertukar pesan seperti itu, topologi jaringan itu sendiri akan berubah.  Setelah ini terjadi, SPF akan menghitung ulang tabel routing sesuai dengan kondisi yang diubah.  Ini adalah proses yang sangat panjang, dan jika Anda memiliki seribu perangkat dalam satu zona, Anda perlu mengontrol ukuran memori router sehingga cukup untuk menyimpan semua LSA dan database besar status saluran LSDB.  Segera setelah perubahan terjadi di bagian zona, algoritma SPF segera menghitung ulang rute.  Secara default, LSA diperbarui setiap 30 menit.  Proses ini tidak terjadi secara bersamaan di semua perangkat, namun, bagaimanapun, pembaruan dilakukan oleh setiap router dengan frekuensi 30 menit.  Lebih banyak perangkat jaringan.  Semakin banyak memori dan waktu yang diperlukan untuk memperbarui LSDB. <br><br>  Anda dapat memecahkan masalah ini jika Anda membagi satu zona umum menjadi beberapa zona terpisah, yaitu, menggunakan multi-zonasi.  Untuk melakukan ini, Anda harus memiliki rencana atau diagram dari seluruh jaringan yang Anda kelola.  Zona nol AREA 0 adalah zona utama Anda.  Ini adalah tempat di mana Anda terhubung ke jaringan eksternal, misalnya, akses ke Internet.  Saat membuat zona baru, Anda harus dipandu oleh aturan: setiap zona harus memiliki satu ABR, Router Perbatasan Area.  Router perbatasan memiliki satu antarmuka di satu zona, dan antarmuka kedua di zona lain.  Misalnya, router R5 memiliki antarmuka di zona 1 dan zona 0. Seperti yang saya katakan, setiap zona harus terhubung ke zona nol, yaitu, memiliki router tepi, salah satu antarmuka yang terhubung ke AREA 0. <br><br><img src="https://habrastorage.org/webt/so/lw/yu/solwyugzi0kcniowromdhqrf4em.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan koneksi R6-R7 rusak. </font><font style="vertical-align: inherit;">Dalam hal ini, pembaruan LSA hanya akan didistribusikan di zona AREA 1 dan hanya akan menyangkut zona ini. </font><font style="vertical-align: inherit;">Perangkat di zona 2 dan zona 0 bahkan tidak akan mengetahuinya. </font><font style="vertical-align: inherit;">Router perbatasan R5 meringkas informasi tentang apa yang terjadi di zonanya dan mengirimkan ke AREA zona utama 0 informasi total tentang keadaan jaringan. </font><font style="vertical-align: inherit;">Perangkat dalam satu zona tidak perlu menyadari semua perubahan LSA dalam zona lain, karena router ABR akan meneruskan informasi ringkasan tentang rute dari satu zona ke zona lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tidak sepenuhnya jelas tentang konsep zona, Anda dapat menemukan lebih banyak dalam pelajaran berikutnya ketika kita akan mengkonfigurasi routing OSPF dan mempertimbangkan beberapa contoh.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BDSrDuTRo0Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Terima kasih telah tinggal bersama kami.  Apakah Anda suka artikel kami?  Ingin melihat materi yang lebih menarik?  Dukung kami dengan melakukan pemesanan atau merekomendasikannya kepada teman-teman Anda, <b>diskon 30% untuk pengguna Habr pada analog unik dari server entry-level yang kami temukan untuk Anda:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seluruh kebenaran tentang VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps dari $ 20 atau bagaimana membagi server?</a>  (opsi tersedia dengan RAID1 dan RAID10, hingga 24 core dan hingga 40GB DDR4). <br><br>  <b>Dell R730xd 2 kali lebih murah?</b>  Hanya kami yang memiliki <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2 x Intel TetraDeca-Core Xeon 2x E5-2697v3 2.6GHz 14C 64GB DDR4 4x960GB SSD 1Gbps 100 TV dari $ 199</a> di Belanda!</b>  <b><b>Dell R420 - 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps 100TB - mulai dari $ 99!</b></b>  Baca tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Membangun Infrastruktur Bldg.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kelas menggunakan server Dell R730xd E5-2650 v4 seharga 9.000 euro untuk satu sen?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466449/">https://habr.com/ru/post/id466449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466439/index.html">Periksa diri Anda: berapa banyak pertanyaan yang dapat Anda jawab ChGK?</a></li>
<li><a href="../id466441/index.html">Kode kereta python: 10 kesalahan paling umum yang dilakukan pengembang</a></li>
<li><a href="../id466443/index.html">ShIoTiny dan dunia: sensor analog atau ADC untuk yang terkecil</a></li>
<li><a href="../id466445/index.html">Serangan antara trust di antara domain</a></li>
<li><a href="../id466447/index.html">Untuk apa kita membangun CDN?</a></li>
<li><a href="../id466451/index.html">Baca_Anda tidak bisa_menghapus</a></li>
<li><a href="../id466453/index.html">Pelatihan Cisco 200-125 CCNA v3.0. Hari 45. Mengkonfigurasi OSPF</a></li>
<li><a href="../id466455/index.html">Layanan, layanan microser dan pemrograman berorientasi batch</a></li>
<li><a href="../id466457/index.html">Pertanian dan panel surya - strategi win-win untuk insinyur listrik dan petani</a></li>
<li><a href="../id466459/index.html">Tes Integrasi Paralel Postgresql di Aplikasi GO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>