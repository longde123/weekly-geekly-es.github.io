<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∞Ô∏è üì± üêÇ Ap√≥s a reuni√£o "Novos recursos do PostgreSQL 11" ‚õ∑Ô∏è üõ≥Ô∏è ü§∑üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje falaremos sobre os recursos mais importantes do PostgreSQL 11. Por que apenas sobre eles - porque nem todo mundo precisa de alguns recursos, ent√£...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ap√≥s a reuni√£o "Novos recursos do PostgreSQL 11"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/414031/">  Hoje falaremos sobre os recursos mais importantes do PostgreSQL 11. Por que apenas sobre eles - porque nem todo mundo precisa de alguns recursos, ent√£o escolhemos os mais populares. <br><br><h3>  Conte√∫do </h3><br><img src="https://habrastorage.org/webt/3l/ef/wk/3lefwko0funvsqwyvgcaqtf7ory.png" align="right" width="300"><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jit compila√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Particionamento</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√çndices</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√çndices de Cobertura</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SP GiST</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desempenho</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WAL</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Backup e replica√ß√£o</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para dba</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Execu√ß√£o paralela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Optimizers</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fun√ß√µes da janela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Altera√ß√µes na pesquisa de texto completo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Json (b) e texto completo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Procedimentos PL / *</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pgbench</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprimoramentos no PSQL</a> </li></ul><a name="habracut"></a><br><a name="1"></a><h3>  Jit compila√ß√£o </h3><br>  O PostgreSQL finalmente introduziu a compila√ß√£o JIT, ou seja, compilar consultas em c√≥digo bin√°rio.  Para fazer isso, compile o PostgreSQL com suporte √† compila√ß√£o JIT <code>(Compile time 1 (--with-llvm))</code> .  Ao mesmo tempo, a m√°quina deve ter a vers√£o LLVM n√£o inferior a 3.9. <br><br>  O que pode acelerar o JIT? <br><br><ul><li>  Consultas com a cl√°usula WHERE, ou seja, tudo o que vem ap√≥s esta palavra-chave.  Isso nem sempre √© necess√°rio, mas a oportunidade √© √∫til. </li><li>  C√°lculo da lista de alvos: na terminologia do PostgreSQL, √© tudo o que h√° entre select e from. </li><li>  Agregados. </li><li>  Converta registros de uma visualiza√ß√£o para outra (Proje√ß√£o).  Por exemplo, quando voc√™ aplica jun√ß√£o a duas tabelas, o resultado √© uma nova tupla contendo campos de ambas as tabelas. </li><li>  Deforma√ß√£o da tupla.  Um dos problemas de qualquer banco de dados, pelo menos em letras min√∫sculas, relacionais, √© como obter um campo de um registro no disco.  Afinal, pode haver nulo, eles t√™m registros diferentes e, em geral, essa n√£o √© a opera√ß√£o mais barata. </li></ul><br>  <code>Compile time 2</code> significa que o JIT n√£o √© usado.  No PostgreSQL, h√° um momento de planejamento de consultas, quando o sistema decide o que vale JIT e o que n√£o vale.  Nesse ponto, ele faz JITs e, em seguida, o executor √© executado como est√°. <br><br>  O JIT √© tornado plug√°vel.  Por padr√£o, ele funciona com o LLVM, mas voc√™ pode conectar qualquer outro JIT. <br><br><img src="https://habrastorage.org/webt/hm/pk/lk/hmpklkbpxsi1qzqyvyx3drcl6_y.png" width="600"><br><br>  Se voc√™ compilou o PostgreSQL sem o suporte ao JIT, a primeira configura√ß√£o n√£o funcionar√°.  Op√ß√µes implementadas para desenvolvedores, existem configura√ß√µes para fun√ß√µes JIT individuais. <br><br>  O pr√≥ximo ponto sutil est√° relacionado a jit_above_cost.  O JIT em si n√£o √© gratuito.  Portanto, o PostgreSQL assume como padr√£o a otimiza√ß√£o de JIT se o custo de uma consulta exceder 100 mil papagaios condicionais, nos quais s√£o explicados, explicados, analisados ‚Äã‚Äãe assim por diante.  Esse valor √© escolhido aleatoriamente, portanto, preste aten√ß√£o nele. <br><br>  Mas nem sempre depois de ativar o JIT, tudo funciona imediatamente.  Geralmente, todo mundo come√ßa a experimentar o JIT usando a tabela select * from, na qual id = 600 consulta e eles falham.  Provavelmente, √© necess√°rio de alguma forma complicar a solicita√ß√£o e, em seguida, todos geram um banco de dados gigante e comp√µem a solicita√ß√£o.  Como resultado, o PostgreSQL repousa sobre as capacidades do disco; n√£o possui a capacidade de buffers e caches compartilhados. <br><br>  Aqui est√° um exemplo completamente abstrato.  Existem 9 campos nulos com frequ√™ncias diferentes, para que voc√™ possa observar o efeito da deforma√ß√£o da tupla. <br><br> <code>select i as x1, <br> case when i % 2 = 0 then i else null end as x2, <br> case when i % 3 = 0 then i else null end as x3, <br> case when i % 4 = 0 then i else null end as x4, <br> case when i % 5 = 0 then i else null end as x5, <br> case when i % 6 = 0 then i else null end as x6, <br> case when i % 7 = 0 then i else null end as x7, <br> case when i % 8 = 0 then i else null end as x8, <br> case when i % 9 = 0 then i else null end as x9 <br> into t <br> from generate_series(0, 10000000) i; <br> <br> vacuum t; <br> analyze t;</code> <br> <br>  O PostgreSQL tem muitas possibilidades e, para ver as vantagens do JIT, desative as duas primeiras linhas para n√£o interferir e redefina os limites. <br><br> <code>set max_parallel_workers=0; <br> set max_parallel_workers_per_gather=0; <br> set jit_above_cost=0; <br> set jit_inline_above_cost=0; <br> set jit_optimize_above_cost=0;</code> <br> <br>  Aqui est√° o pr√≥prio pedido: <br><br> <code>set jit=off; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000; <br> <br> set jit=on; <br> explain analyze <br> select count(*) from t where <br> sqrt(pow(x9, 2) + pow(x8,2)) &lt; 10000;</code> <br> <br>  E aqui est√° o resultado: <br><br> <code>Planning Time: 0.71 ms <br> Execution Time: <b>1986.323</b> ms <br> <br> VS <br> <br> Planning Time: 0.060 ms <br> JIT: <br> Functions: 4 <br> Generation Time: 0.911 ms <br> Inlining: true <br> Inlining Time: 23.876 ms <br> Optimization: true <br> Optimization Time: 41.399 ms <br> Emission Time: 21.856 ms <br> Execution Time: <b>949.112</b> ms</code> <br> <br>  O JIT ajudou a acelerar a solicita√ß√£o pela metade.  O tempo de planejamento √© praticamente o mesmo, mas esse √© provavelmente o resultado do cache do PostgreSQL, ent√£o ignore-o. <br><br>  Se resumir, foram necess√°rios cerca de 80 ms para a compila√ß√£o do JIT.  Por que o JIT n√£o √© gratuito?  Antes de executar a solicita√ß√£o, voc√™ precisa compil√°-la e isso tamb√©m leva tempo.  E tr√™s ordens de magnitude a mais que o planejamento.  N√£o √© um prazer caro, mas vale a pena devido ao tempo de execu√ß√£o. <br><br>  Dessa forma, voc√™ pode usar o JIT, embora nem sempre seja ben√©fico. <br><br><a name="2"></a><h3>  Particionamento </h3><br>  Se voc√™ prestou aten√ß√£o ao particionamento no PostgreSQL, provavelmente percebeu que ele foi feito para exibi√ß√£o.  A situa√ß√£o melhorou um pouco na vers√£o 10, quando uma declara√ß√£o declarativa de parti√ß√µes (se√ß√µes) apareceu.  Por outro lado, tudo permaneceu o mesmo por dentro e funcionou aproximadamente o mesmo que nas vers√µes anteriores, ou seja, ruim. <br>  De muitas maneiras, esse problema foi resolvido pelo m√≥dulo pg_pathman, que permitiu trabalhar com se√ß√µes e cort√°-las no tempo ideal ideal no tempo de execu√ß√£o. <br><br>  Na vers√£o 11, o particionamento foi bastante aprimorado: <br><br><ul><li>  Primeiro, a tabela de parti√ß√µes pode ter uma chave prim√°ria, que deve incluir a chave de parti√ß√£o.  De fato, essa √© uma chave semi-prim√°ria ou uma semi-chave prim√°ria.  Infelizmente, voc√™ n√£o pode fazer uma chave estrangeira nela.  Espero que isso seja corrigido no futuro. </li><li>  Agora tamb√©m √© poss√≠vel particionar n√£o apenas por intervalo, mas tamb√©m por lista e hash.  O hash √© bastante primitivo, o restante da express√£o √© usado para isso. </li><li>  Ao atualizar, a linha se move entre as se√ß√µes.  Anteriormente, era necess√°rio escrever um gatilho, mas agora √© feito automaticamente. </li></ul><br>  A grande quest√£o √©: quantas se√ß√µes posso ter?  Honestamente, com um grande n√∫mero de se√ß√µes (milhares e dezenas de milhares), o recurso n√£o funciona bem.  Pg_pathman faz melhor. <br><br>  Tamb√©m fez se√ß√µes por padr√£o.  Novamente, em pg_pathman, voc√™ pode fazer a cria√ß√£o autom√°tica de se√ß√µes, o que √© mais conveniente.  Aqui, tudo o que n√£o p√¥de ser empurrado em algum lugar cai na se√ß√£o.  Se em um sistema real para fazer isso por padr√£o, depois de algum tempo voc√™ fica com essa bagun√ßa, que atormenta. <br><br>  O PostgreSQL 11 agora pode otimizar o particionamento se duas tabelas forem unidas por uma chave de parti√ß√£o e os esquemas de particionamento corresponderem.  Isso √© controlado por um par√¢metro especial, que √© desativado por padr√£o. <br><br>  Voc√™ pode calcular agregados para cada se√ß√£o separadamente e adicionar.  Por fim, voc√™ pode criar um √≠ndice na tabela particionada pai e, em seguida, ser√£o criados √≠ndices locais em todas as tabelas conectadas a ela. <br><br>  Na se√ß√£o "O que h√° de novo", uma coisa maravilhosa √© mencionada - a capacidade de descartar se√ß√µes ao executar uma solicita√ß√£o.  Vamos verificar como funciona.  O resultado √© uma tabela: <br><br><img src="https://habrastorage.org/webt/pd/yq/og/pdyqogkeovn-af_egj5u8wlszne.png" width="500"><br><br>  Fazemos um tipo e uma tabela de duas colunas com uma chave prim√°ria, com uma coluna bigserial, inserindo os dados.  Criamos a segunda tabela, que ser√° particionada e ser√° uma c√≥pia da primeira.  Adicione a chave prim√°ria √† tabela particionada. <br><br><img src="https://habrastorage.org/webt/in/5h/gr/in5hgrummalku8i2gfizbjbt3hm.png" width="500"><br><br>  A tabela consistir√° em dois tipos de entradas: ‚Äúbab√°s do sexo feminino‚Äù e ‚Äúmotoristas do sexo masculino‚Äù.  E haver√° uma motorista do sexo feminino.  Fazemos duas se√ß√µes, dividimos por lista, adicionamos a chave prim√°ria e inserimos todos os dados da tabela na qual tudo isso √© gerado.  O resultado foi completamente desinteressante: <br><br><img src="https://habrastorage.org/webt/r5/st/ax/r5staxao_opewadzu9wavch_w6w.png"><br><br>  Preste aten√ß√£o ao pedido.  Selecionamos tudo de uma tabela n√£o particionada, conectamos a uma tabela particionada.  Pegamos um peda√ßo pequeno e escolhemos apenas um tipo, eles passam por um.  Indicamos que a coluna oss deve ter um valor.  Acontece uma sele√ß√£o de drivers s√≥lidos. <br><br>  Na execu√ß√£o, desabilitamos especificamente a paraleliza√ß√£o, porque o PostgreSQL 11, por padr√£o, paraleliza muito ativamente consultas mais ou menos complexas.  Se olharmos para o plano de execu√ß√£o (explique analisar), pode-se ver que o sistema adicionou os dados nas duas se√ß√µes: na bab√° e nos motoristas, embora as bab√°s n√£o estivessem l√°.  N√£o houve chamadas para o buffer.  Tempo gasto, condi√ß√£o usada, embora o PostgreSQL possa descobrir tudo.  Ou seja, a declara√ß√£o de elimina√ß√£o da parti√ß√£o n√£o funciona imediatamente.  Talvez nas pr√≥ximas vers√µes isso seja corrigido.  Nesse caso, o m√≥dulo pg_pathman nesse caso funciona sem problemas. <br><br><a name="3"></a><h3>  √çndices </h3><br><ul><li>  Otimiza√ß√£o de lances de maneira mon√≥tona, ou seja, √°rvore b.  Todo mundo sabe que, quando voc√™ insere dados em crescimento mon√≥tono, eles n√£o s√£o muito r√°pidos.  Agora o PostgreSQL √© capaz de armazenar em cache a p√°gina final de uma maneira especial e n√£o percorrer todo o caminho desde a raiz at√© a inser√ß√£o.  Isso acelera significativamente o trabalho. </li><li>  O PostgreSQL 10 tornou poss√≠vel o uso de um √≠ndice de hash, porque come√ßou a usar o WAL (write write log).  Anteriormente, obtivemos o valor, desbloqueamos a p√°gina, retornamos o valor.  Para o pr√≥ximo valor, voc√™ teve que bloquear a p√°gina novamente, retornar, desbloquear e assim por diante.  Agora o hash se tornou muito mais r√°pido.  Ele permite bloquear uma p√°gina de cada vez para recuperar um registro de um √≠ndice de hash, retornar todos os valores de l√° e desbloque√°-lo.  Agora est√° implementado para HASH, GiST e GIN.  No futuro, isso provavelmente ser√° implementado para o SP-GiST.  Mas para o BRIN, com sua l√≥gica min / max, isso n√£o pode ser feito em princ√≠pio. </li><li>  Se voc√™ costumava criar √≠ndices funcionais, a atualiza√ß√£o HOT (Heap Only Tuple) era efetivamente desabilitada.  Quando um registro √© atualizado no PostgreSQL, uma nova c√≥pia √© realmente criada, e isso requer colar em todos os √≠ndices que est√£o na tabela para que o novo valor aponte para a nova tupla.  Essa otimiza√ß√£o √© implementada h√° muito tempo: se a atualiza√ß√£o n√£o alterar os campos que n√£o est√£o inclu√≠dos nos √≠ndices e houver espa√ßo livre na mesma p√°gina, os √≠ndices n√£o ser√£o atualizados e, na vers√£o antiga da tupla, ser√° colocado um ponteiro para a nova vers√£o.  Isso permite reduzir um pouco a gravidade do problema com as atualiza√ß√µes.  No entanto, essa otimiza√ß√£o n√£o funcionaria se voc√™ tivesse √≠ndices funcionais.  No PostgreSQL 11, ele come√ßou a funcionar.  Se voc√™ criou um √≠ndice funcional e atualizou uma tupla que n√£o altera de que depende o √≠ndice funcional, a atualiza√ß√£o HOT funcionar√°. </li></ul><br><a name="4"></a><h3>  √çndices de Cobertura </h3><br>  Essa funcionalidade foi implementada pelo PostgresPro h√° tr√™s anos e, durante todo esse tempo, o PostgreSQL tentou adicion√°-lo.  Os √≠ndices de cobertura significam que voc√™ pode adicionar colunas extras ao √≠ndice exclusivo, diretamente na tupla do √≠ndice. <br><br>  Porque  Todo mundo adora a varredura apenas de √≠ndice para o seu trabalho r√°pido.  Para isso, s√£o constru√≠dos √≠ndices condicionais de "cobertura": <br><br><img src="https://habrastorage.org/webt/ep/s7/vf/eps7vfc5hddmnsu6occowc250kw.png" width="600"><br><br>  Mas, ao mesmo tempo, voc√™ precisa manter a exclusividade.  Portanto, dois √≠ndices est√£o sendo criados, estreitos e amplos. <br>  A desvantagem √© que, ao aplicar v√°cuo, inserir ou atualizar uma tabela, voc√™ deve atualizar os dois √≠ndices.  Portanto, a inser√ß√£o em um √≠ndice √© uma opera√ß√£o lenta.  E o √≠ndice de cobertura permitir√° gerenciar apenas um √≠ndice. <br><br>  √â verdade que ele tem algumas limita√ß√µes.  Mais precisamente, os benef√≠cios que podem n√£o ser imediatamente entendidos.  As colunas c e d no primeiro √≠ndice de cria√ß√£o n√£o precisam ser tipos escalares para os quais um √≠ndice de √°rvore b √© definido.  Ou seja, eles n√£o t√™m necessariamente uma compara√ß√£o mais-menos.  Pode ser pontos ou pol√≠gonos.  A √∫nica coisa √© que a tupla deve ser menor que 2,7 Kb, porque n√£o h√° brindes no √≠ndice, mas voc√™ pode se encaixar naquilo que n√£o pode ser comparado. <br><br>  No entanto, dentro do √≠ndice com essas colunas cobertas garantidas, nenhum c√°lculo √© feito durante a pesquisa.  Isso deve ser feito por um filtro que esteja acima do √≠ndice.  Por um lado, por que n√£o calcul√°-lo dentro do √≠ndice, por outro lado, √© uma chamada de fun√ß√£o extra.  Mas nem tudo √© t√£o assustador quanto parece. <br><br>  Al√©m disso, voc√™ pode adicionar essas colunas cobertas √† chave prim√°ria. <br><br><a name="5"></a><h3>  SP GiST </h3><br>  Poucas pessoas usam esse √≠ndice porque √© bastante espec√≠fico.  No entanto, tornou-se poss√≠vel armazenar nele n√£o exatamente o que foi inserido.  Refere-se ao √≠ndice com perdas, compacta√ß√£o.  Tome pol√≠gonos como exemplo.  Em vez disso, uma caixa delimitadora √© colocada no √≠ndice, ou seja, o ret√¢ngulo m√≠nimo que cont√©m o pol√≠gono desejado.  Nesse caso, representamos o ret√¢ngulo como um ponto no espa√ßo quadridimensional e, em seguida, trabalhamos com o quad3 cl√°ssico, no espa√ßo quadridimensional. <br><br>  Tamb√©m para o SP-GiST introduziu a opera√ß√£o "prefix search".  Retorna true se uma linha √© um prefixo de outra.  Eles o introduziram n√£o apenas assim, mas por uma solicita√ß√£o desse tipo, com suporte ao SP-GiST. <br><br> <code>SELECT * FROM table WHERE c ^@ ‚Äûabc‚Äú</code> <br> <br>  Na √°rvore b, h√° um limite de 2,7 Kb por linha, mas o SP-GiST n√£o.  √â verdade que o PostgreSQL tem uma limita√ß√£o: um √∫nico valor n√£o pode exceder 1 GB. <br><br><a name="6"></a><h3>  Desempenho </h3><br><ul><li>  <b>A verifica√ß√£o apenas do √≠ndice de bitmap foi exibida</b> .  Funciona da mesma forma que a varredura de √≠ndice cl√°ssico, exceto que n√£o pode garantir nenhum pedido.  Portanto, √© aplic√°vel apenas a algumas agrega√ß√µes, como count (*), porque o bitmap n√£o pode transferir campos do √≠ndice para o executor.  Ele s√≥ pode relatar o fato de um registro que satisfa√ßa as condi√ß√µes. </li><li>  A pr√≥xima inova√ß√£o √© a <b>atualiza√ß√£o do Mapa do Espa√ßo Livre durante a aplica√ß√£o do v√°cuo</b> .  Infelizmente, nenhum dos desenvolvedores de sistemas que trabalham com o PostgreSQL pensa que √© necess√°rio excluir no final da tabela, caso contr√°rio, furos e espa√ßo n√£o alocado ser√£o exibidos.  Para acompanhar isso, implementamos o FSM, o que nos permite n√£o ampliar a tabela, mas inserir a tupla nos vazios.  Anteriormente, isso era feito com v√°cuo, mas no final.  E agora o v√°cuo √© capaz de fazer isso no processo e, em sistemas com muita carga, ajuda a manter o tamanho da mesa sob controle. </li><li>  <b>Possibilidade de pular a verifica√ß√£o de √≠ndice durante a execu√ß√£o a v√°cuo</b> .  O fato √© que todos os √≠ndices do PostgreSQL, de acordo com a teoria do banco de dados, s√£o chamados de secund√°rios.  Isso significa que os √≠ndices s√£o armazenados longe da tabela; os ponteiros levam a eles a partir deles.  A varredura de √≠ndice apenas permite que voc√™ n√£o fa√ßa esse salto nos ponteiros, mas retire diretamente do √≠ndice.  Mas o v√°cuo, que exclui registros, n√£o pode examin√°-los no √≠ndice e decidir se deve exclu√≠-los ou n√£o, simplesmente porque n√£o existem esses dados no √≠ndice.  Portanto, o v√°cuo √© sempre realizado em duas passagens.  Primeiro, ele passa pela mesa e descobre o que precisa excluir.  Em seguida, ele vai para os √≠ndices anexados a esta tabela, exclui os registros que se referem aos encontrados, retorna √† tabela e exclui para o que estava indo.  E a etapa de ir para os √≠ndices nem sempre √© necess√°ria. <br><br>  Se desde o √∫ltimo v√°cuo n√£o houve exclus√£o ou atualiza√ß√£o, voc√™ n√£o possui registros mortos, n√£o √© necess√°rio exclu√≠-los.  Nesse caso, voc√™ n√£o pode ir para o √≠ndice.  Existem sutilezas adicionais, o b-tree n√£o exclui suas p√°ginas imediatamente, mas em duas passagens.  Portanto, se voc√™ excluiu muitos dados da tabela, precisar√° fazer o v√°cuo.  Mas se voc√™ quiser liberar espa√ßo nos √≠ndices, aspire duas vezes. <br><br>  Algu√©m ficar√° surpreso. Qual √© a tabela em que n√£o houve exclus√£o ou atualiza√ß√£o?  De fato, muitos lidam com isso, simplesmente n√£o pensam.  Essas s√£o apenas tabelas anexadas, onde, por exemplo, os logs s√£o adicionados.  Neles, a remo√ß√£o √© extremamente rara.  E isso economiza bastante a dura√ß√£o do v√°cuo / v√°cuo autom√°tico, reduz a carga no disco, o uso de caches e assim por diante. </li><li>  <b>Confirmar transa√ß√µes competitivas simult√¢neas</b> .  Isto n√£o √© uma inova√ß√£o, mas uma melhoria.  Agora o PostgreSQL detecta que ir√° confirmar agora e atrasa a confirma√ß√£o da transa√ß√£o atual, aguardando o restante das confirma√ß√µes.  Observe que esse recurso tem pouco efeito se voc√™ tiver um servidor pequeno com 2 a 4 n√∫cleos. </li><li>  <b>postgres_fdw (inv√≥lucros de dados estrangeiros)</b> .  O FDW √© uma maneira de conectar uma fonte de dados externa para que pare√ßa um verdadeiro p√≥s-Congresso.  O postgres_fdw permite conectar uma tabela de uma inst√¢ncia vizinha √† sua inst√¢ncia, e ela parecer√° quase como uma tabela real.  Agora, uma das restri√ß√µes para atualiza√ß√£o e exclus√£o foi removida.  O PostgreSQL costuma adivinhar que voc√™ precisa enviar dados brutos.  A maneira de executar a solicita√ß√£o de jun√ß√£o √© bastante simples: executamos em nossa m√°quina, retiramos a tabela da inst√¢ncia usando o FDW, descobrimos a chave prim√°ria de identifica√ß√£o que precisamos excluir e aplicamos atualiza√ß√£o e / ou exclus√£o, ou seja, os dados que vamos e voltamos .  Agora √© poss√≠vel fazer.  Obviamente, se as tabelas estiverem em m√°quinas diferentes, isso n√£o √© t√£o f√°cil, mas o FDW permite que voc√™ fa√ßa a m√°quina remota executar opera√ß√µes, e n√≥s apenas esperamos. </li><li>  <b>toast_tuple_target</b> .  Existem situa√ß√µes em que os dados v√£o al√©m dos limites ap√≥s os quais √© necess√°rio brindar, mas ao mesmo tempo brindar esses valores nem sempre √© agrad√°vel.  Suponha que voc√™ tenha um limite de 90 bytes e precise ajustar 100. Voc√™ precisa iniciar o brinde por 10 bytes, adicion√°-los separadamente e, quando selecionar esse campo, precisar√° acessar o √≠ndice do brinde, descobrir onde est√£o os dados necess√°rios, acessar a tabela do brinde, coletar e dar. </li></ul><br>  Agora, com a ajuda do ajuste fino, voc√™ pode alterar esse comportamento para todo o banco de dados ou uma tabela separada, para que sa√≠das t√£o pequenas n√£o exijam o uso de brinde.  Mas voc√™ deve entender o que est√° fazendo, sem isso, nada funcionar√°. <br><br><a name="7"></a><h3>  WAL </h3><br><ul><li>  WAL (Write Forward Log) √© um registro de grava√ß√£o antecipada.  O tamanho do segmento WAL agora est√° definido no initdb.  Gra√ßas a Deus, n√£o ao compilar. </li><li>  A l√≥gica tamb√©m mudou.  Anteriormente, o conjunto de segmentos WAL era salvo a partir do momento do pen√∫ltimo ponto de verifica√ß√£o e agora a partir do √∫ltimo.  Isso pode reduzir significativamente a quantidade de dados armazenados.  Mas se voc√™ tiver um banco de dados de 1 TB e TPS = 1, ou seja, uma solicita√ß√£o por segundo, n√£o ver√° a diferen√ßa. </li></ul><br><a name="8"></a><h3>  Backup e replica√ß√£o </h3><br><ul><li>  <b>Truncar apareceu na replica√ß√£o l√≥gica</b> .  Foi a √∫ltima das opera√ß√µes DML que n√£o foi refletida na replica√ß√£o l√≥gica.  Agora refletido. </li><li>  <b>Uma mensagem sobre prepara√ß√£o apareceu na replica√ß√£o l√≥gica</b> .  Agora voc√™ pode pegar a transa√ß√£o de prepara√ß√£o, uma confirma√ß√£o de duas fases na replica√ß√£o l√≥gica.  Isso √© implementado para a constru√ß√£o de clusters - heterog√™neo, homog√™neo, fragmentado e n√£o sombreado, multimaster e assim por diante. </li><li>  <b>Exce√ß√£o das tabelas tempor√°rias e n√£o registradas de pg_basebackup</b> .  Muitos reclamaram que pg_basebackup inclui as tabelas listadas.  E excluindo-os, reduzimos o tamanho do backup.  Por√©m, contanto que voc√™ use tabelas tempor√°rias e n√£o registradas, caso contr√°rio, essa op√ß√£o ser√° in√∫til para voc√™. </li><li>  <b>Controle de soma de verifica√ß√£o na replica√ß√£o de streaming (para tabelas)</b> .  Isso permite que voc√™ entenda o que aconteceu com sua r√©plica.  At√© o momento, a fun√ß√£o √© implementada apenas para tabelas. </li><li>  <b>Houve uma promo√ß√£o de posi√ß√µes do slot de replica√ß√£o</b> .  Como sempre, voc√™ pode apenas avan√ßar, voltar apenas se houver um WAL.  Al√©m disso, voc√™ precisa entender muito bem o que est√° fazendo com isso e por qu√™.  Na minha opini√£o, essa √© mais uma op√ß√£o de desenvolvimento, mas quem usa replica√ß√£o l√≥gica para alguns aplicativos ex√≥ticos pode aproveitar. </li></ul><br><a name="9"></a><h3>  Para dba </h3><br><ul><li>  <b>Altere a tabela, adicione a coluna, n√£o o padr√£o nulo X</b> , escreva a tabela inteira.  H√° uma pequena taxa para isso: o valor padr√£o √© armazenado separadamente.  Se voc√™ escolher a tupla e precisar desta coluna, o PostgreSQL √© for√ßado a seguir um caminho de codifica√ß√£o adicional para obter um valor tempor√°rio, substitu√≠-lo na tupla e fornec√™-lo a voc√™.  No entanto, pode-se viver com isso. </li><li>  <b>V√°cuo / an√°lise</b> .  Anteriormente, voc√™ s√≥ podia aplicar v√°cuo ou analisar um banco de dados inteiro ou uma √∫nica tabela.  Agora √© poss√≠vel fazer isso em v√°rias tabelas, com um comando. </li></ul><br><a name="10"></a><h3>  Execu√ß√£o paralela </h3><br><ul><li>  <b>Constru√ß√£o paralela de √≠ndices b-tree</b> .  Na vers√£o 11, tornou-se poss√≠vel incorporar √≠ndices b-tree em v√°rios trabalhadores.  Se voc√™ tem uma m√°quina realmente boa, muitos discos e muitos n√∫cleos, pode criar √≠ndices em paralelo, isso promete um aumento not√°vel no desempenho. </li><li>  <b>Hash conex√£o paralela usando uma tabela de hash compartilhada para executores</b> .    ,           -.   ,     .   - ,     .     . </li><li>  , <b>      union, create table as, select  create materialized view!</b> </li><li> - <b>   (limit)   </b> .    . </li></ul><br>    : <br><br> <code>alter table usr reset (parallel_workers) <br> create index on usr(lower((so).occ)) ‚Äî 2  <br> alter table usr set (parallel_workers=2) <br> create index on usr(upper((so).occ)) ‚Äî 1.8 </code> <br> <br>     parallel worker.        .     16    4  (    )      2 .,    ‚Äî 1,8 .     ,   ,     .  ,         . <br><br>     : <br><br> <code>explain analyze <br> select u1.* from usr u, usr1 u1 where <br> u.id=u1.id+0</code> <br> <br>     ,      . , user ‚Äî   ,    .     .    ,      ,   . <br><br>     ,   PostgreSQL 11           . <br><br><img src="https://habrastorage.org/webt/a4/si/tw/a4sitw7cyqsulcovvmv--yueczs.png"><br><br>    1425 ,  1,5 .    1,4 .  2  .  ,   9.6   : 1      ‚Äî  1 .,   2   1 .    ,    10    tuple.    11    .       :      user,   batch,    x-scan      append   . <br><br>    : <br><br><img src="https://habrastorage.org/webt/7f/rx/2h/7frx2hwdbaxaq4asujz7aembelq.png"><br><br>   .         211 ,   702 .   ,    510     1473.    ,      2  . <br><br>     parallel hash join.       .     ‚Äî 4.     ,     . <br><br>   parallel index scan    .     batch  .   ?        hash join,         .  user    .        ,  parallel hash,   . <br><br>     1 .  ,       OLAP-,  OLTP  .    OLTP  ,      . <br><br><a name="11"></a><h3>  </h3><br>      . <br><br><ul><li>       .   ,            .      ,    ¬´¬ª   ¬´¬ª,     index scan,     .    (highly skewed data),         ,    .      .    ,    ,    . </li><li>       ¬´¬ª,   . </li></ul><br><a name="12"></a><h3> Window- </h3><br>     SQL:2011,      . <br><br><a name="13"></a><h3>     </h3><br>   ,      ,    . ,   ,    ,  ,    ,    . <br><br>   websearch,     .      ,     .        ,   . <br><br> <code># select websearch_to_tsquery('dog or cat'); <br> ---------------------- <br> 'dor' | 'cat' <br> # select websearch_to_tsquery('dog -cat'); <br> ---------------------- <br> 'dor' &amp; !'cat' <br> # select websearch_to_tsquery('or cat'); <br> ---------------------- <br> 'cat'</code> <br> <br>   ‚Äî dog or cat ‚Äî   . Websearch      .     |  ,       .    ‚Äúor cat‚Äù.   ,   .    websearch  ‚Äúor‚Äù  .  ,    -,    . <br><br> Websearch ‚Äî     .       :        ,   .     ,   . <br><br><a name="14"></a><h3> Json(b)   </h3><br>  10-     ,   11-     .    json  json(b),   tsvector.   ( json(b))  -  .      ,    ,   ,  bull, numeric, string, .     . <br><br> <code># select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '"string"'); <br> ------------------- <br> 'text':1 <br> # select jsonb_to_tsvector <br> ('{"a":"texts", "b":12}', '["string", "numeric"]'); <br> ------------------- <br> '12':3 'text':1</code> <br> <br>     json(b),        .      ,   ,   ,   . <br><br><a name="15"></a><h3> PL/*  </h3><br>     . <br><br> <code>CREATE PROCEDURE transaction_test1() <br> LANGUAGE plpgsql <br> AS $$ <br> BEGIN <br> FOR i IN 0..9 LOOP <br> INSERT INTO test1 (a) VALUES (i); <br> IF i % 2 = 0 THEN <br> COMMIT; <br> ELSE <br> ROLLBACK; <br> END IF; <br> END LOOP; <br> END <br> $$; <br> CALL transaction_test1();</code> <br> <br>      call,       ,         .        .     .      select, insert   . <br><br>    ,    ,   PostgreSQL    .    Perl, Python, TL  PL/pgSQL.    Perl    sp begin,         . <br><br> PL/pgSQL    :    ,    . <br><br><a name="16"></a><h3> pgbench </h3><br>     pgbench  ICSB bench ‚Äî ,   ,       .    if,     ,     .  case,       - .   <code>--init-steps</code> ,    ,   . <br><br>         random-seed.   zipfian- .    / ‚Äî   ,      .   -    ,      ,  - ,  . <br><br> ,  ,    - . <br><br><a name="17"></a><h3>  PSQL </h3><br>  ,    PSQL,        .    exit  quit. <br><br><ul><li>   ‚Äî    copy,      2 <sup>32</sup> .  copy      :      2 <sup>32</sup> - . ,     2 <sup>31</sup>  2 <sup>32</sup> copy     .    64-  ,      2 <sup>64</sup> . </li><li>  POSIX  :   NaN <sup>0</sup> = 1  1 <sup>NaN</sup> = 1. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt414031/">https://habr.com/ru/post/pt414031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt414019/index.html">Solu√ß√£o universal para UITableViewRowAction e UIContextualAction</a></li>
<li><a href="../pt414023/index.html">Pergunte a Ethan: Qu√£o r√°pido a vida poderia ter aparecido no universo?</a></li>
<li><a href="../pt414025/index.html">Os empregadores rastreiam computadores, viagens ao banheiro e agora tamb√©m emo√ß√µes; Seu chefe segue voc√™?</a></li>
<li><a href="../pt414027/index.html">Meus amigos podem ser considerados verdadeiros amigos?</a></li>
<li><a href="../pt414029/index.html">Luz misteriosa ao redor de uma estrela rec√©m-formada, e o que os astr√¥nomos pensam sobre ela</a></li>
<li><a href="../pt414037/index.html">Uma vez em uma empresa HFT ...</a></li>
<li><a href="../pt414043/index.html">An√°lise de tabelas de roteamento ou por que outro engenheiro de rede Python</a></li>
<li><a href="../pt414045/index.html">Regulamento: nos Estados Unidos, as empresas dever√£o notificar vazamentos de PD dentro de 30 dias</a></li>
<li><a href="../pt414047/index.html">Como fazer uma poderosa escada Jacob a partir de um transformador de microondas com suas pr√≥prias m√£os</a></li>
<li><a href="../pt414049/index.html">Os principais jogos da E3 2018: Fallout 76, Metro Exodus, Doom Eternal e outros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>