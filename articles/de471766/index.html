<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏽 🔛 📽️ Kotlin / Java-Fehlerbehandlung: Wie geht das richtig? 🈁 🕢 🙋🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelle 


 Die Fehlerbehandlung in jeder Entwicklung spielt eine entscheidende Rolle. Fast alles kann im Programm schief gehen: Der Benutzer gibt fals...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin / Java-Fehlerbehandlung: Wie geht das richtig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/471766/"><img src="https://habrastorage.org/webt/hw/w3/mc/hww3mcjps5hwhykuwyzwj8upunu.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> </p><br><p>  Die Fehlerbehandlung in jeder Entwicklung spielt eine entscheidende Rolle.  Fast alles kann im Programm schief gehen: Der Benutzer gibt falsche Daten ein oder sie kommen über http oder wir haben einen Fehler beim Schreiben der Serialisierung / Deserialisierung gemacht und während der Verarbeitung stürzt das Programm mit einem Fehler ab.  Ja, es kann sein, dass der Speicherplatz knapp wird. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  ¯_ (ツ) _ / ¯, es gibt keinen einzigen Weg, und in jeder spezifischen Situation müssen Sie die am besten geeignete Option auswählen, aber es gibt Empfehlungen, wie Sie es besser machen können. </p></div></div><a name="habracut"></a><br><h3 id="predislovie">  Vorwort </h3><br><p>  Leider (oder nur so ein Leben?) Geht diese Liste weiter und weiter.  Der Entwickler muss ständig darüber nachdenken, dass irgendwo ein Fehler auftreten kann, und es gibt zwei Situationen: </p><br><ul><li>  wenn der erwartete Fehler beim Aufrufen der von uns bereitgestellten Funktion auftritt und versuchen kann, diese zu verarbeiten; </li><li>  wenn während des Vorgangs ein unerwarteter Fehler auftritt, den wir nicht vorhergesehen haben. </li></ul><br><p>  Und wenn die erwarteten Fehler zumindest lokalisiert sind, kann der Rest fast überall passieren.  Wenn wir nichts Wichtiges verarbeiten, können wir einfach mit einem Fehler abstürzen (obwohl dieses Verhalten nicht ausreicht und Sie dem Fehlerprotokoll mindestens eine Nachricht hinzufügen müssen).  Aber wenn gerade die Zahlung verarbeitet wird und Sie einfach nicht fallen können, müssen Sie zumindest eine Antwort über den erfolglosen Vorgang zurückgeben? </p><br><p>  Bevor wir uns mit Möglichkeiten zum Umgang mit Fehlern befassen, einige Worte zu Ausnahmen (Ausnahmen): </p><br><h3 id="exception">  Ausnahme </h3><br><img src="https://habrastorage.org/webt/hn/mx/yz/hnmxyzwyfbelfe32oqi1nyite4o.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> </p><br><p> Die Hierarchie der Ausnahmen ist gut beschrieben und Sie können viele Informationen darüber finden, so dass es keinen Sinn macht, sie hier zu malen.  Was immer noch manchmal zu heftigen Diskussionen führt, werden <code>checked</code> und Fehler <code>unchecked</code> .  Und obwohl die Mehrheit <code>unchecked</code> Ausnahmen als bevorzugt akzeptierte (in Kotlin gibt es überhaupt keine <code>checked</code> Ausnahmen), sind nicht alle damit einverstanden. </p><br><p>  Die <code>checked</code> Ausnahmen hatten wirklich die gute Absicht, sie zu einem bequemen Fehlerbehandlungsmechanismus zu machen, aber die Realität nahm ihre Anpassungen vor, obwohl die Idee, alle Ausnahmen, die von dieser Funktion aus in die Signatur geworfen werden können, in die Signatur einzuführen, verständlich und logisch ist. </p><br><p>  Schauen wir uns ein Beispiel an.  Angenommen, wir haben eine <code>method</code> , die eine überprüfte <code>PanicException</code> .  Eine solche Funktion würde folgendermaßen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> PanicException </span></span>{ }</code> </pre> <br><p>  Aus ihrer Beschreibung geht hervor, dass sie eine Ausnahme auslösen kann und dass es nur eine Ausnahme geben kann.  Sieht es ganz bequem aus?  Und während wir ein kleines Programm haben, ist es das.  Wenn das Programm jedoch etwas größer ist und es mehr solcher Funktionen gibt, treten einige Probleme auf. </p><br><p>  Geprüfte Ausnahmen erfordern laut Spezifikation, dass <strong>alle möglichen</strong> geprüften Ausnahmen (oder ein gemeinsamer Vorfahr für sie) in der Funktionssignatur aufgeführt sind.  Wenn wir also eine Kette von Aufrufen <code>a</code> -&gt; <code>b</code> -&gt; <code>c</code> und die am meisten verschachtelte Funktion eine Ausnahme auslöst, sollte sie für alle in der Kette abgelegt werden.  Und wenn es mehrere Ausnahmen gibt, sollte die oberste Funktion in der Signatur eine Beschreibung aller enthalten. </p><br><p>  Wenn das Programm komplexer wird, führt dieser Ansatz dazu, dass Ausnahmen an der obersten Funktion allmählich zu gemeinsamen Vorfahren zusammenfallen und letztendlich zu <code>Exception</code> .  Was in dieser Form einer <code>unchecked</code> Ausnahme ähnelt und alle Vorteile von geprüften Ausnahmen negiert. </p><br><p>  Und da sich das Programm als lebender Organismus ständig ändert und weiterentwickelt, ist es fast unmöglich, im Voraus vorherzusagen, welche Ausnahmen darin auftreten können.  Infolgedessen müssen wir beim Hinzufügen einer neuen Funktion mit einer neuen Ausnahme die gesamte Kette ihrer Verwendung durchlaufen und die Signaturen aller Funktionen ändern.  Stimmen Sie zu, dies ist nicht die angenehmste Aufgabe (selbst wenn man bedenkt, dass moderne IDEs dies für uns tun). </p><br><p>  Aber der letzte und wahrscheinlich größte Nagel in geprüften Ausnahmen hat Lambdas aus Java 8 "getrieben". Es gibt keine geprüften Ausnahmen ¯_ (ツ) _ / ¯ in ihrer Signatur (da jede Funktion in Lambda mit jeder aufgerufen werden kann Signatur), sodass jeder Funktionsaufruf mit einer aktivierten Ausnahme vom Lambda erzwingt, dass er als deaktiviert in eine Ausnahmeweiterleitung eingeschlossen wird: </p><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).forEach(item -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { functionWithCheckedException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"rethrow"</span></span>, e); } });</code> </pre> <br><p>  Glücklicherweise gibt es in der JVM-Spezifikation überhaupt keine geprüften Ausnahmen, sodass Sie in Kotlin nichts in dasselbe Lambda einwickeln können, sondern einfach die gewünschte Funktion aufrufen können. </p><br><div class="spoiler">  <b class="spoiler_title">obwohl manchmal ...</b> <div class="spoiler_text"><p>  Dies führt zwar manchmal zu unerwarteten Konsequenzen, wie zum Beispiel der fehlerhaften <code>@Transactional</code> von <code>@Transactional</code> im <code>Spring Framework</code> , bei der nur nicht <code>unckecked</code> Ausnahmen "erwartet" werden.  Dies ist jedoch eher ein Merkmal des Frameworks, und möglicherweise wird sich dieses Verhalten im Frühjahr in naher Zukunft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ändern</a> . </p></div></div><br><p>  Ausnahmen selbst sind spezielle Objekte.  Neben der Tatsache, dass sie durch Methoden "geworfen" werden können, sammeln sie bei der Erstellung auch Stacktrace.  Diese Funktion hilft dann bei der Analyse von Problemen und der Suche nach Fehlern, kann jedoch auch zu Leistungsproblemen führen, wenn die Anwendungslogik stark an ausgelöste Ausnahmen gebunden ist.  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel gezeigt</a> , kann das Deaktivieren der Stacktrace-Baugruppe in diesem Fall die Leistung erheblich steigern. Sie sollten jedoch nur in Ausnahmefällen darauf zurückgreifen, wenn dies wirklich erforderlich ist! </p><br><h3 id="obrabotka-oshibok">  Fehlerbehandlung </h3><br><p>  Die Hauptsache bei „unerwarteten“ Fehlern ist, einen Ort zu finden, an dem Sie sie abfangen können.  In JVM-Sprachen kann dies entweder ein Stream-Erstellungspunkt oder ein Filter- / Einstiegspunkt für die http-Methode sein, wo Sie einen Try-Catch für die Behandlung <code>unchecked</code> Fehler setzen können.  Wenn Sie ein Framework verwenden, kann es höchstwahrscheinlich bereits allgemeine Fehlerbehandlungsroutinen erstellen, da Sie beispielsweise im Spring Framework Methoden mit der Annotation <code>@ExceptionHandler</code> . </p><br><p>  Sie können Ausnahmen zu diesen zentralen Verarbeitungspunkten "auslösen", die wir an bestimmten Stellen nicht behandeln möchten, indem Sie dieselben nicht <code>unckecked</code> Ausnahmen <code>unckecked</code> (wenn wir beispielsweise nicht wissen, was an einer bestimmten Stelle zu tun ist und wie der Fehler zu behandeln ist).  Diese Methode ist jedoch nicht immer geeignet, da manchmal der Fehler behoben werden muss und Sie überprüfen müssen, ob alle Stellen von Funktionsaufrufen korrekt verarbeitet werden.  Überlegen Sie, wie Sie dies tun können. </p><br><ol><li><p>  Verwenden Sie weiterhin Ausnahmen und denselben Try-Catch: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { sum = calculateSum(a,b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { sum = -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Der Hauptnachteil besteht darin, dass wir „vergessen“ können, es an der Stelle des Aufrufs in einen Try-Catch zu packen und den Versuch, es an Ort und Stelle zu verarbeiten, zu überspringen, wodurch die Ausnahme bis zum allgemeinen Punkt der Fehlerverarbeitung ausgelöst wird.  Hier können wir zu <code>checked</code> Ausnahmen (für Java) gehen, aber dann werden wir alle oben genannten Nachteile bekommen.  Dieser Ansatz ist praktisch, wenn eine Fehlerbehandlung nicht immer erforderlich ist, in seltenen Fällen jedoch erforderlich ist. </p><br></li><li><p>  Verwenden Sie die versiegelte Klasse als Ergebnis eines Anrufs (Kotlin). <br>  In Kotlin können Sie die Anzahl der Klassenerben begrenzen und sie in der Kompilierungsphase berechenbar machen. Auf diese Weise kann der Compiler überprüfen, ob alle möglichen Optionen im Code analysiert wurden.  In Java können Sie eine gemeinsame Schnittstelle und mehrere Nachkommen erstellen, wobei jedoch Überprüfungen auf Kompilierungsebene verloren gehen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuccessResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>): Result() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExceptionResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exception: Exception): Result() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SuccessResult -&gt; result.value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ExceptionResult -&gt; { result.exception.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br><p>  Hier erhalten wir so etwas wie einen <code>golang</code> Fehler-Ansatz, wenn Sie die resultierenden Werte explizit überprüfen (oder explizit ignorieren) müssen.  Der Ansatz ist sehr praktisch und besonders praktisch, wenn Sie in jeder Situation viele Parameter eingeben müssen.  Die <code>Result</code> Klasse kann mit verschiedenen Methoden erweitert werden, die es einfacher machen, das Ergebnis mit einer Ausnahme zu erhalten, die oben ausgelöst wurde, falls vorhanden (d. H. Wir müssen den Fehler am Ort des Aufrufs nicht behandeln).  Der Hauptnachteil wird nur die Erstellung überflüssiger Zwischenobjekte (und ein etwas ausführlicherer Eintrag) sein, aber es kann auch mit <code>inline</code> Klassen entfernt werden (wenn ein Argument für uns ausreicht).  und als besonderes Beispiel gibt es eine <code>Result</code> von Kotlin.  Es ist wahr, es ist nur für den internen Gebrauch, als  In Zukunft kann sich die Implementierung geringfügig ändern. Wenn Sie sie jedoch verwenden möchten, können Sie das Kompilierungsflag <code>-Xallow-result-return-type</code> hinzufügen. </p><br></li><li><p>  Als einer der möglichen Typen von Anspruch 2 kann die Verwendung des Typs aus der funktionalen Programmierung von <code>Either</code> entweder ein Ergebnis oder ein Fehler sein.  Der Typ selbst kann entweder eine <code>sealed</code> Klasse oder eine <code>inline</code> Klasse sein.  Unten finden Sie ein Beispiel für die Verwendung der Implementierung aus der <code>arrow</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Left -&gt; { result.a.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Right -&gt; result.b }</code> </pre> <br><p>  <code>Either</code> am besten für diejenigen geeignet, die einen funktionalen Ansatz lieben und gerne Anrufketten aufbauen. </p><br></li><li><p>  Verwenden Sie <code>Option</code> oder <code>nullable</code> Typ von Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"some exception"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?</code> </pre> <br><p>  Dieser Ansatz ist geeignet, wenn die Fehlerursache nicht sehr wichtig ist und wenn es sich nur um eine handelt.  Eine leere Antwort wird als Fehler betrachtet und höher geworfen.  Der kürzeste Datensatz, ohne zusätzliche Objekte zu erstellen, aber dieser Ansatz kann nicht immer angewendet werden. </p><br></li><li><p>  Verwendet ähnlich wie in Punkt 4 nur einen Hardcode-Wert als Fehlermarkierung: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(“error”) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span></code> </pre> <br><p>  Dies ist wahrscheinlich der älteste Ansatz zur Fehlerbehandlung, der von <code>C</code> (oder sogar von Algol) stammt.  Es gibt keinen Overhead, nur einen Code, der nicht ganz klar ist (zusammen mit Einschränkungen bei der Auswahl des Ergebnisses), aber im Gegensatz zu Schritt 4 ist es möglich, verschiedene Fehlercodes zu erstellen, wenn mehr als eine mögliche Ausnahme erforderlich ist. </p><br></li></ol><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p>  Alle Ansätze können je nach Situation kombiniert werden, und es gibt keinen, der in allen Fällen geeignet ist. </p><br><p>  So können Sie beispielsweise mithilfe <code>sealed</code> Klassen einen <code>golang</code> Ansatz für Fehler erzielen. <code>golang</code> dies nicht sehr praktisch ist, fahren Sie mit <code>unchecked</code> Fehlern fort. </p><br><p>  Oder verwenden Sie in den meisten <code>nullable</code> Typ als Markierung dafür, dass der Wert nicht berechnet oder von irgendwoher abgerufen werden konnte (z. B. als Indikator dafür, dass der Wert nicht in der Datenbank gefunden wurde). </p><br><p>  Und wenn Sie voll funktionsfähigen Code zusammen mit <code>arrow</code> oder einer ähnlichen Bibliothek haben, ist es höchstwahrscheinlich am besten, <code>Either</code> zu verwenden. </p><br><p>  Bei http-Servern ist es am einfachsten, alle Fehler auf zentrale Punkte zu heben und nur an einigen Stellen den <code>nullable</code> Ansatz mit <code>sealed</code> Klassen zu kombinieren. </p><br><p>  Ich werde mich freuen, in den Kommentaren zu sehen, dass Sie dies verwenden, oder gibt es vielleicht andere bequeme Methoden zur Fehlerbehandlung? </p><br><p>  Und danke an alle, die bis zum Ende gelesen haben! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471766/">https://habr.com/ru/post/de471766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471748/index.html">Apothekenoptimierung: Was wir mit Mathe gemacht haben</a></li>
<li><a href="../de471750/index.html">Privilegierte Zugriffsverwaltung als vorrangige Aufgabe in der Informationssicherheit (z. B. Fudo PAM)</a></li>
<li><a href="../de471756/index.html">Wie der Server startet</a></li>
<li><a href="../de471758/index.html">Wie übersetze ich Text in eine andere Sprache?</a></li>
<li><a href="../de471760/index.html">Edward Snowden: Das Schlachtfeld - Verschlüsselung</a></li>
<li><a href="../de471770/index.html">Lernen Sie Big Data Tools kennen: Spark- und Zeppelin-Notebook-Unterstützung in IntelliJ IDEA</a></li>
<li><a href="../de471772/index.html">Tools zum Starten und Entwickeln von Java-Anwendungen, Kompilieren und Ausführen auf der JVM</a></li>
<li><a href="../de471774/index.html">Android Camera2 API aus der Teekanne, Teil 2, schreibt ein Video</a></li>
<li><a href="../de471776/index.html">Laravel: Erklären Sie die Grundkonzepte. Zweiter Teil: Üben</a></li>
<li><a href="../de471778/index.html">Breaking Micosoft Lunix bei HackQuest 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>