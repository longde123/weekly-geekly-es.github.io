<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèΩ üîõ üìΩÔ∏è Kotlin / Java-Fehlerbehandlung: Wie geht das richtig? üàÅ üï¢ üôãüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quelle 


 Die Fehlerbehandlung in jeder Entwicklung spielt eine entscheidende Rolle. Fast alles kann im Programm schief gehen: Der Benutzer gibt fals...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin / Java-Fehlerbehandlung: Wie geht das richtig?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/471766/"><img src="https://habrastorage.org/webt/hw/w3/mc/hww3mcjps5hwhykuwyzwj8upunu.jpeg"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> </p><br><p>  Die Fehlerbehandlung in jeder Entwicklung spielt eine entscheidende Rolle.  Fast alles kann im Programm schief gehen: Der Benutzer gibt falsche Daten ein oder sie kommen √ºber http oder wir haben einen Fehler beim Schreiben der Serialisierung / Deserialisierung gemacht und w√§hrend der Verarbeitung st√ºrzt das Programm mit einem Fehler ab.  Ja, es kann sein, dass der Speicherplatz knapp wird. </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler</b> <div class="spoiler_text"><p>  ¬Ø_ („ÉÑ) _ / ¬Ø, es gibt keinen einzigen Weg, und in jeder spezifischen Situation m√ºssen Sie die am besten geeignete Option ausw√§hlen, aber es gibt Empfehlungen, wie Sie es besser machen k√∂nnen. </p></div></div><a name="habracut"></a><br><h3 id="predislovie">  Vorwort </h3><br><p>  Leider (oder nur so ein Leben?) Geht diese Liste weiter und weiter.  Der Entwickler muss st√§ndig dar√ºber nachdenken, dass irgendwo ein Fehler auftreten kann, und es gibt zwei Situationen: </p><br><ul><li>  wenn der erwartete Fehler beim Aufrufen der von uns bereitgestellten Funktion auftritt und versuchen kann, diese zu verarbeiten; </li><li>  wenn w√§hrend des Vorgangs ein unerwarteter Fehler auftritt, den wir nicht vorhergesehen haben. </li></ul><br><p>  Und wenn die erwarteten Fehler zumindest lokalisiert sind, kann der Rest fast √ºberall passieren.  Wenn wir nichts Wichtiges verarbeiten, k√∂nnen wir einfach mit einem Fehler abst√ºrzen (obwohl dieses Verhalten nicht ausreicht und Sie dem Fehlerprotokoll mindestens eine Nachricht hinzuf√ºgen m√ºssen).  Aber wenn gerade die Zahlung verarbeitet wird und Sie einfach nicht fallen k√∂nnen, m√ºssen Sie zumindest eine Antwort √ºber den erfolglosen Vorgang zur√ºckgeben? </p><br><p>  Bevor wir uns mit M√∂glichkeiten zum Umgang mit Fehlern befassen, einige Worte zu Ausnahmen (Ausnahmen): </p><br><h3 id="exception">  Ausnahme </h3><br><img src="https://habrastorage.org/webt/hn/mx/yz/hnmxyzwyfbelfe32oqi1nyite4o.png"><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> </p><br><p> Die Hierarchie der Ausnahmen ist gut beschrieben und Sie k√∂nnen viele Informationen dar√ºber finden, so dass es keinen Sinn macht, sie hier zu malen.  Was immer noch manchmal zu heftigen Diskussionen f√ºhrt, werden <code>checked</code> und Fehler <code>unchecked</code> .  Und obwohl die Mehrheit <code>unchecked</code> Ausnahmen als bevorzugt akzeptierte (in Kotlin gibt es √ºberhaupt keine <code>checked</code> Ausnahmen), sind nicht alle damit einverstanden. </p><br><p>  Die <code>checked</code> Ausnahmen hatten wirklich die gute Absicht, sie zu einem bequemen Fehlerbehandlungsmechanismus zu machen, aber die Realit√§t nahm ihre Anpassungen vor, obwohl die Idee, alle Ausnahmen, die von dieser Funktion aus in die Signatur geworfen werden k√∂nnen, in die Signatur einzuf√ºhren, verst√§ndlich und logisch ist. </p><br><p>  Schauen wir uns ein Beispiel an.  Angenommen, wir haben eine <code>method</code> , die eine √ºberpr√ºfte <code>PanicException</code> .  Eine solche Funktion w√ºrde folgenderma√üen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> PanicException </span></span>{ }</code> </pre> <br><p>  Aus ihrer Beschreibung geht hervor, dass sie eine Ausnahme ausl√∂sen kann und dass es nur eine Ausnahme geben kann.  Sieht es ganz bequem aus?  Und w√§hrend wir ein kleines Programm haben, ist es das.  Wenn das Programm jedoch etwas gr√∂√üer ist und es mehr solcher Funktionen gibt, treten einige Probleme auf. </p><br><p>  Gepr√ºfte Ausnahmen erfordern laut Spezifikation, dass <strong>alle m√∂glichen</strong> gepr√ºften Ausnahmen (oder ein gemeinsamer Vorfahr f√ºr sie) in der Funktionssignatur aufgef√ºhrt sind.  Wenn wir also eine Kette von Aufrufen <code>a</code> -&gt; <code>b</code> -&gt; <code>c</code> und die am meisten verschachtelte Funktion eine Ausnahme ausl√∂st, sollte sie f√ºr alle in der Kette abgelegt werden.  Und wenn es mehrere Ausnahmen gibt, sollte die oberste Funktion in der Signatur eine Beschreibung aller enthalten. </p><br><p>  Wenn das Programm komplexer wird, f√ºhrt dieser Ansatz dazu, dass Ausnahmen an der obersten Funktion allm√§hlich zu gemeinsamen Vorfahren zusammenfallen und letztendlich zu <code>Exception</code> .  Was in dieser Form einer <code>unchecked</code> Ausnahme √§hnelt und alle Vorteile von gepr√ºften Ausnahmen negiert. </p><br><p>  Und da sich das Programm als lebender Organismus st√§ndig √§ndert und weiterentwickelt, ist es fast unm√∂glich, im Voraus vorherzusagen, welche Ausnahmen darin auftreten k√∂nnen.  Infolgedessen m√ºssen wir beim Hinzuf√ºgen einer neuen Funktion mit einer neuen Ausnahme die gesamte Kette ihrer Verwendung durchlaufen und die Signaturen aller Funktionen √§ndern.  Stimmen Sie zu, dies ist nicht die angenehmste Aufgabe (selbst wenn man bedenkt, dass moderne IDEs dies f√ºr uns tun). </p><br><p>  Aber der letzte und wahrscheinlich gr√∂√üte Nagel in gepr√ºften Ausnahmen hat Lambdas aus Java 8 "getrieben". Es gibt keine gepr√ºften Ausnahmen ¬Ø_ („ÉÑ) _ / ¬Ø in ihrer Signatur (da jede Funktion in Lambda mit jeder aufgerufen werden kann Signatur), sodass jeder Funktionsaufruf mit einer aktivierten Ausnahme vom Lambda erzwingt, dass er als deaktiviert in eine Ausnahmeweiterleitung eingeschlossen wird: </p><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>).forEach(item -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { functionWithCheckedException(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"rethrow"</span></span>, e); } });</code> </pre> <br><p>  Gl√ºcklicherweise gibt es in der JVM-Spezifikation √ºberhaupt keine gepr√ºften Ausnahmen, sodass Sie in Kotlin nichts in dasselbe Lambda einwickeln k√∂nnen, sondern einfach die gew√ºnschte Funktion aufrufen k√∂nnen. </p><br><div class="spoiler">  <b class="spoiler_title">obwohl manchmal ...</b> <div class="spoiler_text"><p>  Dies f√ºhrt zwar manchmal zu unerwarteten Konsequenzen, wie zum Beispiel der fehlerhaften <code>@Transactional</code> von <code>@Transactional</code> im <code>Spring Framework</code> , bei der nur nicht <code>unckecked</code> Ausnahmen "erwartet" werden.  Dies ist jedoch eher ein Merkmal des Frameworks, und m√∂glicherweise wird sich dieses Verhalten im Fr√ºhjahr in naher Zukunft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√§ndern</a> . </p></div></div><br><p>  Ausnahmen selbst sind spezielle Objekte.  Neben der Tatsache, dass sie durch Methoden "geworfen" werden k√∂nnen, sammeln sie bei der Erstellung auch Stacktrace.  Diese Funktion hilft dann bei der Analyse von Problemen und der Suche nach Fehlern, kann jedoch auch zu Leistungsproblemen f√ºhren, wenn die Anwendungslogik stark an ausgel√∂ste Ausnahmen gebunden ist.  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel gezeigt</a> , kann das Deaktivieren der Stacktrace-Baugruppe in diesem Fall die Leistung erheblich steigern. Sie sollten jedoch nur in Ausnahmef√§llen darauf zur√ºckgreifen, wenn dies wirklich erforderlich ist! </p><br><h3 id="obrabotka-oshibok">  Fehlerbehandlung </h3><br><p>  Die Hauptsache bei ‚Äûunerwarteten‚Äú Fehlern ist, einen Ort zu finden, an dem Sie sie abfangen k√∂nnen.  In JVM-Sprachen kann dies entweder ein Stream-Erstellungspunkt oder ein Filter- / Einstiegspunkt f√ºr die http-Methode sein, wo Sie einen Try-Catch f√ºr die Behandlung <code>unchecked</code> Fehler setzen k√∂nnen.  Wenn Sie ein Framework verwenden, kann es h√∂chstwahrscheinlich bereits allgemeine Fehlerbehandlungsroutinen erstellen, da Sie beispielsweise im Spring Framework Methoden mit der Annotation <code>@ExceptionHandler</code> . </p><br><p>  Sie k√∂nnen Ausnahmen zu diesen zentralen Verarbeitungspunkten "ausl√∂sen", die wir an bestimmten Stellen nicht behandeln m√∂chten, indem Sie dieselben nicht <code>unckecked</code> Ausnahmen <code>unckecked</code> (wenn wir beispielsweise nicht wissen, was an einer bestimmten Stelle zu tun ist und wie der Fehler zu behandeln ist).  Diese Methode ist jedoch nicht immer geeignet, da manchmal der Fehler behoben werden muss und Sie √ºberpr√ºfen m√ºssen, ob alle Stellen von Funktionsaufrufen korrekt verarbeitet werden.  √úberlegen Sie, wie Sie dies tun k√∂nnen. </p><br><ol><li><p>  Verwenden Sie weiterhin Ausnahmen und denselben Try-Catch: </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { sum = calculateSum(a,b); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { sum = -<span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  Der Hauptnachteil besteht darin, dass wir ‚Äûvergessen‚Äú k√∂nnen, es an der Stelle des Aufrufs in einen Try-Catch zu packen und den Versuch, es an Ort und Stelle zu verarbeiten, zu √ºberspringen, wodurch die Ausnahme bis zum allgemeinen Punkt der Fehlerverarbeitung ausgel√∂st wird.  Hier k√∂nnen wir zu <code>checked</code> Ausnahmen (f√ºr Java) gehen, aber dann werden wir alle oben genannten Nachteile bekommen.  Dieser Ansatz ist praktisch, wenn eine Fehlerbehandlung nicht immer erforderlich ist, in seltenen F√§llen jedoch erforderlich ist. </p><br></li><li><p>  Verwenden Sie die versiegelte Klasse als Ergebnis eines Anrufs (Kotlin). <br>  In Kotlin k√∂nnen Sie die Anzahl der Klassenerben begrenzen und sie in der Kompilierungsphase berechenbar machen. Auf diese Weise kann der Compiler √ºberpr√ºfen, ob alle m√∂glichen Optionen im Code analysiert wurden.  In Java k√∂nnen Sie eine gemeinsame Schnittstelle und mehrere Nachkommen erstellen, wobei jedoch √úberpr√ºfungen auf Kompilierungsebene verloren gehen. </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuccessResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>): Result() <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExceptionResult</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> exception: Exception): Result() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SuccessResult -&gt; result.value <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ExceptionResult -&gt; { result.exception.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } }</code> </pre> <br><p>  Hier erhalten wir so etwas wie einen <code>golang</code> Fehler-Ansatz, wenn Sie die resultierenden Werte explizit √ºberpr√ºfen (oder explizit ignorieren) m√ºssen.  Der Ansatz ist sehr praktisch und besonders praktisch, wenn Sie in jeder Situation viele Parameter eingeben m√ºssen.  Die <code>Result</code> Klasse kann mit verschiedenen Methoden erweitert werden, die es einfacher machen, das Ergebnis mit einer Ausnahme zu erhalten, die oben ausgel√∂st wurde, falls vorhanden (d. H. Wir m√ºssen den Fehler am Ort des Aufrufs nicht behandeln).  Der Hauptnachteil wird nur die Erstellung √ºberfl√ºssiger Zwischenobjekte (und ein etwas ausf√ºhrlicherer Eintrag) sein, aber es kann auch mit <code>inline</code> Klassen entfernt werden (wenn ein Argument f√ºr uns ausreicht).  und als besonderes Beispiel gibt es eine <code>Result</code> von Kotlin.  Es ist wahr, es ist nur f√ºr den internen Gebrauch, als  In Zukunft kann sich die Implementierung geringf√ºgig √§ndern. Wenn Sie sie jedoch verwenden m√∂chten, k√∂nnen Sie das Kompilierungsflag <code>-Xallow-result-return-type</code> hinzuf√ºgen. </p><br></li><li><p>  Als einer der m√∂glichen Typen von Anspruch 2 kann die Verwendung des Typs aus der funktionalen Programmierung von <code>Either</code> entweder ein Ergebnis oder ein Fehler sein.  Der Typ selbst kann entweder eine <code>sealed</code> Klasse oder eine <code>inline</code> Klasse sein.  Unten finden Sie ein Beispiel f√ºr die Verwendung der Implementierung aus der <code>arrow</code> : </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculateSum(a,b)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Left -&gt; { result.a.printStackTrace() -<span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Either.Right -&gt; result.b }</code> </pre> <br><p>  <code>Either</code> am besten f√ºr diejenigen geeignet, die einen funktionalen Ansatz lieben und gerne Anrufketten aufbauen. </p><br></li><li><p>  Verwenden Sie <code>Option</code> oder <code>nullable</code> Typ von Kotlin: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) ?: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"some exception"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>?</code> </pre> <br><p>  Dieser Ansatz ist geeignet, wenn die Fehlerursache nicht sehr wichtig ist und wenn es sich nur um eine handelt.  Eine leere Antwort wird als Fehler betrachtet und h√∂her geworfen.  Der k√ºrzeste Datensatz, ohne zus√§tzliche Objekte zu erstellen, aber dieser Ansatz kann nicht immer angewendet werden. </p><br></li><li><p>  Verwendet √§hnlich wie in Punkt 4 nur einen Hardcode-Wert als Fehlermarkierung: </p><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testFun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = calculateSum(a,b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> RuntimeException(‚Äúerror‚Äù) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span></code> </pre> <br><p>  Dies ist wahrscheinlich der √§lteste Ansatz zur Fehlerbehandlung, der von <code>C</code> (oder sogar von Algol) stammt.  Es gibt keinen Overhead, nur einen Code, der nicht ganz klar ist (zusammen mit Einschr√§nkungen bei der Auswahl des Ergebnisses), aber im Gegensatz zu Schritt 4 ist es m√∂glich, verschiedene Fehlercodes zu erstellen, wenn mehr als eine m√∂gliche Ausnahme erforderlich ist. </p><br></li></ol><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p>  Alle Ans√§tze k√∂nnen je nach Situation kombiniert werden, und es gibt keinen, der in allen F√§llen geeignet ist. </p><br><p>  So k√∂nnen Sie beispielsweise mithilfe <code>sealed</code> Klassen einen <code>golang</code> Ansatz f√ºr Fehler erzielen. <code>golang</code> dies nicht sehr praktisch ist, fahren Sie mit <code>unchecked</code> Fehlern fort. </p><br><p>  Oder verwenden Sie in den meisten <code>nullable</code> Typ als Markierung daf√ºr, dass der Wert nicht berechnet oder von irgendwoher abgerufen werden konnte (z. B. als Indikator daf√ºr, dass der Wert nicht in der Datenbank gefunden wurde). </p><br><p>  Und wenn Sie voll funktionsf√§higen Code zusammen mit <code>arrow</code> oder einer √§hnlichen Bibliothek haben, ist es h√∂chstwahrscheinlich am besten, <code>Either</code> zu verwenden. </p><br><p>  Bei http-Servern ist es am einfachsten, alle Fehler auf zentrale Punkte zu heben und nur an einigen Stellen den <code>nullable</code> Ansatz mit <code>sealed</code> Klassen zu kombinieren. </p><br><p>  Ich werde mich freuen, in den Kommentaren zu sehen, dass Sie dies verwenden, oder gibt es vielleicht andere bequeme Methoden zur Fehlerbehandlung? </p><br><p>  Und danke an alle, die bis zum Ende gelesen haben! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471766/">https://habr.com/ru/post/de471766/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471748/index.html">Apothekenoptimierung: Was wir mit Mathe gemacht haben</a></li>
<li><a href="../de471750/index.html">Privilegierte Zugriffsverwaltung als vorrangige Aufgabe in der Informationssicherheit (z. B. Fudo PAM)</a></li>
<li><a href="../de471756/index.html">Wie der Server startet</a></li>
<li><a href="../de471758/index.html">Wie √ºbersetze ich Text in eine andere Sprache?</a></li>
<li><a href="../de471760/index.html">Edward Snowden: Das Schlachtfeld - Verschl√ºsselung</a></li>
<li><a href="../de471770/index.html">Lernen Sie Big Data Tools kennen: Spark- und Zeppelin-Notebook-Unterst√ºtzung in IntelliJ IDEA</a></li>
<li><a href="../de471772/index.html">Tools zum Starten und Entwickeln von Java-Anwendungen, Kompilieren und Ausf√ºhren auf der JVM</a></li>
<li><a href="../de471774/index.html">Android Camera2 API aus der Teekanne, Teil 2, schreibt ein Video</a></li>
<li><a href="../de471776/index.html">Laravel: Erkl√§ren Sie die Grundkonzepte. Zweiter Teil: √úben</a></li>
<li><a href="../de471778/index.html">Breaking Micosoft Lunix bei HackQuest 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>