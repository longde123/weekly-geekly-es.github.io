<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛴️ 🏺 📬 Tests oder Typen 🥩 ‼️ 🤴🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. Neulich habe ich nach einer Möglichkeit gesucht, etwas in Idris zu tun, und bin auf einen guten Beitrag gestoßen, dessen kostenlose Überse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests oder Typen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467677/"><p>  <em>Hallo Habr.</em>  <em>Neulich habe ich nach einer Möglichkeit gesucht, etwas in Idris zu tun, und bin auf einen guten Beitrag gestoßen, dessen kostenlose Übersetzung durchaus angemessen erscheint.</em>  <em>Freiheiten und Knebel, wo nötig, werde ich "hier durch solche Kringel am Anfang und am Ende" bezeichnen.</em> </p><br><p>  Wann und wann Tests verwenden?  Welche Informationen und welche Garantien erhalten wir im Austausch für unsere Bemühungen, sie zu schreiben? </p><br><p>  Wir werden uns ein einfaches und leicht erfundenes Beispiel ansehen, das in Python, C, Haskell und Idris ausgedrückt wird.  Wir werden auch sehen, was über die Implementierung gesagt werden kann, ohne jeweils zusätzliches Wissen darüber. </p><br><p> Wir werden die verschiedenen Hintertüren nicht berücksichtigen, die es uns ermöglichen, die <code>unsafePerformIO</code> explizit zu verletzen (z. B. C-Erweiterungen, <code>unsafePerformIO</code> in Haskell, unsichere Typkonvertierungen), da sonst keine Schlussfolgerungen gezogen werden können und dieser Beitrag recht kurz ist.  "Darüber hinaus verfügt derselbe Haskell über eine Teilmenge von Safe Haskell, die die Verwendung dieser und einer Reihe anderer Tricks, die die Integrität der Sprache verletzen könnten, explizit und transitiv verbietet." </p><a name="habracut"></a><br><h2>  Spezifikation </h2><br><blockquote>  Lassen Sie eine Liste und eine Bedeutung gegeben werden.  Es ist erforderlich, den Index dieses Werts in der Liste zurückzugeben oder anzugeben, dass dieser Wert nicht in der Liste enthalten ist. </blockquote><p>  Die Implementierung dieser Spezifikation ist trivial, daher ist es selbstverständlich zu fragen, und hier sind im Allgemeinen Tests oder Typen.  Diese Eigenschaften und Argumentationsmethoden, über die wir heute sprechen werden, sind jedoch auf einen viel komplexeren Code anwendbar.  Lassen Sie die Implementierung zehntausend Zeilen unlesbaren Spaghetti-Codes verwenden, wenn dies hilft, ihre Nützlichkeit zu erkennen. </p><br><h2>  Python </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y, z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 10000   </span></span></code> </pre> <br><p>  Wir stellen sofort fest, dass wir nicht an den ungeprüften sem- und semantikunabhängigen Eigenschaften eines Programms wie Variablennamen und Textdokumentation interessiert sind. Daher habe ich absichtlich keinen Code geschrieben, der die Wahrnehmung unterstützt.  Wir sind nur daran interessiert, dass es vorbehaltlich bestehender Tests und Typprüfungen <em>nicht unwahr sein kann</em> . </p><br><p>  Im obigen Code gibt es praktisch keine nützlichen Informationen außer der Tatsache, dass wir eine Funktion haben, die zwei Argumente akzeptiert.  Diese Funktion kann ebenso gut den Index des Wertes in der Liste finden oder einen beleidigenden Brief an Ihre Großmutter senden. </p><br><p>  <strong>Analyse</strong> </p><br><p>  Wir erhalten nicht nur fragilen Code ohne Tests und Typen, sondern unsere einzige Möglichkeit zu verstehen, was eine Funktion tut, ist die Dokumentation.  Und da die Dokumentation von Personen und nicht von Maschinen überprüft wird, kann sie sich leicht als veraltet oder anfangs falsch herausstellen. </p><br><ul><li>  <strong>Die Dokumentation</strong> <br><ul><li>  ✗ Wir kennen das erwartete Verhalten <br>  Über das Verhalten dieser Funktion haben wir nichts zu sagen.  Du hasst deine Großmutter.  Du bist ein Monster. </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  ✓ Speichersicherheit <br>  Python ist eine Garbage Collection-Sprache, die uns dieses Problem beseitigt.  "Soweit ich weiß, hindert Sie jedoch nichts daran, unsichere Bibliotheken oder C FFI in diese Funktion zu ziehen." </li></ul></li></ul><br><h2>  Python mit Tests </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_happy_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_missing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Jetzt wissen wir, dass unsere Funktion funktioniert, und wenn das Element fehlt, ist das Ergebnis <code>None</code> ? </p><br><p>  Nun ... nein.  Dies ist nur ein Beispiel.  Leider ist der Umfang unserer Funktion unendlich und keine Anzahl von Beispielen kann die korrekte Funktionsweise unserer Funktion beweisen.  Mehr Tests - mehr Vertrauen, aber keine Anzahl von Tests wird alle Zweifel lösen. </p><br><p>  Die Möglichkeit, dass diese Funktion <code>None</code> für <code>4</code> , aber nicht für <code>5</code> zurückgibt, klingt ziemlich verrückt, und in diesem speziellen Fall ist dies höchstwahrscheinlich Unsinn.  Wir können mit unserem Glaubensniveau zufrieden sein und uns mit einer bestimmten Anzahl von Beispielen befassen.  Aber andererseits wird der Beitrag kurz sein. Stellen wir uns also vor, dass die Implementierung nicht so offensichtlich ist. </p><br><p>  Da die Tests im allgemeinen Fall nichts beweisen können, sondern nur das Verhalten <em>anhand</em> spezifischer Beispiele zeigen, können die Tests <em>keine</em> Fehlerfreiheit nachweisen.  Zum Beispiel gibt es keinen Test, der zeigen würde, dass unsere Funktion niemals eine Ausnahme auslöst oder niemals in den ewigen Zyklus eintritt oder keine ungültigen Links enthält.  Dies kann nur eine statische Analyse sein. </p><br><p>  Auch wenn die Beispiele in der Rolle der Beweise nicht sehr gut sind, stellen sie zumindest eine gute Dokumentation dar.  Aus diesen beiden Beispielen können wir die vollständige Spezifikation unter einigen zusätzlichen a priori-Annahmen ableiten - diese beiden Beispiele erfüllen beispielsweise auch die „Gegenspezifikation“ „finde das Element im Array und gib das vorherige zurück, falls vorhanden“, für dessen Erfindung ich zehn Sekunden gebraucht habe . </p><br><p>  <strong>Analyse</strong> </p><br><p>  Obwohl Tests zeigen können, wie unsere Funktion verwendet wird, und auch ein wenig Sicherheit geben können, dass diese Funktion mit zumindest einigen Beispielen korrekt funktioniert, können sie im allgemeinen Fall nichts über unseren Code <em>beweisen</em> .  Dies bedeutet leider, dass Tests nur teilweise dazu beitragen, Fehler zu vermeiden. </p><br><ul><li>  <strong>Die Dokumentation</strong> <br><ul><li>  ✓ <strong>Wir haben ein Anwendungsbeispiel</strong> </li><li>  ✓ <strong>Wir kennen einige</strong> Werteklassen <strong>, die korrekt verarbeitet werden</strong> </li><li>  ✗ Wir kennen alle Arten von Werten, die korrekt verarbeitet werden <br>  Wir haben keine Einschränkungen hinsichtlich der Argumenttypen. Trotz der Existenz von Beispielen für die Funktionsweise der Funktion wissen wir nicht, welche Typen nicht getestet wurden. </li><li>  ✗ Wir kennen das erwartete Verhalten <br>  "Der Autor des Originalartikels hat hier angekreuzt. Ich erlaube mir, angesichts des obigen Kommentars ein Kreuz zu setzen." </li></ul></li><li>  <strong>Spezifikation</strong> <br><ul><li>  ✓ <strong>Funktioniert in mindestens einem Fall</strong> </li><li>  ✗ Der zurückgegebene Index ist immer ein gültiger Index </li><li>  ✗ Der zurückgegebene Index gibt immer einen geeigneten Wert an </li><li>  ✗ Fehlende Elemente geben immer <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Häufige Fehler</strong> <br><ul><li>  ✗ Keine Tippfehler oder falschen Namen <br>  Statische Analysen können helfen, aber da Python eine dynamische Sprache ist, die zur Laufzeit verschiedene Dinge überschreiben kann, können wir niemals beweisen, dass es keine Fehler gibt. <br>  Insbesondere kann es sehr schwierig oder unmöglich sein, festzustellen, ob der Methodenname korrekt ist, da die Gültigkeit des Methodenaufrufs vom Laufzeittyp des Objekts abhängt, für das der Aufruf erfolgt. </li><li>  ✗ Keine unerwartete <code>null</code> </li><li>  ✗ Fehlerfälle werden immer behandelt <br>  Nach meiner Erfahrung ist dies eine der häufigsten Fehlerquellen: In unserem Beispiel gibt die Funktion bei fehlendem Element <code>None</code> zurück, aber der Code, der diese Funktion verwendet, kann beispielsweise davon ausgehen, dass immer eine Zahl zurückgegeben wird.  Darüber hinaus kann dies auch zu einer nicht behandelten Ausnahme führen. </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  ✓ Speichersicherheit </li><li>  ✗ Die Funktion kann nicht mit dem falschen Typ aufgerufen werden </li><li>  ✗ Keine Nebenwirkungen </li><li>  ✗ Keine Ausnahmen </li><li>  ✗ Keine Fehler </li><li>  ✗ Keine ewigen Zyklen </li></ul></li></ul><br><h2>  Haskell </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">xyz</span></span> = <span class="hljs-comment"><span class="hljs-comment">-- 10000  </span></span></code> </pre> <br><p>  Wenn Sie mit der Syntax nicht vertraut sind: Dies ist die Definition einer Funktion <code>x</code> mit den Parametern <code>y</code> und <code>z</code> .  In Haskell können Sie Typen weglassen, da diese aus der Implementierung abgeleitet werden (es sei denn, Sie verwenden natürlich andere erweiterte Funktionen als moderne Erweiterungen des Typsystems). </p><br><p>  Es scheint, dass dies nicht sehr verschieden von der Python-Version ist, aber nur weil wir unsere Funktion in Haskell geschrieben haben und sie gekachelt ist, können wir bereits über einige interessante Eigenschaften sprechen. </p><br><p>  <strong>Analyse</strong> </p><br><p>  Natürlich können wir hier nicht so viele Schlussfolgerungen ziehen, aber hier sind einige Punkte zu beachten: </p><br><ul><li>  <strong>Die Dokumentation</strong> <br><ul><li>  ✗ Wir kennen das erwartete Verhalten </li></ul></li><li>  <strong>Häufige Fehler</strong> <br><ul><li>  ✓ <strong>Keine Tippfehler oder falschen Namen</strong> <br>  Da Haskell eine kompilierte Sprache ist, müssen alle Namen zur Kompilierungszeit aufgelöst werden.  Das Programm wird einfach nicht kompiliert, wenn dieser Fehler auftritt. </li><li>  ✓ <strong>Keine unerwartete <code>null</code></strong> <br>  Haskell hat einfach keine <code>null</code> .  Das Problem ist gelöst! </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  ✓ Speichersicherheit </li><li>  ✓ <strong>Die Funktion kann nicht mit dem falschen Typ aufgerufen werden</strong> </li><li>  ✓ <strong>Keine <em>unerwarteten</em> Nebenwirkungen</strong> <br>  ⟦Der Autor des Originalartikels hat diesen Artikel nicht angegeben, aber ich erlaube mir zu beachten, dass der abgeleitete Typ dieser Funktion bei Nebenwirkungen auf deren Vorhandensein hinweist, sodass der aufrufende Code über ihre Funktionen informiert ist.⟧ </li></ul></li></ul><br><h2>  Angabe des Haskell-Typs </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> :: <span class="hljs-type"><span class="hljs-type">Eq</span></span> a =&gt; [a] -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> xyz = <span class="hljs-comment"><span class="hljs-comment">-- ...</span></span></code> </pre> <br><p>  Früher haben wir über eine eher vernünftige Haltung gegenüber der Sicherheit von Großmüttern gesprochen: Aus den Tests ging hervor, dass die Funktion niemandem schaden würde, aber <em>war die</em> Großmutter <em>wirklich</em> sicher?  Sendet diese Funktion genau keine Schimpfwörter? </p><br><p>  Haskell ist bekannt als reine Funktionssprache.  Dies bedeutet nicht, dass der Code keine Nebenwirkungen haben kann, aber alle Nebenwirkungen müssen im Typ vorhanden sein.  Wir kennen den Typ dieser Funktion und sehen, dass sie sauber ist. Daher sind wir sicher, dass diese Funktion keinen externen Status ändert. </p><br><p>  Dies ist aus anderen Gründen eine sehr interessante Eigenschaft: Da wir wissen, dass es keine Nebenwirkungen gibt, können wir die Funktion dieser Funktion nur anhand ihrer Signatur verstehen!  Suchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> einfach nach dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hoogle-</a> Signatur und sehen Sie sich das erste Ergebnis an.  Natürlich ist dies nicht die einzig mögliche Funktion, die einen solchen Typ haben würde, aber der Typ gibt uns genug Vertrauen für die Zwecke der Dokumentation. </p><br><p>  <strong>Analyse</strong> </p><br><ul><li>  <strong>Die Dokumentation</strong> <br><ul><li>  ✓ <strong>Wir kennen das erwartete Verhalten</strong> </li><li>  ✗ Wir haben ein Anwendungsbeispiel </li><li>  ✓ Wir kennen einige Werteklassen, die korrekt verarbeitet werden </li><li>  ✓ <strong>Wir kennen alle Arten von Werten, die korrekt verarbeitet werden</strong> </li></ul></li><li>  <strong>Spezifikation</strong> <br><ul><li>  ✗ Funktioniert in mindestens einem Fall. <br>  Aufgrund fehlender Tests oder Beweise wissen wir nicht, ob unsere Funktion überhaupt wie erwartet funktioniert! </li><li>  ✗ Der zurückgegebene Index ist immer ein gültiger Index. </li><li>  ✗ Der zurückgegebene Index gibt immer einen geeigneten Wert an. </li><li>  ✗ Ein fehlender Artikel gibt immer <code>None</code> / <code>Nothing</code> . </li></ul></li><li>  <strong>Häufige Fehler</strong> <br><ul><li>  ✓ Keine Tippfehler oder falschen Namen </li><li>  ✓ Keine unerwartete <code>null</code> </li><li>  ✓ Fehlerfälle <strong>werden immer behandelt</strong> <br>  Wenn unsere Funktion <code>Nothing</code> zurückgibt, stellt das Typsystem sicher, dass dieser Fall vom aufrufenden Code korrekt behandelt wird.  Natürlich kann dieser Fall ignoriert werden, aber dies muss explizit erfolgen. </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  ✓ Speichersicherheit </li><li>  ✓ Die Funktion kann nicht mit dem falschen Typ aufgerufen werden </li><li>  ✓ <strong>Keine Nebenwirkungen</strong> </li><li>  ✗ Keine Ausnahmen <br>  Ich teile Ausnahmen und Fehler, weil ich glaube, dass es nach Ausnahmen möglich ist, sie wiederherzustellen, und nach Fehlern (zum Beispiel teilweise definierten Funktionen) - nein. <br>  Ausnahmen werden größtenteils in Typen beschrieben (z. B. in der E / A-Monade).  Auf eine gute Weise sollten wir wissen, dass eine Funktion keine Ausnahme auslöst, sondern nur aufgrund ihres Typs.  Haskell bricht diese Erwartung jedoch, indem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es zulässt, dass Ausnahmen aus reinem Code ausgelöst werden</a> . <br>  "Darüber hinaus ist anzumerken, dass in Haskell Fehler wie das falsche Aufrufen teilweise definierter Funktionen auch als Ausnahmen dargestellt werden, die abgefangen und verarbeitet werden können, sodass der Unterschied zwischen den beiden Kategorien etwas weniger offensichtlich ist." </li><li>  ✗ Keine Fehler <br>  Wir können immer noch teilweise definierte Funktionen verwenden, zum Beispiel die Division durch Null. </li><li>  ✗ Keine ewigen Zyklen </li></ul></li></ul><br><h2>  Haskell mit Tests </h2><br><p>  Denken Sie daran, ich habe vorhin gesagt, dass Tests das Fehlen von Fehlern nicht beweisen können?  Ich habe gelogen.  Wenn die Sterne richtig konvergieren und die Tests mit Typen kombiniert werden, wird es möglich!  Der erste Stern ist die Endlichkeit der Domäne unserer Funktion.  Zweitens: Der Definitionsbereich sollte nicht nur endlich, sondern auch nicht sehr groß sein, da sonst ein solcher Test nur schwer in die Praxis umzusetzen ist. </p><br><p>  Zum Beispiel: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">not</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> not x = ...</code> </pre> <br><p>  Die Eingabe kann entweder <code>True</code> oder <code>False</code> .  Es reicht aus, diese beiden Optionen zu testen, und hier ist es, der Heilige Gral!  Keine Ausnahmen, ewige Zyklen, falsche Ergebnisse, keine Fehler.  ⟦Für eine etwas komplexere Funktion ist jedoch möglicherweise nicht klar, wie viel Zeit für Tests aufgewendet wird: Wenn die Durchführung lange dauert, sind wir dann in einem ewigen Zyklus gelandet oder ist sie nur schwer?  Das Problem, sie aufzuhalten. « </p><br><p>  Tatsächlich trifft dies auch bei Haskell nicht ganz zu: In jedem Haskell-Typ gibt es auch einen Wert ⊥ (der als <code>undefined</code> , <code>error</code> oder in gewissem Sinne als unendliche Rekursion erhalten werden kann), aber Haskelisten schließen traditionell ihre Augen und glauben dies es existiert nicht. </p><br><p>  Außerschulische Lektüre: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es gibt nur vier Milliarden Schwimmer - testen Sie sie alle!</a> </p><br><p>  In unserem ursprünglichen Beispiel ist der Umfang in jedem Fall unendlich, sodass Tests nur zeigen können, dass unser Code für eine begrenzte Anzahl von Beispielen funktioniert. </p><br><p>  <strong>Analyse</strong> <br>  In diesem Fall ergänzen die Tests die Typen und verstopfen einige Löcher im Haskell-Typsystem.  Wir haben viel mehr Vertrauen in unseren Code als nur Tests oder Typen. </p><br><h2>  C. </h2><br><pre> <code class="plaintext hljs">/* C    ,    int */ int x(int *y, size_t n, int z) { /* 10000    */ }</code> </pre> <br><p>  Wir betrachten C aus Interesse für ältere Systeme.  Insbesondere in C werden die Typen höchstwahrscheinlich nicht vom Programmierer, sondern vom Compiler benötigt, um schnelleren Code zu generieren. </p><br><p>  In unserem Beispiel wissen wir nicht, was die Funktion zurückgibt, wenn das Element nicht gefunden wird.  Wir müssen uns auf Tradition oder Dokumentation verlassen (in diesem Fall kann es beispielsweise <code>-1</code> ). </p><br><p>  Wir könnten auch out-Argumente verwenden: Auf diese Weise können wir einen Fehler zurückgeben und den Rückgabewert in diesem out-Argument speichern.  Dies ist eine etwas aussagekräftigere Option, aber wir müssen uns immer noch auf die Dokumentation verlassen, um zu verstehen, welche Parameter gelesen und welche geschrieben werden.  In beiden Fällen ist es schwierig, das Verhalten anhand von Typen zu verstehen. </p><br><pre> <code class="plaintext hljs">/*   ,   out- */ error_t x(int *y, size_t n, int z, size_t *w) { /* 10000    */ }</code> </pre> <br><p>  <strong>Analyse</strong> <br>  Das Typensystem selbst gibt uns nicht so viele Garantien.  Natürlich erhalten wir einige Informationen von diesen Typen, aber vergleichen Sie sie einfach mit dem Fall Haskell. </p><br><h2>  Idris </h2><br><pre> <code class="plaintext hljs">x : Eq x =&gt; List x -&gt; x -&gt; Maybe Int xyz = ...</code> </pre> <br><p>  Diese Funktion ist vom gleichen Typ wie im Fall von Haskell.  Mit einem ausdrucksstärkeren Typsystem können wir jedoch mehr erreichen.  Die Auswahl der Typen kann über die Implementierung sprechen. </p><br><pre> <code class="plaintext hljs">%default total x : Eq x =&gt; Vect nx -&gt; x -&gt; Maybe (Fin n) xyz = ...</code> </pre> <br><p>  Dieser Typ kann gelesen werden als "Gib mir eine Liste mit der Größe <code>n</code> und einem Wert, und ich werde dir entweder eine Zahl kleiner als <code>n</code> oder <code>Nothing</code> ."  Dies stellt sicher, dass die Funktion einen Index zurückgibt, der offensichtlich nicht über die Grenzen hinausgeht. </p><br><p>  Außerdem ist diese Funktion total, dh der Timer hat überprüft, dass sie immer endet.  Dies eliminiert ewige Zyklen und Fehler. </p><br><p>  <strong>Analyse</strong> </p><br><ul><li>  <strong>Spezifikation</strong> <br><ul><li>  ✗ Funktioniert in mindestens einem Fall. </li><li>  ✓ Der <strong>zurückgegebene Index ist immer der richtige Index</strong> </li><li>  ✗ Der zurückgegebene Index gibt immer einen geeigneten Wert an </li><li>  ✗ Fehlende Elemente geben immer <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  ✓ Speichersicherheit </li><li>  ✓ Die Funktion kann nicht mit dem falschen Typ aufgerufen werden </li><li>  ✓ Keine Nebenwirkungen </li><li>  ✗ Keine Ausnahmen </li><li>  ✓ <strong>Keine Fehler</strong> </li><li>  ✓ <strong>Keine ewigen Zyklen</strong> </li></ul></li></ul><br><h2>  Idris mit Tests </h2><br><p>  Da die Typensprache von Idris genauso ausdrucksstark ist wie die Sprache seiner Begriffe (oder vielmehr ihr nachweislich vollständiger Teil), ist die Unterscheidung zwischen Test und Typ verschwommen: </p><br><pre> <code class="plaintext hljs">ex : x [1, 2, 3] 2 = Just 1 ex = Refl</code> </pre> <br><p>  Diese Funktion hat einen ziemlich seltsamen Typ <code>x [1, 2, 3] 2 = Just 1</code> .  Dieser Typ bedeutet, dass der Typer für eine erfolgreiche Typprüfung nachweisen muss, dass <code>x [1, 2, 3] 2</code> strukturell gleich <code>Just 1</code> .  ⟦In diesem Fall ist der Beweis trivial, da es für den Kipper ausreicht, die Begriffe auf beiden Seiten des Gleichheitszeichens zu normalisieren, was aufgrund der Gesamtheit aller verwendeten Funktionen in endlicher Zeit erfolgt und aufgrund von Church-Rosser zu einem einzigartigen Ergebnis führt.  Danach kann man die Reflexivität der Gleichheit nutzen, was Refl .⟧ </p><br><p>  Tatsächlich haben wir einen Typ-Level-Test geschrieben. </p><br><h2>  Idris mit Beweisen </h2><br><p>  Zur Vollständigkeit der Analyse können wir die volle Leistung abhängiger Typen nutzen und unsere Implementierung <em>beweisen</em> (da abhängige Typen in Idris einem logischen System entsprechen, das konstruktive Logik erster Ordnung enthält). </p><br><p>  Insbesondere können wir Eigenschaften nachweisen, die bisher für uns unerreichbar waren: </p><br><pre> <code class="plaintext hljs">--      Eq  DecEq x : DecEq a =&gt; Vect na -&gt; (y : a) -&gt; Maybe (Fin n) xyz = ... --    ,       `x` findIndexOk : DecEq a =&gt; (y : Vect na) -&gt; (z : a) -&gt; case xyz of Just i =&gt; index iy = z Nothing =&gt; Not (Elem zy) findIndexOk yz = ...</code> </pre> <br><p>  Der Typ <code>findIndexOk</code> kann gelesen werden als „für jeden Typ <code>a</code> so dass er einen algorithmisch entscheidbaren Vergleich ( <code>DecEq</code> ) hat, für jeden Vektor <code>y</code> Elementen vom Typ <code>a</code> beliebiger Länge <code>n</code> und jedem Wert <code>z</code> Typ <code>a</code> : Wenn <code>xyz</code> Index <code>i</code> zurückgibt, dann diesen Index liegt <code>z</code> , aber wenn <code>xyz</code> <code>Nothing</code> zurückgibt, dann gibt es überhaupt kein solches Element im Vektor. “ </p><br><p>  "Es ist interessant, dass der Autor des Originalartikels einen Typ angibt, der etwas schwächer ist als der oben angegebene." </p><br><p>  Jetzt haben wir alles eingefangen!  Was sind die Nachteile?  Nun, all diese Beweise zu schreiben kann ziemlich schwierig sein. </p><br><h2>  Vergleich </h2><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Python </th><th>  Python <br>  Tests </th><th>  Haskell </th><th>  Haskell <br>  Typen </th><th>  Haskell <br>  Typen <br>  Tests </th><th>  Idris </th><th>  Idris <br>  Tests </th><th>  Idris <br>  Beweise </th></tr><tr><th>  Die Dokumentation </th></tr><tr><td>  Wir kennen das erwartete Verhalten </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Es gibt ein Anwendungsbeispiel </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Wir kennen einige Arten geeigneter Werte. </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Wir kennen alle Arten geeigneter Werte. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><th>  Spezifikation </th></tr><tr><td>  Funktioniert in mindestens einem Fall </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Der zurückgegebene Index ist immer gültig. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Der zurückgegebene Index ist immer gültig. </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td></tr><tr><td>  Fehlendes Element ergibt "Keine" / "Nichts" </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td></tr><tr><th>  Häufige Fehler </th></tr><tr><td>  Keine Tippfehler oder falschen Namen </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Kein plötzliches "Null" </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Der Fehlerfall wird immer behandelt. </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><th>  Garantien </th></tr><tr><td>  Speichersicherheit </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Kann nicht mit dem falschen Typ aufgerufen werden. </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Keine Nebenwirkungen </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Keine Ausnahmen </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Keine Fehler </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr><tr><td>  Keine ewigen Zyklen </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✗ </td><td>  ✓ </td><td>  ✓ </td><td>  ✓ </td></tr></tbody></table></div><br><h2>  Meinung </h2><br><p>  Meiner Meinung nach ist die Verwendung eines modernen Typsystems an sich im Hinblick auf das Verhältnis der erhaltenen Informationen und Garantien für die aufgewendeten Anstrengungen am effektivsten.  Wenn Sie ziemlich zuverlässigen Code schreiben möchten, können die Typen mit Tests gewürzt werden.  Idealerweise - im Stil von QuickCheck. </p><br><p>  Bei abhängigen Typen wird die Grenze zwischen Tests und Typen weniger offensichtlich.  Wenn Sie Software für Boeing oder für Herzschrittmacher schreiben, kann es hilfreich sein, Beweise zu schreiben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467677/">https://habr.com/ru/post/de467677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467667/index.html">Organisation Projektplanung (Teil 4)</a></li>
<li><a href="../de467669/index.html">Beobachten Sie mich in vollem Umfang: Nutzen Sie das Beste aus Live-Videos auf mobilen Plattformen</a></li>
<li><a href="../de467671/index.html">NLX Retro Computer</a></li>
<li><a href="../de467673/index.html">Eingebaute Go-Funktionen</a></li>
<li><a href="../de467675/index.html">Modellieren des Anwendungsstatus mithilfe von Store-Objekten in SwiftUI</a></li>
<li><a href="../de467679/index.html">PyCrunch - Intelligente Testausführung und visuelle Codeabdeckung in der IDE</a></li>
<li><a href="../de467681/index.html">Sicherheitslücke bei SOAP-Routing-Umwegen</a></li>
<li><a href="../de467683/index.html">Der Versuch, das nicht zusammensetzbare Docking-Schema zusammenzustellen</a></li>
<li><a href="../de467689/index.html">Ein kleiner Überblick über SIMD in .NET / C #</a></li>
<li><a href="../de467691/index.html">Intel Nervana NNP-T und NNP-I - Spezialchips für KI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>