<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â›´ï¸ ğŸº ğŸ“¬ Tests oder Typen ğŸ¥© â€¼ï¸ ğŸ¤´ğŸ½</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr. Neulich habe ich nach einer MÃ¶glichkeit gesucht, etwas in Idris zu tun, und bin auf einen guten Beitrag gestoÃŸen, dessen kostenlose Ãœberse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests oder Typen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467677/"><p>  <em>Hallo Habr.</em>  <em>Neulich habe ich nach einer MÃ¶glichkeit gesucht, etwas in Idris zu tun, und bin auf einen guten Beitrag gestoÃŸen, dessen kostenlose Ãœbersetzung durchaus angemessen erscheint.</em>  <em>Freiheiten und Knebel, wo nÃ¶tig, werde ich "hier durch solche Kringel am Anfang und am Ende" bezeichnen.</em> </p><br><p>  Wann und wann Tests verwenden?  Welche Informationen und welche Garantien erhalten wir im Austausch fÃ¼r unsere BemÃ¼hungen, sie zu schreiben? </p><br><p>  Wir werden uns ein einfaches und leicht erfundenes Beispiel ansehen, das in Python, C, Haskell und Idris ausgedrÃ¼ckt wird.  Wir werden auch sehen, was Ã¼ber die Implementierung gesagt werden kann, ohne jeweils zusÃ¤tzliches Wissen darÃ¼ber. </p><br><p> Wir werden die verschiedenen HintertÃ¼ren nicht berÃ¼cksichtigen, die es uns ermÃ¶glichen, die <code>unsafePerformIO</code> explizit zu verletzen (z. B. C-Erweiterungen, <code>unsafePerformIO</code> in Haskell, unsichere Typkonvertierungen), da sonst keine Schlussfolgerungen gezogen werden kÃ¶nnen und dieser Beitrag recht kurz ist.  "DarÃ¼ber hinaus verfÃ¼gt derselbe Haskell Ã¼ber eine Teilmenge von Safe Haskell, die die Verwendung dieser und einer Reihe anderer Tricks, die die IntegritÃ¤t der Sprache verletzen kÃ¶nnten, explizit und transitiv verbietet." </p><a name="habracut"></a><br><h2>  Spezifikation </h2><br><blockquote>  Lassen Sie eine Liste und eine Bedeutung gegeben werden.  Es ist erforderlich, den Index dieses Werts in der Liste zurÃ¼ckzugeben oder anzugeben, dass dieser Wert nicht in der Liste enthalten ist. </blockquote><p>  Die Implementierung dieser Spezifikation ist trivial, daher ist es selbstverstÃ¤ndlich zu fragen, und hier sind im Allgemeinen Tests oder Typen.  Diese Eigenschaften und Argumentationsmethoden, Ã¼ber die wir heute sprechen werden, sind jedoch auf einen viel komplexeren Code anwendbar.  Lassen Sie die Implementierung zehntausend Zeilen unlesbaren Spaghetti-Codes verwenden, wenn dies hilft, ihre NÃ¼tzlichkeit zu erkennen. </p><br><h2>  Python </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y, z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 10000   </span></span></code> </pre> <br><p>  Wir stellen sofort fest, dass wir nicht an den ungeprÃ¼ften sem- und semantikunabhÃ¤ngigen Eigenschaften eines Programms wie Variablennamen und Textdokumentation interessiert sind. Daher habe ich absichtlich keinen Code geschrieben, der die Wahrnehmung unterstÃ¼tzt.  Wir sind nur daran interessiert, dass es vorbehaltlich bestehender Tests und TypprÃ¼fungen <em>nicht unwahr sein kann</em> . </p><br><p>  Im obigen Code gibt es praktisch keine nÃ¼tzlichen Informationen auÃŸer der Tatsache, dass wir eine Funktion haben, die zwei Argumente akzeptiert.  Diese Funktion kann ebenso gut den Index des Wertes in der Liste finden oder einen beleidigenden Brief an Ihre GroÃŸmutter senden. </p><br><p>  <strong>Analyse</strong> </p><br><p>  Wir erhalten nicht nur fragilen Code ohne Tests und Typen, sondern unsere einzige MÃ¶glichkeit zu verstehen, was eine Funktion tut, ist die Dokumentation.  Und da die Dokumentation von Personen und nicht von Maschinen Ã¼berprÃ¼ft wird, kann sie sich leicht als veraltet oder anfangs falsch herausstellen. </p><br><ul><li>  <strong>Die Dokumentation</strong> <br><ul><li>  âœ— Wir kennen das erwartete Verhalten <br>  Ãœber das Verhalten dieser Funktion haben wir nichts zu sagen.  Du hasst deine GroÃŸmutter.  Du bist ein Monster. </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  âœ“ Speichersicherheit <br>  Python ist eine Garbage Collection-Sprache, die uns dieses Problem beseitigt.  "Soweit ich weiÃŸ, hindert Sie jedoch nichts daran, unsichere Bibliotheken oder C FFI in diese Funktion zu ziehen." </li></ul></li></ul><br><h2>  Python mit Tests </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_happy_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_missing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Jetzt wissen wir, dass unsere Funktion funktioniert, und wenn das Element fehlt, ist das Ergebnis <code>None</code> ? </p><br><p>  Nun ... nein.  Dies ist nur ein Beispiel.  Leider ist der Umfang unserer Funktion unendlich und keine Anzahl von Beispielen kann die korrekte Funktionsweise unserer Funktion beweisen.  Mehr Tests - mehr Vertrauen, aber keine Anzahl von Tests wird alle Zweifel lÃ¶sen. </p><br><p>  Die MÃ¶glichkeit, dass diese Funktion <code>None</code> fÃ¼r <code>4</code> , aber nicht fÃ¼r <code>5</code> zurÃ¼ckgibt, klingt ziemlich verrÃ¼ckt, und in diesem speziellen Fall ist dies hÃ¶chstwahrscheinlich Unsinn.  Wir kÃ¶nnen mit unserem Glaubensniveau zufrieden sein und uns mit einer bestimmten Anzahl von Beispielen befassen.  Aber andererseits wird der Beitrag kurz sein. Stellen wir uns also vor, dass die Implementierung nicht so offensichtlich ist. </p><br><p>  Da die Tests im allgemeinen Fall nichts beweisen kÃ¶nnen, sondern nur das Verhalten <em>anhand</em> spezifischer Beispiele zeigen, kÃ¶nnen die Tests <em>keine</em> Fehlerfreiheit nachweisen.  Zum Beispiel gibt es keinen Test, der zeigen wÃ¼rde, dass unsere Funktion niemals eine Ausnahme auslÃ¶st oder niemals in den ewigen Zyklus eintritt oder keine ungÃ¼ltigen Links enthÃ¤lt.  Dies kann nur eine statische Analyse sein. </p><br><p>  Auch wenn die Beispiele in der Rolle der Beweise nicht sehr gut sind, stellen sie zumindest eine gute Dokumentation dar.  Aus diesen beiden Beispielen kÃ¶nnen wir die vollstÃ¤ndige Spezifikation unter einigen zusÃ¤tzlichen a priori-Annahmen ableiten - diese beiden Beispiele erfÃ¼llen beispielsweise auch die â€Gegenspezifikationâ€œ â€finde das Element im Array und gib das vorherige zurÃ¼ck, falls vorhandenâ€œ, fÃ¼r dessen Erfindung ich zehn Sekunden gebraucht habe . </p><br><p>  <strong>Analyse</strong> </p><br><p>  Obwohl Tests zeigen kÃ¶nnen, wie unsere Funktion verwendet wird, und auch ein wenig Sicherheit geben kÃ¶nnen, dass diese Funktion mit zumindest einigen Beispielen korrekt funktioniert, kÃ¶nnen sie im allgemeinen Fall nichts Ã¼ber unseren Code <em>beweisen</em> .  Dies bedeutet leider, dass Tests nur teilweise dazu beitragen, Fehler zu vermeiden. </p><br><ul><li>  <strong>Die Dokumentation</strong> <br><ul><li>  âœ“ <strong>Wir haben ein Anwendungsbeispiel</strong> </li><li>  âœ“ <strong>Wir kennen einige</strong> Werteklassen <strong>, die korrekt verarbeitet werden</strong> </li><li>  âœ— Wir kennen alle Arten von Werten, die korrekt verarbeitet werden <br>  Wir haben keine EinschrÃ¤nkungen hinsichtlich der Argumenttypen. Trotz der Existenz von Beispielen fÃ¼r die Funktionsweise der Funktion wissen wir nicht, welche Typen nicht getestet wurden. </li><li>  âœ— Wir kennen das erwartete Verhalten <br>  "Der Autor des Originalartikels hat hier angekreuzt. Ich erlaube mir, angesichts des obigen Kommentars ein Kreuz zu setzen." </li></ul></li><li>  <strong>Spezifikation</strong> <br><ul><li>  âœ“ <strong>Funktioniert in mindestens einem Fall</strong> </li><li>  âœ— Der zurÃ¼ckgegebene Index ist immer ein gÃ¼ltiger Index </li><li>  âœ— Der zurÃ¼ckgegebene Index gibt immer einen geeigneten Wert an </li><li>  âœ— Fehlende Elemente geben immer <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>HÃ¤ufige Fehler</strong> <br><ul><li>  âœ— Keine Tippfehler oder falschen Namen <br>  Statische Analysen kÃ¶nnen helfen, aber da Python eine dynamische Sprache ist, die zur Laufzeit verschiedene Dinge Ã¼berschreiben kann, kÃ¶nnen wir niemals beweisen, dass es keine Fehler gibt. <br>  Insbesondere kann es sehr schwierig oder unmÃ¶glich sein, festzustellen, ob der Methodenname korrekt ist, da die GÃ¼ltigkeit des Methodenaufrufs vom Laufzeittyp des Objekts abhÃ¤ngt, fÃ¼r das der Aufruf erfolgt. </li><li>  âœ— Keine unerwartete <code>null</code> </li><li>  âœ— FehlerfÃ¤lle werden immer behandelt <br>  Nach meiner Erfahrung ist dies eine der hÃ¤ufigsten Fehlerquellen: In unserem Beispiel gibt die Funktion bei fehlendem Element <code>None</code> zurÃ¼ck, aber der Code, der diese Funktion verwendet, kann beispielsweise davon ausgehen, dass immer eine Zahl zurÃ¼ckgegeben wird.  DarÃ¼ber hinaus kann dies auch zu einer nicht behandelten Ausnahme fÃ¼hren. </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  âœ“ Speichersicherheit </li><li>  âœ— Die Funktion kann nicht mit dem falschen Typ aufgerufen werden </li><li>  âœ— Keine Nebenwirkungen </li><li>  âœ— Keine Ausnahmen </li><li>  âœ— Keine Fehler </li><li>  âœ— Keine ewigen Zyklen </li></ul></li></ul><br><h2>  Haskell </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">xyz</span></span> = <span class="hljs-comment"><span class="hljs-comment">-- 10000  </span></span></code> </pre> <br><p>  Wenn Sie mit der Syntax nicht vertraut sind: Dies ist die Definition einer Funktion <code>x</code> mit den Parametern <code>y</code> und <code>z</code> .  In Haskell kÃ¶nnen Sie Typen weglassen, da diese aus der Implementierung abgeleitet werden (es sei denn, Sie verwenden natÃ¼rlich andere erweiterte Funktionen als moderne Erweiterungen des Typsystems). </p><br><p>  Es scheint, dass dies nicht sehr verschieden von der Python-Version ist, aber nur weil wir unsere Funktion in Haskell geschrieben haben und sie gekachelt ist, kÃ¶nnen wir bereits Ã¼ber einige interessante Eigenschaften sprechen. </p><br><p>  <strong>Analyse</strong> </p><br><p>  NatÃ¼rlich kÃ¶nnen wir hier nicht so viele Schlussfolgerungen ziehen, aber hier sind einige Punkte zu beachten: </p><br><ul><li>  <strong>Die Dokumentation</strong> <br><ul><li>  âœ— Wir kennen das erwartete Verhalten </li></ul></li><li>  <strong>HÃ¤ufige Fehler</strong> <br><ul><li>  âœ“ <strong>Keine Tippfehler oder falschen Namen</strong> <br>  Da Haskell eine kompilierte Sprache ist, mÃ¼ssen alle Namen zur Kompilierungszeit aufgelÃ¶st werden.  Das Programm wird einfach nicht kompiliert, wenn dieser Fehler auftritt. </li><li>  âœ“ <strong>Keine unerwartete <code>null</code></strong> <br>  Haskell hat einfach keine <code>null</code> .  Das Problem ist gelÃ¶st! </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  âœ“ Speichersicherheit </li><li>  âœ“ <strong>Die Funktion kann nicht mit dem falschen Typ aufgerufen werden</strong> </li><li>  âœ“ <strong>Keine <em>unerwarteten</em> Nebenwirkungen</strong> <br>  âŸ¦Der Autor des Originalartikels hat diesen Artikel nicht angegeben, aber ich erlaube mir zu beachten, dass der abgeleitete Typ dieser Funktion bei Nebenwirkungen auf deren Vorhandensein hinweist, sodass der aufrufende Code Ã¼ber ihre Funktionen informiert ist.âŸ§ </li></ul></li></ul><br><h2>  Angabe des Haskell-Typs </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> :: <span class="hljs-type"><span class="hljs-type">Eq</span></span> a =&gt; [a] -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> xyz = <span class="hljs-comment"><span class="hljs-comment">-- ...</span></span></code> </pre> <br><p>  FrÃ¼her haben wir Ã¼ber eine eher vernÃ¼nftige Haltung gegenÃ¼ber der Sicherheit von GroÃŸmÃ¼ttern gesprochen: Aus den Tests ging hervor, dass die Funktion niemandem schaden wÃ¼rde, aber <em>war die</em> GroÃŸmutter <em>wirklich</em> sicher?  Sendet diese Funktion genau keine SchimpfwÃ¶rter? </p><br><p>  Haskell ist bekannt als reine Funktionssprache.  Dies bedeutet nicht, dass der Code keine Nebenwirkungen haben kann, aber alle Nebenwirkungen mÃ¼ssen im Typ vorhanden sein.  Wir kennen den Typ dieser Funktion und sehen, dass sie sauber ist. Daher sind wir sicher, dass diese Funktion keinen externen Status Ã¤ndert. </p><br><p>  Dies ist aus anderen GrÃ¼nden eine sehr interessante Eigenschaft: Da wir wissen, dass es keine Nebenwirkungen gibt, kÃ¶nnen wir die Funktion dieser Funktion nur anhand ihrer Signatur verstehen!  Suchen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> einfach nach dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hoogle-</a> Signatur und sehen Sie sich das erste Ergebnis an.  NatÃ¼rlich ist dies nicht die einzig mÃ¶gliche Funktion, die einen solchen Typ haben wÃ¼rde, aber der Typ gibt uns genug Vertrauen fÃ¼r die Zwecke der Dokumentation. </p><br><p>  <strong>Analyse</strong> </p><br><ul><li>  <strong>Die Dokumentation</strong> <br><ul><li>  âœ“ <strong>Wir kennen das erwartete Verhalten</strong> </li><li>  âœ— Wir haben ein Anwendungsbeispiel </li><li>  âœ“ Wir kennen einige Werteklassen, die korrekt verarbeitet werden </li><li>  âœ“ <strong>Wir kennen alle Arten von Werten, die korrekt verarbeitet werden</strong> </li></ul></li><li>  <strong>Spezifikation</strong> <br><ul><li>  âœ— Funktioniert in mindestens einem Fall. <br>  Aufgrund fehlender Tests oder Beweise wissen wir nicht, ob unsere Funktion Ã¼berhaupt wie erwartet funktioniert! </li><li>  âœ— Der zurÃ¼ckgegebene Index ist immer ein gÃ¼ltiger Index. </li><li>  âœ— Der zurÃ¼ckgegebene Index gibt immer einen geeigneten Wert an. </li><li>  âœ— Ein fehlender Artikel gibt immer <code>None</code> / <code>Nothing</code> . </li></ul></li><li>  <strong>HÃ¤ufige Fehler</strong> <br><ul><li>  âœ“ Keine Tippfehler oder falschen Namen </li><li>  âœ“ Keine unerwartete <code>null</code> </li><li>  âœ“ FehlerfÃ¤lle <strong>werden immer behandelt</strong> <br>  Wenn unsere Funktion <code>Nothing</code> zurÃ¼ckgibt, stellt das Typsystem sicher, dass dieser Fall vom aufrufenden Code korrekt behandelt wird.  NatÃ¼rlich kann dieser Fall ignoriert werden, aber dies muss explizit erfolgen. </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  âœ“ Speichersicherheit </li><li>  âœ“ Die Funktion kann nicht mit dem falschen Typ aufgerufen werden </li><li>  âœ“ <strong>Keine Nebenwirkungen</strong> </li><li>  âœ— Keine Ausnahmen <br>  Ich teile Ausnahmen und Fehler, weil ich glaube, dass es nach Ausnahmen mÃ¶glich ist, sie wiederherzustellen, und nach Fehlern (zum Beispiel teilweise definierten Funktionen) - nein. <br>  Ausnahmen werden grÃ¶ÃŸtenteils in Typen beschrieben (z. B. in der E / A-Monade).  Auf eine gute Weise sollten wir wissen, dass eine Funktion keine Ausnahme auslÃ¶st, sondern nur aufgrund ihres Typs.  Haskell bricht diese Erwartung jedoch, indem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es zulÃ¤sst, dass Ausnahmen aus reinem Code ausgelÃ¶st werden</a> . <br>  "DarÃ¼ber hinaus ist anzumerken, dass in Haskell Fehler wie das falsche Aufrufen teilweise definierter Funktionen auch als Ausnahmen dargestellt werden, die abgefangen und verarbeitet werden kÃ¶nnen, sodass der Unterschied zwischen den beiden Kategorien etwas weniger offensichtlich ist." </li><li>  âœ— Keine Fehler <br>  Wir kÃ¶nnen immer noch teilweise definierte Funktionen verwenden, zum Beispiel die Division durch Null. </li><li>  âœ— Keine ewigen Zyklen </li></ul></li></ul><br><h2>  Haskell mit Tests </h2><br><p>  Denken Sie daran, ich habe vorhin gesagt, dass Tests das Fehlen von Fehlern nicht beweisen kÃ¶nnen?  Ich habe gelogen.  Wenn die Sterne richtig konvergieren und die Tests mit Typen kombiniert werden, wird es mÃ¶glich!  Der erste Stern ist die Endlichkeit der DomÃ¤ne unserer Funktion.  Zweitens: Der Definitionsbereich sollte nicht nur endlich, sondern auch nicht sehr groÃŸ sein, da sonst ein solcher Test nur schwer in die Praxis umzusetzen ist. </p><br><p>  Zum Beispiel: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">not</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> not x = ...</code> </pre> <br><p>  Die Eingabe kann entweder <code>True</code> oder <code>False</code> .  Es reicht aus, diese beiden Optionen zu testen, und hier ist es, der Heilige Gral!  Keine Ausnahmen, ewige Zyklen, falsche Ergebnisse, keine Fehler.  âŸ¦FÃ¼r eine etwas komplexere Funktion ist jedoch mÃ¶glicherweise nicht klar, wie viel Zeit fÃ¼r Tests aufgewendet wird: Wenn die DurchfÃ¼hrung lange dauert, sind wir dann in einem ewigen Zyklus gelandet oder ist sie nur schwer?  Das Problem, sie aufzuhalten. Â« </p><br><p>  TatsÃ¤chlich trifft dies auch bei Haskell nicht ganz zu: In jedem Haskell-Typ gibt es auch einen Wert âŠ¥ (der als <code>undefined</code> , <code>error</code> oder in gewissem Sinne als unendliche Rekursion erhalten werden kann), aber Haskelisten schlieÃŸen traditionell ihre Augen und glauben dies es existiert nicht. </p><br><p>  AuÃŸerschulische LektÃ¼re: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es gibt nur vier Milliarden Schwimmer - testen Sie sie alle!</a> </p><br><p>  In unserem ursprÃ¼nglichen Beispiel ist der Umfang in jedem Fall unendlich, sodass Tests nur zeigen kÃ¶nnen, dass unser Code fÃ¼r eine begrenzte Anzahl von Beispielen funktioniert. </p><br><p>  <strong>Analyse</strong> <br>  In diesem Fall ergÃ¤nzen die Tests die Typen und verstopfen einige LÃ¶cher im Haskell-Typsystem.  Wir haben viel mehr Vertrauen in unseren Code als nur Tests oder Typen. </p><br><h2>  C. </h2><br><pre> <code class="plaintext hljs">/* C    ,    int */ int x(int *y, size_t n, int z) { /* 10000    */ }</code> </pre> <br><p>  Wir betrachten C aus Interesse fÃ¼r Ã¤ltere Systeme.  Insbesondere in C werden die Typen hÃ¶chstwahrscheinlich nicht vom Programmierer, sondern vom Compiler benÃ¶tigt, um schnelleren Code zu generieren. </p><br><p>  In unserem Beispiel wissen wir nicht, was die Funktion zurÃ¼ckgibt, wenn das Element nicht gefunden wird.  Wir mÃ¼ssen uns auf Tradition oder Dokumentation verlassen (in diesem Fall kann es beispielsweise <code>-1</code> ). </p><br><p>  Wir kÃ¶nnten auch out-Argumente verwenden: Auf diese Weise kÃ¶nnen wir einen Fehler zurÃ¼ckgeben und den RÃ¼ckgabewert in diesem out-Argument speichern.  Dies ist eine etwas aussagekrÃ¤ftigere Option, aber wir mÃ¼ssen uns immer noch auf die Dokumentation verlassen, um zu verstehen, welche Parameter gelesen und welche geschrieben werden.  In beiden FÃ¤llen ist es schwierig, das Verhalten anhand von Typen zu verstehen. </p><br><pre> <code class="plaintext hljs">/*   ,   out- */ error_t x(int *y, size_t n, int z, size_t *w) { /* 10000    */ }</code> </pre> <br><p>  <strong>Analyse</strong> <br>  Das Typensystem selbst gibt uns nicht so viele Garantien.  NatÃ¼rlich erhalten wir einige Informationen von diesen Typen, aber vergleichen Sie sie einfach mit dem Fall Haskell. </p><br><h2>  Idris </h2><br><pre> <code class="plaintext hljs">x : Eq x =&gt; List x -&gt; x -&gt; Maybe Int xyz = ...</code> </pre> <br><p>  Diese Funktion ist vom gleichen Typ wie im Fall von Haskell.  Mit einem ausdrucksstÃ¤rkeren Typsystem kÃ¶nnen wir jedoch mehr erreichen.  Die Auswahl der Typen kann Ã¼ber die Implementierung sprechen. </p><br><pre> <code class="plaintext hljs">%default total x : Eq x =&gt; Vect nx -&gt; x -&gt; Maybe (Fin n) xyz = ...</code> </pre> <br><p>  Dieser Typ kann gelesen werden als "Gib mir eine Liste mit der GrÃ¶ÃŸe <code>n</code> und einem Wert, und ich werde dir entweder eine Zahl kleiner als <code>n</code> oder <code>Nothing</code> ."  Dies stellt sicher, dass die Funktion einen Index zurÃ¼ckgibt, der offensichtlich nicht Ã¼ber die Grenzen hinausgeht. </p><br><p>  AuÃŸerdem ist diese Funktion total, dh der Timer hat Ã¼berprÃ¼ft, dass sie immer endet.  Dies eliminiert ewige Zyklen und Fehler. </p><br><p>  <strong>Analyse</strong> </p><br><ul><li>  <strong>Spezifikation</strong> <br><ul><li>  âœ— Funktioniert in mindestens einem Fall. </li><li>  âœ“ Der <strong>zurÃ¼ckgegebene Index ist immer der richtige Index</strong> </li><li>  âœ— Der zurÃ¼ckgegebene Index gibt immer einen geeigneten Wert an </li><li>  âœ— Fehlende Elemente geben immer <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Garantien</strong> <br><ul><li>  âœ“ Speichersicherheit </li><li>  âœ“ Die Funktion kann nicht mit dem falschen Typ aufgerufen werden </li><li>  âœ“ Keine Nebenwirkungen </li><li>  âœ— Keine Ausnahmen </li><li>  âœ“ <strong>Keine Fehler</strong> </li><li>  âœ“ <strong>Keine ewigen Zyklen</strong> </li></ul></li></ul><br><h2>  Idris mit Tests </h2><br><p>  Da die Typensprache von Idris genauso ausdrucksstark ist wie die Sprache seiner Begriffe (oder vielmehr ihr nachweislich vollstÃ¤ndiger Teil), ist die Unterscheidung zwischen Test und Typ verschwommen: </p><br><pre> <code class="plaintext hljs">ex : x [1, 2, 3] 2 = Just 1 ex = Refl</code> </pre> <br><p>  Diese Funktion hat einen ziemlich seltsamen Typ <code>x [1, 2, 3] 2 = Just 1</code> .  Dieser Typ bedeutet, dass der Typer fÃ¼r eine erfolgreiche TypprÃ¼fung nachweisen muss, dass <code>x [1, 2, 3] 2</code> strukturell gleich <code>Just 1</code> .  âŸ¦In diesem Fall ist der Beweis trivial, da es fÃ¼r den Kipper ausreicht, die Begriffe auf beiden Seiten des Gleichheitszeichens zu normalisieren, was aufgrund der Gesamtheit aller verwendeten Funktionen in endlicher Zeit erfolgt und aufgrund von Church-Rosser zu einem einzigartigen Ergebnis fÃ¼hrt.  Danach kann man die ReflexivitÃ¤t der Gleichheit nutzen, was Refl .âŸ§ </p><br><p>  TatsÃ¤chlich haben wir einen Typ-Level-Test geschrieben. </p><br><h2>  Idris mit Beweisen </h2><br><p>  Zur VollstÃ¤ndigkeit der Analyse kÃ¶nnen wir die volle Leistung abhÃ¤ngiger Typen nutzen und unsere Implementierung <em>beweisen</em> (da abhÃ¤ngige Typen in Idris einem logischen System entsprechen, das konstruktive Logik erster Ordnung enthÃ¤lt). </p><br><p>  Insbesondere kÃ¶nnen wir Eigenschaften nachweisen, die bisher fÃ¼r uns unerreichbar waren: </p><br><pre> <code class="plaintext hljs">--      Eq  DecEq x : DecEq a =&gt; Vect na -&gt; (y : a) -&gt; Maybe (Fin n) xyz = ... --    ,       `x` findIndexOk : DecEq a =&gt; (y : Vect na) -&gt; (z : a) -&gt; case xyz of Just i =&gt; index iy = z Nothing =&gt; Not (Elem zy) findIndexOk yz = ...</code> </pre> <br><p>  Der Typ <code>findIndexOk</code> kann gelesen werden als â€fÃ¼r jeden Typ <code>a</code> so dass er einen algorithmisch entscheidbaren Vergleich ( <code>DecEq</code> ) hat, fÃ¼r jeden Vektor <code>y</code> Elementen vom Typ <code>a</code> beliebiger LÃ¤nge <code>n</code> und jedem Wert <code>z</code> Typ <code>a</code> : Wenn <code>xyz</code> Index <code>i</code> zurÃ¼ckgibt, dann diesen Index liegt <code>z</code> , aber wenn <code>xyz</code> <code>Nothing</code> zurÃ¼ckgibt, dann gibt es Ã¼berhaupt kein solches Element im Vektor. â€œ </p><br><p>  "Es ist interessant, dass der Autor des Originalartikels einen Typ angibt, der etwas schwÃ¤cher ist als der oben angegebene." </p><br><p>  Jetzt haben wir alles eingefangen!  Was sind die Nachteile?  Nun, all diese Beweise zu schreiben kann ziemlich schwierig sein. </p><br><h2>  Vergleich </h2><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Python </th><th>  Python <br>  Tests </th><th>  Haskell </th><th>  Haskell <br>  Typen </th><th>  Haskell <br>  Typen <br>  Tests </th><th>  Idris </th><th>  Idris <br>  Tests </th><th>  Idris <br>  Beweise </th></tr><tr><th>  Die Dokumentation </th></tr><tr><td>  Wir kennen das erwartete Verhalten </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Es gibt ein Anwendungsbeispiel </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Wir kennen einige Arten geeigneter Werte. </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Wir kennen alle Arten geeigneter Werte. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><th>  Spezifikation </th></tr><tr><td>  Funktioniert in mindestens einem Fall </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Der zurÃ¼ckgegebene Index ist immer gÃ¼ltig. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Der zurÃ¼ckgegebene Index ist immer gÃ¼ltig. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td></tr><tr><td>  Fehlendes Element ergibt "Keine" / "Nichts" </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td></tr><tr><th>  HÃ¤ufige Fehler </th></tr><tr><td>  Keine Tippfehler oder falschen Namen </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Kein plÃ¶tzliches "Null" </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Der Fehlerfall wird immer behandelt. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><th>  Garantien </th></tr><tr><td>  Speichersicherheit </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Kann nicht mit dem falschen Typ aufgerufen werden. </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Keine Nebenwirkungen </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Keine Ausnahmen </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Keine Fehler </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr><tr><td>  Keine ewigen Zyklen </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ— </td><td>  âœ“ </td><td>  âœ“ </td><td>  âœ“ </td></tr></tbody></table></div><br><h2>  Meinung </h2><br><p>  Meiner Meinung nach ist die Verwendung eines modernen Typsystems an sich im Hinblick auf das VerhÃ¤ltnis der erhaltenen Informationen und Garantien fÃ¼r die aufgewendeten Anstrengungen am effektivsten.  Wenn Sie ziemlich zuverlÃ¤ssigen Code schreiben mÃ¶chten, kÃ¶nnen die Typen mit Tests gewÃ¼rzt werden.  Idealerweise - im Stil von QuickCheck. </p><br><p>  Bei abhÃ¤ngigen Typen wird die Grenze zwischen Tests und Typen weniger offensichtlich.  Wenn Sie Software fÃ¼r Boeing oder fÃ¼r Herzschrittmacher schreiben, kann es hilfreich sein, Beweise zu schreiben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467677/">https://habr.com/ru/post/de467677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467667/index.html">Organisation Projektplanung (Teil 4)</a></li>
<li><a href="../de467669/index.html">Beobachten Sie mich in vollem Umfang: Nutzen Sie das Beste aus Live-Videos auf mobilen Plattformen</a></li>
<li><a href="../de467671/index.html">NLX Retro Computer</a></li>
<li><a href="../de467673/index.html">Eingebaute Go-Funktionen</a></li>
<li><a href="../de467675/index.html">Modellieren des Anwendungsstatus mithilfe von Store-Objekten in SwiftUI</a></li>
<li><a href="../de467679/index.html">PyCrunch - Intelligente TestausfÃ¼hrung und visuelle Codeabdeckung in der IDE</a></li>
<li><a href="../de467681/index.html">SicherheitslÃ¼cke bei SOAP-Routing-Umwegen</a></li>
<li><a href="../de467683/index.html">Der Versuch, das nicht zusammensetzbare Docking-Schema zusammenzustellen</a></li>
<li><a href="../de467689/index.html">Ein kleiner Ãœberblick Ã¼ber SIMD in .NET / C #</a></li>
<li><a href="../de467691/index.html">Intel Nervana NNP-T und NNP-I - Spezialchips fÃ¼r KI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>