<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏽 ♂️ 👼🏻 Tentang grafik 3D dengan kata-kata sederhana 🤰 🌏 🤮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian 1. Pendahuluan 
 Hai nama saya baldurk. Saya telah bekerja sebagai programmer grafis selama beberapa tahun, jadi meskipun saya bukan ahli, sepe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang grafik 3D dengan kata-kata sederhana</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430930/"><h2>  Bagian 1. Pendahuluan </h2><br>  Hai nama saya baldurk.  Saya telah bekerja sebagai programmer grafis selama beberapa tahun, jadi meskipun saya bukan ahli, sepertinya saya sudah mengerti banyak tentang segala sesuatu yang berkaitan dengan bekerja dengan grafik. <br><br>  Gagasan serangkaian posting ini telah lama melayang di suatu tempat di pinggiran pikiran saya, dan muncul kembali setelah membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang menarik dengan analisis Deus Ex terbaru</a> . <br><br>  Sepertinya saya bahwa grafik, dan terutama kompleksitas yang dicapai dalam permainan modern, adalah topik yang menarik.  Sangat sedikit orang yang ingin mempelajari secara mendalam semua detailnya, tetapi saya percaya ada topik yang menarik bagi semua orang.  Saya pikir sebagian besar orang yang bermain game ingin tahu tentang bagaimana efek ini atau efek itu diperoleh, atau dengan teknologi apa mereka berhasil membuat grafik yang luar biasa di beberapa game baru. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c8/3b9/2ad/4c83b92ad325af58966fc3742aa85a10.jpg"></div><br>  <em>Ada banyak komponen yang diperlukan untuk membuat bahkan game 3D sederhana, belum lagi proyek seperti Watch Dogs.</em> <br><br>  Saya hanya memiliki gagasan umum tentang apa yang perlu dipertimbangkan dalam artikel ini, tetapi itu akan tergantung pada topik mana yang akan menarik perhatian.  Namun, ide utamanya adalah membuat deskripsi umum tentang apa yang terjadi di dalam game modern tanpa menakuti pembaca - saya akan berasumsi bahwa Anda tidak memiliki pengetahuan matematika dan pemrograman.  Jika Anda tahu perbedaan antara CPU dan kartu grafis, dan Anda membedakan RAM dari hard drive, maka ini akan cukup, dan saya akan menjelaskan sisanya. <br><a name="habracut"></a><br>  Artikel ini akan dikembangkan sesuai dengan video <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">walkthrough-nya Chip &amp; Ironicus's Let's Play of Watch Dogs</a> , untuk sedikit menyusun presentasi.  Gim ini terkenal dengan grafisnya (dan pendapat tentangnya bisa sepenuhnya berlawanan), dan ada banyak aspek di dalamnya yang dapat dipertimbangkan dengan contoh-contoh terpisah.  Mungkin saya akan berbicara tentang game lain. <br><br>  Saya akan mulai dengan menjelaskan dasar-dasar yang hampir sama untuk setiap permainan, tetapi saya juga akan melihat beberapa teknik dan efek visual dari Watch Dogs. <br><br>  Saya akan menggunakan alat yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RenderDoc</a> , yang saya tulis di waktu luang saya.  Ini digunakan untuk men-debug masalah dengan grafik - alat ini memungkinkan Anda untuk menguraikan bingkai grafik menjadi bagian-bagian, dan berkat ini kita akan melihat bagaimana hal itu berkumpul. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//OBaA9JD/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Animasi ini menunjukkan bagian dari bingkai yang secara bertahap dibuat dalam proses rendering dengan kartu grafis.</em> <br><br>  Kebanyakan orang tahu bahwa grafik komputer (dan grafik dari video lainnya) terdiri dari serangkaian bingkai foto, masing-masing ditampilkan untuk sebagian kecil dari satu detik.  Di bioskop, secara tradisional digunakan 24 frame per detik (frames per second, FPS), di televisi frekuensinya hampir sama, sekitar 24-30 frame.  Dalam game, FPS dapat diubah karena banyak pekerjaan yang dilakukan di setiap frame.  Penurunan frekuensi di bawah 30 tidak diinginkan, meskipun itu sering terjadi.  Biasanya batas atas untuk game konsol adalah 60 FPS.  Pengembang berupaya menerapkan frekuensi 30 atau 60, yang tergantung pada tujuan permainan.  Pada PC, dengan tampilan dengan frame rate tinggi, Anda dapat mencapai 90, 120, atau bahkan lebih tinggi.  Alasan angka-angka spesifik ini adalah sinkronisasi vertikal (vsync), yang akan kita bahas di bawah ini. <br><br>  Secara mental, kita dapat melihat tugas ini dari sisi yang berlawanan - alih-alih melihat seberapa <em>tinggi</em> frekuensi FPS, kita melihat betapa <em>sedikit</em> waktu yang dialokasikan untuk setiap frame.  Jika kita ingin game bekerja dengan frekuensi 30 FPS, maka kita hanya memiliki 33 milidetik untuk menyelesaikan semua pekerjaan yang diperlukan untuk frame.  Pada 60 FPS, waktunya separuh - sekitar 17 milidetik.  Bahkan untuk komputer, periode waktu ini tidak terlalu besar, mengingat jumlah pekerjaan yang perlu dilakukan.  Untuk memberi Anda gambaran tentang jumlah, maka, menurut perkiraan kasar, peluru bergerak sekitar 1 meter per milidetik. <br><br>  Kami terutama akan berbicara tentang PC karena platform ini terbuka, dan saya tidak dapat berbicara tentang konsol tanpa takut melanggar perjanjian non-pengungkapan (NDA).  Bagaimanapun, pada dasarnya saya akan berbicara tentang apa yang tidak jauh berbeda di konsol, tetapi jika ada sesuatu yang berbeda, maka saya akan menekankan ini.  Untuk platform seluler, sebagian besar perbedaan antara perangkat keras / konsol PC dan perangkat keras seluler tidak relevan dengan topik artikel saya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8a/414/db8/d8a414db8e56c45fae566b8da11316e2.jpg"></div><br>  <em>Jujur, saya meletakkan gambar ini di sini sehingga Anda mengerti bahwa artikel tersebut tidak hanya memiliki teks.</em> <br><br>  Tugas inilah yang menarik minat kami - kami tidak akan khawatir tentang bagaimana semua perhitungan AI dilakukan, atau bagaimana simulasi fisik dilakukan untuk memindahkan objek.  Batas-batas disiplin yang disebut "pemrograman grafis" agak kabur, tetapi saya akan mengatakan bahwa pemrograman grafis dimulai ketika kita memiliki semua informasi yang diperlukan untuk membangun sebuah bingkai: kita tahu apa yang terjadi, semua tekstur dan model berada dalam memori (bukan pada disk ), animasinya sudah dianimasikan, fisika dihitung, dan kita hanya perlu menggambar bingkai yang sudah jadi untuk ditampilkan di layar. <br><br>  Saya akan menambahkan bahwa saya akan mempertimbangkan gim 3D dengan render yang cukup tradisional, seperti Watch Dogs - banyak prinsip dasar yang berlaku untuk gim 2D, tetapi sedikit lebih sulit untuk menunjukkan konsep pada gim tersebut.  Saya juga akan menjelaskan (terutama kepada programmer grafis) bahwa saya terutama berusaha untuk memahami, oleh karena itu, mungkin, saya akan menggunakan penjelasan yang agak meragukan jika mereka memungkinkan saya untuk mencapai tujuan saya. <br><br><h2>  Bagian 2. Terdiri dari bingkai </h2><br>  Sebagian besar waktu kita akan melihat hanya satu frame dan berbicara tentang blok bangunan yang digunakan game untuk membuat bingkai selesai.  Juga di bagian ini akan ada beberapa gambar baru yang indah. <br><br>  Ada beberapa cara agar bingkai dirangkai dari blok bangunan.  Gambar selesai yang dilihat pemain tidak langsung ditampilkan.  Itu diambil segera bertahun-tahun yang lalu, tetapi mesin grafis modern hampir selalu menggunakan semacam preprocessing.  Sebelum menampilkan bingkai selesai pada layar, mesin grafis menggambar banyak gambar menengah dari berbagai jenis yang membantu dalam menghitung gambar akhir. <br><br>  Gambar-gambar ini sangat tergantung pada jenis mesin dan teknik yang perlu diterapkan oleh programmer grafis.  Misalnya, jika dia ingin sinar matahari menciptakan bayangan yang benar, maka satu jenis gambar akan dibutuhkan untuk bayangan itu.  Dia mungkin juga membutuhkan pantulan yang benar pada mobil yang digerakkan pemain, dan untuk ini juga, dia membutuhkan gambar lain dengan pantulan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/874/47d/95e/87447d95ee62161dc63df6e3dd2406f5.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3b/9ec/b69/a3b9ecb6984a5aae18fd57d8c2f4a9f2.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e6/bd2/ff7/1e6bd2ff7c49373dc337d20c0fe2a66a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/5cb/65d/fa45cb65dfcb2042ecfd06ef6c463022.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/4ed/937/3d94ed937c68dd821ab21c4a1a1cf4fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a57/360/2e8/a573602e8f7b69fa3868df93eebc776f.jpg"></div><br>  <em>Berbagai contoh gambar perantara yang digunakan dalam konstruksi bingkai Watch Dogs.</em> <br><br>  Pada artikel ini, saya tidak akan mempertimbangkan masing-masing gambar yang digunakan dalam bingkai Watch Dogs, tetapi hanya yang dasar, sehingga Anda dapat mempelajari sesuatu.  Ini adalah area di mana penelitian grafis terus-menerus terjadi dan teknik baru sedang muncul.  Inovasi juga muncul pada level yang lebih kecil, tetapi ketika pemasaran memberi tahu Anda tentang beberapa fungsi grafis baru, biasanya mengacu pada peningkatan tersebut. <br><br><hr><br>  Masing-masing gambar menengah ini juga dibangun dari fragmen yang bahkan lebih kecil.  Setiap objek dalam adegan atau sekelompok objek terkait dibuat secara terpisah sebagai <em>model bertekstur</em> .  Saat mengembangkan gim, artis membangun model ini dalam editor 3D dan membuat semua sumber daya yang diperlukan untuk mereka.  Kemudian model-model ini ditempatkan di dunia menggunakan editor tingkat dan kota virtual secara bertahap dibangun dari mereka. <br><br>  Mungkin, hampir semua orang tahu ini, dan jika Anda telah menyaksikan perkembangan grafik 3D real-time selama 20 tahun terakhir, Anda tahu betapa jauh lebih rumitnya model-model saat ini.  Pada tahap-tahap pertama pembentukan grafik, pemetaan tekstur adalah proses yang mahal dan, jika mungkin, dibuang dengan cara melukis objek dengan warna yang sama.  Tekstur dibiarkan hanya untuk elemen seperti mata atau wajah yang benar-benar membutuhkan detail. <br><br>  Model 3D seluruhnya terdiri dari segitiga yang saling berhubungan yang membentuk bentuk objek.  Setiap segitiga memiliki tiga titik yang disebut simpul, dan karena segitiga terhubung satu sama lain, simpul dapat dibagi oleh beberapa segitiga.  Kami akan kembali ke sini nanti karena simpul dan segitiga cukup penting.  Perlu juga diingat bahwa beberapa objek, misalnya, karakter atau pohon, harus dianimasikan sebelum dirender.  Model dibuat dalam bentuk statis standar, dan animasi diterapkan di setiap bingkai.  Kami akan kembali ke sini juga. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/357/03d/382/35703d382d727d1e395283a4fb3aae33.jpg"></div><br>  <em>Ini adalah model 3D dari kepala Aiden Pierce setelah animasi.</em>  <em>Segitiga terlihat karena ditarik datar dan tidak dihaluskan, seperti biasanya.</em> <br><br>  Untuk menambahkan lebih detail ke model 3D, tekstur ditumpangkan.  Tekstur adalah file gambar datar biasa, biasanya berukuran persegi atau sederhana, seperti persegi panjang dengan rasio 2: 1.  Tekstur ditumpangkan pada model 3D menggunakan proses yang lebih kompleks, yang akan saya bahas secara lebih rinci di bawah ini, tetapi secara konseptual mirip dengan proses membungkus hadiah.  Alih-alih pola berulang pembungkus kertas, gambar persisnya cocok dengan ukuran pembungkusnya.  Jika Anda melihat model kertas untuk perakitan dengan lem, maka prinsipnya sama. <br><br>  Analogi ini lebih tepat daripada yang Anda bayangkan, karena tekstur ini biasanya dibuat dengan "membuka gulungan" model 3D ke dalam flat blank, seperti yang dilakukan dengan model kertas, setelah itu tekstur digambar di atasnya.  Penyebaran ini sering dilakukan secara otomatis, tetapi dalam kasus objek yang sangat kompleks dapat dilakukan secara manual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/1f7/cf0/b9f1f7cf0d34680c8f313ad11691656f.jpg"></div><br>  <em>Ini adalah tekstur yang sesuai dengan model kepala Aiden Pierce yang ditunjukkan di atas.</em>  <em>Ada bagian untuk gigi dan lidah.</em>  <em>Perhatikan bahwa area di atas dahinya tidak bertekstur karena tertutup secara permanen oleh Topi Baseball Legendaris Aiden Pearce ™.</em> <br><br><blockquote><h4>  Catatan </h4><br>  Saat dibuka, beberapa bagian dari objek yang membutuhkan peningkatan lebih detail, sementara yang lain berkurang. </blockquote><br>  Sangat sering mereka berbicara tentang berbagai "kulit" model, terutama dalam hal karakter yang dapat disesuaikan.  Hari ini, apa yang disebut "kulit" biasanya mengacu pada perubahan kecil dalam model - sabuk baru atau topi yang berbeda - tetapi pada awalnya istilah ini muncul karena model yang sama digunakan, tetapi teksturnya berubah (atau "kulit" - secara harfiah diterjemahkan sebagai "Skin") untuk membuat karakter yang terlihat berbeda.  Bahkan hari ini, dengan bantuan tekstur seperti itu, Anda dapat membuat variabilitas NPC atau objek yang hebat, yang menghemat waktu dan uang - Anda tidak perlu membuat banyak model 3D yang unik.  Pakaian yang berbeda yang Aiden bisa kenakan seringkali hanya tekstur yang berbeda dari model yang sama. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//8ItIFRj/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Berikut ini cuplikan singkat dari rotasi kepala model 3D.</em>  <em>Hanya tekstur yang ditumpangkan, dan tidak lebih.</em> <br><br>  Dalam bingkai yang kami pertimbangkan, ada sekitar 1700 objek yang dirender di bagian render utama.  Beberapa dari mereka akan menjadi model yang sama - benda-benda seperti bunga dalam pot dan tong sampah tidak pernah benar-benar dibuat secara terpisah, ini adalah satu model atau beberapa model ditempatkan di tempat yang berbeda.  Namun, perkiraan jumlah objek yang diambil untuk menyelesaikan bingkai mendekati <strong>4700</strong> - ini memberi kita gambaran tentang berapa banyak pekerjaan tambahan yang perlu dilakukan selain membuat semua model ini. <br><br>  Mari kita lihat contoh lain dari objek - topi baseball yang dikenakan oleh Aiden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa2/1ce/636/aa21ce63666b4636b76ebe062f7536ca.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f7/4d3/b93/0f74d3b9305c6ed4572a5bc55d178a11.jpg"></div><br>  <em>Ini adalah model topi baseball bertekstur dan bertekstur.</em>  <em>Dapat dilihat bahwa tekstur dibangun dari bagian-bagian terpisah yang terhubung ke model.</em> <br><br><blockquote><h4>  Catatan </h4><br>  Visor dan bagian utama topi baseball pada tekstur tidak menyentuh, karena pemindaian bisa sangat rumit dan, jika perlu, dapat dilakukan di beberapa bagian yang berbeda.  Kadang-kadang, tekstur model bentuk kompleks tanpa masalah yang terlihat dan jahitan membutuhkan keterampilan yang adil. </blockquote><br>  Prinsip yang sama yang kami lihat dengan kepala Aiden berlaku untuk topi.  Bahkan, jika kita mengabaikan tekstur dan angka tertentu yang diperlukan untuk melakukan pembungkusan, maka prinsipnya selalu sama. <br><br>  Untuk menunjukkan apa yang salah selama pengembangan, dan untuk menunjukkan bagaimana Anda bisa bersenang-senang saat memprogram grafik, kami dapat melakukan eksperimen kecil.  Karena sebagian besar tekstur memiliki ukuran kotak standar, dan metode membungkus dan membuka tekstur pada model juga sama, mengapa tidak bermain-main dengan mereka sedikit?  Apa yang terjadi jika kita menerapkan tekstur kepala Aiden ke model topi baseball? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/212/1b1/5c7/2121b15c7f8355575864f9333c9eeab0.jpg"></div><br>  <em>Sudah tidak terlalu mirip dengan Topi Baseball Legendaris Aiden Pierce.</em> <br><br>  Di mana ada logo pada tekstur topi baseball, telinga dan gigi terletak di tekstur kepala.  Di mana ada pelindung, hanya ada rambut di tekstur kepala.  Hamparannya persis sama, tetapi tekstur yang berbeda digunakan.  Tentu saja, contoh ini akan menjadi kesalahan dalam gim, tetapi pikirkan tentang apa yang dapat dilakukan jika Anda menghidupkan tekstur atau membuatnya berkedip - dalam gim ini hal-hal ini digunakan untuk berbagai efek yang sekarang dapat Anda perhatikan.  Secara khusus, gim Saint's Row 4 menggunakan efek serupa untuk "simulasi". <br><br>  Ini juga akan berguna untuk memikirkan konsekuensi dari ini - permainan sangat hati-hati menggabungkan pasangan model dan tekstur, yaitu, model yang paling unik harus cocok dengan tekstur unik mereka sendiri. <br><br>  Tentu saja, aturan ini tidak mutlak - dalam beberapa kasus, untuk menghemat ruang, tekstur adalah pola pengulangan standar yang dapat digunakan untuk banyak objek.  Kumpulan benda terkait - misalnya, agen koran - dapat menggunakan tekstur yang sama untuk koran yang berbeda, dengan masing-masing koran mengambil sebagian kecil dari tekstur. <br><br>  Namun demikian, ini berarti bahwa untuk membangun gambar akhir, semua blok bangunan harus ada, yaitu, sebagai hasilnya, banyak model dan tekstur yang diperlukan dapat diperoleh.  Pada bagian selanjutnya, kita akan berbicara tentang mengapa beberapa aspek, seperti refleksi, sangat sulit untuk diterapkan dengan benar.  Saya juga akan berbicara tentang bagaimana permainan menggunakan trik kecil untuk menghemat waktu dan sumber daya. <br><br><h2>  Bagian 3. Apa yang tidak perlu Anda gambar </h2><br>  Seringkali, pemrograman grafik adalah tugas menyeimbangkan selusin kendala yang berbeda untuk mendapatkan kompromi yang sempurna.  Pada bagian terakhir, kita melihat bahwa setiap kali adegan dibuat, itu dikumpulkan dari banyak blok bangunan kecil - orang, mobil, rambu-rambu jalan, bangunan.  Segala sesuatu yang ada di layar terdiri dari komponen individual yang perlu digambar.  Ada beberapa operasi penyeimbangan halus yang akan kita bahas di sini. <br><br>  Prosesor sentral dan kartu grafis bekerja bersama dalam merender bingkai.  Sisa gim dieksekusi dalam CPU, sehingga memutuskan objek mana yang harus digambar dalam frame saat ini, di mana kamera melihat, dan animasi yang dimainkan.  Kartu grafis adalah "pekerja keras" yang melakukan semua pekerjaan rumit yang terlibat dalam rendering piksel, itulah sebabnya mengapa itu adalah perangkat khusus yang terpisah. <br><br>  Ternyata CPU dan kartu grafis memiliki batasan pada kecepatan atau jumlah perhitungan, tetapi ini adalah berbagai jenis pembatasan. <br><br>  Secara umum, CPU lebih tertarik pada bagian kerjanya sendiri: berapa banyak objek yang perlu kita gambar secara total?  Seberapa <i>berbedanya</i> benda-benda ini - apakah 100 lampu identik, atau 100 semak / tanaman / pohon?  Apakah benda-benda ini dianimasikan, apakah mereka bergerak secara dinamis, dan mana di antaranya yang statis atau tidak bergerak? <br><br>  Hal pertama yang kami lakukan untuk mengurangi beban sebanyak mungkin adalah menggambar hanya apa yang terlihat di layar.  Ini tampak jelas, tetapi implementasi membutuhkan kerja yang hati-hati.  Jangan lupa bahwa kita membangun setiap frame dari awal, jadi <i>di setiap frame</i> kita perlu melihat setiap objek dan menentukan apakah itu terlihat atau tidak.  Ini berarti bahwa di setiap permainan ada kekosongan hitam di mana-mana mengikuti pemain, dan ketika dia tidak melihat benda dan orang, mereka tidak ada lagi. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//bmSqTLe/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Dalam animasi ini, kami memutar kamera, menunjukkan kekosongan di belakang pemain.</em>  <em>Pemirsa yang penuh perhatian akan melihat bahwa itu tidak sepenuhnya kosong ...</em> <br><br>  Sulit untuk mengembangkan aturan praktis dalam kasus ini, tetapi secara umum, Anda dapat menggambar sekitar 1000 objek di tempat kejadian tanpa khawatir tentang kurangnya ruang.  Namun, jika Anda perlu membuat 5.000 objek, maka Anda harus berpikir tentang menggunakan trik.  Jangan lupa bahwa di sebagian besar permainan di mana pemain dapat mengontrol kamera, kita tidak bisa tahu dari sudut mana dia akan terlihat, jadi Anda perlu menghemat ruang untuk bermanuver. <br><br>  Ternyata ada banyak trik yang memungkinkan Anda untuk hampir sepenuhnya menggunakan sumber daya yang valid, dan mereka sangat penting dalam permainan seperti Watch Dogs.  Semakin dekat Anda ke perbatasan dan semakin banyak kualitas visual yang bisa Anda dapatkan dari jumlah objek yang sama, semakin baik gim akan terlihat. <br><br>  Bahkan jika Anda melihat apa yang ada di depan Anda dalam adegan itu, ini tidak berarti bahwa Anda harus menggambar seluruh kota.  Jika ada bangunan besar di sebelah kiri atau kanan, maka semua yang ada di belakangnya menjadi tidak terlihat, jadi Anda tidak bisa menggambarnya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demikian pula, beberapa objek di kejauhan menjadi sangat kecil, jadi kita tidak perlu khawatir tentang menggambar tanaman kecil dan semak di kejauhan. </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//auvvQ67/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi ini menunjukkan bahwa jika Anda menyusuri jalan lebih jauh dari apa yang kita lihat, maka tidak ada apa pun di pinggir jalan, tetapi pada jarak yang jauh detailnya menjadi lebih kecil. </font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktanya, masih ada banyak objek dalam adegan ini yang akan berubah menjadi tidak terlihat sebagai hasilnya. </font><font style="vertical-align: inherit;">Masih banyak yang harus dieksplorasi di bidang ini dan berbagai teknik canggih harus diterapkan. </font><font style="vertical-align: inherit;">Anda selalu harus membuat kompromi, tetapi jika Anda dapat menghabiskan sedikit waktu, atau menghasilkan cara yang sangat cerdas untuk menghindari rendering 100 objek dengan hampir tanpa usaha ekstra, maka kita dapat membuat adegan lebih kompleks atau lebih padat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, ada masalah kecil lainnya. Dalam beberapa kasus, kita harus menggambar sebuah bangunan yang nyaris tidak terlihat di layar dan jauh melampaui itu. Memboroskan sumber daya. Kita selalu dapat membagi benda-benda ini menjadi beberapa bagian, maka setiap bagian dapat ditarik atau dilewati, yaitu, akan ada lebih sedikit limbah. Namun, sekarang kami telah meningkatkan jumlah objek yang digambar saat mereka </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di layar, dan menciptakan masalah sebaliknya! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh ini adalah satu dari ratusan, tetapi mudah untuk menjelaskan tentang keputusan apa yang harus dibuat dan percobaan apa yang harus dilakukan untuk menemukan titik keseimbangan yang sempurna untuk setiap permainan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena aksi bidikan kami dari Watch Dogs terjadi di kota, kami dapat melihatnya dari atas untuk kira-kira memahami apa yang sedang digambar. </font><font style="vertical-align: inherit;">Dalam gambaran statis ini, terutama terlihat bahwa Watch Dogs melakukan pekerjaan setiap tiga bulan.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//My8bi1m/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami pindah untuk menunjukkan area yang terlihat di depan kamera (maaf untuk instalasi untuk menghemat waktu).</font></font></em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/719/960/135/7199601359a0d421147d9f632061bfaf.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perkiraan visibilitas kamera ditumpangkan pada gambar. </font><font style="vertical-align: inherit;">Lebar segitiga ini tergantung pada Bidang Tampilan - kadang-kadang dalam game ini adalah opsi khusus, kadang-kadang nilai konstan.</font></font></em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ccf/5ff/d45/ccf5ffd455dccf7098393602c9944139.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah tampilan bingkai foto pemandangan, bidang pandang kamera terbatas pada warna putih.</font></font></em> <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa dari Anda sudah bisa memikirkan sedikit trik yang akan memungkinkan Anda untuk mengatasi batasan rendering sejumlah objek - mengapa tidak membuat objek kombinasi yang sangat kompleks dari segala sesuatu di area kecil, hingga daun individu? Maka menggambar 1000 objek akan lebih dari cukup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi di sini kita dihadapkan pada serangkaian batasan yang sama sekali berbeda - kartu grafis memiliki kinerja terbatas, dan semakin kompleks objeknya, semakin lama waktu yang diperlukan untuk menggambar. Artinya, bahkan satu objek, jika cukup kompleks, dapat mengurangi frame rate game menjadi 20 FPS. Termasuk inilah sebabnya saya mengatakan bahwa batas jumlah objek agak kabur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jumlah waktu yang dihabiskan untuk suatu objek tergantung pada kompleksitas dan detail dari model dan tekstur, serta pada kecanggihan pencahayaan dan bayangan. Ini juga mengapa gim yang mencoba menerapkan grafis yang lebih rumit atau canggih cenderung menggunakan adegan yang kurang rumit dan terperinci - penyeimbangan menggeser skala dalam satu arah atau lainnya, sehingga Anda dapat memberi Anda lebih banyak ruang untuk bermanuver, mengorbankan apa yang tidak begitu penting untuk gim .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45f/2d5/233/45f2d5233fe8bd806ab2fbf18baa038d.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah semacam peta panas, yang menunjukkan di bagian mana dari pemandangan itu ada model yang sangat kompleks. Perhatikan berapa banyak masalah yang dapat ditimbulkan oleh pohon dan vegetasi.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ada serangkaian teknik lain yang disebut "level of detail" (LOD), yang secara khusus dirancang untuk memecahkan masalah tersebut. Mirip dengan kenyataan bahwa kita dapat mengoptimalkan jumlah objek, memotong semua yang tidak perlu, kita dapat meningkatkan pasokan "kompleksitas", menghilangkan yang tidak perlu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu trik sebenarnya terkenal - ini mengubah resolusi tekstur. Topik ini biasanya bersinggungan dengan banyak orang lain, jadi saya akan mencoba menjelaskannya dengan cara yang mudah diakses.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tekstur dalam gim biasanya persegi panjang dengan ukuran yang sama dengan kekuatan dua - 512, 1024, 2048, 4096. Ada banyak alasan untuk ini, tetapi salah satu kelebihannya adalah Anda dapat mengambil tekstur ukuran 1024x1024 dan dengan mudah membuat versi ukurannya yang lebih kecil dengan ukuran 512x512 . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk alasan yang akan saya bahas di bawah ini, selalu diperlukan bahwa tekstur memiliki semua jenis versi yang lebih kecil. Artinya, tekstur dengan ukuran 1024x1024 akan memiliki versi lebih kecil dari 512x512, 256x256, 128x128, 64x64, 32x32, 16x16, 8x8, 4x4, 2x2 dan 1x1. Namun, salah satu keuntungan dari hal ini adalah bahwa jika objek yang jauh memiliki ukuran kecil di layar, maka menerapkan tekstur 1024x1024 padanya berarti membuang-buang sumber daya. Kita dapat menghemat dengan menggunakan versi yang lebih kecil dari tekstur yang sama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Demikian pula, bahkan objek dekat dapat dianggap tidak terlalu signifikan dan menggunakan tekstur yang lebih kecil untuknya. </font></font><br><br><blockquote><h4>  Catatan </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biasanya, ketika seorang pemain mendekati suatu objek, tekstur terbesar digunakan, tetapi karena kebanyakan orang telah melihat dalam permainan tertentu, ini tidak selalu terjadi dan teksturnya terlihat terlalu buram sebelum memuat. </font><font style="vertical-align: inherit;">Ini biasanya terjadi karena tekstur tidak dapat dimuat dari DVD atau hard drive langsung ke memori kartu grafis untuk rendering. </font><font style="vertical-align: inherit;">Paling sering ini terjadi ketika seorang pemain tiba-tiba mengubah posisinya, misalnya, selama respawn, memuat level baru atau gerakan yang sangat cepat. </font><font style="vertical-align: inherit;">Dalam semua kasus lain, tekstur biasanya dimuat secara bertahap, dalam proses memindahkan pemain di seluruh dunia.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga dapat menerapkan proses penyederhanaan ini ke model-model yang digunakan dalam gim, meskipun jauh lebih sulit untuk dilakukan. Dengan membuat versi sederhana dari objek kompleks, Anda dapat memastikan bahwa pada jarak yang jauh mereka tidak menggerogoti sebagian dari persediaan kompleksitas yang terbatas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berkat objek yang disederhanakan dan model yang dipotong, Anda dapat menghemat banyak uang dan Anda harus menggunakan pendekatan ini dalam game apa pun seperti Watch Dogs. Tetapi pada saat yang sama, itu bisa menjadi pemborosan sumber daya. Hal ini diperlukan untuk membuat keputusan yang sangat bijaksana dan seimbang tentang berapa banyak versi model yang disederhanakan diperlukan. Jika jumlah mereka terlalu sedikit, maka Anda tidak akan bisa menabung terlalu banyak, atau akan ada lompatan yang nyata dalam kualitas saat mengubahnya. Jika ada terlalu banyak, maka Anda akan membuang-buang memori dan menghabiskan waktu yang dibutuhkan manusia untuk membuat objek.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/801/f01/9ed/801f019ed8c365cfebbbeea2320bf3d7.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah bagaimana objek dan karakter yang kompleks terlihat pada jarak ketika mereka tidak bisa dibedakan dari versi mereka yang sangat rinci.</font></font></em> <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap sekarang Anda sudah mengetahui beberapa masalah yang diprogram oleh para pemrogram grafis, seniman, dan perancang level untuk menggabungkan grafis berkualitas tinggi dengan kecepatan tinggi. </font><font style="vertical-align: inherit;">Pada konsol, persamaan ini sedikit lebih mudah untuk diselesaikan daripada di PC, karena peralatannya konstan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada bagian sebelumnya, saya mengatakan bahwa saya akan berbicara tentang mengapa sangat sulit untuk menerapkan refleksi dan hal-hal serupa lainnya dengan benar. Alasannya cukup sederhana - cadangan produktivitas dan sumber daya yang terus saya bicarakan tidak berubah tergantung pada apakah Anda memiliki refleksi atau tidak. Jika Anda ingin membuat refleksi yang dapat kembali menampilkan seluruh adegan, maka Anda harus mengulang semua pekerjaan yang saya bicarakan. Selain itu, pantulan sangat tergantung pada sudut di mana kita melihatnya, jadi untuk mendapatkan refleksi yang akurat untuk setiap objek pantulan, pantulan haruslah milik mereka sendiri!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini bisa keluar dari kendali dengan sangat cepat, dan biasanya permainan yang ada pantulannya memungkinkan mereka untuk bebas atau berasumsi. Game sangat jarang membuat pantulan di lingkungan yang kompleks, maksimum yang bisa dicapai adalah cermin di kamar mandi, di mana tidak ada begitu banyak objek, kompleksitas adegannya kecil, dan karenanya Anda bisa mengeluarkan biaya tambahan. Mungkin pantulan sebenarnya dalam permainan hanya akan berada di permukaan air yang tidak rata atau bergelombang, sehingga bahkan adegan yang sangat kasar dan terperinci rendah sudah cukup untuk membuat pantulan yang meyakinkan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Biasanya sulit untuk sepenuhnya menghindari permukaan reflektif, itulah sebabnya game menggunakan gambar lingkungan langsung yang telah dirender, yang memberikan hasil "cukup baik". Tetapi mereka tidak berdiri dengan cermat, dan jika Anda melihat dengan cermat pada pantulannya, Anda akan melihat bahwa ini adalah tiruan. Ada teknik-teknik modern yang membantu menciptakan refleksi dalam kondisi tertentu, dan mungkin nanti saya akan membicarakannya, tetapi gambar yang telah dirender sebelumnya ("yang direnderkan") masih diperlukan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06c/9bd/b94/06c9bdb94b41c1a83b7d574cdf90f449.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar yang diberikan ini disebut "peta kubus". Itu tidak sepenuhnya akurat sehubungan dengan tempat di mana Aiden berdiri, tetapi cukup dekat dengannya.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Watch Dogs merefleksikan waktu nyata. Saya tidak menyelidiki masalah ini secara terperinci, tetapi saya percaya bahwa mereka selalu ditampilkan ketika karakternya ada di jalan, dan terutama digunakan untuk mendapatkan refleksinya yang tepat pada mobil tempat dia duduk, untuk memperbaiki gambar dan memberinya sedikit realitas. . Karena pemain selalu fokus pada mobilnya dan lingkungan terdekatnya, fakta refleksi yang salah pada mobil lain hampir tidak terlihat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak perkiraan yang tersedia untuk mempercepat rendering refleksi ini. Sebagai contoh, objek yang jauh lebih sedikit ditampilkan dalam refleksi daripada yang ada di adegan nyata - total sekitar 350 - dan banyak dari mereka sangat disederhanakan dibandingkan dengan versi lengkap. Saya menduga bahwa objek yang kompleks, seperti orang-orang, benar-benar dibuang terlepas dari jarak, tetapi saya belum menguji teori ini. Selain itu, tidak ada bayangan pada benda-benda ini, dan pencahayaannya sangat sederhana - hanya yang berasal dari matahari dan langit. Refleksi dibuat dari tanah seperti pada lensa "mata ikan", yaitu, refleksi bumi itu sendiri tidak mungkin, dan apa yang di sebelahnya memiliki detail yang sangat rendah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi bahkan dengan semua penyederhanaan ini, refleksi hanya mengatasi apa yang dimaksudkan. </font><font style="vertical-align: inherit;">Jika Anda mengemudi di bawah rel, Anda bisa mendapatkan refleksi yang tepat dengan pandangan ke arah mobil, yang dalam praktiknya tidak akan berhasil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keputusan ini disengaja dan tidak mudah dibuat. </font><font style="vertical-align: inherit;">Stok adalah nilai konstan, jadi jika Anda meninggalkan ruang untuk refleksi ini, maka Anda perlu mengorbankan sesuatu yang lain.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/cda/fcd/ab1cdafcde2ca5c15111ca30f5b6bb5f.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut ini adalah pemandangan yang sangat "mencurigakan" dari pemandangan di sekitar Aiden dengan pandangan bawah, dibuat untuk refleksi. </font><font style="vertical-align: inherit;">Anda dapat menavigasi sepanjang dua lampu dan rel kereta.</font></font></em> <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada bagian lain dari pekerjaan yang ingin saya sebutkan di sini - bayangan. Kemudian saya berencana untuk berbicara tentang cara kerja bayangan, karena ini adalah topik yang menarik, tetapi sekarang yang paling penting adalah untuk mengingat bahwa bayangan sangat mirip dengan refleksi. Setiap sumber cahaya yang menghasilkan bayangan harus membuat gambar pemandangan dari sudut pandangnya. Kali ini tidak ada banyak cara untuk menyederhanakan pekerjaan - untuk perhitungan bayangan yang benar, setiap sumber cahaya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memiliki gambar ini.</font></font><br><br><blockquote><h4>  Catatan </h4><br>      ,    .           ,      «»  ,             .         ,  ,        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber penerangan bayangan yang paling jelas dan paling signifikan adalah matahari (atau bulan, jika terjadi pada malam hari). </font><font style="vertical-align: inherit;">Karena matahari sangat besar, 3-5 gambar biasanya dibuat untuk itu, dan bukan satu, seperti dalam kasus lampu depan atau lampu senter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, ini adalah salah satu kasus di mana Watch Dogs tidak bisa dijadikan contoh yang baik. </font><font style="vertical-align: inherit;">Perhitungan bayangan dalam gim ini cukup rumit dan, menurut saya, dioptimalkan secara khusus untuk kasus bayangan di kota. </font><font style="vertical-align: inherit;">Karena itu, saya lebih baik beralih ke Far Cry 4 dan mempertimbangkan perhitungan bayangan pada contoh bingkai dari game ini.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/4a4/ae6/21c4a4ae665924ba44245b8e18249f8b.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah adegan dari Far Cry 4 yang saya gunakan sebagai contoh.</font></font></em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/502/26c/7ae50226c3cc0c40c916c58f26ba27f3.jpg"></div><br>  <em>Berikut adalah gambar dengan informasi tentang bayangan adegan ini - masing-masing membutuhkan rendering adegan yang sama sekali baru.</em> <br><br>  Karena itu, ketika kita perlu menambahkan pengecoran bayangan ke sumber cahaya, kita harus membuat adegan sekali lagi.  Di sini, Anda juga dapat menggunakan beberapa perkiraan yang digunakan dalam kasus refleksi, hanya saja jauh lebih kecil.  Anda dapat melewati objek kecil atau jauh, tetapi perlu diingat bahwa objek ini tidak akan muncul untuk membuat bayangan.  Anda dapat membuat gambar sangat kecil, tetapi kemudian bayangannya akan kasar dan detail rendah.  Biasanya tidak mungkin untuk menggunakan versi objek yang sangat disederhanakan, karena dengan begitu akan terlihat bahwa objek melemparkan bayangan pada dirinya sendiri, atau celah muncul di antara objek dan bayangannya. <br><br>  Konsekuensi lain yang sangat mudah untuk dilewatkan adalah kebutuhan untuk membuat gambar bayangan untuk setiap sumber cahaya.  Dalam banyak kasus, dimungkinkan untuk menyederhanakan sumber pencahayaan dengan menggabungkannya - di Watch Dogs ini terjadi dengan lampu mobil. <br><br>  Ketika kedua lampu menyala, hanya satu sumber cahaya yang diambil, tetapi memiliki bentuk khusus, karena itu terlihat seperti dua sinar.  Jika lampu depan memiliki bayangan, maka ini tidak begitu mudah dilakukan, dan itu akan jauh lebih terlihat - ketika pemain lewat di depan mobil, maka cahaya akan datang dari suatu tempat di antara dua lampu depan.  Mungkin Anda harus memisahkan lampu depan, tetapi pada saat yang sama, tidak hanya akan ada biaya tambahan untuk menghitung bayangan, tetapi Anda juga harus menggambar pencahayaan baru. <br><br><hr><br>  Hal utama yang ingin saya tekankan dengan semua ini adalah kompromi.  Kita tentu saja bisa menghilangkan semua perkiraan ini, tetapi kita harus menghabiskan cadangan sumber daya kita untuk ini, yaitu, mengorbankan sesuatu yang lain.  Setiap pengembang game harus memutuskan apa yang penting baginya untuk fokus dalam permainan, dan apa yang paling mengesankan atau paling mengganggu pemain. <br><br><h2>  Bagian 4. Memindahkan puncak </h2><br>  Pada bagian ini saya akan berbicara lebih banyak tentang detail teknis dari objek animasi di tempat kejadian. <br><br>  Pemrogram grafik sering berbicara tentang "grafik pipa".  Grafis 3D agak mirip jalur perakitan dengan gerakan yang jelas dari satu tahap ke tahap lainnya, tetapi tidak bekerja hanya dengan satu objek pada satu waktu. <br><br>  Semua kartu grafis modern memiliki kira-kira sabuk konveyor yang sama, mereka memiliki peralatan dan perangkat lunak khusus yang secara langsung di-flash "dalam silikon" untuk memaksimalkan kecepatan konveyor.  Tentu saja, ada banyak variasi antara berbagai produsen dan keluarga kartu grafis, tetapi biasanya kita tidak perlu khawatir tentang <em>bagaimana</em> mereka bekerja pada tingkat ini. <br><br><blockquote><h4>  Catatan </h4><br>  Jika Anda tertarik pada bagaimana semuanya bekerja pada tingkat perangkat keras abstrak, maka saya merekomendasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">serangkaian artikel oleh Fabian Giesen di jalur pipa grafis</a> .  Seri artikel ini <em>jauh</em> lebih rinci dan membutuhkan lebih banyak pemahaman daripada posting saya. </blockquote><br>  Saya akan melewatkan banyak detail untuk menjelaskan prinsip-prinsip yang menarik dan penting.  Di bagian ini, kita akan melihat bagian pertama dari pipa, yang disebut <strong>Vertex Shader</strong> . <br><br>  Shaders menjadi tersebar luas sekitar 16 tahun yang lalu, setelah rilis DirectX 9, di mana vertex dan pixel shaders muncul.  Untuk menjelaskan apa itu shader dan membandingkannya dengan apa yang dulu, saya akan berbicara tentang pekerjaan yang mereka lakukan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/357/03d/382/35703d382d727d1e395283a4fb3aae33.jpg"></div><br>  <em>Kepala kerangka Aiden bersama kita lagi.</em> <br><br>  Biarkan saya mengingatkan Anda bahwa di bagian 2, kami memeriksa model dari mana dunia game dibuat.  Pola-pola ini terdiri dari titik-titik individual yang disebut simpul yang terhubung dalam segitiga.  Saya mengatakan bahwa saya akan memberi tahu Anda lebih banyak tentang mereka nanti, dan sekarang saya menepati janji saya. <br><br>  Karena semua yang ada di dunia gim terdiri dari simpul, semua yang perlu dilakukan dengan model ini harus dilakukan dengan simpul.  Ketika datang ke kartu grafis, yang dilihatnya adalah daftar panjang simpul.  Baginya, tidak ada hal seperti menjalankan animasi, atau mengayunkan daun pohon, atau konsep abstrak lainnya. <br><br>  Mari kita lihat contoh sederhana dari apa yang harus kita lakukan - memindahkan dan memposisikan objek di dunia.  Untuk memulainya, mari kita ambil kasus sederhana, bukan karakter. <br><br>  Saat membuat objek dalam editor 3D seperti Maya dan 3D Studio Max, seniman selalu membangun dari dalam dunia mereka sendiri yang terpisah.  Benda-benda ini tidak segera dibuat di rombongan Chicago, melainkan, lingkungan mereka terlihat seperti "ruang putih kosong" dari Matrix.  Setiap objek terletak di tengah kekosongan absolut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd0/a55/a3c/bd0a55a3c96f5fefc237bdf22194e009.png"></div><br>  <em>Berikut adalah lampu lalu lintas dalam permainan di suatu tempat di bawah rel, dan terletak di dunianya sendiri.</em> <br><br>  Saat menyimpan ke disk, model tidak tahu di mana ia akan berada di dunia dan kapan akan diunduh dan ditransfer ke kartu grafis.  Ini berarti bahwa ketika tiba saatnya untuk menggambar objek, kita perlu memindahkannya dari dunia kita sendiri ke adegan yang kita gambar.  Ini terjadi dengan setiap objek digambar, dan bahkan objek tak bergerak seperti bangunan dan jembatan juga berpindah dari dunianya sendiri ke pemandangan di setiap bingkai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d65/21d/673/d6521d67344753566d0d2b4ff3b4fbf9.png"></div><br>  <em>Di sini kita melihat beberapa lampu lalu lintas sudah ditempatkan di adegan akhir yang sebagian dibangun.</em> <br><br>  Seperti yang saya sebutkan di atas, satu-satunya hal yang dapat kita kerjakan adalah puncak.  Kami tidak bisa hanya mengatakan kepada kartu grafis: "Bisakah Anda meletakkan lampu lalu lintas ini di bawah jembatan?  Dan kemudian menempatkan satu lagi sedikit lebih jauh?  Hebat! ” <br><br>  Karena itu, alih-alih memberi tahu kartu grafis apa yang perlu dilakukan dengan objek itu sendiri, kita perlu mengatakan apa yang harus dilakukan dengan semua simpulnya.  Ternyata dalam hal ini semuanya menjadi sangat sederhana.  Jika kita mengubah semua simpul dengan cara yang persis sama dan mereka tetap tidak bergerak satu sama lain, maka ini mirip dengan memindahkan objek secara keseluruhan.  Yang perlu kita lakukan adalah mencari tahu apa "perubahan" yang disebut transformasi. <br><br><blockquote><h4>  Catatan </h4><br>  Perhitungan matematis dari semua ini tidak terlalu rumit, tetapi berada di luar cakupan artikel.  Jika Anda sudah mempelajari aljabar linier, Anda mungkin tahu semua yang Anda butuhkan - pada dasarnya semuanya bermuara pada perkalian matriks vektor. </blockquote><br>  Sebelum munculnya vertex shaders, opsi yang memungkinkan untuk mengubah simpul pada kartu grafis sangat terbatas.  Yang tersedia adalah objek yang bergerak dan berputar, serta beberapa operasi lain, tetapi tidak ada yang terlalu berlebihan atau rumit. <br><br>  Vertex shaders adalah program komputer kecil yang dijalankan pada kartu grafis.  Mereka mengambil satu simpul, melakukan <em>tindakan yang diperlukan</em> dengan itu dan mengeluarkan simpul keluaran.  Mereka tidak hanya bisa memindahkannya, tetapi juga membuat mereka melompat-lompat, menjauh dari puncak terdekat, mengayun tergantung pada angin, menjadi animasi dan banyak lagi. <br><br>  Saya mengambil salah satu shader vertex yang digunakan pada Watch Dogs dan bereksperimen dengannya sedikit untuk menunjukkan apa yang dilakukannya.  Ini adalah pekerjaan yang sangat melelahkan, tetapi saya berhasil menemukan vertex shader yang digunakan untuk karakter dan mengubahnya.  Ada vertex shader lain yang digunakan untuk kulit, misalnya, untuk wajah dan tangan, tetapi Anda akan segera memahami prinsipnya. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//Wqyv7B8/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Saya membuat perubahan yang sangat sederhana yang menambahkan tikungan pada model karakter, tetapi semua yang lain digunakan seperti biasa.</em> <br><br>  Animasi di atas menunjukkan bahwa karakternya entah bagaimana anehnya terdistorsi.  Ini membawa kita kembali ke prinsip "jika Anda memindahkan setiap titik, maka ini mirip dengan memindahkan seluruh objek."  Perubahan yang dilakukan pada vertex shader hanya berfungsi untuk satu vertex pada satu waktu, tetapi karena mereka semua bekerja dengan distorsi yang sama, efeknya diterapkan ke seluruh objek. <br><br>  Anda juga dapat membuat perubahan pada bagian transformasi, yang bertanggung jawab untuk "hanya pindah ke tempat," sehingga alih-alih menempatkan karakter di tempat yang tepat, dia mengangkatnya di atas tanah.  Ini tidak disimulasikan dengan bantuan fisika, oleh karena itu tidak ada hubungannya dengan gravitasi atau tabrakan dengan benda lain - jika kita mau, kita dapat membuat semua orang melayang di udara. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//tktCaw4/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Dalam animasi ini, kami membuat vertex shader secara bertahap menaikkan dan menurunkan objek.</em> <br><br>  Jelas, semua ini tidak terlalu konstruktif, tetapi memberi kita gambaran umum tentang cara kerja vertex shaders - jika kita sekarang ingin menghidupkan daun di pohon sehingga mereka berayun, kita akan melakukan hal yang sama.  Hanya alih-alih menaikkan dan menurunkan, mereka akan berayun ke arah angin.  Kemudian kita dapat mengubah kekuatan angin sehingga pohon-pohon bergoyang lebih atau kurang. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//5Sl1uhw/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Di sini kita melihat apa yang terjadi ketika semuanya meningkat sekitar tujuh kali.</em> <br><br>  Saya menyederhanakan sedikit, tetapi pada dasarnya tugas sebagian besar shader vertex adalah "memindahkan objek ke tempatnya".  Pengecualiannya adalah semua objek animasi - orang, hewan, serta objek seperti tali berayun, pakaian berkibar, dll. <br><br><hr><br>  Orang animasi terhubung dengan gagasan menggunakan kerangka dan "kulit".  Kerangka adalah deskripsi sederhana dari karakter yang bergerak.  Pada tahap ini, kita tidak peduli dengan gesper, topi, atau celana jeans yang tidak dianimasikan - hanya gerakan penting yang paling tepat untuk kerangka manusia yang penting bagi kita. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0f/bf2/ce7/f0fbf2ce7c1a0d3d287f8cc4b04b41f2.png"></div><br>  <em>Kerangka sederhana dari sosok manusia ditampilkan di sini.</em>  <em>Itu tidak diambil dari Watch Dogs, karena kerangka itu sulit untuk divisualisasikan di luar editor 3D.</em> <br><br>  <em>Gambar dilisensikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Attribution-ShareAlike CC BY-SA</a> © <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tim MakeHuman</a> 2001-2014</em> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//nXYWZOr/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Ini adalah pose jepret atau pose-T yang menunjukkan bagaimana karakter terlihat tanpa menggunakan animasi.</em> <br><br>  Animasi - berlari, berjalan, melompat - hanya berlaku untuk kerangka ini.  Ini membuat keseluruhan proses menjadi sangat sederhana, karena kita hanya perlu mempertimbangkan sekitar seratus tulang, bukan ribuan dan ribuan simpul. <br><br>  Setelah membuat kerangka, setiap dhuwur menempel pada satu atau lebih tulang dalam pose statis ini, dan hubungan ini disebut "menguliti".  Pada saat Half-Life 1, ketika teknologi ini mulai digunakan, masing-masing simpul terkait dengan hanya satu tulang.  Saat ini, mereka bahkan dapat bergabung dengan empat tulang, sementara masing-masing tulang diberi berat, di mana tingkat pengaruh tulang pada puncak tergantung.  Berkat ini, Anda bisa mendapatkan animasi yang lebih halus, memungkinkan tulang untuk bersinggungan di area yang berbeda tanpa membuat sudut tajam saat menggerakkan lengan atau kaki. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/af5/e31/7e5af5e314bf44d7f9098941be6eacbc.png"></div><br>  <em>Ini adalah kerangka yang ditunjukkan di atas dengan tulang paha diputar.</em>  <em>Warna-warna menunjukkan berat tulang pinggul relatif terhadap bagian atas model.</em> <br><br>  <em>Gambar dilisensikan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Attribution-ShareAlike CC BY-SA</a> © <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tim MakeHuman</a> 2001-2014</em> <br><br>  Teknologi ini memiliki keterbatasan, terutama di tempat-tempat pakaian dan kulit dikompresi atau diregangkan dalam engsel, misalnya pada siku dan bahu.  Ini adalah cara yang tidak sempurna, tetapi sangat efektif untuk menghidupkan.  Keterbatasan paling serius adalah sangat sulit membuat animasi wajah yang memikat dengan cara ini.  Anda dapat membuat banyak tulang "palsu" di wajah Anda, misalnya untuk alis dan di sekitar mulut, tetapi ini hanya perkiraan kasar dari otot dan kulit. <br><br>  Fitur penting lain dari teknik ini adalah perbandingan verteks dan tulang sangat spesifik dan terkait dengan bagaimana perbandingan ini dilakukan.  Dimungkinkan untuk menggunakan animasi untuk beberapa model yang berbeda, tetapi setiap model individu di mana Anda ingin menggunakan kerangka harus dikaitkan dengan tulang.  Alasannya adalah bahwa animasi memindahkan simpul dari posisi semula relatif ke kerangka mereka.  Jika simpul tidak pada posisi yang diharapkan, maka masalah akan muncul. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//JdJEwEW/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Jika model tidak cocok dengan kerangka yang digunakan olehnya, maka animasinya akan <u>sepenuhnya</u> salah.</em> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//Wt5PSQY/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Jika kita membuat karakter dua kali lebih lebar, kita mendapatkan efek yang mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"donat makan berlebihan" Drake</a> , tetapi terlihat bahwa animasi yang lebih dekat dengan kuas menjadi salah, karena ini adalah tempat mereka paling jauh dari posisi aslinya.</em> <br><br>  Animasi pertama mungkin tampak aneh bagi Anda - animasi kesalahan seperti ini sering terjadi di permainan.  Biasanya mereka disebabkan oleh fakta bahwa animasi yang salah diterapkan pada kerangka, atau model menggunakan kerangka yang salah.  Seperti dalam kasus dengan tekstur dan model, kerangka, menguliti dan model harus sangat hati-hati dibandingkan, jika tidak hasilnya akan cepat menjadi sedih. <br><br>  Saya harap Anda mendapat ide tentang tujuan vertex shader dan memahami bagaimana animasi digunakan untuk mengubah model statis menjadi karakter yang hidup. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430930/">https://habr.com/ru/post/id430930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430918/index.html">Tentang Flutter, secara singkat: Dasar-dasar</a></li>
<li><a href="../id430922/index.html">Contoh perhitungan untuk switchboard</a></li>
<li><a href="../id430924/index.html">Ada pemrograman</a></li>
<li><a href="../id430926/index.html">Waktu terfragmentasi; sedikit tentang kesamaan sistem terdistribusi dan model memori yang lemah</a></li>
<li><a href="../id430928/index.html">Hanya tentang "rumah pintar": cara membuat lampu latar "pintar"</a></li>
<li><a href="../id430932/index.html">Peretas mencuri lebih dari 21 juta rubel dari bank Rusia</a></li>
<li><a href="../id430934/index.html">Asterisk dialplan extension mask generator</a></li>
<li><a href="../id430936/index.html">DEFCON 21. Konferensi DNS dapat berbahaya bagi kesehatan Anda. Bagian 2</a></li>
<li><a href="../id430938/index.html">Cara mendapatkan pesanan pertama dalam desain saat tidak ada portofolio dan pengalaman</a></li>
<li><a href="../id430940/index.html">SDK untuk Anda, SDK untuk saya, SDK untuk semua orang! Cara membuat SDK dan mengapa diperlukan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>