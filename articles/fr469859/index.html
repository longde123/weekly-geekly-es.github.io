<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤ŸğŸ½ â” ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ Pointeur et valeur sÃ©mantique pour dÃ©terminer le rÃ©cepteur d'une mÃ©thode âš™ï¸ ğŸ™‡ğŸ» ğŸ‰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La crÃ©ation de nouveaux types de donnÃ©es est une partie importante du travail de chaque programmeur. Dans la plupart des langues, une dÃ©finition de ty...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pointeur et valeur sÃ©mantique pour dÃ©terminer le rÃ©cepteur d'une mÃ©thode</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469859/">  La crÃ©ation de nouveaux types de donnÃ©es est une partie importante du travail de chaque programmeur.  Dans la plupart des langues, une dÃ©finition de type consiste en une description de ses champs et mÃ©thodes.  Dans Golang, en plus de cela, vous devez dÃ©cider quelle sÃ©mantique de destinataire pour les mÃ©thodes du nouveau type Ã  utiliser: valeur (valeur) ou pointeur (pointeur).  Ã€ premiÃ¨re vue, cette dÃ©cision peut sembler secondaire, car dans la plupart des cas, le programme fonctionnera avec n'importe quelle sÃ©mantique du destinataire.  Par consÃ©quent, de nombreuses personnes ignorent ce point et Ã©crivent du code et ne l'ont pas compris jusqu'Ã  la fin, ce qui est affectÃ© par la sÃ©mantique du destinataire de la mÃ©thode.  Et pour le comprendre, vous devez approfondir un peu le fonctionnement de Golang. <br><a name="habracut"></a><br>  Prenons un petit exemple.  DÃ©finissez une structure de <i>chat</i> avec un champ <i>Nom</i> et une <i>mÃ©thode sayHello (chaÃ®ne de personnes)</i> .  Ci-aprÃ¨s, <i>par une mÃ©thode,</i> je ferai rÃ©fÃ©rence Ã  une fonction associÃ©e Ã  un type particulier, un <i>objet</i> Ã  une variable qui a des mÃ©thodes, et le <i>destinataire de la mÃ©thode</i> sera la variable indiquÃ©e entre parenthÃ¨ses aprÃ¨s le mot <i>func</i> dans la description de la mÃ©thode. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> cat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *cat)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(person </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Meow, meow, %s!"</span></span>, person) }</code> </pre> <br>  Si nous dÃ©finissons un pointeur sur <i>cat</i> et que nous lui demandons le champ <i>Nom</i> , alors, Ã©videmment, nous obtiendrons une erreur, car le champ est appelÃ© Ã  partir de <i>zÃ©ro</i> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c *cat <span class="hljs-comment"><span class="hljs-comment">// c=nil fmt.Println(c.Name) //panic: runtime error: invalid memory address or nil pointer dereference</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/L3FnRJXKqs0</a> <br><br>  Cependant, lorsque la mÃ©thode <i>sayHello ()</i> est appelÃ©e sur la mÃªme variable, il n'y aura pas d'erreur: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c *cat <span class="hljs-comment"><span class="hljs-comment">// c=nil c.sayHello(â€œHumanâ€) //Meow, meow, Human!</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/EMoFgKL1HEi</a> <br><br>  Pourquoi <i>nil</i> peut-il appeler une mÃ©thode dans cet exemple, et comment cela s'explique-t-il en termes d'architecture du langage lui-mÃªme?  Cela devient possible car la mÃ©thode dans Go est du sucre syntaxique ou, en d'autres termes, un wrapper autour d'une fonction qui possÃ¨de l'un des arguments de destinataire.  Lorsque la <i>mÃ©thode c.sayHello (Â«HumanÂ»)</i> est appelÃ©e, la construction <i>(* cat) .sayHello (c, s)</i> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/X9leJeIvxcA</a> ) sera effectivement appelÃ©e.  En appelant la mÃ©thode <i>nil Ã </i> partir de l'exemple ci-dessus, nous appelons pratiquement la fonction avec <i>nil</i> dans les arguments, et c'est dÃ©jÃ  une situation tout Ã  fait normale.  Par consÃ©quent, dans Go <i>nil, c'est</i> le bon destinataire pour les mÃ©thodes. <br><br>  Ã‰tant donnÃ© que le rÃ©cepteur de mÃ©thode est en fait un argument, les recommandations d'utilisation de la sÃ©mantique Â«valeurÂ» ou Â«pointeurÂ» pour le rÃ©cepteur de mÃ©thode sont similaires aux recommandations pour les arguments de fonction.  Ils sont Ã  leur tour dÃ©duits de la rÃ¨gle de base de Go: les <b>arguments sont toujours passÃ©s Ã  la fonction par valeur</b> .  Cela signifie que le transfert de tout argument Ã  la fonction se produit par sa copie: si la fonction accepte une structure en entrÃ©e, alors une copie complÃ¨te de cette structure viendra Ã  l'intÃ©rieur;  s'il prend un pointeur sur un objet, alors une nouvelle variable viendra avec un pointeur sur le mÃªme objet.  Cela peut Ãªtre vu en comparant l'adresse de la variable avant de la transmettre Ã  la fonction avec l'adresse de l'argument Ã  l'intÃ©rieur de la fonction ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/oc2ssC_Irs8</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/FeQa2HUdX0a</a> ). <br><br>  Lorsque le passage de lien est utilisÃ©: <br><br><ul><li>  Pour les grandes structures.  Le pointeur occupe un seul mot machine (32, 64 bits selon le systÃ¨me).  Par consÃ©quent, lors de l'appel d'une mÃ©thode avec un pointeur dans le rÃ©cepteur, la copie du pointeur est moins coÃ»teuse que la copie de l'objet entier, comme ce serait le cas en passant par valeur. </li><li>  Si la mÃ©thode appelÃ©e modifie les donnÃ©es de l'objet lui-mÃªme.  Lorsque le destinataire est transfÃ©rÃ© par rÃ©fÃ©rence, la mÃ©thode peut affecter l'Ã©tat de l'objet appelant en apportant indirectement des modifications.  Ce qui est impossible en passant par la valeur. </li></ul><br>  Lors de l'utilisation du transfert de valeur: <br><br><ul><li>  Pour les types intÃ©grÃ©s simples tels que les nombres, les chaÃ®nes, les boolÃ©ens.  Lorsque vous utilisez le pointeur, presque la mÃªme quantitÃ© de mÃ©moire est utilisÃ©e que l'objet de ce type, et le coÃ»t de sa maintenance par le garbage collector augmente, comme cela sera dÃ©crit ci-dessous. </li><li>  Pour les tranches, ainsi que pour d'autres types de rÃ©fÃ©rence: carte et canaux - cela n'a aucun sens de prendre un pointeur.  Ils sont eux-mÃªmes dÃ©jÃ  un pointeur. </li><li>  Avec le multithread, le passage par valeur est sÃ»r, contrairement au passage par rÃ©fÃ©rence. </li><li>  Pour les petites structures.  Dans de tels cas, la transmission par valeur est plus efficace.  En effet, les donnÃ©es internes des mÃ©thodes sont placÃ©es dans un cadre distinct de la pile.  AprÃ¨s avoir quittÃ© une fonction, son cadre est effacÃ©.  Lorsque nous fouillons quelque chose le long du pointeur, nous transfÃ©rons ces donnÃ©es de la pile vers le tas, d'oÃ¹ ces donnÃ©es peuvent Ãªtre disponibles pour d'autres fonctions.  L'augmentation du tas crÃ©e une charge supplÃ©mentaire pour le garbage collector, dont le fonctionnement rÃ©duit la vitesse du programme de 25% en moyenne.  Lorsque vous utilisez le transfert valeur par valeur, les donnÃ©es restent sur la pile et aucun travail de ramasse-miettes supplÃ©mentaire n'est requis. </li></ul><br>  Lorsque vous devez penser Ã  la sÃ©mantique du destinataire: <br><br><ul><li>  Le type de destinataire peut varier selon le sujet.  Dans l'un de ses discours, Bill Kennedy a donnÃ© un bon exemple avec le type d'utilisateur dÃ©crivant l'utilisateur.  Une fois passÃ© par valeur, une copie sera crÃ©Ã©e pour l'utilisateur.  Cela conduira au fait que plusieurs copies d'un mÃªme utilisateur peuvent coexister dans le programme en mÃªme temps, qui peuvent ensuite Ãªtre modifiÃ©es indÃ©pendamment, ce qui ne correspond pas au domaine, car l'utilisateur rÃ©el est toujours un, et il ne peut pas Ãªtre dÃ©crit Ã  diffÃ©rents moments par diffÃ©rents ensembles les donnÃ©es. </li><li>  Une autre faÃ§on sÃ»re de dÃ©terminer le type de destinataire d'une mÃ©thode consiste Ã  utiliser la mÃ©thode constructeur pour son type.  Si le constructeur retourne une valeur / un pointeur, alors lors de la crÃ©ation d'une entitÃ©, il est supposÃ© qu'ils continueront Ã  travailler avec elle en tant que valeur / pointeur.  Par consÃ©quent, il est Ã©galement prÃ©fÃ©rable d'utiliser la mÃªme sÃ©mantique dans le rÃ©cepteur de mÃ©thode. </li><li>  Il existe une rÃ¨gle non Ã©crite, en violation de laquelle le compilateur ne jurera pas, mais votre code ne s'amÃ©liorera certainement pas.  Si l'une des mÃ©thodes de type utilise un pointeur / valeur comme rÃ©cepteur, pour conserver la cohÃ©rence, les mÃ©thodes restantes doivent utiliser un pointeur / valeur.  Les mÃ©thodes de type ne doivent pas avoir de hachage de rÃ©cepteurs de valeur et de pointeur. </li></ul><br><h4>  Quel est le rÃ©sultat </h4><br>  Dans Go Value, la sÃ©mantique signifie copier une valeur; la sÃ©mantique du pointeur signifie donner accÃ¨s Ã  une valeur.  Cela s'applique Ã  la fois aux arguments des mÃ©thodes et Ã  leurs destinataires.  Pour les types intÃ©grÃ©s, tels que les nombres, les lignes, les tranches, les cartes, les canaux et les petites structures, vous devez presque toujours utiliser le transfert basÃ© sur la valeur.  Pour les structures qui occupent une grande quantitÃ© de mÃ©moire et les structures dont l'Ã©tat peut Ãªtre indirectement modifiÃ© par leurs mÃ©thodes, vous devez utiliser le transfert par rÃ©fÃ©rence.  En outre, la sÃ©mantique du destinataire peut dÃ©pendre du domaine dÃ©crit par le type, de la sÃ©mantique renvoyÃ©e dans sa fabrique et de la sÃ©mantique du destinataire dÃ©jÃ  utilisÃ©e dans d'autres mÃ©thodes de ce type. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469859/">https://habr.com/ru/post/fr469859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469835/index.html">RÃªves soviÃ©tiques de l'avenir, partie 2. Maintenant avec Sepulki</a></li>
<li><a href="../fr469837/index.html">PremiÃ¨re rencontre Flutter Ã  Saint-PÃ©tersbourg: reportages vidÃ©o</a></li>
<li><a href="../fr469839/index.html">VulnÃ©rabilitÃ© de spam dans Pikabu</a></li>
<li><a href="../fr469843/index.html">"OÃ¹ sont ces jeunes punks qui nous essuieront de la surface de la terre?"</a></li>
<li><a href="../fr469855/index.html">Gradle + LLVM</a></li>
<li><a href="../fr469861/index.html">Structures de donnÃ©es pour les programmeurs de jeux: donnÃ©es en masse</a></li>
<li><a href="../fr469865/index.html">700 employÃ©s et plusieurs continents: comment Alconost a construit un modÃ¨le commercial sans officier</a></li>
<li><a href="../fr469869/index.html">Pourquoi vous devriez overclocker la RAM (c'est facile!)</a></li>
<li><a href="../fr469871/index.html">Quand les claviers Ã©taient des tables</a></li>
<li><a href="../fr469875/index.html">Comment protÃ©ger vos mots de passe en 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>