<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏽 ❔ 👨‍👩‍👧‍👦 Pointeur et valeur sémantique pour déterminer le récepteur d'une méthode ⚙️ 🙇🏻 🏉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La création de nouveaux types de données est une partie importante du travail de chaque programmeur. Dans la plupart des langues, une définition de ty...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pointeur et valeur sémantique pour déterminer le récepteur d'une méthode</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469859/">  La création de nouveaux types de données est une partie importante du travail de chaque programmeur.  Dans la plupart des langues, une définition de type consiste en une description de ses champs et méthodes.  Dans Golang, en plus de cela, vous devez décider quelle sémantique de destinataire pour les méthodes du nouveau type à utiliser: valeur (valeur) ou pointeur (pointeur).  À première vue, cette décision peut sembler secondaire, car dans la plupart des cas, le programme fonctionnera avec n'importe quelle sémantique du destinataire.  Par conséquent, de nombreuses personnes ignorent ce point et écrivent du code et ne l'ont pas compris jusqu'à la fin, ce qui est affecté par la sémantique du destinataire de la méthode.  Et pour le comprendre, vous devez approfondir un peu le fonctionnement de Golang. <br><a name="habracut"></a><br>  Prenons un petit exemple.  Définissez une structure de <i>chat</i> avec un champ <i>Nom</i> et une <i>méthode sayHello (chaîne de personnes)</i> .  Ci-après, <i>par une méthode,</i> je ferai référence à une fonction associée à un type particulier, un <i>objet</i> à une variable qui a des méthodes, et le <i>destinataire de la méthode</i> sera la variable indiquée entre parenthèses après le mot <i>func</i> dans la description de la méthode. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> cat <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *cat)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(person </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Meow, meow, %s!"</span></span>, person) }</code> </pre> <br>  Si nous définissons un pointeur sur <i>cat</i> et que nous lui demandons le champ <i>Nom</i> , alors, évidemment, nous obtiendrons une erreur, car le champ est appelé à partir de <i>zéro</i> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c *cat <span class="hljs-comment"><span class="hljs-comment">// c=nil fmt.Println(c.Name) //panic: runtime error: invalid memory address or nil pointer dereference</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/L3FnRJXKqs0</a> <br><br>  Cependant, lorsque la méthode <i>sayHello ()</i> est appelée sur la même variable, il n'y aura pas d'erreur: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c *cat <span class="hljs-comment"><span class="hljs-comment">// c=nil c.sayHello(“Human”) //Meow, meow, Human!</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/EMoFgKL1HEi</a> <br><br>  Pourquoi <i>nil</i> peut-il appeler une méthode dans cet exemple, et comment cela s'explique-t-il en termes d'architecture du langage lui-même?  Cela devient possible car la méthode dans Go est du sucre syntaxique ou, en d'autres termes, un wrapper autour d'une fonction qui possède l'un des arguments de destinataire.  Lorsque la <i>méthode c.sayHello («Human»)</i> est appelée, la construction <i>(* cat) .sayHello (c, s)</i> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/X9leJeIvxcA</a> ) sera effectivement appelée.  En appelant la méthode <i>nil à</i> partir de l'exemple ci-dessus, nous appelons pratiquement la fonction avec <i>nil</i> dans les arguments, et c'est déjà une situation tout à fait normale.  Par conséquent, dans Go <i>nil, c'est</i> le bon destinataire pour les méthodes. <br><br>  Étant donné que le récepteur de méthode est en fait un argument, les recommandations d'utilisation de la sémantique «valeur» ou «pointeur» pour le récepteur de méthode sont similaires aux recommandations pour les arguments de fonction.  Ils sont à leur tour déduits de la règle de base de Go: les <b>arguments sont toujours passés à la fonction par valeur</b> .  Cela signifie que le transfert de tout argument à la fonction se produit par sa copie: si la fonction accepte une structure en entrée, alors une copie complète de cette structure viendra à l'intérieur;  s'il prend un pointeur sur un objet, alors une nouvelle variable viendra avec un pointeur sur le même objet.  Cela peut être vu en comparant l'adresse de la variable avant de la transmettre à la fonction avec l'adresse de l'argument à l'intérieur de la fonction ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/oc2ssC_Irs8</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://play.golang.org/p/FeQa2HUdX0a</a> ). <br><br>  Lorsque le passage de lien est utilisé: <br><br><ul><li>  Pour les grandes structures.  Le pointeur occupe un seul mot machine (32, 64 bits selon le système).  Par conséquent, lors de l'appel d'une méthode avec un pointeur dans le récepteur, la copie du pointeur est moins coûteuse que la copie de l'objet entier, comme ce serait le cas en passant par valeur. </li><li>  Si la méthode appelée modifie les données de l'objet lui-même.  Lorsque le destinataire est transféré par référence, la méthode peut affecter l'état de l'objet appelant en apportant indirectement des modifications.  Ce qui est impossible en passant par la valeur. </li></ul><br>  Lors de l'utilisation du transfert de valeur: <br><br><ul><li>  Pour les types intégrés simples tels que les nombres, les chaînes, les booléens.  Lorsque vous utilisez le pointeur, presque la même quantité de mémoire est utilisée que l'objet de ce type, et le coût de sa maintenance par le garbage collector augmente, comme cela sera décrit ci-dessous. </li><li>  Pour les tranches, ainsi que pour d'autres types de référence: carte et canaux - cela n'a aucun sens de prendre un pointeur.  Ils sont eux-mêmes déjà un pointeur. </li><li>  Avec le multithread, le passage par valeur est sûr, contrairement au passage par référence. </li><li>  Pour les petites structures.  Dans de tels cas, la transmission par valeur est plus efficace.  En effet, les données internes des méthodes sont placées dans un cadre distinct de la pile.  Après avoir quitté une fonction, son cadre est effacé.  Lorsque nous fouillons quelque chose le long du pointeur, nous transférons ces données de la pile vers le tas, d'où ces données peuvent être disponibles pour d'autres fonctions.  L'augmentation du tas crée une charge supplémentaire pour le garbage collector, dont le fonctionnement réduit la vitesse du programme de 25% en moyenne.  Lorsque vous utilisez le transfert valeur par valeur, les données restent sur la pile et aucun travail de ramasse-miettes supplémentaire n'est requis. </li></ul><br>  Lorsque vous devez penser à la sémantique du destinataire: <br><br><ul><li>  Le type de destinataire peut varier selon le sujet.  Dans l'un de ses discours, Bill Kennedy a donné un bon exemple avec le type d'utilisateur décrivant l'utilisateur.  Une fois passé par valeur, une copie sera créée pour l'utilisateur.  Cela conduira au fait que plusieurs copies d'un même utilisateur peuvent coexister dans le programme en même temps, qui peuvent ensuite être modifiées indépendamment, ce qui ne correspond pas au domaine, car l'utilisateur réel est toujours un, et il ne peut pas être décrit à différents moments par différents ensembles les données. </li><li>  Une autre façon sûre de déterminer le type de destinataire d'une méthode consiste à utiliser la méthode constructeur pour son type.  Si le constructeur retourne une valeur / un pointeur, alors lors de la création d'une entité, il est supposé qu'ils continueront à travailler avec elle en tant que valeur / pointeur.  Par conséquent, il est également préférable d'utiliser la même sémantique dans le récepteur de méthode. </li><li>  Il existe une règle non écrite, en violation de laquelle le compilateur ne jurera pas, mais votre code ne s'améliorera certainement pas.  Si l'une des méthodes de type utilise un pointeur / valeur comme récepteur, pour conserver la cohérence, les méthodes restantes doivent utiliser un pointeur / valeur.  Les méthodes de type ne doivent pas avoir de hachage de récepteurs de valeur et de pointeur. </li></ul><br><h4>  Quel est le résultat </h4><br>  Dans Go Value, la sémantique signifie copier une valeur; la sémantique du pointeur signifie donner accès à une valeur.  Cela s'applique à la fois aux arguments des méthodes et à leurs destinataires.  Pour les types intégrés, tels que les nombres, les lignes, les tranches, les cartes, les canaux et les petites structures, vous devez presque toujours utiliser le transfert basé sur la valeur.  Pour les structures qui occupent une grande quantité de mémoire et les structures dont l'état peut être indirectement modifié par leurs méthodes, vous devez utiliser le transfert par référence.  En outre, la sémantique du destinataire peut dépendre du domaine décrit par le type, de la sémantique renvoyée dans sa fabrique et de la sémantique du destinataire déjà utilisée dans d'autres méthodes de ce type. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469859/">https://habr.com/ru/post/fr469859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469835/index.html">Rêves soviétiques de l'avenir, partie 2. Maintenant avec Sepulki</a></li>
<li><a href="../fr469837/index.html">Première rencontre Flutter à Saint-Pétersbourg: reportages vidéo</a></li>
<li><a href="../fr469839/index.html">Vulnérabilité de spam dans Pikabu</a></li>
<li><a href="../fr469843/index.html">"Où sont ces jeunes punks qui nous essuieront de la surface de la terre?"</a></li>
<li><a href="../fr469855/index.html">Gradle + LLVM</a></li>
<li><a href="../fr469861/index.html">Structures de données pour les programmeurs de jeux: données en masse</a></li>
<li><a href="../fr469865/index.html">700 employés et plusieurs continents: comment Alconost a construit un modèle commercial sans officier</a></li>
<li><a href="../fr469869/index.html">Pourquoi vous devriez overclocker la RAM (c'est facile!)</a></li>
<li><a href="../fr469871/index.html">Quand les claviers étaient des tables</a></li>
<li><a href="../fr469875/index.html">Comment protéger vos mots de passe en 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>