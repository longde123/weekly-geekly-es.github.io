<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔐 🍠 👩🏾‍🤝‍👩🏻 256行裸机C ++中的可理解的RayTracing 🙅🏻 💂🏼 🎄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="256行裸机C ++中的可理解的RayTracing 


这是我简短的计算机图形学课程的另一章。 这次我们谈论的是射线追踪。 像往常一样，我尽量避免使用第三方库，因为我相信这会使学生检查引擎盖下的情况。 还要检查tinykaboom项目 。 


 网上有很多关于射线追踪的文章。 但是，问题在于几...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>256行裸机C ++中的可理解的RayTracing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477244/"><h1 id="understandable-raytracing-in-256-lines-of-bare-c">  256行裸机C ++中的可理解的RayTracing </h1><br><p>这是我<a href="https://github.com/ssloy/tinyrenderer/wiki">简短的计算机图形学课程的</a>另一章。 这次我们谈论的是射线追踪。 像往常一样，我尽量避免使用第三方库，因为我相信这会使学生检查引擎盖下的情况。 还要检查<a href="https://github.com/ssloy/tinykaboom/wiki">tinykaboom项目</a> 。 </p><br><p> 网上有很多关于射线追踪的文章。 但是，问题在于几乎所有的软件都显示了很难理解的完整软件。 以非常著名的<a href="https://www.taylorpetrick.com/blog/post/business-rt">商务卡射线追踪器</a>挑战<a href="https://www.taylorpetrick.com/blog/post/business-rt">为例</a> 。 它产生了令人印象深刻的程序，但是很难理解它是如何工作的。 除了要显示我可以进行渲染之外，我还想详细告诉您如何自己进行渲染。 </p><br><p>  <i>注意：仅查看我的代码，或仅手捧一杯茶阅读本文，这都是没有意义的。</i>  <i>本文旨在帮助您拿起键盘并实现自己的渲染引擎。</i>  <i>肯定会比我的好。</i>  <i>至少要更改编程语言！</i> </p><br><p> 因此，今天的目标是学习如何渲染此类图像： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><a name="habracut"></a><br><h1> 步骤1：将映像写入磁盘 </h1><br><p> 我不想打扰窗口管理器，鼠标/键盘处理之类的东西。 我们程序的结果将是一张保存在磁盘上的简单图片。 因此，我们需要做的第一件事就是将图片保存到磁盘。  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">在这里，</a>您可以找到允许我们执行此操作的代码。 让我列出主文件： </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br><p> 在主函数中仅调用render（），仅此而已。  render（）函数内部是什么？ 首先，我将帧缓冲区定义为Vec3f值的一维数组，它们是简单的三维向量，可为每个像素提供（r，g，b）值。 向量的类别存在于文件geometry.h中，在此不再赘述：它实际上是对二维和三维向量的琐碎操作（加法，减法，赋值，标量乘积，标量积）。 </p><br><p> 我将图像保存为<a href="https://en.wikipedia.org/wiki/Netpbm_format">ppm格式</a> 。 这是保存图像的最简单方法，尽管并非总是最方便地进一步查看图像的方法。 如果要以其他格式保存，建议您链接第三方库，例如<a href="https://github.com/nothings/stb">stb</a> 。 这是一个很棒的库：您只需在项目中包含一个头文件stb_image_write.h，它将使您能够以最流行的格式保存图像。 </p><br><p>  <b>警告：</b>我的代码充满了错误，我在上游修复了这些错误，但较早的提交受到影响。 检查<a href="https://github.com/ssloy/tinyraycaster/issues/9">此问题</a> 。 </p><br><p> 因此，此步骤的目标是确保我们可以a）在内存中创建映像+分配不同的颜色，以及b）将结果保存到磁盘。 然后，您可以在第三方软件中查看它。 结果如下： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg" alt="图片"></p><br><h1> 步骤2，关键一步：光线追踪 </h1><br><p> 这是整个链中最重要，最困难的一步。 我想在代码中定义一个球体并绘制它，而不会沉迷于材质或照明。 这就是我们的结果应如下所示： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg" alt="图片"></p><br><p> 为了方便起见，我在存储库中每步只有一个提交；  Github使得查看所做的更改非常容易。  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">例如</a> ， <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">此处</a>是第二次提交更改的内容。 </p><br><p> 首先，我们需要什么来表示计算机内存中的球体？ 四个数字就足够了：一个用于球心的三维矢量和一个描述半径的标量： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><p> 这段代码中唯一不平凡的事情是一个函数，它使您可以检查给定的射线（从orig的原点开始沿dir的方向）是否与我们的球面相交。  <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">可以在此处找到</a>有关射线-球面相交的算法的详细说明，我强烈建议您这样做并检查我的代码。 </p><br><p> 光线追踪如何工作？ 这很简单。 第一步，我们只是用渐变色填充了图片： </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><p> 现在，对于每个像素，我们将形成一条来自原点并穿过像素的射线，然后检查该射线是否与球体相交： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><p> 如果没有与球面相交，则使用color1绘制像素，否则使用color2绘制像素： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { ￼ [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } ￼ [...] }</span></span></code> </pre> <br><p> 在这一点上，我建议您拿一支铅笔在纸上检查所有的计算结果（射线-球面相交以及射线对图像的扫描）。 以防万一，我们的相机由以下因素决定： </p><br><ul><li> 图片宽度 </li><li> 图片高度 </li><li> 视场角 </li><li> 摄像头位置，Vec3f（0.0.0） </li><li> 沿z轴的负无限远方向上的视图方向 </li></ul><br><p> 让我说明一下我们如何计算要跟踪的射线的初始方向。 在主循环中，我们有以下公式： </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = (<span class="hljs-number"><span class="hljs-number">2</span></span>*(i + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>)*width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -(<span class="hljs-number"><span class="hljs-number">2</span></span>*(j + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>);</code> </pre> <br><p> 它来自哪里？ 很简单 我们的相机位于原点，并且面向-z方向。 让我来说明一下，此图从顶部显示了相机，y轴指向屏幕之外： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/5c1/b99/e005c1b996cc7eb9978bc434f6773196.png" alt="图片"></p><br><p> 如我所说，相机位于原点，场景投影在位于平面z = -1的屏幕上。 视场指定空间的哪个扇区在屏幕上可见。 在我们的图像中，屏幕为16像素宽； 可以计算世界坐标系中的长度吗？ 这很简单：让我们关注由红色，灰色和灰色虚线形成的三角形。 很容易看到tan（视场/ 2）=（屏幕宽度） <em>0.5 /（屏幕相机距离）。</em>  <em>我们将屏幕放置在距相机1的距离处，因此（屏幕宽度）= 2</em> tan（视场/ 2）。 </p><br><p> 现在让我们说，我们要通过屏幕第12个像素的中心投射一个矢量，即我们要计算蓝色矢量。 我们该怎么做？ 从屏幕左侧到蓝色矢量尖端的距离是多少？ 首先，它是12 + 0.5像素。 我们知道屏幕的16个像素对应于2 <em>tan（fov / 2）世界单位。</em>  <em>因此，向量的尖端位于</em> <em>距左边缘的</em> <em>（12 + 0.5）/ 16</em> 2 <em>tan（fov / 2）世界单位，或（12 + 0.5）</em> 2/16 * tan（fov / 2） <em>的距离</em> -屏幕与-z轴之间的交点处的棕褐色（fov / 2）。 将屏幕纵横比添加到计算中，您将确切找到射线方向的公式。 </p><br><h1> 第3步：添加更多球体 </h1><br><p> 最困难的部分已经过去，现在我们的道路已经明确。 如果我们知道如何绘制一个球体，那么添加更多球体就不会花我们很长时间。  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">检查</a>代码中<a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">的更改</a> ，这是生成的图像： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg" alt="图片"></p><br><h1> 步骤4：照明 </h1><br><p> 除了光线不足之外，图像在所有方面都是完美的。 在本文的其余部分，我们将讨论照明。 让我们添加一些点光源： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre> <br><p> 计算真实的全局照明是一项非常非常艰巨的任务，因此，像其他所有人一样，我们将通过绘制完全非物理的，但在视觉上似乎合理的结果来欺骗眼睛。 首先：为什么冬天寒冷，夏天炎热？ 因为地球表面的加热取决于太阳光线的入射角。 太阳升到地平线以上的位置越高，表面越亮。 相反，它在地平线上方越低，则越暗。 太阳升起之后，光子甚至根本无法到达我们。 </p><br><p> 返回我们的球体：我们从相机发出光线（与光子无关！），它停在一个球体上。 我们如何知道交点照明的强度？ 实际上，检查该点的法线向量与描述光的方向的向量之间的角度就足够了。 角度越小，表面照明越好。 回想一下，两个向量a和b之间的标量积等于向量范数乘以向量之间角度的余弦值的乘积：a * b = | a |  | b |  cos（alpha（a，b））。 如果我们采用单位长度的矢量，则点积将为我们提供表面照明的强度。 </p><br><p> 因此，在cast_ray函数中，我们将考虑光源的情况下返回颜色，而不是恒定的颜色： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre> <br><p> 可以进行上一步的修改，结果如下： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg" alt="图片"></p><br><h1> 步骤5：镜面照明 </h1><br><p> 点积技巧可以很好地模拟无光泽表面的照度，在文献中将其称为漫射照明。 如果要绘制有光泽的表面该怎么办？ 我想要一张这样的照片： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg" alt="图片"></p><br><p> 检查<a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">需要多少修改</a> 。 简而言之，发光表面上的光越亮，视角方向与<i>反射</i>光方向之间的夹角就越小。 </p><br><p> 这种带有哑光和发光表面照明的技巧被称为<a href="https://en.wikipedia.org/wiki/Phong_reflection_model">Phong反射模型</a> 。  Wiki对此照明模型有相当详细的描述。 最好与源代码并排阅读。 这是了解魔术的关键图片： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png" alt="图片"></p><br><h1> 第6步：阴影 </h1><br><p> 为什么我们有光却没有阴影？ 不好啦！ 我想要这张照片： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg" alt="图片"></p><br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">仅用六行代码就</a>可以实现这一点：在绘制每个点时，我们只需确保当前点和光源之间的线段不与场景对象相交即可。 如果有交叉点，我们将跳过当前光源。 只有一点点微妙之处：我沿法线方向移动该点： </p><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre> <br><p> 怎么会这样 只是我们的点位于对象的表面上，并且（数字误差除外）该点的任何光线都将与对象本身相交。 </p><br><h1> 步骤7：思考 </h1><br><p> 这太不可思议了，但是要将反射添加到渲染中，我们只需要添加三行代码： </p><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre> <br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">亲自观察：</a>与球体相交时，我们仅计算反射射线（借助于用于镜面反射高光的相同函数！），然后在反射射线的方向上递归调用cast_ray函数。 确保使用<a href="">递归深度</a> ，将其设置为4，尝试从0开始盯着不同的值，图片中会发生什么变化？ 这是我的反射和递归深度为4的结果： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg" alt="图片"></p><br><h1> 步骤8：折射 </h1><br><p> 如果我们知道要进行反射，则<a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">折射很容易</a> 。 我们需要添加一个函数来计算折射射线（ <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">使用斯涅尔定律</a> ），并在递归函数cast_ray中添加三行代码。 这是最接近的球是“玻璃制成”的结果，它同时反射和折射光： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg" alt="图片"></p><br><h1>  Steo 9：超越领域 </h1><br><p> 到目前为止，我们仅渲染球体，因为它是最简单的非平凡数学对象之一。 让我们添加一架飞机。 棋盘是经典的选择。 为此目的，添加<a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">十几行就</a>足够<a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">了</a> 。 </p><br><p> 结果如下： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><p> 如承诺的那样，该代码有256行代码， <a href="https://github.com/ssloy/tinyraytracer">请自己检查</a> ！ </p><br><h1> 步骤10：家庭作业 </h1><br><p> 我们已经走了很长一段路：我们已经学会了如何向场景添加对象，如何计算相当复杂的光照。 让我把两个作业留给您做功课。 绝对所有准备工作已经在分支<a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">homework_assignment中完成</a> 。 每次分配将需要十行代码顶部。 </p><br><h3> 作业1：环境图 </h3><br><p> 此刻，如果光线不与任何对象相交，我们只需将像素设置为恒定的背景色即可。 为何实际上是恒定的呢？ 让我们拍摄一张球形照片（文件<a href="">envmap.jpg</a> ）并将其用作背景！ 为了使生活更轻松，我将我们的项目与stb库链接在一起，以方便使用jpg格式。 它应该给我们这样的形象： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg" alt="图片"></p><br><h3> 作业2：嘎嘎嘎嘎！ </h3><br><p> 我们可以同时渲染球体和平面（请参见棋盘格）。 因此，让我们绘制三角形网格！ 我编写了一个代码，使您可以读取.obj文件，并且向其中添加了射线三角形相交函数。 现在将鸭子添加到我们的场景中应该是微不足道的： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg" alt="图片"></p><br><h1> 结论 </h1><br><p> 我的主要目标是显示有趣（容易！）的项目。 我坚信，要成为一名优秀的程序员，必须要做很多附带项目。 我不了解您，但是即使代码的复杂性相当，我个人也不会被会计软件和扫雷器所吸引。 </p><br><p> 几个小时的时间和250行代码为我们提供了raytracer。 几天内可以完成<a href="https://github.com/ssloy/tinyrenderer/wiki">五百行</a>软件光栅化程序。 图形对于学习编程真的很酷！ </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN477244/">https://habr.com/ru/post/zh-CN477244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN477230/index.html">教育软件的历史：第一款个人计算机，教育游戏和学生软件</a></li>
<li><a href="../zh-CN477234/index.html">终结电线兄弟的老鼠</a></li>
<li><a href="../zh-CN477236/index.html">美国法院允许各州恢复网络中立</a></li>
<li><a href="../zh-CN477238/index.html">加因果报应：批评了堆栈溢出的原因以及为什么许多人抱怨社区毒性</a></li>
<li><a href="../zh-CN477242/index.html">我们如何选择ServiceDesk。 第三部分</a></li>
<li><a href="../zh-CN477248/index.html">崩溃后恢复Postgres数据库的初次经验（relatton base / 16490的块4123007中的无效页面）</a></li>
<li><a href="../zh-CN477250/index.html">因此，您想在计算器上运行Windows 10吗？ 好吧</a></li>
<li><a href="../zh-CN477252/index.html">企业孵化器和加速器的发展方式：从托马斯·爱迪生（Thomas Edison）的实验室到Y组合器</a></li>
<li><a href="../zh-CN477254/index.html">XSS，CSRF和Flash身份验证。 使用r0ot-mi Web解决问题-客户端。 第二部分</a></li>
<li><a href="../zh-CN477256/index.html">明年，在联盟号运载火箭上首次正式发布OneWeb，以及在Angara运载火箭上启动</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>