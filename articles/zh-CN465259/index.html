<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎨 🧜🏻 🦉 ValueTask <TResult>-为什么，为什么以及如何？ 👔 🙌🏽 🤸🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="翻译序言 


 与科学文章不同，这类文章很难“接近文本”地翻译，因此必须进行大量改编。 因此，对于处理原始文章的文字方面的某些自由，我深表歉意。 我的目标只有一个-使翻译易于理解，即使在某些地方它与原始文章有很大出入。 对于建设性的批评以及对译文的修正/补充，我将不胜感激。 
 引言 


 Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ValueTask <TResult>-为什么，为什么以及如何？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/465259/"><h3 id="predislovie-k-perevodu">  <em>翻译序言</em> </h3><br><p>  <em>与科学文章不同，这类文章很难“接近文本”地翻译，因此必须进行大量改编。</em>  <em>因此，对于处理原始文章的文字方面的某些自由，我深表歉意。</em>  <em>我的目标只有一个-使翻译易于理解，即使在某些地方它与原始文章有很大出入。</em>  <em>对于建设性的批评以及对译文的修正/补充，我将不胜感激。</em> </p><br><h2 id="vvedenie"> 引言 </h2><br><p> <code>System.Threading.Tasks</code>命名空间和<code>Task</code>类首先是在.NET Framework 4中引入的。此后，此类型及其派生类<code>Task&lt;TResult&gt;</code>牢固地进入了.NET编程的实践，并成为异步模型的关键方面。在C＃5中实现，其<code>async/await</code> 。 在本文中，我将讨论引入新类型的<code>ValueTask/ValueTask&lt;TResult&gt;</code> ，其目的是在处理内存的开销起关键作用的情况下提高异步代码的性能。 </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/f4/7b/3c/f47b3cblzfyn77xgh1odpwfgy5i.jpeg"></a> </p><a name="habracut"></a><br><h2 id="task"> 工作任务 </h2><br><p>  <code>Task</code>多种用途，但主要目的是“承诺”-表示等待操作完成的能力的对象。 您启动操作并获取<code>Task</code> 。 操作本身完成后，将完成此<code>Task</code> 。 在这种情况下，有三个选项： </p><br><ol><li> 该操作在启动器线程中同步完成。  <em>例如，当访问一些已经在buffer中的数据时</em> 。 </li><li> 该操作是异步执行的，但是设法<em>在</em>发起方收到<code>Task</code> 。  <em>例如，当执行对尚未缓冲的数据的快速访问时</em> </li><li> 该操作是异步执行的，并<em>在</em>启动程序接收到<code>Task</code> <em>之后</em>结束<em>，</em> <em>例如通过网络接收数据</em> 。 </li></ol><br><p> 为了获得异步调用的结果，客户端可以在等待完成时阻塞调用线程，这通常与异步的概念相抵触，或者提供一种将在异步操作完成后执行的回调方法。 使用<code>Task</code>类的对象的<code>ContinueWith</code>方法显式呈现.NET 4中的回调模型，该方法接收一个委托，该委托在异步操作完成时被调用。 </p><br><pre> <code class="plaintext hljs">SomeOperationAsync().ContinueWith(task =&gt; { try { TResult result = task.Result; UseResult(result); } catch (Exception e) { HandleException(e); } });</code> </pre> <br><p> 使用.NET Frmaework 4.5和C＃5，通过引入<code>async/await</code>关键字及其背后的机制，简化了异步操作的结果。 这种机制（生成的代码）能够优化上述所有情况，即使到达目标路径也能正确处理完成。 </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p>  <code>Task</code>类非常灵活，并具有多个优点。 例如，您可以多次“期望”此类的对象，可以由任意数量的消费者竞争性地预期结果。 可以将一个类的实例存储在字典中，以用于任何数量的后续调用，其目标是将来“等待”。 所描述的方案使您可以将<code>Task</code>对象视为一种异步获取结果的缓存。 此外，如果脚本需要， <code>Task</code>还可以阻止等待线程，直到操作完成。 也有所谓的。 组合器，用于等待任务集完成的各种策略，例如“ Task.WhenAny”-异步等待许多任务中第一个任务的完成。 </p><br><p> 但是，尽管如此，最常见的用例只是启动异步操作，然后等待其执行结果。 这种简单的情况非常普遍，不需要上面的灵活性： </p><br><pre> <code class="plaintext hljs">TResult result = await SomeOperationAsync(); UseResult(result);</code> </pre> <br><p> 这与我们编写同步代码的方式非常相似（例如<code>TResult result = SomeOperation();</code> ）。 此选项自然转换为<code>async/await</code> 。 </p><br><p> 此外，尽管具有所有优点，但<code>Task</code>类型具有潜在的缺陷。  <code>Task</code>是一个类，这意味着每个创建任务实例的操作都会在堆上分配一个对象。 我们创建的对象越多，GC所需的工作就越多，垃圾回收器的工作就花费了更多的资源，这些资源可用于其他目的。 这对于代码来说是一个明显的问题，其中一方面经常创建<code>Task</code>实例，另一方面又增加了对吞吐量和性能的要求。 </p><br><p> 在许多情况下，运行时库和主库可以减轻这种影响。 例如，如果您编写以下方法： </p><br><pre> <code class="plaintext hljs">public async Task WriteAsync(byte value) { if (_bufferedCount == _buffer.Length) { await FlushAsync(); } _buffer[_bufferedCount++] = value; }</code> </pre> <br><p> 并且通常，缓冲区中将有足够的空间，操作将同步结束。 如果是这样，则返回的任务没有什么特别的，没有返回值，并且该操作已经完成。 换句话说，我们正在处理<code>Task</code> ，它等效于同步<code>void</code>操作。 在这种情况下，运行时仅缓存<code>Task</code>对象，并且每次将其用作任何<code>async Task</code>的结果-同步完成的方法（ <code>Task.ComletedTask</code> ）。 再举一个例子，假设您编写： </p><br><pre> <code class="plaintext hljs">public async Task&lt;bool&gt; MoveNextAsync() { if (_bufferedCount == 0) { await FillBuffer(); } return _bufferedCount &gt; 0; }</code> </pre> <br><p> 以同样的方式，假设大多数情况下缓冲区中有一些数据。 该方法检查<code>_bufferedCount</code> ，查看该变量大于零，然后返回<code>true</code> 。 仅在验证时未缓冲数据时，才需要异步操作。 尽管如此，只有两个可能的逻辑结果（ <code>true</code>和<code>false</code> ），以及通过<code>Task&lt;bool&gt;</code>两个可能的返回状态。 基于同步完成或异步，但在退出方法之前，运行时将缓存<code>Task&lt;bool&gt;</code>两个实例（一个表示<code>true</code> ，另一个表示<code>false</code> ），并返回所需的一个，从而避免了其他分配。 当您必须创建一个新的<code>Task&lt;bool&gt;</code>对象时，唯一的选择是异步执行，这种情况在“返回”之后结束。 在这种情况下，该方法必须创建一个新的<code>Task&lt;bool&gt;</code>对象，因为 在退出该方法时，尚不知道操作完成的结果。 返回的对象必须是唯一的，因为 它将最终存储异步操作的结果。 </p><br><p> 从运行时还有其他类似的缓存示例。 但是，这种策略并非在所有地方都适用。 例如，方法： </p><br><pre> <code class="plaintext hljs">public async Task&lt;int&gt; ReadNextByteAsync() { if (_bufferedCount == 0) { await FillBuffer(); } if (_bufferedCount == 0) { return -1; } _bufferedCount--; return _buffer[_position++]; }</code> </pre> <br><p> 也经常同步结束。 但是，与前面的示例不同，此方法返回的整数结果大约有40亿个可能值。 要缓存<code>Task&lt;int&gt;</code> ，在这种情况下，将需要数百GB的内存。 此处的环境还支持<code>Task&lt;int&gt;</code>的小型缓存，其中包含几个较小的值。 因此，例如，如果操作同步完成（缓冲区中存在数据），结果为4，则将使用缓存。 但是，如果结果是同步的，但完成是42，则将创建一个新的<code>Task&lt;int&gt;</code>对象，类似于调用<code>Task.FromResult(42)</code> 。 </p><br><p> 许多库实现都尝试通过支持自己的缓存来缓解这些情况。 一个示例是<code>MemoryStream.ReadAsync</code>的重载。  .NET Framework 4.5中引入的此操作始终同步结束，因为 这只是从内存中读取。  <code>ReadAsync</code>返回一个<code>Task&lt;int&gt;</code> ，其中整数结果表示读取的字节数。 在代码中，经常在循环中使用<code>ReadAsync</code>时发生这种情况。 此外，是否存在以下症状： </p><br><ul><li> 在循环的大多数迭代中，请求的字节数不会改变。 </li><li> 在大多数迭代中， <code>ReadAsync</code>可以读取请求的字节数。 </li></ul><br><p> 也就是说，对于重复调用， <code>ReadAsync</code>同步运行并返回<code>Task&lt;int&gt;</code>对象， <code>ReadAsync</code>迭代的结果相同。 从逻辑<code>MemoryStream</code> ， <code>MemoryStream</code>缓存上一个成功完成的任务，对于所有后续调用，如果新结果与上一个匹配，则从缓存中返回一个实例。 如果结果不匹配，则使用<code>Task.FromResult</code>创建一个新实例，该实例又将在返回之前进行缓存。 </p><br><p> 但是，尽管如此，在许多情况下，即使同步完成，也必须强制操作创建新的<code>Task&lt;TResult&gt;</code>对象。 </p><br><h2 id="valuetasktresult-i-sinhronnoe-zavershenie">  ValueTask &lt;TResult&gt;和同步完成 </h2><br><p> 最终，所有这些都是将新型<code>ValueTask&lt;TResult&gt;</code>引入.NET Core 2.0的动机。 同样，通过nuget包<code>System.Threading.Tasks.Extensions</code> ，其他.NET版本中也提供了此类型。 </p><br><p>  .NET Core 2.0中引入<code>ValueTask&lt;TResult&gt;</code>作为能够包装<code>TResult</code>或<code>Task&lt;TResult&gt;</code> 。 这意味着可以从<code>async</code>方法返回此类型的对象。 这种类型的引入的第一个<code>ValueTask&lt;TResult&gt;</code>是立即可见的：如果该方法成功且同步完成，则无需在堆上创建任何内容，只需创建一个带有结果值的<code>ValueTask&lt;TResult&gt;</code>实例<code>ValueTask&lt;TResult&gt;</code> 。 仅当方法异步退出时，我们才需要创建<code>Task&lt;TResult&gt;</code> 。 在这种情况下， <code>ValueTask&lt;TResult&gt;</code>用作<code>Task&lt;TResult&gt;</code>的包装。  <code>ValueTask&lt;TResult&gt;</code>优化目的，决定使<code>ValueTask&lt;TResult&gt;</code>能够聚合<code>Task&lt;TResult&gt;</code> ：在成功和失败的情况下，异步方法创建<code>Task&lt;TResult&gt;</code> ，从内存优化的角度来看，最好聚合<code>Task&lt;TResult&gt;</code>对象本身<code>Task&lt;TResult&gt;</code> ，以便在<code>ValueTask&lt;TResult&gt;</code>保留其他字段以用于各种完成情况（例如，存储异常）。 </p><br><p> 鉴于以上所述，不再需要在诸如上述<code>MemoryStream.ReadAsync</code>方法中进行缓存，而是可以按以下方式实现： </p><br><pre> <code class="plaintext hljs">public override ValueTask&lt;int&gt; ReadAsync(byte[] buffer, int offset, int count) { try { int bytesRead = Read(buffer, offset, count); return new ValueTask&lt;int&gt;(bytesRead); } catch (Exception e) { return new ValueTask&lt;int&gt;(Task.FromException&lt;int&gt;(e)); } }</code> </pre> <br><h2 id="valuetasklttresultgt-i-asinhronnoe-zavershenie">  ValueTask &lt;TResult&gt;和异步终止 </h2><br><p> 能够编写不需要为结果分配额外内存的异步方法，并具有同步完成功能，这确实是一大优势。 如上所述，这是在.NET Core 2.0中引入新的<code>ValueTask&lt;TResult&gt;</code>的主要目标。 现在，预期将在“热道路”上使用的所有新方法都将使用<code>ValueTask&lt;TResult&gt;</code>而不是<code>Task&lt;TResult&gt;</code>作为返回类型。 例如，.NET Core 2.1（使用<code>Memory&lt;byte&gt;</code>而不是<code>byte[]</code>作为参数）中<code>Stream</code>的<code>ReadAsync</code>方法的新重载返回<code>ValueTask&lt;int&gt;</code>的实例。 这样可以大大减少使用流时的分配数量（通常， <code>ReadAsync</code>方法是同步完成的，例如<code>MemoryStream</code>的示例）。 </p><br><p> 但是，当开发具有高带宽的服务时，异步终止并不少见，我们需要尽力避免额外的分配。 </p><br><p> 如前所述，在<code>async/await</code>模型中，任何异步完成的操作都必须返回唯一的对象才能等待完成。 独特是因为 它将用作执行回调的渠道。 但是请注意，此构造并未说明在异步操作完成之后是否可以<em>重用</em>返回的等待对象。 如果可以重用对象，则API可以为这些类型的对象维护一个池。 但是，在这种情况下，此池无法支持并发访问-池中的对象将从“已完成”状态变为“未完成”状态，反之亦然。 </p><br><p> 为了支持使用此类池的可能性，在.NET Core 2.1中添加了<code>IValueTaskSource&lt;TResult&gt;</code>接口，并扩展了<code>ValueTask&lt;TResult&gt;</code>结构：现在，这种类型的对象不仅可以包装<code>TResult</code>或<code>Task&lt;TResult&gt;</code>对象，还可以包装<code>IValueTaskSource&lt;TResult&gt;</code>实例。 新接口提供了基本功能，允许<code>ValueTask&lt;TResult&gt;</code>对象以与<code>IValueTaskSource&lt;TResult&gt;</code>相同的方式与<code>IValueTaskSource&lt;TResult&gt;</code>一起<code>Task&lt;TResult&gt;</code> ： </p><br><pre> <code class="plaintext hljs">public interface IValueTaskSource&lt;out TResult&gt; { ValueTaskSourceStatus GetStatus(short token); void OnCompleted( Action&lt;object&gt; continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags); TResult GetResult(short token); }</code> </pre> <br><p>  <code>GetStatus</code>旨在在<code>ValueTask&lt;TResult&gt;.IsCompleted/IsCompletedSuccessfully</code> -允许您确定操作是否已完成（成功）。 在<code>ValueTask&lt;TResult&gt;</code>使用<code>ValueTask&lt;TResult&gt;</code>触发回调。  <code>GetResult</code>用于获取结果或引发异常。 </p><br><p> 大多数开发人员不太可能需要处理<code>IValueTaskSource&lt;TResult&gt;</code>接口，因为 异步方法返回时，将其隐藏在<code>ValueTask&lt;TResult&gt;</code>实例后面。 接口本身主要是为那些开发高性能API的人设计的，旨在避免不必要的工作。 </p><br><p> 在.NET Core 2.1中，有几种此类API的示例。 其中最著名的是<code>Socket.ReceiveAsync</code>和<code>Socket.SendAsync</code>方法的新重载。 例如： </p><br><pre> <code class="plaintext hljs">public ValueTask&lt;int&gt; ReceiveAsync( Memory&lt;byte&gt; buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default);</code> </pre> <br><p>  <code>ValueTask&lt;int&gt;</code>类型的对象用作返回值。 <br> 如果该方法同步退出，则它将返回带有相应值的<code>ValueTask&lt;int&gt;</code> ： </p><br><pre> <code class="plaintext hljs">int result = …; return new ValueTask&lt;int&gt;(result);</code> </pre> <br><p> 如果操作异步完成，则使用一个缓存对象，该对象实现<code>IValueTaskSource&lt;TResult&gt;</code>接口： </p><br><pre> <code class="plaintext hljs">IValueTaskSource&lt;int&gt; vts = …; return new ValueTask&lt;int&gt;(vts);</code> </pre> <br><p>  <code>Socket</code>实现支持一个缓存的对象用于接收，而一个缓存的对象用于发送数据，只要每个对象在没有竞争的情况下使用（例如，没有竞争性的数据发送）。 即使在异步执行的情况下，该策略也会减少分配的额外内存量。 <br> 描述的.NET Core 2.1中的<code>Socket</code>优化对<code>NetworkStream</code>的性能产生了积极影响。 它的重载是<code>Stream</code>类的<code>ReadAsync</code>方法： </p><br><pre> <code class="plaintext hljs">public virtual ValueTask&lt;int&gt; ReadAsync( Memory&lt;byte&gt; buffer, CancellationToken cancellationToken);</code> </pre> <br><p> 只是将工作委托给<code>Socket.ReceiveAsync</code>方法。 就使用内存而言，提高套接字方法的效率可以提高<code>NetworkStream</code>方法的效率。 </p><br><h2 id="non-generic-valuetask"> 非通用ValueTask </h2><br><p> 早些时候，我多次提到.NET Core 2.0中<code>ValueTask&lt;T&gt;</code>的最初目标是优化具有“非空”结果的方法的同步完成情况。 这意味着不需要非类型的<code>ValueTask</code> ：在同步完成的情况下，方法通过<code>Task.CompletedTask</code>属性使用单例，并且还隐式接收<code>async Task</code>方法的运行时。 </p><br><p> 但是，随着避免不必要分配的能力的出现以及异步执行的出现，对非类型化<code>ValueTask</code>再次变得重要起来。 因此，在.NET Core 2.1中，我们引入了<code>ValueTask</code>和<code>IValueTaskSource</code> 。 它们是对应泛型类型的类似物，并且以相同的方式使用，但是用于返回空（ <code>void</code> ）的方法。 </p><br><h2 id="realizaciya-ivaluetasksource--ivaluetasksourcelttgt"> 实施IValueTaskSource / IValueTaskSource &lt;T&gt; </h2><br><p> 大多数开发人员将不需要实现这些接口。 而且要实现它们并非易事。 如果您决定需要自己实现它们，那么在.NET Core 2.1内，可以作为示例的几种实现： </p><br><ul><li>  <a href="">AwaitableSocketAsyncEventArgs</a> </li><li>  <a href="">AsyncOperation &lt;TResult&gt;</a> </li><li>  <a href="">DefaultPipeReader</a> </li></ul><br><p> 为了简化这些任务（ <code>IValueTaskSource / IValueTaskSource&lt;T&gt;</code> ），我们计划在.NET Core 3.0中引入类型<code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code> 。 这种结构将封装所有必要的逻辑。  <code>ManualResetValueTaskSourceCore&lt;TResult&gt;</code>实例可以在实现<code>IValueTaskSource&lt;TResult&gt;</code>和/或<code>IValueTaskSource</code>另一个对象中使用，并将大部分工作委托给它。 您可以在ttps上了解有关此的更多信息：//github.com/dotnet/corefx/issues/32664。 </p><br><h2 id="pravilnaya-model-ispolzovaniya-valuetasks"> 使用ValueTasks的正确模型 </h2><br><p> 甚至粗略地检查也<code>ValueTask</code>和<code>ValueTask&lt;TResult&gt;</code>比<code>Task</code>和<code>Task&lt;TResult&gt;</code> <code>ValueTask&lt;TResult&gt;</code>更多的限制。 这是正常的，甚至是可取的，因为它们的主要目标是等待异步执行完成。 </p><br><p> 尤其是，由于<code>ValueTask</code>和<code>ValueTask&lt;TResult&gt;</code>可以聚合可重用对象的事实而产生了明显的限制。 通常， <em>在使用</em> <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> * <em>时，绝不要执行</em>以下操作* <em>（</em>让我通过“ Never” *重新制定）： </p><br><ul><li>  <strong>切勿重复使用同一<code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>对象</strong> </li></ul><br><p>  <em>动机：</em> <code>Task</code>和<code>Task&lt;TResult&gt;</code>实例永远不会从“已完成”状态变为“未完成”状态，我们可以根据需要多次使用它们等待结果-完成后，我们将始终获得相同的结果。 相反，由于<code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ，它们可以充当重用对象的包装器，这意味着它们的状态可以更改，因为 重用对象的状态根据定义发生了变化-从“完成”变为“未完成”，反之亦然。 </p><br><ul><li>  <strong>&lt;从不<code>ValueTask</code> / <code>ValueTask&amp;lt;TResult&amp;gt;</code></strong>  <strong>在竞争模式下。</strong> </li></ul><br><p>  <em>动机：一个</em>包装的对象希望一次只能从一个使用者使用一个回调，并且试图竞争竞争很容易导致竞争状况和细微的编程错误。 竞争期望，这是上述<strong>多重期望中</strong>描述的选项之一。 请注意， <code>Task</code> / <code>Task&lt;TResult&gt;</code>允许任何数量的竞争期望。 </p><br><ul><li>  <strong>在操作完成之前，切勿使用<code>.GetAwaiter().GetResult()</code></strong> 。 </li></ul><br><p>  <em>动机：</em>在操作完成之前， <code>IValueTaskSource</code> / <code>IValueTaskSource&lt;TResult&gt;</code>不应支持锁定。 实际上，阻塞会导致竞争状况，这不太可能是消费者方面的预期行为。 使用<code>Task</code> / <code>Task&lt;TResult&gt;</code>可以执行此操作，从而阻塞调用线程，直到操作完成。 </p><br><p> 但是，如果您仍然需要执行上述操作之一，并且被调用的方法返回<code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>实例， <code>ValueTask</code>怎么办？ 对于这种情况， <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>提供了<code>.AsTask()</code>方法。 通过调用此方法，您将获得<code>Task</code> / <code>Task&lt;TResult&gt;</code>的实例，并且您已经可以对其执行必要的操作。  <em>不允许</em>在调用<code>.AsTask()</code>之后重用原始对象。 </p><br><p> <strong>  </strong> : <em>    <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,   ( <code>await</code> )   (,    <code>.ConfigureAwait(false)</code> ),   <code>.AsTask()</code> ,        <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> .</em> </p><br><pre> <code class="plaintext hljs">// Given this ValueTask&lt;int&gt;-returning method… public ValueTask&lt;int&gt; SomeValueTaskReturningMethodAsync(); … // GOOD int result = await SomeValueTaskReturningMethodAsync(); // GOOD int result = await SomeValueTaskReturningMethodAsync().ConfigureAwait(false); // GOOD Task&lt;int&gt; t = SomeValueTaskReturningMethodAsync().AsTask(); // WARNING ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); ... // storing the instance into a local makes it much more likely it'll be misused, // but it could still be ok // BAD: awaits multiple times ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = await vt; int result2 = await vt; // BAD: awaits concurrently (and, by definition then, multiple times) ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); Task.Run(async () =&gt; await vt); Task.Run(async () =&gt; await vt); // BAD: uses GetAwaiter().GetResult() when it's not known to be done ValueTask&lt;int&gt; vt = SomeValueTaskReturningMethodAsync(); int result = vt.GetAwaiter().GetResult();</code> </pre> <br><p>    , "",  ,       (    ,      ). </p><br><p>   <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>  ,       .  ,  <code>IsCompleted</code>  <code>true</code> ,    (   ,  ),    — <code>false</code> ,  <code>IsCompletedSuccessfully</code>  <code>true</code>     .   " " ,   , ,    ,    ,    .            <code>await</code> / <code>.AsTask()</code>     <code>.Result</code> .  ,   <code>SocketsHttpHandler</code>  .NET Core 2.1,     <code>.ReadAsync</code> ,   <code>ValueTask&lt;int&gt;</code> .    ,       , ,  .      ,         ..   . 因为    ,     , ,  ,    : </p><br><pre> <code class="plaintext hljs">int bytesRead; { ValueTask&lt;int&gt; readTask = _connection.ReadAsync(buffer); if (readTask.IsCompletedSuccessfully) { bytesRead = readTask.Result; } else { using (_connection.RegisterCancellation()) { bytesRead = await readTask; } } }</code> </pre> <br><p>    , .. <code>ValueTask&lt;int&gt;</code> ,     <code>.Result</code> ,    <code>await</code> ,     . </p><br><h2 id="dolzhny-li-vse-novye-asinhronnye-api-vozvraschat-valuetask--valuetasklttresultgt">      API  ValueTask / ValueTask&lt;TResult&gt;? </h2><br><p>  ,  .      <code>Task</code> / <code>ValueTask&lt;TResult&gt;</code> . </p><br><p>    ,   <code>Task</code> / <code>Task&lt;TResult&gt;</code>     .   ,       ""  / ,    <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,      <code>ValueTask&lt;TResult&gt;</code>  <code>Task&lt;TResult&gt;</code> : ,   ,  <code>await</code>     <code>Task&lt;TResult&gt;</code>   <code>ValueTask&lt;TResult&gt;</code> .  ,       (,  API  <code>Task</code>  <code>Task&lt;bool&gt;</code> ), ,    ,   <code>Task</code> ( <code>Task&lt;bool&gt;</code> ).  , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>    .  ,    async-,              <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,       . </p><br><p>     , <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code>   , : </p><br><ol><li>  ,    API    , </li><li>  API        ,  </li><li>   ,      ,         ,    . </li></ol><br><p>  ,     <code>abstract</code> / <code>virtual</code>  ,    ,           /  ? </p><br><h2 id="chto-dalshe"> 接下来是什么？ </h2><br><p>    .NET,     API,  <code>Task</code> / <code>Task&lt;TResult&gt;</code> . ,  ,     API c <code>ValueTask</code> / <code>ValueTask&lt;TResult&gt;</code> ,     .         <code>IAsyncEnumerator&lt;T&gt;</code> ,      .NET Core 3.0.  <code>IEnumerator&lt;T&gt;</code>   <code>MoveNext</code> ,    .   — <code>IAsyncEnumerator&lt;T&gt;</code>   <code>MoveNextAsync</code> .      ,        <code>Task&lt;bool&gt;</code> ,        ,    .  ,       ,       ,      (        ),   ,   ,         <code>await foreach</code> -,  ,      <code>MoveNextAsync</code> ,  <code>ValueTask&lt;bool&gt;</code> .         , ,   ,     " " ,         . ,  C#      ,           . </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN465259/">https://habr.com/ru/post/zh-CN465259/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN465247/index.html">角度的 了解@ Input，@ Output和EventEmitter</a></li>
<li><a href="../zh-CN465249/index.html">理查德·斯托曼（Richard Stallman）在莫斯科工业大学的演讲。 2019年八月</a></li>
<li><a href="../zh-CN465251/index.html">夏天快结束了。 几乎没有数据泄漏</a></li>
<li><a href="../zh-CN465255/index.html">使用HttpClientFactory的.Net Core WCF连接池实现</a></li>
<li><a href="../zh-CN465257/index.html">“当心，FAS！”：麦当劳的诡计，神圣的沙威玛，虚假的克鲁尼和一些街头魔术</a></li>
<li><a href="../zh-CN465261/index.html">宏的魔力，或如何使AVR汇编程序程序员的工作更轻松</a></li>
<li><a href="../zh-CN465263/index.html">在PostgreSQL中锁定：3.锁定其他对象</a></li>
<li><a href="../zh-CN465267/index.html">打字稿 表达魔术</a></li>
<li><a href="../zh-CN465269/index.html">培训Cisco 200-125 CCNA v3.0。 第26天。DNS和DHCP</a></li>
<li><a href="../zh-CN465271/index.html">黑客通过送餐和酒店预订服务来窃取和洗钱。</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>