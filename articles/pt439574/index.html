<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∞üèø ü§ûüèæ üë∞üèΩ Protocolo SmartCard I2C. Comandos do Exchange APDU via interface I2C üßñüèæ üê¢ üöì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 H√° algum tempo, participei do desenvolvimento de um dispositivo no qual era necess√°rio implementar a criptografia russa. Como no futur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protocolo SmartCard I2C. Comandos do Exchange APDU via interface I2C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439574/"><h2>  1. Introdu√ß√£o </h2><br>  H√° algum tempo, participei do desenvolvimento de um dispositivo no qual era necess√°rio implementar a criptografia russa.  Como no futuro deveria certificar essa decis√£o, alguns requisitos foram apresentados para a implementa√ß√£o da criptografia.  E como uma das op√ß√µes para simplificar a implementa√ß√£o desses requisitos, consideramos a possibilidade de integrar um leitor de cart√£o inteligente ao dispositivo ou instalar um chip de cart√£o inteligente, no qual muitos cen√°rios necess√°rios para trabalhar com informa√ß√µes importantes j√° foram implementados. <br><br>  Infelizmente, essa solu√ß√£o n√£o se encaixou por algum motivo, embora se fosse poss√≠vel usar a criptografia de hardware russa j√° preparada, isso aceleraria significativamente o desenvolvimento e a subsequente certifica√ß√£o do produto final.  E as raz√µes para a impossibilidade de usar tokens USB ou cart√µes inteligentes eram muito comuns: o dispositivo deveria ser bastante compacto (um pequeno m√≥dulo para dispositivos M2M ou IoT), operado principalmente no modo sem manuten√ß√£o e funcionando em uma ampla faixa de temperatura. <br><br>  Neste artigo, quero falar sobre uma poss√≠vel solu√ß√£o para esse caso usando o chip A7001, que est√° conectado ao sistema atrav√©s da interface I2C. <br><br><img src="https://habrastorage.org/webt/e5/bw/lh/e5bwlh2fhtuxpwj7cdmmt7ujtjc.png"><br><a name="habracut"></a><br><h2>  Problemas de implementa√ß√£o de criptografia no PAC </h2><br>  N√£o quero me debru√ßar sobre os problemas da certifica√ß√£o de criptografia.  Quem trabalha com isso est√° ciente disso, mas o resto parece n√£o precisar.  Mas sobre alguns pontos importantes ainda vale a pena dizer. <br><br>  Em teoria, n√£o deve haver problemas especiais com criptografia.  Afinal, √© suficiente usar uma das bibliotecas criptogr√°ficas, por exemplo, OpenSSL ou qualquer outra dentre muitas existentes. <br><br>  Os problemas come√ßam quando √© necess√°rio que esta solu√ß√£o seja certificada.  E a implementa√ß√£o puramente de software de criptografia no firmware transforma o dispositivo em um dispositivo de prote√ß√£o de informa√ß√µes criptogr√°ficas completas, exigindo um estudo minucioso em um laborat√≥rio de testes.  Afinal, ao desenvolver uma solu√ß√£o usando criptografia, mais cedo ou mais tarde voc√™ ter√° que pensar em coisas como um esquema de chaves, armazenamento de chaves, gera√ß√£o de n√∫meros aleat√≥rios e outros assuntos sutis. <br><br>  Existe um m√©todo elegante para implementar algoritmos criptogr√°ficos russos certificados para algumas solu√ß√µes, o que nos permite simplificar levemente o processo de cria√ß√£o de dispositivos finais e reduzir o tempo para seu desenvolvimento e subsequente certifica√ß√£o.  √â suficiente incorporar um cart√£o inteligente ou chip de cart√£o inteligente no dispositivo, usando-o como uma esp√©cie de "raiz de confian√ßa" e, assim, resolver um n√∫mero significativo de quest√µes dolorosas que exigem longa pesquisa e confirma√ß√£o em laborat√≥rios de teste. <br><br><img src="https://habrastorage.org/webt/e2/iq/6i/e2iq6i49c7ber2rkbgu6sv8fl3u.png"><br><br><h2>  Microcontrolador de cart√£o inteligente com interface I2C </h2><br>  Para escrever este artigo, usei o chip A7001, que se conecta ao dispositivo final via barramento I2C, dispon√≠vel em praticamente qualquer dispositivo.  O chip foi fornecido pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aladdin RD</a> , que j√° possui firmware instalado que suporta criptografia russa. <br><br>  O microcontrolador A7001AG (microcontrolador de autentica√ß√£o segura) √© fabricado pela NXP.  De acordo com a folha de dados do chip, o <b>A7001AG</b> √© um microcontrolador protegido contra acesso n√£o autorizado, com base na arquitetura cl√°ssica 80C51, com um coprocessador criptogr√°fico. <br><br>  No modo de economia de energia, o microcontrolador consome 50 ŒºA.  Ele suporta tens√£o de alimenta√ß√£o na faixa de 1,62V a 5,5V e pode ser operado em temperaturas de -25 ¬∞ C a + 85 ¬∞ C. <br><br>  Para interagir com dispositivos externos, a interface escrava I2C √© usada com uma velocidade de at√© 100 kbit / s. <br><br>  O microcontrolador est√° dispon√≠vel em v√°rias op√ß√µes de caixa.  Acabei no formato HVQFN32.  Trata-se de uma caixa de pl√°stico medindo 5x5x0,85 mm com 32 contatos e um passo de 0,5 mm. <br><br>  Apar√™ncia do processo: <br><br><img src="https://habrastorage.org/webt/tn/7r/mz/tn7rmzk8pbzw1ezupbdv7fxvqhm.png"><br><br>  Sua pinagem: <br><br><img src="https://habrastorage.org/webt/tr/bo/5r/trbo5rlj2_q0v-lxbs7wbqevlu0.png"><br><br><h2>  Sistema host para conectar o chip A7001 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A placa ESP32 WiFi Kit 32 da Heltec</a> foi tomada como o layout do sistema host com a interface I2C.  Custa menos de 1000 rublos, possui todas as interfaces com e sem fio necess√°rias, h√° um conector para conectar uma bateria de l√≠tio com um circuito de carregamento, al√©m de um display OLED de 0,96 polegadas. <br><br><img src="https://habrastorage.org/webt/uf/kq/li/ufkqlihfpi9w0692rq8junv0ybo.jpeg"><br><br>  Um sistema quase perfeito para a cria√ß√£o de prot√≥tipos de v√°rios dispositivos IoT e M2M, com os quais eu sempre quis brincar. <br><br>  A placa pode ser programada no ambiente de desenvolvimento nativo e no IDE do Arduino.  Existem muitos exemplos para trabalhar com ele.  Para simplificar, optei pelo IDE padr√£o do Arduino. <br><br><h2>  Diagrama de circuito </h2><br>  O diagrama do circuito para conectar o chip A7001 √© mostrado na figura.  <s>√â um pouco diferente da folha de dados recomendada.</s>  <s>De acordo com a descri√ß√£o do fabricante, o terminal 22 (sinal de redefini√ß√£o RST_N) deve ter alto potencial, mas o circuito n√£o foi iniciado de acordo com este esquema.</s>  <s>Como resultado do ‚Äúpux√£o cient√≠fico‚Äù, a operabilidade foi alcan√ßada conectando um resistor pull-up R4 ao condutor de pot√™ncia negativo.</s> <br><br>  <i>ATUALIZA√á√ÉO: Conforme sugerido nos coment√°rios, o esquema corresponde √† folha de dados, enquanto a descri√ß√£o da sa√≠da me confundiu</i> <blockquote>  RST_N - Redefinir entrada, <b>ativo BAIXO</b> </blockquote><br><br><img src="https://habrastorage.org/webt/ud/l3/nd/udl3nd7nz2ck8gtwkb3dhdudzqy.png"><br><br>  O circuito √© montado em uma pequena placa de ensaio.  Os sinais de energia e I2C s√£o conectados por quatro fios de conex√£o, e o pr√≥prio m√≥dulo ESP32 √© conectado ao computador via USB para receber energia de todo o circuito e preencher o firmware. <br><br><img src="https://habrastorage.org/webt/de/xz/w1/dexzw1kvlnoixvk0ko-9svuvkbg.png"><br><br><h2>  Protocolo I2C do cart√£o inteligente </h2><br>  Quando ouvi falar pela primeira vez sobre como conectar microcontroladores de cart√£o inteligente por meio do barramento I2C, eles me explicaram que a camada f√≠sica da interface do cart√£o inteligente (GOST R ISO / IEC 7816-3-2013) foi substitu√≠da por I2C (SMBus) e tudo funcionou normalmente. cart√µes inteligentes de acordo com GOST R ISO / IEC 7816-4-2013 usando comandos APDU. <br><br>  Descobriu-se que isso n√£o √© bem verdade, ou melhor, n√£o existe.  A intera√ß√£o com o microcontrolador em um n√≠vel alto ocorre usando os comandos APDU convencionais, mas tamb√©m existem alguns "buts". <br><br><ol><li>  A interface I2C (SMBus) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ru.wikipedia.org/wiki/I%C2%B2C</a> √© um barramento com endere√ßamento escravo, fundamentalmente diferente da interface UART serial, projetada para comunicar dois dispositivos ponto a ponto e n√£o usar endere√ßamento .  Isso significa que todos os dados transmitidos (comandos APDU) devem ser "compactados" no formato de dados do barramento I2C. </li><li>  O trabalho com um cart√£o inteligente come√ßa com sua redefini√ß√£o, geralmente desligando a alimenta√ß√£o, por exemplo, removendo fisicamente o cart√£o do leitor de cart√£o.  Ap√≥s a redefini√ß√£o, o cart√£o inteligente envia primeiro o bloco de dados ATR (Answer To Reset), que cont√©m as informa√ß√µes de configura√ß√£o necess√°rias para configurar a intera√ß√£o com o cart√£o inteligente. <br>  E o chip no barramento I2C n√£o √© uma exce√ß√£o, mas no caso em que o microcontrolador deve ser soldado √† placa de circuito impresso, ele pode n√£o ter um circuito de fonte de alimenta√ß√£o do microcircuito ou controle de software da sa√≠da de redefini√ß√£o.  Portanto, a redefini√ß√£o do chip √© implementada, incluindo, no n√≠vel dos comandos do protocolo I2C. </li></ol><br>  Esses e outros problemas s√£o resolvidos pelo Protocolo Smart Card I2C, cuja descri√ß√£o pode ser encontrada no site do NXP em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.nxp.com/docs/en/supporting-information/AN12207.pdf</a> . <br><br><h2>  Parte do software </h2><br>  Uma pesquisa na biblioteca com a implementa√ß√£o do <i>protocolo Smart Card I2C Protocol</i> n√£o retornou nenhum resultado.  Portanto, eu tive que entender as especifica√ß√µes e fazer a implementa√ß√£o das fun√ß√µes b√°sicas do que estava √† m√£o. <br><br><div class="spoiler">  <b class="spoiler_title">Fontes de esbo√ßo para o IDE do Arduino</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Wire.h&gt; #include &lt;vector&gt; // I2C address on chip A7001 #define ADDR_A7001 static_cast&lt;uint16_t&gt;(0x48) using namespace std; typedef std::vector&lt;uint8_t&gt; vect; //-------------------------------------------------------------------------- // Output dump data by serial port void vect_dump(const char * prefix, const vect &amp; v, const size_t start = 0, const size_t count = 0) { if(prefix) { Serial.print(prefix); } if(v.size() &lt; start) { Serial.println("Empty"); return; } for(size_t i=0; i &lt; (v.size()-start) &amp;&amp; (count == 0 || i &lt; count); i++) { uint8_t b = v[start + i]; // Format output HEX data if(i) Serial.print(" "); if(b &lt; 0x0F) Serial.print("0"); Serial.print(b, HEX); } Serial.println(""); } //-------------------------------------------------------------------------- // Send array bytes by I2C to address A7001 and read response result_size bytes vect sci2c_exchange(const vect data, const uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(data.data(), data.size()); Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); //delay(1); vect result(result_size, 0); if(result_size &gt;= 2) { result[0] = Wire.read(); // Data size CDB result[1] = Wire.read(); // PCB for(size_t i=2; i&lt;result.size()-2 &amp;&amp; Wire.available(); i++) { result[i+2] = Wire.read(); } } return result; } //-------------------------------------------------------------------------- // Read Status Code uint8_t sci2c_status(const char * msg = nullptr) { vect v = sci2c_exchange({0b0111}, 2); uint8_t status = v[1] &gt;&gt; 4; if(msg) { Serial.print(msg); // Prefix switch(status) { case 0b0000: Serial.println("OK (Ready)"); break; case 0b0001: Serial.println("OK (Busy)"); break; case 0b1000: Serial.println("ERROR (Exception raised)"); break; case 0b1001: Serial.println("ERROR (Over clocking)"); break; case 0b1010: Serial.println("ERROR (Unexpected Sequence)"); break; case 0b1011: Serial.println("ERROR (Invalid Data Length)"); break; case 0b1100: Serial.println("ERROR (Unexpected Command)"); break; case 0b1101: Serial.println("ERROR (Invalid EDC)"); break; default: Serial.print("ERROR (Other Exception "); Serial.print(status, BIN); Serial.println("b)"); break; } } return status; } static uint8_t apdu_master_sequence_counter = 0; // Sequence Counter Master, Master to Slave //-------------------------------------------------------------------------- // Send APDU void sci2c_apdu_send(const vect apdu) { vect_dump("C-APDU =&gt; ", apdu); vect data(2, 0); // 0x00 - Master to Slave Data Transmission command + reserve to length data.insert(data.end(), std::begin(apdu), std::end(apdu)); data[0] |= (apdu_master_sequence_counter &lt;&lt; 4); if(++apdu_master_sequence_counter &gt; 0b111) { apdu_master_sequence_counter = 0; } data[1] = data.size() - 2; sci2c_exchange(data, 2); delay(10); sci2c_status(""); } //-------------------------------------------------------------------------- // Receive APDU vect sci2c_apdu_recv(uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(0b0010); // 0010b - Slave to Master Data Transmission command Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); vect result(result_size, 0); for(size_t i=0; i&lt;result.size() &amp;&amp; Wire.available(); i++) { result[i] = Wire.read(); } vect_dump("R-APDU &lt;= ", result); return result; } //-------------------------------------------------------------------------- void setup(){ Wire.begin(); Serial.begin(9600); while (!Serial); Serial.println(""); Serial.println("Smart Card I2C Protocol Arduino demo on A7001"); Serial.println(""); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); // Soft Reset sci2c_exchange({0b00011111}, 2); //The bits b0 to b5 set to 011111b indicate the Soft Reset command. delay(5); // Wait at least tRSTG (time, ReSeT Guard) sci2c_status("Status SoftReset: "); // Read ATR vect ATR = sci2c_exchange({0b101111}, 29+2); //The bits b0 to b5 set to 101111b indicate the Read Answer to Reset command. sci2c_status("Status ATR: "); vect_dump("ATR: ", ATR, 2); // Parameter Exchange // The bits b0 to b5 set to 111111b of the PCB send by the master device indicate the Parameter Exchange command. // The bits b6 and b7 of the PCB send by the master device code the CDBIsm,max(Command Data Bytes Integer, Slave to Master, MAXimum) vect CDB = sci2c_exchange({0b11111111}, 2); sci2c_status("Status CDB: "); vect_dump("CDB: ", CDB, 1); // Further examples of the exchange of APDU // Exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); // Read Card Production Life Cycle sci2c_apdu_send({0x80, 0xCA, 0x9F, 0x7F, 0x00}); sci2c_status("Status card LC send: "); sci2c_apdu_recv(0x30+1); // R-APDU size + 1 byte PBC sci2c_status("Status card LC recv: "); // Read Card Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0x66, 0x00}); sci2c_status("Status card info send: "); sci2c_apdu_recv(0x51+1); // R-APDU size + 1 byte PBC sci2c_status("Status card info recv: "); // Read Key Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0xE0, 0x00}); sci2c_status("Status key send: "); sci2c_apdu_recv(0x17+1); // R-APDU size + 1 byte PBC sci2c_status("Status key recv: "); // Again exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); Serial.println("Done!\n"); } //-------------------------------------------------------------------------- void loop() { delay(100); }</span></span></span></span></code> </pre> <br></div></div><br>  Para trabalhar com a porta I2C, usei a biblioteca Wire padr√£o.  Devo dizer imediatamente que esta biblioteca n√£o √© adequada para a implementa√ß√£o completa do protocolo I2C do cart√£o inteligente, porque  n√£o permite controlar ACK e NACK ao transmitir e ler bytes individuais, o que √© necess√°rio para implementar a recep√ß√£o correta de dados de comprimento vari√°vel de um cart√£o inteligente. <br><br>  Sim, e os exemplos usuais do c√≥digo do Wire n√£o funcionaram pela primeira vez, mas depois de dan√ßar com um teclado de <s>pandeiro</s> , v√°rios litros de caf√©, pesquisando no Yandex e Yandex no Google, uma solu√ß√£o foi encontrada. <br><br><pre> <code class="cpp hljs">Wire.write ( ); Wire.endTransmission (<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Wire.requestFrom (ADDR_A7001, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  A julgar pela documenta√ß√£o da biblioteca, esse design n√£o libera o barramento I2C ap√≥s chamar <i>endTransmission</i> .  Por√©m, para o m√≥dulo baseado em ESP32 que eu usei, a transfer√™ncia de dados n√£o ocorre fisicamente durante a chamada para <i>endTransmission (false)</i> , conforme escrito na documenta√ß√£o da biblioteca Wire, mas durante a chamada para <i>requestFrom (true)</i> , enquanto os dados est√£o na fila somente antes disso. transferir. <br><br>  Dadas essas limita√ß√µes, eu tive que fazer algumas ‚Äúmuletas‚Äù, mas eu realmente queria lan√ßar o chip A7001 sem reescrever as bibliotecas padr√£o.  Por esse motivo, o tratamento de erros de protocolo n√£o foi implementado e tamb√©m n√£o foi poss√≠vel receber dados de tamanho vari√°vel (ou seja, voc√™ sempre precisa especificar o n√∫mero exato de bytes a serem lidos). <br><br>  Tais restri√ß√µes n√£o s√£o permitidas em um sistema real, mas n√£o s√£o essenciais para demonstrar o uso de comandos APDU ao trabalhar no barramento I2C.  Portanto, se ocorrer um erro no protocolo de troca ao trocar dados pela porta I2C, o comutador de altern√¢ncia ser√° nosso. <br>  Em outras palavras, se durante a repeti√ß√£o dessas experi√™ncias tudo funcionou e parou repentinamente antes de procurar um erro no c√≥digo, desligue e ligue novamente.  Com um alto grau de probabilidade, isso pode resolver o problema. <br><br><h2>  Exemplos de c√≥digo para trabalhar com o chip A7001 </h2><br>  Nos exemplos, eu uso v√°rias fun√ß√µes auxiliares: <br><br>  <b>vect_dump</b> - envia dados de despejo no formato HEX para a porta de depura√ß√£o; <br>  <b>sci2c_exchange</b> - envia uma matriz de dados via I2C e l√™ o n√∫mero especificado de bytes de resposta; <br>  <b>sci2c_status</b> - l√™ o status da resposta do microcircuito e, se necess√°rio, exibe seu status na porta de depura√ß√£o; <br>  <b>sci2c_apdu_send</b> - envia um comando APDU; <br>  <b>sci2c_apdu_recv</b> - leia a resposta ao comando APDU. <br><br><h3>  Inicializa√ß√£o do microchip </h3><br>  De acordo com a descri√ß√£o do <i>protocolo Smart Card I2C</i> , antes de iniciar o trabalho com o chip, tr√™s comandos devem ser executados sequencialmente: Reinicializa√ß√£o (Reinicializa√ß√£o a frio ou suave), Leia ATR (Leia a resposta a redefinir) e Configure par√¢metros de troca (Dispositivo mestre troca o par√¢metro).  E somente depois disso o chip est√° pronto para aceitar comandos APDU. <br><br><h3>  Redefini√ß√£o suave </h3><br>  Tudo √© simples aqui, enviamos um comando de reinicializa√ß√£o e aguardamos o tempo definido: <br><br><pre> <code class="cpp hljs">sci2c_exchange ({<span class="hljs-number"><span class="hljs-number">0b00011111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); delay(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      (tRSTG, time, ReSeT Guard)</span></span></code> </pre><br><h3>  Leia a resposta para redefinir </h3><br>  A leitura do ATR √© um pouco mais complicada, pois  voc√™ precisa n√£o apenas enviar um comando, mas tamb√©m ler os dados da resposta.  De acordo com a descri√ß√£o do protocolo, o tamanho m√°ximo dos dados retornados CDBATS, MAX (bytes de dados de comando, resposta para redefini√ß√£o, MAXimum) pode ser de 29 bytes. <br><br><pre> <code class="cpp hljs">vect ATR = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b101111</span></span>}, <span class="hljs-number"><span class="hljs-number">29</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 29  + 1  PCB + 1  ‚Äî   vect_dump("ATR: ", ATR);</span></span></code> </pre><br>  Ler dados ATR: <b>1E 00 00 00 B8 03 11 01 05 B9 02 01 01 BA 01 01 BB 0D 41 37 30 30 31 43 47 20 32 34 32 52 31</b> <br><br>  Onde 1E √© o tamanho dos dados retornados (29 bytes + 1 byte do PCB) e 00 √© o PCB (Protocolo Control Byte), que deve ser igual a 0 e, aparentemente, neste exemplo, os dados n√£o foram lidos corretamente (deve haver um byte do PCB, e h√° tr√™s deles). <br><br>  A seguir est√£o os dados codificados no formato TLV: <br><br>  <b>B8h</b> - <i>Objeto de dados de baixo n√≠vel</i> , tamanho 3 bytes ( <i>11h 01h 05h</i> ); <br>  <b>B9h</b> - <i>Objeto de dados de liga√ß√£o de protocolo</i> , 2 bytes de tamanho ( <i>01h 01h</i> ); <br>  <b>BAh</b> - <i>objeto de dados de camada superior</i> , 1 byte ( <i>01h</i> ) de tamanho; <br>  <b>BBh</b> - <i>objeto de dados do sistema operacional</i> , 13 bytes ( <i>41 37 30 30 31 43 47 20 32 34 32 52 31</i> ). <br><br>  <b>Descriptografia da configura√ß√£o de leitura do chip</b> <br>  <i>Objeto de dados de baixo n√≠vel</i> : <b>11h</b> - vers√µes <b>principais</b> e secund√°rias do protocolo suportado. <br><br>  <i>C√≥digos de detec√ß√£o de erros</i> : <b>01h</b> - suporte para detec√ß√£o de erros e controle de integridade dos dados transmitidos usando LRC (c√≥digo de redund√¢ncia longitudinal). <br><br>  <i>N√∫mero inteiro de espera de quadro (FWI)</i> : <b>05h</b> - atraso m√°ximo entre dois comandos.  O intervalo de valores pode variar de 10 ms a 5120ms, o padr√£o √© 5120ms.  O valor √© calculado pela f√≥rmula T = 10ms x 2 ^ FWI.  O que, neste caso, nos d√° um atraso de 320 ms (10ms x 2 ^ 5). <br><br>  <i>Objeto de dados de liga√ß√£o de protocolo</i> - consiste em dois valores, <b>01h 01h</b> , que codificam o protocolo suportado e o protocolo padr√£o.  Esses valores significam suporte ao protocolo APDU [GOST R ISO / IEC 7816-3-2013] e, como voc√™ pode imaginar, o mesmo protocolo √© instalado por padr√£o. <br><br>  <i>Objeto de dados de camada superior</i> - o n√∫mero <b>01h</b> significa suporte para o formato APDU curto e estendido. <br><br>  <i>O objeto de dados do sistema operacional</i> √© um identificador de at√© 15 bytes de tamanho, conforme definido no padr√£o [GOST R ISO / IEC 7816-4-2013].  No nosso caso, esta √© a sequ√™ncia " <i>A7001CG 242R1</i> ". <br><br><h3>  Trocas de dispositivos principais Par√¢metro </h3><br>  O √∫ltimo comando para inicializar as configura√ß√µes de troca: <br><br><pre> <code class="cpp hljs">vect CDB = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b11111111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); sci2c_status(<span class="hljs-string"><span class="hljs-string">"Status CDB: "</span></span>); vect_dump(<span class="hljs-string"><span class="hljs-string">"CDB: "</span></span>, CDB, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Valor de retorno: CCh - (11001100b), de acordo com a ficha t√©cnica, os bits de 4 e 5 devem ser uma nega√ß√£o bit a bit dos bits 2 e 3 (NNb codifica o CDBIMS, MAX negado por bits) e, de acordo com o valor codificado, o chip suporta o tamanho m√°ximo poss√≠vel de comando de 252 bytes CDBIMS , Valor MAX (bytes de dados de comando inteiro, mestre para escravo, m√°ximo). <br><br>  De acordo com a descri√ß√£o do protocolo, ap√≥s executar esses tr√™s comandos e nessa ordem, o microcircuito est√° pronto para executar os comandos APDU habituais (embora pare√ßa funcionar sem definir par√¢metros de troca, ou seja, foi o suficiente para fazer um Soft Reset e ler o ATR). <br><br><h2>  Executando comandos APDU </h2><br>  <b>Cada ciclo de execu√ß√£o de comandos APDU consiste nas seguintes etapas:</b> <br><br><ol><li>  Enviar APDU (comando Master to Slave Data Transmission). </li><li>  Aguarde o tempo de prote√ß√£o para receber e processar o comando. </li><li>  Aguarde o processamento do comando para ler o status (comando Status). </li><li>  Leia os dados de resposta (comando Escravo para transmiss√£o de dados mestre). </li></ol><br>  Essa l√≥gica √© implementada nas <b>fun√ß√µes sci2c_apdu_send</b> e <b>sci2c_apdu_recv</b> , e h√° um ponto importante aqui: no formato do protocolo Smart Card I2C Protocol, existem contadores dos comandos APDU transmitidos.  Esses contadores devem controlar os dispositivos mestre e escravo e s√£o projetados para controlar a sequ√™ncia de dados transmitidos, para que, em caso de erro de recep√ß√£o, seja poss√≠vel transmitir ou solicitar dados APDU novamente. <br><br>  Exemplos da implementa√ß√£o dessas fun√ß√µes podem ser encontrados no c√≥digo, e abaixo est√£o apenas os comandos APDU e os dados de resposta. <br><br><h3>  Exemplo da folha de dados: </h3><br>  C-APDU =&gt; <b>00 A4 04 04 04 54 65 73 74 00</b> - leia o arquivo com o nome "Teste". <br>  R-APDU &lt;= <b>6A 86</b> - de acordo com a folha de dados, a resposta deve ser <b>64 82</b> ( <i>arquivo ou aplicativo n√£o encontrado</i> ), mas, no nosso caso, o firmware √© carregado no microcircuito e a resposta difere do exemplo descrito na documenta√ß√£o. <br><br><h3>  Ciclo de vida da produ√ß√£o do cart√£o de leitura </h3><br>  C-APDU =&gt; <b>80 CA 9F 7F 00</b> <br>  R-APDU &lt;= <b>9F 7F 2A 47 90 51 67 47 91 12 10 38 00 53 56 00 40 39 93 73 50 48 12 53 63 00 00 00 00 13 2C 19 30 34 30 33 39 00 00 00 00 00 00 00 00 90 00</b> <br><br><h3>  Leia as informa√ß√µes do cart√£o de leitura </h3><br><br>  C-APDU =&gt; <b>80 CA 00 66 00</b> <br>  R-APDU &lt;= <b>66 4C 73 4A 06 07 2A 86 48 86 FC 6B 01 60 0C 06 0A 2A 86 48 86 FC 6B 02 02 01 01 63 63 06 06 07 2A 86 48 86 FC 6B 03 64 0B 06 09 2A 86 48 86 FC 6B 04 02 55 65 0B 06 09 2B 85 10 86 48 64 02 01 03 66 0C 06 0A 2B 06 01 04 01 2A 02 6E 01 02 90 00</b> <br><br><h3>  Leia as principais informa√ß√µes de leitura </h3><br>  C-APDU =&gt; <b>80 CA 00 E0 00</b> <br>  R-APDU &lt;= <b>E0 12 C0 04 01 FF 80 10 C0 04 02 FF 80 10 C0 04 03 FF 80 10 90 00</b> <br><br><h2>  Em conclus√£o </h2><br>  Essa experi√™ncia de implementar a troca de equipes da APDU por meio da interface I2C foi muito interessante.  At√© me vi pensando v√°rias vezes que gosto de resolver v√°rios problemas do campo dos circuitos e tamb√©m da soldagem comum, desde a √∫ltima vez que tive que pegar um ferro de soldar h√° mais de 5 anos. <br><br>  Espero que este artigo seja √∫til e ajude a entender os interessados ‚Äã‚Äãneste t√≥pico.  Escreva se o material lhe interessar.  Tentarei responder a todas as perguntas deste artigo e, se o t√≥pico do uso do protocolo I2C do cart√£o inteligente for interessante, tentarei divulg√°-lo com mais detalhes nas publica√ß√µes a seguir. <br><br><h2>  Refer√™ncias: </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Descri√ß√£o da interface I2C (SMBus)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Folha de dados no microcontrolador A7001AG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Descri√ß√£o do protocolo Smart Card I2C</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GOST R ISO / IEC 7816-3-2013</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GOST R ISO / IEC 7816-4-2013</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439574/">https://habr.com/ru/post/pt439574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439564/index.html">Aplica√ß√£o pr√°tica da transforma√ß√£o de √°rvore AST usando Putout como exemplo</a></li>
<li><a href="../pt439566/index.html">Por que a documenta√ß√£o do SRE √© importante. Parte 3</a></li>
<li><a href="../pt439568/index.html">SSDs baseados em QLC - um assassino de disco r√≠gido? Realmente n√£o</a></li>
<li><a href="../pt439570/index.html">Magia IPython para editar tags de c√©lulas Jupyter</a></li>
<li><a href="../pt439572/index.html">Projeto assistido por computador de equipamentos eletr√¥nicos</a></li>
<li><a href="../pt439576/index.html">Uma ampla vis√£o geral das entrevistas em Python. Dicas e truques</a></li>
<li><a href="../pt439578/index.html">√Ä quest√£o das transforma√ß√µes e outras opera√ß√µes</a></li>
<li><a href="../pt439580/index.html">Fazendo o Git for Windows funcionar no ReactOS</a></li>
<li><a href="../pt439584/index.html">Projeto Lenergy como repensar fontes de alimenta√ß√£o port√°teis</a></li>
<li><a href="../pt439586/index.html">Protocolo SPBm como base do Extreme Automated Campus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>