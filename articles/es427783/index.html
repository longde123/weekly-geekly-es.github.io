<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐵 〰️ 🌚 Curso MIT "Seguridad de sistemas informáticos". Lección 14: "SSL y HTTPS", parte 1 👇🏽 💎 💇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnología de Massachusetts. Conferencia Curso # 6.858. "Seguridad de los sistemas informáticos". Nikolai Zeldovich, James Mickens. Año 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguridad de sistemas informáticos". Lección 14: "SSL y HTTPS", parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/427783/"><h3>  Instituto de Tecnología de Massachusetts.  Conferencia Curso # 6.858.  "Seguridad de los sistemas informáticos".  Nikolai Zeldovich, James Mickens.  Año 2014 </h3><br>  Computer Systems Security es un curso sobre el desarrollo e implementación de sistemas informáticos seguros.  Las conferencias cubren modelos de amenazas, ataques que comprometen la seguridad y técnicas de seguridad basadas en trabajos científicos recientes.  Los temas incluyen seguridad del sistema operativo (SO), características, gestión del flujo de información, seguridad del idioma, protocolos de red, seguridad de hardware y seguridad de aplicaciones web. <br><br>  Lección 1: "Introducción: modelos de amenaza" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 2: "Control de ataques de hackers" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 3: “Desbordamientos del búfer: exploits y protección” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 4: “Separación de privilegios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 5: “¿De dónde vienen los sistemas de seguridad?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> <br>  Lección 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 7: “Sandbox de cliente nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 8: "Modelo de seguridad de red" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 9: "Seguridad de aplicaciones web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 10: “Ejecución simbólica” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 11: "Ur / Lenguaje de programación web" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 12: Seguridad de red <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 13: "Protocolos de red" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <br>  Lección 14: "SSL y HTTPS" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  Ahora veremos cómo se utilizan los protocolos criptográficos para proteger las conexiones de red en Internet y cómo generalmente interactúan con los factores de la red.  Antes de profundizar en los detalles, quiero recordarles que habrá una prueba el miércoles, pero no en esta audiencia, sino en Walker, en el 3er piso, durante el tiempo de conferencia habitual. <br><br><img src="https://habrastorage.org/webt/xe/vb/0j/xevb0jkxnzy3og_ofywkhfmhzli.jpeg"><br><br>  Entonces, hoy hablaremos sobre cómo Internet usa la criptografía para proteger una conexión de red, y consideraremos dos temas estrechamente relacionados. <br><br>  El primero es cómo proteger criptográficamente las conexiones a una escala mayor que la que protege el sistema Kerberos, que cubrimos en la última conferencia.  El segundo es cómo integrar esta protección criptográfica, proporcionada a nivel de red, en toda la aplicación, y cómo el navegador web garantiza el uso de la protección provista por el protocolo criptográfico.  Estos temas están estrechamente relacionados, por lo que resulta que la protección de las comunicaciones de red es bastante fácil de proporcionar, porque la criptografía siempre funciona.  Pero integrarlo en el navegador es una tarea mucho más difícil que construir un sistema en torno a la criptografía. <br><br>  Antes de sumergirnos en esta discusión, quiero recordarles los elementos básicos de la criptografía que utilizaremos. <br><br>  En nuestra última conferencia sobre Kerberos, utilizamos criptografía simétrica, o <br>  cifrado y descifrado.  Su significado es que tiene una clave secreta K y dos funciones.  Por lo tanto, puede tomar algún dato, llamémoslo P, este es texto sin formato al que puede aplicar la función de cifrado, y esta es la función de alguna tecla K. Y si cifra este texto sin formato, obtendrá el texto cifrado C. De manera similar, tenemos hay una función de descifrado D que usa la misma clave K, como resultado de lo cual el texto cifrado C se convertirá en texto plano P. Esta es la primitiva alrededor de la cual se construyó Kerberos. <br><br><img src="https://habrastorage.org/webt/pg/km/c5/pgkmc5lrc_vzzniemf7k_qxv0c8.jpeg"><br><br>  Pero resulta que hay otras primitivas que serán útiles para la discusión de hoy, y que se denominan cifrado y descifrado asimétrico.  La idea aquí es tener diferentes claves para el cifrado y descifrado.  Veamos por qué esto es tan útil. <br><br>  Aquí hay una función E, que puede encriptar un determinado conjunto de mensajes P con una determinada clave pública pk, como resultado, para obtener el texto encriptado C.Para desencriptarlo con la función D, solo necesita especificar la clave secreta correspondiente sk y obtener el texto fuente P. <br><br><img src="https://habrastorage.org/webt/oy/xp/3j/oyxp3jjifkqzcsikcgjrbmtaj_g.jpeg"><br><br>  La conveniencia del cifrado asimétrico es que puede publicar una clave pública en Internet y las personas pueden cifrar mensajes por usted, pero necesita una clave secreta para descifrar sus mensajes.  Hoy veremos cómo se usa esto en el protocolo.  En la práctica, a menudo utilizará la criptografía de clave pública de una manera ligeramente diferente.  Por ejemplo, en lugar de cifrar y descifrar mensajes, es posible que deba firmar o verificar mensajes. <br><br>  Resulta que a nivel de implementación, estas son operaciones relacionadas, pero a nivel de aplicación API pueden parecer un poco diferentes.  Por ejemplo, puede firmar el mensaje M con su clave secreta sk y obtener alguna firma S. Luego puede verificar este mensaje con la clave pública correspondiente pk y, como resultado, obtener un indicador lógico que indica si la firma S es correcta para el mensaje M. <br><br><img src="https://habrastorage.org/webt/ib/2a/0j/ib2a0j4ie3lp28irckclwqkd6tw.jpeg"><br><br>  Aquí hay algunas garantías relativamente intuitivas que proporcionan estas características.  Si, por ejemplo, recibió esta firma y se verifica correctamente, significa que tuvo que ser generada por alguien con la clave secreta correcta.  ¿Eso está claro? <br><br>  Luego, intentemos descubrir cómo proteger las conexiones de red a una escala mayor que Kerberos.  En Kerberos, teníamos un modelo bastante simple, donde todos los usuarios y servidores usaban algún tipo de conexión con el objeto KDC, que tenía esta tabla gigante de usuarios, servicios y sus claves.  Siempre que un usuario quiera hablar con algún servidor, debe pedirle a KDC que cree el ticket que necesita en base a esta mesa gigante. <br><br><img src="https://habrastorage.org/webt/_p/re/mf/_premfpwfmsf-ux_g91rdizrpkk.jpeg"><br><br>  Así que esto parece un modelo bastante simple.  Entonces, ¿por qué necesitamos algo más?  ¿Por qué Kerberos no es lo suficientemente bueno para trabajar con sitios?  ¿Por qué Internet no usa Kerberos exclusivamente para proteger todas las conexiones? <br><br>  Respondiste correctamente, porque el único KDC debería confiar en todos, y esto es malo.  Puede tener problemas si considera que cierta máquina es absolutamente segura. <br><br>  Quizás las personas en el MIT estén dispuestas a confiar en alguien en la red local administrada por KDC, pero no todos en Internet. <br><br>  Y la respuesta del segundo alumno también es correcta: es muy difícil administrar una cantidad tan enorme de claves.  De hecho, puede ser muy difícil construir un KDC único que pueda administrar mil millones de claves o diez mil millones de claves para todas las personas en el mundo.  Otra complicación del uso de Kerberos para todo Internet es que todos los usuarios deben tener una clave, o deben ser conocidos por KDC.  Ni siquiera puede usar Kerberos en nuestro instituto para conectarse a algunos servidores si no tiene una cuenta en la base de datos de Kerberos.  Si bien para toda Internet es bastante razonable esperar que cuando vayas a la computadora, no sepa en absoluto quién eres, pero te permitirá ir al sitio web de Amazon, que está protegido por criptografía. <br><br><img src="https://habrastorage.org/webt/yq/ok/mn/yqokmnixur_msywempw4ufdtd80.jpeg"><br><br>  ¿Eh? <br><br>  Hay varias otras cosas que espera de un protocolo criptográfico, y veremos cómo aparecen en SSL.  Pero la idea clave es que esta solución es la misma para Kerberos y para SSL o TLS.  Tiene razón cuando menciona que los protocolos Kerberos originales sobre los que leemos en los materiales de la conferencia se desarrollaron hace mucho tiempo.  Y si queremos usarlos para la Internet moderna, entonces tendrán que cambiar algo.  ¿Qué otras ideas tienes, por qué no deberíamos usar Kerberos? <br><br>  Así es, hay un problema de escalado al restaurar el acceso, y posiblemente al registrar nuevos usuarios, porque tendrá que ir personalmente a alguna oficina de cuentas y obtener una cuenta allí.  Que mas <br><br>  <b>Estudiante: El</b> servidor Kerberos siempre debe estar en línea. <br><br>  <b>Profesor:</b> sí, este es otro problema.  Hemos enumerado algún tipo de problemas de administración, pero a nivel de protocolo, KDC siempre debe estar en línea, porque en realidad sirve como intermediario para cualquiera de sus interacciones con los servicios.  Esto significa que cada vez que visita un nuevo sitio web, debe hablar con KDC.  En primer lugar, será un cuello de botella en términos de rendimiento.  Al igual que otros tipos de escalabilidad, este principio conducirá a la escalabilidad del rendimiento, mientras que los principios enumerados anteriormente solo conducen a la escalabilidad de la administración. <br><br><img src="https://habrastorage.org/webt/_o/nb/xw/_onbxws5l_wixnqzzhhqnhniknk.jpeg"><br><br>  Entonces, ¿cómo podemos resolver este problema utilizando estos principios?  La idea es usar el cifrado de clave para dejar de usar KDC. <br><br>  Primero averigüemos si puede establecer una conexión segura si solo conoce algunas de las claves públicas del otro lado.  Y luego veremos cómo conectamos la versión de clave pública de KDC a la autenticación de las partes en este protocolo.  Si no desea usar KDC, puede hacer lo siguiente con la criptografía de clave pública: de alguna manera, descubra la clave pública del socio en el otro lado de la conexión.  Entonces, en Kerberos, si quiero conectarme a un servidor de archivos, solo sé la clave pública del servidor de archivos desde algún lugar.  Como estudiante de primer año, recibo una copia impresa que dice que la clave pública del servidor de archivos es tal y tal, y puedo usarla para conectarme. <br><br>  Simplemente puede cifrar el mensaje para la clave pública del servidor de archivos al que desea conectarse.  Pero resulta que en la práctica, estas operaciones con estas claves públicas son bastante lentas.  Son varios órdenes de magnitud más lentos que las claves de cifrado simétrico.  Por lo tanto, en la práctica, generalmente siempre desea abandonar el uso del cifrado público. <br><br>  Por lo tanto, un protocolo típico podría verse así.  Tiene A y B, quieren comunicarse y A conoce la clave pública B. Al mismo tiempo, A genera algún tipo de clave de sesión S, simplemente eligiendo un número aleatorio para ello.  Entonces A está a punto de enviar la clave de sesión S B, por lo que parece Kerberos.  Vamos a cifrar la clave de sesión S para B. <br><br>  Si recuerdas, en Kerberos, para hacer esto, necesitábamos un KDC porque A no conocía la clave para B o no se le permitió saberlo, porque es un secreto que solo B puede saber. Pero con una clave pública, puedes hacerlo inmediatamente, solo encripte el secreto con esta clave pública de Bspk y envíe el mensaje B. Ahora B puede descifrar este mensaje y decir: Necesito usar esta clave secreta.  Ahora tenemos un canal de comunicación donde todos los mensajes se cifran simplemente con esta clave secreta S. <br><br><img src="https://habrastorage.org/webt/22/o9/mt/22o9mt6zwalsi4qdqdxslwf9-0a.jpeg"><br><br>  Entonces, hay algunas características útiles en este protocolo.  En primer lugar, eliminamos la necesidad de tener KDC en línea y generar una clave de sesión para nosotros.  Simplemente podríamos garantizar la confidencialidad de la información transmitida si una de las partes en la conexión la genera y luego la cifra para el otro lado sin usar KDC. <br><br>  Otra cosa buena es la confianza de que solo B puede leer los mensajes enviados de A a B, porque solo B puede descifrar este mensaje.  Por lo tanto, B debe tener la clave privada correspondiente S. <br><br>  <b>Estudiante:</b> ¿importa quién da esta clave: usuario o servidor? <br><br>  <b>Profesor:</b> tal vez.  Creo que depende de las propiedades que desee de este protocolo.  Por lo tanto, ¿qué pasa si A comete un error o utiliza la aleatoriedad incorrecta, el servidor que envía los datos de regreso piensa: "Oh, ahora estos son los únicos datos que A verá".  Es posible que esto no sea del todo correcto, por lo que debe pensarlo.  Hay varios otros problemas con este protocolo. <br><br>  <b>Estudiante:</b> ¿Puede un atacante usar una clave para enviar mensajes repetidos? <br><br>  <b>Profesor:</b> sí, el problema puede ser que puedo enviar estos mensajes nuevamente, y parecerá que A está enviando el mensaje B nuevamente, y así sucesivamente. <br><br>  Por lo tanto, generalmente la solución a este problema es que ambos lados de la conexión están involucrados en la generación de S y esto asegura que la clave que usamos sea "nueva".  Porque aquí, en la figura, en realidad B no genera nada, por lo que estos mensajes de protocolo tienen el mismo aspecto cada vez. <br><br>  Por lo general, sucede que un lado elige un número aleatorio como S, y luego el otro lado, B, también elige un número aleatorio, generalmente llamado nonce.  Hay dos números y una clave que no está realmente seleccionada solo por un lado, es un hash que ambos lados han elegido para la interacción conjunta.  Además del hash, puede usar el protocolo Diffie-Hellman, que examinamos en la última conferencia, gracias al cual obtiene privacidad primero.  Esta es una matemática más complicada que simplemente dividir dos números aleatorios que han elegido estos dos lados.  Pero entonces obtendrá una propiedad tan buena como la clave secreta compartida original, eliminando la necesidad de transferir la clave de descifrado al transmitir datos cifrados. <br><br>  Por lo tanto, los ataques repetidos se pueden evitar de la siguiente manera.  B genera nonce y luego establece la clave secreta real S ', que se utiliza para hacer hash de la clave secreta S con este nonce.  Y, por supuesto, B tendría que enviar un nonce a A para averiguar qué sucede cuando ambos acuerdan la clave. <br><br><img src="https://habrastorage.org/webt/d1/kj/yd/d1kjydts_olj6gitw4qnayq6aac.jpeg"><br><br>  Otro problema es que no existe una autenticación real A. A sabe quién es B, o al menos sabe quién puede descifrar los datos.  Pero B no tiene idea de quién está del otro lado, ya sea algún tipo de adversario que se haga pasar por otro u otra persona.  ¿Cómo se puede solucionar esto en el mundo de la clave pública? <br><br>  Hay varias formas de hacer esto.  Una posibilidad es firmar este mensaje inicialmente, porque tenemos este buen principio de Firmar.  Entonces quizás podríamos firmar esto con una clave secreta.  Este signo simplemente proporciona una firma, pero presumiblemente la asigna, y también proporciona este mensaje. <br><br>  Entonces B debe saber que A es una clave pública para verificar la firma.  Pero si B sabe que A es una clave pública, entonces B estará bastante seguro de que A es quien envió este mensaje. <br><br><img src="https://habrastorage.org/webt/9k/zg/xq/9kzgxqxgtokahv9sq5goydxluvk.jpeg"><br><br>  Otra cosa que puedes hacer es confiar en el cifrado.  Entonces, tal vez B pueda enviar nonce a A, cifrándolo con la clave pública proporcionada por A. Y luego solo A puede descifrar nonce y generar la clave de sesión final S '.  Así que hay algunos trucos que podrías hacer.  Así es como funcionan actualmente los certificados de cliente en los navegadores de Internet. <br><br>  Por lo tanto, A tiene una clave secreta y, por lo tanto, cuando recibe un certificado MIT personal, su navegador crea una clave secreta de larga duración y recibe un certificado.  Y cada vez que envía una solicitud al servidor web, demuestra el hecho de que conoce la clave secreta de su certificado de usuario y luego establece la clave secreta S para el resto de la conexión. <br><br>  Estos son problemas que se solucionan fácilmente a nivel de protocolo.  Sin embargo, la base de todo lo anterior es que todas las partes conocen las claves públicas de las demás.  ¿Cómo puedes encontrar la clave pública de alguien?  Supongamos que quiero conectarme a un sitio web, tengo una URL a la que quiero conectarme o un nombre de host, ¿cómo puedo saber qué clave pública coincide? <br><br>  Del mismo modo, si me conecto al servidor MIT para ver mis calificaciones, ¿cómo sabe el servidor cuál debería ser mi clave pública para distinguirla de la clave pública de otro estudiante de MIT? <br><br>  Este es el problema principal que ha abordado el KDC.  De hecho, KDC resolvió dos problemas para nosotros.  Primero, generó un mensaje (Ebspk (S)), creó una clave de sesión y la cifró para el servidor.  Ahora hemos solucionado esto creando criptografía de clave pública.  Pero también necesitábamos hacer coincidir los nombres de las cadenas principales con las claves criptográficas de Kerberos que nos proporcionaron anteriormente. <br><br>  Hay un protocolo TLC para tales cosas en el mundo HTTPS.  Su significado es que continuaremos confiando en ciertos aspectos del proceso que admiten estas tablas gigantes que asignan los nombres de los participantes del proceso a las claves criptográficas.  El plan es que tendremos algo llamado una autoridad de certificación, que se indica con las letras CA en todo tipo de literatura sobre seguridad de red.  Esta CA también admite lógicamente la tabla, en una parte de la cual se muestran los nombres de todos los participantes, y en la otra, las claves públicas correspondientes.  La principal diferencia entre este centro y Kerberos es que esta CA no tiene que estar en línea para todas las transacciones. <br>  En Kerberos, para conectarse con alguien o encontrar la clave de otra persona, debe hablar con KDC.  En cambio, en el mundo de CA, hacen esto. <br><br><img src="https://habrastorage.org/webt/n7/sr/ag/n7sragiofvbto-bml-z-y5vszdi.jpeg"><br><br>  Si tiene algún tipo de nombre aquí y la clave correspondiente en otra parte de la tabla, la autoridad de certificación simplemente firmará mensajes de que existen ciertas filas en esta tabla.  Por lo tanto, la autoridad de certificación tendrá que tener sus propias claves públicas y privadas aquí.  Utilizará una clave secreta para buscar mensajes para otros usuarios en el sistema en los que pueda confiar. <br><br>  Entonces, si tiene un registro de "nombre + clave" en la base de datos de CA, CA creará un mensaje de que este nombre coincide con esta clave pública y firmará este mensaje con su clave privada de CA. <br><br><img src="https://habrastorage.org/webt/4v/7q/1u/4v7q1ulrryyh20haewxx5hbd-xo.jpeg"><br><br>  Esto le permite hacer cosas muy similares a lo que hace Kerberos, pero al mismo tiempo eliminamos la necesidad de encontrar una CA en línea para todas las transacciones.  Y, en realidad, será mucho más escalable.  Esto es exactamente lo que comúnmente se llama un certificado.  La escalabilidad está garantizada por el hecho de que para un cliente o cualquier otra persona que use este sistema, un certificado proporcionado por una fuente no es inferior a un certificado de otra fuente.  Está firmado por la clave secreta de la autoridad de certificación.  Por lo tanto, puede verificar su autenticidad sin tener que ponerse en contacto con una autoridad de certificación o cualquier otra parte mencionada aquí. <br><br>  Funciona asi.  El servidor con el que desea hablar almacena el certificado que recibió originalmente de la autoridad de certificación.  Y cada vez que te conectas a él, el servidor te dice: “OK, aquí está mi certificado.  Fue firmado por esta CA.  Puede verificar la firma y simplemente asegurarse de que sea mi clave pública y que sea mi nombre ". <br><br>  Por otro lado, lo mismo sucede con los certificados de cliente.  Cuando un usuario se conecta al servidor web, su certificado de cliente indica que su clave pública coincide con la clave secreta que se generó originalmente en el navegador.  Por lo tanto, al conectarse al servidor, presentará un certificado firmado por la autoridad de certificación del MIT, que indica que su nombre de usuario corresponde a esta clave pública.     ,  ,    , ,       Athena. <br><br> <b>:</b>   ,      ? <br><br> <b>:</b> ,     ,    –   ,       ?  -      , ,  , ,    .    -      ,          .    .       ,  VeriSign. US Postal Service       CA,      ,           .  ,  CA  ,       KDC. <br><br>  ,      ,   Kerberos. ,    ,          KDC.        ,       KDC,       ,       .        ,          ,        .            CA  ,   KDS. <br><br> <b>:</b>      ? <br><br> <b>:</b> ,    .  ,   ,    KDC,          .    ,    .   , ,      .  ,  ,   ,  .       Kerberos,     .  Kerberos       ,       .  ,    ,      .     ,        ,        .    ,     . <br><br>   ,        .   ,  , CA        - ,     . ,        amazon.com,             amazon.com.     CA,       .  ,        ,     ,      . <br><br><img src="https://habrastorage.org/webt/te/xw/6a/texw6avc3kshcb4gza2tfknu0ac.jpeg"><br><br>     . , CA   ,    ,   ,    ,    -   ,     .  ,       ,        .   - ,     amazon.com,           ,   -       . <br><br>  ,     -,    ,    ,       ,    .    ,      .     «» ,    ,     . <br><br>   ,    . -,            CRL, ertificate Revocation List.    .       ,  -   ,    . ,  ,       ,       : «,    ,   ,   -       .     ,      ». <br><br>  ,   ,  ,     CRL,  ,   web-,     CRL. ,    - ,   ,       .     ,   ,     ,      ,        ,     . <br><br>     ,     .      ,       .          ,   .     ,             .       ,        CRL,         -   . <br><br> ,    ?      ,     .  ,       CRL   . <br><br>     ,       ,  ,      Kerberos,      KDC.   CA      ,         .    ,  «    SSL »,  OCSP.       CA   KDC.  ,    ,  ,     ,    ,       , -      .  ,   OCSP,        : «,    .   ,     »?  ,       CRL   .   ,     ,      .    ,    ,          . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">26:30 min </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curso MIT "Seguridad de los sistemas informáticos". </font><font style="vertical-align: inherit;">Lección 14: "SSL y HTTPS", parte 2</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q1OF_0ICt9A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La versión completa del curso está disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Gracias por quedarte con nosotros.  ¿Te gustan nuestros artículos?  ¿Quieres ver más materiales interesantes?  <b>Apóyenos</b> haciendo un pedido o recomendándolo a sus amigos, un <b>descuento del 30% para los usuarios de Habr en un análogo único de servidores de nivel de entrada que inventamos para usted:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">toda la verdad sobre VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de $ 20 o cómo dividir el servidor?</a>  (las opciones están disponibles con RAID1 y RAID10, hasta 24 núcleos y hasta 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps hasta diciembre de forma gratuita</b> al pagar por un período de seis meses, puede ordenar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  <b>Dell R730xd 2 veces más barato?</b>  ¡Solo tenemos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV desde $ 249</a> en los Países Bajos y los Estados Unidos!</b>  Lea sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cómo construir un edificio de infraestructura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">clase utilizando servidores Dell R730xd E5-2650 v4 que cuestan 9,000 euros por un centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427783/">https://habr.com/ru/post/es427783/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427771/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 13: Protocolos de red, parte 2</a></li>
<li><a href="../es427773/index.html">Escribí una extensión de navegador cruzado para pestañas, pero tú no haces eso</a></li>
<li><a href="../es427775/index.html">Un bot disfrazado de programador corrige errores en el código</a></li>
<li><a href="../es427779/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 13: Protocolos de red, Parte 3</a></li>
<li><a href="../es427781/index.html">¿Por qué las organizaciones de crédito?</a></li>
<li><a href="../es427785/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 14: "SSL y HTTPS", parte 2</a></li>
<li><a href="../es427787/index.html">Curso MIT "Seguridad de sistemas informáticos". Lección 14: "SSL y HTTPS", parte 3</a></li>
<li><a href="../es427789/index.html">Exxon Mobil acusado de manipular los datos de impacto ambiental de la compañía para engañar a los inversores</a></li>
<li><a href="../es427793/index.html">Winamp 2019: retorno triunfal y perspectivas vagas</a></li>
<li><a href="../es427795/index.html">[Viernes] Venganza AI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>