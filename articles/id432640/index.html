<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕡 🚴🏻 🙇🏾 Rilis Rust 1.31 dan Rust 2018 👓 ⚗️ 🤱🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tim pengembangan Rust dengan bangga mengumumkan rilis versi baru Rust, 1.31.0, serta "Rust 2018". Rust adalah bahasa pemrograman yang memungkinkan sem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rilis Rust 1.31 dan Rust 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432640/"><p>  Tim pengembangan Rust dengan bangga mengumumkan rilis versi baru Rust, 1.31.0, serta "Rust 2018".  Rust adalah bahasa pemrograman yang memungkinkan semua orang membuat perangkat lunak yang andal dan efisien. </p><br><p> Jika Anda memiliki versi Rust sebelumnya yang diinstal menggunakan <code>rustup</code> , maka untuk meningkatkan versi Rust ke versi 1.31.0 Anda hanya perlu melakukan: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Jika Anda belum menginstal <code>rustup</code> , Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menginstalnya</a> dari halaman yang sesuai di situs web kami.  <a href="">Catatan rilis terperinci untuk Rust 1.31.0</a> tersedia di GitHub. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1310">  Apa yang termasuk dalam versi stabil 1.31.0 </h2><br><p>  Rust 1.31 bisa dibilang rilis paling signifikan sejak Rust 1.0!  Iterasi pertama "Rust 2018" termasuk dalam rilis ini, tetapi ini bukan satu-satunya inovasi!  Tinjauan perbaikan akan lama, jadi di sini adalah daftar isi: </p><br><ul><li>  <strong>Karat 2018</strong> <br><ul><li>  <strong>Masa hidup non-leksikal</strong> </li><li>  <strong>Modul sistem berubah</strong> </li></ul></li><li>  <strong>Aturan tambahan untuk menampilkan masa hidup</strong> </li><li> <strong><code>const fn</code></strong> </li> <li>  <strong>Alat baru</strong> </li><li>  <strong>Pemeriksaan kualitas kode instrumental</strong> </li><li>  <strong>Dokumentasi</strong> </li><li>  <strong>Kelompok Kerja Subjek</strong> </li><li>  <strong>Situs web baru</strong> </li><li>  <strong>Stabilisasi perpustakaan standar</strong> </li><li>  <strong>Peningkatan Kargo</strong> </li><li>  <strong>Rilis Pengembang</strong> </li></ul><a name="habracut"></a><br><h3 id="rust-2018">  Karat 2018 </h3><br><p>  Kami menulis tentang Rust 2018 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk pertama kalinya di bulan Maret</a> , dan kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di bulan Juli</a> .  Untuk detail <em>mengapa Anda</em> membutuhkan Rust 2018, lihat publikasi ini.  Dalam ulasan ini, ada banyak hal yang perlu diceritakan kepada kami, jadi kami hanya akan fokus pada apa yang dimaksud dengan Rust 2018. Anda juga dapat membacanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di posting di Mozilla Hacks</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan</a> ). </p><br><p>  Singkatnya, Rust 2018 adalah kesempatan untuk mengintegrasikan semua pekerjaan yang telah kami lakukan selama tiga tahun terakhir ke dalam keseluruhan yang koheren.  Rust 2018 lebih dari sekadar perbaikan bahasa.  Selain mereka, itu termasuk: </p><br><ul><li>  Toolkit (dukungan dalam IDE, <code>rustfmt</code> , Clippy) </li><li>  Dokumentasi </li><li>  Kelompok kerja subjek </li><li>  Situs web baru </li></ul><br><p>  Selanjutnya kita akan membicarakan semua ini secara lebih rinci dan tentang inovasi lainnya. </p><br><p>  Mari buat proyek baru menggunakan Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo new foo</code> </pre> <br><p>  Inilah isi <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "foo" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] edition = "2018" [dependencies]</code> </pre> <br><p>  Kunci baru telah ditambahkan ke bagian <code>[package]</code> : <code>edition</code> .  Harap dicatat bahwa itu diinstal pada <code>2018</code> .  Anda juga dapat menginstalnya di <code>2015</code> - nilai ini akan ditetapkan secara default jika kunci tidak ada. </p><br><p>  Menggunakan Rust 2018 akan membuka kunci beberapa fitur baru yang tidak diizinkan di Rust 2015. </p><br><p>  Penting untuk dicatat bahwa setiap paket bisa dalam mode 2015 atau 2018, dan mereka akan bekerja bersama.  Proyek edisi 2018 Anda dapat menggunakan dependensi edisi 2015, dan proyek edisi 2015 dapat menggunakan dependensi edisi 2018.  Ini memastikan integritas ekosistem dan bahwa semua fitur baru akan opsional, sambil mempertahankan kompatibilitas dengan kode yang ada.  Selain itu, ketika Anda memutuskan untuk memasukkan kode Rust 2015 ke Rust 2018, perubahan dapat dilakukan secara otomatis melalui <code>cargo fix</code> . </p><br><p>  Anda mungkin bertanya: bagaimana dengan fitur-fitur baru itu sendiri?  Pertama, mereka juga ditambahkan di Rust 2015, jika mereka kompatibel dengan fitur-fitur edisi ini.  Dengan demikian, sebagian besar bahasanya tetap sama di mana-mana.  Anda dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual editorial</a> untuk mengetahui versi minimum <code>rustc</code> untuk setiap fitur baru dan persyaratan lainnya.  Namun, ada beberapa inovasi besar yang perlu disebutkan secara terpisah: masa hidup non-leksikal dan beberapa perubahan dalam sistem modul. </p><br><h4 id="neleksicheskie-vremena-zhizni">  Masa hidup non-leksikal </h4><br><p>  Jika Anda telah mengikuti Rust selama beberapa tahun terakhir, Anda terkadang menemukan istilah "NLL" atau "masa hidup non-leksikal".  Ini adalah jargon, yang, secara sederhana, berarti: peminjam telah menjadi lebih pintar dan sekarang menerima beberapa kode yang benar, yang ditolak sebelumnya.  Pertimbangkan sebuah contoh: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; }</code> </pre> <br><p>  Karat yang digunakan untuk melempar kesalahan kompilasi: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | 6 | let z = &amp;mut x; | ^ mutable borrow occurs here 7 | } | - immutable borrow ends here</code> </pre> <br><p>  Ini karena bidang kehidupan tautan didefinisikan "secara leksikal";  yaitu, meminjam <code>y</code> dianggap aktif sampai <code>y</code> keluar dari ruang lingkup di akhir <code>main</code> , bahkan jika kita tidak pernah menggunakan <code>y</code> di dalam lingkup lagi.  Semuanya baik-baik saja dengan kode di atas, tetapi penganalisis ketergantungan tidak dapat memahami ini. </p><br><p>  Sekarang kode ini dikompilasi dengan baik. </p><br><p>  Tetapi bagaimana jika kita menggunakan <code>y</code> ?  Misalnya, seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"y: {}"</span></span>, y); }</code> </pre> <br><p>  Rust dulu memberi Anda kesalahan ini: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | let z = &amp;mut x; | ^ mutable borrow occurs here ... 8 | } | - immutable borrow ends here</code> </pre> <br><p>  Di Rust 2018, pesan kesalahan ini membaik: </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:13 | 4 | let y = &amp;x; | -- immutable borrow occurs here 5 | let z = &amp;mut x; | ^^^^^^ mutable borrow occurs here 6 | 7 | println!("y: {}", y); | - borrow later used here</code> </pre> <br><p>  Alih-alih menunjukkan di mana Anda keluar dari ruang lingkup, itu menunjukkan di mana terjadi konflik pinjaman.  Ini sangat menyederhanakan kesalahan debug seperti ini. </p><br><p>  Di Rust 1.31, ini merupakan peningkatan khusus untuk Rust 2018. Kami berencana untuk menambahkannya ke Rust 2015 nanti. </p><br><h4 id="izmeneniya-sistemy-moduley">  Modul sistem berubah </h4><br><p>  Sistem modul bisa jadi sulit bagi orang yang mempelajari Rust untuk pertama kalinya.  Tentu saja, selalu ada sesuatu yang membutuhkan waktu untuk dikuasai.  Tetapi alasan utama mengapa modul sangat memalukan bagi banyak orang adalah bahwa meskipun aturan sederhana dan konsisten yang mendefinisikan sistem modul, konsekuensi dari penggunaannya mungkin tampak kontradiktif, misterius dan tidak wajar. </p><br><p>  Oleh karena itu, edisi 2018 membuat beberapa perubahan pada cara jalur bekerja, menyederhanakan sistem modul dan membuatnya lebih dimengerti. </p><br><p>  Berikut ini ringkasan singkatnya: </p><br><ul><li>  <code>extern crate</code> tidak lagi diperlukan hampir di tempat lain. </li><li>  Anda dapat mengimpor makro menggunakan <code>use</code> , alih-alih menggunakan atribut <code>#[macro_use]</code> . </li><li>  Jalur absolut dimulai dengan nama wadah, di mana kata kunci <code>crate</code> merujuk ke wadah saat ini. </li><li>  <code>foo.rs</code> dan subdirektori <code>foo/</code> dapat hidup berdampingan;  <code>mod.rs</code> tidak lagi diperlukan saat menempatkan submodula dalam subdirektori. </li></ul><br><p>  Sepertinya seperangkat aturan yang sewenang-wenang, tetapi secara umum, model mental sekarang telah sangat disederhanakan. </p><br><p>  Masih ada <em>banyak</em> detail, silakan lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual editorial</a> untuk semua detailnya. </p><br><h3 id="dopolnitelnye-pravila-vyvoda-vremen-zhizni">  Aturan tambahan untuk menampilkan masa hidup </h3><br><p>  Mari kita bicara tentang peningkatan yang tersedia di kedua edisi: kami telah menambahkan beberapa aturan inferensi tambahan untuk blok <code>impl</code> dan definisi fungsi.  Kode seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  sekarang dapat ditulis seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'_</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  Seumur hidup <code>'_</code> masih menunjukkan bahwa <code>BufReader</code> menganggapnya sebagai parameter, tetapi kita tidak perlu lagi memberinya nama. </p><br><p>  Masa hidup masih perlu didefinisikan dalam struktur.  Namun, kita tidak perlu lagi menulis kode boilerplate seperti sebelumnya: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Rust 2015 struct Ref&lt;'a, T: 'a&gt; { field: &amp;'a T } // Rust 2018 struct Ref&lt;'a, T&gt; { field: &amp;'a T }</span></span></code> </pre> <br><p>  Ketergantungan <code>: 'a</code> akan menjadi keluaran.  Anda masih dapat menentukannya secara eksplisit jika Anda mau.  Kami sedang mempertimbangkan peluang lain untuk penarikan di tempat-tempat seperti itu untuk masa depan, tetapi sejauh ini kami tidak memiliki rencana yang konkret. </p><br><h3 id="const-fn"> <code>const fn</code> </h3> <br><p>  Rust memiliki beberapa cara untuk mendeklarasikan suatu fungsi: <code>fn</code> untuk fungsi biasa, <code>unsafe fn</code> untuk fungsi tidak aman, dan <code>extern fn</code> untuk fungsi eksternal.  Rilis ini menambahkan cara baru untuk mendeklarasikan suatu fungsi: <code>const fn</code> .  Digunakan seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { x + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><p>  Fungsi konstan dapat disebut sebagai fungsi normal, tetapi selain itu dapat digunakan dalam konteks konstan apa pun.  Namun, itu akan dieksekusi pada waktu kompilasi, dan tidak selama eksekusi program.  Sebagai contoh: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SIX: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = foo(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><p>  Fungsi <code>foo</code> akan dieksekusi pada waktu kompilasi dan <code>SIX</code> akan diatur ke <code>6</code> . </p><br><p>  Fungsi konstan tidak dapat melakukan segala sesuatu yang fungsi normal dapat lakukan: mereka harus memiliki hasil deterministik.  Ini penting untuk alasan keandalan.  Dalam bentuk saat ini, fungsi konstan dapat melakukan subset operasi minimal.  Berikut ini beberapa contoh yang dapat Anda lakukan di dalamnya: </p><br><ul><li>  Gunakan operasi bilangan aritmatika dan perbandingan </li><li>  Gunakan operasi logis apa pun kecuali <code>&amp;&amp;</code> dan <code>||</code> </li><li>  Desain susunan, struktur, enumerasi, dan tupel </li><li>  Sebut fungsi konstan lainnya </li><li>  Akses menurut indeks dalam array dan irisan </li><li>  Mengakses bidang struktur dan tupel </li><li>  Gunakan konstanta (tetapi bukan nilai statis, dan bahkan bukan referensi untuknya) </li><li>  Gunakan tautan <code>&amp;</code> dan <code>*</code> </li><li>  Melemparkan tipe kecuali melemparkan pointer mentah ke nilai integer </li></ul><br><p>  Kami akan memperluas kapabilitas fungsi konstan, tetapi set di atas sudah cukup untuk menggunakan <code>const fn</code> dalam praktiknya. </p><br><p>  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual untuk</a> detailnya. </p><br><h3 id="novye-instrumenty">  Alat baru </h3><br><p>  Edisi 2018 menandai awal dari tingkat kematangan baru untuk ekosistem alat Rust.  Cargo, Rustdoc, dan Rustup telah menjadi alat utama sejak versi 1.0;  Dengan edisi 2018, generasi baru alat akan datang yang kini dapat digunakan semua orang: Clippy, Rustfmt, dan dukungan IDE. </p><br><p>  Alat analisa kode statis yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>clippy</code></a> sekarang tersedia di Rust yang stabil.  Anda dapat menginstalnya melalui <code>rustup component add clippy</code> dan jalankan dengan <code>cargo clippy</code> .  Clippy sekarang telah menerima versi 1.0 dan memiliki jaminan stabilitas yang sama untuk pemeriksaan statis seperti rustc.  Pemeriksaan baru dapat ditambahkan, atau fungsionalitas yang lama dapat diperluas, tetapi yang lama tidak dapat dihapus (hanya dapat ditandai sebagai usang).  Ini berarti bahwa kode yang mengkompilasi dengan clippy akan terus mengkompilasi dengan clippy (dengan asumsi tidak ada pemeriksaan yang diatur untuk menghasilkan <br>  kesalahan melalui <code>deny</code> ), tetapi dapat menghasilkan peringatan baru. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rustfmt</a> adalah alat untuk memformat kode di Rust.  Pemformatan kode otomatis akan menghemat waktu Anda, selain itu, akan membawa kode Anda lebih dekat ke <a href="">gaya Karat resmi</a> .  Anda dapat menginstalnya melalui <code>rustup component add rustfmt</code> dan menggunakan perintah <code>cargo fmt</code> . </p><br><p>  Rilis saat ini termasuk Rustfmt 1.0.  Mulai sekarang, kami menjamin kompatibilitas ke belakang untuk Rustfmt: jika Anda memformat kode Anda hari ini, maka pemformatan tidak akan berubah di masa mendatang (hanya untuk pengaturan default).  Kompatibilitas mundur berarti sekarang praktis menjalankan Rustfmt pada CI Anda (gunakan <code>cargo fmt --check</code> ).  Coba ini bersama dengan "memformat saat menyimpan" di editor, dan alur kerja Anda akan mengalami revolusi. </p><br><p>  Dukungan IDE adalah salah satu fitur yang paling banyak diminta untuk Rust.  Sekarang ada beberapa solusi berkualitas tinggi: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode studio visual</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IntelliJ</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Atom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teks luhur 3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gerhana</a> </li></ul><br><p>  Dukungan kerja di IDE belum selesai.  Secara khusus, penyelesaian kode dalam editor berbasis RLS tidak secara normal.  Namun, jika Anda terutama menginginkan dukungan untuk jenis, dokumentasi, dan "transisi ke definisi", maka Anda akan puas. </p><br><h3 id="instrumentalnye-proverki-kachestva-koda-tool-lints">  Pemeriksaan kualitas kode instrumental (tool lints) </h3><br><p>  Di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rust 1.30,</a> kami menstabilkan "atribut instrumental" seperti <code>#[rustfmt::skip]</code> .  Di Rust 1.31, kami menstabilkan sesuatu seperti ini: "tool lints" seperti <code>#[allow(clippy::bool_comparison)]</code> .  Ini memungkinkan Anda menentukan ruang nama untuk pemeriksaan agar memperjelas alat apa yang mereka gunakan. </p><br><p>  Jika sebelumnya Anda pernah menggunakan cek Clippy, Anda dapat bermigrasi sebagai berikut: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  #![cfg_attr(feature = "cargo-clippy", allow(bool_comparison))] //  #![allow(clippy::bool_comparison)]</span></span></code> </pre> <br><p>  Anda tidak lagi membutuhkan <code>cfg_attr</code> !  Sekarang Anda juga akan menerima peringatan yang akan membantu Anda beralih menggunakan gaya baru. </p><br><h3 id="dokumentaciya">  Dokumentasi </h3><br><p>  Ada beberapa perbaikan pada Rustdoc tahun ini, dan buku yang sepenuhnya ditulis ulang, The Rust Programming Language, dirilis.  Anda dapat membeli <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salinan kertas dari No Starch Press</a> ! </p><br><p>  Itu sebelumnya disebut "edisi kedua" buku, tetapi karena itu menjadi edisi cetak pertama, ini menyebabkan kebingungan.  Bagaimanapun, edisi cetak direncanakan akan diperbarui secara berkala.  Pada akhirnya, setelah banyak diskusi dengan No Starch, diputuskan untuk memperbarui buku di situs web dengan setiap rilis, dan No Starch akan secara berkala mengambil perubahan dan mencetaknya.  Buku ini laris manis dan menghasilkan uang untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Black Girls Code</a> . </p><br><p>  Anda dapat menemukan versi buku yang baru di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><h3 id="predmetnye-rabochie-gruppy">  Kelompok Kerja Subjek </h3><br><p>  Tahun ini kami mengumumkan pembentukan empat kelompok kerja: </p><br><ul><li>  Layanan jaringan </li><li>  Aplikasi baris perintah </li><li>  Perakitan web </li><li>  Perangkat tertanam </li></ul><br><p>  Kelompok-kelompok itu bekerja sangat keras untuk membuat Rust lebih baik di setiap bidang ini.  Berikut ini beberapa pencapaiannya: </p><br><ul><li>  Layanan jaringan mendesain ulang antarmuka untuk Futures, dan sebagai tambahan menunggu.  Perbaikan ini belum dirilis, tetapi kami sudah dekat dengan itu! </li><li>  Tim CLI bekerja pada perpustakaan dan dokumentasi untuk membuat aplikasi baris perintah lebih baik. </li><li>  WebAssembly telah merilis banyak alat kelas dunia untuk menggunakan Rust dengan wasm. </li><li>  Untuk perangkat tertanam, dimungkinkan untuk mengembangkan ARM pada Rust yang stabil! </li></ul><br><p>  Anda dapat mempelajari lebih lanjut tentang semua ini di situs baru kami! </p><br><h3 id="novyy-veb-sayt">  Situs web baru </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Minggu lalu</a> kami mengumumkan versi baru situs web kami.  Sekarang telah menjadi versi resmi rust-lang.org! </p><br><p>  Untuk membuatnya butuh satu tahun kerja banyak orang.  Meskipun masih banyak yang harus dilakukan sebelum selesai, kami bangga dengan pekerjaan yang dilakukan. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisasi perpustakaan standar </h3><br><p>  Implementasi <code>From</code> Baru telah ditambahkan: </p><br><ul><li>  <code>u8</code> sekarang mengimplementasikan <code>From&lt;NonZeroU8&gt;</code> , serupa untuk jenis numerik lainnya dan yang setara dengan <code>NonZero</code> mereka </li><li>  <code>Option&lt;&amp;T&gt;</code> mengimplementasikan <code>From&lt;&amp;Option&lt;T&gt;&gt;</code> , mirip dengan <code>&amp;mut</code> </li></ul><br><p>  Fungsi-fungsi berikut juga telah distabilkan: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>slice::align_to</code></a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>slice::align_to</code></a> yang bisa berubah </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>slice::chunks_exact</code></a> , dan juga rekan-rekan yang bisa berubah dan <code>r</code> (seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>slice::rchunks_exact_mut</code></a> ) di semua kombinasi </li></ul><br><p>  Lihat <a href="">catatan rilis untuk lebih</a> jelasnya. </p><br><h3 id="uluchsheniya-v-cargo">  Peningkatan Kargo </h3><br><p>  Cargo sekarang akan memuat paket secara paralel menggunakan HTTP / 2. </p><br><p>  Selain itu, karena <code>extern crate</code> sekarang opsional, itu akan membuat frustasi untuk menulis <code>extern crate foo as bar;</code>  untuk mengubah nama ketergantungan.  Karenanya, Anda dapat melakukannya di <code>Cargo.toml</code> dengan cara ini: </p><br><pre> <code class="plaintext hljs">[dependencies] baz = { version = "0.1", package = "foo" }</code> </pre> <br><p>  atau, yang setara: </p><br><pre> <code class="plaintext hljs">[dependencies.baz] version = "0.1" package = "foo"</code> </pre> <br><p>  Paket <code>foo</code> sekarang tersedia sebagai <code>baz</code> untuk digunakan dalam kode Anda. </p><br><p>  Lihat <a href="">catatan rilis untuk lebih</a> jelasnya. </p><br><h2 id="razrabotchiki-1310">  Pengembang 1.31.0 </h2><br><p>  Biasanya, di akhir ulasan, kami berterima kasih kepada <a href="">orang</a> - <a href="">orang yang berkontribusi pada rilis</a> .  Tetapi kali ini, tidak seperti masa lalu, daftar ini tidak sepenuhnya mencakup semua orang yang membantu, dan semua jumlah pekerjaan yang telah dilakukan.  Setiap rilis reguler adalah hasil dari enam minggu kerja, tetapi rilis ini adalah puncak dari tiga tahun upaya yang tercermin dalam berbagai repositori yang dibuat oleh sejumlah besar orang.  Kami senang bekerja sama dengan Anda semua, dan kami menantikan perkembangan berkelanjutan Rust selama tiga tahun ke depan. </p><br><p>  <em>Dari penerjemah: Saya mengucapkan terima kasih khusus kepada anggota komunitas Rustycrate dan secara pribadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@dashadee</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ozkriff</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">humbug</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">mvlabat</a> atas bantuan mereka dalam terjemahan dan proofreading.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432640/">https://habr.com/ru/post/id432640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432628/index.html">@Pythonetc November 2018</a></li>
<li><a href="../id432630/index.html">Segala sesuatu yang Anda ingin tahu tentang pemrosesan permintaan, tetapi malu untuk bertanya</a></li>
<li><a href="../id432634/index.html">Tinjauan Umum Lima Perpustakaan Pengembangan Web HTTP</a></li>
<li><a href="../id432636/index.html">React Tutorial Bagian 1: Ikhtisar Kursus, React, ReactDOM, dan JSX Alasan untuk Popularitas</a></li>
<li><a href="../id432638/index.html">Apa yang Baru di Upsource 2018.2</a></li>
<li><a href="../id432642/index.html">Menggunakan DeviceLock DLP dan Citrix Xen untuk mengontrol email di perangkat seluler</a></li>
<li><a href="../id432644/index.html">Sekilas tentang Intamsys FUNMAT HT Printer 3D Suhu Tinggi</a></li>
<li><a href="../id432646/index.html">Merger top-down dan bottom-up yang seimbang</a></li>
<li><a href="../id432648/index.html">Bagaimana kami memasuki pasar penyedia cloud dan jatuh cinta dengan B2B. Kasus MCS</a></li>
<li><a href="../id432650/index.html">Kumpulan persyaratan untuk proyek perangkat lunak - tanpa pemotongan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>