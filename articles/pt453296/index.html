<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ç üëÇüèΩ üë®üèø Gerenciando a assincronia no PHP: das promessas √†s corotinas üèæ üåù üë®‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O que √© assincronia? Em suma, assincronia significa executar v√°rias tarefas durante um per√≠odo espec√≠fico de tempo. O PHP √© executado em um √∫nico enca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gerenciando a assincronia no PHP: das promessas √†s corotinas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/453296/"><p><img src="https://habrastorage.org/webt/ud/ah/t9/udaht9uat9o8n1cj2y_uwpzhbqw.jpeg"></p><br><p>  O que √© assincronia?  Em suma, assincronia significa executar v√°rias tarefas durante um per√≠odo espec√≠fico de tempo.  O PHP √© executado em um √∫nico encadeamento, o que significa que apenas uma parte do c√≥digo PHP pode ser executada a qualquer momento.  Isso pode parecer uma limita√ß√£o, mas na verdade nos d√° mais liberdade.  Como resultado, n√£o precisamos enfrentar toda a complexidade associada √† programa√ß√£o multithread.  Mas, por outro lado, h√° um conjunto de problemas.  Temos que lidar com assincronia.  Precisamos, de alguma forma, gerenci√°-lo e coorden√°-lo. </p><br><p>  <em>Apresentando a tradu√ß√£o de um artigo do blog do desenvolvedor de back-end Skyeng, Sergey Zhuk.</em> </p><a name="habracut"></a><br><p>  Por exemplo, quando executamos duas solicita√ß√µes HTTP paralelas, dizemos que elas est√£o "executando em paralelo".  Isso geralmente √© f√°cil e simples de fazer, mas surgem problemas quando precisamos simplificar as respostas dessas solicita√ß√µes, por exemplo, quando uma solicita√ß√£o requer dados recebidos de outra solicita√ß√£o.  Assim, √© na administra√ß√£o da assincronia que est√° a maior dificuldade.  Existem v√°rias maneiras diferentes de resolver esse problema. </p><br><blockquote>  Atualmente, o PHP n√£o possui suporte nativo para abstra√ß√µes de alto n√≠vel para controlar a assincronia, e precisamos usar bibliotecas de terceiros, como ReactPHP e Amp.  Nos exemplos deste artigo, eu uso o ReactPHP. </blockquote><br><h3>  Promessas </h3><br><p>  Para entender melhor a id√©ia de promessas, um exemplo da vida real ser√° √∫til.  Imagine que voc√™ est√° no McDonald's e deseja fazer um pedido.  Voc√™ paga por isso e, assim, inicia a transa√ß√£o.  Em resposta a essa transa√ß√£o, voc√™ espera obter um hamb√∫rguer e batatas fritas.  Mas o caixa n√£o devolve imediatamente a comida.  Em vez disso, voc√™ recebe um cheque com o n√∫mero do pedido.  Considere esta verifica√ß√£o como uma promessa para um pedido futuro.  Agora voc√™ pode fazer essa verifica√ß√£o e come√ßar a pensar no seu delicioso almo√ßo.  O hamb√∫rguer e as batatas fritas esperados ainda n√£o est√£o prontos, ent√£o espere at√© que seu pedido seja conclu√≠do.  Assim que o n√∫mero dele aparecer na tela, voc√™ trocar√° o cheque pelo seu pedido.  Estas s√£o as promessas: </p><br><blockquote>  <i>Substitua pelo valor futuro.</i> </blockquote><p>  Uma promessa √© uma representa√ß√£o para um significado futuro, um inv√≥lucro independente do tempo que envolvemos em torno de um significado.  N√£o nos importamos se o valor j√° est√° aqui ou ainda n√£o.  Continuamos a pensar nele da mesma maneira.  Imagine que temos tr√™s solicita√ß√µes HTTP ass√≠ncronas que s√£o executadas "em paralelo", para que sejam conclu√≠das aproximadamente em um ponto no tempo.  Mas queremos, de alguma forma, coordenar e organizar suas respostas.  Por exemplo, queremos imprimir essas respostas assim que recebidas, mas com uma pequena restri√ß√£o: n√£o imprima a segunda resposta at√© que a primeira seja recebida.  Aqui, quero dizer que, se <b>$ promessa1</b> for cumprida, n√≥s a imprimiremos.  Por√©m, se <b>$ promessa2</b> for cumprida primeiro, n√£o a imprimiremos, porque ainda <b>est√°</b> em andamento.  Imagine que estamos tentando adaptar tr√™s solicita√ß√µes competitivas de forma que, para o usu√°rio final, elas pare√ßam uma solicita√ß√£o r√°pida. </p><br><p>  Ent√£o, como podemos resolver esse problema com promessas?  Primeiro de tudo, precisamos de uma fun√ß√£o que retorne uma promessa.  Podemos coletar tr√™s dessas promessas e depois coloc√°-las juntas.  Aqui est√° um c√≥digo falso para isso: </p><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fakeResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url, callable $callback)</span></span></span><span class="hljs-function"> </span></span>{ $callback(<span class="hljs-string"><span class="hljs-string">"response for $url"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $resolve)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($url)</span></span></span><span class="hljs-function"> </span></span>{ fakeResponse($url, $resolve); }); }</code> </pre> <br><p>  Aqui eu tenho duas fun√ß√µes: <br>  <b>fakeResponse (string $ url, callable $ callback)</b> cont√©m uma resposta codificada e permite o retorno especificado com esta resposta; <br>  <b>makeRequest (string $ url)</b> retorna uma promessa que usa <b>fakeResponse ()</b> para indicar que a solicita√ß√£o foi conclu√≠da. </p><br><p>  No c√≥digo do cliente, simplesmente chamamos a fun√ß√£o <b>makeRequest ()</b> e obtemos as promessas: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url1'</span></span>); $promise2 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url2'</span></span>); $promise3 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url3'</span></span>);</code> </pre> <br><p>  Era simples, mas agora precisamos ordenar essas respostas de alguma forma.  Mais uma vez, queremos que a resposta da segunda promessa seja impressa somente ap√≥s a conclus√£o da primeira.  Para resolver esse problema, voc√™ pode criar uma cadeia de promessas: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  No c√≥digo acima, come√ßamos com <b>$ promessa1</b> .  Depois de conclu√≠do, imprimimos seu valor.  N√£o nos importamos quanto tempo leva: menos de um segundo ou uma hora.  Assim que a promessa for conclu√≠da, imprimiremos seu valor.  E ent√£o esperamos por <b>$ promessa2</b> .  E aqui podemos ter dois cen√°rios: </p><br><p>  <b>$ promessa2</b> j√° <b>est√°</b> completo e imediatamente imprimimos seu valor; <br>  <b>O $ promessa2</b> ainda <b>est√°</b> sendo cumprido e estamos aguardando. </p><br><p>  Gra√ßas ao encadeamento de promessas, n√£o precisamos mais nos preocupar se alguma promessa foi ou n√£o cumprida.  Promis n√£o depende de tempo e, portanto, oculta seus estados (no processo, j√° conclu√≠dos ou cancelados). </p><br><p>  √â assim que voc√™ pode controlar a assincronia com promessas.  E parece √≥timo, a cadeia de promessas √© muito mais bonita e compreens√≠vel do que um monte de retornos aninhados. </p><br><h3>  Geradores </h3><br><p>  No PHP, os geradores s√£o suporte de linguagem interna para fun√ß√µes que podem ser pausadas e, em seguida, continuadas.  Quando a execu√ß√£o do c√≥digo dentro desse gerador √© interrompida, parece um pequeno programa bloqueado.  Mas fora deste programa, fora do gerador, todo o resto continua funcionando.  Isso √© toda a magia e poder dos geradores. </p><br><p>  Podemos literalmente pausar o gerador localmente para esperar a promessa ser conclu√≠da.  A id√©ia b√°sica √© usar promessas e geradores juntos.  Eles assumem o controle da assincronia e chamamos de rendimento quando precisamos suspender o gerador.  Aqui est√° o mesmo programa, mas agora estamos conectando geradores e promessas: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { $promise1 = makeRequest('url1'); $promise2 = makeRequest('url2'); $promise3 = makeRequest('url3'); var_dump(yield $promise1); var_dump(yield $promise2); var_dump(yield $promise3); });</span></span></code> </pre> <br><blockquote>  <i>Para esse c√≥digo, eu uso a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">recoilphp / recoil</a> , que permite chamar <b>ReactKernel :: start ()</b> .</i>  <i>Recoil torna poss√≠vel usar geradores PHP para executar promessas ass√≠ncronas do ReactPHP.</i> </blockquote><p>  Aqui, ainda estamos fazendo tr√™s consultas em paralelo, mas agora estamos classificando as respostas usando a palavra-chave <b>yield</b> .  E, novamente, exibimos os resultados no final de cada promessa, mas somente ap√≥s a anterior. </p><br><h3>  Coroutines </h3><br><p>  As corotinas s√£o uma maneira de dividir uma opera√ß√£o ou processo em partes, com alguma execu√ß√£o dentro de cada uma dessas partes.  Como resultado, verifica-se que, em vez de executar toda a opera√ß√£o por vez (o que pode levar a um congelamento percept√≠vel do aplicativo), ela ser√° executada gradualmente at√© que toda a quantidade necess√°ria de trabalho seja conclu√≠da. </p><br><p>  Agora que temos geradores interrupt√≠veis e renov√°veis, podemos us√°-los para escrever c√≥digo ass√≠ncrono com promessas de uma forma s√≠ncrona mais familiar.  Usando geradores e promessas de PHP, voc√™ pode se livrar completamente dos retornos de chamada.  A id√©ia √© que, quando cumprimos uma promessa (usando a chamada de rendimento), uma corrotina a assina.  Corutin faz uma pausa e espera at√© que a promessa seja conclu√≠da (conclu√≠da ou cancelada).  Assim que a promessa for conclu√≠da, a rotina continuar√° a ser cumprida.  Ap√≥s a conclus√£o bem-sucedida, a promessa da rotina envia o valor recebido de volta ao contexto do gerador usando a chamada <b>Generator :: send ($ value)</b> .  Se a promessa falhar, Corutin lan√ßa uma exce√ß√£o atrav√©s do gerador usando a chamada <b>Generator :: throw ()</b> .  Na aus√™ncia de retornos de chamada, podemos escrever c√≥digo ass√≠ncrono que se parece quase com o c√≥digo s√≠ncrono usual. </p><br><p>  <b>Execu√ß√£o sequencial</b> </p><br><p>  Ao usar a corotina, a ordem de execu√ß√£o no c√≥digo ass√≠ncrono agora importa.  O c√≥digo √© executado exatamente no local em que a palavra-chave yield √© chamada e pausada at√© que a promessa seja conclu√≠da.  Considere o seguinte c√≥digo: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { echo 'Response 1: ', yield makeRequest('url1'), PHP_EOL; echo 'Response 2: ', yield makeRequest('url2'), PHP_EOL; echo 'Response 3: ', yield makeRequest('url3'), PHP_EOL; });</span></span></code> </pre> <br><p>  <b>Promise1:</b> ser√° exibido <b>aqui</b> , ent√£o a execu√ß√£o pausa e aguarda.  Assim que a promessa do <b>makeRequest ('url1')</b> for conclu√≠da, imprimimos seu resultado e passamos para a pr√≥xima linha de c√≥digo. </p><br><p>  <b>Tratamento de erros</b> </p><br><p>  O Padr√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Promises / A +</a> Promise declara que cada Promise cont√©m os m√©todos <b>then () e catch ()</b> .  Essa interface permite criar cadeias a partir de promessas e, opcionalmente, capturar erros.  Considere o seguinte c√≥digo: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> operation()-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yetAnotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $result; });</code> </pre> <br><p>  Aqui temos uma cadeia de promessas que passa o resultado de cada promessa anterior para a pr√≥xima.  Mas n√£o h√° bloco <b>catch ()</b> nesta cadeia, n√£o h√° tratamento de erros aqui.  Quando uma promessa em uma cadeia falha, a execu√ß√£o do c√≥digo √© movida para o manipulador de erros mais pr√≥ximo da cadeia.  No nosso caso, isso significa que a promessa pendente ser√° ignorada e quaisquer erros lan√ßados desaparecer√£o para sempre.  Com as corotinas, o tratamento de erros vem √† tona.  Se alguma opera√ß√£o ass√≠ncrona falhar, uma exce√ß√£o ser√° lan√ßada: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">RejectedPromise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... function failedOperation() { return new RejectedPromise(new RuntimeException('Something went wrong')); } ReactKernel::start(function () { try { yield failedOperation(); } catch (Throwable $error) { echo $error-&gt;getMessage() . PHP_EOL; } });</span></span></code> </pre> <br><h3>  Tornando leg√≠vel o c√≥digo ass√≠ncrono </h3><br><p>  Os geradores t√™m um efeito colateral realmente importante que podemos usar para controlar a assincronia e que resolve o problema de legibilidade do c√≥digo ass√≠ncrono.  √â dif√≠cil para n√≥s entender como o c√≥digo ass√≠ncrono ser√° executado devido ao fato de o thread de execu√ß√£o alternar constantemente entre diferentes partes do programa.  No entanto, nosso c√©rebro funciona basicamente de forma s√≠ncrona e de rosca √∫nica.  Por exemplo, planejamos nosso dia de maneira muito consistente: fazer um, depois outro e assim por diante.  Mas o c√≥digo ass√≠ncrono n√£o funciona da maneira que nosso c√©rebro est√° acostumado a pensar.  Mesmo uma simples cadeia de promessas pode n√£o parecer muito leg√≠vel: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Temos que desmont√°-lo mentalmente para entender o que est√° acontecendo l√°.  Portanto, precisamos de um padr√£o diferente para controlar a assincronia.  Em resumo, os geradores fornecem uma maneira de escrever c√≥digo ass√≠ncrono para que pare√ßa s√≠ncrono. </p><br><p>  Promessas e geradores combinam o melhor dos dois mundos: obtemos c√≥digo ass√≠ncrono com √≥timo desempenho, mas, ao mesmo tempo, parece s√≠ncrono, linear e seq√ºencial.  As corotinas permitem ocultar a assincronia, que j√° est√° se tornando um detalhe de implementa√ß√£o.  E nosso c√≥digo ao mesmo tempo parece que nosso c√©rebro est√° acostumado a pensar - linear e sequencialmente. </p><br><p>  Se estamos falando sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ReactPHP</a> , podemos usar a biblioteca RecoilPHP para escrever promessas na forma de corotina.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Amp, as</a> corotinas est√£o dispon√≠veis imediatamente. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt453296/">https://habr.com/ru/post/pt453296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt453280/index.html">D√≠vida t√©cnica</a></li>
<li><a href="../pt453286/index.html">O erro mais caro da minha vida: detalhes sobre o ataque √† porta do cart√£o SIM</a></li>
<li><a href="../pt453290/index.html">Data Science Digest (maio de 2019)</a></li>
<li><a href="../pt453292/index.html">"Um livrinho sobre buracos negros"</a></li>
<li><a href="../pt453294/index.html">Reagir Carregamento lento</a></li>
<li><a href="../pt453298/index.html">Ver√£o: hora de atualizar ... voc√™ mesmo</a></li>
<li><a href="../pt453300/index.html">Jogo 3D Shaders para Iniciantes</a></li>
<li><a href="../pt453302/index.html">A primeira hora de vida com Yandex.Module</a></li>
<li><a href="../pt453304/index.html">Principais benef√≠cios do Zextras PowerStore</a></li>
<li><a href="../pt453306/index.html">Kubernetes vai dominar o mundo. Quando e como?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>