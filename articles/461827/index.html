<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèø ‚èèÔ∏è üß¢ Desarrollo de aplicaciones h√≠bridas PHP / Go con RoadRunner üïµüèΩ ‚ú≥Ô∏è üëèüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La aplicaci√≥n PHP cl√°sica es de un solo subproceso, carga pesada (a menos, por supuesto, que escriba en microframes) y la muerte inevitable del proces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de aplicaciones h√≠bridas PHP / Go con RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461827/"> La aplicaci√≥n PHP cl√°sica es de un solo subproceso, carga pesada (a menos, por supuesto, que escriba en microframes) y la muerte inevitable del proceso despu√©s de cada solicitud ... Dicha aplicaci√≥n es pesada y lenta, pero podemos darle una segunda vida por hibridaci√≥n.  Para acelerar, demonizamos y optimizamos las p√©rdidas de memoria para lograr un mejor rendimiento, presentaremos nuestro propio servidor de aplicaciones PHP Golang RoadRunner para agregar flexibilidad: simplifique el c√≥digo PHP, expanda la pila y comparta la responsabilidad entre el servidor y la aplicaci√≥n.  En esencia, haremos que nuestra aplicaci√≥n funcione como si la estuvi√©ramos escribiendo en Java u otro idioma. <br><br>  Gracias a la hibridaci√≥n, una aplicaci√≥n previamente lenta dej√≥ de sufrir 502 errores bajo carga, el tiempo de respuesta promedio a las solicitudes disminuy√≥, el rendimiento aument√≥ y la implementaci√≥n y el ensamblaje se hicieron m√°s f√°ciles debido a la unificaci√≥n de la aplicaci√≥n y a la eliminaci√≥n de enlaces innecesarios en forma de nginx + php-fpm. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RUm94xCaXMo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Anton Titov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Lachezis</a> ) es CTO y cofundador de SpiralScout LLC con 12 a√±os de experiencia activa en desarrollo comercial en PHP.  En los √∫ltimos a√±os, ha estado implementando activamente Golang en la pila de desarrollo de la compa√±√≠a.  Anton habl√≥ sobre un ejemplo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP Rusia 2019</a> . <br><a name="habracut"></a><br><h2>  Ciclo de vida de la aplicaci√≥n PHP </h2><br>  Esquem√°ticamente, un dispositivo de aplicaci√≥n abstracta con un cierto marco se ve as√≠. <br><br><img src="https://habrastorage.org/webt/mm/va/0d/mmva0djqxjc5l733ikzi738ydry.jpeg"><br><br>  Cuando enviamos una solicitud a un proceso, sucede: <br><br><ul><li>  inicializaci√≥n del proyecto; </li><li>  cargar bibliotecas, marcos y ORM compartidos; </li><li>  cargar bibliotecas requeridas para un proyecto espec√≠fico; </li><li>  enrutamiento; </li><li>  solicitud de enrutamiento a un controlador espec√≠fico; </li><li>  Generaci√≥n de respuesta. </li></ul><br>  Este es el principio de funcionamiento de una aplicaci√≥n cl√°sica <strong>de subproceso √∫nico</strong> con un √∫nico punto de entrada, que despu√©s de cada ejecuci√≥n se destruye por completo o se borra su estado.  Todo el c√≥digo se descarga de la memoria, el trabajador se borra o simplemente restablece su estado. <br><br><h3>  Carga perezosa </h3><br>  La forma est√°ndar y f√°cil de acelerar es la implementaci√≥n del <strong>sistema de carga diferida</strong> o las bibliotecas de carga a pedido. <br><br><img src="https://habrastorage.org/webt/vj/eb/gp/vjebgpv7_a4fuvu64x4g8eqmbke.jpeg"><br><br><blockquote>  Con Lazy-loading solicitamos solo el c√≥digo necesario. </blockquote><br>  Al acceder a un controlador espec√≠fico, solo las bibliotecas necesarias se cargar√°n en la memoria, se procesar√°n y luego se descargar√°n.  Esto le permite <strong>reducir el tiempo promedio de respuesta del proyecto</strong> y facilitar enormemente el proceso de trabajo en el servidor.  En todos los marcos que estamos utilizando actualmente, se implementa el principio de carga diferida. <br><br><h3>  C√°lculos frecuentes de cach√© </h3><br>  El m√©todo es m√°s complicado y se usa activamente, por ejemplo, en el marco de Symfony, los motores de plantillas, los esquemas ORM y el enrutamiento.  Esto no es almacenamiento en cach√© como memcached o Redis para datos de usuario.  Este sistema <strong>calienta partes del c√≥digo de antemano</strong> .  En la primera solicitud, el sistema genera un c√≥digo o un archivo de cach√©, y en solicitudes posteriores, estos c√°lculos, necesarios, por ejemplo, para compilar una plantilla, ya no se realizar√°n. <br><br><img src="https://habrastorage.org/webt/nb/44/f6/nb44f6isfvs6vouultxridabeps.jpeg"><br><br>  El almacenamiento en cach√© <strong>acelera</strong> significativamente <strong>la aplicaci√≥n</strong> , pero al mismo tiempo la <strong>complica</strong> .  Por ejemplo, hay problemas al invalidar el cach√© y actualizar la aplicaci√≥n.  No confunda el cach√© del usuario con el cach√© de la aplicaci√≥n; en uno, los datos cambian con el tiempo, en el otro solo cuando se actualiza el c√≥digo. <br><br><h3>  Procesamiento de solicitudes </h3><br>  Cuando se recibe una solicitud de un servidor PHP-FPM externo, el punto de entrada de la solicitud y la inicializaci√≥n coincidir√°n. <br><br><blockquote>  Resulta que la solicitud del cliente es el estado de nuestro proceso. </blockquote><br>  La √∫nica forma de cambiar este estado es destruir completamente al trabajador y comenzar de nuevo con una nueva solicitud. <br><br><img src="https://habrastorage.org/webt/jc/cr/rb/jccrrb-szkhb6_nfn2zthotuctk.jpeg"><br><br>  Este es un modelo cl√°sico de un solo hilo con sus ventajas. <br><br><ul><li>  Todos los trabajadores al final de la solicitud mueren. </li><li>  P√©rdidas de memoria, condici√≥n de carrera, puntos muertos no son inherentes a PHP.  No te preocupes por eso. </li><li>  El c√≥digo es simple: escribimos, procesamos la solicitud, morimos y seguimos adelante. </li></ul><br>  Por otro lado, para cada solicitud, cargamos completamente el marco, todas las bibliotecas, realizamos algunos c√°lculos, volvemos a compilar las plantillas.  Con cada solicitud en un c√≠rculo producimos muchas manipulaciones y trabajos innecesarios. <br><br><h3>  C√≥mo funciona en el servidor </h3><br>  Lo m√°s probable es que funcionen un mont√≥n de nginx y PHP.  Nginx funcionar√° como un proxy inverso: proporcione a los usuarios parte de las estad√≠sticas y delegue parte de las solicitudes al administrador de procesos PHP PHP-FPM a continuaci√≥n.  El gerente ya plantea un trabajador separado para la solicitud y la procesa.  Despu√©s de eso, el trabajador es destruido o despedido.  A continuaci√≥n, se crea un nuevo trabajador para la siguiente solicitud. <br><br><img src="https://habrastorage.org/webt/8f/lc/fp/8flcfpz6zxemgxlas6avx5aguqa.jpeg"><br><br>  Tal modelo funciona de manera estable: la aplicaci√≥n es casi imposible de eliminar.  Pero con cargas pesadas, la cantidad de trabajo para inicializar y destruir trabajadores afecta el rendimiento del sistema, porque incluso para una simple solicitud GET, a menudo tenemos que extraer un mont√≥n de dependencias y volver a aumentar la conexi√≥n de la base de datos. <br><br><h2>  Acelerando la aplicaci√≥n </h2><br>  ¬øC√≥mo acelerar la aplicaci√≥n cl√°sica despu√©s de introducir cach√© y carga diferida?  ¬øQu√© otras opciones hay? <br><br>  <strong>Dir√≠gete al lenguaje en s√≠</strong> . <br><br><ul><li>  <strong>Utiliza OPCache.</strong>  ¬øCreo que nadie est√° ejecutando PHP en producci√≥n sin OPCache habilitado? </li><li>  Espere <strong>RFC: precarga</strong> .  Le permite precargar un conjunto de archivos en una m√°quina virtual. </li><li>  <strong>JIT</strong> : acelera seriamente la aplicaci√≥n en tareas vinculadas a la CPU.  Desafortunadamente, con las tareas relacionadas con las bases de datos, no ayudar√° mucho. </li></ul><br>  <strong>Usa alternativas</strong> .  Por ejemplo, la m√°quina virtual HHVM de Facebook.  Ejecuta c√≥digo en un entorno m√°s optimizado.  Desafortunadamente, HHVM no es totalmente compatible con la sintaxis de PHP.  Como alternativa, los compiladores kPHP de VK o PeachPie, que convierte completamente el c√≥digo a .NET C #, son una alternativa. <br><br>  <strong>Reescribir completamente a otro idioma.</strong>  Esta es una opci√≥n radical: elimine completamente la carga de c√≥digo entre solicitudes. <br><br>  Puede <b>almacenar</b> completamente <b>el estado de la aplicaci√≥n en la memoria</b> , usar esta memoria activamente para el trabajo y olvidarse del concepto de un trabajador moribundo y borrar completamente la aplicaci√≥n entre solicitudes. <br><br>  Para lograr esto, movemos el punto de entrada, que sol√≠a estar junto con el punto de inicializaci√≥n, profundamente en la aplicaci√≥n. <br><br><h3>  Transferencia de punto de entrada - demonizaci√≥n </h3><br>  Esto est√° creando un bucle infinito en la aplicaci√≥n: solicitud entrante, ejec√∫tela a trav√©s del marco, genere una respuesta para el usuario.  Este es un ahorro importante: todo el arranque, toda la inicializaci√≥n del marco se realiza solo una vez, y luego la aplicaci√≥n procesa varias solicitudes. <br><br><img src="https://habrastorage.org/webt/ce/7k/3l/ce7k3lov0kzcyxc3zyjq008taiy.jpeg"><br><br><h3>  Adaptamos la aplicaci√≥n </h3><br>  Curiosamente, podemos centrarnos en optimizar solo esa parte de la aplicaci√≥n que se ejecutar√° <strong>en tiempo de ejecuci√≥n</strong> : controladores, l√≥gica de negocios.  En este caso, puede abandonar el modelo de carga diferida.  Formaremos parte del proyecto bootstrapping desde el principio, en el momento de la inicializaci√≥n.  C√°lculos preliminares: enrutamiento, plantillas, configuraciones, esquemas ORM inflar√°n la inicializaci√≥n, pero en el futuro ahorrar√°n tiempo de procesamiento para una solicitud espec√≠fica. <br><br><img src="https://habrastorage.org/webt/fz/kj/ft/fzkjftdkc41niwqyrmml-ijjkwy.jpeg"><br><br>  No recomiendo compilar plantillas al descargar un trabajador, pero descargar, por ejemplo, todas las configuraciones es √∫til. <br><br><h3>  Compara modelos </h3><br>  Compare los modelos demonizados (izquierda) y cl√°sicos. <br><br><img src="https://habrastorage.org/webt/zo/en/6r/zoen6rl8zyj6tpn7bghp_ozv61m.jpeg"><br><br>  El modelo demonizado lleva m√°s tiempo desde el momento en que se cre√≥ el proceso hasta el momento en que se devuelve la respuesta al usuario.  La aplicaci√≥n cl√°sica est√° optimizada para una r√°pida creaci√≥n, procesamiento y destrucci√≥n. <br><br>  Sin embargo, todas las solicitudes posteriores despu√©s de calentar el c√≥digo son mucho m√°s r√°pidas.  El marco, la aplicaci√≥n, el contenedor ya est√° en la memoria y listo para aceptar solicitudes y responder r√°pidamente. <br><br><h3>  Problemas del modelo de larga vida. </h3><br>  A pesar de las ventajas, el modelo tiene un conjunto de limitaciones. <br><br>  <strong>Fugas de memoria.</strong>  La aplicaci√≥n permanece en la memoria durante mucho tiempo, y si usa las "curvas" de la biblioteca, las dependencias incorrectas o los estados globales, la memoria comenzar√° a perder.  En alg√∫n momento, aparecer√° un error fatal que romper√° la solicitud del usuario. <br><br>  El problema se resuelve de dos maneras. <br><br><ul><li>  Escriba c√≥digo preciso, use bibliotecas comprobadas. </li><li>  Monitorear activamente a los trabajadores.  Si sospecha que hay p√©rdida de memoria dentro del proceso, c√°mbielo proactivamente a un an√°logo con un l√≠mite inferior, es decir, simplemente a una nueva copia que a√∫n no haya logrado acumular memoria sin limpiar. </li></ul><br>  <strong>Fugas de datos</strong> .  Por ejemplo, si durante una solicitud entrante guardamos al usuario actual del sistema en alguna variable global y olvidamos restablecer esta variable despu√©s de la solicitud, entonces existe la posibilidad de que el siguiente usuario del sistema obtenga accidentalmente acceso a datos que no deber√≠a ver. <br><br>  El problema se resuelve a nivel de arquitectura de la aplicaci√≥n. <br><br><ul><li>  No almacene un usuario activo en un contexto global.  Todos los datos que son espec√≠ficos del contexto de la solicitud se descartan y se borran antes de la pr√≥xima solicitud. </li><li>  Maneje los datos de la sesi√≥n con cuidado.  Sesiones en PHP: con el enfoque cl√°sico, este es un objeto global.  Envu√©lvalo correctamente para que, en una solicitud posterior, se restablezca. </li></ul><br>  <strong>Gesti√≥n de recursos</strong> . <br><br><ul><li>  Supervisar las conexiones a la base de datos.  Si la aplicaci√≥n se bloquea en la memoria durante un mes o dos, entonces la conexi√≥n abierta probablemente se cerrar√° dentro de este tiempo: la base de datos se volver√° a instalar, se reiniciar√° o el firewall restablecer√° la conexi√≥n.  En el nivel de c√≥digo, considere volver a conectar, o despu√©s de cada solicitud, restablecer la conexi√≥n y volver a subirla en la pr√≥xima solicitud. </li><li>  Evite el bloqueo de archivos de larga duraci√≥n.  Si su trabajador escribe alguna informaci√≥n en un archivo, no hay problema.  Pero si este archivo est√° abierto y tiene un bloqueo, entonces ning√∫n otro proceso en su sistema tendr√° acceso hasta que se libere el bloqueo. </li></ul><br><br><h2>  Explore el modelo de larga vida </h2><br>  Considere un modelo de trabajador de larga duraci√≥n, demonizando una aplicaci√≥n, y explore formas de implementarla. <br><br><h3>  Enfoque sin bloqueo </h3><br>  Utilizamos PHP asincr√≥nico: cargamos la aplicaci√≥n una vez en la memoria y procesamos las solicitudes HTTP entrantes dentro de la aplicaci√≥n.  Ahora la <strong>aplicaci√≥n y el servidor son un solo proceso</strong> .  Cuando llega la solicitud, creamos una rutina por separado o, en el bucle de eventos, damos una promesa, la procesamos y se la damos al usuario. <br><br><img src="https://habrastorage.org/webt/v6/js/od/v6jsodvtlxjfy1udzwvl0wa2njk.jpeg"><br><br>  La ventaja innegable del enfoque es el m√°ximo rendimiento.  Tambi√©n es posible utilizar herramientas interesantes, por ejemplo, <strong>configurar WebSocket directamente en su aplicaci√≥n</strong> . <br><br>  Sin embargo, el enfoque <strong>aumenta</strong> significativamente <strong>la complejidad del desarrollo</strong> .  Es necesario instalar ELDO, recuerde que no todos los controladores de bases de datos ser√°n compatibles y que la biblioteca PDO est√° excluida. <br><br>  Para resolver problemas en el caso de demonizaci√≥n con un enfoque sin bloqueo, puede utilizar herramientas conocidas: <strong>ReactPHP</strong> , <strong>amphp</strong> y <strong>Swoole</strong> , un desarrollo interesante en forma de una extensi√≥n C.  Estas herramientas funcionan r√°pidamente, tienen una buena comunidad y buena documentaci√≥n. <br><br><h3>  Enfoque de bloqueo </h3><br>  No levantamos corutinas dentro de la aplicaci√≥n, sino que lo hacemos desde el exterior. <br><br><img src="https://habrastorage.org/webt/ad/ul/eq/adulequ1msa3sb6ae6saah3bu-c.jpeg"><br><br>  Simplemente <strong>recogemos algunos procesos de aplicaci√≥n</strong> , como har√≠a PHP-FPM.  En lugar de transmitir estas solicitudes en forma de un estado de proceso, las entregamos desde el exterior en forma de un protocolo o mensaje. <br><br>  Escribimos el mismo <strong>c√≥digo de subproceso √∫nico</strong> que conocemos, utilizamos las mismas bibliotecas y el mismo PDO.  Todo el trabajo duro de trabajar con sockets, HTTP y otras herramientas se realiza <strong>fuera de la aplicaci√≥n PHP</strong> . <br><br>  De los inconvenientes: debemos <strong>monitorear la memoria</strong> y recordar que la <strong>comunicaci√≥n entre dos procesos diferentes no es gratuita</strong> , pero necesitamos transferir datos.  Esto crear√° una ligera sobrecarga. <br><br>  Para resolver el problema, ya existe una <strong>herramienta PHP-RM</strong> escrita en PHP.  En la biblioteca ReactPHP, tiene <strong>integraci√≥n con varios marcos</strong> .  Sin embargo, PHP-PM es muy <strong>lento, pierde memoria a nivel del servidor</strong> y bajo carga no muestra tanto crecimiento como PHP-FRM. <br><br><h2>  Escribimos nuestro servidor de aplicaciones </h2><br>  Escribimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro servidor de aplicaciones</a> , que es similar a PHP-RM, pero hay m√°s funcionalidades.  ¬øQu√© quer√≠amos del servidor? <br><br>  <strong>Combinar con marcos existentes.</strong>  Nos gustar√≠a tener una integraci√≥n flexible con casi todos los marcos en el mercado.  No tengo ganas de escribir una herramienta que funcione solo en un caso particular en particular. <br><br>  <strong>Diferentes procesos para servidor y aplicaci√≥n</strong> .  Posibilidad de un reinicio en caliente, de modo que cuando se desarrolle localmente, presione F5 y vea el nuevo c√≥digo actualizado, as√≠ como poder expandirlos individualmente. <br><br>  <strong>Alta velocidad y estabilidad</strong> .  A√∫n as√≠, estamos escribiendo un servidor HTTP. <br><br>  <strong>F√°cil extensibilidad</strong> .  Queremos usar el servidor no solo como un servidor HTTP, sino tambi√©n para escenarios individuales como un servidor de cola o un servidor gRPC. <br><br>  <strong>Trabaje fuera de la caja</strong> siempre <strong>que</strong> sea ‚Äã‚Äãposible: Windows, Linux, CPU ARM. <br><br>  Capacidad para escribir <strong>extensiones multiproceso</strong> muy <strong>r√°pidas</strong> espec√≠ficas para nuestra aplicaci√≥n. <br><br>  Como ya entendi√≥, escribiremos en Golang. <br><br><h2>  Servidor RoadRunner </h2><br>  Para crear un servidor PHP, debe resolver 4 problemas principales: <br><br><ul><li>  Establecer comunicaci√≥n entre los procesos de Golang y PHP. </li><li>  Gesti√≥n de procesos: creaci√≥n, destrucci√≥n, seguimiento de trabajadores. </li><li>  Equilibrio de tareas: distribuci√≥n eficiente de tareas a los trabajadores.  Dado que estamos implementando un sistema que bloquea a un trabajador individual para una tarea entrante espec√≠fica en particular, es importante crear un sistema que diga r√°pidamente que el proceso ha terminado el trabajo y est√° listo para aceptar la siguiente tarea. </li><li>  Pila HTTP: env√≠o de datos de solicitud HTTP al trabajador.  Es una tarea simple escribir un punto entrante al que el usuario env√≠a una solicitud, que se pasa a PHP y se devuelve. </li></ul><br><h3>  Variantes de interacci√≥n entre procesos. </h3><br>  Primero, solucionemos el problema de comunicaci√≥n entre los procesos de Golang y PHP.  Tenemos varias formas <br><br>  <strong>Incrustar: incrustar un int√©rprete PHP directamente en Golang.</strong>  Esto es posible, pero requiere un ensamblado PHP personalizado, una configuraci√≥n compleja y un proceso com√∫n para el servidor y PHP.  Como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-php</a> , por ejemplo, donde el int√©rprete PHP est√° integrado en Golang. <br><br>  <strong>Memoria compartida: el uso del espacio de memoria compartida,</strong> <strong>donde los procesos comparten este espacio</strong> .  Se necesita un trabajo minucioso.  Al intercambiar datos, tendr√° que sincronizar el estado manualmente y la cantidad de errores que pueden ocurrir es bastante grande.  La memoria compartida tambi√©n depende del sistema operativo. <br><br><h3>  Escribiendo su protocolo de transporte - Goridge </h3><br>  Seguimos un camino simple que se utiliza en casi todas las soluciones en sistemas Linux: utilizamos el protocolo de transporte.  Est√° <strong>escrito en la parte superior de los TUBOS est√°ndar y ENCHUFES UNIX / TCP</strong> . <br><br>  Tiene la capacidad de transferir datos en ambas direcciones, detectar errores y tambi√©n etiquetar solicitudes y colocar encabezados.  Un matiz importante para nosotros es la capacidad de implementar el protocolo sin dependencias tanto del lado de PHP como de Golang, sin extensiones C en un lenguaje puro. <br><br>  Como con cualquier protocolo, la base es un paquete de datos.  En nuestro caso, el paquete tiene un encabezado fijo de 17 bytes. <br><br><img src="https://habrastorage.org/webt/wb/_h/g_/wb_hg_qtkmoxe74sthy12rhtzms.jpeg"><br><br>  El primer byte se asigna para determinar el tipo de paquete.  Esto puede ser una secuencia o una bandera que indica el tipo de serializaci√≥n de datos.  Luego, dos veces empaquetamos el tama√±o de los datos en Little Endian y Big Endian.  Utilizamos este legado para detectar errores de transmisi√≥n.  Si vemos que el tama√±o de los datos empaquetados en dos pedidos diferentes no coincide, lo m√°s probable es que se haya producido un error de transferencia de datos.  Luego se transmiten los datos. <br><br><img src="https://habrastorage.org/webt/bt/rb/dr/btrbdre8cwionih8m6e7yze2crw.jpeg"><br><br>  En la tercera versi√≥n del paquete, eliminaremos ese legado, presentaremos un enfoque m√°s cl√°sico con una suma de comprobaci√≥n y tambi√©n agregaremos la capacidad de usar este protocolo con procesos PHP as√≠ncronos. <br><br>  Para implementar el protocolo en Golang y PHP, utilizamos herramientas est√°ndar. <br><br>  <strong>En Golang:</strong> bibliotecas de codificaci√≥n / binarias y bibliotecas io y net para trabajar con canalizaciones est√°ndar y sockets UNIX / TCP. <br><br>  <strong>En PHP:</strong> la funci√≥n familiar para trabajar con paquetes de datos binarios / desempaquetar y las extensiones de flujos y sockets para tuber√≠as y sockets. <br><br>  Un <strong>efecto secundario</strong> interesante surgi√≥ durante la implementaci√≥n.  Lo integramos con la biblioteca est√°ndar de Golang net / rpc, que nos permite llamar al c√≥digo de servicio de Golang directamente en la aplicaci√≥n. <br><br>  Escribimos un servicio: <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  sample type  struct{} // Hi returns greeting message. func (a *App) Hi(name string, r *string) error { *r = fmt.Sprintf("ll, %s!", name) return nil }</span></span></code> </pre> <br>  Se llama una peque√±a cantidad de c√≥digo desde la aplicaci√≥n: <br><br><pre> <code class="go hljs">&lt;?php use Spiral\Goridge; require <span class="hljs-string"><span class="hljs-string">"vendor/autoload.php"</span></span>; $rpc = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\RPC( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\SocketRelay(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">6001</span></span>) ); echo $rpc-&gt;call(<span class="hljs-string"><span class="hljs-string">"App.Hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Antony"</span></span>);</code> </pre> <br><h3>  PHP Process Manager </h3><br>  La siguiente parte del servidor es la gesti√≥n de los trabajadores de PHP. <br><img src="https://habrastorage.org/webt/vt/jy/tk/vtjytk9effas7jkgjgadvbek_zw.jpeg"><br><br>  Worker es un proceso PHP que observamos constantemente desde Golang.  Recopilamos el registro de sus errores en el archivo STDERR, nos comunicamos con el trabajador a trav√©s del protocolo de transporte Goridge y recopilamos estad√≠sticas sobre el consumo de memoria, la ejecuci√≥n de tareas y el bloqueo. <br><br>  La implementaci√≥n es simple: esta es la funcionalidad est√°ndar de os / exec, runtime, sync, atomic.  Para crear trabajadores usamos <strong>Worker Factory</strong> . <br><img src="https://habrastorage.org/webt/wq/kr/tt/wqkrtt0n0xxvhdnxuvx_4f2deiy.jpeg"><br><br>  ¬øPor qu√© la f√°brica de trabajadores?  Porque queremos comunicarnos tanto en tuber√≠as est√°ndar como en enchufes.  En este caso, el proceso de inicializaci√≥n es ligeramente diferente.  Al crear un trabajador que se comunica por canalizaci√≥n, podemos crearlo de inmediato y enviar datos directamente.  En el caso de los sockets, debe crear un trabajador, esperar hasta que llegue al sistema, hacer un apret√≥n de manos PID y solo entonces continuar trabajando. <br><br><h3>  Balanceador de tareas </h3><br>  La tercera parte del servidor es la m√°s importante para el rendimiento. <br><br>  Para la implementaci√≥n, utilizamos la funcionalidad est√°ndar de Golang, un <strong>canal protegido</strong> .  En particular, creamos varios trabajadores y los colocamos en este canal como una pila LIFO. <br><img src="https://habrastorage.org/webt/bm/po/f4/bmpof4s5-owl810px69ectqiw_i.jpeg"><br>  Cuando recibimos tareas del usuario, enviamos una solicitud a la pila LIFO y solicitamos emitir el primer trabajador libre.  Si el trabajador no puede ser asignado por un cierto per√≠odo de tiempo, el usuario recibe un error del tipo "Error de tiempo de espera".  Si el trabajador est√° asignado, se obtiene de la pila, se bloquea, despu√©s de lo cual recibe la tarea del usuario. <br><img src="https://habrastorage.org/webt/cm/2o/cq/cm2ocqak94ubao7tk8vxnglfyyo.jpeg"><br>  Una vez procesada la tarea, la respuesta se devuelve al usuario y el trabajador se encuentra al final de la pila.  Est√° listo para realizar la siguiente tarea nuevamente. <br><img src="https://habrastorage.org/webt/oj/f_/l4/ojf_l4ipil8fcslpyherhsg02la.jpeg"><br>  Si se produce un error, el usuario recibir√° un error, ya que el trabajador ser√° destruido.  Pedimos a Worker Pool y Worker Factory que creen un proceso id√©ntico y lo reemplacen en la pila.  Esto permite que el sistema funcione incluso en caso de errores fatales simplemente recreando a los trabajadores por analog√≠a con PHP-FPM. <br><img src="https://habrastorage.org/webt/qs/li/dq/qslidqche8glb-q5pucwfwnpogw.jpeg"><br><br>  Como resultado, result√≥ implementar un peque√±o sistema que funciona muy r√°pidamente: <strong>200 ns para la asignaci√≥n de trabajadores</strong> .  Es capaz de funcionar incluso en caso de errores fatales.  Cada trabajador en un punto en el tiempo procesa solo una tarea, lo que nos permite utilizar el <strong>enfoque cl√°sico de bloqueo</strong> . <br><br><h3>  Monitoreo proactivo </h3><br>  Una parte separada tanto del administrador de procesos como del equilibrador de tareas es el sistema de monitoreo proactivo. <br><img src="https://habrastorage.org/webt/83/zq/ep/83zqepdmerd6ozakntcmv33hnus.jpeg"><br><br>  Este es un sistema que una vez por segundo sondea a los trabajadores y monitorea los indicadores: analiza la cantidad de memoria que consumen, la cantidad de memoria que contienen, si est√°n inactivos.  Adem√°s del seguimiento, el sistema supervisa las p√©rdidas de memoria.  Si el trabajador excede un cierto l√≠mite, lo veremos y lo eliminaremos cuidadosamente del sistema antes de que ocurra una fuga fatal. <br><br><h3>  Pila HTTP </h3><br>  La √∫ltima y simple parte. <br><img src="https://habrastorage.org/webt/hl/cc/7e/hlcc7ehfob5vhc_zjse_em8e0eg.jpeg"><br>  <strong>C√≥mo se implementa:</strong> <br><br><ul><li>  plantea un punto HTTP en el lado de Golang; </li><li>  recibimos una solicitud; </li><li>  convertir al formato PSR-7; </li><li>  enviar la solicitud al primer trabajador libre; </li><li>  Desempaquete la solicitud en un objeto PSR-7; </li><li>  procesamos </li><li>  Generamos la respuesta. </li></ul><br>  Para la implementaci√≥n, utilizamos la <strong>biblioteca</strong> est√°ndar de <strong>Golang NET / HTTP</strong> .  Esta es una famosa biblioteca con muchas extensiones.  Capaz de funcionar tanto sobre HTTPS como sobre el protocolo HTTP / 2. <br><br>  En el lado de PHP, utilizamos el est√°ndar PSR-7 <strong>.</strong>  Es un <strong>marco independiente</strong> con muchas extensiones y Middlewares.  El <strong>dise√±o del</strong> PSR-7 es <strong>inmutable</strong> , lo que encaja bien con el concepto de aplicaciones de larga duraci√≥n y evita errores de consulta globales. <br><br>  Ambas estructuras en Golang y PSR-7 son similares, lo que ahorr√≥ significativamente tiempo para asignar una solicitud de un idioma a otro. <br><br>  Para iniciar el servidor se requiere un <strong>enlace m√≠nimo</strong> : <br><br><pre> <code class="go hljs">http: address: <span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> workers: command: <span class="hljs-string"><span class="hljs-string">"php psr-worker.php"</span></span> pool: numWorkers: <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Adem√°s, desde la versi√≥n 1.3.0 se puede omitir la √∫ltima parte de la configuraci√≥n. <br><br>  Descargue el archivo binario del servidor, p√≥ngalo en el contenedor Docker o en la carpeta del proyecto.  Alternativamente, a nivel mundial, escribimos un peque√±o archivo de configuraci√≥n que describe qu√© pod vamos a escuchar, qu√© trabajador es el punto de entrada y cu√°ntos se requieren. <br><br>  En el lado de PHP, escribimos un ciclo primario que recibe una solicitud PSR-7, la procesa y devuelve una respuesta o un error al servidor. <br><br><pre> <code class="go hljs">while ($req = $psr7-&gt;acceptRequest()) { try { $resp = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> \Zend\Diactoros\Response(); $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>); $psr7-&gt;respond($resp); } catch (\Throwable $e) { $psr7-&gt;getWorker()-&gt;error((<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)$e); } }</code> </pre> <br>  <strong>Asamblea</strong>  Para implementar el servidor, elegimos una arquitectura con un enfoque de componentes.  Esto permite ensamblar el servidor para las necesidades del proyecto, agregando o eliminando piezas individuales seg√∫n los requisitos de la aplicaci√≥n. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { rr.Container.Register(env.ID, &amp;env.Service{}) rr.Container.Register(rpc.ID, &amp;rpc.Service{}) rr.Container.Register(http.ID, &amp;http.Service{}) rr.Container.Register(static.ID, &amp;static.Service{}) rr.Container.Register(limit.ID, &amp;limit.Service{} <span class="hljs-comment"><span class="hljs-comment">// you can register additional commands using cmd.CLI rr.Execute() }</span></span></code> </pre> <br><h2>  Casos de uso </h2><br>  Considere las opciones para usar el servidor y modificar la estructura.  Para comenzar, considere la canalizaci√≥n cl√°sica: el trabajo del servidor con las solicitudes. <br><br><h3>  Modularidad </h3><br>  El servidor recibe la solicitud a un punto HTTP y la pasa a trav√©s de un conjunto de Middleware, que est√°n escritos en Golang.  Una solicitud entrante se convierte en una tarea que el trabajador comprende.  El servidor entrega la tarea al trabajador y la devuelve. <br><br><img src="https://habrastorage.org/webt/zz/v5/ak/zzv5akvapzklanxdlzunxdq-xpu.jpeg"><br><br>  Al mismo tiempo, el trabajador, utilizando el protocolo Goridge, se comunica con el servidor, monitorea su estado y le transfiere datos. <br><br><h3>  Middleware en Golang: Autorizaci√≥n </h3><br>  Esta es la primera cosa que hacer.  En nuestra aplicaci√≥n, escribimos Middleware para <strong>autorizar al usuario por token JWT</strong> .  Middleware est√° escrito de la misma manera para cualquier otro tipo de autorizaci√≥n.  Una implementaci√≥n muy banal y simple es escribir Rate-Limiter o Circuit-Breaker. <br><br><img src="https://habrastorage.org/webt/on/zg/ro/onzgroqwxc7umuy-y2xfv9s7dqe.jpeg"><br><br>  <strong>La autorizaci√≥n es r√°pida</strong> .  Si la solicitud no es v√°lida, simplemente no la env√≠e a la aplicaci√≥n PHP y no desperdicie recursos en el procesamiento de tareas in√∫tiles. <br><br><h3>  Monitoreo </h3><br>  El segundo caso de uso.  Podemos integrar el sistema de monitoreo directamente en Golang Middleware.  Por ejemplo, Prometheus, para recopilar estad√≠sticas sobre la velocidad de los puntos de respuesta, la cantidad de errores. <br><br><img src="https://habrastorage.org/webt/rz/_o/hz/rz_ohzkiz6bwjoebzqu2qt4e6dc.jpeg"><br><br>  Tambi√©n puede <strong>combinar el monitoreo con m√©tricas espec√≠ficas de la aplicaci√≥n</strong> (disponible como est√°ndar con 1.4.5).  Por ejemplo, podemos enviar el n√∫mero de solicitudes a la base de datos o el n√∫mero de solicitudes espec√≠ficas procesadas al servidor Golang, y luego a Prometheus. <br><br><h3>  Rastreo distribuido y registro </h3><br>  Escribimos Middleware con un administrador de procesos.  En particular, podemos conectarnos al sistema en tiempo real para monitorear registros y <strong>recopilar todos los registros en una base de datos central</strong> , lo cual es √∫til al escribir aplicaciones distribuidas. <br><br><img src="https://habrastorage.org/webt/lf/ir/cd/lfircdprhx6nqetmadblqftvbu4.jpeg"><br><br>  Tambi√©n podemos <strong>etiquetar solicitudes</strong> , darles una identificaci√≥n espec√≠fica y pasar esta identificaci√≥n a todos los servicios posteriores o sistemas de comunicaci√≥n entre ellos.  Como resultado, podemos construir un <strong>rastreo distribuido</strong> y ver c√≥mo funcionan los registros de la aplicaci√≥n. <br><br><h3>  Grabe su historial de consultas </h3><br>  Este es un peque√±o m√≥dulo que registra todas las solicitudes entrantes y las almacena en una base de datos externa.  El m√≥dulo le permite realizar solicitudes de repetici√≥n en el proyecto e implementar un sistema de prueba autom√°tico, un sistema de prueba de carga o simplemente verificar el funcionamiento de la API. <br><br><img src="https://habrastorage.org/webt/ex/q3/kg/exq3kgpym1uf6tjcfwysjk1so00.jpeg"><br><br>  ¬øC√≥mo implementamos el m√≥dulo? <br><br>  <strong>Procesamos parte de las solicitudes de Golang</strong> .  Escribimos Middleware en Golang y podemos enviar parte de las solicitudes a Handler, que tambi√©n est√° escrito en Golang.  Si alg√∫n punto de la aplicaci√≥n es preocupante en t√©rminos de rendimiento, lo reescribimos en Golang y arrastramos la pila de un idioma a otro. <br><br><img src="https://habrastorage.org/webt/q0/zf/qn/q0zfqnzddo_mn7h-d779cg9ganm.jpeg"><br><br>  <strong>Estamos escribiendo un servidor WebSocket</strong> .  Implementar un servidor WebSocket o un servidor de notificaciones push se est√° convirtiendo en una tarea trivial. <br><br><ul><li>  Servicio de Golang a nivel de servidor. </li><li>  Para la comunicaci√≥n usamos Goridge. </li><li>  Capa de servicio delgada en PHP. </li><li>  Implementamos el servidor de notificaciones. </li></ul><br>  Recibimos una solicitud y generamos una conexi√≥n WebSocket.  Si la aplicaci√≥n necesita enviar alg√∫n tipo de notificaci√≥n al usuario, lanza este mensaje a trav√©s del protocolo RPC al servidor WebSocket. <br><br><img src="https://habrastorage.org/webt/go/ta/fv/gotafvsepr8u8_r_lvfdjpff2rg.jpeg"><br><br>  <strong>Gestiona tu entorno PHP.</strong>  Al crear un grupo de trabajadores, RoadRunner tiene control total sobre el estado de las variables de entorno y le permite cambiarlas a su gusto.  Si estamos escribiendo una aplicaci√≥n distribuida grande, podemos usar una sola fuente de datos de configuraci√≥n y conectarla como un sistema para configurar el entorno.  Si planteamos un conjunto de servicios, todos estos servicios afectar√°n a un solo sistema, se configurar√°n y luego funcionar√°n.  Esto puede simplificar enormemente la implementaci√≥n, as√≠ como deshacerse de los archivos .env. <br><br><img src="https://habrastorage.org/webt/iv/m5/03/ivm503pht02yug6do6-od3pyt6i.jpeg"><br><br>  Curiosamente, las variables env que est√°n disponibles dentro del trabajador no son globales dentro del sistema.  Esto mejora ligeramente la seguridad del contenedor. <br><br><h3>  Integraci√≥n de la biblioteca de Golang en PHP </h3><br>  Utilizamos esta opci√≥n en el sitio web oficial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RoadRunner</a> .  Esta es una integraci√≥n de una base de datos casi completa <strong>con la b√∫squeda de texto completo BleveSearch</strong> dentro del servidor. <br><br><img src="https://habrastorage.org/webt/5a/ba/uc/5abaucml3dmvxqpns_h7bug_ldi.jpeg"><br><br>  Indexamos las p√°ginas de documentaci√≥n: las colocamos en Bolt DB, despu√©s de lo cual realizamos una b√∫squeda de texto completo sin una base de datos real como MySQL y sin un cl√∫ster de b√∫squeda como Elasticsearch.  El resultado fue un peque√±o proyecto donde parte de la funcionalidad est√° en PHP, pero la b√∫squeda est√° en Golang. <br><br><h3>  Implementando Funciones Lambda </h3><br>  Puede ir m√°s all√° y <strong>deshacerse por completo de la capa HTTP.</strong>  En este caso, implementar, por ejemplo, las funciones de Lambda es una tarea simple. <br><br><img src="https://habrastorage.org/webt/ty/ie/dy/tyiedyrsetx2l5wljnllkbju0xg.jpeg"><br><br>  Para la implementaci√≥n, utilizamos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiempo</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecuci√≥n</a> est√°ndar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AWS</a> para la funci√≥n Lambda.  Escribimos un peque√±o enlace, cortamos completamente los servidores HTTP y enviamos los datos en formato binario a los trabajadores.  Tambi√©n tenemos acceso a la configuraci√≥n del entorno, que nos permite escribir funciones que se configuran directamente desde el panel de administraci√≥n de Amazon. <br><br>  Los trabajadores est√°n en memoria durante toda la vida del proceso, y la funci√≥n Lambda despu√©s de la solicitud inicial permanece en la memoria durante 15 minutos.  En este momento, el c√≥digo no se carga y responde r√°pidamente.  En las pruebas sint√©ticas, recibimos hasta <strong>0.5 ms por cada solicitud entrante</strong> . <br><br><h3>  gRPC para PHP </h3><br>  La opci√≥n m√°s dif√≠cil es reemplazar la capa HTTP con la capa gRPC.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete est√° disponible en GitHub</a> . <br><img src="https://habrastorage.org/webt/jh/u5/cg/jhu5cgv7-cdj6wf4ifukhqxnd0u.jpeg"><br><br>  Podemos enviar por proxy todas las solicitudes de Protobuf entrantes a una aplicaci√≥n PHP subordinada, all√≠ se pueden desempaquetar, procesar y responder.  Podemos escribir c√≥digo tanto en PHP como en Golang, combinando y transfiriendo funcionalidad de una pila a otra.  El servicio es compatible con Middleware.  Tanto la aplicaci√≥n independiente como junto con HTTP pueden funcionar. <br><br><h3>  Servidor de colas </h3><br>  La √∫ltima y m√°s interesante opci√≥n es la implementaci√≥n del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servidor de colas</a> . <br><img src="https://habrastorage.org/webt/rn/ch/1i/rnch1i0ieekunszmsv_ppegtwbu.jpeg"><br><br>  En el lado de PHP, todo lo que hacemos es obtener una carga binaria, desempacarla, hacer el trabajo y decirle al servidor sobre el √©xito.  En el lado de Golang, estamos totalmente comprometidos en la gesti√≥n de las conexiones con los corredores.  Puede ser RabbitMQ, Amazon SQS o Beanstalk. <br><br>  En el lado de Golang, implementamos el " <strong>cierre agraciado" de los</strong> trabajadores.  Podemos esperar bellamente la implementaci√≥n de la "conexi√≥n duradera": si se pierde la conexi√≥n con el intermediario, el servidor espera un momento utilizando la "estrategia de retroceso", levanta la conexi√≥n y la aplicaci√≥n ni siquiera lo nota. <br><br>  Podemos procesar estas solicitudes en PHP y Golang, y ponerlas en cola en ambos lados: <br><br><ul><li>  desde PHP a trav√©s del protocolo Goridge Goridge RPC; </li><li>  de Golang: comunicaci√≥n con la biblioteca SDK. </li></ul><br>  Si la carga √∫til cae, entonces no cae todo el Consumidor, sino solo un proceso separado.  El sistema lo eleva inmediatamente, la tarea se env√≠a al siguiente trabajador.  Esto le permite realizar tareas sin parar. <br><br>  Implementamos uno de los corredores directamente en la memoria del servidor y utilizamos la funcionalidad Golang.  Esto nos permite escribir una aplicaci√≥n usando colas antes de elegir la pila final.  Levantamos la aplicaci√≥n localmente, la iniciamos y tenemos colas que funcionan en la memoria y se comportan de la misma manera que se comportar√≠an en RabbitMQ, Amazon SQS o Beanstalk. <br><br>  Cuando se usan dos idiomas en un paquete h√≠brido, vale la pena recordar c√≥mo separarlos. <br><br><h3>  Dominios de dominio separados </h3><br><blockquote>  Golang es un lenguaje multiproceso y r√°pido que es adecuado para escribir l√≥gica de infraestructura y supervisi√≥n de usuarios y l√≥gica de autorizaci√≥n. </blockquote><br>  Tambi√©n es √∫til para <strong>implementar controladores personalizados</strong> para acceder a las fuentes de datos; estas son colas, por ejemplo, Kafka, Cassandra. <br><br><blockquote>  PHP es un gran lenguaje para escribir l√≥gica de negocios. </blockquote><br>  Este es un buen sistema para renderizar HTML, ORM y trabajar con la base de datos. <br><br><h2>  Herramienta de comparaci√≥n </h2><br>  Hace varios meses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Habr√© compar√≥</a> PHP-FPM, PHP-PM, React-PHP, Roadrunner y otras herramientas.  El punto de referencia se llev√≥ a cabo en un proyecto con Symfony 4 real. <br><br>  RoadRunner bajo carga muestra buenos resultados y est√° por delante de todos los servidores.  En comparaci√≥n con PHP-FPM, el rendimiento es 6-8 veces m√°s. <br><img src="https://habrastorage.org/webt/ny/tx/yl/nytxylmddyrmglxjoe8hos7tnka.jpeg"><br><br>  En el mismo punto de referencia, RoadRunner no perdi√≥ una sola solicitud, todo se resolvi√≥ al 100%.  Desafortunadamente, React-PHP perdi√≥ 8‚Äì9 solicitudes bajo cargas, esto es inaceptable.  Nos gustar√≠a que el servidor no se bloquee y funcione de manera estable. <br><img src="https://habrastorage.org/webt/7b/fl/gq/7bflgqhrq1f-y0jixnud_k1ckdg.jpeg"><br><br>  Desde la publicaci√≥n de RoadRunner en acceso p√∫blico en GitHub, hemos recibido m√°s de 30,000 instalaciones.  La comunidad nos ha ayudado a escribir un conjunto espec√≠fico de extensiones, mejoras y creemos que la soluci√≥n tiene derecho a la vida. <br><br>  RoadRunner es bueno si desea <strong>acelerar significativamente la aplicaci√≥n, pero a√∫n no est√° listo para saltar a PHP asincr√≥nico</strong> .  Este es un compromiso que requerir√° una cierta cantidad de esfuerzo, pero no tan significativo como una reescritura completa de la base del c√≥digo. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tome RoadRunner</a> si desea tener <strong>m√°s control sobre el ciclo de vida de PHP</strong> , <strong>si no hay suficientes capacidades de PHP,</strong> por ejemplo, para el sistema de colas o Kafka, y cuando su popular biblioteca de Golang resuelve su problema, que no est√° en PHP, y la escritura lleva tiempo, que usted tampoco tiene. <br><br><h2>  Resumen </h2><br>  Lo que obtuvimos al escribir este servidor y usarlo en nuestra infraestructura de producci√≥n. <br><br><ul><li>  <strong>Aumentaron la velocidad de reacci√≥n de los puntos de aplicaci√≥n en 4 veces en</strong> comparaci√≥n con PHP-FPM. </li><li>  <strong>Se deshizo completamente de 502 errores bajo cargas</strong> .  En las cargas m√°ximas, el servidor solo espera un poco m√°s y responde como si no hubiera cargas. </li><li>  Despu√©s de optimizar las p√©rdidas de memoria, los trabajadores <strong>permanecen en la memoria hasta por 2 meses</strong> .  Esto ayuda al escribir aplicaciones distribuidas, ya que todas las solicitudes entre servicios ya est√°n en cach√© a nivel de socket. </li><li>  <strong>Usamos Keep-Alive.</strong>  Esto acelera significativamente la comunicaci√≥n entre un sistema distribuido. </li><li>  Dentro de la infraestructura real, <strong>colocamos todo en el Alpine Docker en Kubernetes</strong> .  El sistema de implementaci√≥n y construcci√≥n del proyecto ahora es m√°s f√°cil.  Todo lo que se requiere es construir una compilaci√≥n RoadRunner personalizada para el proyecto, ponerla en el proyecto Docker, completar la imagen de Docker y luego subir tranquilamente nuestro pod a Kubernetes. </li><li>  Seg√∫n el tiempo real de uno de los proyectos a puntos individuales que no tienen acceso a la base de datos, el <strong>tiempo de respuesta promedio es de 0,33 ms</strong> . </li></ul><br><blockquote>  La pr√≥xima conferencia profesional para desarrolladores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP PHP Rusia</a> solo el pr√≥ximo a√±o.  Por ahora, ofrecemos lo siguiente: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Preste</a> atenci√≥n a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GolangConf</a> si est√° interesado en la parte Go y desea conocer m√°s detalles o escuchar argumentos a favor de cambiar a este idioma.  Si est√° listo para compartir su experiencia, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">env√≠e res√∫menes</a> . </li><li>  Participe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> en Mosc√∫, si todo es importante para usted que est√° asociado con un alto rendimiento, env√≠e un informe antes del 7 de septiembre o reserve una entrada. </li><li>  Suscr√≠base al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bolet√≠n</a> y al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de telegramas</a> para recibir una invitaci√≥n a PHP Rusia 2020 antes que otros. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461827/">https://habr.com/ru/post/461827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461815/index.html">Una revoluci√≥n en el dise√±o de las fuentes de alimentaci√≥n para computadoras hace medio siglo</a></li>
<li><a href="../461817/index.html">CMake y C ++: hermanos para siempre</a></li>
<li><a href="../461819/index.html">¬øPor qu√© el dise√±o simple de un sitio web es mejor cient√≠ficamente?</a></li>
<li><a href="../461821/index.html">La nueva inmunoterapia elimin√≥ todos los tumores en una mujer con c√°ncer de seno metast√°sico</a></li>
<li><a href="../461823/index.html">Cuatro reglas mejoradas para el dise√±o de software</a></li>
<li><a href="../461829/index.html">TCP vs UDP o el futuro de los protocolos de red</a></li>
<li><a href="../461831/index.html">StealthWatch: implementaci√≥n y personalizaci√≥n. Parte 2</a></li>
<li><a href="../461833/index.html">No te pierdas en tres pinos: una representaci√≥n egoc√©ntrica del entorno.</a></li>
<li><a href="../461835/index.html">C√≥mo los gr√°ficos de Gantt simplifican y potencian la gesti√≥n de proyectos</a></li>
<li><a href="../461841/index.html">PVS-Studio investig√≥ el motor de bala del Red Dead Redemption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>