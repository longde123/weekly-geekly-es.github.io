<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧘🏿 ⏏️ 🧢 Desarrollo de aplicaciones híbridas PHP / Go con RoadRunner 🕵🏽 ✳️ 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La aplicación PHP clásica es de un solo subproceso, carga pesada (a menos, por supuesto, que escriba en microframes) y la muerte inevitable del proces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Desarrollo de aplicaciones híbridas PHP / Go con RoadRunner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461827/"> La aplicación PHP clásica es de un solo subproceso, carga pesada (a menos, por supuesto, que escriba en microframes) y la muerte inevitable del proceso después de cada solicitud ... Dicha aplicación es pesada y lenta, pero podemos darle una segunda vida por hibridación.  Para acelerar, demonizamos y optimizamos las pérdidas de memoria para lograr un mejor rendimiento, presentaremos nuestro propio servidor de aplicaciones PHP Golang RoadRunner para agregar flexibilidad: simplifique el código PHP, expanda la pila y comparta la responsabilidad entre el servidor y la aplicación.  En esencia, haremos que nuestra aplicación funcione como si la estuviéramos escribiendo en Java u otro idioma. <br><br>  Gracias a la hibridación, una aplicación previamente lenta dejó de sufrir 502 errores bajo carga, el tiempo de respuesta promedio a las solicitudes disminuyó, el rendimiento aumentó y la implementación y el ensamblaje se hicieron más fáciles debido a la unificación de la aplicación y a la eliminación de enlaces innecesarios en forma de nginx + php-fpm. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RUm94xCaXMo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Anton Titov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Lachezis</a> ) es CTO y cofundador de SpiralScout LLC con 12 años de experiencia activa en desarrollo comercial en PHP.  En los últimos años, ha estado implementando activamente Golang en la pila de desarrollo de la compañía.  Anton habló sobre un ejemplo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP Rusia 2019</a> . <br><a name="habracut"></a><br><h2>  Ciclo de vida de la aplicación PHP </h2><br>  Esquemáticamente, un dispositivo de aplicación abstracta con un cierto marco se ve así. <br><br><img src="https://habrastorage.org/webt/mm/va/0d/mmva0djqxjc5l733ikzi738ydry.jpeg"><br><br>  Cuando enviamos una solicitud a un proceso, sucede: <br><br><ul><li>  inicialización del proyecto; </li><li>  cargar bibliotecas, marcos y ORM compartidos; </li><li>  cargar bibliotecas requeridas para un proyecto específico; </li><li>  enrutamiento; </li><li>  solicitud de enrutamiento a un controlador específico; </li><li>  Generación de respuesta. </li></ul><br>  Este es el principio de funcionamiento de una aplicación clásica <strong>de subproceso único</strong> con un único punto de entrada, que después de cada ejecución se destruye por completo o se borra su estado.  Todo el código se descarga de la memoria, el trabajador se borra o simplemente restablece su estado. <br><br><h3>  Carga perezosa </h3><br>  La forma estándar y fácil de acelerar es la implementación del <strong>sistema de carga diferida</strong> o las bibliotecas de carga a pedido. <br><br><img src="https://habrastorage.org/webt/vj/eb/gp/vjebgpv7_a4fuvu64x4g8eqmbke.jpeg"><br><br><blockquote>  Con Lazy-loading solicitamos solo el código necesario. </blockquote><br>  Al acceder a un controlador específico, solo las bibliotecas necesarias se cargarán en la memoria, se procesarán y luego se descargarán.  Esto le permite <strong>reducir el tiempo promedio de respuesta del proyecto</strong> y facilitar enormemente el proceso de trabajo en el servidor.  En todos los marcos que estamos utilizando actualmente, se implementa el principio de carga diferida. <br><br><h3>  Cálculos frecuentes de caché </h3><br>  El método es más complicado y se usa activamente, por ejemplo, en el marco de Symfony, los motores de plantillas, los esquemas ORM y el enrutamiento.  Esto no es almacenamiento en caché como memcached o Redis para datos de usuario.  Este sistema <strong>calienta partes del código de antemano</strong> .  En la primera solicitud, el sistema genera un código o un archivo de caché, y en solicitudes posteriores, estos cálculos, necesarios, por ejemplo, para compilar una plantilla, ya no se realizarán. <br><br><img src="https://habrastorage.org/webt/nb/44/f6/nb44f6isfvs6vouultxridabeps.jpeg"><br><br>  El almacenamiento en caché <strong>acelera</strong> significativamente <strong>la aplicación</strong> , pero al mismo tiempo la <strong>complica</strong> .  Por ejemplo, hay problemas al invalidar el caché y actualizar la aplicación.  No confunda el caché del usuario con el caché de la aplicación; en uno, los datos cambian con el tiempo, en el otro solo cuando se actualiza el código. <br><br><h3>  Procesamiento de solicitudes </h3><br>  Cuando se recibe una solicitud de un servidor PHP-FPM externo, el punto de entrada de la solicitud y la inicialización coincidirán. <br><br><blockquote>  Resulta que la solicitud del cliente es el estado de nuestro proceso. </blockquote><br>  La única forma de cambiar este estado es destruir completamente al trabajador y comenzar de nuevo con una nueva solicitud. <br><br><img src="https://habrastorage.org/webt/jc/cr/rb/jccrrb-szkhb6_nfn2zthotuctk.jpeg"><br><br>  Este es un modelo clásico de un solo hilo con sus ventajas. <br><br><ul><li>  Todos los trabajadores al final de la solicitud mueren. </li><li>  Pérdidas de memoria, condición de carrera, puntos muertos no son inherentes a PHP.  No te preocupes por eso. </li><li>  El código es simple: escribimos, procesamos la solicitud, morimos y seguimos adelante. </li></ul><br>  Por otro lado, para cada solicitud, cargamos completamente el marco, todas las bibliotecas, realizamos algunos cálculos, volvemos a compilar las plantillas.  Con cada solicitud en un círculo producimos muchas manipulaciones y trabajos innecesarios. <br><br><h3>  Cómo funciona en el servidor </h3><br>  Lo más probable es que funcionen un montón de nginx y PHP.  Nginx funcionará como un proxy inverso: proporcione a los usuarios parte de las estadísticas y delegue parte de las solicitudes al administrador de procesos PHP PHP-FPM a continuación.  El gerente ya plantea un trabajador separado para la solicitud y la procesa.  Después de eso, el trabajador es destruido o despedido.  A continuación, se crea un nuevo trabajador para la siguiente solicitud. <br><br><img src="https://habrastorage.org/webt/8f/lc/fp/8flcfpz6zxemgxlas6avx5aguqa.jpeg"><br><br>  Tal modelo funciona de manera estable: la aplicación es casi imposible de eliminar.  Pero con cargas pesadas, la cantidad de trabajo para inicializar y destruir trabajadores afecta el rendimiento del sistema, porque incluso para una simple solicitud GET, a menudo tenemos que extraer un montón de dependencias y volver a aumentar la conexión de la base de datos. <br><br><h2>  Acelerando la aplicación </h2><br>  ¿Cómo acelerar la aplicación clásica después de introducir caché y carga diferida?  ¿Qué otras opciones hay? <br><br>  <strong>Dirígete al lenguaje en sí</strong> . <br><br><ul><li>  <strong>Utiliza OPCache.</strong>  ¿Creo que nadie está ejecutando PHP en producción sin OPCache habilitado? </li><li>  Espere <strong>RFC: precarga</strong> .  Le permite precargar un conjunto de archivos en una máquina virtual. </li><li>  <strong>JIT</strong> : acelera seriamente la aplicación en tareas vinculadas a la CPU.  Desafortunadamente, con las tareas relacionadas con las bases de datos, no ayudará mucho. </li></ul><br>  <strong>Usa alternativas</strong> .  Por ejemplo, la máquina virtual HHVM de Facebook.  Ejecuta código en un entorno más optimizado.  Desafortunadamente, HHVM no es totalmente compatible con la sintaxis de PHP.  Como alternativa, los compiladores kPHP de VK o PeachPie, que convierte completamente el código a .NET C #, son una alternativa. <br><br>  <strong>Reescribir completamente a otro idioma.</strong>  Esta es una opción radical: elimine completamente la carga de código entre solicitudes. <br><br>  Puede <b>almacenar</b> completamente <b>el estado de la aplicación en la memoria</b> , usar esta memoria activamente para el trabajo y olvidarse del concepto de un trabajador moribundo y borrar completamente la aplicación entre solicitudes. <br><br>  Para lograr esto, movemos el punto de entrada, que solía estar junto con el punto de inicialización, profundamente en la aplicación. <br><br><h3>  Transferencia de punto de entrada - demonización </h3><br>  Esto está creando un bucle infinito en la aplicación: solicitud entrante, ejecútela a través del marco, genere una respuesta para el usuario.  Este es un ahorro importante: todo el arranque, toda la inicialización del marco se realiza solo una vez, y luego la aplicación procesa varias solicitudes. <br><br><img src="https://habrastorage.org/webt/ce/7k/3l/ce7k3lov0kzcyxc3zyjq008taiy.jpeg"><br><br><h3>  Adaptamos la aplicación </h3><br>  Curiosamente, podemos centrarnos en optimizar solo esa parte de la aplicación que se ejecutará <strong>en tiempo de ejecución</strong> : controladores, lógica de negocios.  En este caso, puede abandonar el modelo de carga diferida.  Formaremos parte del proyecto bootstrapping desde el principio, en el momento de la inicialización.  Cálculos preliminares: enrutamiento, plantillas, configuraciones, esquemas ORM inflarán la inicialización, pero en el futuro ahorrarán tiempo de procesamiento para una solicitud específica. <br><br><img src="https://habrastorage.org/webt/fz/kj/ft/fzkjftdkc41niwqyrmml-ijjkwy.jpeg"><br><br>  No recomiendo compilar plantillas al descargar un trabajador, pero descargar, por ejemplo, todas las configuraciones es útil. <br><br><h3>  Compara modelos </h3><br>  Compare los modelos demonizados (izquierda) y clásicos. <br><br><img src="https://habrastorage.org/webt/zo/en/6r/zoen6rl8zyj6tpn7bghp_ozv61m.jpeg"><br><br>  El modelo demonizado lleva más tiempo desde el momento en que se creó el proceso hasta el momento en que se devuelve la respuesta al usuario.  La aplicación clásica está optimizada para una rápida creación, procesamiento y destrucción. <br><br>  Sin embargo, todas las solicitudes posteriores después de calentar el código son mucho más rápidas.  El marco, la aplicación, el contenedor ya está en la memoria y listo para aceptar solicitudes y responder rápidamente. <br><br><h3>  Problemas del modelo de larga vida. </h3><br>  A pesar de las ventajas, el modelo tiene un conjunto de limitaciones. <br><br>  <strong>Fugas de memoria.</strong>  La aplicación permanece en la memoria durante mucho tiempo, y si usa las "curvas" de la biblioteca, las dependencias incorrectas o los estados globales, la memoria comenzará a perder.  En algún momento, aparecerá un error fatal que romperá la solicitud del usuario. <br><br>  El problema se resuelve de dos maneras. <br><br><ul><li>  Escriba código preciso, use bibliotecas comprobadas. </li><li>  Monitorear activamente a los trabajadores.  Si sospecha que hay pérdida de memoria dentro del proceso, cámbielo proactivamente a un análogo con un límite inferior, es decir, simplemente a una nueva copia que aún no haya logrado acumular memoria sin limpiar. </li></ul><br>  <strong>Fugas de datos</strong> .  Por ejemplo, si durante una solicitud entrante guardamos al usuario actual del sistema en alguna variable global y olvidamos restablecer esta variable después de la solicitud, entonces existe la posibilidad de que el siguiente usuario del sistema obtenga accidentalmente acceso a datos que no debería ver. <br><br>  El problema se resuelve a nivel de arquitectura de la aplicación. <br><br><ul><li>  No almacene un usuario activo en un contexto global.  Todos los datos que son específicos del contexto de la solicitud se descartan y se borran antes de la próxima solicitud. </li><li>  Maneje los datos de la sesión con cuidado.  Sesiones en PHP: con el enfoque clásico, este es un objeto global.  Envuélvalo correctamente para que, en una solicitud posterior, se restablezca. </li></ul><br>  <strong>Gestión de recursos</strong> . <br><br><ul><li>  Supervisar las conexiones a la base de datos.  Si la aplicación se bloquea en la memoria durante un mes o dos, entonces la conexión abierta probablemente se cerrará dentro de este tiempo: la base de datos se volverá a instalar, se reiniciará o el firewall restablecerá la conexión.  En el nivel de código, considere volver a conectar, o después de cada solicitud, restablecer la conexión y volver a subirla en la próxima solicitud. </li><li>  Evite el bloqueo de archivos de larga duración.  Si su trabajador escribe alguna información en un archivo, no hay problema.  Pero si este archivo está abierto y tiene un bloqueo, entonces ningún otro proceso en su sistema tendrá acceso hasta que se libere el bloqueo. </li></ul><br><br><h2>  Explore el modelo de larga vida </h2><br>  Considere un modelo de trabajador de larga duración, demonizando una aplicación, y explore formas de implementarla. <br><br><h3>  Enfoque sin bloqueo </h3><br>  Utilizamos PHP asincrónico: cargamos la aplicación una vez en la memoria y procesamos las solicitudes HTTP entrantes dentro de la aplicación.  Ahora la <strong>aplicación y el servidor son un solo proceso</strong> .  Cuando llega la solicitud, creamos una rutina por separado o, en el bucle de eventos, damos una promesa, la procesamos y se la damos al usuario. <br><br><img src="https://habrastorage.org/webt/v6/js/od/v6jsodvtlxjfy1udzwvl0wa2njk.jpeg"><br><br>  La ventaja innegable del enfoque es el máximo rendimiento.  También es posible utilizar herramientas interesantes, por ejemplo, <strong>configurar WebSocket directamente en su aplicación</strong> . <br><br>  Sin embargo, el enfoque <strong>aumenta</strong> significativamente <strong>la complejidad del desarrollo</strong> .  Es necesario instalar ELDO, recuerde que no todos los controladores de bases de datos serán compatibles y que la biblioteca PDO está excluida. <br><br>  Para resolver problemas en el caso de demonización con un enfoque sin bloqueo, puede utilizar herramientas conocidas: <strong>ReactPHP</strong> , <strong>amphp</strong> y <strong>Swoole</strong> , un desarrollo interesante en forma de una extensión C.  Estas herramientas funcionan rápidamente, tienen una buena comunidad y buena documentación. <br><br><h3>  Enfoque de bloqueo </h3><br>  No levantamos corutinas dentro de la aplicación, sino que lo hacemos desde el exterior. <br><br><img src="https://habrastorage.org/webt/ad/ul/eq/adulequ1msa3sb6ae6saah3bu-c.jpeg"><br><br>  Simplemente <strong>recogemos algunos procesos de aplicación</strong> , como haría PHP-FPM.  En lugar de transmitir estas solicitudes en forma de un estado de proceso, las entregamos desde el exterior en forma de un protocolo o mensaje. <br><br>  Escribimos el mismo <strong>código de subproceso único</strong> que conocemos, utilizamos las mismas bibliotecas y el mismo PDO.  Todo el trabajo duro de trabajar con sockets, HTTP y otras herramientas se realiza <strong>fuera de la aplicación PHP</strong> . <br><br>  De los inconvenientes: debemos <strong>monitorear la memoria</strong> y recordar que la <strong>comunicación entre dos procesos diferentes no es gratuita</strong> , pero necesitamos transferir datos.  Esto creará una ligera sobrecarga. <br><br>  Para resolver el problema, ya existe una <strong>herramienta PHP-RM</strong> escrita en PHP.  En la biblioteca ReactPHP, tiene <strong>integración con varios marcos</strong> .  Sin embargo, PHP-PM es muy <strong>lento, pierde memoria a nivel del servidor</strong> y bajo carga no muestra tanto crecimiento como PHP-FRM. <br><br><h2>  Escribimos nuestro servidor de aplicaciones </h2><br>  Escribimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nuestro servidor de aplicaciones</a> , que es similar a PHP-RM, pero hay más funcionalidades.  ¿Qué queríamos del servidor? <br><br>  <strong>Combinar con marcos existentes.</strong>  Nos gustaría tener una integración flexible con casi todos los marcos en el mercado.  No tengo ganas de escribir una herramienta que funcione solo en un caso particular en particular. <br><br>  <strong>Diferentes procesos para servidor y aplicación</strong> .  Posibilidad de un reinicio en caliente, de modo que cuando se desarrolle localmente, presione F5 y vea el nuevo código actualizado, así como poder expandirlos individualmente. <br><br>  <strong>Alta velocidad y estabilidad</strong> .  Aún así, estamos escribiendo un servidor HTTP. <br><br>  <strong>Fácil extensibilidad</strong> .  Queremos usar el servidor no solo como un servidor HTTP, sino también para escenarios individuales como un servidor de cola o un servidor gRPC. <br><br>  <strong>Trabaje fuera de la caja</strong> siempre <strong>que</strong> sea ​​posible: Windows, Linux, CPU ARM. <br><br>  Capacidad para escribir <strong>extensiones multiproceso</strong> muy <strong>rápidas</strong> específicas para nuestra aplicación. <br><br>  Como ya entendió, escribiremos en Golang. <br><br><h2>  Servidor RoadRunner </h2><br>  Para crear un servidor PHP, debe resolver 4 problemas principales: <br><br><ul><li>  Establecer comunicación entre los procesos de Golang y PHP. </li><li>  Gestión de procesos: creación, destrucción, seguimiento de trabajadores. </li><li>  Equilibrio de tareas: distribución eficiente de tareas a los trabajadores.  Dado que estamos implementando un sistema que bloquea a un trabajador individual para una tarea entrante específica en particular, es importante crear un sistema que diga rápidamente que el proceso ha terminado el trabajo y está listo para aceptar la siguiente tarea. </li><li>  Pila HTTP: envío de datos de solicitud HTTP al trabajador.  Es una tarea simple escribir un punto entrante al que el usuario envía una solicitud, que se pasa a PHP y se devuelve. </li></ul><br><h3>  Variantes de interacción entre procesos. </h3><br>  Primero, solucionemos el problema de comunicación entre los procesos de Golang y PHP.  Tenemos varias formas <br><br>  <strong>Incrustar: incrustar un intérprete PHP directamente en Golang.</strong>  Esto es posible, pero requiere un ensamblado PHP personalizado, una configuración compleja y un proceso común para el servidor y PHP.  Como en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">go-php</a> , por ejemplo, donde el intérprete PHP está integrado en Golang. <br><br>  <strong>Memoria compartida: el uso del espacio de memoria compartida,</strong> <strong>donde los procesos comparten este espacio</strong> .  Se necesita un trabajo minucioso.  Al intercambiar datos, tendrá que sincronizar el estado manualmente y la cantidad de errores que pueden ocurrir es bastante grande.  La memoria compartida también depende del sistema operativo. <br><br><h3>  Escribiendo su protocolo de transporte - Goridge </h3><br>  Seguimos un camino simple que se utiliza en casi todas las soluciones en sistemas Linux: utilizamos el protocolo de transporte.  Está <strong>escrito en la parte superior de los TUBOS estándar y ENCHUFES UNIX / TCP</strong> . <br><br>  Tiene la capacidad de transferir datos en ambas direcciones, detectar errores y también etiquetar solicitudes y colocar encabezados.  Un matiz importante para nosotros es la capacidad de implementar el protocolo sin dependencias tanto del lado de PHP como de Golang, sin extensiones C en un lenguaje puro. <br><br>  Como con cualquier protocolo, la base es un paquete de datos.  En nuestro caso, el paquete tiene un encabezado fijo de 17 bytes. <br><br><img src="https://habrastorage.org/webt/wb/_h/g_/wb_hg_qtkmoxe74sthy12rhtzms.jpeg"><br><br>  El primer byte se asigna para determinar el tipo de paquete.  Esto puede ser una secuencia o una bandera que indica el tipo de serialización de datos.  Luego, dos veces empaquetamos el tamaño de los datos en Little Endian y Big Endian.  Utilizamos este legado para detectar errores de transmisión.  Si vemos que el tamaño de los datos empaquetados en dos pedidos diferentes no coincide, lo más probable es que se haya producido un error de transferencia de datos.  Luego se transmiten los datos. <br><br><img src="https://habrastorage.org/webt/bt/rb/dr/btrbdre8cwionih8m6e7yze2crw.jpeg"><br><br>  En la tercera versión del paquete, eliminaremos ese legado, presentaremos un enfoque más clásico con una suma de comprobación y también agregaremos la capacidad de usar este protocolo con procesos PHP asíncronos. <br><br>  Para implementar el protocolo en Golang y PHP, utilizamos herramientas estándar. <br><br>  <strong>En Golang:</strong> bibliotecas de codificación / binarias y bibliotecas io y net para trabajar con canalizaciones estándar y sockets UNIX / TCP. <br><br>  <strong>En PHP:</strong> la función familiar para trabajar con paquetes de datos binarios / desempaquetar y las extensiones de flujos y sockets para tuberías y sockets. <br><br>  Un <strong>efecto secundario</strong> interesante surgió durante la implementación.  Lo integramos con la biblioteca estándar de Golang net / rpc, que nos permite llamar al código de servicio de Golang directamente en la aplicación. <br><br>  Escribimos un servicio: <br><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//  sample type  struct{} // Hi returns greeting message. func (a *App) Hi(name string, r *string) error { *r = fmt.Sprintf("ll, %s!", name) return nil }</span></span></code> </pre> <br>  Se llama una pequeña cantidad de código desde la aplicación: <br><br><pre> <code class="go hljs">&lt;?php use Spiral\Goridge; require <span class="hljs-string"><span class="hljs-string">"vendor/autoload.php"</span></span>; $rpc = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\RPC( <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Goridge\SocketRelay(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">6001</span></span>) ); echo $rpc-&gt;call(<span class="hljs-string"><span class="hljs-string">"App.Hi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Antony"</span></span>);</code> </pre> <br><h3>  PHP Process Manager </h3><br>  La siguiente parte del servidor es la gestión de los trabajadores de PHP. <br><img src="https://habrastorage.org/webt/vt/jy/tk/vtjytk9effas7jkgjgadvbek_zw.jpeg"><br><br>  Worker es un proceso PHP que observamos constantemente desde Golang.  Recopilamos el registro de sus errores en el archivo STDERR, nos comunicamos con el trabajador a través del protocolo de transporte Goridge y recopilamos estadísticas sobre el consumo de memoria, la ejecución de tareas y el bloqueo. <br><br>  La implementación es simple: esta es la funcionalidad estándar de os / exec, runtime, sync, atomic.  Para crear trabajadores usamos <strong>Worker Factory</strong> . <br><img src="https://habrastorage.org/webt/wq/kr/tt/wqkrtt0n0xxvhdnxuvx_4f2deiy.jpeg"><br><br>  ¿Por qué la fábrica de trabajadores?  Porque queremos comunicarnos tanto en tuberías estándar como en enchufes.  En este caso, el proceso de inicialización es ligeramente diferente.  Al crear un trabajador que se comunica por canalización, podemos crearlo de inmediato y enviar datos directamente.  En el caso de los sockets, debe crear un trabajador, esperar hasta que llegue al sistema, hacer un apretón de manos PID y solo entonces continuar trabajando. <br><br><h3>  Balanceador de tareas </h3><br>  La tercera parte del servidor es la más importante para el rendimiento. <br><br>  Para la implementación, utilizamos la funcionalidad estándar de Golang, un <strong>canal protegido</strong> .  En particular, creamos varios trabajadores y los colocamos en este canal como una pila LIFO. <br><img src="https://habrastorage.org/webt/bm/po/f4/bmpof4s5-owl810px69ectqiw_i.jpeg"><br>  Cuando recibimos tareas del usuario, enviamos una solicitud a la pila LIFO y solicitamos emitir el primer trabajador libre.  Si el trabajador no puede ser asignado por un cierto período de tiempo, el usuario recibe un error del tipo "Error de tiempo de espera".  Si el trabajador está asignado, se obtiene de la pila, se bloquea, después de lo cual recibe la tarea del usuario. <br><img src="https://habrastorage.org/webt/cm/2o/cq/cm2ocqak94ubao7tk8vxnglfyyo.jpeg"><br>  Una vez procesada la tarea, la respuesta se devuelve al usuario y el trabajador se encuentra al final de la pila.  Está listo para realizar la siguiente tarea nuevamente. <br><img src="https://habrastorage.org/webt/oj/f_/l4/ojf_l4ipil8fcslpyherhsg02la.jpeg"><br>  Si se produce un error, el usuario recibirá un error, ya que el trabajador será destruido.  Pedimos a Worker Pool y Worker Factory que creen un proceso idéntico y lo reemplacen en la pila.  Esto permite que el sistema funcione incluso en caso de errores fatales simplemente recreando a los trabajadores por analogía con PHP-FPM. <br><img src="https://habrastorage.org/webt/qs/li/dq/qslidqche8glb-q5pucwfwnpogw.jpeg"><br><br>  Como resultado, resultó implementar un pequeño sistema que funciona muy rápidamente: <strong>200 ns para la asignación de trabajadores</strong> .  Es capaz de funcionar incluso en caso de errores fatales.  Cada trabajador en un punto en el tiempo procesa solo una tarea, lo que nos permite utilizar el <strong>enfoque clásico de bloqueo</strong> . <br><br><h3>  Monitoreo proactivo </h3><br>  Una parte separada tanto del administrador de procesos como del equilibrador de tareas es el sistema de monitoreo proactivo. <br><img src="https://habrastorage.org/webt/83/zq/ep/83zqepdmerd6ozakntcmv33hnus.jpeg"><br><br>  Este es un sistema que una vez por segundo sondea a los trabajadores y monitorea los indicadores: analiza la cantidad de memoria que consumen, la cantidad de memoria que contienen, si están inactivos.  Además del seguimiento, el sistema supervisa las pérdidas de memoria.  Si el trabajador excede un cierto límite, lo veremos y lo eliminaremos cuidadosamente del sistema antes de que ocurra una fuga fatal. <br><br><h3>  Pila HTTP </h3><br>  La última y simple parte. <br><img src="https://habrastorage.org/webt/hl/cc/7e/hlcc7ehfob5vhc_zjse_em8e0eg.jpeg"><br>  <strong>Cómo se implementa:</strong> <br><br><ul><li>  plantea un punto HTTP en el lado de Golang; </li><li>  recibimos una solicitud; </li><li>  convertir al formato PSR-7; </li><li>  enviar la solicitud al primer trabajador libre; </li><li>  Desempaquete la solicitud en un objeto PSR-7; </li><li>  procesamos </li><li>  Generamos la respuesta. </li></ul><br>  Para la implementación, utilizamos la <strong>biblioteca</strong> estándar de <strong>Golang NET / HTTP</strong> .  Esta es una famosa biblioteca con muchas extensiones.  Capaz de funcionar tanto sobre HTTPS como sobre el protocolo HTTP / 2. <br><br>  En el lado de PHP, utilizamos el estándar PSR-7 <strong>.</strong>  Es un <strong>marco independiente</strong> con muchas extensiones y Middlewares.  El <strong>diseño del</strong> PSR-7 es <strong>inmutable</strong> , lo que encaja bien con el concepto de aplicaciones de larga duración y evita errores de consulta globales. <br><br>  Ambas estructuras en Golang y PSR-7 son similares, lo que ahorró significativamente tiempo para asignar una solicitud de un idioma a otro. <br><br>  Para iniciar el servidor se requiere un <strong>enlace mínimo</strong> : <br><br><pre> <code class="go hljs">http: address: <span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> workers: command: <span class="hljs-string"><span class="hljs-string">"php psr-worker.php"</span></span> pool: numWorkers: <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br>  Además, desde la versión 1.3.0 se puede omitir la última parte de la configuración. <br><br>  Descargue el archivo binario del servidor, póngalo en el contenedor Docker o en la carpeta del proyecto.  Alternativamente, a nivel mundial, escribimos un pequeño archivo de configuración que describe qué pod vamos a escuchar, qué trabajador es el punto de entrada y cuántos se requieren. <br><br>  En el lado de PHP, escribimos un ciclo primario que recibe una solicitud PSR-7, la procesa y devuelve una respuesta o un error al servidor. <br><br><pre> <code class="go hljs">while ($req = $psr7-&gt;acceptRequest()) { try { $resp = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> \Zend\Diactoros\Response(); $resp-&gt;getBody()-&gt;write(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>); $psr7-&gt;respond($resp); } catch (\Throwable $e) { $psr7-&gt;getWorker()-&gt;error((<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)$e); } }</code> </pre> <br>  <strong>Asamblea</strong>  Para implementar el servidor, elegimos una arquitectura con un enfoque de componentes.  Esto permite ensamblar el servidor para las necesidades del proyecto, agregando o eliminando piezas individuales según los requisitos de la aplicación. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { rr.Container.Register(env.ID, &amp;env.Service{}) rr.Container.Register(rpc.ID, &amp;rpc.Service{}) rr.Container.Register(http.ID, &amp;http.Service{}) rr.Container.Register(static.ID, &amp;static.Service{}) rr.Container.Register(limit.ID, &amp;limit.Service{} <span class="hljs-comment"><span class="hljs-comment">// you can register additional commands using cmd.CLI rr.Execute() }</span></span></code> </pre> <br><h2>  Casos de uso </h2><br>  Considere las opciones para usar el servidor y modificar la estructura.  Para comenzar, considere la canalización clásica: el trabajo del servidor con las solicitudes. <br><br><h3>  Modularidad </h3><br>  El servidor recibe la solicitud a un punto HTTP y la pasa a través de un conjunto de Middleware, que están escritos en Golang.  Una solicitud entrante se convierte en una tarea que el trabajador comprende.  El servidor entrega la tarea al trabajador y la devuelve. <br><br><img src="https://habrastorage.org/webt/zz/v5/ak/zzv5akvapzklanxdlzunxdq-xpu.jpeg"><br><br>  Al mismo tiempo, el trabajador, utilizando el protocolo Goridge, se comunica con el servidor, monitorea su estado y le transfiere datos. <br><br><h3>  Middleware en Golang: Autorización </h3><br>  Esta es la primera cosa que hacer.  En nuestra aplicación, escribimos Middleware para <strong>autorizar al usuario por token JWT</strong> .  Middleware está escrito de la misma manera para cualquier otro tipo de autorización.  Una implementación muy banal y simple es escribir Rate-Limiter o Circuit-Breaker. <br><br><img src="https://habrastorage.org/webt/on/zg/ro/onzgroqwxc7umuy-y2xfv9s7dqe.jpeg"><br><br>  <strong>La autorización es rápida</strong> .  Si la solicitud no es válida, simplemente no la envíe a la aplicación PHP y no desperdicie recursos en el procesamiento de tareas inútiles. <br><br><h3>  Monitoreo </h3><br>  El segundo caso de uso.  Podemos integrar el sistema de monitoreo directamente en Golang Middleware.  Por ejemplo, Prometheus, para recopilar estadísticas sobre la velocidad de los puntos de respuesta, la cantidad de errores. <br><br><img src="https://habrastorage.org/webt/rz/_o/hz/rz_ohzkiz6bwjoebzqu2qt4e6dc.jpeg"><br><br>  También puede <strong>combinar el monitoreo con métricas específicas de la aplicación</strong> (disponible como estándar con 1.4.5).  Por ejemplo, podemos enviar el número de solicitudes a la base de datos o el número de solicitudes específicas procesadas al servidor Golang, y luego a Prometheus. <br><br><h3>  Rastreo distribuido y registro </h3><br>  Escribimos Middleware con un administrador de procesos.  En particular, podemos conectarnos al sistema en tiempo real para monitorear registros y <strong>recopilar todos los registros en una base de datos central</strong> , lo cual es útil al escribir aplicaciones distribuidas. <br><br><img src="https://habrastorage.org/webt/lf/ir/cd/lfircdprhx6nqetmadblqftvbu4.jpeg"><br><br>  También podemos <strong>etiquetar solicitudes</strong> , darles una identificación específica y pasar esta identificación a todos los servicios posteriores o sistemas de comunicación entre ellos.  Como resultado, podemos construir un <strong>rastreo distribuido</strong> y ver cómo funcionan los registros de la aplicación. <br><br><h3>  Grabe su historial de consultas </h3><br>  Este es un pequeño módulo que registra todas las solicitudes entrantes y las almacena en una base de datos externa.  El módulo le permite realizar solicitudes de repetición en el proyecto e implementar un sistema de prueba automático, un sistema de prueba de carga o simplemente verificar el funcionamiento de la API. <br><br><img src="https://habrastorage.org/webt/ex/q3/kg/exq3kgpym1uf6tjcfwysjk1so00.jpeg"><br><br>  ¿Cómo implementamos el módulo? <br><br>  <strong>Procesamos parte de las solicitudes de Golang</strong> .  Escribimos Middleware en Golang y podemos enviar parte de las solicitudes a Handler, que también está escrito en Golang.  Si algún punto de la aplicación es preocupante en términos de rendimiento, lo reescribimos en Golang y arrastramos la pila de un idioma a otro. <br><br><img src="https://habrastorage.org/webt/q0/zf/qn/q0zfqnzddo_mn7h-d779cg9ganm.jpeg"><br><br>  <strong>Estamos escribiendo un servidor WebSocket</strong> .  Implementar un servidor WebSocket o un servidor de notificaciones push se está convirtiendo en una tarea trivial. <br><br><ul><li>  Servicio de Golang a nivel de servidor. </li><li>  Para la comunicación usamos Goridge. </li><li>  Capa de servicio delgada en PHP. </li><li>  Implementamos el servidor de notificaciones. </li></ul><br>  Recibimos una solicitud y generamos una conexión WebSocket.  Si la aplicación necesita enviar algún tipo de notificación al usuario, lanza este mensaje a través del protocolo RPC al servidor WebSocket. <br><br><img src="https://habrastorage.org/webt/go/ta/fv/gotafvsepr8u8_r_lvfdjpff2rg.jpeg"><br><br>  <strong>Gestiona tu entorno PHP.</strong>  Al crear un grupo de trabajadores, RoadRunner tiene control total sobre el estado de las variables de entorno y le permite cambiarlas a su gusto.  Si estamos escribiendo una aplicación distribuida grande, podemos usar una sola fuente de datos de configuración y conectarla como un sistema para configurar el entorno.  Si planteamos un conjunto de servicios, todos estos servicios afectarán a un solo sistema, se configurarán y luego funcionarán.  Esto puede simplificar enormemente la implementación, así como deshacerse de los archivos .env. <br><br><img src="https://habrastorage.org/webt/iv/m5/03/ivm503pht02yug6do6-od3pyt6i.jpeg"><br><br>  Curiosamente, las variables env que están disponibles dentro del trabajador no son globales dentro del sistema.  Esto mejora ligeramente la seguridad del contenedor. <br><br><h3>  Integración de la biblioteca de Golang en PHP </h3><br>  Utilizamos esta opción en el sitio web oficial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RoadRunner</a> .  Esta es una integración de una base de datos casi completa <strong>con la búsqueda de texto completo BleveSearch</strong> dentro del servidor. <br><br><img src="https://habrastorage.org/webt/5a/ba/uc/5abaucml3dmvxqpns_h7bug_ldi.jpeg"><br><br>  Indexamos las páginas de documentación: las colocamos en Bolt DB, después de lo cual realizamos una búsqueda de texto completo sin una base de datos real como MySQL y sin un clúster de búsqueda como Elasticsearch.  El resultado fue un pequeño proyecto donde parte de la funcionalidad está en PHP, pero la búsqueda está en Golang. <br><br><h3>  Implementando Funciones Lambda </h3><br>  Puede ir más allá y <strong>deshacerse por completo de la capa HTTP.</strong>  En este caso, implementar, por ejemplo, las funciones de Lambda es una tarea simple. <br><br><img src="https://habrastorage.org/webt/ty/ie/dy/tyiedyrsetx2l5wljnllkbju0xg.jpeg"><br><br>  Para la implementación, utilizamos el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiempo</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ejecución</a> estándar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AWS</a> para la función Lambda.  Escribimos un pequeño enlace, cortamos completamente los servidores HTTP y enviamos los datos en formato binario a los trabajadores.  También tenemos acceso a la configuración del entorno, que nos permite escribir funciones que se configuran directamente desde el panel de administración de Amazon. <br><br>  Los trabajadores están en memoria durante toda la vida del proceso, y la función Lambda después de la solicitud inicial permanece en la memoria durante 15 minutos.  En este momento, el código no se carga y responde rápidamente.  En las pruebas sintéticas, recibimos hasta <strong>0.5 ms por cada solicitud entrante</strong> . <br><br><h3>  gRPC para PHP </h3><br>  La opción más difícil es reemplazar la capa HTTP con la capa gRPC.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">paquete está disponible en GitHub</a> . <br><img src="https://habrastorage.org/webt/jh/u5/cg/jhu5cgv7-cdj6wf4ifukhqxnd0u.jpeg"><br><br>  Podemos enviar por proxy todas las solicitudes de Protobuf entrantes a una aplicación PHP subordinada, allí se pueden desempaquetar, procesar y responder.  Podemos escribir código tanto en PHP como en Golang, combinando y transfiriendo funcionalidad de una pila a otra.  El servicio es compatible con Middleware.  Tanto la aplicación independiente como junto con HTTP pueden funcionar. <br><br><h3>  Servidor de colas </h3><br>  La última y más interesante opción es la implementación del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">servidor de colas</a> . <br><img src="https://habrastorage.org/webt/rn/ch/1i/rnch1i0ieekunszmsv_ppegtwbu.jpeg"><br><br>  En el lado de PHP, todo lo que hacemos es obtener una carga binaria, desempacarla, hacer el trabajo y decirle al servidor sobre el éxito.  En el lado de Golang, estamos totalmente comprometidos en la gestión de las conexiones con los corredores.  Puede ser RabbitMQ, Amazon SQS o Beanstalk. <br><br>  En el lado de Golang, implementamos el " <strong>cierre agraciado" de los</strong> trabajadores.  Podemos esperar bellamente la implementación de la "conexión duradera": si se pierde la conexión con el intermediario, el servidor espera un momento utilizando la "estrategia de retroceso", levanta la conexión y la aplicación ni siquiera lo nota. <br><br>  Podemos procesar estas solicitudes en PHP y Golang, y ponerlas en cola en ambos lados: <br><br><ul><li>  desde PHP a través del protocolo Goridge Goridge RPC; </li><li>  de Golang: comunicación con la biblioteca SDK. </li></ul><br>  Si la carga útil cae, entonces no cae todo el Consumidor, sino solo un proceso separado.  El sistema lo eleva inmediatamente, la tarea se envía al siguiente trabajador.  Esto le permite realizar tareas sin parar. <br><br>  Implementamos uno de los corredores directamente en la memoria del servidor y utilizamos la funcionalidad Golang.  Esto nos permite escribir una aplicación usando colas antes de elegir la pila final.  Levantamos la aplicación localmente, la iniciamos y tenemos colas que funcionan en la memoria y se comportan de la misma manera que se comportarían en RabbitMQ, Amazon SQS o Beanstalk. <br><br>  Cuando se usan dos idiomas en un paquete híbrido, vale la pena recordar cómo separarlos. <br><br><h3>  Dominios de dominio separados </h3><br><blockquote>  Golang es un lenguaje multiproceso y rápido que es adecuado para escribir lógica de infraestructura y supervisión de usuarios y lógica de autorización. </blockquote><br>  También es útil para <strong>implementar controladores personalizados</strong> para acceder a las fuentes de datos; estas son colas, por ejemplo, Kafka, Cassandra. <br><br><blockquote>  PHP es un gran lenguaje para escribir lógica de negocios. </blockquote><br>  Este es un buen sistema para renderizar HTML, ORM y trabajar con la base de datos. <br><br><h2>  Herramienta de comparación </h2><br>  Hace varios meses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en Habré comparó</a> PHP-FPM, PHP-PM, React-PHP, Roadrunner y otras herramientas.  El punto de referencia se llevó a cabo en un proyecto con Symfony 4 real. <br><br>  RoadRunner bajo carga muestra buenos resultados y está por delante de todos los servidores.  En comparación con PHP-FPM, el rendimiento es 6-8 veces más. <br><img src="https://habrastorage.org/webt/ny/tx/yl/nytxylmddyrmglxjoe8hos7tnka.jpeg"><br><br>  En el mismo punto de referencia, RoadRunner no perdió una sola solicitud, todo se resolvió al 100%.  Desafortunadamente, React-PHP perdió 8–9 solicitudes bajo cargas, esto es inaceptable.  Nos gustaría que el servidor no se bloquee y funcione de manera estable. <br><img src="https://habrastorage.org/webt/7b/fl/gq/7bflgqhrq1f-y0jixnud_k1ckdg.jpeg"><br><br>  Desde la publicación de RoadRunner en acceso público en GitHub, hemos recibido más de 30,000 instalaciones.  La comunidad nos ha ayudado a escribir un conjunto específico de extensiones, mejoras y creemos que la solución tiene derecho a la vida. <br><br>  RoadRunner es bueno si desea <strong>acelerar significativamente la aplicación, pero aún no está listo para saltar a PHP asincrónico</strong> .  Este es un compromiso que requerirá una cierta cantidad de esfuerzo, pero no tan significativo como una reescritura completa de la base del código. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tome RoadRunner</a> si desea tener <strong>más control sobre el ciclo de vida de PHP</strong> , <strong>si no hay suficientes capacidades de PHP,</strong> por ejemplo, para el sistema de colas o Kafka, y cuando su popular biblioteca de Golang resuelve su problema, que no está en PHP, y la escritura lleva tiempo, que usted tampoco tiene. <br><br><h2>  Resumen </h2><br>  Lo que obtuvimos al escribir este servidor y usarlo en nuestra infraestructura de producción. <br><br><ul><li>  <strong>Aumentaron la velocidad de reacción de los puntos de aplicación en 4 veces en</strong> comparación con PHP-FPM. </li><li>  <strong>Se deshizo completamente de 502 errores bajo cargas</strong> .  En las cargas máximas, el servidor solo espera un poco más y responde como si no hubiera cargas. </li><li>  Después de optimizar las pérdidas de memoria, los trabajadores <strong>permanecen en la memoria hasta por 2 meses</strong> .  Esto ayuda al escribir aplicaciones distribuidas, ya que todas las solicitudes entre servicios ya están en caché a nivel de socket. </li><li>  <strong>Usamos Keep-Alive.</strong>  Esto acelera significativamente la comunicación entre un sistema distribuido. </li><li>  Dentro de la infraestructura real, <strong>colocamos todo en el Alpine Docker en Kubernetes</strong> .  El sistema de implementación y construcción del proyecto ahora es más fácil.  Todo lo que se requiere es construir una compilación RoadRunner personalizada para el proyecto, ponerla en el proyecto Docker, completar la imagen de Docker y luego subir tranquilamente nuestro pod a Kubernetes. </li><li>  Según el tiempo real de uno de los proyectos a puntos individuales que no tienen acceso a la base de datos, el <strong>tiempo de respuesta promedio es de 0,33 ms</strong> . </li></ul><br><blockquote>  La próxima conferencia profesional para desarrolladores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PHP PHP Rusia</a> solo el próximo año.  Por ahora, ofrecemos lo siguiente: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Preste</a> atención a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GolangConf</a> si está interesado en la parte Go y desea conocer más detalles o escuchar argumentos a favor de cambiar a este idioma.  Si está listo para compartir su experiencia, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">envíe resúmenes</a> . </li><li>  Participe en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">HighLoad ++</a> en Moscú, si todo es importante para usted que está asociado con un alto rendimiento, envíe un informe antes del 7 de septiembre o reserve una entrada. </li><li>  Suscríbase al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">boletín</a> y al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">canal de telegramas</a> para recibir una invitación a PHP Rusia 2020 antes que otros. </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/461827/">https://habr.com/ru/post/461827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461815/index.html">Una revolución en el diseño de las fuentes de alimentación para computadoras hace medio siglo</a></li>
<li><a href="../461817/index.html">CMake y C ++: hermanos para siempre</a></li>
<li><a href="../461819/index.html">¿Por qué el diseño simple de un sitio web es mejor científicamente?</a></li>
<li><a href="../461821/index.html">La nueva inmunoterapia eliminó todos los tumores en una mujer con cáncer de seno metastásico</a></li>
<li><a href="../461823/index.html">Cuatro reglas mejoradas para el diseño de software</a></li>
<li><a href="../461829/index.html">TCP vs UDP o el futuro de los protocolos de red</a></li>
<li><a href="../461831/index.html">StealthWatch: implementación y personalización. Parte 2</a></li>
<li><a href="../461833/index.html">No te pierdas en tres pinos: una representación egocéntrica del entorno.</a></li>
<li><a href="../461835/index.html">Cómo los gráficos de Gantt simplifican y potencian la gestión de proyectos</a></li>
<li><a href="../461841/index.html">PVS-Studio investigó el motor de bala del Red Dead Redemption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>