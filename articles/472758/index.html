<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôèüèº üé± üóØÔ∏è Propuesta: prueba - funci√≥n incorporada de verificaci√≥n de errores üöó üòî üë©üèΩ‚Äçü§ù‚Äçüë©üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Resumen 


 Se propone una nueva construcci√≥n de try que est√° espec√≠ficamente dise√±ada para eliminar las expresiones if asociadas com√∫nmente con el ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Propuesta: prueba - funci√≥n incorporada de verificaci√≥n de errores</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472758/"><h2 id="kratkoe-soderzhanie">  Resumen </h2><br><p> Se propone una nueva construcci√≥n de <code>try</code> que est√° espec√≠ficamente dise√±ada para eliminar las expresiones <code>if</code> asociadas com√∫nmente con el manejo de errores en Go.  Este es el √∫nico cambio de idioma.  Los autores admiten el uso de funciones de biblioteca <code>defer</code> y est√°ndar para enriquecer o ajustar errores.  Esta peque√±a extensi√≥n es adecuada para la mayor√≠a de los escenarios, pr√°cticamente sin complicar el lenguaje. </p><br><p>  La construcci√≥n de <code>try</code> es f√°cil de explicar, f√°cil de implementar, esta funcionalidad es ortogonal a otras construcciones de lenguaje y es totalmente compatible con versiones anteriores.  Tambi√©n es extensible si lo queremos en el futuro. </p><br><p>  El resto de este documento est√° organizado de la siguiente manera: despu√©s de una breve introducci√≥n, damos una definici√≥n de la funci√≥n incorporada y explicamos su uso en la pr√°ctica.  La secci√≥n de discusi√≥n revisa sugerencias alternativas y el dise√±o actual.  Al final, se dar√°n las conclusiones y el plan de implementaci√≥n con ejemplos y una secci√≥n de preguntas y respuestas. </p><a name="habracut"></a><br><h2 id="vvedenie">  Introduccion </h2><br><p>  En la √∫ltima conferencia de Gophercon en Denver, los miembros del equipo Go (Russ Cox, Marcel van Lohuizen) presentaron algunas ideas nuevas sobre c√≥mo reducir el tedio del manejo manual de errores en Go ( <a href="">dise√±o borrador</a> ).  Desde entonces, hemos recibido una gran cantidad de comentarios. </p><br><p>  Como Russ Cox explic√≥ en su <a href="">revisi√≥n del problema</a> , nuestro objetivo es hacer que el manejo de errores sea m√°s liviano al reducir la cantidad de c√≥digo dedicado espec√≠ficamente a la verificaci√≥n de errores.  Tambi√©n queremos que el c√≥digo de manejo de errores de escritura sea m√°s conveniente, aumentando la probabilidad de que los desarrolladores a√∫n dediquen tiempo a corregir el manejo de errores.  Al mismo tiempo, queremos dejar el c√≥digo de manejo de errores claramente visible en el c√≥digo del programa. </p><br><p>  Las ideas discutidas en el borrador del borrador se concentran alrededor de la nueva declaraci√≥n de <code>check</code> unaria, que simplifica la verificaci√≥n expl√≠cita del valor de error obtenido de alguna expresi√≥n (generalmente una llamada a funci√≥n), as√≠ como la declaraci√≥n de manejadores de errores ( <code>handle</code> ) y un conjunto de reglas que conectan estas dos nuevas construcciones de lenguaje. </p><br><p>  La mayor√≠a de los comentarios que recibimos se centraron en los detalles y la complejidad del dise√±o del <code>handle</code> , y la idea de un operador de <code>check</code> result√≥ ser m√°s atractiva.  De hecho, varios miembros de la comunidad tomaron la idea de un operador de <code>check</code> y lo expandieron.  Aqu√≠ hay algunas publicaciones m√°s similares a nuestra oferta: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PeterRK</a> propuso la primera propuesta escrita (conocida por nosotros) para usar la construcci√≥n de <code>check</code> lugar del operador en su publicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes clave del manejo de errores</a> </li><li>  No hace mucho tiempo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Markus</a> propuso dos nuevas palabras clave, <code>guard</code> y <code>must</code> junto con el uso de <code>defer</code> para envolver errores en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 31442</a> </li><li>  Tambi√©n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pjebs</a> sugiri√≥ una construcci√≥n <code>must</code> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 32219</a> </li></ul><br><p>  La propuesta actual, aunque diferente en detalles, se bas√≥ en estos tres y, en general, en los comentarios recibidos sobre el proyecto de dise√±o propuesto el a√±o pasado. </p><br><p>  Para completar la imagen, queremos se√±alar que se pueden encontrar a√∫n m√°s sugerencias de manejo de errores en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">esta p√°gina wiki</a> .  Tambi√©n vale la pena se√±alar que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Liam Breck</a> vino con un amplio conjunto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">requisitos</a> para el mecanismo de manejo de errores. </p><br><p>  Finalmente, despu√©s de la publicaci√≥n de esta propuesta, supimos que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ryan Hileman</a> implement√≥ la <code>try</code> cinco a√±os usando la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">herramienta de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">reescritura</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">og</a> y la us√≥ con √©xito en proyectos reales.  Ver ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://news.ycombinator.com/item?id=20101417</a> ). </p><br><h2 id="vstroennaya-funkciya-try">  Funci√≥n de prueba incorporada </h2><br><h3 id="predlozhenie">  Oferta </h3><br><p>  Sugerimos agregar un nuevo elemento de lenguaje similar a una funci√≥n llamado <code>try</code> y llamado con una firma </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(expr)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T1, T2, ... Tn)</span></span></span></span></code> </pre> <br><p>  donde <code>expr</code> significa una expresi√≥n de un par√°metro de entrada (generalmente una llamada a funci√≥n) que devuelve n + 1 valores de los tipos <code>T1, T2, ... Tn</code> y <code>error</code> para el √∫ltimo valor.  Si <code>expr</code> es un valor √∫nico (n = 0), este valor debe ser de tipo <code>error</code> y <code>try</code> no devuelve un resultado.  Al llamar a <code>try</code> con una expresi√≥n que no devuelve el √∫ltimo valor de <code>error</code> de tipo, <code>error</code> produce un error de compilaci√≥n. </p><br><p>  La construcci√≥n <code>try</code> solo puede usarse en una funci√≥n que devuelve al menos un valor, y cuyo √∫ltimo valor de retorno es de tipo <code>error</code> .  Llamar a <code>try</code> en otros contextos conduce a un error de compilaci√≥n. </p><br><p>  Llama a <code>try</code> con la funci√≥n <code>f()</code> como en el ejemplo </p><br><pre> <code class="go hljs">x1, x2, ‚Ä¶ xn = try(f())</code> </pre> <br><p>  conduce al siguiente c√≥digo: </p><br><pre> <code class="go hljs">t1, ‚Ä¶ tn, te := f() <span class="hljs-comment"><span class="hljs-comment">// t1, ‚Ä¶ tn,  ()   if te != nil { err = te //  te    error return //     } x1, ‚Ä¶ xn = t1, ‚Ä¶ tn //     //    </span></span></code> </pre><br><p>  En otras palabras, si el √∫ltimo tipo de <code>error</code> devuelto por <code>expr</code> es <code>nil</code> , <code>try</code> simplemente devuelve los primeros n valores, eliminando el <code>nil</code> final. </p><br><p>  Si el √∫ltimo valor devuelto por <code>expr</code> no es <code>nil</code> , entonces: </p><br><ul><li>  El valor de retorno de <code>error</code> de la funci√≥n de cierre (en el pseudoc√≥digo mencionado anteriormente <code>err</code> , aunque puede ser cualquier identificador o valor de retorno sin nombre) recibe el valor de error devuelto por <code>expr</code> </li><li>  hay una salida de la funci√≥n envolvente </li><li>  Si la funci√≥n de cierre tiene par√°metros de retorno adicionales, estos par√°metros conservan los valores que conten√≠an antes de la llamada de <code>try</code> . </li><li>  si la funci√≥n de cierre tiene par√°metros de retorno sin nombre adicionales, se les devuelven los valores cero correspondientes (que es id√©ntico a guardar sus valores cero originales con los que se inicializan). </li></ul><br><p>  Si <code>try</code> usa en m√∫ltiples asignaciones, como en el ejemplo anterior, y se detecta un error distinto de cero (en adelante, nulo - aprox. Por.), La asignaci√≥n (por variables de usuario) no se realiza y ninguna de las variables en el lado izquierdo de la asignaci√≥n cambia.  Es decir, <code>try</code> comporta como una llamada a una funci√≥n: sus resultados est√°n disponibles solo si <code>try</code> devuelve el control al llamante (a diferencia del caso con un retorno de la funci√≥n de cierre).  Como resultado, si las variables en el lado izquierdo de la asignaci√≥n son par√°metros de retorno, el uso de <code>try</code> dar√° como resultado un comportamiento diferente del c√≥digo t√≠pico que se encuentra ahora.  Por ejemplo, si <code>a,b, err</code> se denominan par√°metros de retorno de una funci√≥n de cierre, aqu√≠ est√° este c√≥digo: </p><br><pre> <code class="go hljs">a, b, err = f() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><p>  siempre asignar√° valores a las variables <code>a, b</code> <code>err</code> , independientemente de si la llamada a <code>f()</code> devolvi√≥ un error o no.  Desaf√≠o contrario </p><br><pre> <code class="go hljs">a, b = try(f())</code> </pre> <br><p>  en caso de error, deje <code>a</code> y <code>b</code> sin cambios.  A pesar de que este es un matiz sutil, creemos que tales casos son bastante raros.  Si se requiere un comportamiento de asignaci√≥n incondicional, debe continuar utilizando las expresiones <code>if</code> . </p><br><h3 id="ispolzovanie">  Uso </h3><br><p>  La definici√≥n de <code>try</code> expl√≠citamente le dice c√≥mo usarlo: muchas expresiones <code>if</code> que verifican retornos de error pueden reemplazarse con <code>try</code> .  Por ejemplo: </p><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ‚Ä¶, err <span class="hljs-comment"><span class="hljs-comment">//       }</span></span></code> </pre> <br><p>  se puede simplificar a </p><br><pre> <code class="go hljs">f := try(os.Open(filename))</code> </pre> <br><p>  Si la funci√≥n de llamada no devuelve un error, <code>try</code> no se puede utilizar (consulte la secci√≥n Discusi√≥n).  En este caso, el error debe procesarse en cualquier caso localmente (ya que no hay retorno de error), y en este caso, <code>if</code> sigue siendo el mecanismo apropiado para verificar errores. </p><br><p>  En t√©rminos generales, nuestro objetivo no es reemplazar todas las posibles verificaciones de errores con una <code>try</code> .  El c√≥digo que requiere una sem√°ntica diferente puede y debe seguir utiliz√°ndose <code>if</code> expresiones y variables expl√≠citas con valores de error. </p><br><h3 id="testirovanie-i-try">  Prueba y prueba </h3><br><p>  En uno de nuestros intentos anteriores de escribir una especificaci√≥n (ver la secci√≥n de iteraci√≥n de dise√±o a continuaci√≥n), <code>try</code> fue dise√±ado para entrar en p√°nico cuando ocurre un error cuando se usa dentro de una funci√≥n sin un error de retorno.  Esto permiti√≥ utilizar pruebas unitarias de prueba basadas en el paquete de <code>testing</code> de la biblioteca est√°ndar. </p><br><p>  Como una de las opciones, es posible usar funciones de prueba con firmas en el paquete de <code>testing</code> </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.T)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkXxx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*testing.B)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre> <br><p>  para permitir el uso de <code>try</code> en las pruebas.  Una funci√≥n de prueba que devuelve un error distinto de cero llamar√° impl√≠citamente a <code>t.Fatal(err)</code> o <code>b.Fatal(err)</code> .  Este es un peque√±o cambio de biblioteca que evita la necesidad de diferentes comportamientos (retorno o p√°nico) para <code>try</code> , seg√∫n el contexto. </p><br><p>  Uno de los inconvenientes de este enfoque es que <code>t.Fatal</code> y <code>b.Fatal</code> no podr√°n devolver el n√∫mero de l√≠nea en el que cay√≥ la prueba.  Otra desventaja es que tambi√©n debemos cambiar las subpruebas de alguna manera.  La soluci√≥n a este problema es una pregunta abierta;  No proponemos cambios espec√≠ficos al paquete de <code>testing</code> en este documento. </p><br><p>  Consulte tambi√©n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 21111</a> , que sugiere permitir que las funciones de ejemplo devuelvan un error. </p><br><h3 id="obrabotka-oshibok">  Manejo de errores </h3><br><p>  El <a href="">dise√±o del borrador</a> original se refer√≠a en gran medida al soporte de idiomas para envolver o aumentar los errores.  El borrador propuso un nuevo <code>handle</code> palabras clave y una nueva forma de <em>declarar controladores de errores</em> .  Esta nueva construcci√≥n del lenguaje atrajo problemas como las moscas debido a la sem√°ntica no trivial, especialmente cuando se considera su efecto en el flujo de ejecuci√≥n.  En particular, la funcionalidad del <code>handle</code> cruz√≥ miserablemente con la funci√≥n de <code>defer</code> , lo que hizo que la nueva caracter√≠stica del lenguaje no fuera ortogonal a todo lo dem√°s. </p><br><p>  Esta propuesta reduce el dise√±o original del borrador a su esencia.  Si se requiere enriquecimiento o ajuste de errores, hay dos enfoques: adjuntar a <code>if err != nil { return err}</code> , o "declarar" un controlador de errores dentro de la expresi√≥n de <code>defer</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      -   err = ‚Ä¶ // /  } }()</span></span></code> </pre> <br><p>  En este ejemplo, <code>err</code> es el nombre del par√°metro de retorno de <code>error</code> tipo <code>error</code> funci√≥n de cierre. </p><br><p>  En la pr√°ctica, imaginamos funciones de ayuda como </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleErrorf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error, format </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, args ...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { *err = fmt.Errorf(format + <span class="hljs-string"><span class="hljs-string">": %v"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(args, *err)...) } }</code> </pre><br><p>  o algo similar  El paquete <code>fmt</code> puede convertirse en un lugar natural para tales ayudantes (ya proporciona <code>fmt.Errorf</code> ).  Con ayudantes, la definici√≥n de un controlador de errores en muchos casos se reducir√° a una sola l√≠nea.  Por ejemplo, para enriquecer el error de la funci√≥n "copiar", puede escribir </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.HandleErrorf(&amp;err, <span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst)</code> </pre><br><p>  if <code>fmt.HandleErrorf</code> agrega impl√≠citamente informaci√≥n de error. Dicha construcci√≥n es bastante f√°cil de leer y tiene la ventaja de que puede implementarse sin agregar nuevos elementos de la sintaxis del lenguaje. </p><br><p>  La principal desventaja de este enfoque es que se debe nombrar el par√°metro de error devuelto, lo que potencialmente conduce a una API menos precisa (consulte las preguntas frecuentes sobre este tema).  Creemos que nos acostumbraremos cuando se establezca el estilo apropiado de escritura de c√≥digo. </p><br><h3 id="effektivnost-defer">  La eficiencia difiere </h3><br><p>  Una consideraci√≥n importante cuando se usa <code>defer</code> como un controlador de errores es la eficiencia.  La expresi√≥n <code>defer</code> se considera <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lenta</a> .  No queremos elegir entre un c√≥digo eficiente y un buen manejo de errores.  Independientemente de esta propuesta, los equipos de compilaci√≥n y tiempo de ejecuci√≥n de Go discutieron m√©todos de implementaci√≥n alternativos, y creemos que podemos hacer formas t√≠picas de usar diferir para manejar errores comparables en eficiencia al c√≥digo "manual" existente.  Esperamos agregar una implementaci√≥n m√°s r√°pida de <code>defer</code> en Go 1.14 (ver tambi√©n el ticket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CL 171158</a> , que es el primer paso en esta direcci√≥n). </p><br><h3 id="specialnye-sluchai-go-tryf-defer-tryf">  Casos especiales: <code>go try(f), defer try(f)</code> </h3><br><p>  La construcci√≥n <code>try</code> parece una funci√≥n, y debido a esto, se espera que pueda usarse en cualquier lugar donde una llamada de funci√≥n sea aceptable.  Sin embargo, si la llamada <code>try</code> se usa en la declaraci√≥n <code>go</code> , las cosas se complican: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> try(f())</code> </pre><br><p>  Aqu√≠ <code>f()</code> se ejecuta cuando la expresi√≥n go se ejecuta en la rutina actual, los resultados de llamar a <code>f</code> se pasan como argumentos para <code>try</code> , que comienza en la nueva rutina.  Si <code>f</code> devuelve un error distinto de cero, se espera que <code>try</code> regrese de la funci√≥n de cierre;  sin embargo, no hay funci√≥n (y no hay par√°metro de retorno de <code>error</code> de tipo), porque  El c√≥digo se ejecuta en una gorutina separada.  Debido a esto, proponemos deshabilitar <code>try</code> en una expresi√≥n <code>go</code> . </p><br><p>  Situaci√≥n con </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> try(f())</code> </pre><br><p>  parece similar, pero aqu√≠ la sem√°ntica de <code>defer</code> significa que la ejecuci√≥n de <code>try</code> se retrasar√° hasta que regrese de la funci√≥n de cierre.  Como antes, <code>f()</code> eval√∫a cuando <code>defer</code> , y sus resultados se pasan al <code>try</code> diferido. </p><br><p>  <code>try</code> comprueba el error <code>f()</code> devuelto solo en el √∫ltimo momento antes de regresar de la funci√≥n de cierre.  Sin cambiar el comportamiento de <code>try</code> , dicho error puede sobrescribir otro valor de error que la funci√≥n de cierre intenta devolver.  Esto, en el mejor de los casos, confunde, en el peor, provoca errores.  Debido a esto, le proponemos que proh√≠ba tambi√©n el <code>try</code> llamada en la declaraci√≥n de <code>defer</code> .  Siempre podemos reconsiderar esta decisi√≥n si existe una aplicaci√≥n razonable de dicha sem√°ntica. </p><br><p>  Finalmente, al igual que el resto de las construcciones integradas, <code>try</code> solo se puede usar como una llamada;  no se puede usar como una funci√≥n de valor o en una expresi√≥n de asignaci√≥n variable como en <code>f := try</code> (al igual que <code>f := print</code> y <code>f := new</code> est√°n prohibidos). </p><br><h2 id="obsuzhdenie">  La discusi√≥n </h2><br><h3 id="iteracii-dizayna">  Iteraciones de dise√±o </h3><br><p>  La siguiente es una breve discusi√≥n de dise√±os anteriores que condujeron a la propuesta m√≠nima actual.  Esperamos que esto arroje luz sobre las decisiones de dise√±o seleccionadas. </p><br><p>  Nuestra primera iteraci√≥n de esta oraci√≥n se inspir√≥ en dos ideas del art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Partes clave del manejo de errores", a</a> saber, usar la funci√≥n incorporada en lugar del operador y la funci√≥n Go habitual para manejar errores en lugar de la nueva construcci√≥n del lenguaje.  A diferencia de esa publicaci√≥n, nuestro controlador de errores ten√≠a un <code>func(error) error</code> firma <code>func(error) error</code> fijo para simplificar las cosas.  La funci√≥n <code>try</code> llamar√≠a a un controlador de errores si hubiera un error antes de que <code>try</code> saliera de la funci√≥n de cierre.  Aqu√≠ hay un ejemplo: </p><br><pre> <code class="go hljs">handler := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"foo failed: %v"</span></span>, err) <span class="hljs-comment"><span class="hljs-comment">//   } f := try(os.Open(filename), handler) //     </span></span></code> </pre><br><p>  Si bien este enfoque permiti√≥ la definici√≥n de manejadores de errores efectivos definidos por el usuario, tambi√©n plante√≥ muchas preguntas que obviamente no ten√≠an las respuestas correctas: ¬øQu√© deber√≠a suceder si se pasa nada al manejador?  ¬øDeber√≠as <code>try</code> entrar <code>try</code> p√°nico o considerar esto como la falta de un controlador?  ¬øQu√© sucede si se llama al controlador con un error distinto de cero y luego devuelve un resultado nulo?  ¬øEsto significa que el error est√° "cancelado"?  ¬øO deber√≠a una funci√≥n de cierre devolver un error vac√≠o?  Tambi√©n hubo dudas de que la transferencia opcional de un controlador de errores alentar√≠a a los desarrolladores a ignorar los errores en lugar de corregirlos.  Tambi√©n ser√≠a f√°cil hacer el manejo correcto de errores en todas partes, pero omita un uso de <code>try</code> .  Y similares </p><br><p>  En la siguiente iteraci√≥n, la capacidad de pasar un controlador de errores personalizado se elimin√≥ a favor de usar <code>defer</code> para ajustar los errores.  Esto parec√≠a un mejor enfoque porque hac√≠a que los manejadores de errores fueran mucho m√°s notorios en el c√≥digo fuente.  Este paso tambi√©n elimin√≥ todos los problemas relacionados con la transferencia opcional de las funciones del controlador, pero exigi√≥ que se nombraran los par√°metros devueltos con el tipo de <code>error</code> si se requer√≠a acceso (decidimos que esto era normal).  Adem√°s, en un intento de hacer que <code>try</code> √∫til no solo dentro de las funciones que devuelven errores, fue necesario hacer que el comportamiento de <code>try</code> sensible al contexto: si <code>try</code> us√≥ a nivel de paquete, o si se llam√≥ dentro de una funci√≥n que no devuelve un error, <code>try</code> autom√°ticamente en p√°nico cuando se detecta un error.  (Y como efecto secundario, debido a esta propiedad, la construcci√≥n del lenguaje se llam√≥ <code>must</code> lugar de <code>try</code> en esa oraci√≥n). El comportamiento sensible al contexto de <code>try</code> (o <code>must</code> ) parec√≠a natural y tambi√©n bastante √∫til: eliminar√≠a muchas funciones definidas por el usuario utilizadas en expresiones inicializando variables de paquete.  Tambi√©n abri√≥ la posibilidad de usar las pruebas unitarias de prueba con el paquete de <code>testing</code> . </p><br><p>  Sin embargo, el comportamiento sensible al contexto de <code>try</code> estaba lleno de errores: por ejemplo, el comportamiento de una funci√≥n que usa <code>try</code> podr√≠a cambiar silenciosamente (p√°nico o no) al agregar o eliminar un error de retorno a la firma de la funci√≥n.  Esto parec√≠a una propiedad demasiado peligrosa.  La soluci√≥n obvia era dividir la funcionalidad de <code>try</code> en dos funciones separadas de <code>try</code> y <code>try</code> , (muy similar a la forma en que se sugiri√≥ en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 31442</a> ).  Sin embargo, esto requerir√≠a dos funciones integradas, mientras que solo el <code>try</code> directamente relacionado con un mejor soporte para el manejo de errores. </p><br><p>  Por lo tanto, en la iteraci√≥n actual, en lugar de incluir la segunda funci√≥n incorporada, decidimos eliminar la sem√°ntica dual de <code>try</code> y, por lo tanto, permitir su uso solo en funciones que devuelven un error. </p><br><h3 id="osobennosti-predlozhennogo-dizayna">  Caracter√≠sticas del dise√±o propuesto. </h3><br><p>  Esta sugerencia es bastante corta y puede parecer un paso atr√°s en comparaci√≥n con el borrador del a√±o pasado.  Creemos que las soluciones seleccionadas est√°n justificadas: </p><br><ul><li><p>  Lo primero es lo primero, <code>try</code> tiene exactamente la misma sem√°ntica de la declaraci√≥n de <code>check</code> propuesta en el original sin <code>handle</code> .  Esto confirma la fidelidad del borrador original en uno de los aspectos importantes. </p><br></li><li><p>  Elegir una funci√≥n integrada en lugar de operadores tiene varias ventajas.  No requiere una nueva palabra clave como <code>check</code> , lo que har√≠a que el dise√±o sea incompatible con los analizadores existentes.  Tampoco es necesario expandir la sintaxis de las expresiones con un nuevo operador.  Agregar una nueva funci√≥n incorporada es relativamente trivial y completamente ortogonal a otras caracter√≠sticas del lenguaje. </p><br></li><li><p>  El uso de una funci√≥n en l√≠nea en lugar de un operador requiere el uso de par√©ntesis.  Deber√≠amos escribir <code>try(f())</code> lugar de <code>try f()</code> .  Este es el precio (peque√±o) que tenemos que pagar por la compatibilidad con los analizadores existentes.  Sin embargo, esto tambi√©n hace que el dise√±o sea compatible con versiones futuras: si decidimos en el camino que pasar de alguna forma una funci√≥n de manejo de errores o agregar un par√°metro adicional para <code>try</code> para este prop√≥sito es una buena idea, agregar un argumento adicional a la llamada de <code>try</code> ser√° trivial. </p><br></li><li><p>  Al final result√≥ que, la necesidad de escribir corchetes tiene sus ventajas.  En expresiones m√°s complejas con m√∫ltiples llamadas de <code>try</code> , los par√©ntesis mejoran la legibilidad al eliminar la necesidad de tratar con la precedencia del operador, como en los siguientes ejemplos: </p><br></li></ul><br><pre> <code class="go hljs">info := try(try(os.Open(file)).Stat()) <span class="hljs-comment"><span class="hljs-comment">//   try info := try (try os.Open(file)).Stat() //  try   info := try (try (os.Open(file)).Stat()) //  try  </span></span></code> </pre><br><p>     <code>try</code> ,      :       <code>try</code> , ..   <code>try</code>   (receiver)  <code>.Stat</code> (  <code>os.Open</code> ). </p><br><p>     <code>try</code> ,        :    <code>os.Open(file)</code> ..       <code>try</code> (  ,   <code>try</code>    <code>os</code> ,   ,   <code>try</code>      <code>try</code> ). </p><br><p>           , ..      . </p><br><ul><li>           .   ,          .   ,      ,      ,     . </li></ul><br><h2 id="vyvody">  Conclusiones </h2><br><p>       <a href="">  </a>         .    ,      .            <code>defer</code> ,           . </p><br><p>  Go         -  ,         . ,   Go     <code>append</code> .     <code>append</code>         ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     .    ,       .  ,        <code>try</code> . </p><br><p>          ,     ,   Go      : <code>panic</code>  <code>recover</code> .   <code>error</code>   <code>try</code>   . </p><br><p>  , <code>try</code>     ,     ,      ‚Äî      ‚Äî   ,     .        Go: </p><br><ul><li>       </li><li>     , <code>try</code>       </li><li>      </li><li>    - </li></ul><br><p>        ,    ,       .     <code>if</code> -. </p><br><h2 id="realizaciya">  Implementaci√≥n </h2><br><p>   : </p><br><ul><li>   Go. </li><li>     <code>try</code> . ,            .      . </li><li>  <code>go/types</code>  <code>try</code> .   . </li><li>    <code>gccgo</code> . ( ,  ). </li><li>      . </li></ul><br><p>    -  ,     . ,        .           . </p><br><p> Robert Griesemer    <code>go/types</code> ,     () <code>cmd/compile</code> .    ,         Go 1.14,  1  2019. </p><br><p> , Ian Lance Taylor    <code>gccgo</code> ,    . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Go 2,  !"</a> ,                . </p><br><p> 1 ,    ,      ,    Go 1.14  . </p><br><p>  Ejemplos </p><br><p>  <code>CopyFile</code>     : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } }() r := try(os.Open(src)) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w := try(os.Create(dst)) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { w.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { os.Remove(dst) <span class="hljs-comment"><span class="hljs-comment">//    ‚Äútry‚Äù    } }() try(io.Copy(w, r)) try(w.Close()) return nil }</span></span></code> </pre><br><p>   ,    " ",  <code>defer</code>  : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.HandleErrorf(&amp;err, <span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst)</code> </pre><br><p>           (  <code>defer</code> -),        <code>defer</code>     ,    . </p><br><p>  <code>printSum</code>          </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { x := try(strconv.Atoi(a)) y := try(strconv.Atoi(b)) fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><p>   : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { fmt.Println( <span class="hljs-string"><span class="hljs-string">"result:"</span></span>, try(strconv.Atoi(a)) + try(strconv.Atoi(b)), ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><p>  <code>main</code>  <a href="">   </a>      : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localMain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { hex := try(ioutil.ReadAll(os.Stdin)) data := try(parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex))) try(os.Stdout.Write(data)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := localMain(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } }</code> </pre><br><p> -   <code>try</code>      ,        : </p><br><pre> <code class="plaintext hljs">n, err := src.Read(buf) if err == io.EOF { break } try(err)</code> </pre><br><h2 id="voprosy-i-otvety">    </h2><br><p> ,     . </p><br><p> <strong>:        ?</strong> </p><br><p> :        <code>check</code>  <code>handle</code> ,     .  ,  <code>handle</code>          <code>defer</code> ,   <code>handle</code>   . </p><br><p> <strong>:  try   ?</strong> </p><br><p> :    <code>try</code>     Go     .       -  ,           .          ,     .        ,     "  ".  <code>try</code>     , ..          . </p><br><p> <strong>:  <code>try</code>  try?</strong> </p><br><p> :    ,  <code>check</code> , <code>must</code>  <code>do</code> .   <code>try</code>            ,           . <code>try</code>       <code>check</code> (,        ),  -       .         .         <code>must</code>          ; <code>try</code> ‚Äî  . ,  Rust  Swift   <code>try</code>       (   ).         . </p><br><p> <strong>:      <code>?</code>   Rust?</strong> </p><br><p> : Go      ;  ,           Go (        ;   -   ).         ,     <code>?</code> ,      .   , ,   ,     (package, interface, if, append, recover, ...),  ,        (struct, var, func, int, len, image,  ..). Rust   <code>?</code>     <code>try</code>   ‚Äî      Go,    ,   (   )   . ,  <code>?</code>      .    ,   ,     (,   ..)  .       .       ,   . </p><br><p> <strong>:       ( error)  ,  defer   ,   go doc.    ?</strong> </p><br><p> :     <code>go doc</code>   ,       -   ( <code>_</code> ) ,         . ,  <code>func f() (_ A, _ B, err error)</code>    <code>go doc</code>  <code>func f() (A, B, error)</code> .      ,   ,     ,      .  ,         ,     . ,   ,    ,       -,       (deferred) .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jonathan Geddes</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   <code>try()</code>        . </p><br><p> <strong>:     defer    ?</strong> </p><br><p> :    <code>defer</code>          . ,  ,       defer         "" . .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CL 171758</a> ,     defer   30%. </p><br><p> <strong>:           ?</strong> </p><br><p> :  ,        . ,         ( ,    ),      .     <code>defer</code>              ,     .   <code>defer</code> -   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://golang.org/issue/29934</a> (   Go 2),    . </p><br><p> <strong>:  ,   try,    error.  ,       ?</strong> </p><br><p> :           <code>error</code> (  )   ,  ,     <code>nil</code> .           <code>try</code> . (      ,  .     - ). </p><br><p> <strong>:    Go  ,     try   ?</strong> </p><br><p> :  <code>try</code>     ,   <code>try</code> .    <code>super return</code> -, <code>try</code>      <code>Go</code>        . <code>try</code>       .     <em></em>  . </p><br><p> <strong>:     try   ,         .   ?</strong> </p><br><p> : <code>try</code>        ;       ,     .       <code>try</code>    ( ),     .   , <code>if</code>   . </p><br><p> <strong>:   ,       .    try,    defer    .   ?</strong> </p><br><p> :         ,       .     . </p><br><p> <strong>:  <code>try</code>     (  <code>catch</code> )?</strong> </p><br><p> : <code>try</code> ‚Äî   ("")      ,  ,      (    )   . <code>try</code>   ;       .        .     "" .     ,        .  , <code>try</code> ‚Äî      .   ,  ,       <code>throw</code>  <code>try-catch</code>     Go. ,         (,    ),     (   )     ,      .    ""      <code>try-catch</code> ,       . ,    ,      .  Go    .     <code>panic</code> ,       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472758/">https://habr.com/ru/post/472758/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472746/index.html">Servidor de terminal para administrador; Ni una sola brecha SSH</a></li>
<li><a href="../472748/index.html">Navegador sem√°ntico o vida sin sitios</a></li>
<li><a href="../472750/index.html">OK, ¬ørealmente necesito Kubernetes?</a></li>
<li><a href="../472752/index.html">CSE: Kubernetes para cualquier persona en vCloud</a></li>
<li><a href="../472754/index.html">C√≥mo hablar ingl√©s en un mes. 9 pasos f√°ciles y probados</a></li>
<li><a href="../472760/index.html">Reduzca el tiempo de computaci√≥n de unos pocos a√±os a minutos. Comprender el aprendizaje autom√°tico cu√°ntico</a></li>
<li><a href="../472762/index.html">An√°lisis t√©cnico del exploit checkm8</a></li>
<li><a href="../472766/index.html">Parametrizaci√≥n desde archivo en py.test</a></li>
<li><a href="../472768/index.html">C√≥mo contratar, despedir y regresar de la administraci√≥n al desarrollo: video de Badoo Techleads Meetup # 5</a></li>
<li><a href="../472770/index.html">Organizaci√≥n de la interfaz en Unity con UI Canvas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>