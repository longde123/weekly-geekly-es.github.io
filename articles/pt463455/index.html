<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☮️ 🌬️ 📰 Milhares de coisas para corrigir em Java a partir da versão um: uma ótima entrevista com Sergey Kuksenko da Oracle 🐣 🤱🏼 🛕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sergey Kuksenko é um engenheiro de desempenho que viu o Java ainda na versão 1.0. Durante esse período, ele conseguiu participar do desenvolvimento de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Milhares de coisas para corrigir em Java a partir da versão um: uma ótima entrevista com Sergey Kuksenko da Oracle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/463455/"><p><img src="https://habrastorage.org/webt/df/kc/6_/dfkc6_bq7r5jfxx7vr1awxr-mf8.jpeg"></p><br><p>  Sergey Kuksenko é um engenheiro de desempenho que viu o Java ainda na versão 1.0.  Durante esse período, ele conseguiu participar do desenvolvimento de aplicativos móveis, clientes, servidores e máquinas virtuais.  Desde 2005, o Java atua no desempenho e atualmente trabalha na Oracle para melhorar o desempenho do JDK.  Um dos palestrantes mais populares da Joker e JPoint. </p><br><p>  Este habrapost é uma ótima entrevista com Sergey, dedicada aos seguintes tópicos: </p><br><ul><li>  Culto da Performance; </li><li>  Quando e o que precisa ser otimizado, o design inicial da linguagem e da biblioteca; </li><li>  Áreas promissoras para maior otimização; </li><li>  Como participar do desenvolvimento e o que pode ser quebrado por otimizações; </li><li>  Truques do compilador, registro de posicionamento; </li><li>  É possível montar um gato a partir de carne picada; </li><li>  Quando os testes funcionam por cinco dias consecutivos e outras rotinas domésticas; </li><li>  Como se tornar um engenheiro de desempenho; </li><li>  Preparando um relatório para o próximo Coringa. <a name="habracut"></a></li></ul><br><h2 id="o-kulte-proizvoditelnosti">  Sobre o culto à produtividade </h2><br><p>  <strong>Oleg:</strong> Você é nosso antigo orador e esta não é a nossa primeira entrevista.  Diga-me um pouco, quem é você agora, o que você está fazendo? </p><br><p>  <strong>Sergey:</strong> Eu sou o mesmo de muitos anos atrás e estou fazendo a mesma coisa.  Trabalho na equipe Java Performance e sou responsável pelo desempenho das máquinas Java Oracle, OpenJDK. </p><br><p>  <strong>Oleg:</strong> Então, eu tenho uma pergunta meio troll: aqui você é um engenheiro de desempenho e seus relatórios são sobre todos os tipos de desempenho.  Você não acha que o problema de desempenho é superestimado?  Todo mundo corre com ela, mas isso é mesmo necessário? </p><br><p>  <strong>Sergey:</strong> Esta é uma boa pergunta.  Tudo depende do outro.  Esse tipo de atenção do público pode ser considerado excessivo.  A produtividade dos negócios, por outro lado, é dinheiro. </p><br><p>  Esse é o dinheiro real que as pessoas gastam em hardware, em algum tipo de nuvem na Amazônia.  Se você não processar suas solicitações com rapidez suficiente - é isso, você perde clientes, perde dinheiro, perde todo o resto.  Portanto, a solicitação de desempenho, é claro, está sempre lá.  A questão é quão importante é em cada caso.  Fico calado sobre o comércio de alta frequência. </p><br><p>  <strong>Oleg:</strong> A propósito, você acha que o Java é adequado para isso? </p><br><p>  <strong>Sergey:</strong> Você teve a oportunidade de conhecer uma pessoa como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Peter Lawrey</a> ? </p><br><p>  <strong>Oleg:</strong> Quem é o CEO da Chronicle Software, os desenvolvedores do OpenHFT? </p><br><p>  <strong>Sergey:</strong> Este é um amigo muito famoso de Londres que viaja muito em conferências.  Eles trabalham em Java em negociações de alta frequência, vivem muito bem. </p><br><p>  <strong>Oleg:</strong> Eles estão fazendo isso em Java ou é chamado código nativo de Java?  Ainda assim, há uma diferença. </p><br><p>  <strong>Sergey:</strong> Eu não sei nesse nível, ele não contou.  Em princípio, se desejado, tudo o que é necessário pode ser alcançado no próprio Java. </p><br><p>  <strong>Oleg:</strong> Interessante.  Se você tomar, por exemplo, uma comunidade de pythonists, eles terão muito menos culto à produtividade.  Como é exatamente isso que acontece em nossa comunidade?  Talvez <em>você</em> tenha provocado o culto ao desempenho com seus relatórios?  Você, Shipilev, Pangin, Ivanov e assim por diante. </p><br><p> <strong>Sergey:</strong> Eu não sei como aconteceu.  O culto à produtividade na conferência russa é muito maior do que na americana.  Talvez isso reflita o próprio público.  Em nós, as pessoas querem se envolver mais em produtividade, é interessante para elas.  E na América, eles querem fazer mais pelo que pagam mais.  Mas isso é uma hipótese, conjectura.  Isso aconteceu. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MvJJgR6nxXQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="kogda-i-chto-nuzhno-optimizirovat">  Quando e o que precisa ser otimizado </h2><br><p>  <strong>Oleg:</strong> Você disse que ainda há um pedido de desempenho.  Em que momento você precisa começar a pensar em desempenho?  Quando o trovão atacará? </p><br><p>  <strong>Sergey:</strong> Esta é uma pergunta abstrata geral.  É melhor recorrer novamente à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">palestra</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alexey Shipilev</a> em uma das conferências anteriores, onde ele pintou tudo isso o suficiente. </p><br><p>  <strong>Oleg:</strong> Sim, eu lembro da "curva do nome Sh". </p><br><p>  <strong>Sergey:</strong> Você precisa fazer o desempenho imediatamente, mas dependendo de qual nível.  Não é necessário escrever referências imediatamente.  Sabe-se, por exemplo, que a restrição banal do nível de arquitetura da API entre Set como um conjunto e SortedSet já nos impõe restrições algorítmicas fundamentais. </p><br><p>  Se inserirmos um SortedSet na API (embora ninguém precise desse classificado) e, em seguida, ele se espalhar por todo o sistema, essa coisa terá que ser realizada com muito esforço. </p><br><p>  A questão começa no próprio nível de design - é uma questão de restrições mínimas.  As menores restrições possíveis devem ser usadas para que você possa brincar com elas mais tarde.  Por exemplo, quando torci vários pedaços de Java, vieram à mente palavrões extremamente ruins.  Gostaria de fazer algo com uma das classes base, mas não posso fazer nada, porque a API é fixa, você não pode mais alterá-la, ela já foi rastreada.  Mas, para fazer alguns truques e fazer overclock, você precisa ocultar alguns detalhes. </p><br><p>  Estudo de caso: eu costumava me agachar na classe java.math.BigDecimal.  Houve um grande pedido de lados diferentes para dispersá-lo de alguma forma.  Existe um caso bom e especial quando o nosso BigDecimal não é "Grande", é apenas o decimal e você precisa lê-los. </p><br><p>  Agora, é claro, um wrapper apropriado foi criado para isso.  Mas se não houvesse um construtor público saindo do BigDecimal, mas alguns métodos e fábricas estáticos, seria possível tornar o BigDecimal abstrato e cuspir duas implementações diferentes que funcionavam conforme necessário.  Mas isso é impossível, porque o construtor se destaca.  Por esse motivo, você já precisa fazer uma verificação desnecessária do tempo de execução, o que permite seguir um caminho rápido em alguns casos. </p><br><p>  <strong>Oleg:</strong> Daqui resulta que, ao desenvolver uma biblioteca padrão, vale a pena abandonar os designers e fazer construtores em todos os lugares? </p><br><p>  <strong>Sergey:</strong> Está ficando tarde. </p><br><p>  <strong>Oleg:</strong> Se não fosse tarde demais, seria uma boa ideia? </p><br><p>  <strong>Sergey:</strong> Ela daria mais espaço para manobra.  Veja: estamos escrevendo novo, e esse novo está do lado de fora do construtor.  Duas operações são obtidas: primeiro criamos um objeto, depois chamamos o construtor que o preenche.  E, às vezes, seria muito útil ocultar a própria criação do objeto e criar o objeto errado que temos lá fora.  Essa é uma restrição de idioma, o original, desde os primeiros dias do Java. </p><br><p>  <strong>Oleg:</strong> Bem, agora todo mundo usa estruturas DI que permitem que você torça proxies como quiser e adicione qualquer coisa, ignorando essa limitação.  No design original do idioma, você poderia adicionar algo assim, o contêiner de injeção de dependência embutido? </p><br><p>  <strong>Sergey:</strong> Eu tenho uma opinião muito específica sobre o design inicial da linguagem.  Se você se lembra da história do Java 1.0, saiu uma pressão de tempo bastante séria, tudo tinha que ser feito rapidamente. </p><br><p>  Existem milhares de coisas que eu pessoalmente gostaria de ver corrigidas desde a primeira versão.  Mas receio que, mesmo que um dentre esses mil seja escolhido, um-dois-três, e eles tivessem começado a ser feitos no momento do lançamento do primeiro Java, o Java não teria sido lançado.  Este é um exemplo padrão de que o melhor é o inimigo do bem. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/9E6DKrxOLHo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="chto-eschyo-mozhno-optimizirovat-v-java">  O que mais pode ser otimizado em Java </h2><br><p>  <strong>Oleg:</strong> As pessoas comuns podem consertar algo apenas em seu projeto, e você, como engenheiros de desempenho no JDK, afeta imediatamente centenas de milhares de projetos.  Surge a pergunta: ao longo de mais de 20 anos de desenvolvimento Java, houve alguma área no JDK em que a intervenção dos engenheiros principais pode levar a um efeito perceptível?  E quão perceptível é esse "efeito perceptível"? </p><br><p>  <strong>Sergey:</strong> Primeiro, agora o Java não funciona no hardware que, digamos, há 10 anos.  Ferro agora e ferro há 10 anos são duas grandes diferenças, e é aconselhável fazer várias otimizações. </p><br><p>  Em segundo lugar, é claro que é maravilhoso quando um engenheiro de desempenho se senta e acelera algo, obtém grandes números, se reporta a seus superiores, ganha dinheiro por um bônus após esses overclocking.  Mas uma enorme quantidade de trabalho está em andamento em novos projetos.  Um recurso é adicionado e a tarefa do engenheiro de desempenho não é fazer overclock no recurso, mas garantir que tudo esteja bem nesse recurso.  Ou, se não estiver ok, crie algum tipo de correção. </p><br><p>  <strong>Oleg:</strong> Como você pode ter certeza?  Você não verifica o código formalmente.  O que é um "certifique-se"? </p><br><p>  <strong>Sergey:</strong> Garantir que está tudo bem do ponto de vista do desempenho é a opinião subjetiva subjetiva de um engenheiro de desempenho que escreverá um relatório e dirá que "tudo está normal nesse recurso".  Dependendo do tamanho do recurso, isso implica algumas vezes em ação, outras em esforços diferentes.  A partir do fato de que você só precisa se sentar estupidamente, observe o que está sendo feito lá, faça benchmarks nesta área, faça benchmarks, veja o que acontece na saída e tome uma decisão informada razoável. </p><br><p>  <strong>Oleg:</strong> E do ponto de vista do desempenho e dos novos recursos - o Java geralmente avança?  Existe algo aí?  Porque nosso hardware não mudou muito, por exemplo, se falamos sobre a Intel. </p><br><p>  <strong>Sergey:</strong> Por que período isso não mudou? </p><br><p>  <strong>Oleg:</strong> Por exemplo, nos últimos 10 anos. </p><br><p>  <strong>Sergey:</strong> Sim, existe um AVX-512 em hardware há uma década? </p><br><p>  <strong>Oleg:</strong> Não.  Ele, provavelmente, nem sempre está presente no moderno? </p><br><p>  <strong>Sergey:</strong> Eu definitivamente não.  Temos em nosso laboratório, mas tudo é ocupado por compiladores.  Eles estão ferrando até agora, então eu não olhei. </p><br><p>  <strong>Oleg:</strong> O suporte ao AVX-512 pode ser considerado um exemplo de recurso típico? </p><br><p>  <strong>Sergey:</strong> Provavelmente possível.  O que exatamente eu faço: tivemos uma grande camada de trabalho no fato de que existem requisitos modernos para adicionar novos algoritmos criptográficos.  É algo em que os algoritmos de criptografia de dez anos simplesmente não podem ser invocados.  Precisamos de novos algoritmos, chaves maiores.  E a adição de novos algoritmos criptográficos ocorre, eu diria, constantemente. </p><br><p>  <strong>Oleg:</strong> Eles de alguma forma aceleram o hardware? </p><br><p>  <strong>Sergey:</strong> Tudo depende de algoritmos específicos.  Existem algoritmos muito bem acelerados.  A propósito, há 10 anos, isso não teria funcionado no hardware da Intel, mas em cerca de 5 a 6 o quão boas instruções apareceram, até unidades AES com acelerações.  Tudo isso foi implementado com um intervalo de tempo mínimo. </p><br><p>  <strong>Oleg:</strong> E a GPU, eles também são capazes de multiplicar matrizes? </p><br><p>  <strong>Sergey:</strong> Sobre a GPU - uma conversa em separado.  Temos para isso um projeto do Panamá no qual todo esse trabalho é realizado e, algum dia, ele alcançará a linha principal do Java com todas as vantagens. </p><br><p>  <strong>Oleg:</strong> Eu tenho alguns conhecidos que estão envolvidos, condicionalmente, em matemática financeira.  De algum ponto em diante, eles sempre mudam para C ++ para computação e afirmam que é muito inconveniente usar todas essas otimizações e hardware da plataforma gerenciada.  Isso pode ser melhorado? </p><br><p>  <strong>Sergey:</strong> Também temos um grande pedido para isso e há vários requisitos internos.  Por exemplo, para fazer algo funcionar melhor no campo de aprendizado de máquina.  Como regra, essa é uma multiplicação matricial banal, que pode ser descartada na GPU.  O trabalho está em andamento, digamos assim. </p><br><p>  Temos dois grandes projetos: Valhalla e Panamá, que devem coletar recursos como a GPU.  Na junção de Valhalla e Panamá, fica uma API de vetor que funciona com nossas instruções SIMD / SSE / AVX diretamente do código Java, e a própria Valhalla com tipos embutidos é um grande passo nessa direção. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/M4URPKrbr0A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="chto-mozhno-slomat-optimizaciey-kak-pouchastvovat-v-razrabotke">  O que pode ser quebrado pela otimização, como participar do desenvolvimento </h2><br><p>  <strong>Oleg:</strong> Os guarda-chuvas que você mencionou são parecidos.  É possível que um projeto afete outro, inclusive em termos de código e perfil de desempenho?  Por exemplo, você refatorou algo, e o infeliz Ron Presler, derramando lágrimas, está fixando seus testes em um canto à noite? </p><br><p>  <strong>Sergey:</strong> Isso acontece o tempo todo.  Um exemplo concreto é a API Vector.  Para que a API Vector funcione bem, nossos vetores nativos devem eventualmente se tornar tipos de valor ou, como agora é chamado em Java, tipos embutidos.  Você pode fazer uma solução alternativa no hotspot e implementá-lo de alguma forma, mas eu quero ter uma solução geral.  Por outro lado, o principal recurso dos tipos embutidos é precisamente não se preocupar com o layout desses dados, e o layout desses dados é extremamente importante para a API Vector. </p><br><p>  Porque, de fato, corresponde diretamente ao AVX-512 e tudo mais.  É claro que você precisa fazer alguns agachamentos, algumas otimizações que, por um lado, tornarão o tipo embutido um tipo normal, mas que terão um layout baseado em hardware.  Naturalmente, ocorrem interseções.  Se você olhar para os grupos de pessoas que movem o Panamá e movem Valhalla, eles se cruzam mais da metade. </p><br><p>  <strong>Oleg:</strong> Puramente organizacional, aqui você tem um projeto, algum tipo de problema com o desempenho, mas está na junção de vários projetos.  O que fazer depois?  Como resolver isso?  Acontece que isso já é uma troca entre projetos e pessoas, e não entre algumas tarefas abstratas. </p><br><p>  <strong>Sergey:</strong> Tudo é muito simples aqui: se esse é um problema de desempenho com um recurso que está sendo projetado, você precisa ir para as pessoas que estão projetando e dizer: “e assim por diante, o que vamos fazer?  Vamos fazer diferente.  A discussão começa e o problema está resolvido. </p><br><p>  Se o código já existe, ele já funciona.  No caso ideal, você corrige esse problema ou, se não puder corrigi-lo completamente, solta o protótipo e, em seguida, chega ao proprietário do código e diz: "Aqui está o protótipo, o que faremos?"  Além disso, resolvemos esse problema especificamente para cada caso. </p><br><p>  <strong>Oleg:</strong> Temos pessoas interessadas aqui que não podem participar desse processo, esses são usuários finais. </p><br><p>  <strong>Sergey:</strong> Eles não podem participar exatamente o suficiente para que não sejam pagos por seus salários na Oracle.  Se você não precisa de um salário, vá ao OpenJDK e participe. </p><br><p>  <strong>Oleg:</strong> Quão real é?  O OpenJDK tem alguns gênios como você, onde as pessoas comuns estão e onde você está.  Digamos que algo esteja diminuindo a velocidade para mim, o que devo fazer e como? </p><br><p>  <strong>Sergey:</strong> Se você não conhece o problema, esta é uma pergunta separada, se alguém procurará uma solução para você, esta é uma questão como uma área, um exemplo e assim por diante.  Mesmo que você não conheça o problema, talvez faça sentido escrever no OpenJDK e perguntar.  Se isso é algo que alguém clica imediatamente na cabeça, as pessoas o agarram.  Se não interessar a ninguém, ficará sem resposta. </p><br><p>  <strong>Oleg:</strong> Suponha que eu conheça o problema e até saiba o que precisa ser corrigido. </p><br><p>  <strong>Sergey:</strong> Se você conhece o problema, você vem ao OpenJDK, assina todos os pedaços de papel necessários, oferece um patch, ele é revisado e derramado. </p><br><p>  <strong>Oleg:</strong> É simples assim? </p><br><p>  <strong>Sergey:</strong> Bem, sim, um pouco de burocracia, espere um pouco.  Ontem, Tagir ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">lany</a> ) pegou uma pequena correção que eu abandonei.  Ele só quer ser levado até o fim.  Ele começou a lembrá-lo por conta própria.  Ele diz: "Droga, o que é isso, eu fiz tudo, planejado, ninguém está revisando".  Bem, sim, ninguém está revisando.  É julho, metade do escritório de Java está de férias.  Eles sairão de férias e farão isso. </p><br><p>  <strong>Oleg:</strong> Férias nos EUA são quase as mesmas datas que normalmente na Rússia? </p><br><p>  <strong>Sergey:</strong> Não, o sistema de férias nos EUA é completamente diferente do da Rússia.  Em primeiro lugar, eles são significativamente menores.  E também, nos EUA, o sistema de férias está ligado às escolas.  Quando você tem filhos em férias - depois em feriados.  Assim que as férias começam, toda a América começa a se mover.  E como as aulas aqui terminam em meados de junho e começam em meados de agosto, esse delta para férias não é tão grande - apenas dois meses. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ulWWSKr0Ce0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="kompilyatornye-tryuki-razmeschenie-registrov">  Truques do compilador, registrar o posicionamento </h2><br><p>  <strong>Oleg:</strong> Já aconteceu que você otimizou algo em casa e depois disso os usuários tiveram que escrever código de maneira diferente?  Em termos relativos, se a operação de selecionar uma substring costumava ter um intervalo e agora faz uma cópia completa, essa refatoração altera a maneira como você escreve o código. </p><br><p>  <strong>Sergey:</strong> Certamente foi, mas não vou dar exemplos específicos agora.  A questão é: o que as pessoas estabelecem ao escrever código.  Se eles precisarem reduzir o desempenho máximo e, para isso, fazem todos os tipos de truques específicos do compilador, devem estar preparados para que o compilador evolua com o tempo e precisam modificar constantemente seu código de acordo com o estado atual do compilador.  E isso é ótimo. </p><br><p>  Suponhamos que, de repente, depois de 20 anos, Graal venha a ser o compilador principal do HotSpot - então esses pobres terão que reescrever tudo.  Isso só acontece se você assumiu uma tarefa técnica - rastrear alterações no compilador.  É muito mais simples escrever o código correto sem vínculos diretos, com implementações gerais mais ou menos normais. </p><br><p>  A propósito, sobre compiladores - não apenas sobre compiladores Java, mas em geral.  Existe a lei de Moore, que não é uma lei, mas apenas uma observação empírica de que o número de transistores dobra a cada ano e meio. </p><br><p>  E existe exatamente a mesma lei ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Lei de Proebsting</a> ) que o desempenho do código sem modificação aumenta em 4% a cada um ano e meio ou dois.  Esse 4% é o que os usuários finais recebem de graça apenas com a evolução dos compiladores.  Não é hardware, ou seja, compiladores. </p><br><p>  <strong>Oleg:</strong> Gostaria de saber de onde vêm essas porcentagens.  Isso é algum tipo de ineficiência inicial?  Mas, algum dia, esse estoque de ineficiências terminará. </p><br><p>  <strong>Sergey:</strong> Não, é apenas uma questão de desenvolvimento de tecnologia.  Saí dos compiladores quando comecei a trabalhar no desempenho.  Mas uma vez que eu estava noivo, e a maior descoberta para mim foi feita em 2005 ou 2006.  Descobri isso em 2008 porque não <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">li o artigo a</a> tempo. </p><br><p>  Uma tarefa muito importante de qualquer geração de código é a alocação de registros.  Sabe-se que, em geral, esse problema é NP-completo.  É muito difícil resolvê-lo e, portanto, todos os compiladores tentam conduzir algum tipo de algoritmo aproximado com vários graus de qualidade. </p><br><p>  E aqui vem um artigo em que os caras provam que, em alguns casos, que cobrem um grande número de compiladores e um grande número de representações internas com certas restrições, existe um algoritmo polinomial exato para a tarefa de alocar a alocação de registros.  Viva, vamos lá! </p><br><p>  Isso aconteceu em 2005, os compiladores feitos anteriormente não sabiam disso. </p><br><p>  <strong>Oleg:</strong> Agora você pode criar um novo alocador para Java? </p><br><p>  <strong>Sergey:</strong> Agora que existe uma solução teórica, ela pode ser reescrita.  Não entrei em detalhes, mas sei que os caras da Excelsior implementaram o algoritmo. </p><br><p>  <strong>Oleg:</strong> Recentemente, fizemos uma entrevista com Cliff Click e ele falou sobre o alocador de gênios insanamente complexo e insano que ele escreveu para Java.  Não quer escrever outro? </p><br><p>  <strong>Sergey:</strong> Não. </p><br><p>  <strong>Oleg:</strong> Existe algo normal? </p><br><p>  <strong>Sergey:</strong> Não, ele não é normal.  Do meu ponto de vista utilitarista, direi que procuro em assembler e às vezes vejo: "Bem, sim, aqui os registros ficaram ruins".  Se eu recorrer a chutar nossos compiladores e reescrevermos o alocador, o que obteremos?  Obteremos algum ganho, mas é improvável que eu o veja, exceto nos exemplos em que vi a alocação ineficiente de registros.  Enquanto não houver grandes falhas nessa área, sempre haverá algo a ser feito e a obtenção de mais ganhos. </p><br><p>  <strong>Oleg:</strong> Existem áreas de trabalho no JDK em que todo o compilador do compartimento do motor ou a mágica do desempenho chega à superfície?  Você diz que precisa escrever um código normal normal e tudo ficará bem, mas parece suspeito. </p><br><p>  <strong>Sergey:</strong> Tudo ficará bem até você precisar de um super duper.  Se você precisar muito rápido, esteja preparado para sempre reescrevê-lo.  No momento, se você pegar um aplicativo grande e abstrato, em geral, como está escrito - geralmente não desempenha um papel em termos de desempenho. </p><br><p>  Por um lado, assim que o coletor de lixo é acionado, ele consome 10-20%, por outro lado, a arquitetura do aplicativo começa a aparecer.  O grande problema que eu vi no monte de aplicativos é que eles estão mudando os dados.  Pegamos os dados daqui, transferimos para lá, fizemos algumas transformações lá.  Em geral, qualquer programa faz exatamente isso.  Ele transfere dados de um lugar para outro de alguma forma.  Mas se você tiver muitas mudanças no programa, o compilador não ajudará. </p><br><p>  <strong>Oleg:</strong> Você pode tentar rastrear algumas coisas simples, como: esse pedaço de memória está mudando de proprietário e se movendo entre objetos nessa direção. </p><br><p>  <strong>Sergey:</strong> Não, isso é um problema de design.  Mas eu não apenas mudo, mas mudo com modificações, faço algo com elas.  O maior benefício em aplicativos reais e massivos pode ser obtido se você pensar a respeito: são necessárias muitas mudanças.  Em vez de dez, fazer sete já é bom. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/kxgo7Y4cdA8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JRBWBJ6S4aU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>(Pode parecer que o mesmo vídeo foi acidentalmente duplicado aqui. Na verdade, tudo é mais simples, Habr armazenou a imagem errada do YouTube)</em> </p><br><h2 id="sobiraem-koshku-iz-farsha">  Coletamos um gato de carne picada </h2><br><p>  <strong>Oleg:</strong> Acabamos de ter uma conferência Hydra sobre computação distribuída.  E muitas pessoas se preocupam muito com um modelo de custo, determinando o custo de cada operação <strong>-</strong> muito granular, muito preciso.  As pessoas realmente querem escrever todas as instruções, somar o custo de cada uma delas e ver quantas barras seu código precisará.  Eu me pergunto como essa abordagem funciona na realidade moderna.    ,   ? </p><br><p> <strong>:</strong> ,      .  ,    .         ,   .  ,     .   ,    ,      ,        .           ? </p><br><p> <strong>:</strong> : «    ». </p><br><p> <strong>:</strong>  , .   ,     .    ,   ?   .   —   ,      .   ,   , -   ,    . </p><br><p> <strong>:</strong>       ,      ? </p><br><p> <strong>:</strong>     ,     ?   ,     .         ? </p><br><p> <strong>:</strong> , -  ? </p><br><p> <strong>:</strong>   ,          — ,   .   -  .   ?    ,      ,   ,        ,   . ,           . </p><br><p> <strong>:</strong>    . </p><br><p> <strong>:</strong>      ,       1 .   ,      ,   .     , -  ,  -  . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/O8oN4KSZEXE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/i0Jr2l3jrDA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pyat-dney-na-testy-i-drugie-zadachi-performance-inzhenera">        performance- </h2><br><p> <strong>:</strong>     OpenJDK    .        ? C++    .       —   -? </p><br><p> <strong>:</strong> ,  ,  .     .     OpenJDK  15 .      15    . </p><br><p> <strong>:</strong>   ,      ,       .          . </p><br><p> <strong>:</strong>   !       ,    ,   .     ,    ,  , , ,         .  ,       .     :   ,  ,   (  ,     ),      —   .      ,   ,      . </p><br><p> <strong>:</strong> ,      ? </p><br><p> <strong>:</strong> , ,       Java. </p><br><p> <strong>:</strong>   ? </p><br><p> <strong>:</strong> , ,    Valhalla. </p><br><p> <strong>:</strong>    -  ,  ,  —   ,      ?     ?               . </p><br><p> <strong>:</strong>    ,  .   —       .    ,   ,    ,    .  ,  , .      .    2-3 ,      ,      ,       ,  — ,   . </p><br><p> , ,   inline-,        Java        Joker.    .  ,    Java-   ,    runtime-.     red flag: runtime-    0.         ?  ,      out of order- — . </p><br><p>     ,   . ,   .     ?             .       .  baseline,   ,       5-6 ,          —     .  ,    ,  -  2    —     -    .   3%   - ,     .  3%  ? </p><br><p> <strong>:</strong>    ,      ? </p><br><p> <strong>:</strong>     ,     .     performance-,     . ,             ,   — . </p><br><p>        ,    ,  .   performance- —     ,    - performance-  -       ,   .  ,   ,     . </p><br><p> ,    ,   ,   ,   performance- —  class libraries    hotspot,     . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/cz93lTJW-do" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="kak-voyti-v-performance">  «»  performance </h2><br><p> <strong>:</strong> , -     performance-,     . ,      ,       ? </p><br><p> <strong>:</strong>    .     ?    ,    performance-         performance-. </p><br><p>  ,      :  ,       ,   Oracle, Twitter, Netflix  ,    -   .          ,              —    .  ,     performance-    ,   . </p><br><p>     -  ,   ,    performance-  ,      ?     ,   ,    . </p><br><p>     ,   performance- —    .    :          - performance review,        , , ,  ,  .     —  performance   . </p><br><p>    : « ,  ...»,        ,     —  . ,  -     — ,   ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> ,    . </p><br><h2 id="podgotovka-k-joker">   Joker </h2><br><p> <strong>:</strong>    Joker  .   ? </p><br><p> <strong>:</strong>  inline-,     . </p><br><p> <strong>:</strong>  ,    value-? </p><br><p> <strong>:</strong> ,       ,    .          .   ,    .   value   Java-   .    value,  value,   by value, -  by value,       value type.     ,         . </p><br><p>      .  ,   ,   ,  Rémi Forax -        ,    inline-. ,   ,      Kotlin inline-   ,     value- Java,    . </p><br><p>      .         value-,     ,  , mvt (minimum value types),     LW 1.     LW 2 —  ,         .  , ,        ,    .   ,      ,  , ,  performance-  ,   ,       ,   ,   . </p><br><p> <strong>:</strong>    ,               - -? </p><br><p> <strong>:</strong>  , -     .   , ,   ,   ,   invokedynamic  . </p><br><p> <strong>:</strong>  ,    , ,   ,  . </p><br><p> <strong>:</strong>    ,    ,    ,            .  — ,   ,    .   ,     ? </p><br><p> <strong>:</strong>   , ,  ,    . </p><br><p> <strong>:</strong>  .    , ,   inline-       generic-     ,       inline-.        ,        . </p><br><p> <strong>:</strong>     ,  -    ? </p><br><p> <strong>:</strong>    :     inline- LW2   .    value-,     generic,       . </p><br><blockquote>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">«   Java -?        Valhalla»</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Joker</a> ,    - 25-26  2019 .  ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463455/">https://habr.com/ru/post/pt463455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463439/index.html">Computador de controle Apollo de bordo: análise por vareta e engenharia de memória em vários núcleos costurados</a></li>
<li><a href="../pt463441/index.html">Sampler. Utilitário do console para visualizar o resultado de qualquer comando do shell</a></li>
<li><a href="../pt463443/index.html">JMeter - Faca de Testador Suíço (Parte 2)</a></li>
<li><a href="../pt463445/index.html">9 tipos de soluções de software de colaboração para gerenciar equipes ágeis</a></li>
<li><a href="../pt463447/index.html">Astra Linux 1.6 (Smolensk). O sistema está pronto para funcionar com usuários comuns? Exemplos de muletas</a></li>
<li><a href="../pt463459/index.html">Erros ocultos com transições de elemento compartilhado</a></li>
<li><a href="../pt463461/index.html">O que é e o que não está no Go. Parte 1</a></li>
<li><a href="../pt463463/index.html">Método para criar um efeito DRAG e DROP</a></li>
<li><a href="../pt463465/index.html">O livro “JavaScript expressivo. Programação web moderna. 3ª edição</a></li>
<li><a href="../pt463469/index.html">Gato de Schrodinger sem caixa: o problema do consenso em sistemas distribuídos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>