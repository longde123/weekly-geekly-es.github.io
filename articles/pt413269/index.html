<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏭️ ✍️ 👃🏽 Como as máquinas analisam big data: uma introdução aos algoritmos de cluster 💇 🎮 📃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tradução de como as máquinas percebem o big data: uma introdução aos algoritmos de cluster . 

 Dê uma olhada na imagem abaixo. Esta é uma coleção de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como as máquinas analisam big data: uma introdução aos algoritmos de cluster</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>Tradução de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como as máquinas percebem o big data: uma introdução aos algoritmos de cluster</a> .</i> <br><br>  Dê uma olhada na imagem abaixo.  Esta é uma coleção de insetos (caracóis não são insetos, mas não encontraremos falhas) de várias formas e tamanhos.  Agora divida-os em vários grupos de acordo com o grau de semelhança.  Não pega.  Comece agrupando aranhas. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Terminou?  Embora não exista uma solução "certa" aqui, você deve ter dividido essas criaturas em quatro <b>grupos</b> .  Em um aglomerado há aranhas, no segundo - um par de caracóis, no terceiro - borboletas e no quarto - um trio de abelhas e vespas. <br><br>  Bem feito, certo?  Você provavelmente poderia fazer o mesmo se houvesse o dobro de insetos na imagem.  E se você tivesse muito tempo - ou um desejo de entomologia -, provavelmente teria agrupado centenas de insetos. <br><br>  No entanto, para uma máquina, agrupar dez objetos em grupos significativos não é uma tarefa fácil.  Graças a um ramo tão complexo da matemática como a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">combinatória</a> , sabemos que 10 insetos são agrupados de 115.975 maneiras.  E se houver 20 insetos, o número de opções de agrupamento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">excederá 50 trilhões</a> . <br><br>  Com cem insetos, o número de soluções possíveis será maior que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">número de partículas elementares no Universo conhecido</a> .  Quanto mais?  Segundo minhas estimativas, cerca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quinhentos milhões de bilhões de bilhões de vezes mais</a> .  Acontece que mais de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quatro milhões de bilhões de</a></b> soluções do <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google</a></b> (o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que é o Google?</a> ).  E isso é apenas para centenas de objetos. <br><br>  Quase todas essas combinações serão sem sentido.  Apesar do número inimaginável de soluções, você mesmo encontrou rapidamente uma das poucas maneiras úteis de agrupar. <br><br>  Nós, humanos, temos como certa nossa excelente capacidade de catalogar e entender grandes quantidades de dados.  Não importa se é texto ou imagens na tela ou uma sequência de objetos - as pessoas, em geral, compreendem efetivamente os dados provenientes do mundo circundante. <br><br>  Dado que um aspecto fundamental do desenvolvimento da IA ​​e do aprendizado de máquina é que as máquinas podem entender rapidamente grandes volumes de dados de entrada, como posso melhorar a eficiência do trabalho?  Neste artigo, consideraremos três algoritmos de clustering com os quais as máquinas podem compreender rapidamente grandes quantidades de dados.  Esta lista está longe de ser completa - existem outros algoritmos - mas já é bem possível começar com ela. <br><br>  Para cada algoritmo, descreverei quando ele pode ser usado, como funciona e também darei um exemplo com a análise passo a passo.  Acredito que, para uma compreensão real do algoritmo, você precisa repetir o trabalho você mesmo.  Se você estiver <b>realmente interessado</b> , perceberá que é melhor executar algoritmos no papel.  Ato, ninguém te culpará! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Três grupos suspeitosamente limpos com k = 3</i> <br><br><h2>  Cluster K-significa </h2><br><h5>  Usado por: </h5><br>  Quando você entende quantos grupos podem ser obtidos para encontrar <b>um predeterminado</b> (a priori). <br><br><h5>  Como funciona: </h5><br>  O algoritmo atribui aleatoriamente cada observação a uma das <b>k</b> categorias e calcula a <b>média</b> de cada categoria.  Em seguida, ele reatribui cada observação à categoria com a média mais próxima e calcula novamente as médias.  O processo é repetido até que sejam necessárias reatribuições. <br><br><h5>  Exemplo de trabalho: </h5><br>  Pegue um grupo de 12 jogadores e o número de gols marcados por cada um na temporada atual (por exemplo, no intervalo de 3 a 30).  Dividimos os jogadores, digamos, em três grupos. <br><br>  <b>Etapa 1</b> : você precisa dividir os jogadores aleatoriamente em três grupos e calcular a média de cada um deles. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>Etapa 2</b> : reatribua cada jogador ao grupo com a média mais próxima.  Por exemplo, o jogador A (5 gols) vai para o grupo 2 (média = 9).  Então, novamente, calculamos as médias do grupo. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>Repita o</b> passo 2 várias vezes até que os jogadores parem de mudar de grupo.  Neste exemplo artificial, isso acontecerá na próxima iteração.  <b>Pare com isso!</b>  Você formou três clusters a partir de um conjunto de dados! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Os agrupamentos devem corresponder à posição dos jogadores em campo - defensores, zagueiros e atacantes.  K-significa funciona neste exemplo porque há motivos para acreditar que os dados serão divididos nessas três categorias. <br><br>  Assim, com base na variação estatística no desempenho, a máquina pode justificar a localização dos jogadores em campo para qualquer esporte coletivo.  Isso é útil para análises esportivas, bem como para outras tarefas nas quais a divisão do conjunto de dados em grupos predefinidos ajuda a tirar as conclusões apropriadas. <br><br>  Existem várias variações do algoritmo descrito.  A formação inicial de clusters pode ser realizada de várias maneiras.  Examinamos a classificação aleatória dos jogadores em grupos, seguida pelo cálculo das médias.  Como resultado, as médias iniciais do grupo são próximas umas das outras, o que aumenta a repetibilidade. <br><br>  Uma abordagem alternativa é formar grupos que consistem em apenas um jogador e depois agrupá-los nos grupos mais próximos.  Os clusters resultantes são mais dependentes do estágio inicial de formação e a repetibilidade em conjuntos de dados com alta variabilidade diminui.  Mas com essa abordagem, pode levar menos iterações para concluir o algoritmo, porque menos tempo será gasto na divisão dos grupos. <br><br>  A desvantagem óbvia do agrupamento k-means é que você precisa adivinhar <b>antecipadamente</b> quantos clusters você possui.  Existem métodos para avaliar a conformidade de um conjunto específico de clusters.  Por exemplo, Soma dos quadrados dentro do cluster é uma medida de variabilidade dentro de cada cluster.  Quanto "melhores" os agrupamentos, menor a soma total de quadrados intracluster. <br><br><h2>  Armazenamento em cluster hierárquico </h2><br><h5>  Usado por: </h5><br>  Quando você precisa revelar a relação entre os valores (observações). <br><br><h5>  Como funciona: </h5><br>  A matriz de distância é calculada na qual o valor da célula ( <i>i, j</i> ) é a métrica da distância entre os valores de <i>iej</i> .  Então, um par dos valores mais próximos é obtido e a média é calculada.  Uma nova matriz de distância é criada, os valores emparelhados são combinados em um objeto.  Em seguida, um par dos valores mais próximos é obtido dessa nova matriz e um novo valor médio é calculado.  O ciclo se repete até que todos os valores sejam agrupados. <br><br><h5>  Exemplo de trabalho: </h5><br>  Pegue um conjunto de dados extremamente simplificado com várias espécies de baleias e golfinhos.  Sou biólogo e posso garantir que muito mais propriedades são usadas para construir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">árvores filogenéticas</a> .  Mas, no nosso exemplo, nos restringimos ao comprimento característico do corpo de seis espécies de mamíferos marinhos.  Haverá duas etapas de cálculos. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>Etapa 1</b> : a matriz de distâncias entre todas as vistas é calculada.  Usaremos a métrica euclidiana que descreve a distância entre nossos dados, como os assentamentos no mapa.  Você pode obter a diferença no comprimento dos corpos de cada par lendo o valor na interseção da coluna e linha correspondentes. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>Etapa 2</b> : pegue um par de duas espécies mais próximas umas das outras.  Nesse caso, é um golfinho-nariz-de-garrafa e um golfinho-cinzento, no qual o comprimento médio do corpo é de 3,3 m. <br><br>  Repetimos o passo 1, calculando novamente a matriz de distância, mas desta vez combinamos golfinho-nariz-de-garrafa e golfinho-cinzento em um objeto com um comprimento de corpo de 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Agora repetimos o passo 2, mas com uma nova matriz de distância.  Desta vez, a moagem e a baleia assassina serão as mais próximas, então vamos colocá-las em casal e calcular a média - 7 m. <br><br>  Em seguida, repita o passo 1: calcule novamente a matriz de distâncias, mas com a baleia moída e a baleia assassina na forma de um único objeto com 7 m de comprimento. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  Repita a etapa 2 com esta matriz.  A menor distância (3,7 m) será entre os dois objetos combinados, portanto, nós os combinaremos em um objeto ainda maior e calcularemos o valor médio - 5,2 m. <br><br>  Em seguida, repita a etapa 1 e calcule uma nova matriz combinando golfinho-nariz-de-garrafa / golfinho cinza com moagem / baleia assassina. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  Repita a etapa 2. A menor distância (5 m) será entre a jubarte e a barbatana, por isso combinamos e calculamos a média - 17,5 m. <br><br>  Novamente, o passo 1: calcule a matriz. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Por fim, repita o passo 2 - resta apenas uma distância (12,3 m), portanto, uniremos todos em um objeto e pararemos.  Aqui está o que aconteceu: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  O objeto possui uma estrutura hierárquica (lembre-se de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSON</a> ), para que possa ser exibido como um gráfico em árvore ou dendrograma.  O resultado é semelhante a uma árvore genealógica.  Quanto mais próximos dois valores estiverem de uma árvore, mais semelhantes ou mais estreitamente conectados. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Um dendograma simples gerado usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">R-Fiddle.org</a></i> <br><br>  A estrutura do dendrograma permite entender a estrutura do próprio conjunto de dados.  Em nosso exemplo, temos dois galhos principais - um com jubarte e barbatana, o outro com um golfinho-nariz-de-garrafa / golfinho-cinzento e uma baleia grind / killer. <br><br>  Na biologia evolutiva, conjuntos de dados muito maiores, com muitas espécies e uma abundância de caracteres, são usados ​​para identificar relações taxonômicas.  Fora da biologia, o cluster hierárquico é aplicado nas áreas de mineração de dados e aprendizado de máquina. <br><br>  Essa abordagem não requer previsão do número necessário de clusters.  Você pode dividir o dendrograma resultante em grupos, “aparando” a árvore na altura desejada.  Você pode escolher a altura de diferentes maneiras, dependendo da resolução desejada do cluster de dados. <br>  Por exemplo, se o dendrograma acima for cortado a uma altura de 10, cruzaremos os dois ramos principais, dividindo o dendrograma em duas colunas.  Se cortar a uma altura de 2, divida o dendrograma em três grupos. <br><br>  Outros algoritmos de cluster hierárquico podem diferir em três aspectos daqueles descritos neste artigo. <br><br>  A coisa mais importante é a abordagem.  Aqui usamos o método <b>aglomerativo</b> : começamos com valores individuais e os agrupamos ciclicamente até obter um grande agrupamento.  Uma abordagem alternativa (e computacionalmente mais complexa) implica a sequência inversa: primeiro um grande cluster é criado e, em seguida, é dividido sequencialmente em clusters cada vez menores até que valores separados permaneçam. <br><br>  Existem também vários métodos para calcular matrizes de distância.  As métricas euclidianas são suficientes para a maioria das tarefas, mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outras métricas</a> são mais adequadas em algumas situações. <br><br>  Finalmente, o critério de ligação pode variar.  O relacionamento entre os clusters depende da proximidade entre eles, mas a definição de "proximidade" pode ser diferente.  Em nosso exemplo, medimos a distância entre os valores médios (ou "centróides") de cada grupo e combinamos os grupos mais próximos em pares.  Mas você pode usar outra definição. <br><br>  Suponha que cada cluster consiste em vários valores discretos.  A distância entre dois clusters pode ser definida como a distância mínima (ou máxima) entre qualquer um de seus valores, conforme mostrado abaixo.  Para diferentes contextos, é conveniente usar diferentes definições do critério de junção. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Vermelho / azul: piscina centróide;</i>  <i>vermelho / verde: combinação baseada em mínimos;</i>  <i>verde / azul: mesclando com base em altas.</i> <br><br><h2>  Definição de comunidades em gráficos (detecção de comunidade de gráficos) </h2><br><h5>  Usado por: </h5><br>  Quando seus dados podem ser apresentados na forma de uma rede, ou "gráfico". <br><br><h5>  Como funciona: </h5><br>  <b>Uma comunidade em um gráfico</b> pode ser definida aproximadamente como um subconjunto de vértices que estão mais conectados entre si do que com o restante da rede.  Existem diferentes algoritmos de definição de comunidade baseados em definições mais específicas, como Edge Betweenness, Modularity-Maximsation, Walktrap, Percolation de Clique, Leading Eigenvector ... <br><br><h5>  Exemplo de trabalho: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A teoria dos grafos</a> é um ramo da matemática muito interessante que nos permite modelar sistemas complexos na forma de conjuntos abstratos de “pontos” (vértices, nós) conectados por “linhas” (arestas). <br><br>  Talvez a primeira aplicação de gráficos que vem à mente seja o estudo de redes sociais.  Nesse caso, os picos representam pessoas conectadas por costelas a amigos / assinantes.  Mas você pode imaginar qualquer sistema na forma de uma rede se puder justificar o método de conexão significativa dos componentes.  Aplicações inovadoras de agrupamento usando a teoria dos grafos incluem a extração de propriedades de dados visuais e a análise de redes reguladoras genéticas. <br><br>  Como um exemplo simples, vejamos o gráfico abaixo.  Isso mostra os oito sites que eu visito com mais frequência.  Os links entre eles são baseados em links nos artigos da Wikipedia.  Esses dados podem ser coletados manualmente, mas para projetos grandes, é muito mais rápido escrever um script Python.  Por exemplo, este: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>O gráfico é construído usando o pacote igraph para R 3.3.3</i> <br><br>  A cor dos picos depende da participação nas comunidades e o tamanho depende da centralidade.  Observe que os mais centrais são o Google e o Twitter. <br><br>  Além disso, os clusters resultantes refletem com muita precisão tarefas reais (esse é sempre um indicador importante de desempenho).  Os vértices que representam os sites de link / pesquisa são destacados em amarelo;  sites destacados em azul para publicações on-line (artigos, tweets ou código);  destacados em vermelho estão o PayPal e o YouTube, fundados por ex-funcionários do PayPal.  Boa dedução para o computador! <br><br>  Além de visualizar grandes sistemas, o verdadeiro poder das redes reside na análise matemática.  Vamos começar convertendo a imagem da rede em um formato matemático.  A seguir, <b>é apresentada a</b> matriz de <b>adjacência</b> da rede. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Os valores nas interseções de colunas e linhas indicam se há uma aresta entre esse par de vértices.  Por exemplo, entre Médio e Twitter, é, portanto, na interseção dessa linha e coluna, que está 1. E entre Médio e PayPal, não há aresta; portanto, na célula correspondente, há 0. <br><br>  Se representarmos todas as propriedades da rede na forma de uma matriz de adjacência, isso nos permitirá tirar todos os tipos de conclusões úteis.  Por exemplo, a soma dos valores em qualquer coluna ou linha caracteriza o <b>grau de</b> cada vértice - ou seja, o número de objetos conectados a esse vértice.  Geralmente indicado pela letra <i>k</i> . <br><br>  Se somarmos os graus de todos os vértices e dividirmos por dois, obtemos L - o número de arestas na rede.  E o número de linhas e colunas é igual a N - o número de vértices na rede. <br><br>  Conhecendo apenas k, L, N e os valores em todas as células da matriz de adjacência A, podemos calcular a modularidade de qualquer cluster. <br><br>  Suponha que agrupamos uma rede em várias comunidades.  Em seguida, você pode usar o valor da modularidade para prever a "qualidade" do cluster.  Uma modularidade mais alta indica que dividimos a rede em comunidades "exatas", e uma modularidade mais baixa sugere que os clusters são formados mais por acaso do que razoavelmente.  Para tornar mais claro: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  A modularidade é uma medida da "qualidade" dos grupos. <br><br>  A modularidade pode ser calculada usando a seguinte fórmula: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Vamos olhar para esta fórmula bastante impressionante. <br><br>  <b>M</b> , como você sabe, isso é modularidade. <br><br>  O coeficiente <b>1 / 2L</b> significa que dividimos o restante do "corpo" da fórmula por 2L, ou seja, pelo número duplo de arestas na rede.  Em Python, pode-se escrever: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  O que é <code>#stuff with i and j</code> ?  O bit entre parênteses nos diz para subtrair (k_i k_j) / 2L de A_ij, onde A_ij é o valor na matriz na interseção da linha ie coluna j. <br><br>  Os valores k_i e k_j são os graus de cada vértice.  Eles podem ser encontrados somando os valores na linha ie coluna j, respectivamente.  Se os multiplicarmos e dividirmos por 2L, obteremos o número esperado de arestas entre os vértices iej se a rede for misturada aleatoriamente. <br><br>  O conteúdo dos colchetes reflete a diferença entre a estrutura real da rede e a esperada se a rede foi reconstruída aleatoriamente.  Se você brinca com os valores, a modularidade mais alta será A_ij = 1 e baixa (k_i k_j) / 2L.  Ou seja, a modularidade aumenta se houver uma aresta "inesperada" entre os vértices iej. <br><br>  Finalmente, multiplicamos o conteúdo dos colchetes pelo que é indicado na fórmula como δc_i, c_j.  Esta é a função Kronecker-delta.  Aqui está sua implementação em Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Sim, tão simples.  A função recebe dois argumentos e, se forem idênticos, retornará 1 e, se não, então 0. <br><br>  Em outras palavras, se os vértices iej caírem em um cluster, então δc_i, c_j = 1. E se eles estiverem em clusters diferentes, a função retornará 0. <br><br>  Como multiplicamos o conteúdo dos colchetes pelo símbolo Kronecker, o resultado da soma investida the será mais alto quando os vértices dentro de um cluster forem conectados por um grande número de arestas "inesperadas".  Assim, a modularidade é um indicador de quão bem um gráfico é agrupado em comunidades individuais. <br><br>  A divisão por 2L limita a modularidade superior à unidade.  Se a modularidade for próxima de 0 ou negativa, isso significa que o cluster atual da rede não faz sentido.  Ao aumentar a modularidade, podemos encontrar uma maneira melhor de agrupar a rede. <br><br>  Observe que, para avaliar a "qualidade" do agrupamento de um gráfico, precisamos determinar com antecedência como ele será agrupado.  Infelizmente, a menos que a amostra seja muito pequena, devido à complexidade computacional, é simplesmente fisicamente impossível passar estupidamente por todos os métodos de agrupar um gráfico comparando sua modularidade. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A Combinatorics</a> sugere que, para uma rede com 8 vértices, existem 4.140 métodos de agrupamento.  Para uma rede com 16 vértices, já haverá mais de 10 bilhões de maneiras, para uma rede com 32 vértices, 128 septilhões e para uma rede com 80 vértices, o número de métodos de agrupamento excederá o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">número de átomos no Universo observável</a> . <br><br>  Portanto, em vez de enumeração, usaremos o método heurístico, que ajudará a calcular relativamente facilmente clusters com o máximo de modularidade.  Esse é um algoritmo chamado <i>Fast-Greedy Modularity-Maximization</i> , um tipo de análogo ao algoritmo de agrupamento hierárquico aglomerado descrito acima.  Em vez de combinar com base na proximidade, o Mod-Max une comunidades, dependendo das mudanças na modularidade.  Como funciona: <br><br>  <b>Primeiro,</b> cada vértice é atribuído à sua própria comunidade e a modularidade de toda a rede é calculada - M. <br><br>  <b>Etapa 1</b> : para cada par de comunidades conectadas por pelo menos uma borda, o algoritmo calcula a alteração resultante na modularidade ΔM no caso de combinar esses pares de comunidades. <br><br>  <b>Etapa 2</b> : então um par é obtido, quando combinado, ΔM será máximo e combinado.  Para esse cluster, uma nova modularidade é calculada e armazenada. <br><br>  As etapas 1 e 2 são <b>repetidas</b> : cada vez que um par de comunidades se junta, o que dá o maior AM, um novo esquema de agrupamento e seu M. <br><br>  As iterações <b>param</b> quando todos os vértices são agrupados em um cluster enorme.  Agora, o algoritmo verifica os registros armazenados e encontra o esquema de cluster com a mais alta modularidade.  É ela quem volta como uma estrutura comunitária. <br><br>  Era computacionalmente difícil, pelo menos para as pessoas.  A teoria dos grafos é uma fonte rica de problemas computacionais difíceis e de NP-hard.  Usando gráficos, podemos tirar muitas conclusões úteis sobre sistemas e conjuntos de dados complexos.  Pergunte a Larry Page, cujo algoritmo PageRank - que ajudou o Google a se transformar de uma startup para uma dominante global em menos de uma geração - é inteiramente baseado na teoria dos grafos. <br><br>  Hoje, estudos sobre a teoria dos grafos se concentram na identificação de comunidades.  Existem muitas alternativas para o algoritmo Modularity-Maximization, que, embora útil, não deixa de ter suas desvantagens. <br><br>  Primeiro, com uma abordagem aglomerativa, comunidades pequenas e bem definidas são frequentemente combinadas em comunidades maiores.  Isso é chamado de limite de resolução - o algoritmo não aloca comunidades menores que um determinado tamanho.  Outra desvantagem é que, em vez de um pico global pronunciado e facilmente alcançável, o algoritmo Mod-Max procura gerar um amplo "platô" a partir de muitos valores próximos de modularidade.  Como resultado, é difícil destacar o vencedor. <br><br>  Outros algoritmos usam métodos diferentes para definir comunidades.  Por exemplo, Edge-Betweenness é um algoritmo de divisão (divisão) que começa agrupando todos os vértices em um cluster enorme.  Em seguida, as arestas menos "importantes" são removidas iterativamente até que todos os vértices sejam isolados.  O resultado é uma estrutura hierárquica na qual os vértices estão mais próximos, mais semelhantes. <br><br>  O algoritmo, Clique Percolation, leva em consideração possíveis interseções entre comunidades.  Há um grupo de algoritmos baseados em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caminhada aleatória</a> em um gráfico e existem métodos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">agrupamento espectral</a> que lidam com a decomposição espectral (composição automática) da matriz de adjacência e outras matrizes dela derivadas.  Todas essas idéias são usadas para destacar recursos, por exemplo, na visão de máquina. <br><br>  Não analisaremos exemplos de trabalho para cada algoritmo em detalhes.  ,              ,     20    . <br><br><h2>  Conclusão </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   —    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413269/">https://habr.com/ru/post/pt413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413253/index.html">Richard Hamming: Capítulo 21. Fibra Óptica</a></li>
<li><a href="../pt413255/index.html">Richard Hamming: Capítulo 27. Dados Inválidos</a></li>
<li><a href="../pt413261/index.html">Como a pesquisa funciona</a></li>
<li><a href="../pt413265/index.html">Para o balneário com TI</a></li>
<li><a href="../pt413267/index.html">10 qualidades essenciais a serem observadas para um gerente de produto iniciante</a></li>
<li><a href="../pt413271/index.html">Sem senhas: como o sistema de autenticação em um registro distribuído funciona</a></li>
<li><a href="../pt413273/index.html">Gerenciamento de requisitos de produtos de TI dentro da empresa</a></li>
<li><a href="../pt413275/index.html">Teste comparativo de churrasqueiras para obter o resultado mais delicioso</a></li>
<li><a href="../pt413277/index.html">JSFiddle - nova versão</a></li>
<li><a href="../pt413279/index.html">O aplicativo móvel calcula o conteúdo calórico de pratos em restaurantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>