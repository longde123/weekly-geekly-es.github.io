<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≠Ô∏è ‚úçÔ∏è üëÉüèΩ Como as m√°quinas analisam big data: uma introdu√ß√£o aos algoritmos de cluster üíá üéÆ üìÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tradu√ß√£o de como as m√°quinas percebem o big data: uma introdu√ß√£o aos algoritmos de cluster . 

 D√™ uma olhada na imagem abaixo. Esta √© uma cole√ß√£o de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como as m√°quinas analisam big data: uma introdu√ß√£o aos algoritmos de cluster</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>Tradu√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">como as m√°quinas percebem o big data: uma introdu√ß√£o aos algoritmos de cluster</a> .</i> <br><br>  D√™ uma olhada na imagem abaixo.  Esta √© uma cole√ß√£o de insetos (carac√≥is n√£o s√£o insetos, mas n√£o encontraremos falhas) de v√°rias formas e tamanhos.  Agora divida-os em v√°rios grupos de acordo com o grau de semelhan√ßa.  N√£o pega.  Comece agrupando aranhas. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Terminou?  Embora n√£o exista uma solu√ß√£o "certa" aqui, voc√™ deve ter dividido essas criaturas em quatro <b>grupos</b> .  Em um aglomerado h√° aranhas, no segundo - um par de carac√≥is, no terceiro - borboletas e no quarto - um trio de abelhas e vespas. <br><br>  Bem feito, certo?  Voc√™ provavelmente poderia fazer o mesmo se houvesse o dobro de insetos na imagem.  E se voc√™ tivesse muito tempo - ou um desejo de entomologia -, provavelmente teria agrupado centenas de insetos. <br><br>  No entanto, para uma m√°quina, agrupar dez objetos em grupos significativos n√£o √© uma tarefa f√°cil.  Gra√ßas a um ramo t√£o complexo da matem√°tica como a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">combinat√≥ria</a> , sabemos que 10 insetos s√£o agrupados de 115.975 maneiras.  E se houver 20 insetos, o n√∫mero de op√ß√µes de agrupamento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exceder√° 50 trilh√µes</a> . <br><br>  Com cem insetos, o n√∫mero de solu√ß√µes poss√≠veis ser√° maior que o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√∫mero de part√≠culas elementares no Universo conhecido</a> .  Quanto mais?  Segundo minhas estimativas, cerca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quinhentos milh√µes de bilh√µes de bilh√µes de vezes mais</a> .  Acontece que mais de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">quatro milh√µes de bilh√µes de</a></b> solu√ß√µes do <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google</a></b> (o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que √© o Google?</a> ).  E isso √© apenas para centenas de objetos. <br><br>  Quase todas essas combina√ß√µes ser√£o sem sentido.  Apesar do n√∫mero inimagin√°vel de solu√ß√µes, voc√™ mesmo encontrou rapidamente uma das poucas maneiras √∫teis de agrupar. <br><br>  N√≥s, humanos, temos como certa nossa excelente capacidade de catalogar e entender grandes quantidades de dados.  N√£o importa se √© texto ou imagens na tela ou uma sequ√™ncia de objetos - as pessoas, em geral, compreendem efetivamente os dados provenientes do mundo circundante. <br><br>  Dado que um aspecto fundamental do desenvolvimento da IA ‚Äã‚Äãe do aprendizado de m√°quina √© que as m√°quinas podem entender rapidamente grandes volumes de dados de entrada, como posso melhorar a efici√™ncia do trabalho?  Neste artigo, consideraremos tr√™s algoritmos de clustering com os quais as m√°quinas podem compreender rapidamente grandes quantidades de dados.  Esta lista est√° longe de ser completa - existem outros algoritmos - mas j√° √© bem poss√≠vel come√ßar com ela. <br><br>  Para cada algoritmo, descreverei quando ele pode ser usado, como funciona e tamb√©m darei um exemplo com a an√°lise passo a passo.  Acredito que, para uma compreens√£o real do algoritmo, voc√™ precisa repetir o trabalho voc√™ mesmo.  Se voc√™ estiver <b>realmente interessado</b> , perceber√° que √© melhor executar algoritmos no papel.  Ato, ningu√©m te culpar√°! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Tr√™s grupos suspeitosamente limpos com k = 3</i> <br><br><h2>  Cluster K-significa </h2><br><h5>  Usado por: </h5><br>  Quando voc√™ entende quantos grupos podem ser obtidos para encontrar <b>um predeterminado</b> (a priori). <br><br><h5>  Como funciona: </h5><br>  O algoritmo atribui aleatoriamente cada observa√ß√£o a uma das <b>k</b> categorias e calcula a <b>m√©dia</b> de cada categoria.  Em seguida, ele reatribui cada observa√ß√£o √† categoria com a m√©dia mais pr√≥xima e calcula novamente as m√©dias.  O processo √© repetido at√© que sejam necess√°rias reatribui√ß√µes. <br><br><h5>  Exemplo de trabalho: </h5><br>  Pegue um grupo de 12 jogadores e o n√∫mero de gols marcados por cada um na temporada atual (por exemplo, no intervalo de 3 a 30).  Dividimos os jogadores, digamos, em tr√™s grupos. <br><br>  <b>Etapa 1</b> : voc√™ precisa dividir os jogadores aleatoriamente em tr√™s grupos e calcular a m√©dia de cada um deles. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>Etapa 2</b> : reatribua cada jogador ao grupo com a m√©dia mais pr√≥xima.  Por exemplo, o jogador A (5 gols) vai para o grupo 2 (m√©dia = 9).  Ent√£o, novamente, calculamos as m√©dias do grupo. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>Repita o</b> passo 2 v√°rias vezes at√© que os jogadores parem de mudar de grupo.  Neste exemplo artificial, isso acontecer√° na pr√≥xima itera√ß√£o.  <b>Pare com isso!</b>  Voc√™ formou tr√™s clusters a partir de um conjunto de dados! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Os agrupamentos devem corresponder √† posi√ß√£o dos jogadores em campo - defensores, zagueiros e atacantes.  K-significa funciona neste exemplo porque h√° motivos para acreditar que os dados ser√£o divididos nessas tr√™s categorias. <br><br>  Assim, com base na varia√ß√£o estat√≠stica no desempenho, a m√°quina pode justificar a localiza√ß√£o dos jogadores em campo para qualquer esporte coletivo.  Isso √© √∫til para an√°lises esportivas, bem como para outras tarefas nas quais a divis√£o do conjunto de dados em grupos predefinidos ajuda a tirar as conclus√µes apropriadas. <br><br>  Existem v√°rias varia√ß√µes do algoritmo descrito.  A forma√ß√£o inicial de clusters pode ser realizada de v√°rias maneiras.  Examinamos a classifica√ß√£o aleat√≥ria dos jogadores em grupos, seguida pelo c√°lculo das m√©dias.  Como resultado, as m√©dias iniciais do grupo s√£o pr√≥ximas umas das outras, o que aumenta a repetibilidade. <br><br>  Uma abordagem alternativa √© formar grupos que consistem em apenas um jogador e depois agrup√°-los nos grupos mais pr√≥ximos.  Os clusters resultantes s√£o mais dependentes do est√°gio inicial de forma√ß√£o e a repetibilidade em conjuntos de dados com alta variabilidade diminui.  Mas com essa abordagem, pode levar menos itera√ß√µes para concluir o algoritmo, porque menos tempo ser√° gasto na divis√£o dos grupos. <br><br>  A desvantagem √≥bvia do agrupamento k-means √© que voc√™ precisa adivinhar <b>antecipadamente</b> quantos clusters voc√™ possui.  Existem m√©todos para avaliar a conformidade de um conjunto espec√≠fico de clusters.  Por exemplo, Soma dos quadrados dentro do cluster √© uma medida de variabilidade dentro de cada cluster.  Quanto "melhores" os agrupamentos, menor a soma total de quadrados intracluster. <br><br><h2>  Armazenamento em cluster hier√°rquico </h2><br><h5>  Usado por: </h5><br>  Quando voc√™ precisa revelar a rela√ß√£o entre os valores (observa√ß√µes). <br><br><h5>  Como funciona: </h5><br>  A matriz de dist√¢ncia √© calculada na qual o valor da c√©lula ( <i>i, j</i> ) √© a m√©trica da dist√¢ncia entre os valores de <i>iej</i> .  Ent√£o, um par dos valores mais pr√≥ximos √© obtido e a m√©dia √© calculada.  Uma nova matriz de dist√¢ncia √© criada, os valores emparelhados s√£o combinados em um objeto.  Em seguida, um par dos valores mais pr√≥ximos √© obtido dessa nova matriz e um novo valor m√©dio √© calculado.  O ciclo se repete at√© que todos os valores sejam agrupados. <br><br><h5>  Exemplo de trabalho: </h5><br>  Pegue um conjunto de dados extremamente simplificado com v√°rias esp√©cies de baleias e golfinhos.  Sou bi√≥logo e posso garantir que muito mais propriedades s√£o usadas para construir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√°rvores filogen√©ticas</a> .  Mas, no nosso exemplo, nos restringimos ao comprimento caracter√≠stico do corpo de seis esp√©cies de mam√≠feros marinhos.  Haver√° duas etapas de c√°lculos. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>Etapa 1</b> : a matriz de dist√¢ncias entre todas as vistas √© calculada.  Usaremos a m√©trica euclidiana que descreve a dist√¢ncia entre nossos dados, como os assentamentos no mapa.  Voc√™ pode obter a diferen√ßa no comprimento dos corpos de cada par lendo o valor na interse√ß√£o da coluna e linha correspondentes. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>Etapa 2</b> : pegue um par de duas esp√©cies mais pr√≥ximas umas das outras.  Nesse caso, √© um golfinho-nariz-de-garrafa e um golfinho-cinzento, no qual o comprimento m√©dio do corpo √© de 3,3 m. <br><br>  Repetimos o passo 1, calculando novamente a matriz de dist√¢ncia, mas desta vez combinamos golfinho-nariz-de-garrafa e golfinho-cinzento em um objeto com um comprimento de corpo de 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Agora repetimos o passo 2, mas com uma nova matriz de dist√¢ncia.  Desta vez, a moagem e a baleia assassina ser√£o as mais pr√≥ximas, ent√£o vamos coloc√°-las em casal e calcular a m√©dia - 7 m. <br><br>  Em seguida, repita o passo 1: calcule novamente a matriz de dist√¢ncias, mas com a baleia mo√≠da e a baleia assassina na forma de um √∫nico objeto com 7 m de comprimento. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  Repita a etapa 2 com esta matriz.  A menor dist√¢ncia (3,7 m) ser√° entre os dois objetos combinados, portanto, n√≥s os combinaremos em um objeto ainda maior e calcularemos o valor m√©dio - 5,2 m. <br><br>  Em seguida, repita a etapa 1 e calcule uma nova matriz combinando golfinho-nariz-de-garrafa / golfinho cinza com moagem / baleia assassina. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  Repita a etapa 2. A menor dist√¢ncia (5 m) ser√° entre a jubarte e a barbatana, por isso combinamos e calculamos a m√©dia - 17,5 m. <br><br>  Novamente, o passo 1: calcule a matriz. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Por fim, repita o passo 2 - resta apenas uma dist√¢ncia (12,3 m), portanto, uniremos todos em um objeto e pararemos.  Aqui est√° o que aconteceu: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  O objeto possui uma estrutura hier√°rquica (lembre-se de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JSON</a> ), para que possa ser exibido como um gr√°fico em √°rvore ou dendrograma.  O resultado √© semelhante a uma √°rvore geneal√≥gica.  Quanto mais pr√≥ximos dois valores estiverem de uma √°rvore, mais semelhantes ou mais estreitamente conectados. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Um dendograma simples gerado usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">R-Fiddle.org</a></i> <br><br>  A estrutura do dendrograma permite entender a estrutura do pr√≥prio conjunto de dados.  Em nosso exemplo, temos dois galhos principais - um com jubarte e barbatana, o outro com um golfinho-nariz-de-garrafa / golfinho-cinzento e uma baleia grind / killer. <br><br>  Na biologia evolutiva, conjuntos de dados muito maiores, com muitas esp√©cies e uma abund√¢ncia de caracteres, s√£o usados ‚Äã‚Äãpara identificar rela√ß√µes taxon√¥micas.  Fora da biologia, o cluster hier√°rquico √© aplicado nas √°reas de minera√ß√£o de dados e aprendizado de m√°quina. <br><br>  Essa abordagem n√£o requer previs√£o do n√∫mero necess√°rio de clusters.  Voc√™ pode dividir o dendrograma resultante em grupos, ‚Äúaparando‚Äù a √°rvore na altura desejada.  Voc√™ pode escolher a altura de diferentes maneiras, dependendo da resolu√ß√£o desejada do cluster de dados. <br>  Por exemplo, se o dendrograma acima for cortado a uma altura de 10, cruzaremos os dois ramos principais, dividindo o dendrograma em duas colunas.  Se cortar a uma altura de 2, divida o dendrograma em tr√™s grupos. <br><br>  Outros algoritmos de cluster hier√°rquico podem diferir em tr√™s aspectos daqueles descritos neste artigo. <br><br>  A coisa mais importante √© a abordagem.  Aqui usamos o m√©todo <b>aglomerativo</b> : come√ßamos com valores individuais e os agrupamos ciclicamente at√© obter um grande agrupamento.  Uma abordagem alternativa (e computacionalmente mais complexa) implica a sequ√™ncia inversa: primeiro um grande cluster √© criado e, em seguida, √© dividido sequencialmente em clusters cada vez menores at√© que valores separados permane√ßam. <br><br>  Existem tamb√©m v√°rios m√©todos para calcular matrizes de dist√¢ncia.  As m√©tricas euclidianas s√£o suficientes para a maioria das tarefas, mas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">outras m√©tricas</a> s√£o mais adequadas em algumas situa√ß√µes. <br><br>  Finalmente, o crit√©rio de liga√ß√£o pode variar.  O relacionamento entre os clusters depende da proximidade entre eles, mas a defini√ß√£o de "proximidade" pode ser diferente.  Em nosso exemplo, medimos a dist√¢ncia entre os valores m√©dios (ou "centr√≥ides") de cada grupo e combinamos os grupos mais pr√≥ximos em pares.  Mas voc√™ pode usar outra defini√ß√£o. <br><br>  Suponha que cada cluster consiste em v√°rios valores discretos.  A dist√¢ncia entre dois clusters pode ser definida como a dist√¢ncia m√≠nima (ou m√°xima) entre qualquer um de seus valores, conforme mostrado abaixo.  Para diferentes contextos, √© conveniente usar diferentes defini√ß√µes do crit√©rio de jun√ß√£o. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Vermelho / azul: piscina centr√≥ide;</i>  <i>vermelho / verde: combina√ß√£o baseada em m√≠nimos;</i>  <i>verde / azul: mesclando com base em altas.</i> <br><br><h2>  Defini√ß√£o de comunidades em gr√°ficos (detec√ß√£o de comunidade de gr√°ficos) </h2><br><h5>  Usado por: </h5><br>  Quando seus dados podem ser apresentados na forma de uma rede, ou "gr√°fico". <br><br><h5>  Como funciona: </h5><br>  <b>Uma comunidade em um gr√°fico</b> pode ser definida aproximadamente como um subconjunto de v√©rtices que est√£o mais conectados entre si do que com o restante da rede.  Existem diferentes algoritmos de defini√ß√£o de comunidade baseados em defini√ß√µes mais espec√≠ficas, como Edge Betweenness, Modularity-Maximsation, Walktrap, Percolation de Clique, Leading Eigenvector ... <br><br><h5>  Exemplo de trabalho: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A teoria dos grafos</a> √© um ramo da matem√°tica muito interessante que nos permite modelar sistemas complexos na forma de conjuntos abstratos de ‚Äúpontos‚Äù (v√©rtices, n√≥s) conectados por ‚Äúlinhas‚Äù (arestas). <br><br>  Talvez a primeira aplica√ß√£o de gr√°ficos que vem √† mente seja o estudo de redes sociais.  Nesse caso, os picos representam pessoas conectadas por costelas a amigos / assinantes.  Mas voc√™ pode imaginar qualquer sistema na forma de uma rede se puder justificar o m√©todo de conex√£o significativa dos componentes.  Aplica√ß√µes inovadoras de agrupamento usando a teoria dos grafos incluem a extra√ß√£o de propriedades de dados visuais e a an√°lise de redes reguladoras gen√©ticas. <br><br>  Como um exemplo simples, vejamos o gr√°fico abaixo.  Isso mostra os oito sites que eu visito com mais frequ√™ncia.  Os links entre eles s√£o baseados em links nos artigos da Wikipedia.  Esses dados podem ser coletados manualmente, mas para projetos grandes, √© muito mais r√°pido escrever um script Python.  Por exemplo, este: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>O gr√°fico √© constru√≠do usando o pacote igraph para R 3.3.3</i> <br><br>  A cor dos picos depende da participa√ß√£o nas comunidades e o tamanho depende da centralidade.  Observe que os mais centrais s√£o o Google e o Twitter. <br><br>  Al√©m disso, os clusters resultantes refletem com muita precis√£o tarefas reais (esse √© sempre um indicador importante de desempenho).  Os v√©rtices que representam os sites de link / pesquisa s√£o destacados em amarelo;  sites destacados em azul para publica√ß√µes on-line (artigos, tweets ou c√≥digo);  destacados em vermelho est√£o o PayPal e o YouTube, fundados por ex-funcion√°rios do PayPal.  Boa dedu√ß√£o para o computador! <br><br>  Al√©m de visualizar grandes sistemas, o verdadeiro poder das redes reside na an√°lise matem√°tica.  Vamos come√ßar convertendo a imagem da rede em um formato matem√°tico.  A seguir, <b>√© apresentada a</b> matriz de <b>adjac√™ncia</b> da rede. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Os valores nas interse√ß√µes de colunas e linhas indicam se h√° uma aresta entre esse par de v√©rtices.  Por exemplo, entre M√©dio e Twitter, √©, portanto, na interse√ß√£o dessa linha e coluna, que est√° 1. E entre M√©dio e PayPal, n√£o h√° aresta; portanto, na c√©lula correspondente, h√° 0. <br><br>  Se representarmos todas as propriedades da rede na forma de uma matriz de adjac√™ncia, isso nos permitir√° tirar todos os tipos de conclus√µes √∫teis.  Por exemplo, a soma dos valores em qualquer coluna ou linha caracteriza o <b>grau de</b> cada v√©rtice - ou seja, o n√∫mero de objetos conectados a esse v√©rtice.  Geralmente indicado pela letra <i>k</i> . <br><br>  Se somarmos os graus de todos os v√©rtices e dividirmos por dois, obtemos L - o n√∫mero de arestas na rede.  E o n√∫mero de linhas e colunas √© igual a N - o n√∫mero de v√©rtices na rede. <br><br>  Conhecendo apenas k, L, N e os valores em todas as c√©lulas da matriz de adjac√™ncia A, podemos calcular a modularidade de qualquer cluster. <br><br>  Suponha que agrupamos uma rede em v√°rias comunidades.  Em seguida, voc√™ pode usar o valor da modularidade para prever a "qualidade" do cluster.  Uma modularidade mais alta indica que dividimos a rede em comunidades "exatas", e uma modularidade mais baixa sugere que os clusters s√£o formados mais por acaso do que razoavelmente.  Para tornar mais claro: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  A modularidade √© uma medida da "qualidade" dos grupos. <br><br>  A modularidade pode ser calculada usando a seguinte f√≥rmula: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Vamos olhar para esta f√≥rmula bastante impressionante. <br><br>  <b>M</b> , como voc√™ sabe, isso √© modularidade. <br><br>  O coeficiente <b>1 / 2L</b> significa que dividimos o restante do "corpo" da f√≥rmula por 2L, ou seja, pelo n√∫mero duplo de arestas na rede.  Em Python, pode-se escrever: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  O que √© <code>#stuff with i and j</code> ?  O bit entre par√™nteses nos diz para subtrair (k_i k_j) / 2L de A_ij, onde A_ij √© o valor na matriz na interse√ß√£o da linha ie coluna j. <br><br>  Os valores k_i e k_j s√£o os graus de cada v√©rtice.  Eles podem ser encontrados somando os valores na linha ie coluna j, respectivamente.  Se os multiplicarmos e dividirmos por 2L, obteremos o n√∫mero esperado de arestas entre os v√©rtices iej se a rede for misturada aleatoriamente. <br><br>  O conte√∫do dos colchetes reflete a diferen√ßa entre a estrutura real da rede e a esperada se a rede foi reconstru√≠da aleatoriamente.  Se voc√™ brinca com os valores, a modularidade mais alta ser√° A_ij = 1 e baixa (k_i k_j) / 2L.  Ou seja, a modularidade aumenta se houver uma aresta "inesperada" entre os v√©rtices iej. <br><br>  Finalmente, multiplicamos o conte√∫do dos colchetes pelo que √© indicado na f√≥rmula como Œ¥c_i, c_j.  Esta √© a fun√ß√£o Kronecker-delta.  Aqui est√° sua implementa√ß√£o em Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Sim, t√£o simples.  A fun√ß√£o recebe dois argumentos e, se forem id√™nticos, retornar√° 1 e, se n√£o, ent√£o 0. <br><br>  Em outras palavras, se os v√©rtices iej ca√≠rem em um cluster, ent√£o Œ¥c_i, c_j = 1. E se eles estiverem em clusters diferentes, a fun√ß√£o retornar√° 0. <br><br>  Como multiplicamos o conte√∫do dos colchetes pelo s√≠mbolo Kronecker, o resultado da soma investida the ser√° mais alto quando os v√©rtices dentro de um cluster forem conectados por um grande n√∫mero de arestas "inesperadas".  Assim, a modularidade √© um indicador de qu√£o bem um gr√°fico √© agrupado em comunidades individuais. <br><br>  A divis√£o por 2L limita a modularidade superior √† unidade.  Se a modularidade for pr√≥xima de 0 ou negativa, isso significa que o cluster atual da rede n√£o faz sentido.  Ao aumentar a modularidade, podemos encontrar uma maneira melhor de agrupar a rede. <br><br>  Observe que, para avaliar a "qualidade" do agrupamento de um gr√°fico, precisamos determinar com anteced√™ncia como ele ser√° agrupado.  Infelizmente, a menos que a amostra seja muito pequena, devido √† complexidade computacional, √© simplesmente fisicamente imposs√≠vel passar estupidamente por todos os m√©todos de agrupar um gr√°fico comparando sua modularidade. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A Combinatorics</a> sugere que, para uma rede com 8 v√©rtices, existem 4.140 m√©todos de agrupamento.  Para uma rede com 16 v√©rtices, j√° haver√° mais de 10 bilh√µes de maneiras, para uma rede com 32 v√©rtices, 128 septilh√µes e para uma rede com 80 v√©rtices, o n√∫mero de m√©todos de agrupamento exceder√° o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√∫mero de √°tomos no Universo observ√°vel</a> . <br><br>  Portanto, em vez de enumera√ß√£o, usaremos o m√©todo heur√≠stico, que ajudar√° a calcular relativamente facilmente clusters com o m√°ximo de modularidade.  Esse √© um algoritmo chamado <i>Fast-Greedy Modularity-Maximization</i> , um tipo de an√°logo ao algoritmo de agrupamento hier√°rquico aglomerado descrito acima.  Em vez de combinar com base na proximidade, o Mod-Max une comunidades, dependendo das mudan√ßas na modularidade.  Como funciona: <br><br>  <b>Primeiro,</b> cada v√©rtice √© atribu√≠do √† sua pr√≥pria comunidade e a modularidade de toda a rede √© calculada - M. <br><br>  <b>Etapa 1</b> : para cada par de comunidades conectadas por pelo menos uma borda, o algoritmo calcula a altera√ß√£o resultante na modularidade ŒîM no caso de combinar esses pares de comunidades. <br><br>  <b>Etapa 2</b> : ent√£o um par √© obtido, quando combinado, ŒîM ser√° m√°ximo e combinado.  Para esse cluster, uma nova modularidade √© calculada e armazenada. <br><br>  As etapas 1 e 2 s√£o <b>repetidas</b> : cada vez que um par de comunidades se junta, o que d√° o maior AM, um novo esquema de agrupamento e seu M. <br><br>  As itera√ß√µes <b>param</b> quando todos os v√©rtices s√£o agrupados em um cluster enorme.  Agora, o algoritmo verifica os registros armazenados e encontra o esquema de cluster com a mais alta modularidade.  √â ela quem volta como uma estrutura comunit√°ria. <br><br>  Era computacionalmente dif√≠cil, pelo menos para as pessoas.  A teoria dos grafos √© uma fonte rica de problemas computacionais dif√≠ceis e de NP-hard.  Usando gr√°ficos, podemos tirar muitas conclus√µes √∫teis sobre sistemas e conjuntos de dados complexos.  Pergunte a Larry Page, cujo algoritmo PageRank - que ajudou o Google a se transformar de uma startup para uma dominante global em menos de uma gera√ß√£o - √© inteiramente baseado na teoria dos grafos. <br><br>  Hoje, estudos sobre a teoria dos grafos se concentram na identifica√ß√£o de comunidades.  Existem muitas alternativas para o algoritmo Modularity-Maximization, que, embora √∫til, n√£o deixa de ter suas desvantagens. <br><br>  Primeiro, com uma abordagem aglomerativa, comunidades pequenas e bem definidas s√£o frequentemente combinadas em comunidades maiores.  Isso √© chamado de limite de resolu√ß√£o - o algoritmo n√£o aloca comunidades menores que um determinado tamanho.  Outra desvantagem √© que, em vez de um pico global pronunciado e facilmente alcan√ß√°vel, o algoritmo Mod-Max procura gerar um amplo "plat√¥" a partir de muitos valores pr√≥ximos de modularidade.  Como resultado, √© dif√≠cil destacar o vencedor. <br><br>  Outros algoritmos usam m√©todos diferentes para definir comunidades.  Por exemplo, Edge-Betweenness √© um algoritmo de divis√£o (divis√£o) que come√ßa agrupando todos os v√©rtices em um cluster enorme.  Em seguida, as arestas menos "importantes" s√£o removidas iterativamente at√© que todos os v√©rtices sejam isolados.  O resultado √© uma estrutura hier√°rquica na qual os v√©rtices est√£o mais pr√≥ximos, mais semelhantes. <br><br>  O algoritmo, Clique Percolation, leva em considera√ß√£o poss√≠veis interse√ß√µes entre comunidades.  H√° um grupo de algoritmos baseados em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">caminhada aleat√≥ria</a> em um gr√°fico e existem m√©todos de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">agrupamento espectral</a> que lidam com a decomposi√ß√£o espectral (composi√ß√£o autom√°tica) da matriz de adjac√™ncia e outras matrizes dela derivadas.  Todas essas id√©ias s√£o usadas para destacar recursos, por exemplo, na vis√£o de m√°quina. <br><br>  N√£o analisaremos exemplos de trabalho para cada algoritmo em detalhes.  ,              ,     20    . <br><br><h2>  Conclus√£o </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   ‚Äî    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt413269/">https://habr.com/ru/post/pt413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt413253/index.html">Richard Hamming: Cap√≠tulo 21. Fibra √ìptica</a></li>
<li><a href="../pt413255/index.html">Richard Hamming: Cap√≠tulo 27. Dados Inv√°lidos</a></li>
<li><a href="../pt413261/index.html">Como a pesquisa funciona</a></li>
<li><a href="../pt413265/index.html">Para o balne√°rio com TI</a></li>
<li><a href="../pt413267/index.html">10 qualidades essenciais a serem observadas para um gerente de produto iniciante</a></li>
<li><a href="../pt413271/index.html">Sem senhas: como o sistema de autentica√ß√£o em um registro distribu√≠do funciona</a></li>
<li><a href="../pt413273/index.html">Gerenciamento de requisitos de produtos de TI dentro da empresa</a></li>
<li><a href="../pt413275/index.html">Teste comparativo de churrasqueiras para obter o resultado mais delicioso</a></li>
<li><a href="../pt413277/index.html">JSFiddle - nova vers√£o</a></li>
<li><a href="../pt413279/index.html">O aplicativo m√≥vel calcula o conte√∫do cal√≥rico de pratos em restaurantes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>