<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏽 🤶🏼 👩🏽‍💻 Des tests statiques ou sauvez le soldat Ryan 🤸🏾 👨🏽‍🚀 ♉️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une version se glisse souvent inaperçue. Et toute erreur qui a été soudainement découverte devant lui nous menace d'un décalage des délais, des hotfix...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Des tests statiques ou sauvez le soldat Ryan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/452926/">  Une version se glisse souvent inaperçue.  Et toute erreur qui a été soudainement découverte devant lui nous menace d'un décalage des délais, des hotfix, du travail jusqu'au matin et des nerfs épuisés.  Quand une telle ruée a commencé à se produire systématiquement, nous avons réalisé que vous ne pouvez plus vivre comme ça.  Il a été décidé de développer un système de validation complet pour sauver <s>le</s> développeur <s>ordinaire de Ryan</s> , Artyom, qui est rentré chez lui avant 21 h, ou à 10 ou à 11 heures ... vous comprenez.  L'idée était que le développeur découvre l'erreur alors que les modifications n'avaient pas encore atteint le référentiel, et lui-même n'a pas perdu le contexte de la tâche. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/050/6ad/e0c0506adfa607df0102904b82c0d96a.png"></div><br>  Aujourd'hui, les modifications apportées sont soigneusement vérifiées d'abord localement, puis avec une série de tests d'intégration sur la ferme d'assemblage.  Dans cet article, nous parlerons de la première étape de la vérification - les tests statiques, qui surveillent l'exactitude des ressources et analysent le code.  Il s'agit du premier sous-système de la chaîne et il représente la majeure partie des erreurs trouvées. <br><a name="habracut"></a><br><h2>  Comment tout a commencé </h2><br>  Le processus manuel de vérification du jeu avant la sortie a commencé dans QA une semaine et demie avant la sortie.  Naturellement, les bogues qui sont à ce stade doivent être corrigés dès que possible. <br><br>  En raison du manque de temps pour une bonne solution, une «béquille» temporaire est ajoutée, qui prend alors racine pendant longtemps et est entourée d'autres solutions peu populaires. <br><br>  Tout d'abord, nous avons décidé d'automatiser la recherche d'erreurs apparentes: plantages, incapacité à terminer l'ensemble principal des actions du jeu (ouvrir un magasin, faire un achat, jouer à un niveau).  Pour ce faire, le jeu démarre dans un mode de jeu automatique spécial et si quelque chose s'est mal passé, nous le saurons juste après avoir passé le test sur notre ferme. <br><br>  Mais la plupart des erreurs que les testeurs et notre test de fumée automatisé ont constatées étaient le manque de ressources ou des paramètres incorrects de différents systèmes.  Par conséquent, l'étape suivante consistait en <i>des tests statiques</i> - vérifier la disponibilité des ressources, leurs relations et leurs paramètres sans lancer l'application.  Ce système a été lancé par une étape supplémentaire sur la ferme d'assemblage et a grandement simplifié la recherche et la correction des erreurs.  Mais pourquoi gaspiller les ressources de la ferme d'assemblage si vous pouvez détecter une erreur avant même de valider et de placer le code du problème dans le référentiel?  Cela peut être <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fait avec des hooks de pré-validation</a> , qui sont juste démarrés avant que la validation ne soit créée et envoyée au référentiel. <br><br>  Et oui, nous sommes tellement cool que les tests statiques avant de valider et sur la ferme d'assemblage sont effectués par un seul code, ce qui simplifie considérablement sa prise en charge. <br><br>  Nos efforts peuvent être divisés en trois domaines: <br><br><ul><li>  création d'une ferme d'assemblage - l'endroit même où tout ce qui a été collecté et vérifié sera collecté; </li><li>  développement de tests statiques - vérification de l'exactitude des ressources, de leurs relations, lancement d'analyseurs de code; </li><li>  développement de tests d'exécution - lancement de l'application en mode lecture automatique. </li></ul><br>  Une tâche distincte consistait à organiser le lancement des tests sur la machine par le développeur.  Il était nécessaire de minimiser le temps d'exécution localement (le développeur n'a pas à attendre 10 minutes pour valider une ligne) et de s'assurer que chaque système qui effectue les modifications a installé notre système. <br><br><h2>  De nombreuses exigences - un seul système </h2><br>  Pendant le développement, il y a tout un ensemble d'assemblages qui peuvent être utiles: avec et sans tricheurs, bêta ou alpha, iOS ou Android.  Dans chaque cas, différentes ressources, paramètres ou même code différent peuvent être nécessaires.  L'écriture de scripts pour des tests statiques pour chaque assemblage possible entraîne un système complexe avec de nombreux paramètres.  En plus d'être difficile à entretenir et à modifier, chaque projet dispose également de son propre jeu de vélos à béquille. <br><br>  Par essais et erreurs, nous sommes arrivés à un système, chaque test dans lequel peut prendre en compte le contexte de lancement et décider de l'exécuter ou non, quoi exactement et comment vérifier.  Au début des tests, nous avons identifié trois propriétés principales: <br><br><ul><li>  type d'assemblage: pour les ressources de publication et de débogage, les contrôles seront différents en termes de rigueur, d'exhaustivité de la couverture, ainsi que de paramètres pour les identifiants et la vérification des fonctionnalités disponibles; </li><li>  plate-forme: ce qui est valide pour Android peut être incorrect pour iOS, les ressources sont également collectées différemment et toutes les ressources de la version Android ne seront pas dans iOS et vice versa; </li><li>  emplacement de lancement: où exactement allons-nous lancer - sur l'agent de build où tous les tests disponibles sont nécessaires ou sur l'ordinateur de l'utilisateur où la liste des startups doit être minimisée. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e86/9b4/a61/e869b4a61b7f46ba9d545058baa4af5a.png"></div><br><h2>  Système de test statique </h2><br>  Le cœur du système et l'ensemble de base des tests statiques sont implémentés en python.  La base n'est que quelques entités: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d09/e44/1fd/d09e441fd62385fb616c3875cdc67a4d.png"></div><br>  <i>Le contexte de test</i> est un concept étendu.  Il stocke à la fois les paramètres de construction et de lancement, dont nous avons parlé ci-dessus, ainsi que les méta-informations que les tests remplissent et utilisent. <br><br>  Vous devez d'abord comprendre quels tests exécuter.  Pour cela, la méta-information contient les types de ressources qui nous intéressent spécifiquement dans ce lancement.  Les types de ressources sont déterminés par des tests enregistrés dans le système.  Un test peut être «associé» à un ou plusieurs types, et si, au moment de la validation, il s'avère que les fichiers que ce test vérifie ont changé, alors la ressource associée a changé.  Cela convient parfaitement à notre idéologie - pour exécuter localement le moins de vérifications possible: si les fichiers dont le test est responsable n'ont pas changé, vous n'avez pas besoin de l'exécuter. <br><br>  Par exemple, il y a une description du poisson, dans laquelle le modèle 3D et la texture sont indiqués. Si le fichier de description a changé, il est vérifié que le modèle et la texture qui y sont indiqués existent.  Dans d'autres cas, il n'est pas nécessaire d'effectuer une vérification du poisson. <br><br>  D'un autre côté, changer une ressource peut nécessiter des changements et des entités en fonction: si l'ensemble des textures stockées dans nos fichiers xml a changé, alors il est nécessaire de vérifier des modèles 3D supplémentaires, car il peut s'avérer que la texture nécessaire au modèle est supprimée.  Les optimisations décrites ci-dessus ne sont appliquées que localement sur la machine de l'utilisateur au moment de la validation, et lors du lancement sur la ferme d'assemblage, il est supposé que tous les fichiers ont changé et nous exécutons tous les tests. <br><br>  Le problème suivant est la dépendance de certains tests par rapport à d'autres: il est impossible de vérifier le poisson avant de trouver toutes les textures et modèles.  Par conséquent, nous avons divisé toute l'exécution en deux étapes: <br><br><ul><li>  préparation du contexte </li><li>  vérification </li></ul><br>  Dans un premier temps, le contexte est rempli d'informations sur les ressources trouvées (dans le cas des poissons, avec des identifiants de motifs et de textures).  Dans la deuxième étape, en utilisant les informations stockées, vérifiez simplement si la ressource souhaitée existe.  Un contexte simplifié est présenté ci-dessous. <br><br><pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerificationContext</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, app_path, build_type, platform, changed_files=None)</span></span></span><span class="hljs-function">:</span></span>       self.__app_path = app_path       self.__build_type = build_type       self.__platform = platform       <span class="hljs-comment"><span class="hljs-comment">#          self.__modified_resources = set()       self.__expected_resources = set()       #      ,              self.__changed_files = changed_files       # -  ,          self.__resources = {} def expect_resources(self, resources):   self.__expected_resources.update(resources) def is_resource_expected(self, resource):   return resource in self.__expected_resources def register_resource(self, resource_type, resource_id, resource_data=None):   self.__resources.setdefault(resource_type, {})[resource_id] = resource_data def get_resource(self, resource_type, resource_id):   if resource_type not in self.__resources or resource_id not in self.__resources[resource_type]:       return None, None   return resource_id, self.__resources[resource_type][resource_id]</span></span></code> </pre> <br>  Après avoir déterminé tous les paramètres qui affectent le lancement du test, nous avons réussi à cacher toute la logique à l'intérieur de la classe de base.  Dans un test spécifique, il reste à écrire uniquement le test lui-même et les valeurs nécessaires pour les paramètres. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestCase</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, context, build_types=None, platforms=None, predicate=None,               expected_resources=None, modified_resources=None)</span></span></span><span class="hljs-function">:</span></span>      self.__name = name      self.__context = context      self.__build_types = build_types      self.__platforms = platforms      self.__predicate = predicate      self.__expected_resources = expected_resources      self.__modified_resources = modified_resources      <span class="hljs-comment"><span class="hljs-comment">#               #   ,          self.__need_run = self.__check_run()      self.__need_resource_run = False  @property  def context(self):      return self.__context  def fail(self, message):      print('Fail: {}'.format(message))  def __check_run(self):      build_success = self.__build_types is None or self.__context.build_type in self.__build_types      platform_success = self.__platforms is None or self.__context.platform in self.__platforms      hook_success = build_success      if build_success and self.__context.is_build('hook') and self.__predicate:          hook_success = any(self.__predicate(changed_file) for changed_file in self.__context.changed_files)      return build_success and platform_success and hook_success  def __set_context_resources(self):      if not self.__need_run:          return      if self.__modified_resources:          self.__context.modify_resources(self.__modified_resources)      if self.__expected_resources:          self.__context.expect_resources(self.__expected_resources)   def init(self):      """        ,                    ,          """      self.__need_resource_run = self.__modified_resources and any(self.__context.is_resource_expected(resource) for resource in self.__modified_resources)  def _prepare_impl(self):      pass  def prepare(self):      if not self.__need_run and not self.__need_resource_run:          return      self._prepare_impl()  def _run_impl(self):      pass  def run(self):      if self.__need_run:          self._run_impl()</span></span></code> </pre> <br>  Pour revenir à l'exemple des poissons, nous avons besoin de deux tests, dont l'un trouve les textures et les enregistre en contexte, l'autre recherche les textures pour les modèles trouvés. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyTexture</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TestCase)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, context)</span></span></span><span class="hljs-function">:</span></span>      super(VerifyTexture, self).__init__(<span class="hljs-string"><span class="hljs-string">'VerifyTexture'</span></span>, context,                                          build_types=[<span class="hljs-string"><span class="hljs-string">'production'</span></span>, <span class="hljs-string"><span class="hljs-string">'hook'</span></span>],                                          platforms=[<span class="hljs-string"><span class="hljs-string">'windows'</span></span>, <span class="hljs-string"><span class="hljs-string">'ios'</span></span>],                                          expected_resources=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>,                                          modified_resources=[<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>],                                          predicate=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> file_path: os.path.splitext(file_path)[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'.png'</span></span>)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_prepare_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      texture_dir = os.path.join(self.context.app_path, <span class="hljs-string"><span class="hljs-string">'resources'</span></span>, <span class="hljs-string"><span class="hljs-string">'textures'</span></span>)      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> root, dirs, files <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> os.walk(texture_dir):          <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> tex_file <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> files:              self.context.register_resource(<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>, tex_file) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VerifyModels</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TestCase)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, context)</span></span></span><span class="hljs-function">:</span></span>      super(VerifyModels, self).__init__(<span class="hljs-string"><span class="hljs-string">'VerifyModels'</span></span>, context,                                         expected_resources=[<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>],                                         predicate=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> file_path: os.path.splitext(file_path)[<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'.obj'</span></span>)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_run_impl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      models_descriptions = etree.parse(os.path.join(self.context.app_path, <span class="hljs-string"><span class="hljs-string">'resources'</span></span>, <span class="hljs-string"><span class="hljs-string">'models.xml'</span></span>))      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> model_xml <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> models_descriptions.findall(<span class="hljs-string"><span class="hljs-string">'.//Model'</span></span>):          texture_id = model_xml.get(<span class="hljs-string"><span class="hljs-string">'texture'</span></span>)          texture = self.context.get_resource(<span class="hljs-string"><span class="hljs-string">'Texture'</span></span>, texture_id)          <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> texture <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>:              self.fail(<span class="hljs-string"><span class="hljs-string">'Texture for model {} was not found: {}'</span></span>.format(model_xml.get(<span class="hljs-string"><span class="hljs-string">'id'</span></span>), texture_id))</code> </pre> <br><h2>  Répartition du projet </h2><br>  Le développement de jeux dans Playrix s'effectue sur son propre moteur et, par conséquent, tous les projets ont une structure de fichiers et un code similaires utilisant les mêmes règles.  Par conséquent, de nombreux tests généraux sont écrits une seule fois et figurent dans le code général.  Il suffit que les projets mettent à jour la version du système de test et connectent un nouveau test. <br><br>  Pour simplifier l'intégration, nous avons écrit un runner qui reçoit le fichier de configuration et les tests de conception (à leur sujet plus tard).  Le fichier de configuration contient des informations de base sur lesquelles nous avons écrit ci-dessus: type d'assemblage, plate-forme, chemin d'accès au projet. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runner</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, config_str, setup_function)</span></span></span><span class="hljs-function">:</span></span>      self.__tests = []      config_parser = RawConfigParser()      config_parser.read_string(config_str)      app_path = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'app_path'</span></span>)      build_type = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'build_type'</span></span>)      platform = config_parser.get(<span class="hljs-string"><span class="hljs-string">'main'</span></span>, <span class="hljs-string"><span class="hljs-string">'platform'</span></span>)      <span class="hljs-string"><span class="hljs-string">'''      get_changed_files         CVS      '''</span></span>      changed_files = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> build_type != <span class="hljs-string"><span class="hljs-string">'hook'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> get_changed_files()      self.__context = VerificationContext(app_path, build_type, platform, changed_files)      setup_function(self)  @property  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">context</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.__context  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, test)</span></span></span><span class="hljs-function">:</span></span>      self.__tests.append(test)  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.init()      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.prepare()      <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__tests:          test.run()</code> </pre> <br>  La beauté du fichier de configuration est qu'il peut être généré sur la ferme d'assemblage pour différents assemblages en mode automatique.  Mais passer des paramètres pour tous les tests via ce fichier peut ne pas être très pratique.  Pour ce faire, il existe un fichier de configuration spécial qui est stocké dans le référentiel du projet et des listes de fichiers ignorés, des masques de recherche dans le code, etc., y sont écrits. <br><br><div class="spoiler">  <b class="spoiler_title">Exemple de fichier de configuration</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">[main] app_path = {app_path} build_type = production platform = ios</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Exemple d'optimisation de XML</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifySourceCodepage</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">allow_utf8</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">allow_utf8Bom</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"false"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">autofix_path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ci/autofix"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IgnoreFiles</span></span></span><span class="hljs-tag">&gt;</span></span>*android/tmp/*<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IgnoreFiles</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifySourceCodepage</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifyCodeStructures</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Checker</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"NsStringConversion"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Checker</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"LogConstructions"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">VerifyCodeStructures</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">root</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></div></div><br>  En plus de la partie générale, les projets ont leurs propres particularités et différences; par conséquent, il existe des ensembles de tests de projet qui sont connectés au système via la configuration du runner.  Pour le code des exemples, quelques lignes suffiront pour s'exécuter: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(runner)</span></span></span><span class="hljs-function">:</span></span>  runner.add_test(VerifyTexture(runner.context))  runner.add_test(VerifyModels(runner.context)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span>  raw_config = <span class="hljs-string"><span class="hljs-string">'''  [main]  app_path = {app_path}  build_type = production  platform = ios  '''</span></span>  runner = Runner(raw_config, setup)  runner.run()</code> </pre> <br><h2>  Râteau collecté </h2><br>  Bien que python lui-même soit multiplateforme, nous avons régulièrement eu des problèmes avec le fait que les utilisateurs ont leur propre environnement unique, dans lequel ils peuvent ne pas avoir la version que nous attendons, plusieurs versions, ou aucun interprète du tout.  Par conséquent, cela ne fonctionne pas comme prévu ou ne fonctionne pas du tout.  Il y a eu plusieurs itérations pour résoudre ce problème: <br><br><ol><li>  Python et tous les packages sont installés par l'utilisateur.  Mais il y a deux «mais»: tous les utilisateurs ne sont pas des programmeurs et l'installation via pip install pour les concepteurs, et pour les programmeurs aussi, peut être un problème. </li><li>  Il existe un script qui installe tous les packages nécessaires.  C'est déjà mieux, mais si l'utilisateur a installé le mauvais python, des conflits peuvent survenir dans le travail. </li><li>  Fourniture de la version correcte de l'interpréteur et des dépendances du stockage d'artefacts (Nexus) et exécution de tests dans un environnement virtuel. </li></ol><br>  Un autre problème est la performance.  Plus il y a de tests, plus la modification est vérifiée sur l'ordinateur de l'utilisateur.  Tous les quelques mois, il y a un profilage et une optimisation des goulots d'étranglement.  Le contexte a donc été amélioré, un cache pour les fichiers texte est apparu, les mécanismes des prédicats ont été améliorés (déterminant que ce fichier est intéressant pour le test). <br><br>  Et puis il ne reste plus qu'à résoudre le problème de la façon d'implémenter le système sur tous les projets et de forcer tous les développeurs à inclure des hooks d'occasion, mais c'est une histoire complètement différente ... <br><br><h2>  Conclusion </h2><br>  Pendant le processus de développement, nous avons dansé sur le rake, nous nous sommes battus, mais nous avons tout de même un système qui nous permet de trouver des erreurs lors de la validation, de réduire le travail des testeurs et les tâches avant la publication concernant la texture manquante appartenaient au passé.  Pour un bonheur complet, une simple configuration de l'environnement et l'optimisation des tests individuels ne suffisent pas, mais les golems du département ci y travaillent dur. <br><br>  Un exemple complet du code utilisé comme exemples dans l'article peut être trouvé dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">notre référentiel</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr452926/">https://habr.com/ru/post/fr452926/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr452910/index.html">Bonjour, Habr! Bonjour Tercon</a></li>
<li><a href="../fr452914/index.html">ML sur Scala avec le sourire, pour ceux qui n'ont pas peur de l'expérimentation</a></li>
<li><a href="../fr452916/index.html">Levez-vous et partez. Chirurgie vertébrale: quand faire, ce qui est dangereux</a></li>
<li><a href="../fr452922/index.html">Tables de grille CSS flexibles</a></li>
<li><a href="../fr452924/index.html">Ce que vous devez faire pour empêcher le vol de votre compte Google</a></li>
<li><a href="../fr452928/index.html">Nous restaurons les machines virtuelles à partir du magasin de données initialisé par erreur. L'histoire d'un non-sens avec une fin heureuse</a></li>
<li><a href="../fr452938/index.html">Les pistolets de l'imprimante 3D sont de retour, et maintenant ils ne peuvent plus être arrêtés</a></li>
<li><a href="../fr452942/index.html">GeekBrains organise 12 réunions en ligne gratuites avec des experts en programmation</a></li>
<li><a href="../fr452944/index.html">Quel sera le "Dialogue" des linguistes et des spécialistes de l'analyse des données</a></li>
<li><a href="../fr452946/index.html">Relire la «philosophie de programmation de Windows 95 / NT» de Lou Greenaw</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>