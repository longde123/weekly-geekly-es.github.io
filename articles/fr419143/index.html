<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèº üë©‚Äçüë¶ üôéüèæ Cr√©ation d'une machine d'arcade d'√©mulation. Partie 4 ‚õ≤Ô∏è üë®üèø‚Äçüé§ üõéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parties du premier , deuxi√®me , troisi√®me . 

 Le reste de la machine 
 Le code que nous avons √©crit pour √©muler le processeur 8080 est assez g√©n√©ral ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cr√©ation d'une machine d'arcade d'√©mulation. Partie 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419143/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/735/b99/6eb735b9990860a94f9ef0a18ba46a82.jpg" alt="image"></div><br>  Parties du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">deuxi√®me</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisi√®me</a> . <br><br><h2>  Le reste de la machine </h2><br>  Le code que nous avons √©crit pour √©muler le processeur 8080 est assez g√©n√©ral et peut √™tre facilement adapt√© pour fonctionner sur n'importe quelle machine avec le compilateur C. Mais pour jouer au jeu lui-m√™me, nous devons faire plus.  Nous devrons √©muler l'√©quipement de toute la machine d'arcade et √©crire du code qui colle les caract√©ristiques sp√©cifiques de notre environnement informatique √† l'√©mulateur. <br><br>  (Vous pouvez √™tre int√©ress√© par le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sch√©ma de circuit de la</a> machine.) <br><a name="habracut"></a><br><h2>  Timings </h2><br>  Le jeu fonctionne sur le 2 MHz 8080. Votre ordinateur est beaucoup plus rapide.  Pour en tenir compte, nous devrons trouver une sorte de m√©canisme. <br><br><h2>  Interruptions </h2><br>  Les interruptions sont con√ßues pour que le processeur puisse traiter des t√¢ches avec des temps d'ex√©cution pr√©cis, comme les E / S.  Le processeur peut ex√©cuter le programme et lorsque la broche d'interruption est d√©clench√©e, il arr√™te d'ex√©cuter le programme en cours et fait autre chose. <br><br>  Nous devons simuler la fa√ßon dont une machine d'arcade g√©n√®re des interruptions. <br><br><h2>  Graphisme </h2><br>  Space Invaders dessine des graphiques dans sa m√©moire dans la plage d'adresses 0x2400.  Un v√©ritable contr√¥leur vid√©o mat√©riel lirait la RAM et contr√¥lerait un √©cran CRT.  Notre programme devra √©muler ce comportement en affichant une image du jeu dans une fen√™tre. <br><br><h2>  Boutons </h2><br>  Le jeu poss√®de des boutons physiques que le programme lit √† l'aide de la commande IN du processeur 8080. Notre √©mulateur devra lier l'entr√©e clavier √† ces commandes IN. <br><br><h2>  ROM et RAM </h2><br>  Je dois admettre: nous ¬´coupons le coin¬ª en cr√©ant une m√©moire tampon de 16 kilo-octets, qui inclut les 16 Ko inf√©rieurs de l'allocation de m√©moire du processeur.  En fait, les 2 premiers Ko d'allocation de m√©moire sont une v√©ritable m√©moire morte (ROM).  Nous devrons mettre des op√©rations d'√©criture en m√©moire dans une fonction afin qu'il ne soit pas possible d'√©crire sur la ROM. <br><br><h2>  Son </h2><br>  Jusqu'√† pr√©sent, nous n'avons rien dit sur le son.  Space Invaders a un joli mod√®le de son analogique qui reproduit l'un des 8 sons contr√¥l√©s par la commande OUT, qui est transmis √† l'un des ports.  Nous devrons convertir ces commandes OUT afin de lire des √©chantillons sonores sur notre plateforme. <br><br>  Cela peut sembler beaucoup de travail, mais ce n'est pas si mal, et nous pouvons √©voluer progressivement.  La premi√®re chose que nous voulons faire est de voir l'√©cran, pour lequel nous avons besoin d'interruptions, de graphiques et d'une partie du traitement des commandes IN et OUT. <br><br><h2>  Affiche et met √† jour </h2><br><h3>  Les bases </h3><br>  Vous connaissez probablement les composants d'un syst√®me d'affichage vid√©o.  Quelque part dans le syst√®me, il existe une sorte de RAM, qui contient une image √† afficher √† l'√©cran.  Dans le cas des appareils analogiques, il existe un √©quipement qui lit cette RAM et convertit les octets en tension analogique transmise au moniteur. <br><br>  Une compr√©hension plus approfondie du syst√®me nous aidera √† analyser le but de l'allocation de m√©moire et de la fonctionnalit√© de code. <br><br>  Les √©crans analogiques ont des exigences en termes de taux de rafra√Æchissement et de temporisation.  √Ä tout moment, l'affichage a un pixel sp√©cifique mis √† jour.  L'image transmise √† l'√©cran est remplie point par point, en partant du coin sup√©rieur gauche et en haut √† droite, puis du premier point de la deuxi√®me ligne, du dernier point de la deuxi√®me ligne, etc.  Une fois la derni√®re ligne trac√©e √† l'√©cran, le contr√¥leur vid√©o peut g√©n√©rer une interruption verticale vierge (√©galement connue sous le nom de VBI ou VBL). <br><br>  Pour assurer une animation fluide, l'image en RAM trait√©e par le contr√¥leur vid√©o ne peut pas √™tre modifi√©e.  Si la mise √† jour de la RAM s'est produite au milieu du cadre, le spectateur verra des parties de deux images.  Il en r√©sulte un effet de ¬´d√©chirure¬ª lorsqu'un cadre diff√©rent du cadre en bas est affich√© en haut de l'√©cran.  Si vous avez d√©j√† vu un saut de ligne, vous savez √† quoi il ressemble. <br><br>  Pour √©viter les lacunes, le logiciel doit faire quelque chose pour √©viter de transf√©rer l'emplacement de la mise √† jour de l'√©cran.  Et il n'y a qu'une seule fa√ßon de proc√©der. <br><br>  VBL est g√©n√©r√© apr√®s la fin de la derni√®re ligne, et il y a g√©n√©ralement un certain temps avant de redessiner la premi√®re ligne.  (Il s'agit du temps de blanc vertical et il peut √™tre d'environ 1 milliseconde.) <br><br>  Lorsque VBL est re√ßu, le programme commence √† rendre l'√©cran par le haut. <br><br>  Chaque ligne est trac√©e avant le processus inverse de balayage d'image. <br><br>  Le CPU est toujours en avance sur le retour √† chaud, et √©vite donc les sauts de ligne. <br><br><div style="text-align:center;"><img src="http://www.emulator101.com/images/verticalretrace.jpg" alt="image"></div><br><h2>  Syst√®me vid√©o Space Invaders </h2><br>  Une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> tr√®s informative nous apprend que les Space Invaders ont deux interruptions vid√©o.  L'une concerne la fin du cadre, mais elle g√©n√®re √©galement une interruption au milieu de l'√©cran.  La page d√©crit le syst√®me de mise √† jour de l'√©cran - le jeu dessine des graphiques dans la moiti√© sup√©rieure de l'√©cran lorsqu'il re√ßoit une interruption au milieu de l'√©cran et dessine des graphiques dans la partie inf√©rieure de l'√©cran lorsqu'il re√ßoit une interruption √† la fin de la trame.  C'est un moyen assez intelligent d'√©liminer les sauts de ligne et un bon exemple de ce qui peut √™tre r√©alis√© lorsque vous d√©veloppez du mat√©riel et des logiciels en m√™me temps. <br><br>  Nous devons forcer l'√©mulation de notre machine pour g√©n√©rer de telles interruptions.  Si nous les g√©n√©rons avec une fr√©quence de 60 Hz, ainsi que la machine Space Invaders, alors le jeu sera dessin√© avec la bonne fr√©quence. <br><br>  Dans la section suivante, nous parlerons de la m√©canique des interruptions et r√©fl√©chirons √† la fa√ßon de les √©muler. <br><br><h2>  Boutons et ports </h2><br>  Le 8080 impl√©mente les E / S √† l'aide des instructions IN et OUT.  Il dispose de 8 ports IN et OUT distincts - le port est d√©termin√© par l'octet de donn√©es de la commande.  Par exemple, <code>IN 3</code> mettra la valeur du port 3 dans le registre A et <code>OUT 2</code> enverra A au port 2. <br><br>  J'ai pris des informations sur l'objectif de chaque port sur le site Web de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Computer Archaeology</a> .  Si ces informations n'√©taient pas disponibles, il faudrait les obtenir en √©tudiant le sch√©ma √©lectrique, ainsi qu'en lisant et en ex√©cutant le code √©tape par √©tape. <br><br> <code>: <br>  1 <br>  0  (0,  ) <br> 1  Start   <br> 2  Start   <br> 3 ? <br> 4     <br> 5     <br> 6     <br> 7 ? <br> <br>  2 <br>  0,1 DIP-   (0:3,1:4,2:5,3:6) <br> 2 ""  <br> 3 DIP-  , 1:1000,0:1500 <br> 4     <br> 5     <br> 6     <br> 7    DIP-, 1:,0: <br> <br>  3    <br> <br>  2     ( 0,1,2) <br>  3    <br>  4    <br>  5    <br>  6  "" ? ,     , <br>       (0=a,1=b,2=c  ..) <br> <br> (  3,5,6      1=$01  2=$00 <br>    ,       (attract mode))</code> <br> <br>  Il existe trois fa√ßons d'impl√©menter les E / S dans notre pile logicielle (qui comprend un √©mulateur 8080, un code machine et un code de plate-forme). <br><br><ol><li>  Int√©grez les connaissances de la machine dans notre √©mulateur 8080 </li><li>  Int√©grer la connaissance de l'√©mulateur 8080 dans le code machine </li><li>  Inventer une interface formelle entre les trois parties du code pour permettre l'√©change d'informations via l'API </li></ol><br>  J'ai exclu la premi√®re option - il est assez √©vident que l'√©mulateur est tout en bas de cette cha√Æne d'appel et doit rester s√©par√©.  (Imaginez que vous devez r√©utiliser l'√©mulateur pour un autre jeu, et vous comprendrez ce que je veux dire.) Dans le cas g√©n√©ral, le transfert de structures de donn√©es de haut niveau √† des niveaux inf√©rieurs est une mauvaise solution architecturale. <br><br>  J'ai choisi l'option 2. Permettez-moi de montrer le code en premier: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode = state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*opcode == <span class="hljs-number"><span class="hljs-number">0xdb</span></span>) <span class="hljs-comment"><span class="hljs-comment">//machine specific handling for IN { uint8_t port = opcode[1]; state-&gt;a = MachineIN(state, port); state-&gt;pc++; } else if (*opcode == 0xd3) //OUT { uint8_t port = opcode[1]; MachineOUT(state, port); state-&gt;pc++; } else Emulate8080Op(state); }</span></span></code> </pre> <br>  Ce code r√©impl√©mente le traitement des opcodes pour IN et OUT dans la m√™me couche, qui appelle l'√©mulateur pour le reste des commandes.  √Ä mon avis, cela rend le code plus propre.  Ceci est similaire √† un remplacement ou √† une sous-classe pour les deux commandes, qui fait r√©f√©rence √† une couche automate. <br><br>  L'inconv√©nient est que nous transf√©rons l'√©mulation des opcodes √† deux endroits.  Je ne vous bl√¢merai pas d'avoir choisi la troisi√®me option.  Dans la deuxi√®me option, moins de code est requis, mais l'option 3 est plus ¬´propre¬ª, mais le prix est une augmentation de complexit√©.  C'est une question de choix de style. <br><br><h2>  Registre √† d√©calage </h2><br>  La machine Space Invaders dispose d'une solution mat√©rielle int√©ressante qui impl√©mente une commande de d√©calage de bits.  Le 8080 a des commandes pour un d√©calage de 1 bit, mais des dizaines de commandes 8080 seront n√©cessaires pour impl√©menter un d√©calage multi-bits / multi-octets. Un mat√©riel sp√©cial permet au jeu d'effectuer ces op√©rations en quelques instructions seulement.  Avec son aide, chaque image est dessin√©e sur le terrain de jeu, c'est-√†-dire qu'elle est utilis√©e plusieurs fois par image. <br><br>  Je ne pense pas pouvoir mieux l'expliquer que l'excellente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyse de</a> l'arch√©ologie informatique: <br><br> <code>; 16- : <br> ; f 0  <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    4  x  y,     x, : <br> ; $0000, <br> ; write $aa -&gt; $aa00, <br> ; write $ff -&gt; $ffaa, <br> ; write $12 -&gt; $12ff, .. <br> ; <br> ;    2 ( 0,1,2)    8- , : <br> ; offset 0: <br> ; rrrrrrrr result=xxxxxxxx <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 2: <br> ; rrrrrrrr result=xxxxxxyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ; offset 7: <br> ; rrrrrrrr result=xyyyyyyy <br> ; xxxxxxxxyyyyyyyy <br> ; <br> ;    3   .</code> <br> <br>  Pour la commande OUT, l'√©criture sur le port 2 d√©finit la quantit√© de d√©calage et l'√©criture sur le port 4 d√©finit les donn√©es dans les registres √† d√©calage.  La lecture avec IN 3 renvoie des donn√©es d√©cal√©es de la quantit√© de d√©calage.  Dans ma machine, cela est impl√©ment√© comme ceci: <br><br><pre> <code class="cpp hljs"> -(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) MachineIN(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port) { <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> v = (shift1&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>) | shift0; a = ((v &gt;&gt; (<span class="hljs-number"><span class="hljs-number">8</span></span>-shift_offset)) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) MachineOUT(<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> port, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(port) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: shift_offset = value &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: shift0 = shift1; shift1 = value; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><h2>  Clavier </h2><br>  Pour obtenir la r√©ponse de la machine, nous devons lui associer une entr√©e clavier.  La plupart des plateformes ont un moyen de recevoir les √©v√©nements de frappe et de lib√©ration.  Le code de plate-forme pour les boutons ressemblera √† ceci: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PeekMessage(&amp;msg,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,PM_REMOVE)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYDOWN ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyDown(LEFT); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.message==WM_KEYUP ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.wParam == VK_LEFT ) MachineKeyUp(LEFT); } }</code> </pre> <br>  Le code machine collant le code de la plateforme au code de l'√©mulateur ressemblera √† ceci: <br><br><pre> <code class="cpp hljs"> MachineKeyDown(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> key) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> LEFT: port[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Set bit 5 of port 1 break; case RIGHT: port[1] |= 0x40; //Set bit 6 of port 1 break; /*....*/ } } PlatformKeyUp(char key) { switch(key) { case LEFT: port[1] &amp;= 0xDF //Clear bit 5 of port 1 break; case RIGHT: port[1] &amp;= 0xBF //Clear bit 6 of port 1 break; /*....*/ } }</span></span></code> </pre> <br>  Si vous le souhaitez, vous pouvez combiner le code de la machine et de la plateforme √† votre guise - c'est le choix de l'impl√©mentation.  Je ne le ferai pas car je vais porter la machine sur plusieurs plates-formes diff√©rentes. <br><br><h2>  Interruptions </h2><br>  Apr√®s avoir √©tudi√© le manuel, j'ai r√©alis√© que le 8080 g√®re les interruptions comme suit: <br><br><ol><li>  La source d'interruption (externe au CPU) d√©finit la broche d'interruption du CPU. </li><li>  Lorsque le CPU confirme que l'interruption est re√ßue, la source de l'interruption peut envoyer n'importe quel opcode au bus et le CPU le voit.  (Le plus souvent, ils utilisent la commande RST.) </li><li>  Le CPU ex√©cute cette commande.  S'il s'agit de RST, il s'agit alors d'un analogue de la commande CALL pour une adresse fixe au bas de la m√©moire.  Il pousse le PC actuel sur la pile. </li><li>  Le code de l'adresse m√©moire inf√©rieure traite ce que l'interruption veut dire au programme.  Une fois le traitement termin√©, RST se termine par un appel √† RET. </li></ol><br>  L'√©quipement vid√©o du jeu g√©n√®re deux interruptions que nous devons √©muler par programmation: la fin de l'image et le milieu de l'image.  Les deux sont ex√©cut√©s √† 60 Hz (60 fois par seconde).  1/60 de seconde est de 16,6667 millisecondes. <br><br>  Pour simplifier le travail avec les interruptions, j'ajouterai une fonction √† l'√©mulateur 8080: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> interrupt_num)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//perform "PUSH PC" Push(state, (state-&gt;pc &amp; 0xFF00) &gt;&gt; 8, (state-&gt;pc &amp; 0xff)); //Set the PC to the low memory vector. //This is identical to an "RST interrupt_num" instruction. state-&gt;pc = 8 * interrupt_num; }</span></span></code> </pre> <br>  Le code de la plateforme doit impl√©menter une minuterie que nous pouvons appeler (pour l'instant, je l'appelle simplement time ()).  Le code machine l'utilisera pour transmettre une interruption √† l'√©mulateur 8080.  Dans le code machine, lorsque le temporisateur expire, j'appelle GenerateInterrupt: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!done) { Emulate8080Op(state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( time() - lastInterrupt &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">//1/60 second has elapsed { //only do an interrupt if they are enabled if (state-&gt;int_enable) { GenerateInterrupt(state, 2); //interrupt 2 //Save the time we did this lastInterrupt = time(); } } }</span></span></code> </pre> <br>  Il y a quelques d√©tails sur la fa√ßon dont le 8080 g√®re r√©ellement les interruptions, que nous n'√©mulerons pas.  Je pense qu'un tel traitement sera suffisant pour nos besoins. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr419143/">https://habr.com/ru/post/fr419143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr419131/index.html">Annonce de la date de lancement pr√©liminaire du module lunaire SpaceIL</a></li>
<li><a href="../fr419133/index.html">Webinaires du vendredi: apprendre √† programmer gratuitement</a></li>
<li><a href="../fr419135/index.html">Vendredi JS: jeu JS et CSS en ligne</a></li>
<li><a href="../fr419137/index.html">Journalisation des activit√©s √† l'aide de l'API Web Beacon</a></li>
<li><a href="../fr419141/index.html">Le phishing sexuel gagne du terrain aux √âtats-Unis</a></li>
<li><a href="../fr419145/index.html">Fintech Digest: la capitalisation d'Apple a d√©pass√© le billion de dollars, l'IA a aid√© eBay √† augmenter ses revenus de plusieurs milliards</a></li>
<li><a href="../fr419147/index.html">Cube √† 1000 dimensions: est-il possible de cr√©er un mod√®le informatique de la m√©moire humaine aujourd'hui?</a></li>
<li><a href="../fr419149/index.html">Guide de Mikrotik RoMON</a></li>
<li><a href="../fr419151/index.html">Maison intelligente: une nouvelle dimension de confort et la recherche de l'excellence. Deuxi√®me partie</a></li>
<li><a href="../fr419153/index.html">M√©morandum sur les droits de Cyborg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>