<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>„äôÔ∏è ü§≥ üí® Schnellere Verkettung von Zeichenfolgen zum Selbermachen in Go üèÆ üèΩ üóÉÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir die Bindung von kurzen Leitungen in Go um 30% beschleunigen. Und daf√ºr m√ºssen wir Go selbst nicht √§ndern, all dies wird als Bibliothe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnellere Verkettung von Zeichenfolgen zum Selbermachen in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417479/"><p><img src="https://habrastorage.org/webt/36/bi/u0/36biu0kvugh_maxmmyhmuvqlrs8.png"></p><br><p>  Heute werden wir die Bindung von kurzen Leitungen in Go um 30% beschleunigen.  Und daf√ºr m√ºssen wir Go selbst nicht √§ndern, all dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek</a> eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drittanbieters</a> implementiert. </p><br><p>  Unter dem Schnitt, auf den Sie warten: </p><br><ul><li> Vergleichen von <code>+</code> , <code>strings.Builder</code> und nativen Verkettungsfunktionen </li><li>  Gehen Sie zu internen Zeilendetails </li><li>  Ziemlich viel Assembler </li></ul><br><p>  Dieser Artikel kann auch als Ausrede f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL123256 angesehen werden: Laufzeit, cmd / compile: specialize concatstring2</a> .  Ideen zur Verbesserung dieser √Ñnderungsliste sind willkommen. </p><a name="habracut"></a><br><h1 id="srazu-rezultaty">  Sofort Ergebnisse </h1><br><p>  Der Vergleich wurde mit der <code>go tip</code> (Master) -Version des Compilers durchgef√ºhrt.  Sie k√∂nnen √§hnliche Ergebnisse f√ºr Versionen um Go 1.5 erhalten.  Die letzte signifikante √Ñnderung an der Funktion <code>concatstrings</code> war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL3120: cmd / gc: Zuweisen von Puffern f√ºr nicht maskierte Zeichenfolgen auf dem Stapel</a> . </p><br><pre> <code class="hljs powershell">BenchmarkConcat2Operator<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">83.8</span></span> ns/op BenchmarkConcat2Builder<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">70.9</span></span> ns/op BenchmarkConcat2<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">62.1</span></span> ns/op BenchmarkConcat3Operator<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">104</span></span> ns/op BenchmarkConcat3Builder<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">89.9</span></span> ns/op BenchmarkConcat3<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">82.1</span></span> ns/op</code> </pre> <br><p>  <code>ConcatOperator</code> verwendet <code>+</code> . <br>  <code>ConcatBuilder</code> verwendet <code>ConcatBuilder</code> mit der richtigen <code>ConcatBuilder</code> . <br>  <code>Concat</code> verwendet die Funktion, die wir als Teil dieser Geschichte implementieren. </p><br><p>  Vergleich √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchstat</a> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta Concat2<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">84.2</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">62.7</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">2</span></span>% <span class="hljs-number"><span class="hljs-number">-25.49</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) Concat3<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">103</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">83</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">4</span></span>% <span class="hljs-number"><span class="hljs-number">-19.83</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br><p>  Die Assembler-Implementierung unter <code>GOARCH=AMD64</code> etwas schneller und verf√ºgt √ºber eine zus√§tzliche Optimierung, die im integrierten Operator <code>+</code> vorhanden ist. Weitere <code>GOARCH=AMD64</code> weiter unten: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta Concat2<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">84.2</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">57.1</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">-32.20</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br><p>  Wir werden die Assembler-Funktion als 100% ige Leistung betrachten (im Vergleich zu den √ºbrigen betrachteten Implementierungen). </p><br><blockquote>  Ergebnisse f√ºr l√§ngere Zeilen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README.md</a> .  Je l√§nger die Zeichenfolge ist, desto weniger ausgepr√§gt ist der Unterschied zwischen den Implementierungen. </blockquote><br><h1 id="naivnaya-konkatenaciya">  Naive Verkettung </h1><br><p>  Die einfachste L√∂sung ist die Verwendung des Operators <code>+</code> . </p><br><p>  Die Semantik dieser Anweisung lautet wie folgt: Nehmen Sie zwei Zeilen und geben Sie eine Ergebniszeichenfolge zur√ºck, die die Verkettung beider Zeilen enth√§lt.  Es gibt keine Garantie daf√ºr, dass eine neue Zeile zur√ºckgegeben wird.  Wenn beispielsweise eine leere Zeichenfolge und eine andere verkn√ºpft sind, gibt die Laufzeit m√∂glicherweise ein nicht leeres Argument zur√ºck, sodass kein neuer Speicher zugewiesen und keine Daten kopiert werden m√ºssen. </p><br><p>  Wie aus den Ergebnissen am Anfang des Artikels hervorgeht, ist dies jedoch der langsamste Weg. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y }</code> </pre> <br><blockquote>  Leistungsbewertung: <strong>67,8%</strong> . </blockquote><br><h1 id="stringsbuilder">  Strings.Builder </h1><br><p>  Vor nicht allzu langer Zeit wurde Go - <a href="">strings.Builder</a> ein neuer Typ hinzugef√ºgt.  Dies ist ein Analogon zu <code>bytes.Buffer</code> , aber beim Aufrufen der <code>String()</code> -Methode wird der Speicher nicht neu zugewiesen und die Daten werden nicht kopiert. </p><br><p>  Im Gegensatz zu <code>bytes.Buffer</code> verf√ºgt der Builder nicht √ºber die Optimierung eines <a href="">kleinen Puffers</a> und daher des zuvor zugewiesenen Speichers f√ºr eine Zeichenfolge.  Wenn Sie die <code>Grow</code> Methode nicht verwenden, ist die Leistung schlechter als bei <code>bytes.Buffer</code> .  Mehrere Regressionen in Go 1.11 werden durch diese spezielle Funktion verursacht (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL113235</a> ). </p><br><p>  In unserem Code werden wir diesen Fehler aus Gr√ºnden der Reinheit des Experiments vermeiden. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2builder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder strings.Builder builder.Grow(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x) + <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(y)) <span class="hljs-comment"><span class="hljs-comment">//      builder.WriteString(x) builder.WriteString(y) return builder.String() }</span></span></code> </pre> <br><blockquote>  Leistungsbewertung: <strong>80,5%</strong> (+12,7). </blockquote><br><h1 id="kodogeneraciya-dlya-konkatenacii">  Codegenerierung zur Verkettung </h1><br><p>  Wenn wir uns ansehen, welchen Code der Compiler f√ºr den Operator <code>+</code> generiert, werden Aufrufe der Funktionen <code>concatstring2</code> , <code>concatstring3</code> <code>concatstring2</code> <code>concatstring3</code> (bis einschlie√ülich <code>concatstring5</code> ). </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2codegen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } <span class="hljs-comment"><span class="hljs-comment">// =&gt; CALL runtime.concatstring2(SB) func concat3codegen(x, y, z) string { return x + y + z } // =&gt; CALL runtime.concatstring3(SB)</span></span></code> </pre> <br><p>  Schauen <a href="">Sie</a> sich <a href="">runtime / string.go selbst an</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concatstring2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf *tmpBuf, a [2]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> concatstrings(buf, a[:]) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concatstring3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf *tmpBuf, a [3]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> concatstrings(buf, a[:]) }</code> </pre> <br><p>  Es bleibt also, die Funktion <code>concatstrings</code> zu lernen. <br>  Eine vollst√§ndige Liste finden Sie unten unter dem Spoiler, aber hier ist eine allgemeine Beschreibung: </p><br><ol><li>  Der Parameter <code>buf</code> kann <code>nil</code> .  Dieser Puffer wird vom Compiler zugewiesen, wenn die Zeile nicht aus ihrer Definition "entkommt".  Wenn die Zeichenfolge l√§nger als der Frame lebt, ist dieser Puffer immer <code>nil</code> (wie es am h√§ufigsten vorkommt).  Wenn dieser Puffer jedoch verf√ºgbar ist, kann die Zuordnung vermieden werden, falls das Ergebnis in ihn eindringt (seine Gr√∂√üe betr√§gt 32 Byte). </li><li>  Wenn alle Zeilen au√üer einer leer sind, gibt die Funktion diese Zeile zur√ºck.  Gleichzeitig umgehen die auf dem Stapel ausgew√§hlten Zeilen, die ihren Frame verlassen, diese Optimierung, sodass der Aufrufer keinen bereits freigegebenen Speicher erh√§lt. </li><li>  Ferner werden alle Zeilen in den neuen Speicher kopiert. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndige Auflistung der Concatstrings-Funktion</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// concatstrings implements a Go string concatenation x+y+z+... // The operands are passed in the slice a. // If buf != nil, the compiler has determined that the result does not // escape the calling function, so the string data can be stored in buf // if small enough. func concatstrings(buf *tmpBuf, a []string) string { idx := 0 l := 0 count := 0 for i, x := range a { n := len(x) if n == 0 { continue } if l+n &lt; l { throw("string concatenation too long") } l += n count++ idx = i } if count == 0 { return "" } // If there is just one string and either it is not on the stack // or our result does not escape the calling frame (buf != nil), // then we can return that string directly. if count == 1 &amp;&amp; (buf != nil || !stringDataOnStack(a[idx])) { return a[idx] } s, b := rawstringtmp(buf, l) for _, x := range a { copy(b, x) b = b[len(x):] } return s }</span></span></code> </pre> </div></div><br><p>  Hier sehen wir mehrere Stellen gleichzeitig, die f√ºr einen bestimmten Fall optimiert werden k√∂nnen: </p><br><ul><li>  <code>buf</code> meistens leer.  Wenn der Compiler nicht beweisen konnte, dass die Zeichenfolge sicher auf dem Stapel abgelegt werden kann, f√ºhrt das √úbergeben eines zus√§tzlichen Parameters und das √úberpr√ºfen auf <code>nil</code> innerhalb der Funktion nur zu Overhead. </li><li>  F√ºr den Sonderfall mit <code>len(a) == 2</code> ben√∂tigen wir keinen Zyklus und die Berechnungen k√∂nnen vereinfacht werden.  Und dies ist die h√§ufigste Form der Verkettung. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Verkettungsstatistik</b> <div class="spoiler_text"><p>  Bei der Ausf√ºhrung von <code>./make.bash</code> ( <code>./make.bash</code> Go-Compilers und der stdlib) werden 445 Verkettungen mit zwei Operanden angezeigt: </p><br><ul><li>  398 Ergebnisse laufen davon.  In diesem Fall ist unsere Spezialisierung sinnvoll. </li><li>  47 Ergebnisse verlassen Ihren Rahmen nicht. </li></ul><br><p>  Insgesamt <strong>89% der</strong> Verkettungen aus zwei Argumenten werden ins Schwitzen gebracht. </p><br><p>  F√ºr das Dienstprogramm <code>go</code> haben wir: </p><br><ul><li>  501 ruft concatstring2 auf </li><li>  194 ruft concatstring3 auf </li><li>  55 ruft concatstring4 auf </li></ul></div></div><br><h1 id="versiya-dlya-vseh-arhitektur">  Version f√ºr alle Architekturen </h1><br><p>  Um die Spezialisierung zu implementieren, m√ºssen wir wissen, wie die Linien in Go dargestellt werden.  Die Bin√§rkompatibilit√§t ist uns wichtig, w√§hrend sie <code>unsafe.Pointer</code> ist. Der <code>unsafe.Pointer</code> kann ohne Einbu√üen durch <code>*byte</code> werden. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> stringStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { str *<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  Die zweite wichtige Schlussfolgerung, die wir aus der Laufzeit ziehen k√∂nnen: Linien beginnen ihr Leben ver√§nderlich.  Es wird ein Speicher zugewiesen, auf den durch das <code>[]byte</code> verwiesen wird, in das der Inhalt der neuen Zeile geschrieben wird, und erst danach wird das <code>[]byte</code> verworfen, und der Speicher, auf den es verweist, wird in <code>stringStruct</code> gespeichert. </p><br><p>  F√ºr diejenigen, die mehr Details w√ºnschen, wird empfohlen, die Funktionen von <code>rawstringtmp</code> und <code>rawstring</code> . </p><br><div class="spoiler">  <b class="spoiler_title">runtime.rawstring</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// rawstring allocates storage for a new string. The returned // string and byte slice both refer to the same storage. // The storage is not zeroed. Callers should use // b to set the string contents and then drop b. func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false) stringStructOf(&amp;s).str = p stringStructOf(&amp;s).len = size *(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, size} return }</span></span></code> </pre> </div></div><br><p>  Mit der dunklen Seite des <code>unsafe</code> Pakets k√∂nnen wir ungef√§hr gleich hochdrehen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { length := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x) + <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(y) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> length == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> } b := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, length) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(b, x) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(b[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x):], y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goString(&amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>], length) }</code> </pre> <br><p>  Wir markieren <code>[]byte</code> , mit dem wir den Inhalt einer neuen Zeile bilden.  Dann k√∂nnen wir die Zeile nur finalisieren, indem wir sie auf die erwartete Laufzeitdarstellung bringen.  Die <code>goString</code> Funktion ist daf√ºr verantwortlich: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, length </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { s := stringStruct{str: ptr, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: length} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(*<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)(unsafe.Pointer(&amp;s)) }</code> </pre> <br><blockquote>  Leistungsbewertung: <strong>91,9%</strong> (+10,9). </blockquote><br><h1 id="versiya-dlya-amd64">  AMD64-Version </h1><br><p>  Leider hat die vorherige Version der Funktion keine Optimierung f√ºr die Verkettung mit einer leeren Zeichenfolge, und wir f√ºhren auch eine Reihe unn√∂tiger Berechnungen durch, da der Speicher nicht direkt zugewiesen werden kann. Wir m√ºssen mit dem Byte-Slice arbeiten. </p><br><p>  Eine der interessanten Funktionen des Go-Assemblers besteht darin, dass Sie beispielsweise nicht exportierbare Laufzeitfunktionen aufrufen k√∂nnen.  Wir k√∂nnen <code>runtime¬∑mallocgc</code> aus dem Assemblycode <code>runtime¬∑mallocgc</code> , auch wenn es nicht Teil des <code>runtime</code> .  Wir werden diese Eigenschaft nutzen. </p><br><p>  Wir k√∂nnen auch den Besitz der Stapelspeicherzeilen √ºberpr√ºfen, wodurch es sicher ist, die R√ºckgabe eines der Argumente als Ergebnis zu optimieren. </p><br><p>  Angenommen, eine Funktion wird mit den Argumenten <code>concat2("", "123")</code> aufgerufen.  <code>x</code> ist eine leere Zeichenfolge, und wenn <code>y</code> nicht auf dem Stapel zugeordnet ist, k√∂nnen wir sie als Ergebnis der Verkettung zur√ºckgeben. </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/; ,  x  y   stringStruct. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; CX - y.str. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; SI - y.len. maybe_return_y: /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;      . MOVQ (TLS), AX /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; *g CMPQ CX, (AX) JL return_y /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;  y_str &lt; g.stack.lo CMPQ CX, 8(AX) JGE return_y /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;  y_str &gt;= g.stack.hi JMP concatenate /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; y  ,    return_y: MOVQ CX, ret+32(FP) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; stringStruct.len MOVQ SI, ret+40(FP) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; stringStruct.str RET</span></span></code> </pre> <br><p>  <code>MOVQ (TLS), AX</code> verschiebt <a href="">* g</a> in das <code>AX</code> Register.  Das Lesen bei Nullpunktverschiebung ergibt das Feld <code>g.stack.lo</code> , und <code>g.stack.hi</code> beginnt mit dem 8. Byte (f√ºr eine 64-Bit-Plattform). </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { lo <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0(AX) hi uintptr // 8(AX) } stackguard0 uintptr // 16(AX) stackguard1 uintptr // 24(AX) // ...   }</span></span></code> </pre> <br><p>  Der <code>concatenate</code> K√∂rper weist Speicher zu, f√ºllt ihn mit beiden Zeilen und gibt eine neue Zeile zur√ºck. </p><br><div class="spoiler">  <b class="spoiler_title">Vollst√§ndige Auflistung mit Kommentaren</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"textflag.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"funcdata.h"</span></span> <span class="hljs-type"><span class="hljs-type">TEXT</span></span> ¬∑<span class="hljs-type"><span class="hljs-type">Strings</span></span>(<span class="hljs-type"><span class="hljs-type">SB</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">$4</span></span>8<span class="hljs-number"><span class="hljs-number">-48</span></span> <span class="hljs-type"><span class="hljs-type">NO_LOCAL_POINTERS</span></span> //    . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">CX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">TESTQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">JZ</span></span> maybe_return_y // x -  ,   y <span class="hljs-type"><span class="hljs-type">TESTQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">JZ</span></span> maybe_return_x // y -  ,   x concatenate: <span class="hljs-type"><span class="hljs-type">LEAQ</span></span> (<span class="hljs-type"><span class="hljs-type">DI</span></span>)(<span class="hljs-type"><span class="hljs-type">SI</span></span>*<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> // len(x) + len(y) //     . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">R8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-string"><span class="hljs-string">$0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVB</span></span> <span class="hljs-string"><span class="hljs-string">$0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime¬∑mallocgc(<span class="hljs-type"><span class="hljs-type">SB</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> //     <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) //  x. <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime¬∑memmove(<span class="hljs-type"><span class="hljs-type">SB</span></span>) //  y   len(x). <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">CX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> <span class="hljs-type"><span class="hljs-type">LEAQ</span></span> (<span class="hljs-type"><span class="hljs-type">AX</span></span>)(<span class="hljs-type"><span class="hljs-type">DI</span></span>*<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">BX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">BX</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime¬∑memmove(<span class="hljs-type"><span class="hljs-type">SB</span></span>) //   . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> <span class="hljs-type"><span class="hljs-type">ADDQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">R8</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span> maybe_return_y: //      . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> (<span class="hljs-type"><span class="hljs-type">TLS</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> // *g <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, (<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JL</span></span> return_y //  y_ptr &lt; stk.lo <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JGE</span></span> return_y //  y_ptr &gt;= stk.hi <span class="hljs-type"><span class="hljs-type">JMP</span></span> concatenate // y  ,    return_y: <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span> maybe_return_x: //      . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> (<span class="hljs-type"><span class="hljs-type">TLS</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> // *g <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, (<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JL</span></span> return_x //  x_ptr &lt; stk.lo <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JGE</span></span> return_x //  x_ptr &gt;= stk.hi <span class="hljs-type"><span class="hljs-type">JMP</span></span> concatenate // x  ,    return_x: <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span></code> </pre> <br><p>  Wenn Sie an der Art von <code>NO_LOCAL_POINTERS</code> in diesem Code interessiert sind, k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Calling a Go-Funktion von asm</a> lesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">("schwerwiegender Fehler: fehlende Stackmap")</a> . </p></div></div><br><blockquote>  Leistungsbewertung: <strong>100%</strong> (+8,6). </blockquote><br><h1 id="v-kachestve-zaklyucheniya">  Abschlie√üend </h1><br><p>  Der gesamte Code wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Concat-</a> Paket bereitgestellt. </p><br><p>  Ist die Welt bereit f√ºr eine so schnelle Verkettung?  Wer wei√ü. </p><br><p>  Zu Beginn des Artikels wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL123256</a> erw√§hnt.  Er hat mehrere Entwicklungspfade: </p><br><ol><li>  Variationsspezialisierung f√ºr den Fall, dass der Compiler keinen tempor√§ren Puffer zuweist.  Es gibt weniger Wachstum f√ºr jeden Fall, aber es deckt mehr Arten der Verkettung ab und erh√∂ht praktisch nicht die Gr√∂√üe des Codes (sowohl Maschinen- als auch Go-Code). </li><li>  Weitere Spezialisierungen f√ºr Sonderf√§lle.  H√∂here Gewinne, aber mehr Maschinencode k√∂nnen den Anweisungscache besch√§digen. </li><li>  Tonnenweise Maschinencode f√ºr jeden Sonderfall und jedes spezielle Memmove in der Art und Weise, wie dies in glibc erfolgt.  Hier stellen sich vor allem Fragen der Zweckm√§√üigkeit. </li></ol><br><p>  Die derzeit vorgeschlagene Option beschleunigt nur den h√§ufigsten und einfachsten Fall der Verkettung eines Zeichenfolgenpaars (arity = 2). </p><br><p>  Wenn Go diese √Ñnderung nicht akzeptiert, kann eine vergleichbare Beschleunigung erreicht werden, indem Zeichenfolgenoperationen in Form einer Bibliothek eines Drittanbieters implementiert werden.  Weniger bequem, sch√∂n und elegant, aber es funktioniert. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417479/">https://habr.com/ru/post/de417479/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar486164/index.html">ŸÅŸäÿ±Ÿàÿ≥ ŸÉŸàÿ±ŸàŸÜÿß 2019-nCoV. ÿ£ÿ≥ÿ¶ŸÑÿ© Ÿàÿ£ÿ¨Ÿàÿ®ÿ© ÿπŸÜ ÿ≠ŸÖÿßŸäÿ© ÿßŸÑÿ¨Ÿáÿßÿ≤ ÿßŸÑÿ™ŸÜŸÅÿ≥Ÿä ŸàÿßŸÑÿ™ÿ∑ŸáŸäÿ±</a></li>
<li><a href="../ar486174/index.html">ŸÑÿØŸä ÿµŸÅÿ± ÿØŸàÿ±ÿßŸÜ</a></li>
<li><a href="../de417473/index.html">Vertrauensw√ºrdiger Speicher mit DRBD9 und Proxmox (Teil 1: NFS)</a></li>
<li><a href="../de417475/index.html">Glusterfs + L√∂schcodierung: Wenn Sie viel brauchen, billig und zuverl√§ssig</a></li>
<li><a href="../de417477/index.html">Hot Desking</a></li>
<li><a href="../de417481/index.html">Informationen zu Generatoren in JavaScript ES6 und warum es optional ist, sie zu studieren</a></li>
<li><a href="../de417483/index.html">Vergleich von JS-Frameworks: React, Vue und Hyperapp</a></li>
<li><a href="../de417485/index.html">[Lesezeichen] Systemadministrator-Spickzettel f√ºr Linux-Netzwerktools</a></li>
<li><a href="../de417487/index.html">Der Ort, an dem das russische Internet begann</a></li>
<li><a href="../de417489/index.html">Bericht des Club of Rome 2018, Kapitel 3.4: ‚ÄûDezentrale Energie‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>