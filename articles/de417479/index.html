<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>㊙️ 🤳 💨 Schnellere Verkettung von Zeichenfolgen zum Selbermachen in Go 🏮 🏽 🗃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute werden wir die Bindung von kurzen Leitungen in Go um 30% beschleunigen. Und dafür müssen wir Go selbst nicht ändern, all dies wird als Bibliothe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schnellere Verkettung von Zeichenfolgen zum Selbermachen in Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417479/"><p><img src="https://habrastorage.org/webt/36/bi/u0/36biu0kvugh_maxmmyhmuvqlrs8.png"></p><br><p>  Heute werden wir die Bindung von kurzen Leitungen in Go um 30% beschleunigen.  Und dafür müssen wir Go selbst nicht ändern, all dies wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliothek</a> eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Drittanbieters</a> implementiert. </p><br><p>  Unter dem Schnitt, auf den Sie warten: </p><br><ul><li> Vergleichen von <code>+</code> , <code>strings.Builder</code> und nativen Verkettungsfunktionen </li><li>  Gehen Sie zu internen Zeilendetails </li><li>  Ziemlich viel Assembler </li></ul><br><p>  Dieser Artikel kann auch als Ausrede für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL123256 angesehen werden: Laufzeit, cmd / compile: specialize concatstring2</a> .  Ideen zur Verbesserung dieser Änderungsliste sind willkommen. </p><a name="habracut"></a><br><h1 id="srazu-rezultaty">  Sofort Ergebnisse </h1><br><p>  Der Vergleich wurde mit der <code>go tip</code> (Master) -Version des Compilers durchgeführt.  Sie können ähnliche Ergebnisse für Versionen um Go 1.5 erhalten.  Die letzte signifikante Änderung an der Funktion <code>concatstrings</code> war <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL3120: cmd / gc: Zuweisen von Puffern für nicht maskierte Zeichenfolgen auf dem Stapel</a> . </p><br><pre> <code class="hljs powershell">BenchmarkConcat2Operator<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">83.8</span></span> ns/op BenchmarkConcat2Builder<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">70.9</span></span> ns/op BenchmarkConcat2<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">62.1</span></span> ns/op BenchmarkConcat3Operator<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">104</span></span> ns/op BenchmarkConcat3Builder<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">89.9</span></span> ns/op BenchmarkConcat3<span class="hljs-literal"><span class="hljs-literal">-8</span></span> <span class="hljs-number"><span class="hljs-number">20000000</span></span> <span class="hljs-number"><span class="hljs-number">82.1</span></span> ns/op</code> </pre> <br><p>  <code>ConcatOperator</code> verwendet <code>+</code> . <br>  <code>ConcatBuilder</code> verwendet <code>ConcatBuilder</code> mit der richtigen <code>ConcatBuilder</code> . <br>  <code>Concat</code> verwendet die Funktion, die wir als Teil dieser Geschichte implementieren. </p><br><p>  Vergleich über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benchstat</a> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta Concat2<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">84.2</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">62.7</span></span>ns ± <span class="hljs-number"><span class="hljs-number">2</span></span>% <span class="hljs-number"><span class="hljs-number">-25.49</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">10</span></span>) Concat3<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">103</span></span>ns ± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">83</span></span>ns ± <span class="hljs-number"><span class="hljs-number">4</span></span>% <span class="hljs-number"><span class="hljs-number">-19.83</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">10</span></span>+<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br><p>  Die Assembler-Implementierung unter <code>GOARCH=AMD64</code> etwas schneller und verfügt über eine zusätzliche Optimierung, die im integrierten Operator <code>+</code> vorhanden ist. Weitere <code>GOARCH=AMD64</code> weiter unten: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta Concat2<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">84.2</span></span>ns ± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">57.1</span></span>ns ± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">-32.20</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.000</span></span> n=<span class="hljs-number"><span class="hljs-number">9</span></span>+<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br><p>  Wir werden die Assembler-Funktion als 100% ige Leistung betrachten (im Vergleich zu den übrigen betrachteten Implementierungen). </p><br><blockquote>  Ergebnisse für längere Zeilen finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">README.md</a> .  Je länger die Zeichenfolge ist, desto weniger ausgeprägt ist der Unterschied zwischen den Implementierungen. </blockquote><br><h1 id="naivnaya-konkatenaciya">  Naive Verkettung </h1><br><p>  Die einfachste Lösung ist die Verwendung des Operators <code>+</code> . </p><br><p>  Die Semantik dieser Anweisung lautet wie folgt: Nehmen Sie zwei Zeilen und geben Sie eine Ergebniszeichenfolge zurück, die die Verkettung beider Zeilen enthält.  Es gibt keine Garantie dafür, dass eine neue Zeile zurückgegeben wird.  Wenn beispielsweise eine leere Zeichenfolge und eine andere verknüpft sind, gibt die Laufzeit möglicherweise ein nicht leeres Argument zurück, sodass kein neuer Speicher zugewiesen und keine Daten kopiert werden müssen. </p><br><p>  Wie aus den Ergebnissen am Anfang des Artikels hervorgeht, ist dies jedoch der langsamste Weg. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y }</code> </pre> <br><blockquote>  Leistungsbewertung: <strong>67,8%</strong> . </blockquote><br><h1 id="stringsbuilder">  Strings.Builder </h1><br><p>  Vor nicht allzu langer Zeit wurde Go - <a href="">strings.Builder</a> ein neuer Typ hinzugefügt.  Dies ist ein Analogon zu <code>bytes.Buffer</code> , aber beim Aufrufen der <code>String()</code> -Methode wird der Speicher nicht neu zugewiesen und die Daten werden nicht kopiert. </p><br><p>  Im Gegensatz zu <code>bytes.Buffer</code> verfügt der Builder nicht über die Optimierung eines <a href="">kleinen Puffers</a> und daher des zuvor zugewiesenen Speichers für eine Zeichenfolge.  Wenn Sie die <code>Grow</code> Methode nicht verwenden, ist die Leistung schlechter als bei <code>bytes.Buffer</code> .  Mehrere Regressionen in Go 1.11 werden durch diese spezielle Funktion verursacht (siehe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL113235</a> ). </p><br><p>  In unserem Code werden wir diesen Fehler aus Gründen der Reinheit des Experiments vermeiden. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2builder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builder strings.Builder builder.Grow(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x) + <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(y)) <span class="hljs-comment"><span class="hljs-comment">//      builder.WriteString(x) builder.WriteString(y) return builder.String() }</span></span></code> </pre> <br><blockquote>  Leistungsbewertung: <strong>80,5%</strong> (+12,7). </blockquote><br><h1 id="kodogeneraciya-dlya-konkatenacii">  Codegenerierung zur Verkettung </h1><br><p>  Wenn wir uns ansehen, welchen Code der Compiler für den Operator <code>+</code> generiert, werden Aufrufe der Funktionen <code>concatstring2</code> , <code>concatstring3</code> <code>concatstring2</code> <code>concatstring3</code> (bis einschließlich <code>concatstring5</code> ). </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2codegen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } <span class="hljs-comment"><span class="hljs-comment">// =&gt; CALL runtime.concatstring2(SB) func concat3codegen(x, y, z) string { return x + y + z } // =&gt; CALL runtime.concatstring3(SB)</span></span></code> </pre> <br><p>  Schauen <a href="">Sie</a> sich <a href="">runtime / string.go selbst an</a> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concatstring2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf *tmpBuf, a [2]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> concatstrings(buf, a[:]) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concatstring3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf *tmpBuf, a [3]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> concatstrings(buf, a[:]) }</code> </pre> <br><p>  Es bleibt also, die Funktion <code>concatstrings</code> zu lernen. <br>  Eine vollständige Liste finden Sie unten unter dem Spoiler, aber hier ist eine allgemeine Beschreibung: </p><br><ol><li>  Der Parameter <code>buf</code> kann <code>nil</code> .  Dieser Puffer wird vom Compiler zugewiesen, wenn die Zeile nicht aus ihrer Definition "entkommt".  Wenn die Zeichenfolge länger als der Frame lebt, ist dieser Puffer immer <code>nil</code> (wie es am häufigsten vorkommt).  Wenn dieser Puffer jedoch verfügbar ist, kann die Zuordnung vermieden werden, falls das Ergebnis in ihn eindringt (seine Größe beträgt 32 Byte). </li><li>  Wenn alle Zeilen außer einer leer sind, gibt die Funktion diese Zeile zurück.  Gleichzeitig umgehen die auf dem Stapel ausgewählten Zeilen, die ihren Frame verlassen, diese Optimierung, sodass der Aufrufer keinen bereits freigegebenen Speicher erhält. </li><li>  Ferner werden alle Zeilen in den neuen Speicher kopiert. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Vollständige Auflistung der Concatstrings-Funktion</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// concatstrings implements a Go string concatenation x+y+z+... // The operands are passed in the slice a. // If buf != nil, the compiler has determined that the result does not // escape the calling function, so the string data can be stored in buf // if small enough. func concatstrings(buf *tmpBuf, a []string) string { idx := 0 l := 0 count := 0 for i, x := range a { n := len(x) if n == 0 { continue } if l+n &lt; l { throw("string concatenation too long") } l += n count++ idx = i } if count == 0 { return "" } // If there is just one string and either it is not on the stack // or our result does not escape the calling frame (buf != nil), // then we can return that string directly. if count == 1 &amp;&amp; (buf != nil || !stringDataOnStack(a[idx])) { return a[idx] } s, b := rawstringtmp(buf, l) for _, x := range a { copy(b, x) b = b[len(x):] } return s }</span></span></code> </pre> </div></div><br><p>  Hier sehen wir mehrere Stellen gleichzeitig, die für einen bestimmten Fall optimiert werden können: </p><br><ul><li>  <code>buf</code> meistens leer.  Wenn der Compiler nicht beweisen konnte, dass die Zeichenfolge sicher auf dem Stapel abgelegt werden kann, führt das Übergeben eines zusätzlichen Parameters und das Überprüfen auf <code>nil</code> innerhalb der Funktion nur zu Overhead. </li><li>  Für den Sonderfall mit <code>len(a) == 2</code> benötigen wir keinen Zyklus und die Berechnungen können vereinfacht werden.  Und dies ist die häufigste Form der Verkettung. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Verkettungsstatistik</b> <div class="spoiler_text"><p>  Bei der Ausführung von <code>./make.bash</code> ( <code>./make.bash</code> Go-Compilers und der stdlib) werden 445 Verkettungen mit zwei Operanden angezeigt: </p><br><ul><li>  398 Ergebnisse laufen davon.  In diesem Fall ist unsere Spezialisierung sinnvoll. </li><li>  47 Ergebnisse verlassen Ihren Rahmen nicht. </li></ul><br><p>  Insgesamt <strong>89% der</strong> Verkettungen aus zwei Argumenten werden ins Schwitzen gebracht. </p><br><p>  Für das Dienstprogramm <code>go</code> haben wir: </p><br><ul><li>  501 ruft concatstring2 auf </li><li>  194 ruft concatstring3 auf </li><li>  55 ruft concatstring4 auf </li></ul></div></div><br><h1 id="versiya-dlya-vseh-arhitektur">  Version für alle Architekturen </h1><br><p>  Um die Spezialisierung zu implementieren, müssen wir wissen, wie die Linien in Go dargestellt werden.  Die Binärkompatibilität ist uns wichtig, während sie <code>unsafe.Pointer</code> ist. Der <code>unsafe.Pointer</code> kann ohne Einbußen durch <code>*byte</code> werden. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> stringStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { str *<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>  Die zweite wichtige Schlussfolgerung, die wir aus der Laufzeit ziehen können: Linien beginnen ihr Leben veränderlich.  Es wird ein Speicher zugewiesen, auf den durch das <code>[]byte</code> verwiesen wird, in das der Inhalt der neuen Zeile geschrieben wird, und erst danach wird das <code>[]byte</code> verworfen, und der Speicher, auf den es verweist, wird in <code>stringStruct</code> gespeichert. </p><br><p>  Für diejenigen, die mehr Details wünschen, wird empfohlen, die Funktionen von <code>rawstringtmp</code> und <code>rawstring</code> . </p><br><div class="spoiler">  <b class="spoiler_title">runtime.rawstring</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// rawstring allocates storage for a new string. The returned // string and byte slice both refer to the same storage. // The storage is not zeroed. Callers should use // b to set the string contents and then drop b. func rawstring(size int) (s string, b []byte) { p := mallocgc(uintptr(size), nil, false) stringStructOf(&amp;s).str = p stringStructOf(&amp;s).len = size *(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, size} return }</span></span></code> </pre> </div></div><br><p>  Mit der dunklen Seite des <code>unsafe</code> Pakets können wir ungefähr gleich hochdrehen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { length := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x) + <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(y) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> length == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> } b := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, length) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(b, x) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(b[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x):], y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> goString(&amp;b[<span class="hljs-number"><span class="hljs-number">0</span></span>], length) }</code> </pre> <br><p>  Wir markieren <code>[]byte</code> , mit dem wir den Inhalt einer neuen Zeile bilden.  Dann können wir die Zeile nur finalisieren, indem wir sie auf die erwartete Laufzeitdarstellung bringen.  Die <code>goString</code> Funktion ist dafür verantwortlich: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ptr *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, length </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { s := stringStruct{str: ptr, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: length} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(*<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)(unsafe.Pointer(&amp;s)) }</code> </pre> <br><blockquote>  Leistungsbewertung: <strong>91,9%</strong> (+10,9). </blockquote><br><h1 id="versiya-dlya-amd64">  AMD64-Version </h1><br><p>  Leider hat die vorherige Version der Funktion keine Optimierung für die Verkettung mit einer leeren Zeichenfolge, und wir führen auch eine Reihe unnötiger Berechnungen durch, da der Speicher nicht direkt zugewiesen werden kann. Wir müssen mit dem Byte-Slice arbeiten. </p><br><p>  Eine der interessanten Funktionen des Go-Assemblers besteht darin, dass Sie beispielsweise nicht exportierbare Laufzeitfunktionen aufrufen können.  Wir können <code>runtime·mallocgc</code> aus dem Assemblycode <code>runtime·mallocgc</code> , auch wenn es nicht Teil des <code>runtime</code> .  Wir werden diese Eigenschaft nutzen. </p><br><p>  Wir können auch den Besitz der Stapelspeicherzeilen überprüfen, wodurch es sicher ist, die Rückgabe eines der Argumente als Ergebnis zu optimieren. </p><br><p>  Angenommen, eine Funktion wird mit den Argumenten <code>concat2("", "123")</code> aufgerufen.  <code>x</code> ist eine leere Zeichenfolge, und wenn <code>y</code> nicht auf dem Stapel zugeordnet ist, können wir sie als Ergebnis der Verkettung zurückgeben. </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/; ,  x  y   stringStruct. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; CX - y.str. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; SI - y.len. maybe_return_y: /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;      . MOVQ (TLS), AX /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; *g CMPQ CX, (AX) JL return_y /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;  y_str &lt; g.stack.lo CMPQ CX, 8(AX) JGE return_y /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/;  y_str &gt;= g.stack.hi JMP concatenate /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; y  ,    return_y: MOVQ CX, ret+32(FP) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; stringStruct.len MOVQ SI, ret+40(FP) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/; stringStruct.str RET</span></span></code> </pre> <br><p>  <code>MOVQ (TLS), AX</code> verschiebt <a href="">* g</a> in das <code>AX</code> Register.  Das Lesen bei Nullpunktverschiebung ergibt das Feld <code>g.stack.lo</code> , und <code>g.stack.hi</code> beginnt mit dem 8. Byte (für eine 64-Bit-Plattform). </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> g <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { stack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { lo <span class="hljs-keyword"><span class="hljs-keyword">uintptr</span></span> <span class="hljs-comment"><span class="hljs-comment">// 0(AX) hi uintptr // 8(AX) } stackguard0 uintptr // 16(AX) stackguard1 uintptr // 24(AX) // ...   }</span></span></code> </pre> <br><p>  Der <code>concatenate</code> Körper weist Speicher zu, füllt ihn mit beiden Zeilen und gibt eine neue Zeile zurück. </p><br><div class="spoiler">  <b class="spoiler_title">Vollständige Auflistung mit Kommentaren</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"textflag.h"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#include</span></span> <span class="hljs-comment"><span class="hljs-comment">"funcdata.h"</span></span> <span class="hljs-type"><span class="hljs-type">TEXT</span></span> ·<span class="hljs-type"><span class="hljs-type">Strings</span></span>(<span class="hljs-type"><span class="hljs-type">SB</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">$4</span></span>8<span class="hljs-number"><span class="hljs-number">-48</span></span> <span class="hljs-type"><span class="hljs-type">NO_LOCAL_POINTERS</span></span> //    . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">CX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">TESTQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">JZ</span></span> maybe_return_y // x -  ,   y <span class="hljs-type"><span class="hljs-type">TESTQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">JZ</span></span> maybe_return_x // y -  ,   x concatenate: <span class="hljs-type"><span class="hljs-type">LEAQ</span></span> (<span class="hljs-type"><span class="hljs-type">DI</span></span>)(<span class="hljs-type"><span class="hljs-type">SI</span></span>*<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> // len(x) + len(y) //     . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">R8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-string"><span class="hljs-string">$0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVB</span></span> <span class="hljs-string"><span class="hljs-string">$0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime·mallocgc(<span class="hljs-type"><span class="hljs-type">SB</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> //     <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) //  x. <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime·memmove(<span class="hljs-type"><span class="hljs-type">SB</span></span>) //  y   len(x). <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">DI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">CX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">SI</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> <span class="hljs-type"><span class="hljs-type">LEAQ</span></span> (<span class="hljs-type"><span class="hljs-type">AX</span></span>)(<span class="hljs-type"><span class="hljs-type">DI</span></span>*<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-type"><span class="hljs-type">BX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">BX</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>) <span class="hljs-type"><span class="hljs-type">CALL</span></span> runtime·memmove(<span class="hljs-type"><span class="hljs-type">SB</span></span>) //   . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> newstr<span class="hljs-number"><span class="hljs-number">-8</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> x+<span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> <span class="hljs-type"><span class="hljs-type">ADDQ</span></span> y+<span class="hljs-number"><span class="hljs-number">24</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>), <span class="hljs-type"><span class="hljs-type">R8</span></span> <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">AX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">R8</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span> maybe_return_y: //      . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> (<span class="hljs-type"><span class="hljs-type">TLS</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> // *g <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, (<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JL</span></span> return_y //  y_ptr &lt; stk.lo <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JGE</span></span> return_y //  y_ptr &gt;= stk.hi <span class="hljs-type"><span class="hljs-type">JMP</span></span> concatenate // y  ,    return_y: <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">CX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">SI</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span> maybe_return_x: //      . <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> (<span class="hljs-type"><span class="hljs-type">TLS</span></span>), <span class="hljs-type"><span class="hljs-type">AX</span></span> // *g <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, (<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JL</span></span> return_x //  x_ptr &lt; stk.lo <span class="hljs-type"><span class="hljs-type">CMPQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(<span class="hljs-type"><span class="hljs-type">AX</span></span>) <span class="hljs-type"><span class="hljs-type">JGE</span></span> return_x //  x_ptr &gt;= stk.hi <span class="hljs-type"><span class="hljs-type">JMP</span></span> concatenate // x  ,    return_x: <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DX</span></span>, ret+<span class="hljs-number"><span class="hljs-number">32</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">MOVQ</span></span> <span class="hljs-type"><span class="hljs-type">DI</span></span>, ret+<span class="hljs-number"><span class="hljs-number">40</span></span>(<span class="hljs-type"><span class="hljs-type">FP</span></span>) <span class="hljs-type"><span class="hljs-type">RET</span></span></code> </pre> <br><p>  Wenn Sie an der Art von <code>NO_LOCAL_POINTERS</code> in diesem Code interessiert sind, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Calling a Go-Funktion von asm</a> lesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">("schwerwiegender Fehler: fehlende Stackmap")</a> . </p></div></div><br><blockquote>  Leistungsbewertung: <strong>100%</strong> (+8,6). </blockquote><br><h1 id="v-kachestve-zaklyucheniya">  Abschließend </h1><br><p>  Der gesamte Code wird als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Concat-</a> Paket bereitgestellt. </p><br><p>  Ist die Welt bereit für eine so schnelle Verkettung?  Wer weiß. </p><br><p>  Zu Beginn des Artikels wurde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CL123256</a> erwähnt.  Er hat mehrere Entwicklungspfade: </p><br><ol><li>  Variationsspezialisierung für den Fall, dass der Compiler keinen temporären Puffer zuweist.  Es gibt weniger Wachstum für jeden Fall, aber es deckt mehr Arten der Verkettung ab und erhöht praktisch nicht die Größe des Codes (sowohl Maschinen- als auch Go-Code). </li><li>  Weitere Spezialisierungen für Sonderfälle.  Höhere Gewinne, aber mehr Maschinencode können den Anweisungscache beschädigen. </li><li>  Tonnenweise Maschinencode für jeden Sonderfall und jedes spezielle Memmove in der Art und Weise, wie dies in glibc erfolgt.  Hier stellen sich vor allem Fragen der Zweckmäßigkeit. </li></ol><br><p>  Die derzeit vorgeschlagene Option beschleunigt nur den häufigsten und einfachsten Fall der Verkettung eines Zeichenfolgenpaars (arity = 2). </p><br><p>  Wenn Go diese Änderung nicht akzeptiert, kann eine vergleichbare Beschleunigung erreicht werden, indem Zeichenfolgenoperationen in Form einer Bibliothek eines Drittanbieters implementiert werden.  Weniger bequem, schön und elegant, aber es funktioniert. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417479/">https://habr.com/ru/post/de417479/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar486164/index.html">فيروس كورونا 2019-nCoV. أسئلة وأجوبة عن حماية الجهاز التنفسي والتطهير</a></li>
<li><a href="../ar486174/index.html">لدي صفر دوران</a></li>
<li><a href="../de417473/index.html">Vertrauenswürdiger Speicher mit DRBD9 und Proxmox (Teil 1: NFS)</a></li>
<li><a href="../de417475/index.html">Glusterfs + Löschcodierung: Wenn Sie viel brauchen, billig und zuverlässig</a></li>
<li><a href="../de417477/index.html">Hot Desking</a></li>
<li><a href="../de417481/index.html">Informationen zu Generatoren in JavaScript ES6 und warum es optional ist, sie zu studieren</a></li>
<li><a href="../de417483/index.html">Vergleich von JS-Frameworks: React, Vue und Hyperapp</a></li>
<li><a href="../de417485/index.html">[Lesezeichen] Systemadministrator-Spickzettel für Linux-Netzwerktools</a></li>
<li><a href="../de417487/index.html">Der Ort, an dem das russische Internet begann</a></li>
<li><a href="../de417489/index.html">Bericht des Club of Rome 2018, Kapitel 3.4: „Dezentrale Energie“</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>