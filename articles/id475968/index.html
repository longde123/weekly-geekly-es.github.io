<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>â° ğŸ’ƒğŸ¾ â˜ï¸ Berita menarik Vue 3 ğŸš© ğŸ‘©ğŸ¼â€ğŸ¤ ğŸ‘©ğŸ¾â€ğŸ’¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alih-alih kata pengantar 
 Vue digunakan di semua proyek FunCorp. Kami memonitor perkembangan kerangka kerja, terus meningkatkan proses pengembangan d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berita menarik Vue 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/475968/"><h2>  Alih-alih kata pengantar </h2><br>  Vue digunakan di semua proyek FunCorp.  Kami memonitor perkembangan kerangka kerja, terus meningkatkan proses pengembangan dan menerapkan praktik terbaik.  Dan, tentu saja, kami tidak dapat melewati dan tidak menerjemahkan artikel oleh Philip Rakovsky, salah satu pendiri VueStorefront, tentang fitur Vue 3 baru yang secara serius mempengaruhi penulisan kode. <br><br><img src="https://habrastorage.org/webt/ta/6z/aq/ta6zaqz4kxyqh_wh0zoo4zayqeo.png" alt="gambar"><br>  Terakhir kali kami melihat fitur yang memengaruhi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kinerja Vue 3</a> .  Kita sudah tahu bahwa aplikasi yang ditulis pada versi baru kerangka kerja bekerja sangat cepat, tetapi kinerja bukanlah perubahan yang paling penting.  Bagi kebanyakan pengembang, bagaimana Vue 3 mempengaruhi cara Anda menulis kode jauh lebih penting. <a name="habracut"></a><br><br>  Seperti yang mungkin sudah Anda duga, Vue 3 akan memiliki banyak fitur keren.  Untungnya, tim Vue telah menambahkan lebih banyak peningkatan dan penambahan daripada memecah perubahan.  Karena itu, sebagian besar pengembang yang tahu Vue 2 harus cepat merasa nyaman dengan sintaks baru. <br><br>  Mari kita mulai dengan API yang mungkin sudah banyak Anda dengar. <br><br><h2>  API komposisi </h2><br>  API Komposisi adalah fitur yang paling banyak dibicarakan dan disebutkan dari versi utama Vue berikutnya.  Sintaksis API Komposisi menyediakan pendekatan yang sama sekali baru untuk mengatur dan menggunakan kembali kode. <br><br>  Kami sekarang membuat komponen dengan sintaks yang disebut API Opsi.  Untuk menambahkan logika, kami membuat properti (opsi) di objek komponen, misalnya, data, metode, dihitung, dll.  Kerugian utama dari pendekatan ini adalah bahwa itu bukan kode JavaScript.  Anda perlu tahu persis opsi apa yang tersedia di templat dan seperti apa nantinya.  Kompiler Vue mengubah properti menjadi kode JavaScript yang berfungsi untuk Anda.  Karena fitur ini, kami tidak dapat sepenuhnya menggunakan pelengkapan otomatis atau pemeriksaan tipe. <br><br>  API Komposisi memecahkan masalah ini dan memungkinkan untuk menggunakan mekanisme yang tersedia melalui opsi menggunakan fungsi JavaScript biasa. <br>  Tim Vue menggambarkan API Komposisi sebagai "API berbasis fitur opsional yang memungkinkan penggunaan komposisi yang fleksibel dalam logika komponen."  Kode yang ditulis menggunakan API baru lebih mudah dibaca, sehingga lebih mudah dipahami. <br><br>  Untuk memahami cara kerja sintaks baru, pertimbangkan contoh komponen sederhana. <br><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span> Count is: {{ count }}, double is {{ double }}, click to increment. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> { ref, computed, onMounted } </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'vue'</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">export</span></span></span><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">default</span></span></span><span class="javascript"> { setup() { </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> count = ref(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">0</span></span></span><span class="javascript">) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> double = computed(</span><span class="hljs-function"><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="javascript"><span class="hljs-function"> =&gt;</span></span></span><span class="javascript"> count.value * </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">) </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">increment</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ count.value++ } onMounted(</span><span class="hljs-function"><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span><span class="javascript"><span class="hljs-function"> =&gt;</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'component mounted!'</span></span></span><span class="javascript">)) </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">return</span></span></span><span class="javascript"> { count, double, increment } } } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Kami akan memecah kode menjadi beberapa bagian dan menganalisis apa yang terjadi di sini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ref, computed, onMounted } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span></code> </pre> <br>  Seperti yang saya sebutkan di atas, API Komposisi menyajikan opsi komponen sebagai fungsi, oleh karena itu, pertama-tama, kita harus mengimpor fungsi yang diperlukan.  Dalam contoh ini, kita perlu membuat properti reaktif menggunakan ref yang dihitung menggunakan dihitung dan mengakses kait siklus hidup yang dipasang menggunakan fungsi onMounted. <br><br>  Anda mungkin memiliki pertanyaan: apa metode pengaturan misterius ini? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup() {} }</code> </pre> <br>  Singkatnya, pengaturan hanyalah fungsi yang meneruskan properti dan fungsi ke templat.  Kami menjelaskan semua properti reaktif dan terkomputasi, kait siklus hidup dan semua pengamat dalam fungsi pengaturan, dan kemudian mengembalikannya untuk digunakan dalam templat. <br><br>  Kenyataan bahwa kami tidak akan kembali dari pengaturan, tidak akan ada akses di templat. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = ref(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Properti hitung reaktif diinisialisasi menggunakan fungsi ref.  Dibutuhkan primitif atau objek dan mengembalikan tautan reaktif.  Nilai yang diteruskan akan disimpan dalam properti nilai dari tautan yang dibuat.  Misalnya, jika kita ingin mengakses nilai penghitungan, kita perlu mengakses penghitungan secara eksplisit. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> double = computed(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> count.value * <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ count.value++ }</code> </pre><br>  Jadi kami mendeklarasikan properti ganda yang dihitung dan fungsi kenaikan. <br><br><pre> <code class="javascript hljs">onMounted(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'component mounted!'</span></span>))</code> </pre> <br>  Menggunakan kait onMounted, kami mencetak pesan ke konsol setelah memasang komponen untuk menunjukkan kemungkinan ini. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, double, increment }</code> </pre> <br>  Agar properti hitung dan gandakan dan metode kenaikan tersedia dalam templat, kami mengembalikannya dari metode penyetelan. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span> Count is: {{ count }}, double is {{ double }}. Click to increment. <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dan voila!  Kami memiliki akses ke properti dan metode dari pengaturan, seperti jika mereka dinyatakan melalui API Opsi yang lama. <br><br>  Ini adalah contoh sederhana, yang serupa dapat dengan mudah ditulis menggunakan API Opsi. <br>  Tetapi keuntungan dari Komposisi API baru tidak begitu banyak dalam kemampuan untuk menulis kode dalam gaya yang berbeda, tetapi dalam kemungkinan terbuka untuk menggunakan kembali logika. <br><br><h2>  Menggunakan kembali kode dengan API Komposisi </h2><br>  Mari kita lihat lebih dekat manfaat API Komposisi baru, misalnya, untuk menggunakan kembali kode.  Sekarang, jika kita ingin menggunakan beberapa bagian kode dalam beberapa komponen, kita memiliki dua opsi: mixin dan slot scoped.  Kedua opsi memiliki kekurangan. <br><br>  Kami ingin mengekstrak fungsi penghitung dan menggunakannya kembali di komponen lain.  Berikut adalah contoh bagaimana hal ini dapat dilakukan dengan menggunakan API yang ada dan menggunakan yang baru. <br><br>  Untuk memulai, pertimbangkan penerapan menggunakan mixin. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CounterMixin <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./mixins/counter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [CounterMixin] }</code> </pre> <br>  Masalah terbesar dengan pendekatan ini adalah kita tidak tahu apa-apa tentang apa yang ditambahkan ke komponen kita.  Ini membuat pemahaman menjadi sulit dan dapat menyebabkan konflik dengan properti dan metode yang ada. <br><br>  Sekarang pertimbangkan slot dengan cakupan terbatas. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{ count, increment }"</span></span></span><span class="hljs-tag">&gt;</span></span> {{ count }} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> @</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"increment"</span></span></span><span class="hljs-tag">&gt;</span></span>Increment<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Counter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Saat menggunakan slot, kita tahu persis properti apa yang kita miliki akses melalui direktif v-slot, yang cukup mudah dimengerti.  Kerugian dari pendekatan ini adalah kita hanya dapat mengakses data komponen Penghitung. <br><br>  Sekarang pertimbangkan implementasi menggunakan API Komposisi. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> count = ref(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ count.value++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, incrememt } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { setup () { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { count, increment } = useCounter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { count, increment } } }</code> </pre> <br>  Terlihat jauh lebih elegan, bukan?  Kami tidak dibatasi oleh templat atau lingkup, dan kami tahu persis properti apa yang tersedia.  Dan karena fakta bahwa useCounter hanyalah fungsi yang mengembalikan data, sebagai bonus yang menyenangkan kita mendapatkan penyelesaian kode di editor.  Tidak ada keajaiban di sini, jadi editor dapat membantu kami mengetik dan memberi petunjuk. <br><br>  Menggunakan perpustakaan pihak ketiga juga terlihat lebih baik.  Sebagai contoh, jika kita ingin menggunakan Vuex, kita dapat secara eksplisit mengimpor fungsi useStore dan tidak menyumbat prototipe Vue dengan properti. $ Store ini.  Pendekatan ini memungkinkan Anda untuk menyingkirkan manipulasi tambahan dalam plugin. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { commit, dispatch } = useStore()</code> </pre> <br>  Jika Anda ingin tahu lebih banyak tentang API Komposisi dan aplikasinya, saya sarankan membaca dokumen di mana tim Vue menjelaskan alasan untuk membuat API baru dan menawarkan kasus yang akan bermanfaat.  Ada juga repositori yang luar biasa dengan contoh penggunaan API Komposisi dari Thorsten LÃ¼nborg, salah satu anggota tim inti Vue. <br><br><h2>  Konfigurasi dan Perubahan Pemasangan </h2><br>  Ada perubahan penting lainnya dalam Vue baru dalam cara kami membangun dan mengkonfigurasi aplikasi kami.  Mari kita lihat sebuah contoh. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Vue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span> Vue.config.ignoredElements = [<span class="hljs-regexp"><span class="hljs-regexp">/^app-/</span></span>] Vue.use(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.mixin(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.component(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) Vue.directive(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vue({ <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">h</span></span></span><span class="hljs-function"> =&gt;</span></span> h(App) }).$mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>)</code> </pre> <br>  Kami sekarang menggunakan objek global Vue untuk mengonfigurasi dan membuat instance Vue baru.  Setiap perubahan yang kita buat pada objek Vue akan memengaruhi instance dan komponen akhir. <br><br>  Mari kita lihat bagaimana ini akan bekerja di Vue 3. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createApp } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> App <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./App.vue'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = createApp(App) app.config.ignoredElements = [<span class="hljs-regexp"><span class="hljs-regexp">/^app-/</span></span>] app.use(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.mixin(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.component(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.directive(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>) app.mount(<span class="hljs-string"><span class="hljs-string">'#app'</span></span>)</code> </pre> <br>  Seperti yang sudah Anda perhatikan, konfigurasi merujuk ke instance Vue khusus yang dibuat menggunakan createApp. <br><br>  Ini membuat kode kami lebih mudah dibaca, mengurangi kemungkinan masalah tak terduga dengan plugin pihak ketiga.  Sekarang perpustakaan pihak ketiga mana pun yang memodifikasi objek global Vue dapat memengaruhi aplikasi Anda di tempat yang tak terduga (terutama jika itu adalah mixin global), yang tidak mungkin dilakukan di Vue 3. <br><br>  Perubahan-perubahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini dibahas</a> dalam RFC, dan mungkin di masa depan implementasinya akan berbeda. <br><br><h2>  Fragmen </h2><br>  Fitur keren lain yang bisa kita andalkan di Vue 3. <br>  Apa itu fragmen? <br>  Saat ini, komponen hanya dapat memiliki satu elemen root, yang berarti bahwa kode di bawah ini tidak akan berfungsi. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>Hello<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span>World<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Alasannya adalah bahwa instance Vue bersembunyi di balik masing-masing komponen hanya dapat dilampirkan ke satu elemen DOM.  Sekarang ada cara untuk membuat komponen dengan beberapa elemen root: untuk ini, Anda perlu menulis komponen dengan gaya fungsional yang tidak memerlukan instance Vue sendiri. <br><br>  Ternyata masalah yang sama ada di komunitas Bereaksi, dipecahkan menggunakan elemen Fragment virtual. <br><br>  Ini terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Columns</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Hello</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">World</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">td</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">React.Fragment</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br>  Terlepas dari kenyataan bahwa Fragmen terlihat seperti elemen DOM biasa, itu adalah virtual dan tidak akan dibuat di pohon DOM.  Dengan pendekatan ini, kita dapat menggunakan fungsionalitas elemen root tunggal tanpa membuat elemen tambahan di DOM. <br><br>  Sekarang Anda dapat menggunakan fragmen di Vue 2, tetapi menggunakan pustaka vue-fragmen, dan di Vue 3 mereka akan bekerja di luar kotak! <br><br><h2>  Ketegangan </h2><br>  Gagasan hebat lainnya dari ekosistem Bereaksi yang akan diterapkan di Vue 3 adalah Suspense. <br><br>  Suspense menjeda pembuatan komponen dan menampilkan sebuah rintisan sampai kondisi tertentu terpenuhi.  Di Vue London, Ewan Yu dengan santai menyentuh Suspense dan mengungkapkan API yang dapat kita harapkan di masa depan.  Komponen suspensi akan memiliki 2 slot: untuk konten dan untuk rintisan. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspense</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspended-component</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag"> #</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">fallback</span></span></span><span class="hljs-tag">&gt;</span></span> Loading... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Suspense</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Rintisan akan ditampilkan sampai komponen &lt;Suspended-komponen /&gt; siap.  Komponen Suspense juga dapat memuat komponen asinkron atau melakukan beberapa tindakan asinkron dalam fungsi pengaturan. <br><br><h2>  Beberapa model-v </h2><br>  v-model adalah arahan yang dengannya Anda dapat menggunakan penjilidan dua arah.  Kita dapat melewatkan properti reaktif dan mengubahnya di dalam komponen. <br><br>  Kami terkenal karena bekerja dengan elemen bentuk. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Tapi tahukah Anda bahwa model-v dapat digunakan dengan komponen apa pun?  Di bawah tenda, v-model hanya meneruskan parameter nilai dan mendengarkan acara masukan. <br><br>  Anda dapat menulis ulang contoh sebelumnya menggunakan sintaks ini sebagai berikut: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-bind:value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-on:input</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"property = $event.target.value"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Anda bahkan dapat mengubah nama dan acara properti default menggunakan opsi model: <br><br><pre> <code class="javascript hljs">model: { <span class="hljs-attr"><span class="hljs-attr">prop</span></span>: <span class="hljs-string"><span class="hljs-string">'checked'</span></span>, <span class="hljs-attr"><span class="hljs-attr">event</span></span>: <span class="hljs-string"><span class="hljs-string">'change'</span></span> }</code> </pre> <br>  Seperti yang Anda lihat, arahan model-v dapat menjadi â€œgula sintaksisâ€ yang sangat berguna jika kita ingin menggunakan pengikatan dua arah dalam komponen kita.  Sayangnya, hanya ada satu model-v per komponen. <br><br>  Untungnya, dalam Vue 3 masalah ini akan terpecahkan.  Kita dapat meneruskan nama ke model-v dan menggunakan model-v sebanyak yang diperlukan. <br><br>  Contoh penggunaan: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">InviteeForm</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inviteeName"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model:email</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"inviteeEmail"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre> <br>  Perubahan-perubahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini dibahas</a> dalam RFC, dan mungkin di masa depan implementasinya akan berbeda. <br><br><h2>  Portal </h2><br>  Portal adalah komponen yang dibuat untuk merender konten di luar hierarki komponen saat ini.  Ini juga salah satu fitur yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diterapkan dalam Bereaksi</a> .  Dalam dokumentasi Bereaksi, portal dijelaskan sebagai berikut: "Portal memungkinkan Anda untuk membuat anak-anak di simpul DOM yang berada di luar hierarki DOM komponen induk." <br><br>  Portal bagus untuk mengimplementasikan komponen seperti modal windows, popup, dan semua yang perlu ditampilkan di atas halaman. <br><br>  Saat menggunakan portal, Anda dapat yakin bahwa gaya komponen induk tidak akan mempengaruhi komponen turunan.  Ini juga akan menghemat hacks indeks-z yang kotor. <br><br>  Untuk setiap portal, kita perlu menentukan tujuan di mana konten portal harus ditampilkan. <br><br>  Berikut ini adalah opsi implementasi pada pustaka portal-vue, yang menambahkan portal ke Vue 2. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"destination"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>This slot content will be rendered wherever the portal-target with name 'destination' is located.<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal-target</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"destination"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!-- This component can be located anywhere in your App. The slot content of the above portal component wilbe rendered here. --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">portal-target</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dan di Vue 3, fitur ini akan keluar dari kotak. <br><br><h2>  API Instruksi Kustom Baru </h2><br>  API arahan khusus akan berubah sedikit dalam Vue 3 agar lebih cocok dengan siklus hidup komponen.  Membuat arahan akan menjadi lebih intuitif, dan karenanya lebih mudah bagi pemula untuk memahami dan belajar. <br><br>  Sekarang deklarasi arahan pengguna terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyDirective = { bind(el, binding, vnode, prevVnode) {}, inserted() {}, update() {}, componentUpdated() {}, unbind() {} }</code> </pre> <br>  Dan dalam Vue 3 akan terlihat seperti ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyDirective = { beforeMount(el, binding, vnode, prevVnode) {}, mounted() {}, beforeUpdate() {}, updated() {}, beforeUnmount() {}, <span class="hljs-comment"><span class="hljs-comment">// new unmounted() {} }</span></span></code> </pre> <br>  Meskipun ini melanggar perubahan, mereka dapat digunakan dengan Vue build yang kompatibel. <br><br>  API ini juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dibahas</a> dan dapat berubah di masa mendatang. <br><br><h2>  Ringkasan </h2><br>  Di samping inovasi yang signifikan - API Komposisi - kami dapat menemukan beberapa peningkatan yang lebih kecil.  Jelas, Vue bergerak menuju peningkatan pengalaman pengembang, menuju penyederhanaan dan API intuitif.  Sangat menyenangkan melihat bahwa tim Vue memutuskan untuk menambahkan banyak ide ke inti kerangka kerja yang sudah diterapkan di perpustakaan pihak ketiga. <br><br>  Daftar di atas hanya berisi perbaikan dan perubahan paling penting untuk API.  Jika Anda ingin mempelajari tentang orang lain, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori RFC</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475968/">https://habr.com/ru/post/id475968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475948/index.html">JH Rainwater "Cara merumput kucing" (bagian dua): semua yang tersisa untuk menguasai teknis</a></li>
<li><a href="../id475950/index.html">Mengapa robot membatasi dirinya untuk mengumpulkan bola golf? Ada juga tenis</a></li>
<li><a href="../id475956/index.html">Bagaimana kami menciptakan teknologi pengenalan teks optik. OCR di Yandex</a></li>
<li><a href="../id475958/index.html">Kisah tentang bagaimana gadis itu berkumpul di IT</a></li>
<li><a href="../id475960/index.html">AHURATUS Smart Home Voice Assistant</a></li>
<li><a href="../id475974/index.html">Bagaimana kami membuat hackathon di kereta dan apa yang terjadi</a></li>
<li><a href="../id475978/index.html">Untuk apa markas kereta itu?</a></li>
<li><a href="../id475980/index.html">Konektivitas rendah, arsitektur, dan organisasi tim</a></li>
<li><a href="../id475982/index.html">Cara belajar bahasa asing</a></li>
<li><a href="../id475986/index.html">Ikhtisar PocketBook 740 Pro Reader: 7,8 inci, perlindungan audio dan IPX8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>