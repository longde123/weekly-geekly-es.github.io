<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🏭 😣 👨‍👧 Dasar-dasar JavaScript untuk Pemula ⤵️ 🖕🏻 🕘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahan, terjemahan yang kami terbitkan hari ini, didedikasikan untuk dasar-dasar JavaScript dan ditujukan untuk programmer pemula. Ini dapat dianggap s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dasar-dasar JavaScript untuk Pemula</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/416375/">  Bahan, terjemahan yang kami terbitkan hari ini, didedikasikan untuk dasar-dasar JavaScript dan ditujukan untuk programmer pemula.  Ini dapat dianggap sebagai referensi kecil untuk konstruksi dasar JS.  Di sini, khususnya, kita akan berbicara tentang sistem tipe data, tentang variabel, tentang array, tentang fungsi, tentang prototipe objek, dan tentang beberapa fitur lain dari bahasa. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/my/cj/zq/mycjzqfpfohnkk9vnefgsl915vm.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tipe Data Primitif</font> </h2><br>  Tipe data primitif berikut tersedia dalam JavaScript: <code>number</code> , <code>boolean</code> , <code>string</code> , <code>undefined</code> , <code>null</code> .  Harus segera dicatat bahwa, ketika bekerja dengan tipe data primitif, misalnya, dengan literal string, kami, bahkan tanpa melakukan konversi eksplisit, akan dapat mengakses metode dan properti mereka.  Intinya di sini adalah bahwa ketika mencoba melakukan operasi seperti itu, literal secara otomatis dilengkapi dengan pembungkus objek yang sesuai. <br><br><h3>  <font color="#3AC1EF">▍ Angka</font> </h3><br>  JavaScript hanya memiliki satu jenis angka - ini adalah angka floating point presisi ganda.  Ini mengarah pada fakta bahwa hasil perhitungan beberapa ekspresi secara aritmatika salah.  Anda mungkin sudah tahu bahwa di JS nilai ekspresi <code>0.1 + 0.2</code> bukan <code>0.3</code> .  Pada saat yang sama, ketika bekerja dengan bilangan bulat masalah tersebut tidak diamati, yaitu, <code>1 + 2 === 3</code> . <br><br>  JavaScript memiliki objek <code>Number</code> , yang merupakan pembungkus objek untuk nilai numerik.  Objek bertipe <code>Number</code> dapat dibuat baik menggunakan perintah dari form <code>var a = new Number(10)</code> , atau Anda dapat mengandalkan perilaku otomatis sistem yang dijelaskan di atas.  Ini, khususnya, memungkinkan Anda untuk memanggil metode yang disimpan dalam <code>Number.prototype</code> sebagaimana diterapkan pada literal numerik: <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">123</span></span>).toString();  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"123"</span></span> (<span class="hljs-number"><span class="hljs-number">1.23</span></span>).toFixed(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-string"><span class="hljs-string">"1.2"</span></span></code> </pre> <br>  Ada fungsi global yang dirancang untuk mengonversi nilai tipe lain ke tipe numerik.  Ini adalah <code>parseInt()</code> , <code>parseFloat()</code> dan konstruksi <code>Number()</code> , yang dalam kasus ini bertindak sebagai fungsi normal yang melakukan konversi jenis: <br><br><pre> <code class="hljs julia">parseInt(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)       //<span class="hljs-number"><span class="hljs-number">1</span></span> parseInt(<span class="hljs-string"><span class="hljs-string">"text"</span></span>)    //<span class="hljs-literal"><span class="hljs-literal">NaN</span></span> parseFloat(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>) //<span class="hljs-number"><span class="hljs-number">1.234</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1"</span></span>)         //<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-string"><span class="hljs-string">"1.234"</span></span>)     //<span class="hljs-number"><span class="hljs-number">1.234</span></span></code> </pre> <br>  Jika selama operasi dengan angka diperoleh sesuatu yang bukan angka (selama beberapa perhitungan, atau ketika mencoba mengubah sesuatu menjadi angka), JavaScript tidak akan melempar kesalahan, tetapi akan menyajikan hasil operasi seperti itu sebagai nilai <code>NaN</code> (Bukan-a-Number, bukan angka).  Untuk memeriksa apakah nilai tertentu adalah <code>NaN</code> , Anda dapat menggunakan fungsi <code>isNaN()</code> . <br><br>  Operasi aritmatika JS bekerja dengan cara yang cukup akrab, tetapi Anda perlu memperhatikan fakta bahwa operator <code>+</code> dapat melakukan penambahan angka dan rangkaian string. <br><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>      //<span class="hljs-number"><span class="hljs-number">2</span></span> "1" + "1"  //"11" <span class="hljs-number"><span class="hljs-number">1</span></span> + "1"    //"11"</code> </pre> <br><h3>  <font color="#3AC1EF">▍Strings</font> </h3><br>  String JavaScript adalah string karakter Unicode.  Literal string dibuat dengan melampirkan teks yang akan diapit dengan tanda kutip ganda ( <code>""</code> ) atau tunggal ( <code>''</code> ).  Seperti yang telah disebutkan, ketika bekerja dengan string literal, kita dapat mengandalkan pembungkus objek yang sesuai, prototipe yang memiliki banyak metode yang berguna, di antaranya adalah <code>substring()</code> , <code>indexOf()</code> , <code>concat()</code> . <br><br><pre> <code class="hljs pgsql">"text".substring(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>) //ex "text".indexOf(<span class="hljs-string"><span class="hljs-string">'x'</span></span>)   //<span class="hljs-number"><span class="hljs-number">2</span></span> "text".concat(" end") //<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  String, seperti nilai-nilai primitif lainnya, tidak dapat diubah.  Misalnya, metode <code>concat()</code> tidak mengubah string yang ada, tetapi membuat yang baru. <br><br><h3>  <font color="#3AC1EF">▍ Nilai logis</font> </h3><br>  Tipe data logis dalam JS diwakili oleh dua nilai - <code>true</code> dan <code>false</code> .  Bahasa dapat secara otomatis mengonversi berbagai nilai ke tipe data logis.  Jadi, false, selain nilai logis <code>false</code> , adalah nilai <code>null</code> , <code>undefined</code> , <code>''</code> (string kosong), <code>0</code> dan <code>NaN</code> .  Segala sesuatu yang lain, termasuk objek apa pun, mewakili makna yang sebenarnya.  Dalam operasi logis, segala sesuatu yang dianggap benar dikonversi menjadi <code>true</code> , dan segala sesuatu yang dianggap salah dikonversi menjadi <code>false</code> .  Lihatlah contoh berikut.  Sesuai dengan prinsip-prinsip di atas, string kosong akan dikonversi menjadi <code>false</code> dan sebagai hasil dari eksekusi kode ini, string <code>This is false</code> akan sampai ke konsol. <br><br><pre> <code class="hljs pgsql">let <span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-type"><span class="hljs-type">text</span></span>) { console.log("This is true"); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.log("This is false"); }</code> </pre> <br><h2>  <font color="#3AC1EF">Benda-benda</font> </h2><br>  Objek adalah struktur dinamis yang terdiri dari pasangan kunci-nilai.  Nilai dapat memiliki tipe data primitif, bisa berupa objek atau fungsi. <br><br>  Objek paling mudah dibuat menggunakan sintaks literal objek: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">message</span></span> : <span class="hljs-string"><span class="hljs-string">"A message"</span></span>, <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }</code> </pre> <br>  Properti suatu objek dapat dibaca, ditambahkan, diedit, dan dihapus kapan saja.  Inilah cara melakukannya: <br><br><ul><li>  Properti membaca: <code>object.name, object[expression]</code> . </li><li>  Menulis data ke properti (jika properti yang diakses tidak ada, properti baru dengan kunci yang ditentukan ditambahkan): <code>object.name = value</code> , <code>object[expression] = value</code> . </li><li>  Menghapus properti: <code>delete object.name</code> , <code>delete object[expression]</code> . </li></ul><br>  Berikut ini beberapa contohnya: <br><br><pre> <code class="hljs ruby">let obj = {}; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    obj.message = <span class="hljs-string"><span class="hljs-string">"A new message"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   delete object.message; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  </code> </pre> <br>  Objek dalam bahasa diimplementasikan sebagai tabel hash.  Tabel hash sederhana dapat dibuat menggunakan perintah <code>Object.create(null)</code> : <br><br><pre> <code class="hljs pgsql">let french = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); french["yes"] = "oui"; french["no"]  = "non"; french["yes"];//"oui"</code> </pre> <br>  Jika objek harus dibuat tidak berubah, Anda dapat menggunakan perintah <code>Object.freeze()</code> . <br><br>  Untuk beralih ke semua properti objek, Anda dapat menggunakan perintah <code>Object.keys()</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logProperty(<span class="hljs-type"><span class="hljs-type">name</span></span>){ console.log(<span class="hljs-type"><span class="hljs-type">name</span></span>); //  console.log(obj[<span class="hljs-type"><span class="hljs-type">name</span></span>]); //   } <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(obj).<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>(logProperty);</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Perbandingan nilai tipe dan objek primitif</font> </h3><br>  Dalam pekerjaan praktis dengan nilai-nilai primitif, Anda dapat, sebagaimana telah disebutkan, melihatnya sebagai objek yang memiliki properti dan metode, meskipun mereka bukan objek.  Nilai-nilai primitif tidak dapat diubah, struktur internal objek dapat berubah. <br><br><h2>  <font color="#3AC1EF">Variabel</font> </h2><br>  Dalam JavaScript, variabel dapat dideklarasikan menggunakan kata kunci <code>var</code> , <code>let</code> dan <code>const</code> . <br><br>  Menggunakan kata kunci <code>var</code> , Anda dapat mendeklarasikan variabel, dan jika perlu, inisialisasi dengan nilai tertentu.  Jika variabel tidak diinisialisasi, nilainya tidak <code>undefined</code> .  Variabel yang dideklarasikan menggunakan kata kunci <code>var</code> memiliki cakupan fungsional. <br><br>  Kata kunci <code>let</code> sangat mirip dengan <code>var</code> , perbedaannya adalah variabel yang dideklarasikan dengan kata kunci <code>let</code> memiliki ruang lingkup blok. <br><br>  Variabel yang dideklarasikan menggunakan kata kunci <code>const</code> juga memiliki lingkup blok, yang, mengingat fakta bahwa nilai-nilai variabel tersebut tidak dapat diubah, akan lebih tepat disebut "konstanta".  Kata kunci <code>const</code> , yang “membekukan” nilai variabel yang dideklarasikan menggunakannya, dapat dibandingkan dengan metode <code>Object.freeze()</code> , yang “membeku” objek. <br><br>  Jika variabel dinyatakan di luar fungsi, cakupannya adalah global. <br><br><h2>  <font color="#3AC1EF">Array</font> </h2><br>  Array dalam JavaScript diimplementasikan menggunakan objek.  Akibatnya, ketika berbicara tentang array, kami, pada kenyataannya, mendiskusikan objek yang mirip dengan array.  Anda bisa bekerja dengan elemen array menggunakan indeksnya.  Indeks numerik dikonversi ke string dan digunakan sebagai nama untuk mengakses nilai elemen array.  Misalnya, konstruk form <code>arr[1]</code> mirip dengan konstruk form <code>arr['1']</code> , dan keduanya akan memberikan akses ke nilai yang sama: <code>arr[1] === arr['1']</code> .  Sesuai dengan di atas, array sederhana dideklarasikan oleh perintah <code>let arr = ['A', 'B', 'C']</code> diwakili sebagai objek dari bentuk berikut: <br><br><pre> <code class="hljs objectivec">{ <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: <span class="hljs-string"><span class="hljs-string">'C'</span></span> }</code> </pre> <br>  Menghapus elemen array menggunakan perintah <code>delete</code> meninggalkan lubang di dalamnya.  Untuk menghindari masalah ini, Anda dapat menggunakan perintah <code>splice()</code> , tetapi bekerja lambat, karena, setelah menghapus suatu elemen, ia memindahkan elemen-elemen yang tersisa dari array, sebenarnya memindahkannya ke awal array, ke kiri. <br><br><pre> <code class="hljs powershell">let arr = [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>]; delete arr[<span class="hljs-number"><span class="hljs-number">1</span></span>]; console.log(arr); // [<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-type"><span class="hljs-type">empty</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>] console.log(arr.length); // <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre> <br>  Metode array memudahkan untuk menerapkan struktur data seperti tumpukan dan antrian: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  let stack = []; stack.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] stack.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let last = stack.pop();  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] console.log(last);       /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  let queue = []; queue.push(1);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1] queue.push(2);           /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ [1, 2] let first = queue.shift();/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/[2] console.log(first);      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Fungsi</font> </h2><br>  Fungsi dalam JavaScript adalah objek.  Fungsi dapat ditugaskan ke variabel, disimpan dalam objek atau array, diteruskan sebagai argumen ke fungsi lain, dan dikembalikan dari fungsi lainnya. <br><br>  Ada tiga cara untuk mendeklarasikan fungsi: <br><br><ul><li>  Deklarasi fungsi klasik (Deklarasi Fungsi atau Pernyataan Fungsi). </li><li>  Penggunaan ekspresi fungsional (Function Expression), yang juga disebut literal fungsional (Function Literal). </li><li>  Menggunakan sintaks fungsi panah (Arrow Function). </li></ul><br><h3>  <font color="#3AC1EF">▍ Deklarasi fungsi klasik</font> </h3><br>  Dengan pendekatan ini untuk mendeklarasikan fungsi, aturan berikut ini berlaku: <br><br><ul><li>  Kata kunci pertama dalam garis deklarasi <code>function</code> adalah <code>function</code> . </li><li>  Fungsi harus diberi nama. </li><li>  Fungsi dapat digunakan dalam kode sebelum deklarasi karena mekanisme menaikkan deklarasi fungsi ke bagian atas lingkup di mana ia dinyatakan. </li></ul><br>  Berikut ini deklarasi fungsi klasik: <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Ekspresi fungsional</font> </h3><br>  Saat menggunakan ekspresi fungsional, berikut ini harus dipertimbangkan: <br><br><ul><li>  Kata kunci <code>function</code> tidak lagi menjadi kata pertama dalam baris deklarasi fungsi. </li><li>  Nama fungsi adalah opsional.  Dimungkinkan untuk menggunakan ekspresi fungsional anonim dan bernama. </li><li>  Perintah untuk menjalankan fungsi tersebut harus mengikuti perintah untuk deklarasi mereka. </li><li>  Fungsi seperti itu dapat diluncurkan segera setelah deklarasi menggunakan sintaksis IIFE (Ekspresi Fungsi yang Segera Diminta - langsung disebut ekspresi fungsi). </li></ul><br>  Ekspresi fungsional terlihat seperti ini: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Fungsi panah</font> </h3><br>  Fungsi panah, pada kenyataannya, dapat dianggap "gula sintaksis" untuk membuat ekspresi fungsional anonim.  Perlu dicatat bahwa fungsi-fungsi tersebut tidak memiliki entitas <code>this</code> sendiri dan <code>arguments</code> .  Deklarasi fungsi panah terlihat seperti ini: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomething = () = &gt; {};</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Cara untuk memanggil fungsi</font> </h3><br>  Fungsinya dapat dipanggil dengan berbagai cara. <br><br><h4>  Panggilan fungsi normal </h4><br><pre> <code class="hljs lisp">doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Panggilan fungsi dalam bentuk metode objek </h4><br><pre> <code class="hljs markdown">theObject.doSomething(arguments) theObject[<span class="hljs-string"><span class="hljs-string">"doSomething"</span></span>](<span class="hljs-link"><span class="hljs-link">arguments</span></span>)</code> </pre> <br><h4>  Panggilan fungsi konstruktor </h4><br><pre> <code class="hljs lisp">new doSomething(<span class="hljs-name"><span class="hljs-name">arguments</span></span>)</code> </pre> <br><h4>  Memanggil fungsi menggunakan metode apply () </h4><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.apply</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[arguments]</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">doSomething</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.call</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">theObject</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">arguments</span></span>)</code> </pre> <br><h4>  Memanggil fungsi menggunakan metode bind () </h4><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> doSomethingWithObject = doSomething.bind(theObject); doSomethingWithObject();</code> </pre> <br>  Fungsi dapat dipanggil dengan argumen lebih atau lebih sedikit daripada jumlah parameter yang ditentukan saat dideklarasikan.  Selama fungsi berfungsi, argumen "ekstra" akan diabaikan begitu saja (meskipun fungsi akan memiliki akses ke sana), parameter yang hilang akan mendapatkan nilai yang <code>undefined</code> . <br><br>  Fungsinya memiliki dua parameter semu: <code>this</code> dan <code>arguments</code> . <br><br><h3>  <font color="#3AC1EF">▍ Kata kunci ini</font> </h3><br>  Kata <code>this</code> mewakili konteks suatu fungsi.  Nilai yang ditunjukkan tergantung pada bagaimana fungsi dipanggil.  Berikut adalah arti dari kata kunci <code>this</code> tergantung pada bagaimana fungsinya dipanggil (dijelaskan di atas dengan contoh kode, konstruksi yang digunakan di sini): <br><br><ul><li>  Panggilan fungsi yang biasa adalah <code>window</code> / <code>undefined</code> . </li><li>  Panggilan fungsi dalam bentuk metode objek adalah <code>theObject</code> . </li><li>  Panggilan fungsi dalam bentuk konstruktor adalah objek baru. </li><li>  Memanggil fungsi menggunakan metode <code>apply()</code> - <code>theObject</code> . </li><li>  Memanggil fungsi menggunakan metode <code>bind()</code> - <code>theObject</code> . </li></ul><br><h3>  <font color="#3AC1EF">▍ Argumen kata kunci</font> </h3><br>  Kata kunci <code>arguments</code> adalah pseudo-parameter yang memberikan akses ke semua argumen yang digunakan untuk memanggil fungsi.  Itu terlihat seperti sebuah array, tetapi bukan sebuah array.  Secara khusus, ia tidak memiliki metode array. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reduceToSum(total, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> sum(){ let args = <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>.prototype.<span class="hljs-keyword"><span class="hljs-keyword">slice</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(arguments); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); } sum(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br>  Alternatif kata kunci <code>arguments</code> adalah sintaks baru untuk parameter yang tersisa.  Dalam contoh berikut, <code>args</code> adalah array yang berisi segala sesuatu yang diteruskan ke fungsi saat dipanggil. <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...args</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> args.reduce(reduceToSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3>  <font color="#3AC1EF">ReturnOperator kembali</font> </h3><br>  Fungsi yang tidak memiliki <code>return</code> pengembalian akan kembali <code>undefined</code> .  Menggunakan kata kunci <code>return</code> , perhatikan bagaimana mekanisme penyisipan titik koma otomatis bekerja.  Misalnya, fungsi berikut tidak akan mengembalikan objek kosong, tetapi nilai yang <code>undefined</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } } getObject()</code> </pre> <br>  Untuk menghindari masalah yang sama, braket keriting pembuka harus ditempatkan pada baris yang sama dengan <code>return</code> : <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Pengetikan dinamis</font> </h2><br>  JavaScript adalah bahasa pengetikan yang dinamis.  Ini berarti bahwa nilai spesifik memiliki tipe, tetapi variabel tidak.  Selama eksekusi program, nilai dari tipe yang berbeda dapat ditulis ke variabel yang sama.  Berikut adalah contoh fungsi yang bekerja dengan nilai dari berbagai jenis: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>){ console.log(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } log(<span class="hljs-number"><span class="hljs-number">1</span></span>); log("text"); log({message : "text"});</code> </pre> <br>  Untuk mengetahui tipe data yang disimpan dalam variabel, Anda dapat menggunakan operator <code>typeof()</code> : <br><br><pre> <code class="hljs lua">let n = <span class="hljs-number"><span class="hljs-number">1</span></span>; typeof(n);   //number let s = <span class="hljs-string"><span class="hljs-string">"text"</span></span>; typeof(s);   //<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> let fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {}; typeof(fn);  //<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Model eksekusi single-threaded</font> </h2><br>  JavaScript runtime adalah single-threaded.  Ini, khususnya, dinyatakan dalam ketidakmungkinan mengeksekusi dua fungsi secara bersamaan (jika Anda tidak memperhitungkan kemungkinan eksekusi kode asinkron, yang tidak kami sentuh di sini).  Runtime memiliki yang disebut Peristiwa Antrian, yang menyimpan daftar tugas yang perlu diproses.  Akibatnya, masalah kunci sumber daya bersama tidak khas untuk skema eksekusi JS tunggal, oleh karena itu, mekanisme kunci tidak diperlukan di sini.  Namun, kode yang termasuk dalam antrian acara harus dijalankan dengan cepat.  Jika Anda kelebihan beban dengan pekerjaan berat, di aplikasi browser, utas utama, halaman aplikasi tidak akan menanggapi tindakan pengguna dan browser akan menawarkan untuk menutup halaman ini. <br><br><h2>  <font color="#3AC1EF">Penanganan pengecualian</font> </h2><br>  JavaScript memiliki mekanisme untuk menangani pengecualian.  Ini bekerja sesuai dengan prinsip yang cukup umum untuk mekanisme seperti itu: kode yang dapat menyebabkan kesalahan dieksekusi menggunakan <code>try/catch</code> konstruk.  Kode itu sendiri ada di blok <code>try</code> , kesalahan diproses di <code>catch</code> . <br><br>  Sangat menarik untuk dicatat bahwa kadang-kadang JavaScript, dalam keadaan darurat, tidak menghasilkan pesan kesalahan.  Hal ini disebabkan oleh fakta bahwa JS tidak melakukan kesalahan hingga adopsi standar ECMAScript 3. <br><br>  Misalnya, dalam fragmen kode berikut, upaya untuk mengubah objek "beku" akan gagal, tetapi pengecualian tidak akan dibuang. <br><br><pre> <code class="hljs pgsql">let obj = <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({}); obj.message = "text";</code> </pre> <br>  Beberapa kesalahan JS "sunyi" muncul dalam mode ketat, Anda dapat mengaktifkannya menggunakan konstruksi <code>"use strict";</code>  . <br><br><h2>  <font color="#3AC1EF">Sistem prototipe</font> </h2><br>  Dasar dari mekanisme JS seperti fungsi konstruktor, perintah <code>Object.create()</code> , kata kunci <code>class</code> , didasarkan pada sistem prototipe. <br>  Perhatikan contoh berikut: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> service = { <span class="hljs-attr"><span class="hljs-attr">doSomething</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> specializedService = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(service); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(specializedService.__proto__ === service); <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br>  Di sini, untuk membuat objek <code>Object.create()</code> , prototipe di antaranya adalah untuk membuat objek <code>service</code> , perintah <code>Object.create()</code> digunakan.  Akibatnya, ternyata metode <code>doSomething()</code> dapat dipanggil dengan mengakses objek specialService.  Selain itu, ini berarti bahwa properti <code>__proto__</code> dari objek <code>__proto__</code> menunjuk ke objek <code>service</code> . <br><br>  Sekarang buat objek serupa menggunakan kata kunci <code>class</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ doSomething(){} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecializedService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ } let specializedService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>(); console.log(specializedService.__proto__ === <span class="hljs-type"><span class="hljs-type">SpecializedService</span></span>.prototype);</code> </pre> <br>  Metode yang dideklarasikan di kelas <code>Service</code> akan ditambahkan ke objek <code>Service.prototype</code> .  Contoh kelas <code>Service</code> akan memiliki prototipe yang sama ( <code>Service.prototype</code> ).  Semua contoh akan mendelegasikan panggilan metode ke objek <code>Service.prototype</code> .  Akibatnya, ternyata metode hanya dideklarasikan sekali saja, di <code>Service.prototype</code> , setelah itu mereka "diwarisi" oleh semua instance kelas. <br><br><h3>  <font color="#3AC1EF">▍ Rantai Prototipe</font> </h3><br>  Objek bisa menjadi "pewaris" objek lain.  Setiap objek memiliki prototipe, metode yang tersedia untuknya.  Jika Anda mencoba mengakses properti yang tidak ada dalam objek itu sendiri, JavaScript akan mulai mencarinya di rantai prototipe.  Proses ini akan berlanjut sampai properti ditemukan, atau sampai pencarian mencapai akhir rantai. <br><br><h2>  <font color="#3AC1EF">Tentang pemrograman fungsional dalam JavaScript</font> </h2><br>  Dalam JavaScript, fungsi adalah objek kelas satu, bahasa mendukung mekanisme penutupan.  Ini membuka jalan untuk menerapkan teknik pemrograman fungsional di JS.  Secara khusus, kita berbicara tentang kemungkinan menggunakan fungsi tingkat tinggi. <br><br>  Penutupan adalah fungsi internal yang memiliki akses ke variabel yang dideklarasikan di dalam fungsi induk, bahkan setelah fungsi induk dijalankan. <br><br>  Fungsi tingkat tinggi adalah fungsi yang dapat mengambil fungsi lain sebagai argumen, mengembalikan fungsi, atau melakukan keduanya. <br><br>  Pemrograman fungsional dalam JS dicakup dalam banyak publikasi.  Jika Anda tertarik, berikut adalah beberapa bahan pada topik ini yang ditujukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk fungsi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komposisi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dekorator</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penutup,</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keterbacaan kode kelas satu yang</a> ditulis dalam gaya fungsional. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Kekuatan JavaScript terletak pada kesederhanaannya.  Memahami mekanisme dasar bahasa memungkinkan pemrogram menggunakan JS untuk lebih efektif menerapkan mekanisme ini dan meletakkan dasar untuk pertumbuhan profesionalnya. <br><br>  <b>Pembaca yang budiman!</b>  Menurut Anda, fitur apa yang dimiliki sebagian besar pemula? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416375/">https://habr.com/ru/post/id416375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416363/index.html">Taobao resmi dibuka di Rusia</a></li>
<li><a href="../id416365/index.html">Koleksi keinginan dan pemungutan suara untuk fitur-fitur baru dari browser Vivaldi</a></li>
<li><a href="../id416367/index.html">Kami memulai ReactOS dengan BTRFS dari bagian ini</a></li>
<li><a href="../id416369/index.html">Hampir rumit. Bagian 2, menciptakan "rumah pintar" nirkabel. Berbasis pada teknologi Linux, perangkat lunak Z-Wave dan MajorDoMo</a></li>
<li><a href="../id416371/index.html">Lampu berkemah analog</a></li>
<li><a href="../id416377/index.html">Kami menjadi ahli dalam pemrograman. Bagian 1</a></li>
<li><a href="../id416379/index.html">Neurobugurt. Bagaimana kami mengajar jaringan saraf untuk menciptakan meme setahun lebih awal dari Stanford</a></li>
<li><a href="../id416381/index.html">Laporan Club of Rome 2018, Bab 3.13: Filantropi, Investasi, Crowdsourcing, dan Blockchain</a></li>
<li><a href="../id416385/index.html">Jika korelasinya keluar 100%, maka suatu kesalahan telah merayap di suatu tempat: pengalaman magang di Rambler Group</a></li>
<li><a href="../id416391/index.html">Optimalisasi penempatan mesin virtual di server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>