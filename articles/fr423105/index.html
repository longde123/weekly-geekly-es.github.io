<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßôüèæ üï∫üèΩ üó®Ô∏è System.IO.Pipelines: E / S hautes performances dans .NET üïù üòâ ‚òéÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="System.IO.Pipelines est une nouvelle biblioth√®que qui simplifie l'organisation du code dans .NET. Il est difficile d'assurer des performances et une p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>System.IO.Pipelines: E / S hautes performances dans .NET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423105/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">System.IO.Pipelines</a> est une nouvelle biblioth√®que qui simplifie l'organisation du code dans .NET.  Il est difficile d'assurer des performances et une pr√©cision √©lev√©es si vous devez g√©rer un code complexe.  La t√¢che de System.IO.Pipelines est de simplifier le code.  Plus de d√©tails sous la coupe! <br><br><img src="https://habrastorage.org/webt/nq/me/p-/nqmep-tqvyyv5nlkpcxjnmlw8z4.jpeg"><a name="habracut"></a><br><br>  La biblioth√®que est n√©e des efforts de l'√©quipe de d√©veloppement .NET Core pour faire de Kestrel l'un des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">serveurs Web les plus rapides de l'industrie</a> .  Il a √©t√© initialement con√ßu dans le cadre de l'impl√©mentation de Kestrel, mais est devenu une API r√©utilisable, disponible dans la version 2.1 en tant qu'API BCL de premi√®re classe (System.IO.Pipelines). <br><br><h2>  Quels probl√®mes r√©sout-elle? </h2><br>  Pour analyser correctement les donn√©es d'un flux ou d'une socket, vous devez √©crire une grande quantit√© de code standard.  En m√™me temps, de nombreux pi√®ges compliquent le code lui-m√™me et son support. <br><br><h2>  Quelles difficult√©s surgissent aujourd'hui? </h2><br>  Commen√ßons par une t√¢che simple.  Nous devons √©crire un serveur TCP qui re√ßoit des messages s√©par√©s par des lignes (\ n) du client. <br><br><h2>  Serveur TCP avec NetworkStream </h2><br>  D√âVIATION: comme dans toute t√¢che n√©cessitant des performances √©lev√©es, chaque cas sp√©cifique doit √™tre consid√©r√© en fonction des caract√©ristiques de votre application.  Il peut ne pas √™tre judicieux de consacrer des ressources √† l'utilisation de diverses approches, qui seront discut√©es plus loin, si l'√©chelle de l'application r√©seau n'est pas tr√®s grande. <br><br>  Le code .NET normal avant d'utiliser des pipelines ressemble √† ceci: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, buffer.Length); <span class="hljs-comment"><span class="hljs-comment">// Process a single line from the buffer ProcessLine(buffer); }</span></span></code> </pre> <br>  voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sample1.cs</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> <br><br>  Ce code fonctionnera probablement avec les tests locaux, mais il contient un certain nombre d'erreurs: <br><br><ul><li>  Peut-√™tre qu'apr√®s un seul appel √† ReadAsync, le message entier ne sera pas re√ßu (jusqu'√† la fin de la ligne). </li><li>  Il ignore le r√©sultat de la m√©thode stream.ReadAsync () - la quantit√© de donn√©es r√©ellement transf√©r√©es vers le tampon. </li><li>  Le code ne g√®re pas la r√©ception de plusieurs lignes dans un seul appel ReadAsync. </li></ul><br>  Ce sont les erreurs de lecture des donn√©es de streaming les plus courantes.  Pour les √©viter, vous devez effectuer un certain nombre de modifications: <br><br><ul><li>  Vous devez mettre en m√©moire tampon les donn√©es entrantes jusqu'√† ce qu'une nouvelle ligne soit trouv√©e. </li><li>  Il est n√©cessaire d'analyser toutes les lignes renvoy√©es dans le tampon. </li></ul><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesRead = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> stream.ReadAsync(buffer, bytesBuffered, buffer.Length - bytesBuffered); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bytesRead == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; var linePosition = -1; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sample2.cs</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> <br><br>  Je le r√©p√®te: cela pourrait fonctionner avec des tests locaux, mais parfois il y a des cha√Ænes de plus de 1 Ko (1024 octets).  Il est n√©cessaire d'augmenter la taille du tampon d'entr√©e jusqu'√† ce qu'une nouvelle ligne soit trouv√©e. <br><br>  De plus, nous collectons des tampons dans un tableau lors du traitement de longues cha√Ænes.  Nous pouvons am√©liorer ce processus avec ArrayPool, qui √©vite la r√©allocation des tampons lors de l'analyse des longues lignes du client. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesBuffered = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer var bytesRemaining = buffer.Length - bytesBuffered; if (bytesRemaining == 0) { // Double the buffer size and copy the previously buffered data into the new buffer var newBuffer = ArrayPool&lt;byte&gt;.Shared.Rent(buffer.Length * 2); Buffer.BlockCopy(buffer, 0, newBuffer, 0, buffer.Length); // Return the old buffer to the pool ArrayPool&lt;byte&gt;.Shared.Return(buffer); buffer = newBuffer; bytesRemaining = buffer.Length - bytesBuffered; } var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, bytesRemaining); if (bytesRead == 0) { // EOF break; } // Keep track of the amount of buffered bytes bytesBuffered += bytesRead; do { // Look for a EOL in the buffered data linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed); if (linePosition &gt;= 0) { // Calculate the length of the line based on the offset var lineLength = linePosition - bytesConsumed; // Process the line ProcessLine(buffer, bytesConsumed, lineLength); // Move the bytesConsumed to skip past the line we consumed (including \n) bytesConsumed += lineLength + 1; } } while (linePosition &gt;= 0); } }</span></span></code> </pre> <br>  <i>voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sample3.cs</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a></i> <br><br>  Le code fonctionne, mais maintenant la taille du tampon a chang√©, en cons√©quence, de nombreuses copies en apparaissent.  Plus de m√©moire est √©galement utilis√©e, car la logique ne r√©duit pas le tampon apr√®s le traitement des lignes.  Pour √©viter cela, vous pouvez enregistrer la liste des tampons, plut√¥t que de modifier la taille du tampon chaque fois qu'une cha√Æne arrive plus longtemps que 1 Ko. <br><br>  De plus, nous n'augmentons pas la taille de la m√©moire tampon de 1 Ko, jusqu'√† ce qu'elle soit compl√®tement vide.  Cela signifie que nous transf√©rerons des tampons de plus en plus petits vers ReadAsync, par cons√©quent, le nombre d'appels au syst√®me d'exploitation augmentera. <br><br>  Nous essaierons d'√©liminer cela et allouerons un nouveau tampon d√®s que la taille de l'existant deviendra inf√©rieure √† 512 octets: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BufferSegment</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] Buffer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Remaining =&gt; Buffer.Length - Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NetworkStream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segments = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;BufferSegment&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumed = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bytesConsumedBufferIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferSegment { Buffer = ArrayPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;.Shared.Rent(<span class="hljs-number"><span class="hljs-number">1024</span></span>) }; segments.Add(segment); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Calculate the amount of bytes remaining in the buffer if (segment.Remaining &lt; minimumBufferSize) { // Allocate a new segment segment = new BufferSegment { Buffer = ArrayPool&lt;byte&gt;.Shared.Rent(1024) }; segments.Add(segment); } var bytesRead = await stream.ReadAsync(segment.Buffer, segment.Count, segment.Remaining); if (bytesRead == 0) { break; } // Keep track of the amount of buffered bytes segment.Count += bytesRead; while (true) { // Look for a EOL in the list of segments var (segmentIndex, segmentOffset) = IndexOf(segments, (byte)'\n', bytesConsumedBufferIndex, bytesConsumed); if (segmentIndex &gt;= 0) { // Process the line ProcessLine(segments, segmentIndex, segmentOffset); bytesConsumedBufferIndex = segmentOffset; bytesConsumed = segmentOffset + 1; } else { break; } } // Drop fully consumed segments from the list so we don't look at them again for (var i = bytesConsumedBufferIndex; i &gt;= 0; --i) { var consumedSegment = segments[i]; // Return all segments unless this is the current segment if (consumedSegment != segment) { ArrayPool&lt;byte&gt;.Shared.Return(consumedSegment.Buffer); segments.RemoveAt(i); } } } } (int segmentIndex, int segmentOffest) IndexOf(List&lt;BufferSegment&gt; segments, byte value, int startBufferIndex, int startSegmentOffset) { var first = true; for (var i = startBufferIndex; i &lt; segments.Count; ++i) { var segment = segments[i]; // Start from the correct offset var offset = first ? startSegmentOffset : 0; var index = Array.IndexOf(segment.Buffer, value, offset, segment.Count - offset); if (index &gt;= 0) { // Return the buffer index and the index within that segment where EOL was found return (i, index); } first = false; } return (-1, -1); }</span></span></code> </pre> <br>  <i>voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sample4.cs</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a></i> <br><br>  En cons√©quence, le code est consid√©rablement compliqu√©.  Lors de la recherche du d√©limiteur, nous suivons les tampons remplis.  Pour ce faire, utilisez une liste, qui affiche des donn√©es en m√©moire tampon lors de la recherche d'un nouveau s√©parateur de ligne.  Par cons√©quent, ProcessLine et IndexOf accepteront List au lieu de byte [], offset et count.  La logique d'analyse commencera √† traiter un segment du tampon ou plusieurs. <br><br>  Et maintenant, le serveur traitera les messages partiels et utilisera la m√©moire partag√©e pour r√©duire la consommation globale de m√©moire.  Cependant, un certain nombre de modifications doivent √™tre apport√©es: <br><br><ol><li>  Depuis ArrayPoolbyte, nous n'utilisons que Byte [] - des tableaux g√©r√©s de mani√®re standard.  En d'autres termes, lorsque les fonctions ReadAsync ou WriteAsync sont ex√©cut√©es, la p√©riode de validit√© des tampons est li√©e √† l'heure de l'op√©ration asynchrone (pour interagir avec les propres API d'E / S du syst√®me d'exploitation).  √âtant donn√© que la m√©moire √©pingl√©e ne peut pas √™tre d√©plac√©e, cela affecte les performances du garbage collector et peut provoquer une fragmentation de la baie.  Vous devrez peut-√™tre modifier l'impl√©mentation du pool, en fonction de la dur√©e d'attente des op√©rations asynchrones. </li><li>  Le d√©bit peut √™tre am√©lior√© en rompant le lien entre la lecture et la logique du processus.  Nous obtenons l'effet du traitement par lots, et maintenant la logique d'analyse sera capable de lire de grandes quantit√©s de donn√©es, en traitant de gros blocs de tampons, plut√¥t que d'analyser des lignes individuelles.  En cons√©quence, le code devient encore plus compliqu√©: <br><br><ul><li>  Il est n√©cessaire de cr√©er deux cycles qui fonctionnent ind√©pendamment l'un de l'autre.  Le premier lira les donn√©es du socket et le second analysera les tampons. </li><li>  Ce qu'il faut, c'est un moyen de dire √† la logique d'analyse que les donn√©es deviennent disponibles. </li><li>  Il est √©galement n√©cessaire de d√©terminer ce qui se passe si la boucle lit les donn√©es du socket trop rapidement.  Nous avons besoin d'un moyen d'ajuster le cycle de lecture si la logique d'analyse ne le suit pas.  Ceci est commun√©ment appel√© ¬´contr√¥le de flux¬ª ou ¬´r√©sistance √† l'√©coulement¬ª. </li><li>  Nous devons nous assurer que les donn√©es sont transmises en toute s√©curit√©.  Maintenant, l'ensemble de tampons est utilis√© √† la fois par le cycle de lecture et le cycle d'analyse; ils fonctionnent ind√©pendamment les uns des autres sur diff√©rents threads. </li><li>  La logique de gestion de la m√©moire est √©galement impliqu√©e dans deux √©l√©ments de code diff√©rents: l'emprunt de donn√©es du pool de tampons, qui lit les donn√©es du socket, et le retour du pool de tampons, qui est la logique d'analyse. </li><li>  Il faut √™tre extr√™mement prudent avec le retour de tampons apr√®s avoir ex√©cut√© la logique d'analyse.  Sinon, il est possible que nous retournions le tampon dans lequel la logique de lecture du socket est toujours en cours d'√©criture. </li></ul></li></ol><br>  La complexit√© commence √† passer par le toit (et c'est loin d'√™tre le cas!).  Pour cr√©er un r√©seau hautes performances, vous devez √©crire du code tr√®s complexe. <br><br>  Le but de System.IO.Pipelines est de simplifier cette proc√©dure. <br><br><h4>  Serveur TCP et System.IO.Pipelines </h4><br>  Voyons comment fonctionne System.IO.Pipelines: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessLinesAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipe = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipe(); Task writing = FillPipeAsync(socket, pipe.Writer); Task reading = ReadPipeAsync(pipe.Reader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.WhenAll(reading, writing); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FillPipeAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket socket, PipeWriter writer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> minimumBufferSize = <span class="hljs-number"><span class="hljs-number">512</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Allocate at least 512 bytes from the PipeWriter Memory&lt;byte&gt; memory = writer.GetMemory(minimumBufferSize); try { int bytesRead = await socket.ReceiveAsync(memory, SocketFlags.None); if (bytesRead == 0) { break; } // Tell the PipeWriter how much was read from the Socket writer.Advance(bytesRead); } catch (Exception ex) { LogError(ex); break; } // Make the data available to the PipeReader FlushResult result = await writer.FlushAsync(); if (result.IsCompleted) { break; } } // Tell the PipeReader that there's no more data coming writer.Complete(); } async Task ReadPipeAsync(PipeReader reader) { while (true) { ReadResult result = await reader.ReadAsync(); ReadOnlySequence&lt;byte&gt; buffer = result.Buffer; SequencePosition? position = null; do { // Look for a EOL in the buffer position = buffer.PositionOf((byte)'\n'); if (position != null) { // Process the line ProcessLine(buffer.Slice(0, position.Value)); // Skip the line + the \n character (basically position) buffer = buffer.Slice(buffer.GetPosition(1, position.Value)); } } while (position != null); // Tell the PipeReader how much of the buffer we have consumed reader.AdvanceTo(buffer.Start, buffer.End); // Stop reading if there's no more data coming if (result.IsCompleted) { break; } } // Mark the PipeReader as complete reader.Complete(); }</span></span></code> </pre> <br>  <i>voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sample5.cs</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a></i> <br><br>  La version en pipeline de notre lecteur de ligne a deux boucles: <br><br><ul><li>  FillPipeAsync lit √† partir du socket et √©crit dans PipeWriter. </li><li>  ReadPipeAsync lit √† partir de PipeReader et analyse les lignes entrantes. </li></ul><br>  Contrairement aux premiers exemples, il n'y a pas de tampons sp√©cialement affect√©s.  C'est l'une des principales fonctions de System.IO.Pipelines.  Toutes les t√¢ches de gestion des tampons sont transf√©r√©es vers les impl√©mentations PipeReader / PipeWriter. <br><br>  La proc√©dure est simplifi√©e: nous utilisons le code uniquement pour la logique m√©tier, au lieu d'impl√©menter une gestion complexe des tampons. <br><br>  Dans la premi√®re boucle, PipeWriter.GetMemory (int) est d'abord appel√© pour obtenir une certaine quantit√© de m√©moire du r√©dacteur principal.  Puis PipeWriter.Advance (int) est appel√©, ce qui indique √† PipeWriter combien de donn√©es sont r√©ellement √©crites dans le tampon.  Ceci est suivi d'un appel √† PipeWriter.FlushAsync () afin que PipeReader puisse acc√©der aux donn√©es. <br><br>  La deuxi√®me boucle consomme les tampons qui ont √©t√© √©crits par PipeWriter mais re√ßus √† l'origine du socket.  Lorsque la demande √† PipeReader.ReadAsync () est renvoy√©e, nous obtenons un ReadResult contenant deux messages importants: les donn√©es lues sous la forme ReadOnlySequence, ainsi que le type de donn√©es logique IsCompleted, qui indique au lecteur si l'√©crivain a fini de travailler (EOF).  Lorsque le terminateur de ligne (EOL) est trouv√© et que la cha√Æne est analys√©e, nous diviserons le tampon en parties pour ignorer le fragment qui a d√©j√† √©t√© trait√©.  Apr√®s cela, PipeReader.AdvanceTo est appel√© et indique √† PipeReader combien de donn√©es ont √©t√© consomm√©es. <br><br>  √Ä la fin de chaque cycle, le lecteur et l'√©crivain sont termin√©s.  Par cons√©quent, le canal principal lib√®re toute la m√©moire allou√©e. <br><br><h2>  System.io.pipelines </h2><br><h4>  Lecture partielle </h4><br>  En plus de g√©rer la m√©moire, System.IO.Pipelines remplit une autre fonction importante: il analyse les donn√©es dans le canal, mais ne les consomme pas. <br><br>  PipeReader poss√®de deux API principales: ReadAsync et AdvanceTo.  ReadAsync re√ßoit des donn√©es du canal, AdvanceTo indique √† PipeReader que ces tampons ne sont plus requis par le lecteur, vous pouvez donc vous en d√©barrasser (par exemple, les renvoyer dans le pool de tampons principal). <br><br>  Voici un exemple d'un analyseur HTTP qui lit les donn√©es des tampons de donn√©es de canal partiels jusqu'√† ce qu'il re√ßoive une ligne de d√©part appropri√©e. <br><br><img src="https://habrastorage.org/webt/9c/lp/d8/9clpd8h1r6b1m1jrwultkuggw6i.png"><br><br><h2>  ReadOnlySequenceT </h2><br>  L'impl√©mentation de canal stocke une liste de tampons associ√©s transmis entre PipeWriter et PipeReader.  PipeReader.ReadAsync expose ReadOnlySequence, qui est un nouveau type de BCL et se compose d'un ou plusieurs segments ReadOnlyMemory &lt;T&gt;.  Il est similaire √† Span ou Memory, ce qui nous donne la possibilit√© de regarder des tableaux et des cha√Ænes. <br><br><img src="https://habrastorage.org/webt/79/y0/kw/79y0kwylohggq941soblji6qd2o.png"><br><br>  √Ä l'int√©rieur du canal, il existe des pointeurs qui indiquent o√π se trouvent le lecteur et l'√©crivain dans l'ensemble g√©n√©ral de donn√©es en surbrillance, et les mettent √©galement √† jour au fur et √† mesure que les donn√©es sont √©crites et lues.  SequencePosition est un point unique dans une liste li√©e de tampons et est utilis√© pour s√©parer efficacement ReadOnlySequence &lt;T&gt;. <br><br>  √âtant donn√© que ReadOnlySequence &lt;T&gt; prend en charge un ou plusieurs segments, le fonctionnement standard de la logique hautes performances consiste √† s√©parer les chemins rapides et lents en fonction du nombre de segments. <br><br>  √Ä titre d'exemple, voici une fonction qui convertit ASCII ReadOnlySequence en une cha√Æne: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAsciiString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReadOnlySequence&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; buffer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.IsSingleSegment) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Encoding.ASCII.GetString(buffer.First.Span); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Create((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)buffer.Length, buffer, (span, sequence) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> segment <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sequence) { Encoding.ASCII.GetChars(segment.Span, span); span = span.Slice(segment.Length); } }); }</code> </pre> <br>  voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sample6.cs</a> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> <br><br><h4>  R√©sistance √† l'√©coulement et contr√¥le du d√©bit </h4><br>  Id√©alement, la lecture et l'analyse fonctionnent ensemble: le flux de lecture consomme les donn√©es du r√©seau et les place dans des tampons, tandis que le flux d'analyse cr√©e des structures de donn√©es appropri√©es.  L'analyse prend g√©n√©ralement plus de temps que la simple copie de blocs de donn√©es √† partir du r√©seau.  Par cons√©quent, le flux de lecture peut facilement surcharger le flux d'analyse.  Par cons√©quent, le flux de lecture sera oblig√© de ralentir ou de consommer plus de m√©moire pour enregistrer les donn√©es pour le flux d'analyse.  Pour garantir des performances optimales, un √©quilibre est n√©cessaire entre la fr√©quence de pause et l'allocation d'une grande quantit√© de m√©moire. <br><br>  Pour r√©soudre ce probl√®me, le pipeline a deux fonctions de contr√¥le de flux de donn√©es: PauseWriterThreshold et ResumeWriterThreshold.  PauseWriterThreshold d√©termine la quantit√© de donn√©es qui doit √™tre mise en m√©moire tampon avant que PipeWriter.FlushAsync ne soit suspendu.  ResumeWriterThreshold d√©termine la quantit√© de m√©moire que le lecteur peut consommer avant que l'enregistreur ne reprenne ses op√©rations. <br><br><img src="https://habrastorage.org/webt/qf/yj/5u/qfyj5u6aahkadlp8nk1gtc9bqr4.png"><br><br>  PipeWriter.FlushAsync ¬´se verrouille¬ª lorsque la quantit√© de donn√©es dans le flux en pipeline d√©passe la limite d√©finie dans PauseWriterThreshold et ¬´d√©verrouille¬ª lorsqu'elle tombe en dessous de la limite d√©finie dans ResumeWriterThreshold.  Pour √©viter de d√©passer la limite de consommation, seules deux valeurs sont utilis√©es. <br><br><h4>  Planification des E / S </h4><br>  Lorsque vous utilisez async / wait, les op√©rations suivantes sont g√©n√©ralement appel√©es dans les threads de pool ou dans le SynchronizationContext en cours. <br><br>  Lors de l'ex√©cution d'E / S, il est tr√®s important de surveiller attentivement o√π il est ex√©cut√© afin de mieux utiliser le cache du processeur.  Ceci est essentiel pour les applications hautes performances telles que les serveurs Web.  System.IO.Pipelines utilise le PipeScheduler pour d√©terminer o√π ex√©cuter les rappels asynchrones.  Cela vous permet de contr√¥ler tr√®s pr√©cis√©ment les flux √† utiliser pour les E / S. <br><br>  Un exemple d'application pratique est le transport Kestrel Libuv, dans lequel les rappels d'E / S sont effectu√©s sur des canaux d√©di√©s de la boucle d'√©v√©nements. <br><br><h2>  Le mod√®le PipeReader pr√©sente d'autres avantages. </h2><br><ul><li>  Certains syst√®mes de base prennent en charge ¬´attendre sans mise en m√©moire tampon¬ª: vous n'avez pas besoin d'allouer de m√©moire tampon jusqu'√† ce que les donn√©es disponibles apparaissent dans le syst√®me de base.  Donc, sur Linux avec epoll, vous ne pouvez pas fournir de tampon de lecture tant que les donn√©es ne sont pas pr√™tes.  Cela √©vite la situation lorsque de nombreux threads attendent des donn√©es et que vous devez imm√©diatement r√©server une √©norme quantit√© de m√©moire. </li><li>  Le pipeline par d√©faut facilite l'√©criture de tests unitaires de code r√©seau: la logique d'analyse est distincte du code r√©seau, et les tests unitaires ex√©cutent uniquement cette logique dans des tampons en m√©moire, plut√¥t que de la consommer directement √† partir du r√©seau.  Il permet √©galement de tester facilement des mod√®les complexes en envoyant des donn√©es partielles.  ASP.NET Core l'utilise pour tester divers aspects des outils d'analyse http de Kestrel. </li><li>  Les syst√®mes qui permettent au code utilisateur d'utiliser les principaux tampons du syst√®me d'exploitation (par exemple, les API d'E / S Windows enregistr√©es) conviennent initialement √† l'utilisation de pipelines car l'impl√©mentation PipeReader fournit toujours des tampons. </li></ul><br><h4>  Autres types connexes </h4><br>  Nous avons √©galement ajout√© un certain nombre de nouveaux types BCL simples √† System.IO.Pipelines: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MemoryPoolT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IMemoryOwnerT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MemoryManagerT</a> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ArrayPoolT a</a> √©t√© ajout√© dans .NET Core 1.0, et dans .NET Core 2.1, il existe d√©sormais une repr√©sentation abstraite plus g√©n√©rale pour un pool qui fonctionne avec n'importe quel MemoryT.  Nous obtenons un point d'extensibilit√© qui nous permet de mettre en ≈ìuvre des strat√©gies de distribution plus avanc√©es, ainsi que de contr√¥ler la gestion des tampons (par exemple, utiliser des tampons pr√©d√©finis au lieu de tableaux exclusivement g√©r√©s). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBufferWriterT</a> est un r√©cepteur pour l'enregistrement de donn√©es tamponn√©es synchronis√©es (impl√©ment√© par PipeWriter). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IValueTaskSource</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ValueTaskT</a> existe depuis la sortie de .NET Core 1.1, mais dans .NET Core 2.1, il a acquis des outils extr√™mement efficaces qui fournissent des op√©rations asynchrones ininterrompues sans distribution.  Voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici pour</a> plus d'informations. </li></ul><br><h2>  Comment utiliser les convoyeurs? </h2><br>  Les API se trouvent dans le package nuget <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">System.IO.Pipelines</a> . <br><br>  Pour un exemple d'application serveur .NET Server 2.1 qui utilise des pipelines pour traiter les messages en minuscules (de l'exemple ci-dessus), voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Il peut √™tre d√©marr√© en utilisant dotnet run (ou Visual Studio).  Dans l'exemple, les donn√©es devraient √™tre transmises √† partir du socket sur le port 8087, puis les messages re√ßus sont √©crits sur la console.  Vous pouvez utiliser un client, tel que netcat ou putty, pour vous connecter au port 8087.  Envoyez un message en minuscules et voyez comment cela fonctionne. <br><br>  Actuellement, le pipeline fonctionne sur Kestrel et SignalR, et nous esp√©rons qu'il trouvera √† l'avenir une application plus large dans de nombreuses biblioth√®ques r√©seau et composants de la communaut√© .NET. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr423105/">https://habr.com/ru/post/fr423105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr423093/index.html">Nous augmentons le caract√®re al√©atoire du fait que [probablement] [presque] par accident</a></li>
<li><a href="../fr423095/index.html">Nouveaut√©s d'Apple Presentation</a></li>
<li><a href="../fr423097/index.html">T√¢ches et solutions pour PostgreSQL Fighter</a></li>
<li><a href="../fr423101/index.html">D√©ploiement du stockage LINSTOR pour Proxmox</a></li>
<li><a href="../fr423103/index.html">Podcasts Python: c'est tout ce que nous avons trouv√©</a></li>
<li><a href="../fr423107/index.html">Nous vous invitons √† la r√©union Go in Production</a></li>
<li><a href="../fr423109/index.html">Ce qu'Apple a pr√©sent√© et ce qu'en pensent les d√©veloppeurs iOS</a></li>
<li><a href="../fr423115/index.html">Effets am√©lior√©s avec le mode de fusion des couches d'arri√®re-plan CSS</a></li>
<li><a href="../fr423117/index.html">Vivre plus longtemps ou vieillir plus lentement: une approche technologique de la vieillesse</a></li>
<li><a href="../fr423119/index.html">Machine d'arcade DIY TTL ... en 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>