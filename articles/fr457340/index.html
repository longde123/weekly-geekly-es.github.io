<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲🏼 🐻 👎🏿 10 plugins PostCSS qui vous feront gagner du temps de mise en page 🐜 🤗 😺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous, le front-end, avons une catégorie d'outils qui ne résolvent pas les problèmes auxquels nous sommes confrontés, mais affectent plutôt le processu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 plugins PostCSS qui vous feront gagner du temps de mise en page</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457340/"><p><img src="https://habrastorage.org/webt/1b/7_/el/1b7_elrk3cworvip4qutltld9to.jpeg"></p><br><p>  Nous, le front-end, avons une catégorie d'outils qui ne résolvent pas les problèmes auxquels nous sommes confrontés, mais affectent plutôt le processus de leur résolution.  Changez-le.  L'attitude envers de tels outils est très différente - à partir de la manie dans l'esprit de «poussons cette chose partout, c'est tellement cool» et se terminant par des excuses comme «si cela ne résout pas le problème commercial, alors nous n'en avons pas besoin».  Mais, de toute façon, nous parlerons aujourd'hui de PostCSS - l'un de ces outils. </p><br><p>  La vague de battage médiatique est depuis longtemps passée; ces dernières années, très peu de choses ont été dites sur PostCSS.  Beaucoup de débutants ne savent même pas ce que c'est.  Je pense qu'il est temps de regarder cet outil du point de vue de son utilisation pratique dans les projets les plus ordinaires, où les gens résolvent des problèmes, plutôt que de jouer avec des technologies à la mode. </p><a name="habracut"></a><br><h2 id="postcss-vs-sass">  PostCSS vs SASS </h2><br><p> Oh ... Apparemment, quelques mots à ce sujet.  Je pense que maintenant un typographe rare n'a pas rencontré de préprocesseurs.  SASS ou mon LESS préféré, moins souvent Stylus, sont utilisés à la fois sur les grands projets et sur les petits.  Quelqu'un essaie d'en tirer le meilleur parti, quelqu'un utilise un ensemble minimaliste - imbrication, variables, importations.  Mais, d'une manière ou d'une autre, ces outils aident à résoudre les problèmes de syntaxe.  Ils nous facilitent l'écriture de code. </p><br><p>  Il y a environ deux ou trois ans, PostCSS était constamment comparé aux préprocesseurs.  Et c'est compréhensible.  Formellement, en l'utilisant, vous pouvez faire la même chose, créer une sorte de syntaxe qui sera plus pratique qu'un CSS pur.  Mais tout cela a provoqué une masse bouillonnante, principalement parce que tout le monde avec l'aide de PostCSS a fait quelque chose de différent.  D'innombrables plugins inconnus, des millions de combinaisons, et à part l'auteur de telle ou telle configuration, personne n'a compris comment cela fonctionne et ce qu'il fait.  C'est comme Vim ou Emacs - vous pouvez en faire un vaisseau spatial, mais il sera très difficile d'enseigner à un autre développeur comment l'utiliser. </p><br><p>  Mais si nous rejetons ces comparaisons, PostCSS est un outil qui nous permet de prendre notre CSS et de faire quelque chose avec.  Personne ne prend la peine d'utiliser SASS pour des raisons de syntaxe, et après l'assemblage, collez PostCSS et faites quelque chose avec le résultat.  Ils ne se contredisent pas. </p><br><h2 id="staroe--ne-znachit-nerabotayuschee">  Vieux ne veut pas dire inactif </h2><br><p>  Récemment, il a été à la mode pour nous de créer des moissonneuses-batteuses capables de faire tout ce qui vient à l'esprit, et leur développement ne s'arrête jamais.  Et s'il n'y a pas de nouveaux commits dans le référentiel pendant quelques mois, alors tout - nous pouvons supposer qu'il est obsolète et l'utiliser maintenant - pas comme il faut.  Je vais exagérer, bien sûr, mais je pense que vous avez vous-même remarqué à quel point cela peut parfois arriver. </p><br><p>  Dans le monde PostCSS, généralement un plugin résout un problème.  Vous pouvez voir des éléments de la philosophie Unix ici.  Une conclusion logique en découle - si le plug-in résout déjà son problème, il n'y a plus rien à faire avec.  Vous pouvez trouver des plugins qui n'ont pas été mis à jour depuis des années, mais cela ne signifie pas qu'ils ont soudainement cessé de résoudre les tâches pour lesquelles ils ont été créés. </p><br><p>  Mais commençons ... J'ai rassemblé une douzaine de plug-ins qui, dans la pratique, ont montré leur capacité à simplifier la vie des concepteurs de mise en page et à gagner du temps lors du développement.  Mais vous pouvez toujours ajouter quelque chose dans les commentaires. </p><br><h2 id="1-doiuse">  N ° 1.  Doiuse </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/anandthakker/doiuse</a> </p><br><p>  Je pense que nous avons tous été confrontés à ce problème: vous écrivez le code, vérifiez dans le chrome - tout va bien.  Vous vous enregistrez en FF - env.  Et puis, dans Safari mobile, tout s'écroule.  Ou dans Edge.  Et vous vous asseyez et ne comprenez pas ce qui ne va pas.  Ensuite, vous regardez le code pendant longtemps, buvez du thé, et tout à coup, il apparaît que certaines propriétés ne sont pas prises en charge dans certains navigateurs.  Vous allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">caniuse</a> et vous voyez la confirmation de l'évidence. </p><br><p><img src="https://habrastorage.org/webt/pm/dy/lw/pmdylwl6g5ahftjlsoikrqyckec.png"></p><br><p>  Bien sûr, avec l'expérience, les mains elles-mêmes se souviennent des propriétés à éviter, mais tout se passe.  Vous ne pouvez pas dormir suffisamment, les délais et les nerfs peuvent être serrés, la liste des navigateurs à changer peut changer.  Et puis l'expérience commencera à échouer.  Doiuse est un outil qui aide beaucoup dans de telles situations. </p><br><p>  Le principe de fonctionnement est simple - nous lui fournissons une liste de navigateurs et notre CSS.  Le plugin va à la base de données caniuse et nous donne en temps réel la réponse que nous avons utilisée à partir de ce qui n'est pas supporté. </p><br><p>  Nous pouvons définir la liste des navigateurs directement dans package.json.  Simple et pratique.  PostCSS utilise une liste de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">navigateurs</a> et, si vous ne l'avez pas encore vue, elle ressemble à ceci: </p><br><pre><code class="plaintext hljs">"browserslist": [ "&gt; .5% and last 2 versions", "not dead", "not OperaMini all", "ie &gt;= 11", "Edge &gt;= 12" ]</code> </pre> <br><p>  Il existe également une configuration de doiuse elle-même, dans laquelle vous pouvez l'obliger à ignorer certains groupes de propriétés si vous êtes sûr qu'elle n'affecte rien.  Par exemple, si vous utilisez des polyfichiers ou suite à la perte de prise en charge d'une propriété, rien ne changera: </p><br><pre> <code class="plaintext hljs">ignore: [ 'will-change', 'object-fit' ]</code> </pre> <br><p>  Le journal standard fourni par le plugin n'est pas très lisible.  Il contient beaucoup d'informations et il n'est pas très pratique de le percevoir.  Mais c'est réparable.  Dans la même configuration, nous pouvons faire notre fonction pour créer un journal. </p><br><blockquote>  Utilisez console.log pour comprendre comment fonctionne l'objet qui transmet PostCSS à cette fonction.  Il y a beaucoup de choses intéressantes. </blockquote><p>  Ma pratique a montré que l'option la plus pratique consiste à afficher les sélecteurs et les propriétés spécifiques qui ne sont pas pris en charge, sans spécifier de navigateurs et de lignes de code.  Si le projet utilise BEM ou certains analogues et que le code du composant est distribué dans des fichiers séparés, cette approche vous permet de trouver rapidement un endroit problématique sans charger le cerveau. </p><br><pre> <code class="javascript hljs">onFeatureUsage(info) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selector = info.usage.parent.selector; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> property = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.prop}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${info.usage.value}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> status = info.featureData.caniuseData.status.toUpperCase(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.missing) { status = <span class="hljs-string"><span class="hljs-string">'NOT SUPPORTED'</span></span>.red; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info.featureData.partial) { status = <span class="hljs-string"><span class="hljs-string">'PARTIAL SUPPORT'</span></span>.yellow; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`\n</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${status}</span></span></span><span class="hljs-string">:\n\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${selector}</span></span></span><span class="hljs-string"> {\n </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${property}</span></span></span><span class="hljs-string">;\n }\n`</span></span>); }</code> </pre> <br><p>  Afin de ne pas écrire de séquences spéciales de caractères pour les couleurs dans la console, vous pouvez connecter le package de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">couleurs</a> , il sera plus pratique avec lui. </p><br><p>  Lors de la construction, il y aura quelque chose comme ça dans la console: </p><br><pre> <code class="plaintext hljs">NOT SUPPORTED: html { -ms-text-size-adjust: 100%; } NOT SUPPORTED: html { -webkit-text-size-adjust: 100%; } PARTIAL SUPPORT: body { display: flex; }</code> </pre> <br><h2 id="2-autoprefixer">  N ° 2.  Autoprefixer </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/postcss/autoprefixer</a> </p><br><p>  C'est même embarrassant de parler de lui, mais trop souvent je vois des gens qui en 2019 écrivent des préfixes avec leurs mains et assurent toujours aux autres qu'ils savent exactement lesquels sont nécessaires et lesquels ne le sont pas.  De telles actions conduisent au fait que le code est envahi par un tas de préfixes inutiles et devient complètement illisible.  Cela affecte la productivité du travail.  D'un autre côté, si vous avez besoin du soutien de dinosaures, vous pouvez toujours oublier quelque chose.  Il vaut donc mieux se débarrasser du travail manuel pour résoudre ce problème. </p><br><p>  L'autopréfixeur fonctionne avec la même base de données caniuse, utilise la même liste de navigateurs et peut ajouter au CSS les préfixes qui sont vraiment nécessaires dans les navigateurs que nous avons spécifiés.  En même temps, le code lui-même devient plus propre et le travail va plus vite. </p><br><h2 id="3-stylelint">  Numéro 3.  Stylelint </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/stylelint/stylelint</a> </p><br><p>  Lorsque vous imprimez beaucoup et rapidement, tôt ou tard, vous commencez à faire de nombreuses erreurs sans les remarquer complètement.  L'œil est flou.  Dans le cas de CSS, cela peut donner un effet amusant (en fait pas) lorsque vous regardez dans le navigateur - vous voyez un problème de mise en page.  Vous regardez le code - il n'est pas là.  Vous regardez dans le navigateur - ça l'est.  Mais dans le code - non.  En conséquence, vous pouvez rechercher un problème difficile pendant une longue période, sans vous rendre compte que vous venez juste de faire le tour.  Pour éviter cela, inventé linter. </p><br><p>  Stylelint est une option populaire.  Il sait travailler avec la syntaxe des principaux préprocesseurs, il connaît les dernières tendances en CSS, il peut le personnaliser à son goût - les configs sont similaires à celles d'eslint.  Formellement, cet outil peut être utilisé seul, sans PostCSS, mais ne pas le mentionner ici serait faux. </p><br><h2 id="4-postcss-flexbugs-fixes">  Numéro 4.  Postcss-flexbugs-fixes </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/luisrudge/postcss-flexbugs-fixes</a> </p><br><p>  Ou dans un sens plus large, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">postcss-fixes</a> , qui inclut ce plugin.  Lentement, mais sûrement, les flexions supplantent l'ancienne approche de la disposition sur les flotteurs.  C'est bien, mais nous savons tous qu'un tas de bugs leur sont associés.  Ils sont décrits dans le référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">flexbugs</a> .  Certains d'entre eux nécessitent une attention particulière, mais il y en a aussi quelques-uns qui sont si simples qu'ils sortent constamment de votre tête.  Par exemple, IE ignore la fonction calc dans la sténographie de la propriété flex.  Ce n'est pas si souvent nécessaire, mais si nécessaire, alors vos mains peuvent écrire une version abrégée et ensuite vous devez réfléchir longtemps au problème.  Heureusement, cela peut être corrigé automatiquement.  Le plugin postcss-flexbugs-fixes vient à la rescousse. </p><br><p>  Dans l'exemple de calc, il trouvera des fragments comme celui-ci dans le code: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw – 1px); }</code> </pre> <br><p>  Et déployez-les: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">flex-grow</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-shrink</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">flex-basis</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">calc</span></span>(1vw - 1px); }</code> </pre> <br><p>  Simple et pratique. </p><br><h2 id="5-postcss-preset-env">  N ° 5.  Postcss-preset-env </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/csstools/postcss-preset-env</a> </p><br><p>  Puisque nous parlons de la prise en charge du navigateur, il ne sera pas hors de propos de parler de postcss-preset-env.  Auparavant, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cssnext</a> jouait le même rôle.  Ce plugin sera utile si vous êtes intéressé par les nouvelles tendances CSS. </p><br><p><img src="https://habrastorage.org/webt/bu/kp/4h/bukp4htn6ewwkk4qznb8phjxzoa.jpeg"></p><br><p>  De nombreuses innovations peuvent être mises en œuvre techniquement en utilisant les anciennes méthodes, elles seront simplement longues, prolixes et laides.  Preset-env vous aide à écrire du code d'une nouvelle manière, à gagner du temps à ce sujet, puis à le convertir en une ancienne version fiable.  Bien sûr, certaines choses comme les propriétés personnalisées ne sont pas du tout implémentées dans les navigateurs plus anciens, donc les solutions de secours y seront utilisées. </p><br><p>  Comme vous pouvez le deviner d'après le nom de l'instrument, il ressemble au même nom prédéfini chez Babel.  Ici, tout est pareil - il existe de nombreux convertisseurs assemblés en un seul ensemble stable.  Certaines transformations nécessitent une connexion ultérieure de scripts polyphiles sur le client, mais la plupart sont implémentées uniquement par CSS.  Pour autant que je comprends, pour les scripts Stage2 + ne sont pas nécessaires.  En tout cas, je n'ai pas rencontré leur besoin.  Corrigez-moi si j'ai raté quelque chose là-bas. </p><br><h2 id="6-postcss-animation">  N ° 6.  Postcss-animation </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/zhouwenbin/postcss-animation</a> </p><br><p>  Souvent, j'entends de différentes personnes (principalement des backends qui ne sont pas très forts en CSS) qu'ils veulent utiliser des animations distinctes d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">animate.css</a> , mais considèrent que c'est une mauvaise idée de connecter toute la bibliothèque.  C'est tout à fait logique.  Mais en conséquence, ils passent beaucoup de temps à essayer de répéter ces animations par eux-mêmes. </p><br><p><img src="https://habrastorage.org/webt/hy/tw/wp/hytwwpkrfzjzsktmomybo51bea0.jpeg"></p><br><p>  Le plugin postcss-animation accélère considérablement ce processus.  Nous écrivons uniquement le nom de l'animation, par exemple: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; }</code> </pre> <br><p>  Et il récupère l'implémentation depuis animate.css et l'insère dans le code. </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-name</span></span>: bounce; } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> bounce { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span>, 20%, 53%, 80%, <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.215, 0.610, 0.355, 1.000); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,0,0); } 40%, 43% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -30px, 0); } 70% { <span class="hljs-attribute"><span class="hljs-attribute">animation-timing-function</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">cubic-bezier</span></span>(0.755, 0.050, 0.855, 0.060); <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0, -15px, 0); } 90% { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translate3d</span></span>(0,-4px,0); } }</code> </pre> <br><h2 id="7-list-selectors">  Numéro 7.  Sélecteurs de liste </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/davidtheclark/list-selectors</a> </p><br><p>  Lorsque vous avez plusieurs typographes et de nombreux styles, la question se pose de la révision du code, qu'il serait bien de voir parfois avec vos yeux la vue d'ensemble avec tous les sélecteurs que nous avons.  Sachez quels ID sont utilisés, s'il existe des sélecteurs de balises ou si la méthodologie acceptée est bien suivie.  Cela est particulièrement important lorsque vous vérifiez le code du débutant, qui peut écrire des choses étranges qui fonctionneront officiellement, mais qui vont en fait à l'encontre des accords acceptés (loin de partout, ces accords sont bien fixés et il est possible d'automatiser de telles choses).  Faites défiler vous-même de nombreuses feuilles de style pour vérifier l'adéquation des sélecteurs pendant longtemps.  Nous avons besoin d'un moyen de les isoler et de les montrer séparément.  Les sélecteurs de liste ne font que résoudre ce problème. </p><br><p>  Tout comme doiuse, ce plugin vous permet d'utiliser sa fonction pour préparer les informations à afficher.  Vous pouvez afficher uniquement ce qui vous intéresse ou tout peindre de différentes couleurs.  A titre d'exemple: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'list-selectors'</span></span>).plugin(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> inspect = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'util'</span></span>).inspect; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'SELECTORS:'</span></span>.blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.selectors, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).blue); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'IDS:'</span></span>.red); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inspect(list.simpleSelectors.ids, { <span class="hljs-attr"><span class="hljs-attr">maxArrayLength</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }).red); })</code> </pre> <br><p>  Cet exemple produit une longue, longue liste de sélecteurs: </p><br><pre> <code class="plaintext hljs">SELECTORS: [ '.mui-progress-bar', '.mui-progress-bar &gt; .indicator', '.mui-progress-bar &gt; .value', '.mui-progress-bar.-radial', '.mui-progress-bar.-radial &gt; .indicator', '.mui-progress-bar.-radial &gt; .indicator &gt; .background', '.mui-progress-bar.-radial &gt; .indicator &gt; .progress', '.mui-progress-bar.-radial &gt; .value', . . .</code> </pre> <br><h2 id="8-immutable-css">  Numéro 8.  Immutable-CSS </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/johno/immutable-css</a> </p><br><p>  Une autre chose à surveiller est l'interruption des styles des bibliothèques tierces.  Si nous avons connecté une sorte de bibliothèque, puis que nous commençons à en écrire nos propres styles pour les sélecteurs, nous obtenons finalement un code déroutant dans lequel nous ne pouvons pas déterminer ce qui est venu.  Cela peut conduire à des bugs aléatoires, qui prennent alors trop de temps à l'improviste.  Plus nous redéfinissons quelque chose, plus il est difficile de comprendre ce qui se passe, même si le problème lui-même qui doit être résolu peut être très simple.  Dans cette situation, un outil appelé immutable-css peut être utile. </p><br><p>  En général, le principe de son travail est simple: il prend des fichiers avec des styles, s'il trouve des correspondances sur des sélecteurs, il commence à s'indigner: </p><br><pre> <code class="plaintext hljs">! .button was mutated 2 times [line 93, col 1]: /css/basscss.css [line 3, col 1]: /css/custom.css [immutable-css] ! .left was mutated 2 times [line 291, col 1]: /css/basscss.css [line 4, col 1]: /css/custom.css [immutable-css]</code> </pre> <br><p>  Le seul problème avec cet outil est qu'il ne prend pas en charge la syntaxe non CSS.  Donc, si des préprocesseurs sont utilisés dans le projet, les fichiers déjà assemblés doivent être comparés.  Mais en général, si la tâche consiste simplement à s'assurer que personne ne réécrit accidentellement les styles d'une bibliothèque tierce, ce n'est pas si important. </p><br><h2 id="9-bye-bye">  N ° 9.  Au revoir! </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/AoDev/css-byebye</a> </p><br><p>  Je pense que tout le monde connaît la situation lorsque nous ajoutons progressivement des composants à un site de travail.  Certains d'entre eux vont immédiatement à la production, et certains restent longtemps assis et attendent leur tour (par exemple, nous nous sommes réconciliés, nous n'avons pas encore fini le backend).  Quelque chose peut être une expérience ou une solution temporaire pour les vacances.  Il peut y avoir de nombreuses situations, mais elles sont unies par le fait que nous avons un tas de composants, et seule une petite partie d'entre eux sont utilisés sur le site de combat.  Ce serait bien de supprimer tout ce qui n'est pas utilisé de l'assemblage actuel.  Cela peut réduire considérablement sa taille, ainsi que réduire les maux de tête à l'avenir, quand il sera nécessaire de faire une refonte par exemple, et la question sera de savoir ce qui doit vraiment être réécrit maintenant et ce qui ne l'est pas. </p><br><p><img src="https://habrastorage.org/webt/l5/rl/e5/l5rle5k5yldudgr5rvtz7hotjom.gif"></p><br><p>  Il existe différentes approches à ce problème.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Uncss</a> vient immédiatement à l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">esprit</a> .  Cet outil détecte automatiquement les styles utilisés sur les pages et supprime les styles inutiles.  Mais dans la pratique, cela conduit presque toujours au fait que personne ne sait ce qui est réellement utilisé et ce qui ne l'est pas.  Je doute aussi tout le temps que cet outil ait supprimé quelque chose de superflu.  Mais c'est probablement ma paranoïa.  Bien que ... </p><br><p>  Bye-bye est un outil plus simple que nous alimentons nous-mêmes une liste de sélecteurs à supprimer de CSS.  Et vous pouvez utiliser des expressions régulières.  Si vous utilisez BEM ou quelque chose d'autre comme ça, alors avec un simple régulier, vous pouvez supprimer un bloc avec tout ce qui s'y rapporte.  Au revoir! </p><br><p>  Cette approche s'est avérée assez pratique.  Il est immédiatement clair quels styles ne sont pas encore utilisés ou ont été supprimés car inutiles, alors que toutes les sources sont en place, tous les paramètres dans un fichier, rien n'est perdu, cela ne cause pas de difficultés pour faire plusieurs assemblages différents, et surtout, la solution est simple et prévisible. </p><br><h2 id="10-postcss-trolling">  N ° 10.  Postcss-trolling </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/juanfran/postcss-trolling</a> </p><br><p>  Tous les outils précédents peuvent augmenter légèrement la productivité de vos concepteurs de mise en page, mais celui-ci donne des résultats tout simplement phénoménaux.  Je le recommande vivement. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  PostCSS est une bonne aide pour un concepteur de mise en page.  S'ils ne sont pas maltraités, bien sûr.  Pour de nombreux problèmes chronophages, il existe des solutions toutes faites sous la forme de plug-ins, et bien qu'ils ne se développent souvent pas et semblent abandonnés, cela n'interfère pas avec leur utilisation. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457340/">https://habr.com/ru/post/fr457340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457330/index.html">Comment vérifier rapidement les avertissements intéressants donnés par l'analyseur PVS-Studio pour le code C et C ++?</a></li>
<li><a href="../fr457332/index.html">Comment voir rapidement les avertissements intéressants générés par l'analyseur PVS-Studio pour le code C et C ++?</a></li>
<li><a href="../fr457334/index.html">TacacsGUI, Configuration Manager</a></li>
<li><a href="../fr457336/index.html">Les conséquences du retrait prématuré des dents de sagesse</a></li>
<li><a href="../fr457338/index.html">Blitz avec Ilya Krasinsky: comment tirer les mauvaises hypothèses, pourquoi rejeter un produit et comment grandir pour un minimum d'action?</a></li>
<li><a href="../fr457342/index.html">Signes d'en haut: comment nous avons sauvé les cartographes du travail inutile et des yeux rouges</a></li>
<li><a href="../fr457348/index.html">Déploiement sur PythonAnywhere depuis GitHub</a></li>
<li><a href="../fr457350/index.html">Pourquoi l'oscilloscope a-t-il besoin d'un support de cryptographie?</a></li>
<li><a href="../fr457352/index.html">Conclusion des informations sur l'affichage de l'acheteur</a></li>
<li><a href="../fr457354/index.html">Obfuscation des données pour les tests de performances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>