<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏘️ 🍄 👨🏿‍🤝‍👨🏽 Frontend-Test 👨🏿‍🚒 💱 🧒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine effektive Strategie für automatisierte Codetests ist äußerst wichtig, um die schnelle und qualitativ hochwertige Arbeit von Teams von Programmier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Frontend-Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477278/">  Eine effektive Strategie für automatisierte Codetests ist äußerst wichtig, um die schnelle und qualitativ hochwertige Arbeit von Teams von Programmierern zu gewährleisten, die an der Unterstützung und Entwicklung von Webprojekten beteiligt sind.  Der Autor des Artikels sagt, dass in der Firma <a href="https://www.stackpath.com/">StackPath</a> , in der er arbeitet, jetzt alles <a href="https://www.stackpath.com/">gut</a> mit dem Testen funktioniert.  Sie haben viele Tools zum Überprüfen von Code.  Aus einer solchen Vielfalt muss man aber jeweils das auswählen, was am besten geeignet ist.  Dies ist ein separates Problem.  Und nachdem die erforderlichen Werkzeuge ausgewählt wurden, müssen Sie noch eine Entscheidung über die Reihenfolge ihrer Verwendung treffen. <br> <a href="https://habr.com/ru/company/ruvds/blog/477278/"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/f09/0a3/1bdf090a307b28098ab0758186db9d2c.svg" alt="Bild"></a> <br>  Der Autor des Artikels gibt an, dass StackPath mit dem Vertrauen in die Qualität des Codes zufrieden ist, das dank des angewendeten Testsystems erreicht wurde.  Hier möchte er eine Beschreibung der vom Unternehmen entwickelten Testprinzipien teilen und über die verwendeten Tools sprechen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Testprinzipien</font> </h2><br>  Bevor wir über bestimmte Tools sprechen, sollten wir über die Antwort auf die Frage nachdenken, was gute Tests sind.  Bevor wir mit der Arbeit an unserem <a href="https://control.stackpath.com/">Portal</a> für Kunden beginnen, haben wir die Grundsätze formuliert und niedergeschrieben, die wir bei der Erstellung von Tests befolgen möchten.  Was wir in erster Linie getan haben, hat uns bei der Auswahl der Werkzeuge geholfen. <br><br>  Hier sind die vier Prinzipien in Frage. <br><br><h3>  <font color="#3AC1EF">▍ Prinzip Nummer 1.</font>  <font color="#3AC1EF">Tests sind als Optimierungsaufgaben zu verstehen</font> </h3><br>  Eine effektive Teststrategie besteht darin, das Problem der Maximierung eines bestimmten Werts (in diesem Fall des Vertrauens, dass die Anwendung ordnungsgemäß funktioniert) und der Minimierung bestimmter Kosten zu lösen (hier werden die "Kosten" durch die für die Unterstützung und Ausführung der Tests erforderliche Zeit dargestellt).  Beim Schreiben von Tests stellen wir häufig die folgenden Fragen in Bezug auf das oben beschriebene Prinzip: <br><br><ul><li>  Wie hoch ist die Wahrscheinlichkeit, dass bei diesem Test ein Fehler auftritt? </li><li>  Verbessert dieser Test unser Testsystem und sind die Kosten für die zum Schreiben erforderlichen Ressourcen den daraus resultierenden Nutzen wert? </li><li>  Ist es möglich, dasselbe Maß an Vertrauen in die zu testende Entität zu erlangen, das dieser Test bietet, indem ein weiterer Test erstellt wird, der einfacher zu schreiben, zu warten und auszuführen ist? </li></ul><br><h3>  <font color="#3AC1EF">▍ Grundsatz Nr. 2.</font>  <font color="#3AC1EF">Ein übermäßiger Gebrauch von Mox sollte vermieden werden.</font> </h3><br>  Eine meiner Lieblingserklärungen zum Konzept von „mok“ fand sich in <a href="http://blog.testdouble.com/talks/2018-03-06-please-dont-mock-me/">dieser</a> Präsentation auf der Konferenz von Assert.js 2018. Der Redner hat die Frage ausführlicher erörtert, als ich sie hier eröffnen werde.  In der Rede wird die Entstehung von Mokas mit dem „Schlagen von Löchern in die Realität“ verglichen.  Und ich denke, dass dies eine sehr visuelle Art ist, Moks wahrzunehmen.  Obwohl es in unseren Tests Mokas gibt, vergleichen wir die Verringerung der „Kosten“ von Tests, die Mokas aufgrund der Vereinfachung des Prozesses des Schreibens und Ausführens von Tests bereitstellt, mit der Verringerung des Werts der Tests, die dazu führen, dass in der Realität ein weiteres Loch gemacht wird. <br><br>  Zuvor verließen sich unsere Programmierer stark auf Komponententests, die so geschrieben wurden, dass alle untergeordneten Abhängigkeiten durch Mokas ersetzt wurden, die die API für die Wiedergabe flacher <a href="https://airbnb.io/enzyme/docs/api/shallow.html">Enzyme verwendeten</a> .  Auf diese Weise gerenderte Entitäten wurden dann mit <a href="https://jestjs.io/docs/en/snapshot-testing">Jest-</a> Snapshots überprüft.  Alle diese Tests wurden nach einem ähnlichen Muster geschrieben: <br><br><pre><code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'renders '</span></span>, () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = shallow();   <span class="hljs-comment"><span class="hljs-comment">//  ,              expect(wrapper).toMatchSnapshot(); });</span></span></code> </pre> <br>  Diese Tests sind an vielen Stellen mit der Realität gefüllt.  Dieser Ansatz macht es sehr einfach, mit Tests eine 100% ige Codeabdeckung zu erzielen.  Wenn Sie solche Tests schreiben, müssen Sie sehr wenig darüber nachdenken, aber wenn Sie nicht alle zahlreichen Integrationspunkte überprüfen, sind solche Tests nicht besonders wertvoll.  Alle Tests können erfolgreich abgeschlossen werden, aber dies gibt nicht viel Vertrauen in die Funktionsfähigkeit der Anwendung.  Und noch schlimmer, alle Mokas haben einen versteckten "Preis", den Sie bezahlen müssen, nachdem die Tests geschrieben wurden. <br><br><h3>  <font color="#3AC1EF">▍ Grundsatz Nr. 3.</font>  <font color="#3AC1EF">Tests sollten das Refactoring von Code erleichtern, nicht erschweren.</font> </h3><br>  Tests wie der oben gezeigte erschweren das Refactoring.  Wenn sich an vielen Stellen im Projekt doppelter Code befindet und ich diesen Code nach einer Weile als separate Komponente formatiere, schlagen alle Tests für die Komponenten, in denen ich diese neue Komponente verwenden werde, fehl.  Komponenten, die mithilfe der Flachrendertechnik abgeleitet wurden, sind bereits etwas anderes.  Wo ich früher Markups wiederholt habe, gibt es jetzt eine neue Komponente. <br><br>  Komplexeres Refactoring, bei dem einige Komponenten zu einem Projekt hinzugefügt und andere entfernt werden, führt zu noch größerer Verwirrung.  Tatsache ist, dass Sie dem System neue Tests hinzufügen und unnötige Tests daraus entfernen müssen.  Die Snapshot-Regeneration ist eine einfache Aufgabe, aber welchen Wert haben solche Tests?  Selbst wenn sie in der Lage sind, einen Fehler zu finden, ist es besser, wenn sie ihn in einer Reihe von Schnappschussänderungen verpassen und einfach neue Schnappschüsse überprüfen, ohne zu viel Zeit darauf zu verwenden. <br><br>  Infolgedessen helfen solche Tests nicht besonders beim Refactoring.  Im Idealfall sollte kein Test fehlschlagen, wenn ich ein Refactoring durchführe. Danach hat sich nichts geändert, was der Benutzer sieht und mit dem er interagiert.  Und umgekehrt - wenn ich ändere, was der Benutzer kontaktiert, sollte mindestens ein Test fehlschlagen.  Wenn Tests diesen beiden Regeln folgen, sind sie ein hervorragendes Werkzeug, um sicherzustellen, dass sich etwas, auf das Benutzer stoßen, während des Refactorings nicht ändert. <br><br><h3>  <font color="#3AC1EF">▍ Grundsatz Nr. 4.</font>  <font color="#3AC1EF">Tests sollten nachvollziehen, wie echte Benutzer mit der Anwendung arbeiten</font> </h3><br>  Ich möchte, dass die Tests nur dann fehlschlagen, wenn sich etwas geändert hat, mit dem der Benutzer interagiert.  Das bedeutet, dass Tests mit der Anwendung genauso funktionieren sollten, wie Benutzer damit arbeiten.  Beispielsweise muss ein Test wirklich mit Formularelementen interagieren und wie ein Benutzer Text in Texteingabefelder eingeben.  Tests sollten nicht auf Komponenten zugreifen und Methoden ihres Lebenszyklus unabhängig aufrufen, sollten nichts in den Status von Komponenten schreiben oder etwas tun, das von den Feinheiten der Komponentenimplementierung abhängt.  Da ich letztendlich den Teil des Systems überprüfen möchte, der mit dem Benutzer in Kontakt steht, ist es logisch, sicherzustellen, dass die Tests bei der Interaktion mit dem System die Aktionen der tatsächlichen Benutzer so genau wie möglich reproduzieren. <br><br><h2>  <font color="#3AC1EF">Werkzeuge testen</font> </h2><br>  Nachdem wir die Ziele definiert haben, die wir erreichen möchten, wollen wir uns darüber unterhalten, welche Tools wir dafür ausgewählt haben. <br><br><h3>  <font color="#3AC1EF">▍TypeScript</font> </h3><br>  Unsere Codebasis verwendet TypeScript.  Unsere Backend-Services sind in Go geschrieben und interagieren mithilfe von gRPC miteinander.  Dies ermöglicht es uns, typisierte gRPC-Clients für die Verwendung auf einem GraphQL-Server zu generieren.  GraphQL-Server-Resolver werden mit Typen getippt, die mit dem <a href="https://github.com/dotansimha/graphql-code-generator">graphql-Code-Generator</a> generiert wurden.  Und schließlich sind unsere Abfragen, Mutationen sowie Abonnementkomponenten und Hooks vollständig typisiert.  Die vollständige Abdeckung unserer Codebasis mit Typen beseitigt eine ganze Klasse von Fehlern, die dadurch verursacht werden, dass das Datenformular nicht den Erwartungen des Programmierers entspricht.  Die Generierung von Typen aus den Schema- und Protobuf-Dateien stellt sicher, dass unser gesamtes System in allen Teilen des verwendeten Technologiestapels homogen bleibt. <br><br><h3>  <font color="#3AC1EF">▍Jest (Unit-Test)</font> </h3><br>  Als Framework zum Testen von Code verwenden wir <a href="https://jestjs.io/">Jest</a> und <a href="https://testing-library.com/docs/react-testing-library/intro">@ testing-library / react</a> .  In Tests, die mit diesen Tools erstellt wurden, testen wir Funktionen oder Komponenten isoliert vom Rest des Systems.  Normalerweise testen wir Funktionen und Komponenten, die am häufigsten in einer Anwendung verwendet werden, oder solche, die viele Möglichkeiten haben, Code auszuführen.  Solche Pfade sind während der Integration oder der End-to-End-Tests (E2E) nur schwer zu überprüfen. <br><br>  Unit Tests sind für uns ein Mittel, um Kleinteile zu testen.  Integrations- und End-to-End-Tests ermöglichen eine hervorragende Überprüfung des Systems in größerem Maßstab, sodass Sie den Gesamtzustand der Anwendung überprüfen können.  Aber manchmal müssen Sie sicherstellen, dass die kleinen Details funktionieren, und das Schreiben von Integrationstests für alle möglichen Verwendungen des Codes ist zu teuer. <br><br>  Beispielsweise müssen wir überprüfen, ob die Tastaturnavigation in der Komponente funktioniert, die für die Arbeit mit der Dropdown-Liste verantwortlich ist.  Gleichzeitig möchten wir aber nicht alle möglichen Varianten eines solchen Verhaltens beim Testen der gesamten Anwendung überprüfen.  Aus diesem Grund testen wir die Navigation einzeln gründlich und achten beim Testen von Seiten mit der entsprechenden Komponente nur auf die Überprüfung von Interaktionen auf höherer Ebene. <br><br><h2>  <font color="#3AC1EF">Werkzeuge testen</font> </h2><br><h3>  <font color="#3AC1EF">▍Cypress (Integrationstests)</font> </h3><br>  Mit <a href="https://www.cypress.io/">Cypress</a> erstellte Integrationstests bilden den Kern unseres Testsystems.  Als wir mit der Erstellung des StackPath-Portals begannen, waren dies die ersten Tests, die wir geschrieben haben, da sie mit sehr geringem Aufwand für ihre Erstellung äußerst wertvoll sind.  Cypress zeigt unsere gesamte Anwendung in einem Browser an und führt Testskripte aus.  Unser gesamtes Frontend funktioniert genauso, wie Benutzer damit arbeiten.  Richtig, die Netzwerkschicht des Systems wird durch Mokami ersetzt.  Jede Netzwerkabfrage, die normalerweise an den GraphQL-Server gesendet wird, gibt bedingte Daten an die Anwendung zurück. <br><br>  Die Verwendung von Mocks zur Simulation der Netzwerkschicht einer Anwendung hat viele Stärken: <br><br><ul><li>  Tests sind schneller.  Selbst wenn das Projekt-Backend extrem schnell ist, kann die Zeit, die erforderlich ist, um Antworten auf Anforderungen, die während der gesamten Testsuite gestellt wurden, zurückzugeben, beträchtlich sein.  Und wenn Moki für die Rückgabe von Antworten verantwortlich ist, werden die Antworten sofort zurückgegeben. </li><li>  Tests werden zuverlässiger.  Eine der Schwierigkeiten beim Durchführen eines vollständigen End-to-End-Tests eines Projekts besteht darin, dass der variable Status der Netzwerk- und Serverdaten berücksichtigt werden muss, der sich ändern kann.  Wenn mit Moxas ein echter Netzwerkzugriff simuliert wird, verschwindet diese Variabilität. </li><li>  Es ist einfach, Situationen zu reproduzieren, die die exakte Wiederholung bestimmter Bedingungen erfordern.  In einem realen System ist es beispielsweise schwierig, bestimmte Anforderungen zum Scheitern zu bringen.  Wenn Sie die korrekte Reaktion der Anwendung auf erfolglose Anfragen überprüfen müssen, können Sie mit moki problemlos Notfallsituationen reproduzieren. </li></ul><br>  Obwohl das Ersetzen des gesamten Backends durch mok eine entmutigende Aufgabe ist, werden alle bedingten Daten mit denselben generierten TypeScript-Typen eingegeben, die in der Anwendung verwendet werden.  Das heißt - zumindest diese Daten - entsprechen strukturell garantiert dem, was ein normales Backend zurückgeben würde.  Während der meisten Tests haben wir uns ziemlich friedlich damit abgefunden, Mooks anstelle von echten Serveraufrufen zu verwenden. <br><br>  Darüber hinaus sind Programmierer sehr erfreut, mit Cypress zu arbeiten.  Tests werden im Cypress Test Runner ausgeführt.  Testbeschreibungen werden links angezeigt, und die Testanwendung wird im <code>iframe</code> Hauptelement ausgeführt.  Nachdem Sie den Test gestartet haben, können Sie seine einzelnen Phasen studieren und herausfinden, wie sich die Anwendung zu dem einen oder anderen Zeitpunkt verhalten hat.  Da das Tool zum Ausführen von Tests im Browser selbst ausgeführt wird, können Sie die Tests mit den Browser-Tools des Entwicklers debuggen. <br><br>  Wenn Sie Front-End-Tests schreiben, dauert es oft sehr lange, bis Sie die Ergebnisse des Tests mit dem Status des DOM zu einem bestimmten Zeitpunkt des Tests verglichen haben.  Cypress vereinfacht diese Aufgabe erheblich, da der Entwickler alles sehen kann, was mit der getesteten Anwendung geschieht.  <a href="">Hier ist ein</a> Videoclip, der dies demonstriert. <br><br>  Diese Tests veranschaulichen unsere Testprinzipien perfekt.  Das Verhältnis ihres Wertes zu ihrem "Preis" passt zu uns.  Tests reproduzieren sehr ähnlich die Aktionen des realen Benutzers, der mit der Anwendung interagiert.  Und nur die Netzwerkschicht des Projekts wurde durch Mokami ersetzt. <br><br><h3>  <font color="#3AC1EF">▍Cypress (End-to-End-Test)</font> </h3><br>  Unsere E2E-Tests werden ebenfalls mit Cypress geschrieben. In diesen Tests wird Moki jedoch weder zur Simulation der Netzwerkebene eines Projekts noch zur Simulation anderer Funktionen verwendet.  Bei der Durchführung von Tests greift die Anwendung auf den realen GraphQL-Server zu, der mit realen Instanzen von Backend-Diensten arbeitet. <br><br>  End-to-End-Tests sind für uns äußerst wertvoll.  Tatsache ist, dass es die Ergebnisse solcher Tests sind, die uns wissen lassen, ob etwas wie erwartet funktioniert oder nicht.  Bei solchen Tests werden keine Mocks verwendet. Daher funktioniert die Anwendung genau so, wie sie von echten Clients verwendet wird.  Es ist jedoch zu beachten, dass End-to-End-Tests „teurer“ sind als andere.  Sie sind langsamer und schwieriger zu schreiben, da bei ihrer Implementierung kurzfristige Fehler auftreten können.  Es sind weitere Arbeiten erforderlich, um sicherzustellen, dass das System in einem bekannten Zustand bleibt, bevor die Tests ausgeführt werden. <br><br>  Tests müssen normalerweise zu einem Zeitpunkt ausgeführt werden, an dem sich das System in einem bekannten Zustand befindet.  Nach Abschluss des Tests wechselt das System in einen anderen bekannten Zustand.  Im Fall von Integrationstests ist es nicht schwierig, dieses Verhalten des Systems zu erreichen, da Aufrufe der API durch Mokas ersetzt werden und folglich jeder Test unter vorbestimmten Bedingungen ausgeführt wird, die vom Programmierer gesteuert werden.  Bei E2E-Tests ist dies jedoch bereits schwieriger, da das Server Data Warehouse Informationen enthält, die sich während des Tests ändern können.  Infolgedessen muss der Entwickler einen Weg finden, um sicherzustellen, dass sich das System zu Beginn des Tests in einem zuvor bekannten Zustand befindet. <br><br>  Zu Beginn des End-to-End-Testlaufs führen wir ein Skript aus, das durch direkte Aufrufe der API ein neues Konto mit Stacks, Sites, Workloads, Monitoren und dergleichen erstellt.  Jede Testsitzung impliziert die Verwendung einer neuen Instanz eines solchen Kontos, aber alles andere bleibt von Zeit zu Zeit unverändert.  Nachdem das Skript alle erforderlichen Schritte ausgeführt hat, erstellt es eine Datei mit den Daten, die zum Ausführen der Tests verwendet werden (normalerweise enthält es Informationen zu Instanz-IDs und Domänen).  Infolgedessen stellt sich heraus, dass Sie mit dem Skript das System in einen zuvor bekannten Zustand versetzen können, bevor Sie die Tests ausführen. <br><br>  Da End-to-End-Tests „teurer“ sind als andere Testarten, schreiben wir im Vergleich zu Integrationstests weniger End-to-End-Tests.  Wir bemühen uns sicherzustellen, dass die Tests kritische Anwendungsmerkmale abdecken.  Dies ist beispielsweise das Registrieren von Benutzern und ihrer Anmeldung, das Erstellen und Einrichten einer Site / eines Workloads usw.  Dank umfangreicher Integrationstests wissen wir, dass unser Frontend im Allgemeinen funktionsfähig ist.  End-to-End-Tests sind jedoch nur erforderlich, um sicherzustellen, dass beim Verbinden des Frontends mit dem Backend nichts passiert, was andere Tests nicht erkennen können. <br><br><h2>  <font color="#3AC1EF">Nachteile unserer umfassenden Teststrategie</font> </h2><br>  Obwohl wir mit den Tests und der Stabilität der Anwendung sehr zufrieden sind, hat die Verwendung einer umfassenden Teststrategie wie unserer auch Nachteile. <br><br>  Zunächst einmal bedeutet die Anwendung einer solchen Teststrategie, dass alle Teammitglieder mit vielen Testwerkzeugen vertraut sein sollten und nicht nur mit einem.  Jeder muss Jest, @ testing-library / react und Cypress kennen.  Gleichzeitig müssen Entwickler diese Tools aber nicht nur kennen.  Sie müssen auch in der Lage sein, Entscheidungen darüber zu treffen, in welcher Situation welche eingesetzt werden soll.  Lohnt es sich, eine neue Möglichkeit zum Schreiben eines End-to-End-Tests zu testen, oder reicht der Integrationstest aus?  Müssen Sie zusätzlich zum End-to-End- oder Integrationstest einen Komponententest schreiben, um die kleinen Details der Implementierung dieser neuen Funktion zu überprüfen? <br><br>  Zweifellos „belastet“ dies sozusagen den Kopf unserer Programmierer, während sie das einzige Werkzeug verwenden, das sie nicht so stark belasten würden.  Normalerweise beginnen wir mit Integrationstests. Wenn wir dann feststellen, dass das untersuchte Feature von besonderer Bedeutung ist und stark vom Serverteil des Projekts abhängt, fügen wir den entsprechenden End-to-End-Test hinzu.  Oder wir beginnen mit Unit-Tests, wenn wir glauben, dass ein Unit-Test nicht alle Feinheiten der Implementierung eines bestimmten Mechanismus verifizieren kann. <br><br>  Natürlich sind wir immer noch mit Situationen konfrontiert, in denen nicht klar ist, wo wir anfangen sollen.  Da wir jedoch ständig Entscheidungen in Bezug auf Tests treffen müssen, tauchen bestimmte Muster gemeinsamer Situationen auf.  Beispielsweise testen wir normalerweise Formularvalidierungssysteme mithilfe von Komponententests.  Dies geschieht aufgrund der Tatsache, dass Sie während des Tests viele verschiedene Szenarien überprüfen müssen.  Gleichzeitig weiß jeder im Team davon und verschwendet keine Zeit damit, eine Teststrategie zu planen, wenn einer von ihnen das Formularvalidierungssystem testen muss. <br><br>  Ein weiterer Nachteil des von uns verwendeten Ansatzes ist die Schwierigkeit, Daten zur Codeabdeckung durch Tests zu sammeln.  Obwohl dies möglich ist, ist es viel komplizierter als in einer Situation, in der ein Projekt getestet wird.  Obwohl das Streben nach einer schönen Anzahl von Code-Coverages durch Tests zu einer Verschlechterung der Testqualität führen kann, sind solche Informationen für das Auffinden von „Lücken“ in der verwendeten Testsuite von Nutzen.  Das Problem bei der Verwendung mehrerer Testtools besteht darin, dass Sie Berichte zur Codeabdeckung mit Tests kombinieren müssen, die von verschiedenen Systemen stammen, um zu verstehen, welcher Teil des Codes nicht getestet wurde.  Es ist möglich, aber es ist definitiv viel schwieriger, als einen Bericht zu lesen, der mit einem Testverfahren erstellt wurde. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Beim Einsatz vieler Testwerkzeuge standen wir vor schwierigen Aufgaben.  Aber jedes dieser Werkzeuge erfüllt seinen eigenen Zweck.  Letztendlich glauben wir, dass wir das Richtige getan haben, indem wir sie in unser Code-Testsystem aufgenommen haben.  Integrationstests - Hier sollten Sie am besten zu Beginn der Arbeit an einer neuen Anwendung oder beim Ausrüsten von Tests eines vorhandenen Projekts mit dem Erstellen eines Testsystems beginnen.  Es wird nützlich sein, zu versuchen, dem Projekt so früh wie möglich End-to-End-Tests hinzuzufügen, um die wichtigsten Funktionen des Projekts zu überprüfen. <br><br>  Wenn die Testsuite End-to-End- und Integrationstests enthält, sollte dies dazu führen, dass der Entwickler ein gewisses Maß an Vertrauen in den Zustand der Anwendung erhält, wenn Änderungen daran vorgenommen werden.  Wenn im Verlauf der Projektarbeiten Fehler auftauchen, die von den Tests nicht erkannt werden, ist zu überlegen, welche Tests diese Fehler auffangen könnten und ob das Auftreten von Fehlern auf die Mängel des gesamten im Projekt verwendeten Testsystems hindeutet. <br><br>  Natürlich sind wir nicht sofort zu unserem aktuellen Testsystem gekommen.  Darüber hinaus gehen wir davon aus, dass sich dieses System mit dem Wachstum unseres Projekts weiterentwickeln wird.  Aber jetzt mögen wir unseren Ansatz zum Testen wirklich. <br><br>  <b>Sehr geehrte Leser!</b>  Welche Strategien verfolgen Sie beim Frontend-Testen?  Welche Frontend-Testtools verwenden Sie? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477278/">https://habr.com/ru/post/de477278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477266/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 390 (18.-24. November 2019)</a></li>
<li><a href="../de477268/index.html">Suchlösungsoptimierung auf Github</a></li>
<li><a href="../de477272/index.html">Erste Einführung in AssemblyScript</a></li>
<li><a href="../de477274/index.html">Wie werden Sie nicht verwendeten CSS-Code los? Teil 1</a></li>
<li><a href="../de477276/index.html">Wie werden Sie nicht verwendeten CSS-Code los? Teil 2</a></li>
<li><a href="../de477282/index.html">Profiling Go-Projektcode und Beheben von Speicherzuordnungsproblemen</a></li>
<li><a href="../de477284/index.html">Warum ist JavaScript im strikten Modus erforderlich?</a></li>
<li><a href="../de477286/index.html">Axios oder Fetch: Was im Jahr 2019 verwenden?</a></li>
<li><a href="../de477288/index.html">John Lewis auf der Undoing Aging Conference 2018</a></li>
<li><a href="../de477290/index.html">Digitale Veranstaltungen in Moskau vom 25. November bis 1. Dezember</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>