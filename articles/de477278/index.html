<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ˜ï¸ ğŸ„ ğŸ‘¨ğŸ¿â€ğŸ¤â€ğŸ‘¨ğŸ½ Frontend-Test ğŸ‘¨ğŸ¿â€ğŸš’ ğŸ’± ğŸ§’</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eine effektive Strategie fÃ¼r automatisierte Codetests ist Ã¤uÃŸerst wichtig, um die schnelle und qualitativ hochwertige Arbeit von Teams von Programmier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Frontend-Test</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477278/">  Eine effektive Strategie fÃ¼r automatisierte Codetests ist Ã¤uÃŸerst wichtig, um die schnelle und qualitativ hochwertige Arbeit von Teams von Programmierern zu gewÃ¤hrleisten, die an der UnterstÃ¼tzung und Entwicklung von Webprojekten beteiligt sind.  Der Autor des Artikels sagt, dass in der Firma <a href="https://www.stackpath.com/">StackPath</a> , in der er arbeitet, jetzt alles <a href="https://www.stackpath.com/">gut</a> mit dem Testen funktioniert.  Sie haben viele Tools zum ÃœberprÃ¼fen von Code.  Aus einer solchen Vielfalt muss man aber jeweils das auswÃ¤hlen, was am besten geeignet ist.  Dies ist ein separates Problem.  Und nachdem die erforderlichen Werkzeuge ausgewÃ¤hlt wurden, mÃ¼ssen Sie noch eine Entscheidung Ã¼ber die Reihenfolge ihrer Verwendung treffen. <br> <a href="https://habr.com/ru/company/ruvds/blog/477278/"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/f09/0a3/1bdf090a307b28098ab0758186db9d2c.svg" alt="Bild"></a> <br>  Der Autor des Artikels gibt an, dass StackPath mit dem Vertrauen in die QualitÃ¤t des Codes zufrieden ist, das dank des angewendeten Testsystems erreicht wurde.  Hier mÃ¶chte er eine Beschreibung der vom Unternehmen entwickelten Testprinzipien teilen und Ã¼ber die verwendeten Tools sprechen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Testprinzipien</font> </h2><br>  Bevor wir Ã¼ber bestimmte Tools sprechen, sollten wir Ã¼ber die Antwort auf die Frage nachdenken, was gute Tests sind.  Bevor wir mit der Arbeit an unserem <a href="https://control.stackpath.com/">Portal</a> fÃ¼r Kunden beginnen, haben wir die GrundsÃ¤tze formuliert und niedergeschrieben, die wir bei der Erstellung von Tests befolgen mÃ¶chten.  Was wir in erster Linie getan haben, hat uns bei der Auswahl der Werkzeuge geholfen. <br><br>  Hier sind die vier Prinzipien in Frage. <br><br><h3>  <font color="#3AC1EF">â– Prinzip Nummer 1.</font>  <font color="#3AC1EF">Tests sind als Optimierungsaufgaben zu verstehen</font> </h3><br>  Eine effektive Teststrategie besteht darin, das Problem der Maximierung eines bestimmten Werts (in diesem Fall des Vertrauens, dass die Anwendung ordnungsgemÃ¤ÃŸ funktioniert) und der Minimierung bestimmter Kosten zu lÃ¶sen (hier werden die "Kosten" durch die fÃ¼r die UnterstÃ¼tzung und AusfÃ¼hrung der Tests erforderliche Zeit dargestellt).  Beim Schreiben von Tests stellen wir hÃ¤ufig die folgenden Fragen in Bezug auf das oben beschriebene Prinzip: <br><br><ul><li>  Wie hoch ist die Wahrscheinlichkeit, dass bei diesem Test ein Fehler auftritt? </li><li>  Verbessert dieser Test unser Testsystem und sind die Kosten fÃ¼r die zum Schreiben erforderlichen Ressourcen den daraus resultierenden Nutzen wert? </li><li>  Ist es mÃ¶glich, dasselbe MaÃŸ an Vertrauen in die zu testende EntitÃ¤t zu erlangen, das dieser Test bietet, indem ein weiterer Test erstellt wird, der einfacher zu schreiben, zu warten und auszufÃ¼hren ist? </li></ul><br><h3>  <font color="#3AC1EF">â– Grundsatz Nr. 2.</font>  <font color="#3AC1EF">Ein Ã¼bermÃ¤ÃŸiger Gebrauch von Mox sollte vermieden werden.</font> </h3><br>  Eine meiner LieblingserklÃ¤rungen zum Konzept von â€mokâ€œ fand sich in <a href="http://blog.testdouble.com/talks/2018-03-06-please-dont-mock-me/">dieser</a> PrÃ¤sentation auf der Konferenz von Assert.js 2018. Der Redner hat die Frage ausfÃ¼hrlicher erÃ¶rtert, als ich sie hier erÃ¶ffnen werde.  In der Rede wird die Entstehung von Mokas mit dem â€Schlagen von LÃ¶chern in die RealitÃ¤tâ€œ verglichen.  Und ich denke, dass dies eine sehr visuelle Art ist, Moks wahrzunehmen.  Obwohl es in unseren Tests Mokas gibt, vergleichen wir die Verringerung der â€Kostenâ€œ von Tests, die Mokas aufgrund der Vereinfachung des Prozesses des Schreibens und AusfÃ¼hrens von Tests bereitstellt, mit der Verringerung des Werts der Tests, die dazu fÃ¼hren, dass in der RealitÃ¤t ein weiteres Loch gemacht wird. <br><br>  Zuvor verlieÃŸen sich unsere Programmierer stark auf Komponententests, die so geschrieben wurden, dass alle untergeordneten AbhÃ¤ngigkeiten durch Mokas ersetzt wurden, die die API fÃ¼r die Wiedergabe flacher <a href="https://airbnb.io/enzyme/docs/api/shallow.html">Enzyme verwendeten</a> .  Auf diese Weise gerenderte EntitÃ¤ten wurden dann mit <a href="https://jestjs.io/docs/en/snapshot-testing">Jest-</a> Snapshots Ã¼berprÃ¼ft.  Alle diese Tests wurden nach einem Ã¤hnlichen Muster geschrieben: <br><br><pre><code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">'renders '</span></span>, () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = shallow();   <span class="hljs-comment"><span class="hljs-comment">//  ,              expect(wrapper).toMatchSnapshot(); });</span></span></code> </pre> <br>  Diese Tests sind an vielen Stellen mit der RealitÃ¤t gefÃ¼llt.  Dieser Ansatz macht es sehr einfach, mit Tests eine 100% ige Codeabdeckung zu erzielen.  Wenn Sie solche Tests schreiben, mÃ¼ssen Sie sehr wenig darÃ¼ber nachdenken, aber wenn Sie nicht alle zahlreichen Integrationspunkte Ã¼berprÃ¼fen, sind solche Tests nicht besonders wertvoll.  Alle Tests kÃ¶nnen erfolgreich abgeschlossen werden, aber dies gibt nicht viel Vertrauen in die FunktionsfÃ¤higkeit der Anwendung.  Und noch schlimmer, alle Mokas haben einen versteckten "Preis", den Sie bezahlen mÃ¼ssen, nachdem die Tests geschrieben wurden. <br><br><h3>  <font color="#3AC1EF">â– Grundsatz Nr. 3.</font>  <font color="#3AC1EF">Tests sollten das Refactoring von Code erleichtern, nicht erschweren.</font> </h3><br>  Tests wie der oben gezeigte erschweren das Refactoring.  Wenn sich an vielen Stellen im Projekt doppelter Code befindet und ich diesen Code nach einer Weile als separate Komponente formatiere, schlagen alle Tests fÃ¼r die Komponenten, in denen ich diese neue Komponente verwenden werde, fehl.  Komponenten, die mithilfe der Flachrendertechnik abgeleitet wurden, sind bereits etwas anderes.  Wo ich frÃ¼her Markups wiederholt habe, gibt es jetzt eine neue Komponente. <br><br>  Komplexeres Refactoring, bei dem einige Komponenten zu einem Projekt hinzugefÃ¼gt und andere entfernt werden, fÃ¼hrt zu noch grÃ¶ÃŸerer Verwirrung.  Tatsache ist, dass Sie dem System neue Tests hinzufÃ¼gen und unnÃ¶tige Tests daraus entfernen mÃ¼ssen.  Die Snapshot-Regeneration ist eine einfache Aufgabe, aber welchen Wert haben solche Tests?  Selbst wenn sie in der Lage sind, einen Fehler zu finden, ist es besser, wenn sie ihn in einer Reihe von SchnappschussÃ¤nderungen verpassen und einfach neue SchnappschÃ¼sse Ã¼berprÃ¼fen, ohne zu viel Zeit darauf zu verwenden. <br><br>  Infolgedessen helfen solche Tests nicht besonders beim Refactoring.  Im Idealfall sollte kein Test fehlschlagen, wenn ich ein Refactoring durchfÃ¼hre. Danach hat sich nichts geÃ¤ndert, was der Benutzer sieht und mit dem er interagiert.  Und umgekehrt - wenn ich Ã¤ndere, was der Benutzer kontaktiert, sollte mindestens ein Test fehlschlagen.  Wenn Tests diesen beiden Regeln folgen, sind sie ein hervorragendes Werkzeug, um sicherzustellen, dass sich etwas, auf das Benutzer stoÃŸen, wÃ¤hrend des Refactorings nicht Ã¤ndert. <br><br><h3>  <font color="#3AC1EF">â– Grundsatz Nr. 4.</font>  <font color="#3AC1EF">Tests sollten nachvollziehen, wie echte Benutzer mit der Anwendung arbeiten</font> </h3><br>  Ich mÃ¶chte, dass die Tests nur dann fehlschlagen, wenn sich etwas geÃ¤ndert hat, mit dem der Benutzer interagiert.  Das bedeutet, dass Tests mit der Anwendung genauso funktionieren sollten, wie Benutzer damit arbeiten.  Beispielsweise muss ein Test wirklich mit Formularelementen interagieren und wie ein Benutzer Text in Texteingabefelder eingeben.  Tests sollten nicht auf Komponenten zugreifen und Methoden ihres Lebenszyklus unabhÃ¤ngig aufrufen, sollten nichts in den Status von Komponenten schreiben oder etwas tun, das von den Feinheiten der Komponentenimplementierung abhÃ¤ngt.  Da ich letztendlich den Teil des Systems Ã¼berprÃ¼fen mÃ¶chte, der mit dem Benutzer in Kontakt steht, ist es logisch, sicherzustellen, dass die Tests bei der Interaktion mit dem System die Aktionen der tatsÃ¤chlichen Benutzer so genau wie mÃ¶glich reproduzieren. <br><br><h2>  <font color="#3AC1EF">Werkzeuge testen</font> </h2><br>  Nachdem wir die Ziele definiert haben, die wir erreichen mÃ¶chten, wollen wir uns darÃ¼ber unterhalten, welche Tools wir dafÃ¼r ausgewÃ¤hlt haben. <br><br><h3>  <font color="#3AC1EF">â–TypeScript</font> </h3><br>  Unsere Codebasis verwendet TypeScript.  Unsere Backend-Services sind in Go geschrieben und interagieren mithilfe von gRPC miteinander.  Dies ermÃ¶glicht es uns, typisierte gRPC-Clients fÃ¼r die Verwendung auf einem GraphQL-Server zu generieren.  GraphQL-Server-Resolver werden mit Typen getippt, die mit dem <a href="https://github.com/dotansimha/graphql-code-generator">graphql-Code-Generator</a> generiert wurden.  Und schlieÃŸlich sind unsere Abfragen, Mutationen sowie Abonnementkomponenten und Hooks vollstÃ¤ndig typisiert.  Die vollstÃ¤ndige Abdeckung unserer Codebasis mit Typen beseitigt eine ganze Klasse von Fehlern, die dadurch verursacht werden, dass das Datenformular nicht den Erwartungen des Programmierers entspricht.  Die Generierung von Typen aus den Schema- und Protobuf-Dateien stellt sicher, dass unser gesamtes System in allen Teilen des verwendeten Technologiestapels homogen bleibt. <br><br><h3>  <font color="#3AC1EF">â–Jest (Unit-Test)</font> </h3><br>  Als Framework zum Testen von Code verwenden wir <a href="https://jestjs.io/">Jest</a> und <a href="https://testing-library.com/docs/react-testing-library/intro">@ testing-library / react</a> .  In Tests, die mit diesen Tools erstellt wurden, testen wir Funktionen oder Komponenten isoliert vom Rest des Systems.  Normalerweise testen wir Funktionen und Komponenten, die am hÃ¤ufigsten in einer Anwendung verwendet werden, oder solche, die viele MÃ¶glichkeiten haben, Code auszufÃ¼hren.  Solche Pfade sind wÃ¤hrend der Integration oder der End-to-End-Tests (E2E) nur schwer zu Ã¼berprÃ¼fen. <br><br>  Unit Tests sind fÃ¼r uns ein Mittel, um Kleinteile zu testen.  Integrations- und End-to-End-Tests ermÃ¶glichen eine hervorragende ÃœberprÃ¼fung des Systems in grÃ¶ÃŸerem MaÃŸstab, sodass Sie den Gesamtzustand der Anwendung Ã¼berprÃ¼fen kÃ¶nnen.  Aber manchmal mÃ¼ssen Sie sicherstellen, dass die kleinen Details funktionieren, und das Schreiben von Integrationstests fÃ¼r alle mÃ¶glichen Verwendungen des Codes ist zu teuer. <br><br>  Beispielsweise mÃ¼ssen wir Ã¼berprÃ¼fen, ob die Tastaturnavigation in der Komponente funktioniert, die fÃ¼r die Arbeit mit der Dropdown-Liste verantwortlich ist.  Gleichzeitig mÃ¶chten wir aber nicht alle mÃ¶glichen Varianten eines solchen Verhaltens beim Testen der gesamten Anwendung Ã¼berprÃ¼fen.  Aus diesem Grund testen wir die Navigation einzeln grÃ¼ndlich und achten beim Testen von Seiten mit der entsprechenden Komponente nur auf die ÃœberprÃ¼fung von Interaktionen auf hÃ¶herer Ebene. <br><br><h2>  <font color="#3AC1EF">Werkzeuge testen</font> </h2><br><h3>  <font color="#3AC1EF">â–Cypress (Integrationstests)</font> </h3><br>  Mit <a href="https://www.cypress.io/">Cypress</a> erstellte Integrationstests bilden den Kern unseres Testsystems.  Als wir mit der Erstellung des StackPath-Portals begannen, waren dies die ersten Tests, die wir geschrieben haben, da sie mit sehr geringem Aufwand fÃ¼r ihre Erstellung Ã¤uÃŸerst wertvoll sind.  Cypress zeigt unsere gesamte Anwendung in einem Browser an und fÃ¼hrt Testskripte aus.  Unser gesamtes Frontend funktioniert genauso, wie Benutzer damit arbeiten.  Richtig, die Netzwerkschicht des Systems wird durch Mokami ersetzt.  Jede Netzwerkabfrage, die normalerweise an den GraphQL-Server gesendet wird, gibt bedingte Daten an die Anwendung zurÃ¼ck. <br><br>  Die Verwendung von Mocks zur Simulation der Netzwerkschicht einer Anwendung hat viele StÃ¤rken: <br><br><ul><li>  Tests sind schneller.  Selbst wenn das Projekt-Backend extrem schnell ist, kann die Zeit, die erforderlich ist, um Antworten auf Anforderungen, die wÃ¤hrend der gesamten Testsuite gestellt wurden, zurÃ¼ckzugeben, betrÃ¤chtlich sein.  Und wenn Moki fÃ¼r die RÃ¼ckgabe von Antworten verantwortlich ist, werden die Antworten sofort zurÃ¼ckgegeben. </li><li>  Tests werden zuverlÃ¤ssiger.  Eine der Schwierigkeiten beim DurchfÃ¼hren eines vollstÃ¤ndigen End-to-End-Tests eines Projekts besteht darin, dass der variable Status der Netzwerk- und Serverdaten berÃ¼cksichtigt werden muss, der sich Ã¤ndern kann.  Wenn mit Moxas ein echter Netzwerkzugriff simuliert wird, verschwindet diese VariabilitÃ¤t. </li><li>  Es ist einfach, Situationen zu reproduzieren, die die exakte Wiederholung bestimmter Bedingungen erfordern.  In einem realen System ist es beispielsweise schwierig, bestimmte Anforderungen zum Scheitern zu bringen.  Wenn Sie die korrekte Reaktion der Anwendung auf erfolglose Anfragen Ã¼berprÃ¼fen mÃ¼ssen, kÃ¶nnen Sie mit moki problemlos Notfallsituationen reproduzieren. </li></ul><br>  Obwohl das Ersetzen des gesamten Backends durch mok eine entmutigende Aufgabe ist, werden alle bedingten Daten mit denselben generierten TypeScript-Typen eingegeben, die in der Anwendung verwendet werden.  Das heiÃŸt - zumindest diese Daten - entsprechen strukturell garantiert dem, was ein normales Backend zurÃ¼ckgeben wÃ¼rde.  WÃ¤hrend der meisten Tests haben wir uns ziemlich friedlich damit abgefunden, Mooks anstelle von echten Serveraufrufen zu verwenden. <br><br>  DarÃ¼ber hinaus sind Programmierer sehr erfreut, mit Cypress zu arbeiten.  Tests werden im Cypress Test Runner ausgefÃ¼hrt.  Testbeschreibungen werden links angezeigt, und die Testanwendung wird im <code>iframe</code> Hauptelement ausgefÃ¼hrt.  Nachdem Sie den Test gestartet haben, kÃ¶nnen Sie seine einzelnen Phasen studieren und herausfinden, wie sich die Anwendung zu dem einen oder anderen Zeitpunkt verhalten hat.  Da das Tool zum AusfÃ¼hren von Tests im Browser selbst ausgefÃ¼hrt wird, kÃ¶nnen Sie die Tests mit den Browser-Tools des Entwicklers debuggen. <br><br>  Wenn Sie Front-End-Tests schreiben, dauert es oft sehr lange, bis Sie die Ergebnisse des Tests mit dem Status des DOM zu einem bestimmten Zeitpunkt des Tests verglichen haben.  Cypress vereinfacht diese Aufgabe erheblich, da der Entwickler alles sehen kann, was mit der getesteten Anwendung geschieht.  <a href="">Hier ist ein</a> Videoclip, der dies demonstriert. <br><br>  Diese Tests veranschaulichen unsere Testprinzipien perfekt.  Das VerhÃ¤ltnis ihres Wertes zu ihrem "Preis" passt zu uns.  Tests reproduzieren sehr Ã¤hnlich die Aktionen des realen Benutzers, der mit der Anwendung interagiert.  Und nur die Netzwerkschicht des Projekts wurde durch Mokami ersetzt. <br><br><h3>  <font color="#3AC1EF">â–Cypress (End-to-End-Test)</font> </h3><br>  Unsere E2E-Tests werden ebenfalls mit Cypress geschrieben. In diesen Tests wird Moki jedoch weder zur Simulation der Netzwerkebene eines Projekts noch zur Simulation anderer Funktionen verwendet.  Bei der DurchfÃ¼hrung von Tests greift die Anwendung auf den realen GraphQL-Server zu, der mit realen Instanzen von Backend-Diensten arbeitet. <br><br>  End-to-End-Tests sind fÃ¼r uns Ã¤uÃŸerst wertvoll.  Tatsache ist, dass es die Ergebnisse solcher Tests sind, die uns wissen lassen, ob etwas wie erwartet funktioniert oder nicht.  Bei solchen Tests werden keine Mocks verwendet. Daher funktioniert die Anwendung genau so, wie sie von echten Clients verwendet wird.  Es ist jedoch zu beachten, dass End-to-End-Tests â€teurerâ€œ sind als andere.  Sie sind langsamer und schwieriger zu schreiben, da bei ihrer Implementierung kurzfristige Fehler auftreten kÃ¶nnen.  Es sind weitere Arbeiten erforderlich, um sicherzustellen, dass das System in einem bekannten Zustand bleibt, bevor die Tests ausgefÃ¼hrt werden. <br><br>  Tests mÃ¼ssen normalerweise zu einem Zeitpunkt ausgefÃ¼hrt werden, an dem sich das System in einem bekannten Zustand befindet.  Nach Abschluss des Tests wechselt das System in einen anderen bekannten Zustand.  Im Fall von Integrationstests ist es nicht schwierig, dieses Verhalten des Systems zu erreichen, da Aufrufe der API durch Mokas ersetzt werden und folglich jeder Test unter vorbestimmten Bedingungen ausgefÃ¼hrt wird, die vom Programmierer gesteuert werden.  Bei E2E-Tests ist dies jedoch bereits schwieriger, da das Server Data Warehouse Informationen enthÃ¤lt, die sich wÃ¤hrend des Tests Ã¤ndern kÃ¶nnen.  Infolgedessen muss der Entwickler einen Weg finden, um sicherzustellen, dass sich das System zu Beginn des Tests in einem zuvor bekannten Zustand befindet. <br><br>  Zu Beginn des End-to-End-Testlaufs fÃ¼hren wir ein Skript aus, das durch direkte Aufrufe der API ein neues Konto mit Stacks, Sites, Workloads, Monitoren und dergleichen erstellt.  Jede Testsitzung impliziert die Verwendung einer neuen Instanz eines solchen Kontos, aber alles andere bleibt von Zeit zu Zeit unverÃ¤ndert.  Nachdem das Skript alle erforderlichen Schritte ausgefÃ¼hrt hat, erstellt es eine Datei mit den Daten, die zum AusfÃ¼hren der Tests verwendet werden (normalerweise enthÃ¤lt es Informationen zu Instanz-IDs und DomÃ¤nen).  Infolgedessen stellt sich heraus, dass Sie mit dem Skript das System in einen zuvor bekannten Zustand versetzen kÃ¶nnen, bevor Sie die Tests ausfÃ¼hren. <br><br>  Da End-to-End-Tests â€teurerâ€œ sind als andere Testarten, schreiben wir im Vergleich zu Integrationstests weniger End-to-End-Tests.  Wir bemÃ¼hen uns sicherzustellen, dass die Tests kritische Anwendungsmerkmale abdecken.  Dies ist beispielsweise das Registrieren von Benutzern und ihrer Anmeldung, das Erstellen und Einrichten einer Site / eines Workloads usw.  Dank umfangreicher Integrationstests wissen wir, dass unser Frontend im Allgemeinen funktionsfÃ¤hig ist.  End-to-End-Tests sind jedoch nur erforderlich, um sicherzustellen, dass beim Verbinden des Frontends mit dem Backend nichts passiert, was andere Tests nicht erkennen kÃ¶nnen. <br><br><h2>  <font color="#3AC1EF">Nachteile unserer umfassenden Teststrategie</font> </h2><br>  Obwohl wir mit den Tests und der StabilitÃ¤t der Anwendung sehr zufrieden sind, hat die Verwendung einer umfassenden Teststrategie wie unserer auch Nachteile. <br><br>  ZunÃ¤chst einmal bedeutet die Anwendung einer solchen Teststrategie, dass alle Teammitglieder mit vielen Testwerkzeugen vertraut sein sollten und nicht nur mit einem.  Jeder muss Jest, @ testing-library / react und Cypress kennen.  Gleichzeitig mÃ¼ssen Entwickler diese Tools aber nicht nur kennen.  Sie mÃ¼ssen auch in der Lage sein, Entscheidungen darÃ¼ber zu treffen, in welcher Situation welche eingesetzt werden soll.  Lohnt es sich, eine neue MÃ¶glichkeit zum Schreiben eines End-to-End-Tests zu testen, oder reicht der Integrationstest aus?  MÃ¼ssen Sie zusÃ¤tzlich zum End-to-End- oder Integrationstest einen Komponententest schreiben, um die kleinen Details der Implementierung dieser neuen Funktion zu Ã¼berprÃ¼fen? <br><br>  Zweifellos â€belastetâ€œ dies sozusagen den Kopf unserer Programmierer, wÃ¤hrend sie das einzige Werkzeug verwenden, das sie nicht so stark belasten wÃ¼rden.  Normalerweise beginnen wir mit Integrationstests. Wenn wir dann feststellen, dass das untersuchte Feature von besonderer Bedeutung ist und stark vom Serverteil des Projekts abhÃ¤ngt, fÃ¼gen wir den entsprechenden End-to-End-Test hinzu.  Oder wir beginnen mit Unit-Tests, wenn wir glauben, dass ein Unit-Test nicht alle Feinheiten der Implementierung eines bestimmten Mechanismus verifizieren kann. <br><br>  NatÃ¼rlich sind wir immer noch mit Situationen konfrontiert, in denen nicht klar ist, wo wir anfangen sollen.  Da wir jedoch stÃ¤ndig Entscheidungen in Bezug auf Tests treffen mÃ¼ssen, tauchen bestimmte Muster gemeinsamer Situationen auf.  Beispielsweise testen wir normalerweise Formularvalidierungssysteme mithilfe von Komponententests.  Dies geschieht aufgrund der Tatsache, dass Sie wÃ¤hrend des Tests viele verschiedene Szenarien Ã¼berprÃ¼fen mÃ¼ssen.  Gleichzeitig weiÃŸ jeder im Team davon und verschwendet keine Zeit damit, eine Teststrategie zu planen, wenn einer von ihnen das Formularvalidierungssystem testen muss. <br><br>  Ein weiterer Nachteil des von uns verwendeten Ansatzes ist die Schwierigkeit, Daten zur Codeabdeckung durch Tests zu sammeln.  Obwohl dies mÃ¶glich ist, ist es viel komplizierter als in einer Situation, in der ein Projekt getestet wird.  Obwohl das Streben nach einer schÃ¶nen Anzahl von Code-Coverages durch Tests zu einer Verschlechterung der TestqualitÃ¤t fÃ¼hren kann, sind solche Informationen fÃ¼r das Auffinden von â€LÃ¼ckenâ€œ in der verwendeten Testsuite von Nutzen.  Das Problem bei der Verwendung mehrerer Testtools besteht darin, dass Sie Berichte zur Codeabdeckung mit Tests kombinieren mÃ¼ssen, die von verschiedenen Systemen stammen, um zu verstehen, welcher Teil des Codes nicht getestet wurde.  Es ist mÃ¶glich, aber es ist definitiv viel schwieriger, als einen Bericht zu lesen, der mit einem Testverfahren erstellt wurde. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Beim Einsatz vieler Testwerkzeuge standen wir vor schwierigen Aufgaben.  Aber jedes dieser Werkzeuge erfÃ¼llt seinen eigenen Zweck.  Letztendlich glauben wir, dass wir das Richtige getan haben, indem wir sie in unser Code-Testsystem aufgenommen haben.  Integrationstests - Hier sollten Sie am besten zu Beginn der Arbeit an einer neuen Anwendung oder beim AusrÃ¼sten von Tests eines vorhandenen Projekts mit dem Erstellen eines Testsystems beginnen.  Es wird nÃ¼tzlich sein, zu versuchen, dem Projekt so frÃ¼h wie mÃ¶glich End-to-End-Tests hinzuzufÃ¼gen, um die wichtigsten Funktionen des Projekts zu Ã¼berprÃ¼fen. <br><br>  Wenn die Testsuite End-to-End- und Integrationstests enthÃ¤lt, sollte dies dazu fÃ¼hren, dass der Entwickler ein gewisses MaÃŸ an Vertrauen in den Zustand der Anwendung erhÃ¤lt, wenn Ã„nderungen daran vorgenommen werden.  Wenn im Verlauf der Projektarbeiten Fehler auftauchen, die von den Tests nicht erkannt werden, ist zu Ã¼berlegen, welche Tests diese Fehler auffangen kÃ¶nnten und ob das Auftreten von Fehlern auf die MÃ¤ngel des gesamten im Projekt verwendeten Testsystems hindeutet. <br><br>  NatÃ¼rlich sind wir nicht sofort zu unserem aktuellen Testsystem gekommen.  DarÃ¼ber hinaus gehen wir davon aus, dass sich dieses System mit dem Wachstum unseres Projekts weiterentwickeln wird.  Aber jetzt mÃ¶gen wir unseren Ansatz zum Testen wirklich. <br><br>  <b>Sehr geehrte Leser!</b>  Welche Strategien verfolgen Sie beim Frontend-Testen?  Welche Frontend-Testtools verwenden Sie? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de477278/">https://habr.com/ru/post/de477278/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de477266/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends fÃ¼r die letzte Woche Nr. 390 (18.-24. November 2019)</a></li>
<li><a href="../de477268/index.html">SuchlÃ¶sungsoptimierung auf Github</a></li>
<li><a href="../de477272/index.html">Erste EinfÃ¼hrung in AssemblyScript</a></li>
<li><a href="../de477274/index.html">Wie werden Sie nicht verwendeten CSS-Code los? Teil 1</a></li>
<li><a href="../de477276/index.html">Wie werden Sie nicht verwendeten CSS-Code los? Teil 2</a></li>
<li><a href="../de477282/index.html">Profiling Go-Projektcode und Beheben von Speicherzuordnungsproblemen</a></li>
<li><a href="../de477284/index.html">Warum ist JavaScript im strikten Modus erforderlich?</a></li>
<li><a href="../de477286/index.html">Axios oder Fetch: Was im Jahr 2019 verwenden?</a></li>
<li><a href="../de477288/index.html">John Lewis auf der Undoing Aging Conference 2018</a></li>
<li><a href="../de477290/index.html">Digitale Veranstaltungen in Moskau vom 25. November bis 1. Dezember</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>