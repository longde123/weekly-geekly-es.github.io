<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 游땴 游빅 Monstruo errante: c칩mo deshacerse de los problemas en el mapa 游깫 游낎 游냈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya en el proceso de creaci칩n de The Witness se ha convertido en uno de mis juegos favoritos. Comenc칠 a jugarlo desde el momento en que Jonathan Blow c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Monstruo errante: c칩mo deshacerse de los problemas en el mapa</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423519/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png" alt="imagen"></div><br>  Ya en el proceso de creaci칩n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness se</a> ha convertido en uno de mis juegos favoritos.  Comenc칠 a jugarlo desde el momento en que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jonathan Blow</a> comenz칩 a desarrollarlo, y no pod칤a esperar a su lanzamiento. <br><br>  A diferencia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">del</a> juego anterior de John <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Braid</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> escala de recursos y programaci칩n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> estaba mucho m치s cerca de los proyectos AAA que de los juegos independientes.  Todos los que trabajan en tales proyectos saben que la cantidad de trabajo al elegir este camino aumenta significativamente.  Hab칤a mucha m치s gente trabajando en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> que en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Braid</a> , pero como con cualquier proyecto de este nivel, hay muchos aspectos que requieren m치s atenci칩n de la que la administraci칩n del proyecto puede permitirse. <br><br>  Por lo tanto, siempre quise encontrar tiempo libre para ayudar a crear <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness a la</a> hora de lanzar el juego.  Entonces, un d칤a, el D칤a de Acci칩n de Gracias, John y yo nos sentamos y miramos la lista de cosas en la base del c칩digo que se beneficiar칤an de los esfuerzos adicionales de otro programador.  Habiendo decidido la importancia relativa de los elementos de la lista, decidimos que la jugabilidad ser치 m치s beneficiosa si realizamos mejoras en el c칩digo de movimiento del jugador. <br><a name="habracut"></a><br><h2>  Walkmonster en pared </h2><br>  En el contexto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> , el objetivo del c칩digo de movimiento de un jugador es ser lo m치s discreto posible.  El jugador debe sumergirse completamente en una realidad alternativa, y en esta experiencia de juego cada detalle es importante.  Lo 칰ltimo que quer칤amos era que el jugador notara que estaba sentado frente a la computadora y moviendo la c치mara virtual. <br><br>  Por lo tanto, el c칩digo de movimiento del jugador debe ser absolutamente confiable.  Si un jugador se aferra a las esquinas, se atasca en las paredes, cae al suelo, desciende de una colina sin la capacidad de regresar, etc., esto destruir치 instant치neamente la ilusi칩n de inmersi칩n y le recordar치 al jugador que est치 dentro de un proceso de juego artificial que es interferido por un sistema poco confiable desplazamientos  En algunas circunstancias, esto puede incluso tener consecuencias desastrosas para el jugador si no tiene la oportunidad de resolver el problema reiniciando el juego o volviendo a cargar el (probablemente muy antiguo) "guardar".  Si juegas a menudo, debes haber encontrado problemas de este tipo y sabes a qu칠 me refiero. <br><br>  Despu칠s de nuestra discusi칩n, comenc칠 a trabajar en esta tarea.  En primer lugar, decid칤 escribir herramientas integradas para trabajar con el c칩digo de movimiento del jugador, para que podamos analizarlo y observar su comportamiento actual.  Despu칠s de abrir el proyecto, me encontr칠 con un problema grave que ya conoc칤a: 쯖칩mo debo nombrar el primer archivo de c칩digo fuente?  Esta es siempre la parte m치s importante de cualquier proyecto ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">como dijo una vez Bob Pollard sobre los nombres de grupos musicales y 치lbumes</a> ).  Si le da al archivo fuente un nombre adecuado, el trabajo posterior ser치 claro y fluido.  Elija el equivocado: puede destruir todo el proyecto. <br><br>  Pero, 쯖u치l es el nombre del sistema para garantizar la calidad del c칩digo de movimiento del jugador?  Nunca he tenido que escribir c칩digo como este antes.  Cuando pens칠 en esto, me di cuenta de que personalmente vi un ejemplo de dicho c칩digo solo una vez: cuando jugu칠 la versi칩n beta temprana de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quake</a> .  Conten칤a errores con la ubicaci칩n de los monstruos, y en la ventana de la consola se pod칤an ver mensajes de error que indicaban que los monstruos, en lugar de crear en la superficie de la tierra, se crean, intersectando parcialmente con la geometr칤a de los niveles.  Cada mensaje de depuraci칩n comenz칩 con la frase "walkmonster in wall at ..." <br><br>  Bingo!  Es dif칤cil encontrar un mejor nombre para el archivo de c칩digo que "walk_monster.cpp".  Y estaba casi seguro de que a partir de ahora el c칩digo se crear칤a sin problemas. <br><br><h2>  Movimiento al punto </h2><br>  Cuando desee probar el sistema, lo m치s importante es <i>probarlo realmente</i> .  Aunque esta regla parece simple, las personas que escriben pruebas a menudo no cumplen. <br><br>  En nuestro caso particular, es muy f치cil <i>imaginar</i> que estamos probando el c칩digo de movimiento de un jugador sin probarlo realmente.  Aqu칤 hay un ejemplo: puedes analizar el volumen de colisiones y superficies sobre las que puedes moverte en el juego, buscar peque침as superficies, huecos, etc.  Una vez eliminados todos estos problemas, podemos decir que ahora el jugador puede moverse y caminar con seguridad alrededor del mundo. <br><br>  Pero, de hecho, probamos los datos, no el c칩digo.  Es muy probable que haya errores en el c칩digo de movimiento que conduzcan a un mal comportamiento incluso con datos de alta calidad. <br><br>  Para evitar esa trampa, quer칤a que el sistema de prueba estuviera lo m치s cerca posible del comportamiento de la persona que realmente controla el movimiento del personaje en el juego.  Comenc칠 escribiendo dos procedimientos que se convertir칤an en los componentes b치sicos de tales pruebas. <br><br>  El primer procedimiento es m치s cercano a las acciones humanas reales.  Esta es una llamada de actualizaci칩n que se conecta al sistema de procesamiento de entrada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> y le pasa los eventos sintetizados del teclado y el mouse.  Es capaz de hacer cosas simples que una persona puede hacer: mirar a su alrededor, ir hacia un punto, mirar un punto, etc.  El procedimiento realiza estas acciones simplemente emulando la interacci칩n del usuario con el teclado y el mouse, por lo que estaba seguro de que al procesar la entrada de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> todo se har치 exactamente como se hizo durante las pruebas.  En los siguientes art칤culos hablar칠 m치s sobre este sistema y su uso. <br><br>  El segundo procedimiento es un paso que no se utiliza en este nivel.  Esta es una funci칩n llamada <i>DriveTowardPoint</i> , que recibe dos puntos en el mundo y, causando un sistema de colisi칩n existente de un jugador, intenta moverse sin problemas de un punto a otro.  Llevando a cabo el regreso, transmite informaci칩n sobre el intento: qu칠 obst치culos encontr칩 en el camino y si logr칩 llegar al punto final. <br><br>  Esta funci칩n no es tan confiable como un m칠todo de prueba con entrada sintetizada, ya que elimina parte de la prueba del sistema de movimiento del jugador.  Por ejemplo, cualquier condici칩n err칩nea asociada con la ubicaci칩n del jugador en caso de problemas con el sistema de colisi칩n no afectar치 las pruebas con esta funci칩n.  Sin embargo, considero que este nivel de prueba es valioso porque puede probar vastas 치reas mucho m치s r치pido, porque no requiere la ejecuci칩n de todo el ciclo del juego, es decir, puede usarse con mucha m치s frecuencia en todo el mundo, y no solo en pruebas separadas . <br><br>  Tambi칠n vale la pena se침alar que esta funci칩n no transmite datos de entrada f칤sica;  por ejemplo, las velocidades no est치n indicadas para el punto de partida.  Esto se debe a que <i>The Witness</i> no es un juego de acci칩n, por lo que el jugador tiene pocas propiedades f칤sicas significativas.  Los jugadores no pueden saltar, correr en las paredes, activar el tiempo de bala.  Puede admitir tales comportamientos utilizando sistemas que describir칠 m치s adelante, pero agregan niveles de complejidad que no eran necesarios en nuestro proyecto. <br><br>  Sea como fuere, despu칠s de implementar <i>DriveTowardPoint</i> podr칤a comenzar a resolver la primera tarea del sistema: determinar d칩nde puede moverse el jugador a <i>The Witness</i> Island. <br><br><h2>  Explorando r치pidamente 치rboles al azar </h2><br>  쮸 d칩nde pueden ir los jugadores?  Parece una pregunta simple, pero te sorprender치 saber cu치ntos juegos se lanzaron cuando el equipo de desarrollo no sab칤a la respuesta real.  Si esto es posible, quer칤a que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> fuera uno de esos pocos juegos en los que los desarrolladores antes del lanzamiento sab칤an exactamente d칩nde pod칤a y no pod칤a obtener un jugador, sin sorpresas. <br><br>  Esto hace que el enunciado del problema (pero probablemente no sea su soluci칩n) sea muy simple: si hay una funci칩n <i>DriveTowardPoint</i> que determina de manera confiable si el jugador puede moverse en l칤nea recta entre dos puntos, cree un mapa de cobertura que muestre d칩nde puede estar el jugador. <br><br>  Por alguna raz칩n, sin escribir una sola l칤nea de c칩digo, por alguna raz칩n pens칠 que ser칤a mejor usar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rapidly Exploring Random Tree</a> .  Para aquellos que no est치n familiarizados con este algoritmo, les explicar칠: este es un proceso muy simple en el que registramos todos los puntos que visitamos con referencia al punto del que vinimos.  Para agregar un punto al 치rbol, tomamos un punto objetivo aleatorio en cualquier parte del mundo, seleccionamos el punto m치s cercano a 칠l, ya en el 치rbol, e intentamos llegar desde este punto al objetivo.  El lugar donde terminamos se convierte en el pr칩ximo punto de muestreo. <br><br>  Por lo general, este algoritmo se usa para buscar rutas: alternativamente para puntos aleatorios, siempre seleccionamos el mismo punto que el objetivo.  Esto inclina la exploraci칩n del espacio hacia el punto objetivo, y esto es lo que se requiere cuando nuestra 칰nica tarea es lograr el objetivo.  Pero en este caso, quer칤a crear un mapa completo de los lugares en los que el jugador podr칤a caer, as칤 que solo uso muestras aleatorias. <br><br>  Despu칠s de implementar este algoritmo (afortunadamente, es muy simple y no requiri칩 mucho tiempo), vi que hizo un trabajo de bastante alta calidad al explorar el espacio (los caminos se muestran por caminos blancos, y las l칤neas rojas verticales indican los lugares donde el algoritmo colision칩 con un obst치culo) : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed2/ca3/fe3/ed2ca3fe3dbfe02cb7c9779af50f9ca6.png"></div><br>  Sin embargo, despu칠s de observar su comportamiento, me di cuenta de que, de hecho, no necesito tal algoritmo.  Por ejemplo, incluso despu칠s de muchas iteraciones, apenas puede explorar las habitaciones similares a las que se muestran a continuaci칩n, a pesar de la densa cobertura de las 치reas exteriores.  Esto se debe a que simplemente no puede seleccionar puntos suficientemente aleatorios dentro de las habitaciones: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/983/2d4/5a5/9832d45a5c14dc13df9a03cf5216697f.png" width="1280" height="720"></div><br>  Si pensara en esto antes de comenzar a trabajar, entender칤a que la ventaja de algoritmos como Rapidly Explorando Random Tree es que exploran efectivamente espacios de alta dimensi칩n.  De hecho, esta suele ser la raz칩n principal de su uso.  Pero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiene</a> espacios de alta dimensi칩n.  Tenemos un espacio bidimensional (s칤, distribuido en una variedad compleja, pero este sigue siendo un espacio bidimensional). <br><br>  En este espacio de baja dimensi칩n, las ventajas de Explorar r치pidamente el 치rbol aleatorio son d칠biles, y su inconveniente es de vital importancia para mi tarea: el algoritmo est치 dise침ado para la b칰squeda m치s eficiente de rutas a pares de puntos conectados en el espacio, y no para la b칰squeda eficiente de todos los puntos accesibles de este espacio.  Si tiene una tarea as칤, de hecho, Explorar r치pidamente el 치rbol aleatorio tomar치 una gran cantidad de tiempo para resolverlo. <br><br>  As칤 que r치pidamente me di cuenta de que necesitaba buscar un algoritmo que efectivamente cubriera completamente los espacios de baja dimensi칩n. <br><br><h2>  Relleno de inundaci칩n 3D </h2><br>  Cuando realmente pens칠 en elegir un algoritmo, se hizo evidente que, de hecho, necesitaba algo como el viejo relleno bidimensional, que se usa para rellenar 치reas del mapa de bits.  Para cualquier punto de partida, solo ten칤a que llenar todo el espacio, verificando exhaustivamente todas las formas posibles.  Desafortunadamente, por muchas razones, la soluci칩n para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> ser치 mucho m치s complicada que para un mapa de bits bidimensional. <br><br>  Primero, no tenemos un concepto claro de la conexi칩n finita de un punto.  Todo el espacio es continuo.  Esto es para un p칤xel, podemos enumerar f치cilmente 4 lugares posibles a los que se puede llegar desde un punto determinado y verificar cada uno de ellos por turno. <br><br>  En segundo lugar, no hay un tama침o fijo de posici칩n en el espacio, como un p칤xel en un mapa de bits.  Las superficies sobre las que se mueve el jugador, y los obst치culos pueden estar en cualquier lugar, no tienen un tama침o topol칩gico m치ximo o m칤nimo, y tampoco est치n vinculados a ninguna cuadr칤cula externa. <br><br>  En tercer lugar, aunque el movimiento a trav칠s del espacio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">The Witness</a> puede considerarse localmente como un movimiento a lo largo de un plano, el espacio en s칤 mismo es en realidad una variedad cambiante y profundamente interconectada, en la que las 치reas transitables del jugador est치n directamente sobre otras 치reas (a veces puede haber varios niveles ubicados uno encima del otro) .  Adem치s, hay conexiones que var칤an seg칰n las condiciones del mundo (puertas abiertas / cerradas, ascensores que suben / bajan, etc.). <br><br>  Dadas las dificultades descritas, es muy simple encontrar su propia opci칩n de implementaci칩n para el llenado, que como resultado se llenar치 de 치reas que se cruzan, faltan rutas importantes, informaci칩n err칩nea sobre conexiones en lugares complejos de la variedad.  Al final, el algoritmo ser치 demasiado engorroso de usar, porque para tener en cuenta los cambios en el estado del mundo, debe volver a ejecutarse. <br><br>  No pens칠 en ninguna buena soluci칩n de inmediato, as칤 que decid칤 comenzar con experimentos simples.  Utilizando el c칩digo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">치rbol aleatorio de exploraci칩n r치pida</a> que escrib칤, cambi칠 la selecci칩n de puntos objetivo de aleatorio a muy controlado.  Cada vez que se agrega un nuevo punto al 치rbol, indico que los puntos est치n a una unidad de distancia a lo largo de las direcciones principales desde el punto que se considerar치 el punto objetivo futuro, como sucede en un simple relleno bidimensional. <br><br>  Pero, por supuesto, si no tiene cuidado, esto crear치 un ciclo de muestreo in칰til.  El punto se ramificar치 en los 8 puntos vecinos a su alrededor, pero estos 8 puntos intentar치n nuevamente volver al punto de partida, y esto continuar치 para siempre.  Por lo tanto, adem치s de la selecci칩n controlada de puntos objetivo, necesito una restricci칩n simple: cualquier punto objetivo que no est칠 dentro de una cierta distancia 칰til m칤nima desde un punto objetivo existente no se tendr치 en cuenta.  Para mi sorpresa, estas dos reglas simples crean un relleno bastante exitoso: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/591/cf6/446/591cf6446fdcc8281f7ebd9449c48703.png"></div><br>  No est치 mal para un experimento bastante simple.  Pero el algoritmo sufre de lo que yo llamo el "eco l칤mite".  Este efecto se puede ver en la siguiente captura de pantalla tomada durante el estudio del mapa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58e/fd0/25f/58efd025f80d2b96274ed849d3e4c568.png"></div><br>  En 치reas sin obst치culos, el algoritmo funciona bien mediante el muestreo a distancias relativamente iguales.  Pero cuando la intersecci칩n llega al borde, crean puntos que est치n "fuera de la cuadr칤cula", es decir, no est치n alineados de acuerdo con el patr칩n de muestras, seg칰n el cual el algoritmo llena el 치rea abierta vecina.  La raz칩n por la que los puntos "en la cuadr칤cula" no crean una teselaci칩n excesivamente densa es porque cada nuevo punto que intenta regresar a uno de los anteriores encuentra el punto anterior all칤 y se niega a volver a contarlo.  Pero al crear nuevos puntos en el borde, est치n completamente desalineados, por lo que nada puede evitar que regresen al espacio ya explorado.  Esto lleva a la creaci칩n de una ola de muestras sesgadas, que contin칰a hasta que alcanza una l칤nea aleatoria de puntos en otro lugar, lo suficientemente cerca como para que el algoritmo pueda encontrarla coincidiendo con el frente m칩vil de los puntos. <br><br>  Aunque esto no parece ser un problema grave, en realidad es cr칤tico.  El objetivo de estos algoritmos es concentrar las muestras en 치reas donde es m치s probable que produzcan resultados productivos.  Cuanto m치s tiempo pasemos muestreando y volviendo a muestrear grandes 치reas abiertas, menos tiempo dedicaremos a marcar las caras de esta 치rea, que es la informaci칩n que necesitamos.  Como estamos tratando con un espacio continuo, y solo un n칰mero infinito de muestras puede describir su forma real, la proporci칩n de muestras significativas a insignificantes es, literalmente, una medida de la efectividad del algoritmo para crear una superficie aceptable para un jugador. <br><br>  Sin embargo, hay una soluci칩n simple para este problema en particular: necesita expandir la distancia a la cual los dos puntos se consideran "bastante cercanos".  Al hacerlo, reduciremos la densidad de muestreo en lugares que <i>no</i> son <i>importantes para</i> nosotros, pero tambi칠n perderemos la densidad de muestreo en lugares que son <i>importantes para</i> nosotros, por ejemplo, las 치reas alrededor de las fronteras que queremos verificar cuidadosamente para detectar la presencia de "agujeros". <br><br><h2>  Muestreo direccional localizado </h2><br>  Probablemente porque comenc칠 con el 치rbol aleatorio de exploraci칩n r치pida, mi cerebro suplant칩 todas las dem치s ideas, excepto la idea de proximidad.  Todos los algoritmos anteriores usaban proximidad para su tarea, por ejemplo, para determinar un nuevo punto que debe considerarse a continuaci칩n, o para seleccionar un punto desde el cual comenzar a llegar a un nuevo punto objetivo. <br><br>  Pero despu칠s de pensar en la tarea durante alg칰n tiempo, me di cuenta de que todo se est치 volviendo m치s l칩gico, si pensamos no solo en la proximidad, sino tambi칠n en la <i>direcci칩n</i> .  Entonces se vuelve obvio, pero si trabajaste en tareas similares, entonces sabes que es f치cil caer en la trampa del pensamiento de mente estrecha y no ver el panorama general, incluso si resulta ser m치s simple.  Eso es exactamente lo que me pas칩. <br><br>  Cuando cambi칠 mi visi칩n de las cosas, el enfoque correcto para el muestreo parec칤a obvio.  Cada vez que quer칤a expandir mi exploraci칩n del espacio desde un punto, solicit칠 la existencia de puntos cercanos en el entorno local.  Sin embargo, en lugar de utilizar la distancia a estos puntos para la investigaci칩n, los clasificar칠 por sus direcciones (antes de eso solo us칠 ocho direcciones principales, pero quer칤a experimentar con otros n칰cleos). <br><br>  En cualquier direcci칩n en la que no "veo" el punto, recorro la distancia especificada y agrego un punto en cualquier lugar donde me detuve (independientemente de si encontr칠 algo o no).  Si veo un punto en una de las direcciones, me muevo all칤 y compruebo si puedo llegar all칤.  Si puedo, entonces solo agrego un borde visible para que el usuario pueda ver f치cilmente que los puntos est치n conectados.  Si no puedo, entonces agrego un nuevo punto en el punto de colisi칩n, definiendo el l칤mite del obst치culo. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m칠todo de muestreo funcion칩 bien. </font><font style="vertical-align: inherit;">Nos permite controlar con mucha precisi칩n el muestreo utilizando par치metros convenientes personalizables, guardar todos los puntos necesarios y evitar teselaciones innecesarias, lo que conduce a un llenado de espacio muy r치pido:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/e45/60e/699e4560ef50242ff48ba0682554248a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dado que el algoritmo busca a lo largo de las direcciones, y no solo usa la proximidad, est치 protegido de los ecos de l칤mites y limita el muestreo excesivo solo a los l칤mites que necesitamos: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f3/673/618/6f3673618d182bb1810e2577c18ab1ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem치s, el algoritmo no se ve afectado por transiciones de estado o problemas con m칰ltiples complejos. Solo se trata de puntos, y estos puntos pueden estar en cualquier lugar, y se pueden agregar otros nuevos en cualquier momento. Si ya compil칩 un mapa del 치rea con la puerta cerrada, luego de abrir la puerta, solo necesita colocar el 칰nico punto de investigaci칩n en el otro lado de la puerta y ordenar el algoritmo para continuar expandiendo este mapa, despu칠s de lo cual se conectar치 correctamente y examinar치 correctamente toda el 치rea fuera de la puerta.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem치s, en cualquier momento, puede cambiar los par치metros b치sicos y el sistema continuar치 funcionando. </font><font style="vertical-align: inherit;">쮻esea realizar un muestreo de 치rea con mayor densidad? </font><font style="vertical-align: inherit;">Simplemente baje la distancia predeterminada. </font><font style="vertical-align: inherit;">Esto ya se puede hacer en el proceso de construcci칩n del mapa, y el algoritmo comenzar치 a tomar muestras con una densidad m치s alta sin la necesidad de restablecer los resultados anteriores (lo que puede llevar alg칰n tiempo).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verificaci칩n rudimentaria de bordes </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El algoritmo predeterminado ya muestra los bordes con bastante cuidado, porque las intersecciones crean puntos adicionales que no est치n incluidos en el patr칩n de muestreo, pero no necesariamente los verifica con el cuidado necesario, ya que no realiza ninguna acci칩n especial cuando encuentra obst치culos. Me di cuenta de que, dado que sab칤a qu칠 puntos se crearon durante las colisiones, los dos puntos de colisi칩n detectados est치n conectados por un borde y podemos solicitar un muestreo adicional para tratar de encontrar m치s puntos l칤mite en el vecindario.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No investigu칠 activamente este enfoque, pero cre칠 un m칠todo rudimentario para probar esta teor칤a, y me pareci칩 prometedor. </font><font style="vertical-align: inherit;">Despu칠s de tomar dos puntos de colisi칩n conectados por un borde, me desplazo al punto medio del borde e intento dibujar el exterior perpendicular al borde. </font><font style="vertical-align: inherit;">Si no cruza el borde a una distancia muy corta, supongo que el borde es m치s complejo y agrego un nuevo punto objetivo para continuar la b칰squeda en esta 치rea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso este esquema simple crea muestras densas de muy alta calidad a lo largo de la frontera sin tomar muestras innecesarias de 치reas abiertas vecinas. </font><font style="vertical-align: inherit;">Aqu칤 hay un 치rea con varios bordes, pero sin marcar bordes:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/c9f/f6d/6dcc9ff6d78ddb981413ed4b795dcd5b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y aqu칤 est치 la misma 치rea con bordes de verificaci칩n: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/24d/6ba/bda24d6ba69e530c352a7d9a0e3c8a3a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No importa cu치n satisfecho est칠 con este resultado, me sorprendi칩 la falta de algoritmos significativamente mejores para el muestreo de bordes, e intentar칠 elegir algunos m칠todos m치s en el futuro. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Victorias r치pidas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso habiendo invertido solo un poco de tiempo en el desarrollo y creando un c칩digo bastante simple, he logrado que Walk Monster ya est칠 creando resultados bastante adecuados que puedan detectar problemas reales en el juego. </font><font style="vertical-align: inherit;">Aqu칤 hay ejemplos de problemas que encontr칠 durante el desarrollo del algoritmo:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ed/6f6/823/4ed6f6823ba2de2886a0fd83f702aa97.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las pendientes a los lados de esta plataforma no deben ser transitables, pero el jugador puede caminar sobre ellas. </font><font style="vertical-align: inherit;">Esto sucedi칩 porque en el c칩digo de movimiento del jugador hay una pobre forma patol칩gica de procesar la geometr칤a oblicua. </font><font style="vertical-align: inherit;">Ahora s칠 que est치 all칤, y lo corregir칠 cuando se trata de garantizar su fiabilidad.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/c38/b83/530c38b83fd5762238c3210d45e72d86.png"></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> supon칤a que el </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">Testigo</font></a><font style="vertical-align: inherit;"> era un juego contemplativo, pero pregunt치ndose por qu칠 parece que hay una piedra, aunque no lo es, no era uno de sus koans. </font><font style="vertical-align: inherit;">Como puede suponer, este problema surgi칩 porque alguien dej칩 la cantidad de colisi칩n en el juego despu칠s de eliminar la geometr칤a que lo denota. </font><font style="vertical-align: inherit;">Esto puede suceder f치cilmente, y es muy bueno que tengamos una herramienta que pueda reconocer r치pidamente tales errores para que las personas no tengan que hacerlo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/233/c86/122233c86cd7f7cf4f08e69cbb76404a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/616/377/012616377b5515b2ee23d71da78bdeeb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se supon칤a que estos objetos eran rocas intransitables, pero Walk Monster descubri칩 que esto no sucedi칩. </font><font style="vertical-align: inherit;">Peor a칰n, Walk Monster descubri칩 que, por alguna raz칩n, el camino es solo de una manera (de la captura de pantalla de izquierda a derecha), pero esto no deber칤a ser as칤. </font><font style="vertical-align: inherit;">Me asegur칠 de que el jugador realmente pueda hacer esto (lo logr칠). </font><font style="vertical-align: inherit;">춰Es muy interesante observar la ocurrencia de tales errores!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preguntas abiertas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando ve buenos resultados que pueden desarrollarse a칰n m치s, es inspirador. </font><font style="vertical-align: inherit;">Como dije, si elige un nombre adecuado para los archivos de origen, 춰todo ir치 como un reloj! </font><font style="vertical-align: inherit;">Pero todo este trabajo se complet칩 en unos pocos d칤as, por lo que est치 lejos de ser exhaustivo y se ha hecho mucho improvisado por completo. </font><font style="vertical-align: inherit;">Si tengo suficiente tiempo para el desarrollo adicional de estos sistemas, entonces vale la pena responder varias preguntas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, 쯤u칠 procesamiento posterior debe hacerse con los datos para que sea m치s f치cil de visualizar? </font><font style="vertical-align: inherit;">Ser치 dif칤cil para las personas descubrir una red no procesada de puntos y bordes, pero si mejora la descripci칩n de los datos, esto probablemente dificultar치 la evaluaci칩n de 치reas transitables dif칤ciles a primera vista.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, 쯖칩mo se pueden mejorar los patrones de muestreo alrededor de las fronteras para garantizar que se encuentre el n칰mero m치ximo de "agujeros"? 쮼xisten buenas maneras de caracterizar la reducci칩n de figuras en una red, y existen esquemas de teselaci칩n de alta calidad que maximicen la probabilidad de cruzar y atravesar estas figuras? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tercero, 쯤u칠 patrones de muestreo son mejores para llenar espacios, regulares o aleatorios? Puedo cambiar f치cilmente los criterios para elegir puntos objetivo para crear patrones m치s aleatorios, pero no est치 muy claro si vale la pena hacerlo y, de ser as칤, qu칠 tipos de patrones aleatorios ser치n mejores.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuarto, 쯤u칠 otra informaci칩n queremos obtener de los mapas de 치reas transitables si ya hemos aprendido c칩mo construirlas? Por ejemplo, es muy simple expandir un sistema existente con funciones tales como buscar rutas o mapas de distancia, de modo que el usuario pueda seleccionar un punto y solicitar la ruta m치s corta entre 칠l y alg칰n otro punto, o ver un mapa de calor de la distancia entre un punto y otros puntos del mapa. 쯉er치n 칰tiles tales consultas? 쯈u칠 otras consultas puedo usar?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por el momento, las visualizaciones de las 치reas transitables de Walk Monster son m치s que suficientes para mostrar que el c칩digo de movimiento del jugador es bastante malo. </font><font style="vertical-align: inherit;">Plane칠 pasar a crear un sistema para tarjetas de prueba nocturnas utilizando el m칠todo de simulaci칩n de entrada del usuario, pero es obvio que ya tenemos suficientes problemas para resolver sin este paso. </font><font style="vertical-align: inherit;">Por lo tanto, el siguiente paso ser치 aumentar la confiabilidad del c칩digo de movimiento del jugador. </font><font style="vertical-align: inherit;">Y mientras estoy trabajando en esto, me gustar칤a comprobar si es posible aumentar la velocidad de ejecuci칩n en uno o dos 칩rdenes de magnitud, porque mientras el trabajo de Walk Monster se ralentiza mucho por el sistema de frenos de colisiones.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es423519/">https://habr.com/ru/post/es423519/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es423505/index.html">Zuckerberg vende acciones de Facebook por $ 13 mil millones para que "nuestros ni침os nunca tengan que enfermarse"</a></li>
<li><a href="../es423507/index.html">C칩mo ahorrar memoria en las pesta침as del navegador, pero no perder su contenido. La experiencia del equipo Yandex.Browser</a></li>
<li><a href="../es423511/index.html">Interceptar la instalaci칩n de Firefox y Chrome en Windows 10</a></li>
<li><a href="../es423513/index.html">Ahorramos en un controlador RAID, o c칩mo alimentar a Varia con Iops</a></li>
<li><a href="../es423515/index.html">Est치 SECO bien o puede romper O de S칍LIDO</a></li>
<li><a href="../es423521/index.html">Siete reglas generales para experimentar con sitios web</a></li>
<li><a href="../es423523/index.html">Sensor combinado, con preferencia y poetas</a></li>
<li><a href="../es423527/index.html">Las aplicaciones para ni침os recopilan datos personales de forma masiva y los transmiten a terceros</a></li>
<li><a href="../es423529/index.html">쯈u칠 necesita todo el equipo para trabajar? 쮺칩mo arrastrar a todos al sistema de gesti칩n de proyectos?</a></li>
<li><a href="../es423531/index.html">Evoluci칩n de la arquitectura m칩vil de Reddit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>