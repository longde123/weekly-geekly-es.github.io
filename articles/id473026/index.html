<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘´ğŸ½ ğŸ‘©ğŸ½ ğŸ”ï¸ Om-yum-yum dan validasi data ğŸ¤­ ğŸ¤µ ğŸ¦†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Mari kita bicara sedikit tentang validasi data. Apa yang rumit dan mengapa harus dibutuhkan, katakanlah, dalam sebuah proyek yang ditul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Om-yum-yum dan validasi data</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473026/"><p> Halo semuanya!  Mari kita bicara sedikit tentang validasi data.  Apa yang rumit dan mengapa harus dibutuhkan, katakanlah, dalam sebuah proyek yang ditulis dalam naskah?  Mengetik naskah cukup baik mengontrol semuanya, tetap untuk memeriksa input pengguna maksimum.  Artinya, untuk melemparkan selusin pelanggan tetap ke dalam proyek dan semuanya, tampaknya, bisa menutup topik, tapi ... Jauh dari biasanya, dan dalam kasus web, hampir tidak pernah, seluruh proyek dalam basis kode tunggal dan menggunakan jenis yang sama.  Di persimpangan basis kode seperti itu, situasi muncul ketika menunggu tidak sesuai dengan kenyataan dan di sini naskah bukan lagi asisten.  Beberapa contoh: </p><a name="habracut"></a><br><ul><li> Bagian klien dari aplikasi menerima data dari API dan memvalidasinya.  Pertama, API dapat tiba-tiba dan kadang-kadang tanpa pemberitahuan berubah, dan kedua, "orang-orang server" sendiri kadang-kadang tidak tahu apa yang dapat dilakukan API mereka, misalnya, di beberapa bidang, alih-alih array yang dijamin, bahkan jika kosong, bulan purnama mungkin diberikan <code>null</code> .  Saat menggambarkan data pada klien, programmer tampaknya menentukan apa yang klien tahu bagaimana bekerja dengan dan jika ada masalah, maka jauh lebih menyenangkan untuk segera melihat pesan di konsol tentang sumber masalah, daripada mengambil bug yang tidak bisa dimengerti yang sudah keluar dari lapisan tampilan (dan itu baik jika segera diperhatikan).  Juga sekarang sudah ada solusi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> ) yang memungkinkan transfer jenis dari server ke klien.  Saya belum mencoba untuk melakukannya, tetapi sangat mungkin bahwa ini adalah masa depan. </li><li>  Situasi sebaliknya adalah ketika server memeriksa parameter yang dikirim untuk segera menghentikan pemrosesan permintaan jika mereka tidak memenuhi yang diharapkan.  Saya pikir tidak perlu ada perincian tentang mengapa ini penting untuk dilakukan. </li><li>  Validasi data sebelum menyimpannya dalam database juga tidak akan berlebihan.  Misalnya, Anda dapat melihat bagaimana itu diatur dalam salah satu sepeda saya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MaraquiaORM # Validasi</a> . </li></ul><br><p>  Saya pikir contoh-contohnya cukup meyakinkan dan sekarang tidak ada perasaan yang dapat Anda lakukan dengan pelanggan tetap yang sederhana, karena ini bukan hanya tentang input pengguna, tetapi tentang validasi kompleks, biasanya bersarang pada beberapa level data.  Perpustakaan khusus sudah diperlukan di sini.  Dan tentu saja ada!  Kebetulan bahwa selama 10 tahun terakhir, setiap kali saya memulai proyek baru, saya mencoba menggunakan perpustakaan lain di dalamnya, menyesuaikannya dengan kebutuhan saya.  Dan setiap kali terjadi kesalahan, yang kadang-kadang mengarah pada penggantian subjek tes di tengah perkembangan aktif.  Saya tidak akan berbicara tentang semua opsi yang saya pelajari, saya hanya akan mengatakan tentang yang diuji dalam proyek saat ini. </p><br><h4 id="type-check">  ketik-cek </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </p><br><p>  Perpustakaan kecil dan cukup nyaman.  Rangkaian ini digambarkan sebagai string.  Menggunakan string multi-line, Anda dapat menggambarkan struktur yang cukup rumit: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">`{ ID: String, creator: { fname: String | Null, mname: String | Null, lname: String | Null, email: [String] } | Undefined, sender: Maybe { name: String, email: String }, type: Number, subject: String, ... }`</span></span></code> </pre> <br><p>  Ada beberapa kekurangan yang cukup serius: </p><br><ul><li>  IDE sama sekali tidak membantu dengan sekumpulan skema, yang sangat mengganggu ketika beralih ke naskah. </li><li>  Pesan kesalahan yang hampir tidak berguna.  Saya belum pernah menggunakan perpustakaan ini selama lebih dari setahun dan mungkin ada sesuatu yang berubah (dilihat dari kodenya, tidak).  Pesan dalam gaya "string yang diharapkan, diterima nol".  Sekarang bayangkan, Anda memiliki array potongan untuk 200 objek, masing-masing memiliki bidang dengan string, dan hanya dalam satu objek salah satu bidang telah rusak.  Bagaimana menemukan bidang ini?  Lihat semua 200 item?  Saya menderita berkali-kali dan itu benar <s>-</s> benar <s>menghancurkan hidup saya,</s> merusak kesan perpustakaan.  Biasanya saya tidak ingin tahu apa yang diharapkan dan diterima di sana, tetapi saya ingin membuka skema data dan menemukan bidang yang diperlukan di dalamnya dan sama dengan data itu sendiri.  Dengan kata lain, dalam pesan kesalahan, sangat penting untuk memiliki keypath ke tempat yang tepat dalam data / skema, dan apa yang diharapkan di sana dan tiba sama sekali dapat dihilangkan. </li><li>  Cukup sepele, tentu saja, tetapi lekukan dalam contoh di atas tidak akan hilang ketika kode dikompresi. </li></ul><br><h4 id="joi">  Joi </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> <br>  Versi Browser: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">joi-browser</a> </p><br><p>  Mungkin perpustakaan paling terkenal tentang hal ini dengan banyak fitur dan API tanpa akhir.  Pada awalnya saya menggunakannya di server dan itu menunjukkan dirinya dengan sempurna.  Pada titik tertentu, saya memutuskan untuk menggantinya dengan <code>type-check</code> pada klien.  Pada saat itu, saya hampir tidak mengontrol ukuran bungkusan, tidak ada masalah dengan ini.  Namun seiring berjalannya waktu, aplikasi ini berkembang pesat dan di Internet seluler, pengunduhan aplikasi pertama sama sekali tidak nyaman.  Diputuskan untuk mengatur pemuatan komponen yang malas.  Laporan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webpack-bundle-analyzer</a> menunjukkan sekelompok raksasa dalam bundel dan mereka semua dengan mudah pergi ke potongan yang dibuat oleh webpack.  Semuanya kecuali <code>Joi</code> .  Banyak komponen berkomunikasi dengan server dan semua respons server divalidasi, yaitu, memasukkan <code>Joi</code> ke dalam beberapa jenis chunk tidak masuk akal, itu hanya akan selalu memuat tepat setelah yang utama.  Pada titik tertentu, bundel utama tampak seperti ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tyts</a> .  Tentu saja, keinginan abadi muncul untuk melakukan sesuatu.  Saya menginginkan perpustakaan yang sama nyamannya, tetapi jauh lebih sedikit. </p><br><h4 id="yup">  Yup </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </p><br><p>  Dalam readme mereka berjanji tentang <code>Joi</code> sama, tetapi dalam ukuran cocok untuk frontend.  Bahkan, itu hanya sekitar dua kali lebih kecil, yaitu, <code>Yup</code> masih perpustakaan terbesar di bundel utama.  Selain itu, kerugian tambahan muncul: </p><br><ul><li>  Pustaka default melewatkan semua yang <code>undefined</code> .  Terus-menerus menulis <code>.required()</code> tidak terlalu menyenangkan, dan saya suka lebih baik ketika awalnya semuanya tidak mungkin dan di mana diizinkan.  <code>Joi</code> memiliki opsi <code>presence: 'required'</code> untuk mengkonfigurasi perilaku ini.  Saya membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">permintaan dengan nomor neraka 666</a> , tetapi sejauh ini penulis diam. </li><li>  Tidak ada cara untuk memeriksa nilai suatu objek, memungkinkan semua kunci.  <code>Joi</code> menggunakan <a href="">object.pattern</a> untuk ini, dengan argumen pertama <a href="">menerima</a> string apa pun.  Mungkin masih mungkin untuk entah bagaimana keluar dari sana, dan penulis dapat memperbaiki minus pertama, tetapi mengingat ukurannya, saya tidak ingin menunggu atau mengedit sesuatu sendiri. </li></ul><br><h4 id="ow">  Ow </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Github</a> </p><br><p>  Pemohon berikutnya akhirnya ternyata sangat kecil, ditambah lagi dia tidak membuatnya terus-menerus menulis <code>()</code> mana Anda dapat melakukannya tanpa itu.  Misalnya, Anda dapat menulis validator yang memungkinkan string atau <code>undefined</code> sebagai berikut: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> optionalStringValidator = ow.optional.string; ow(optionalStringValidator, <span class="hljs-string"><span class="hljs-string">'1'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Ok ow(optionalStringValidator, undefined); // Ok</span></span></code> </pre> <br><p>  Hebat!  Bagaimana dengan <code>null</code> ?  Membalik semua dokumentasi, saya menemukan metode berikut: </p><br><pre> <code class="javascript hljs">ow.any(ow.optional.string, ow.null);</code> </pre> <br><p>  Oh horor!  Ketika saya mencoba untuk menulis ulang bagian dari validasi dalam proyek, saya hampir mematahkan jari saya saat mengetik ini.  Saya <code>ow.nullable</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">masalah</a> menambahkan <code>ow.nullable</code> , yang dikirim ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Singkatnya, mereka mengatakan bahwa <code>null</code> tidak diperlukan sama sekali.  Argumen yang diberikan di sana juga cukup memadai mengingat baris pertama di readme mereka: </p><br><blockquote>  Validasi argumen fungsi untuk manusia </blockquote><p>  Yaitu, perpustakaan ini adalah untuk memvalidasi nilai-nilai yang datang sebagai argumen untuk fungsi.  Tampaknya, mereka tidak benar-benar mengandalkan struktur bersarang besar yang berasal dari server. <br>  Studi lebih lanjut dan upaya untuk menggunakan mengungkapkan beberapa fitur yang, sekali lagi, dijelaskan dengan baik oleh baris yang sama di readme, tetapi tidak cocok untuk saya.  Ini sebenarnya perpustakaan yang cukup bagus, hanya untuk beberapa keperluan lain. </p><br><hr><br><p>  Di sekitar sini, saya sudah benar-benar lelah untuk menyerah dan memutuskan untuk menulis perpustakaan saya dengan blackjack dan perawan.  Ya, ya, saya kembali kepada Anda dengan sepeda berikutnya :).  Bertemu: </p><br><h2 id="omyumyum">  Omyumyum </h2><br><p>  Beberapa contoh: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> om <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'omyumyum'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isOptionalNumber = om.number.or.undefined; isOptionalNumber(<span class="hljs-string"><span class="hljs-string">'1'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt; false isOptionalNumber(1); // =&gt; true isOptionalNumber(undefined); // =&gt; true</span></span></code> </pre> <br><p>  <code>.or</code> dapat digunakan sebanyak yang Anda inginkan dengan meningkatkan opsi yang layak: </p><br><pre> <code class="javascript hljs">om.number.or.string.or.null.or.undefined;</code> </pre> <br><p>  Dalam hal ini, fungsi yang hampir biasa dihasilkan secara konstan yang mengambil argumen apa pun dan mengembalikan <code>boolean</code> . <br>  Jika Anda ingin fungsi untuk melempar kesalahan jika tes gagal: </p><br><pre> <code class="javascript hljs">om(om.number, <span class="hljs-string"><span class="hljs-string">'1'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  TypeError</span></span></code> </pre> <br><p>  Atau dengan kari: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isNumberOrThrow = om(om.number); isNumberOrThrow(<span class="hljs-string"><span class="hljs-string">'1'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  TypeError</span></span></code> </pre> <br><p>  Fungsi yang dihasilkan tidak cukup biasa, karena memiliki metode tambahan.  <code>.or</code> sudah ditampilkan, bagian dari metode akan bergantung pada tipe yang dipilih (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API</a> ), misalnya string dapat ditingkatkan dengan ekspresi reguler: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isNonEmptyString = om.string.pattern(<span class="hljs-regexp"><span class="hljs-regexp">/\S/</span></span>); <span class="hljs-comment"><span class="hljs-comment">// == `om.string.nonEmpty` isNonEmptyString(' '); // =&gt; false isNonEmptyString('1'); // =&gt; true</span></span></code> </pre> <br><p>  Dan untuk objek, Anda dapat menentukan bentuknya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isUserData = om.object.shape({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: om.string, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: om.number.or.vacuum <span class="hljs-comment"><span class="hljs-comment">// `.or.vacuum` == `.or.null.or.undefined` }); isUserData({}); // =&gt; false isUserData({ age: 20 }) // =&gt; false isUserData({ name: '' }); // =&gt; true isUserData({ name: '', age: null }); // =&gt; true isUserData({ name: '', age: 20 }); // =&gt; true</span></span></code> </pre> <br><p>  Keypath yang dijanjikan ke tempat masalah: </p><br><pre> <code class="javascript hljs">om(om.array.of(om.object.shape({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: om.string })), [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }]); <span class="hljs-comment"><span class="hljs-comment">//  TypeError('Type mismatch at "[1].name"')</span></span></code> </pre> <br><p>  Jika fitur <code>.custom(validator: (value: any) =&gt; boolean)</code> tidak cukup, Anda selalu dapat menggunakan <code>.custom(validator: (value: any) =&gt; boolean)</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isEmailOrPhone = om.custom(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'is-email'</span></span>)).or.custom(<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'is-phone'</span></span>)); isEmailOrPhone(<span class="hljs-string"><span class="hljs-string">'test@test.test'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt; true</span></span></code> </pre> <br><p>  Stok juga diharapkan. <code>.and</code> digunakan untuk menggabungkan dan meningkatkan jenis: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isNonZeroString = om.string.and.custom(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// == `om.string.nonZero` isNonZeroString(''); // =&gt; false isNonZeroString('1'); // =&gt; true</span></span></code> </pre> <br><p>  <code>.and</code> lebih diutamakan daripada <code>.custom()</code> , tetapi karena <code>.custom()</code> menerima validator dengan bentuk yang sama persis seperti yang dibuat oleh perpustakaan, ini dapat dielakkan: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      `age`,   `birthday` om.object.shape({ name: om.string }).and.custom( om.object.shape({ age: om.number }) .or.object.shape({ birthday: om.date })] );</span></span></code> </pre> <br><p>  Anda dapat terus meningkatkan validator yang dibuat sebelumnya.  Yang lama tidak rusak sama sekali.  Mari kita coba untuk memperbaiki <code>isUserData</code> dibuat sebelumnya: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isImprovedUserData = isUserData.and.object.shape({ <span class="hljs-attr"><span class="hljs-attr">friends</span></span>: om.array.of(isUserData).or.vacuum }); isImprovedUserData({ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-attr"><span class="hljs-attr">friends</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">18</span></span> }] }); <span class="hljs-comment"><span class="hljs-comment">// =&gt; true</span></span></code> </pre> <br><p>  Nah, tinggal <code>.not</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isNotVacuum = om.not.null.and.not.undefined; <span class="hljs-comment"><span class="hljs-comment">// == `om.not.vacuum` isNotVacuum(1); // =&gt; true isNotVacuum(null); // =&gt; false isNotVacuum(undefined); // =&gt; false</span></span></code> </pre> <br><p>  Metode lain yang tersedia dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API</a> perpustakaan. </p><br><h4 id="plyusy-biblioteki">  Keuntungan perpustakaan: </h4><br><ul><li>  Sintaksis linier dengan <code>.not</code> , <code>.not</code> , <code>.not</code> dan minimum tanda kurung.  Dalam kombinasi dengan naskah naskah autocomplete, himpunan berubah menjadi kesenangan. </li><li>  Berat kecilnya bahkan dibandingkan dengan <code>Ow</code> (hampir 10 kali lebih sedikit (minify + gzip)), dan dibandingkan dengan <code>Joi</code> perpustakaan itu seperti bulu di sebelah gunung. </li><li>  Nama yang bagus :) </li></ul><br><h4 id="minusy-biblioteki">  Kontra perpustakaan: </h4><br><ul><li>  Lebih sedikit jenis dan pengubahnya.  Dan tidak mungkin ada lebih banyak.  Ketiga skenario penggunaan yang diberikan di awal artikel (sesuatu tentang persimpangan dan basis kode) mengasumsikan transfer data teks biasa, dalam kebanyakan kasus ini adalah JSON.  Artinya, menurut pendapat saya, perpustakaan seperti itu harus mendukung jenis yang mungkin di JSON, ditambah jenis yang <code>undefined</code> dan beberapa yang umum digunakan.  <code>Ow</code> sama <code>Ow</code> untuk beberapa alasan, dijejali dengan dukungan untuk semua jenis array yang diketik dan omong kosong lainnya.  Saya pikir ini berlebihan. </li><li>  Tidak dapat mengonversi data seperti <code>Joi</code> .  Saya pikir <code>Joi</code> juga sangat buruk.  Setidaknya saya tidak memiliki cukup kemampuannya dan, jika perlu, saya melakukan transformasi dengan alat yang sama sekali berbeda.  Mungkin ini adalah arah pengembangan lebih lanjut untuk <code>omyumyum</code> . </li></ul><br><p>  Itu saja!  Jika Anda menyukai artikel, suka, berlangganan saluran dan semoga sukses)). </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id473026/">https://habr.com/ru/post/id473026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id473012/index.html">Hasil Konferensi Mitra Advantech di Moskow</a></li>
<li><a href="../id473014/index.html">Pengantar Otorisasi Kubernetes Konsul Hashicorp</a></li>
<li><a href="../id473016/index.html">Model bisnis naik-memanggil yang menguntungkan diimplementasikan dengan mengembangkan aplikasi taksi mirip Uber</a></li>
<li><a href="../id473018/index.html">Kiat untuk calon dari programmer yang melakukan wawancara di Facebook</a></li>
<li><a href="../id473024/index.html">Apa yang perlu Anda ketahui tentang Internet: program pendidikan dasar</a></li>
<li><a href="../id473028/index.html">Di Rusia mulai mengimpor limbah radioaktif dari Eropa? Diurutkan</a></li>
<li><a href="../id473032/index.html">"Harapan adalah strategi yang buruk." SRE intensif di Moskow, 3-5 Februari</a></li>
<li><a href="../id473034/index.html">Bagaimana cara duduk timlid</a></li>
<li><a href="../id473036/index.html">Android Camera2 API dari teko, bagian 3. Media Codec dan streaming video melalui UDP</a></li>
<li><a href="../id473038/index.html">Kode morse 8-bit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>