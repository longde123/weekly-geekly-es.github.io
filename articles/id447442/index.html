<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⭕️ 👨‍🔬 👨🏻‍🏭 Memperkenalkan shell-operator: membuat operator untuk Kubernet lebih mudah 💃🏿 📷 🤛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sudah ada artikel di blog kami tentang kemampuan operator di Kubernetes dan cara menulis operator sederhana sendiri . Kali ini kami ingin menyampaikan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperkenalkan shell-operator: membuat operator untuk Kubernet lebih mudah</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/447442/">  Sudah ada artikel di blog kami tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan operator di Kubernetes</a> dan cara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis operator sederhana sendiri</a> .  Kali ini kami ingin menyampaikan kepada Anda solusi Open Source kami, yang membawa kreasi operator ke tingkat yang sangat mudah - berkenalan dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator shell</a> ! <br><br><h2>  Mengapa </h2><br>  Gagasan operator shell cukup sederhana: berlangganan acara dari objek Kubernetes, dan ketika menerima acara ini, mulai program eksternal, berikan informasi tentang acara tersebut: <br><br><img src="https://habrastorage.org/webt/o6/13/83/o61383z0_6avp-0dbdjlr2fgfyq.png"><a name="habracut"></a><br><br>  Perlunya muncul bersama kami ketika, selama operasi cluster, tugas-tugas kecil mulai tampak bahwa kami benar-benar ingin mengotomatisasi dengan cara yang benar.  Semua tugas kecil ini diselesaikan dengan bantuan skrip bash sederhana, meskipun, seperti yang Anda tahu, operator lebih baik ditulis dalam Golang.  Jelas, berinvestasi dalam pengembangan operator skala penuh untuk setiap tugas kecil seperti itu tidak efisien. <br><br><h2>  Operator dalam 15 menit </h2><br>  Mari kita lihat contoh apa yang dapat diotomatiskan dalam kluster Kubernetes dan bagaimana operator shell akan membantu.  Contohnya adalah sebagai berikut: menduplikasi rahasia untuk mengakses register buruh pelabuhan. <br><br>  Pod yang menggunakan gambar dari registri pribadi harus berisi dalam manifesnya tautan ke rahasia dengan data untuk mengakses registri.  Rahasia ini harus dibuat di setiap namespace sebelum membuat pod.  Sangat mungkin untuk melakukan ini secara manual, tetapi jika kita mengatur lingkungan yang dinamis, maka namespace untuk satu aplikasi akan menjadi banyak.  Dan jika aplikasi juga bukan 2-3 ... jumlah rahasia menjadi sangat besar.  Dan satu hal lagi tentang rahasia: Saya ingin mengubah kunci untuk mengakses registri dari waktu ke waktu.  Akibatnya, <b>operasi manual</b> sebagai solusi sama <b>sekali tidak efektif</b> - Anda perlu mengotomatiskan pembuatan dan pemutakhiran rahasia. <br><br><h3>  Otomatisasi mudah </h3><br>  Kami akan menulis skrip shell yang berjalan sekali setiap N detik dan memeriksa rahasia namespace, dan jika tidak ada rahasia, maka itu dibuat.  Keuntungan dari solusi ini adalah ia terlihat seperti skrip shell di cron - pendekatan klasik dan mudah dipahami.  Downside adalah bahwa dalam interval antara peluncurannya namespace baru dapat dibuat dan untuk beberapa waktu akan tetap tanpa rahasia, yang akan menyebabkan kesalahan dalam meluncurkan pod. <br><br><h3>  Otomasi dengan shell-operator </h3><br>  Agar skrip kami berfungsi dengan benar, peluncuran cron klasik perlu diganti dengan peluncuran ketika acara namespace ditambahkan: dalam hal ini, Anda dapat mengatur untuk membuat rahasia sebelum menggunakannya.  Mari kita lihat bagaimana mengimplementasikan ini menggunakan shell-operator. <br><br>  Pertama, mari kita parsing skrip.  Skrip dalam hal shell-operator disebut kait.  Setiap kait saat startup dengan flag <code>--config</code> memberi tahu operator shell tentang binding-nya, mis.  oleh acara apa yang perlu diluncurkan.  Dalam kasus kami, kami akan menggunakan <code>onKubernetesEvent</code> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash if [[ $1 == "--config" ]] ; then cat &lt;&lt;EOF { "onKubernetesEvent": [ { "kind": "namespace", "event":["add"] } ]} EOF fi</span></span></code> </pre> <br>  Dijelaskan di sini bahwa kami tertarik pada acara untuk menambahkan ( <code>add</code> ) objek dari <code>namespace</code> . <br><br>  Sekarang Anda perlu menambahkan kode yang akan dieksekusi ketika acara terjadi: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash if [[ $1 == "--config" ]] ; then #  cat &lt;&lt;EOF { "onKubernetesEvent": [ { "kind": "namespace", "event":["add"] } ]} EOF else # : # ,  namespace  createdNamespace=$(jq -r '.[0].resourceName' $BINDING_CONTEXT_PATH) #      kubectl create -n ${createdNamespace} -f - &lt;&lt;EOF apiVersion: v1 kind: Secret metadata: ... data: ... EOF fi</span></span></code> </pre> <br>  Hebat!  Hasilnya adalah sebuah skrip kecil yang indah.  Untuk "menghidupkan kembali" itu, dua langkah tetap: untuk menyiapkan gambar dan menjalankannya di cluster. <br><br><h4>  Mempersiapkan gambar dengan kail </h4><br>  Jika Anda melihat skrip, Anda dapat melihat bahwa perintah <code>kubectl</code> dan <code>jq</code> .  Ini berarti bahwa gambar harus memiliki hal-hal berikut: kait kami, operator shell yang akan memantau acara dan menjalankan kait, serta perintah yang digunakan oleh kait (kubectl dan jq).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hub.docker.com</a> sudah memiliki gambar siap pakai di mana shell-operator, kubectl dan jq dikemas.  Tetap menambahkan pengait dengan <code>Dockerfile</code> sederhana: <br><br><pre> <code class="plaintext hljs">$ cat Dockerfile FROM flant/shell-operator:v1.0.0-beta.1-alpine3.9 ADD namespace-hook.sh /hooks $ docker build -t registry.example.com/my-operator:v1 . $ docker push registry.example.com/my-operator:v1</code> </pre> <br><h4>  Peluncuran cluster </h4><br>  Sekali lagi, mari kita lihat hook dan kali ini tuliskan tindakan apa dan dengan objek apa yang dilakukan di cluster: <br><br><ol><li>  Berlangganan acara namespace </li><li>  menciptakan rahasia di ruang nama selain tempat menjalankannya. </li></ol><br>  Ternyata pod di mana gambar kita akan diluncurkan harus memiliki izin untuk tindakan ini.  Ini dapat dilakukan dengan membuat ServiceAccount Anda sendiri.  Izin harus dibuat dalam bentuk ClusterRole dan ClusterRoleBinding, karena  kami tertarik pada objek dari seluruh cluster. <br><br>  Deskripsi akhir dalam YAML adalah sesuatu seperti ini: <br><br><pre> <code class="plaintext hljs">--- apiVersion: v1 kind: ServiceAccount metadata: name: monitor-namespaces-acc --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRole metadata: name: monitor-namespaces rules: - apiGroups: [""] resources: ["namespaces"] verbs: ["get", "watch", "list"] - apiGroups: [""] resources: ["secrets"] verbs: ["get", "list", "create", "patch"] --- apiVersion: rbac.authorization.k8s.io/v1beta1 kind: ClusterRoleBinding metadata: name: monitor-namespaces roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: monitor-namespaces subjects: - kind: ServiceAccount name: monitor-namespaces-acc namespace: example-monitor-namespaces</code> </pre> <br>  Anda dapat menjalankan gambar yang dirakit dalam bentuk Penerapan sederhana: <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment metadata: name: my-operator spec: template: spec: containers: - name: my-operator image: registry.example.com/my-operator:v1 serviceAccountName: monitor-namespaces-acc</code> </pre> <br><br>  Untuk kenyamanan, namespace terpisah dibuat di mana shell-operator akan diluncurkan dan manifes yang dibuat diterapkan: <br><br><pre> <code class="plaintext hljs">$ kubectl create ns example-monitor-namespaces $ kubectl -n example-monitor-namespaces apply -f rbac.yaml $ kubectl -n example-monitor-namespaces apply -f deployment.yaml</code> </pre><br><br>  Itu saja: operator shell akan mulai, berlangganan acara pembuatan namespace dan mulai kail bila perlu. <br><br><img src="https://habrastorage.org/webt/km/wj/tz/kmwjtzvc6gcy3650i1xdta5apyk.png"><br><br>  Dengan demikian, <b>skrip shell sederhana berubah menjadi operator nyata untuk Kubernetes</b> dan berfungsi sebagai bagian integral dari kluster.  Dan semua ini - tanpa proses rumit mengembangkan operator di Golang: <br><br><img src="https://habrastorage.org/webt/e6/1o/gq/e61ogqseislsnug0nkfyr7apk1y.png"><br><br><div class="spoiler">  <b class="spoiler_title">Ada ilustrasi lain tentang hal ini ...</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/md/af/3s/mdaf3sq9bxbdtuue9oyigwiy63k.png"><br><br>  <i>Kami akan mengungkapkan maknanya secara lebih rinci di salah satu publikasi berikut.</i>  <i><b>DIPERBARUI</b> (1 Mei 2019): lihat “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperluas dan memperluas Kubernet (laporan ulasan dan video)</a> ”.</i> </div></div><br><h2>  Penyaringan </h2><br>  Melacak objek itu baik, tetapi sering kali perlu merespons <b>perubahan dalam beberapa properti objek</b> , misalnya, pada perubahan jumlah replika di Deployment, atau pada perubahan label objek. <br><br>  Ketika suatu peristiwa tiba, operator shell menerima manifes JSON objek.  Anda dapat memilih properti yang menarik bagi kami di JSON ini dan menjalankan hook <b>hanya</b> ketika mereka berubah.  Untuk melakukan ini, bidang <code>jqFilter</code> , di mana Anda perlu menentukan ekspresi jq yang akan diterapkan pada manifes JSON. <br><br>  Misalnya, untuk menanggapi perubahan label pada objek Penempatan, Anda perlu memfilter bidang <code>labels</code> dari bidang <code>metadata</code> .  Konfigurasi akan seperti ini: <br><br><pre> <code class="bash hljs">cat &lt;&lt;EOF { <span class="hljs-string"><span class="hljs-string">"onKubernetesEvent"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"deployment"</span></span>, <span class="hljs-string"><span class="hljs-string">"event"</span></span>:[<span class="hljs-string"><span class="hljs-string">"update"</span></span>], <span class="hljs-string"><span class="hljs-string">"jqFilter"</span></span>: <span class="hljs-string"><span class="hljs-string">".metadata.labels"</span></span> } ]} EOF</code> </pre> <br>  Ungkapan ini di jqFilter mengubah manifest JSON panjang Deployment menjadi JSON pendek dengan label: <br><br><img src="https://habrastorage.org/webt/pk/o7/hv/pko7hvuzfnn7nziubhfpuo0cas0.png"><br><br>  Shell-operator hanya akan memicu pengait ketika JSON pendek ini berubah dan perubahan pada properti lainnya diabaikan. <br><br><h2>  Konteks peluncuran hook </h2><br>  Konfigurasi hook memungkinkan Anda menentukan beberapa opsi untuk acara - misalnya, 2 opsi untuk acara dari Kubernetes dan 2 jadwal: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"onKubernetesEvent"</span></span>:[ {<span class="hljs-string"><span class="hljs-string">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"OnCreatePod"</span></span>, <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"pod"</span></span>, <span class="hljs-string"><span class="hljs-string">"event"</span></span>:[<span class="hljs-string"><span class="hljs-string">"add"</span></span>] }, {<span class="hljs-string"><span class="hljs-string">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"OnModifiedNamespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"kind"</span></span>: <span class="hljs-string"><span class="hljs-string">"namespace"</span></span>, <span class="hljs-string"><span class="hljs-string">"event"</span></span>:[<span class="hljs-string"><span class="hljs-string">"update"</span></span>], <span class="hljs-string"><span class="hljs-string">"jqFilter"</span></span>: <span class="hljs-string"><span class="hljs-string">".metadata.labels"</span></span> } ], <span class="hljs-string"><span class="hljs-string">"schedule"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"every 10 min"</span></span>, <span class="hljs-string"><span class="hljs-string">"crontab"</span></span>:<span class="hljs-string"><span class="hljs-string">"0 */10 * * * *"</span></span> }, {<span class="hljs-string"><span class="hljs-string">"name"</span></span>:<span class="hljs-string"><span class="hljs-string">"on Mondays at 12:10"</span></span>, <span class="hljs-string"><span class="hljs-string">"crontab"</span></span>: <span class="hljs-string"><span class="hljs-string">"0 10 12 * * 1"</span></span> ]}</code> </pre> <br>  <i>Penyimpangan kecil: ya, operator shell mendukung <b>menjalankan skrip gaya crontab</b> .</i>  <i>Anda dapat membaca lebih lanjut di <a href="">dokumentasi</a> .</i> <br><br>  Untuk membedakan mengapa hook diluncurkan, operator shell membuat file sementara dan meneruskan path ke <code>BINDING_CONTEXT_TYPE</code> di variabel <code>BINDING_CONTEXT_TYPE</code> .  File tersebut berisi deskripsi JSON tentang alasan pengait dimulai.  Misalnya, setiap 10 menit sebuah pengait akan dimulai dengan konten berikut: <br><br><pre> <code class="plaintext hljs">[{ "binding": "every 10 min"}]</code> </pre> <br>  ... dan pada hari Senin akan dimulai dengan ini: <br><br><pre> <code class="plaintext hljs">[{ "binding": "every 10 min"}, { "binding": "on Mondays at 12:10"}]</code> </pre> <br>  Untuk <code>onKubernetesEvent</code> akan ada lebih banyak JSON yang dipecat sejak itu  itu berisi deskripsi objek: <br><br><pre> <code class="plaintext hljs">[ { "binding": "onCreatePod", "resourceEvent": "add", "resourceKind": "pod", "resourceName": "foo", "resourceNamespace": "bar" } ]</code> </pre> <br>  Isi kolom dapat dipahami dari namanya, dan lebih terinci - baca di <a href="">dokumentasi</a> .  Contoh untuk mendapatkan nama sumber daya dari bidang <code>resourceName</code> menggunakan jq telah ditunjukkan di sebuah pengait yang mereplikasi rahasia: <br><br><pre> <code class="bash hljs">jq -r <span class="hljs-string"><span class="hljs-string">'.[0].resourceName'</span></span> <span class="hljs-variable"><span class="hljs-variable">$BINDING_CONTEXT_PATH</span></span></code> </pre> <br>  Demikian pula, Anda bisa mendapatkan bidang yang tersisa. <br><br><h2>  Apa selanjutnya </h2><br>  Di repositori proyek, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">direktori / contoh</a> , ada contoh kait yang siap dijalankan di kluster.  Saat menulis kait Anda, Anda dapat menganggapnya sebagai dasar. <br><br>  Ada dukungan untuk mengumpulkan metrik menggunakan Prometheus - metrik yang tersedia ditulis di bagian <a href="">METRICS</a> . <br><br>  Seperti yang Anda duga, operator shell ditulis dalam Go dan didistribusikan di bawah lisensi Open Source (Apache 2.0).  Kami akan berterima kasih atas bantuan apa pun dalam mengembangkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek di GitHub</a> : tanda bintang, masalah, dan menarik permintaan. <br><br>  Membuka tabir kerahasiaan, kami juga menginformasikan bahwa operator-shell adalah bagian <b>kecil</b> dari sistem kami, yang dapat terus memperbarui pengaya yang dipasang di kluster Kubernetes dan melakukan berbagai tindakan otomatis.  Kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang sistem ini secara lebih rinci pada hari Senin di HighLoad ++ 2019 di St. Petersburg - video dan transkrip laporan ini akan segera diterbitkan. <br><br>  Kami memiliki rencana untuk membuka sisa sistem ini: addon-operator dan koleksi kait dan modul kami.  Omong-omong, addon-operator sudah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia di GitHub</a> , tetapi dokumentasi untuknya masih dalam proses.  Pelepasan koleksi modul direncanakan di musim panas. <br><br>  Tetap disini! <br><br><h2>  PS </h2><br>  Baca juga di blog kami: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah mudah dan nyaman menyiapkan cluster Kubernetes?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Umumkan operator tambahan</a> ”; </li><li>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperluas dan melengkapi Kubernetes (review dan laporan video)</a> ”; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator untuk Kubernetes: cara menjalankan aplikasi stateful</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperkenalkan plugin baru untuk Grafana - panel Statusmap</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memperkenalkan loghouse - sistem open source untuk bekerja dengan log di Kubernetes</a> "; </li><li>  "Kami secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">resmi memperkenalkan utilitas dapp - DevOps untuk mempertahankan CI / CD</a> ." </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447442/">https://habr.com/ru/post/id447442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447430/index.html">IntelliJ IDEA 2019.1: Kustomisasi tema antarmuka, beralih ekspresi dari Java 12, debugging di dalam wadah Docker</a></li>
<li><a href="../id447434/index.html">Dengan cinta dari Stepik: platform pendidikan Hyperskill</a></li>
<li><a href="../id447436/index.html">Webinar "Mengapa kita perlu penguji?"</a></li>
<li><a href="../id447438/index.html">Tes unittest dan abstrak</a></li>
<li><a href="../id447440/index.html">RBKmoney Pembayaran di bawah tenda - logika platform pembayaran</a></li>
<li><a href="../id447446/index.html">Lokakarya IBM: musim semi-musim panas 2019 - kecerdasan buatan, pengembangan cloud, chat bot, blockchain dan teknologi lainnya</a></li>
<li><a href="../id447448/index.html">Evolusi Kecerdasan: Awal</a></li>
<li><a href="../id447450/index.html">Memecah "celah" sederhana dengan Ghidra - Bagian 1</a></li>
<li><a href="../id447452/index.html">Keamanan Rantai Pasokan: "Seandainya saya Negara Bangsa ..."</a></li>
<li><a href="../id447454/index.html">Kontrol Tampilan Tujuh Segmen FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>