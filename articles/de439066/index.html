<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎬 🤹🏾 ♑️ Betriebssystem auf Rust. Seitenspeicher: Erweitert 💌 👩🏽‍🤝‍👨🏼 🙍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird erläutert, wie der Kernel des Betriebssystems auf physische Speicherrahmen zugreifen kann. Wir werden die Funktion zum Konverti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Betriebssystem auf Rust. Seitenspeicher: Erweitert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439066/">  In diesem Artikel wird erläutert, wie der Kernel des Betriebssystems auf physische Speicherrahmen zugreifen kann.  Wir werden die Funktion zum Konvertieren virtueller Adressen in physische Adressen untersuchen.  Wir werden auch herausfinden, wie Sie neue Zuordnungen in Seitentabellen erstellen. <br><br>  Dieser Blog ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub veröffentlicht</a> .  Wenn Sie Fragen oder Probleme haben, öffnen Sie dort das entsprechende Ticket.  Alle Quellen für den Artikel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h1>  Einführung </h1><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel haben</a> wir die Prinzipien des Paging-Speichers und die Funktionsweise der vierstufigen Seitentabellen unter x86_64 kennengelernt.  Wir haben auch festgestellt, dass der Loader bereits die Seitentabellenhierarchie für unseren Kernel eingerichtet hat, sodass der Kernel auf virtuellen Adressen ausgeführt wird.  Dies verbessert die Sicherheit, aber das Problem tritt auf: Wie kann auf reale physische Adressen zugegriffen werden, die in Seitentabelleneinträgen oder im <code>CR3</code> gespeichert sind? <br><a name="habracut"></a><br>  Im ersten Abschnitt des Artikels werden wir das Problem und verschiedene Lösungsansätze diskutieren.  Anschließend implementieren wir eine Funktion, die sich durch die Hierarchie der Seitentabellen schleicht, um virtuelle Adressen in physische Adressen umzuwandeln.  Schließlich erfahren Sie, wie Sie neue Zuordnungen in Seitentabellen erstellen und nicht verwendete Speicherrahmen zum Erstellen neuer Tabellen finden. <br><br><h2>  Abhängigkeitsaktualisierungen </h2><br>  Zum Arbeiten benötigen Sie <code>x86_64</code> Version 0.4.0 oder höher.  Aktualisieren Sie die Abhängigkeit in unserer <code>Cargo.toml</code> : <br><br><pre> <code class="rust hljs">[dependencies] x86_64 = <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> # or later</code> </pre> <br><h1>  Zugriff auf Seitentabellen </h1><br>  Der Zugriff auf Seitentabellen über den Kernel ist nicht so einfach, wie es scheint.  Um das Problem zu verstehen, werfen Sie einen weiteren Blick auf die vierstufige Tabellenhierarchie aus dem vorherigen Artikel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Wichtig ist, dass in jedem Seiteneintrag die <i>physikalische</i> Adresse der nächsten Tabelle gespeichert wird.  Dies vermeidet die Übersetzung dieser Adressen, was die Leistung verringert und leicht zu Endlosschleifen führt. <br><br>  Das Problem ist, dass wir vom Kernel nicht direkt auf physische Adressen zugreifen können, da dies auch für virtuelle Adressen funktioniert.  Wenn wir beispielsweise zur Adresse <code>4 KiB</code> , erhalten wir Zugriff auf die <i>virtuelle</i> Adresse <code>4 KiB</code> und nicht auf die <i>physische</i> Adresse, an der die Seitentabelle der 4. Ebene gespeichert ist.  Wenn wir auf die physische Adresse von <code>4 KiB</code> zugreifen möchten, müssen wir eine virtuelle Adresse verwenden, die in diese übersetzt wird. <br><br>  Um auf die Frames der Seitentabellen zuzugreifen, müssen Sie diesen Frames einige virtuelle Seiten zuordnen.  Es gibt verschiedene Möglichkeiten, solche Zuordnungen zu erstellen. <br><br>  1. Eine einfache Lösung ist die <b>identische Anzeige aller Seitentabellen</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  In diesem Beispiel sehen wir die identische Anzeige von Frames.  Die physischen Adressen der Seitentabellen sind gleichzeitig gültige virtuelle Adressen, so dass wir ab dem Register CR3 problemlos auf die Seitentabellen aller Ebenen zugreifen können. <br><br>  Dieser Ansatz überfüllt jedoch den virtuellen Adressraum und macht es schwierig, große zusammenhängende Bereiche des freien Speichers zu finden.  Angenommen, wir möchten in der obigen Abbildung einen virtuellen Speicherbereich von 1000 KB erstellen, um beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Datei im Speicher anzuzeigen</a> .  Wir können nicht mit der <code>28  KiB</code> Region beginnen, da sie bei <code>1004  KiB</code> auf einer bereits belegten Seite liegt.  Daher müssen Sie weiter suchen, bis wir ein geeignetes großes Fragment finden, beispielsweise mit <code>1008  KiB</code> .  Es gibt das gleiche Fragmentierungsproblem wie im segmentierten Speicher. <br><br>  Darüber hinaus ist die Erstellung neuer Seitentabellen viel komplizierter, da physische Frames gefunden werden müssen, deren entsprechende Seiten noch nicht verwendet werden.  Für unsere Datei haben wir beispielsweise einen Bereich von 1000 KB <i>virtuellem</i> Speicher reserviert, beginnend bei der Adresse <code>1008  KiB</code> .  Jetzt können wir keinen Frame mit einer physischen Adresse zwischen <code>1000  KiB</code> und <code>2008  KiB</code> , da dieser nicht identisch angezeigt werden kann. <br><br>  2. Eine andere Möglichkeit besteht darin <b>, Seitentabellen nur vorübergehend</b> zu <b>senden,</b> wenn Sie darauf zugreifen müssen.  Für temporäre Vergleiche ist eine identische Anzeige nur der Tabelle der ersten Ebene erforderlich: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/177/978/84e177978079c02224d4032fa02f053b.png"></div><br><br>  In dieser Abbildung verwaltet eine Tabelle der Ebene 1 die ersten 2 MiB des virtuellen Adressraums.  Dies ist möglich, weil der Zugriff vom CR3-Register über Null-Einträge in den Tabellen der Ebenen 4, 3 und 2 erfolgt. Der Datensatz mit Index <b>8</b> übersetzt die virtuelle Seite mit <code>32 KiB</code> in einen physischen Rahmen mit <code>32 KiB</code> , wodurch die Tabelle der Ebene 1 selbst identifiziert wird. In der Abbildung ist dies durch einen horizontalen Pfeil dargestellt. <br><br>  Durch Schreiben in die identisch zugeordnete Tabelle der Ebene 1 kann unser Kernel bis zu 511 Zeitvergleiche erstellen (512 abzüglich des für die Identitätszuordnung erforderlichen Datensatzes).  Im obigen Beispiel hat der Kernel den Nulldatensatz einer Tabelle der Ebene 1 mit einem Frame bei <code>24 KiB</code> abgeglichen.  Dies erzeugte eine temporäre Zuordnung der virtuellen Seite bei <code>0 KiB</code> zu dem physischen Rahmen der Seitentabelle der Seite 2, der durch den gepunkteten Pfeil angezeigt wird.  Jetzt kann der Kernel auf die Tabelle der Ebene 2 zugreifen, indem er auf eine Seite schreibt, die bei <code>0 KiB</code> beginnt. <br><br>  Der Zugriff auf einen beliebigen Rahmen der Seitentabelle mit temporären Zuordnungen besteht daher aus den folgenden Aktionen: <br><br><ul><li>  Suchen Sie einen freien Eintrag in der identisch angezeigten Tabelle der Ebene 1. <br></li><li>  Ordnen Sie diesen Eintrag dem physischen Rahmen der Seitentabelle zu, auf die wir zugreifen möchten. <br></li><li>  Greifen Sie über die dem Eintrag zugeordnete virtuelle Seite auf diesen Frame zu. <br></li><li>  Setzen Sie den Datensatz wieder auf nicht verwendet, wodurch die temporäre Zuordnung entfernt wird. </li></ul><br>  Bei diesem Ansatz bleibt der virtuelle Adressraum sauber, da ständig dieselben 512 virtuellen Seiten verwendet werden.  Der Nachteil ist eine gewisse Umständlichkeit, insbesondere da für einen neuen Vergleich möglicherweise mehrere Tabellenebenen geändert werden müssen, dh der beschriebene Vorgang mehrmals wiederholt werden muss. <br><br>  3. Obwohl beide oben genannten Ansätze funktionieren, gibt es eine dritte Methode: <b>rekursive Seitentabellen</b> .  Es kombiniert die Vorteile beider Ansätze: Es vergleicht ständig alle Frames der Seitentabellen, ohne temporäre Vergleiche zu erfordern, und hält auch benachbarte Seiten nebeneinander, um eine Fragmentierung des virtuellen Adressraums zu vermeiden.  Dies ist die Methode, die wir verwenden werden. <br><br><h2>  Rekursive Seitentabellen </h2><br>  Die Idee ist, einige Datensätze aus der Tabelle der vierten Ebene in sie selbst zu übersetzen.  Daher reservieren wir tatsächlich einen Teil des virtuellen Adressraums und ordnen diesem Raum alle aktuellen und zukünftigen Tabellenrahmen zu. <br><br>  Schauen wir uns ein Beispiel an, um zu verstehen, wie das alles funktioniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  Der einzige Unterschied zum Beispiel am Anfang des Artikels besteht in einem zusätzlichen Datensatz mit dem Index <code>511</code> in der Tabelle der Ebene 4, der dem physischen Frame <code>4 KiB</code> , der sich in dieser Tabelle selbst befindet. <br><br>  Wenn die CPU in diesen Datensatz wechselt, bezieht sie sich nicht auf die Tabelle der Ebene 3, sondern erneut auf die Tabelle der Ebene 4. Dies ähnelt einer rekursiven Funktion, die sich selbst aufruft.  Es ist wichtig, dass der Prozessor davon ausgeht, dass jeder Eintrag in der Tabelle der Ebene 4 auf eine Tabelle der Ebene 3 verweist. Daher wird die Tabelle der Ebene 4 jetzt als Tabelle der Ebene 3 behandelt. Dies funktioniert, da die Tabellen aller Ebenen in x86_64 dieselbe Struktur haben. <br><br>  Indem Sie einem rekursiven Datensatz ein oder mehrere Male folgen, bevor Sie mit der eigentlichen Konvertierung beginnen, können Sie die Anzahl der Ebenen, die der Prozessor durchläuft, effektiv reduzieren.  Wenn wir beispielsweise dem rekursiven Datensatz einmal folgen und dann zur Tabelle der Ebene 3 wechseln, denkt der Prozessor, dass die Tabelle der Ebene 3 eine Tabelle der Ebene 2 ist. Im weiteren Verlauf betrachtet er die Tabelle der Ebene 2 als Tabelle der Ebene 1 und die Tabelle der Ebene 1 als zugeordnet Frame im physischen Speicher.  Dies bedeutet, dass wir jetzt in die Tabelle der Seitenebene 1 lesen und schreiben können, da der Prozessor dies für einen zugeordneten Frame hält.  Die folgende Abbildung zeigt die fünf Schritte einer solchen Übersetzung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Ebenso können wir einem rekursiven Eintrag zweimal folgen, bevor wir mit der Konvertierung beginnen, um die Anzahl der übergebenen Ebenen auf zwei zu reduzieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Lassen Sie uns diese Prozedur Schritt für Schritt durchgehen.  Zuerst folgt die CPU einem rekursiven Eintrag in der Tabelle der Ebene 4 und denkt, dass sie die Tabelle der Ebene 3 erreicht hat. Dann folgt sie erneut dem rekursiven Datensatz und denkt, dass sie die Ebene 2 erreicht hat. In Wirklichkeit befindet sie sich jedoch immer noch auf Ebene 4. Dann geht die CPU zur neuen Adresse und gelangt in die Level 3-Tabelle, denkt jedoch, dass sie sich bereits in der Level 1-Tabelle befindet. Schließlich glaubt der Prozessor am nächsten Einstiegspunkt in der Level 2-Tabelle, auf den physischen Speicherrahmen zugegriffen zu haben.  Dies ermöglicht uns das Lesen und Schreiben in eine Tabelle der Ebene 2. <br><br>  Auf die Tabellen der Ebenen 3 und 4 wird ebenfalls zugegriffen. Um auf die Tabelle der Ebene 3 zuzugreifen, folgen wir dreimal einem rekursiven Datensatz: Der Prozessor glaubt, dass er sich bereits in der Tabelle der Ebene 1 befindet, und im nächsten Schritt erreichen wir die Ebene 3, die die CPU als zugeordneten Frame betrachtet.  Um auf die Level 4-Tabelle selbst zuzugreifen, folgen wir einfach viermal dem rekursiven Datensatz, bis der Prozessor die Level 4-Tabelle selbst als zugeordneten Frame verarbeitet (in der folgenden Abbildung blau). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Das Konzept ist zunächst schwer zu verstehen, aber in der Praxis funktioniert es ziemlich gut. <br><br><h4>  Adressberechnung </h4><br>  Wir können also auf Tabellen aller Ebenen zugreifen, indem wir einem oder mehreren rekursiven Datensätzen folgen.  Da Indizes in Tabellen mit vier Ebenen direkt von der virtuellen Adresse abgeleitet werden, müssen für diese Methode spezielle virtuelle Adressen erstellt werden.  Wie wir uns erinnern, werden Seitentabellenindizes wie folgt aus der Adresse extrahiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Angenommen, wir möchten auf eine Tabelle der Ebene 1 zugreifen, in der eine bestimmte Seite angezeigt wird.  Wie wir oben erfahren haben, müssen Sie einmal einen rekursiven Datensatz und dann die Indizes der 4., 3. und 2. Ebene durchlaufen.  Dazu verschieben wir alle Adressblöcke einen Block nach rechts und setzen den Index des rekursiven Datensatzes an die Stelle des Anfangsindex der Ebene 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Um auf die Tabelle der Ebene 2 dieser Seite zuzugreifen, verschieben wir alle Indexblöcke zwei Blöcke nach rechts und setzen den rekursiven Index an die Stelle beider Quellblöcke: Ebene 4 und Ebene 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Um auf die Tabelle der Ebene 3 zuzugreifen, machen wir dasselbe, wir verschieben einfach bereits drei Adressblöcke nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Um auf die Tabelle der Ebene 4 zuzugreifen, verschieben Sie alle vier Blöcke nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Jetzt können Sie virtuelle Adressen für Seitentabellen aller vier Ebenen berechnen.  Wir können sogar eine Adresse berechnen, die genau auf einen bestimmten Seitentabelleneintrag verweist, indem wir dessen Index mit 8 multiplizieren, der Größe des Seitentabelleneintrags. <br><br>  Die folgende Tabelle zeigt die Struktur der Adressen für den Zugriff auf verschiedene Arten von Frames: <br><br><table><thead><tr><th>  Virtuelle Adresse für </th><th>  Adressstruktur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oktal</a> ) </th></tr></thead><tbody><tr><td>  Seite </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Eintrag in Level 1 Tabelle </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Eintrag in eine Level 2 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Eintrag in eine Level 3 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Eintrag in Level 4 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Hier ist <code></code> der Level 4-Index, <code></code> ist Level 3, <code></code> ist Level 2 und <code>DDD</code> ist Level 1-Index für den angezeigten Frame, <code>EEEE</code> ist sein Offset.  <code>RRR</code> ist der Index des rekursiven Datensatzes.  Ein Index (drei Ziffern) wird durch Multiplikation mit 8 (der Größe des Seitentabelleneintrags) in einen Versatz (vier Ziffern) umgewandelt.  Mit diesem Versatz zeigt die resultierende Adresse direkt auf den entsprechenden Seitentabelleneintrag. <br><br>  <code>SSSS</code> sind Erweiterungsbits der vorzeichenbehafteten Ziffer, <code>SSSS</code> sie sind alle Kopien von Bit 47. Dies ist eine spezielle Anforderung für gültige Adressen in der x86_64-Architektur, die wir in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> erörtert haben. <br><br>  Die Adressen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oktal</a> , da jedes Oktalzeichen drei Bits darstellt, wodurch Sie die 9-Bit-Indizes von Tabellen auf verschiedenen Ebenen klar trennen können.  Dies ist im Hexadezimalsystem nicht möglich, bei dem jedes Zeichen vier Bits darstellt. <br><br><h2>  Implementierung </h2><br>  Nach all dieser Theorie können wir endlich mit der Implementierung fortfahren.  Praktischerweise hat der Loader nicht nur Seitentabellen generiert, sondern auch eine rekursive Anzeige im letzten Datensatz der Level 4-Tabelle. Der Loader hat dies getan, da sonst ein Henne-Ei-Problem auftreten würde: Wir müssen auf die Level 4-Tabelle zugreifen, um eine rekursive Karte zu erstellen aber wir können nicht ohne Anzeige darauf zugreifen. <br><br>  Wir haben diese rekursive Zuordnung bereits am Ende des vorherigen Artikels verwendet, um über die fest codierte Adresse <code>0xffff_ffff_ffff_f000</code> auf die Tabelle der Ebene 4 <code>0xffff_ffff_ffff_f000</code> .  Wenn wir diese Adresse in Oktal konvertieren und sie mit der obigen Tabelle vergleichen, werden wir sehen, dass sie genau der Struktur des Datensatzes in der Tabelle der Ebene 4 mit <code>RRR</code> = <code>0o777</code> , <code>AAAA</code> = <code>0</code> und den Erweiterungsbits des Vorzeichens <code>1</code> : <br><br><pre>  Struktur: 0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
 Adresse: 0o_177777_777_777_777_777_0000 </pre><br>  Dank der Kenntnis rekursiver Tabellen können wir jetzt virtuelle Adressen erstellen, um auf alle aktiven Tabellen zuzugreifen.  Und machen Sie die Broadcast-Funktion. <br><br><h3>  Adressübersetzung </h3><br>  Erstellen Sie als ersten Schritt eine Funktion, die eine virtuelle Adresse in eine physische Adresse konvertiert und dabei die Hierarchie der Seitentabellen durchläuft: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::PhysAddr; use x86_64::structures::paging::PageTable; /// Returns the physical address for the given virtual address, or `None` if the /// virtual address is not mapped. pub fn translate_addr(addr: usize) -&gt; Option&lt;PhysAddr&gt; { // introduce variables for the recursive index and the sign extension bits // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Don't hardcode these values let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12); // check that level 4 entry is mapped let level_4_table = unsafe { &amp;*(level_4_table_addr as *const PageTable) }; if level_4_table[l4_idx].addr().is_null() { return None; } // check that level 3 entry is mapped let level_3_table = unsafe { &amp;*(level_3_table_addr as *const PageTable) }; if level_3_table[l3_idx].addr().is_null() { return None; } // check that level 2 entry is mapped let level_2_table = unsafe { &amp;*(level_2_table_addr as *const PageTable) }; if level_2_table[l2_idx].addr().is_null() { return None; } // check that level 1 entry is mapped and retrieve physical address from it let level_1_table = unsafe { &amp;*(level_1_table_addr as *const PageTable) }; let phys_addr = level_1_table[l1_idx].addr(); if phys_addr.is_null() { return None; } Some(phys_addr + page_offset) }</span></span></code> </pre> <br>  Zunächst führen wir Variablen für den rekursiven Index (511 = <code>0o777</code> ) und die Vorzeichenerweiterungsbits (jeweils 1) ein.  Dann berechnen wir die Indizes der Seitentabellen und den Versatz durch bitweise Operationen, wie in der Abbildung gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Der nächste Schritt besteht darin, die virtuellen Adressen der vier Seitentabellen zu berechnen, wie im vorherigen Abschnitt beschrieben.  Als Nächstes konvertieren wir in der Funktion jede dieser Adressen in <code>PageTable</code> Links.  Dies sind unsichere Vorgänge, da der Compiler nicht wissen kann, dass diese Adressen gültig sind. <br><br>  Nach der Berechnung der Adresse verwenden wir den Indexierungsoperator, um den Datensatz in der Tabelle der Ebene 4 anzuzeigen. Wenn dieser Datensatz Null ist, gibt es keine Tabelle der Ebene 3 für diesen Datensatz der Ebene 4. Dies bedeutet, dass <code>addr</code> keinem physischen Speicher zugeordnet ist.  Also geben wir <code>None</code> .  Ansonsten wissen wir, dass eine Level 3-Tabelle existiert.  Dann wiederholen wir den Vorgang wie auf der vorherigen Ebene. <br><br>  Nachdem wir drei Seiten einer höheren Ebene überprüft haben, können wir endlich den Datensatz der Tabelle der Ebene 1 lesen, der uns den physischen Frame angibt, mit dem die Adresse zugeordnet ist.  Fügen Sie als letzten Schritt den Seitenversatz hinzu - und geben Sie die Adresse zurück. <br><br>  Wenn wir sicher wären, dass die Adresse zugeordnet ist, können wir direkt auf die Tabelle der Ebene 1 zugreifen, ohne auf die Seiten einer höheren Ebene zu schauen.  Da wir dies jedoch nicht wissen, müssen wir zuerst prüfen, ob eine Tabelle der Ebene 1 vorhanden ist. Andernfalls gibt unsere Funktion einen Fehler für fehlende Adressen zurück. <br><br><h4>  Versuchen Sie es </h4><br>  Versuchen wir, die Übersetzungsfunktion für virtuelle Adressen in unserer <code>_start</code> Funktion zu verwenden: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><br>  Nach dem Start sehen wir folgendes Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/e62/054/1bde620549428279e6c1f1647d88a062.png"></div><br><br>  Wie erwartet wird die dem Bezeichner zugeordnete Adresse 0xb8000 in dieselbe physikalische Adresse übersetzt.  Die Codepage und die Stapelseite werden in beliebige physikalische Adressen konvertiert, die davon abhängen, wie der Loader die anfängliche Zuordnung für unseren Kernel erstellt hat. <br><br><h4> <code> RecursivePageTable</code> </h4> <br>  x86_64 bietet einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>RecursivePageTable</code></a> Typ, der sichere Abstraktionen für verschiedene Seitentabellenoperationen implementiert.  Mit diesem Typ können Sie die Funktion <code>translate_addr</code> viel prägnanter implementieren: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. /// /// This function is unsafe because it can break memory safety if an invalid /// address is passed. pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap() } /// Returns the physical address for the given virtual address, or `None` if /// the virtual address is not mapped. pub fn translate_addr(addr: u64, recursive_page_table: &amp;RecursivePageTable) -&gt; Option&lt;PhysAddr&gt; { let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>  Der Typ <code>RecursivePageTable</code> kapselt das unsichere Crawlen von Seitentabellen vollständig ein, sodass der <code>unsafe</code> Code in der Funktion <code>translate_addr</code> nicht mehr benötigt wird.  Die <code>init</code> Funktion bleibt unsicher, da die Richtigkeit der übergebenen <code>level_4_table_addr</code> garantiert werden <code>level_4_table_addr</code> . <br><br>  Unsere <code>_start</code> Funktion muss aktualisiert werden, um die Funktion wie folgt neu zu signieren: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::{self, translate_addr}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000, &amp;recursive_page_table)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a, &amp;recursive_page_table)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48, &amp;recursive_page_table)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>  Anstatt <code>LEVEL_4_TABLE_ADDR</code> an <code>translate_addr</code> und über unsichere <code>LEVEL_4_TABLE_ADDR</code> auf die Seitentabellen zuzugreifen, übergeben wir jetzt Verweise auf den Typ <code>RecursivePageTable</code> .  Somit haben wir jetzt eine sichere Abstraktion und eine klare Semantik des Eigentums.  Dies stellt sicher, dass wir die Seitentabelle beim gemeinsamen Zugriff nicht versehentlich ändern können, da für deren Änderung der ausschließliche Besitz von <code>RecursivePageTable</code> erforderlich ist. <br><br>  Diese Funktion liefert das gleiche Ergebnis wie die manuell geschriebene Originalübersetzungsfunktion. <br><br><h4>  Unsichere Funktionen sicherer machen </h4><br> <code>memory::init</code>   :      <code>unsafe</code> ,       .       ,            4. <br><br>   <code>unsafe</code>     ,          <code>unsafe</code> .         <code>level_4_table_ptr</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(level_4_table_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; RecursivePageTable&lt;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table_ptr = level_4_table_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PageTable; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *level_4_table_ptr; <span class="hljs-comment"><span class="hljs-comment">// &lt;- this operation is unsafe RecursivePageTable::new(level_4_table).unwrap() }</span></span></code> </pre> <br>   ,     ,   . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> <code>RecursivePageTable::new</code>    ,     .      -  . <br><br>    ,     : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { /// Rust currently treats the whole body of unsafe functions as an unsafe /// block, which makes it difficult to see which operations are unsafe. To /// limit the scope of unsafe we use a safe inner function. fn init_inner(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = unsafe { &amp;mut *level_4_table_ptr }; RecursivePageTable::new(level_4_table).unwrap() } init_inner(level_4_table_addr) }</span></span></code> </pre> <br>   <code>unsafe</code>     <code>level_4_table_ptr</code> ,    ,     .     Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC</a>       . <br><br><h2>    </h2><br>         ,   —       . <br><br>       ,    .             1,       .         ,       3,        3,  2   1. <br><br>    ,      .        ,   ,         1.            , ,    <code>0x1000</code> .      <code>0xb8000</code> ,    VGA.   ,     . <br><br>      <code>create_maping</code>   <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB}; pub fn create_example_mapping( recursive_page_table: &amp;mut RecursivePageTable, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let page: Page = Page::containing_address(VirtAddr::new(0x1000)); let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { recursive_page_table.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br>      <code>RecursivePageTable</code> (   )  <code>FrameAllocator</code> ,   .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map_to</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Mapper</code></a>      <code>0x1000</code>      <code>0xb8000</code> .  ,        . <br><br>   <code>page</code>  <code>frame</code> ,  <code>map_to</code>    .   —      .    <code>PRESENT</code> ,     ,   <code>WRITABLE</code>   . <br><br>      ,   <code>FrameAllocator</code> .     <code>map_to</code> ,          .      <code>Size4KiB</code> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Page</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PhysFrame</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PageSize</code></a> ,      4 ,       2 M / 1 . <br><br>  <code>map_to</code>   ,   <code>Result</code> .      ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>expect</code></a>     .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MapperFlush</code></a> ,             (TLB)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>flush</code></a> .   <code>Result</code> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>#[must_use]</code></a>   ,      . <br><br>   ,    <code>0x1000</code>     ,  <code>FrameAllocator</code>    <code>None</code> .      <code>EmptyFrameAllocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br> (   'method <code>allocate_frame</code> is not a member of trait <code>FrameAllocator</code> ',   <code>x86_64</code>   0.4.0.) <br><br>      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] // initialize GDT, IDT, PICS use blog_os::memory::{create_example_mapping, EmptyFrameAllocator}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let mut recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; create_example_mapping(&amp;mut recursive_page_table, &amp;mut EmptyFrameAllocator); unsafe { (0x1900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>        <code>0x1000</code> ,   <code>create_example_mapping</code>      <code>RecursivePageTable</code> .    <code>0x1000</code>    VGA,    -   . <br><br>       <code>0xf021f077f065f04e</code> ,    <i>“New!”</i>   .            <code>0x1000</code> ,         <code>println</code> ,      <code>0x900</code> ,     .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«  VGA»</a> ,    VGA   ,    <code>write_volatile</code> . <br><br>     QEMU,  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef9/1bc/672/ef91bc672e33cbec8847b77028b7624e.png"></div><br><br>   . <br><br>  ,       1    <code>0x1000</code> .     ,       ,  <code>map_to</code>  ,           <code>EmptyFrameAllocator</code> .   ,     <code>0xdeadbeaf000</code>  <code>0x1000</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub fn create_example_mapping(…) { […] let page: Page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); […] } // in src/main.rs #[no_mangle] pub extern "C" fn _start() -&gt; ! { […] unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; […] }</span></span></code> </pre> <br>         : <br><br><pre> panicked at 'map_to failed: FrameAllocationFailed', /…/result.rs:999:5 </pre><br>   ,        1,    <code>FrameAllocator</code> .   ,        ? <br><br><h2>   </h2><br>          ,  ,   VGA.   BIOS  UEFI  ,     ,   .           ,         .       ( )   BIOS. <br><br>     ,        <code>_start</code>      .      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::bootinfo::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument […] }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>BootInfo</code></a>  ,           , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   semver</a> .        <code>p4_table_addr</code> , <code>memory_map</code>  <code>package</code> : <br><br><ul><li>  <code>p4_table_addr</code>        4.        <code>0o_177777_777_777_777_777_0000</code> . <br></li><li>  <code>memory_map</code>   ,           (,   ). <br></li><li>  <code>package</code>         .   ,     . </li></ul><br>     <code>memory_map</code>    <code>FrameAllocator</code> ,       <code>boot_info</code> . <br><br><h4>  <code>entry_point</code> </h4><br>  <code>_start</code>  ,     .  ,        ,          . <br><br>   ,  <code>bootloader</code>    Rust       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>entry_point</code></a>   .      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{bootinfo::BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; […] // create and test example mapping println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>        <code>extern "C"</code>  <code>no_mangle</code> ,         <code>_start</code> .  <code>kernel_main</code>      Rust,        . ,    ,     ,    , ,      . <br><br> ,      <code>memory::init</code>    ,  <code>boot_info.p4_table_addr</code> .  ,   ,               4. <br><br><h2>   </h2><br>     BIOS        ,       .    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br>  <code>frames</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .      <code>alloc</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterator::next</a> . <br><br>  <code>BootInfoFrameAllocator</code>     <code>init_frame_allocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.into_iter().step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br>               : <br><br><ul><li>    <code>iter</code>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>filter</code></a> ,      .          ,  ,    (,   )     ,    <code>InUse</code>  .  ,    ,      - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> range</a> Rust          . <br></li><li>     :          <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>step_by</code></a> .    4096  (4 ),      .       ,         .  <code>map</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>flat_map</code></a> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br>      <code>kernel_main</code> ,     <code>BootInfoFrameAllocator</code>  <code>EmptyFrameAllocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { […] // initialize GDT, IDT, PICS use x86_64::structures::paging::{PageTable, RecursivePageTable}; let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; // new let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); blog_os::memory::create_mapping(&amp;mut recursive_page_table, &amp;mut frame_allocator); unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>      —       -  <i>„New!”</i>  .    <code>map_to</code>      : <br><br><ul><li>     <code>frame_allocator</code> . <br></li><li>        .       . <br></li><li>     ,   . <br></li><li>     . </li></ul><br>    <code>create_maping</code> —   ,         .            . <br><br><h1>  Zusammenfassung </h1><br>     ,      4        .                . <br><br>  ,           .          BIOS,     . <br><br><h1>  Was weiter </h1><br>          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439066/">https://habr.com/ru/post/de439066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439050/index.html">Schulung Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Tag 2. OSI- und TCP-IP-Modelle</a></li>
<li><a href="../de439056/index.html">Integration der Zementmarke</a></li>
<li><a href="../de439060/index.html">7 Arten von Kunden</a></li>
<li><a href="../de439062/index.html">Anisoprint Composer: Hochfester 3D-Druck</a></li>
<li><a href="../de439064/index.html">Ein typischer Rasterfehler (Bootstrap-Raster) oder warum sich Designer und Layout-Designer nicht verstehen</a></li>
<li><a href="../de439068/index.html">Die Spam-Kampagne "Love you" wurde nach Japan weitergeleitet</a></li>
<li><a href="../de439070/index.html">China wird das Anti-Korruptions-KI-System Zero Trust wegen seiner hohen Effizienz aufgeben</a></li>
<li><a href="../de439072/index.html">Manifest des Smart Home-Entwicklers: 15 Prinzipien</a></li>
<li><a href="../de439076/index.html">In welchen Anwendungen soll auf unbekannten Schadcode gewartet werden?</a></li>
<li><a href="../de439078/index.html">Perm-Programmierer verhaftet, weil er eine mobile Anwendung erstellt hat, über die Pädophile gehandelt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>