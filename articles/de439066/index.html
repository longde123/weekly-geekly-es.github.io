<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé¨ ü§πüèæ ‚ôëÔ∏è Betriebssystem auf Rust. Seitenspeicher: Erweitert üíå üë©üèΩ‚Äçü§ù‚Äçüë®üèº üôç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird erl√§utert, wie der Kernel des Betriebssystems auf physische Speicherrahmen zugreifen kann. Wir werden die Funktion zum Konverti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Betriebssystem auf Rust. Seitenspeicher: Erweitert</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439066/">  In diesem Artikel wird erl√§utert, wie der Kernel des Betriebssystems auf physische Speicherrahmen zugreifen kann.  Wir werden die Funktion zum Konvertieren virtueller Adressen in physische Adressen untersuchen.  Wir werden auch herausfinden, wie Sie neue Zuordnungen in Seitentabellen erstellen. <br><br>  Dieser Blog ist auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub ver√∂ffentlicht</a> .  Wenn Sie Fragen oder Probleme haben, √∂ffnen Sie dort das entsprechende Ticket.  Alle Quellen f√ºr den Artikel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h1>  Einf√ºhrung </h1><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel haben</a> wir die Prinzipien des Paging-Speichers und die Funktionsweise der vierstufigen Seitentabellen unter x86_64 kennengelernt.  Wir haben auch festgestellt, dass der Loader bereits die Seitentabellenhierarchie f√ºr unseren Kernel eingerichtet hat, sodass der Kernel auf virtuellen Adressen ausgef√ºhrt wird.  Dies verbessert die Sicherheit, aber das Problem tritt auf: Wie kann auf reale physische Adressen zugegriffen werden, die in Seitentabelleneintr√§gen oder im <code>CR3</code> gespeichert sind? <br><a name="habracut"></a><br>  Im ersten Abschnitt des Artikels werden wir das Problem und verschiedene L√∂sungsans√§tze diskutieren.  Anschlie√üend implementieren wir eine Funktion, die sich durch die Hierarchie der Seitentabellen schleicht, um virtuelle Adressen in physische Adressen umzuwandeln.  Schlie√ülich erfahren Sie, wie Sie neue Zuordnungen in Seitentabellen erstellen und nicht verwendete Speicherrahmen zum Erstellen neuer Tabellen finden. <br><br><h2>  Abh√§ngigkeitsaktualisierungen </h2><br>  Zum Arbeiten ben√∂tigen Sie <code>x86_64</code> Version 0.4.0 oder h√∂her.  Aktualisieren Sie die Abh√§ngigkeit in unserer <code>Cargo.toml</code> : <br><br><pre> <code class="rust hljs">[dependencies] x86_64 = <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> # or later</code> </pre> <br><h1>  Zugriff auf Seitentabellen </h1><br>  Der Zugriff auf Seitentabellen √ºber den Kernel ist nicht so einfach, wie es scheint.  Um das Problem zu verstehen, werfen Sie einen weiteren Blick auf die vierstufige Tabellenhierarchie aus dem vorherigen Artikel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/5e8/a14/9c85e8a145a9078cfcfd92e204f69a5b.svg"></div><br><br>  Wichtig ist, dass in jedem Seiteneintrag die <i>physikalische</i> Adresse der n√§chsten Tabelle gespeichert wird.  Dies vermeidet die √úbersetzung dieser Adressen, was die Leistung verringert und leicht zu Endlosschleifen f√ºhrt. <br><br>  Das Problem ist, dass wir vom Kernel nicht direkt auf physische Adressen zugreifen k√∂nnen, da dies auch f√ºr virtuelle Adressen funktioniert.  Wenn wir beispielsweise zur Adresse <code>4 KiB</code> , erhalten wir Zugriff auf die <i>virtuelle</i> Adresse <code>4 KiB</code> und nicht auf die <i>physische</i> Adresse, an der die Seitentabelle der 4. Ebene gespeichert ist.  Wenn wir auf die physische Adresse von <code>4 KiB</code> zugreifen m√∂chten, m√ºssen wir eine virtuelle Adresse verwenden, die in diese √ºbersetzt wird. <br><br>  Um auf die Frames der Seitentabellen zuzugreifen, m√ºssen Sie diesen Frames einige virtuelle Seiten zuordnen.  Es gibt verschiedene M√∂glichkeiten, solche Zuordnungen zu erstellen. <br><br>  1. Eine einfache L√∂sung ist die <b>identische Anzeige aller Seitentabellen</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f3/813/916/8f3813916cd0a5b5174c8d14dabedb7a.svg"></div><br><br>  In diesem Beispiel sehen wir die identische Anzeige von Frames.  Die physischen Adressen der Seitentabellen sind gleichzeitig g√ºltige virtuelle Adressen, so dass wir ab dem Register CR3 problemlos auf die Seitentabellen aller Ebenen zugreifen k√∂nnen. <br><br>  Dieser Ansatz √ºberf√ºllt jedoch den virtuellen Adressraum und macht es schwierig, gro√üe zusammenh√§ngende Bereiche des freien Speichers zu finden.  Angenommen, wir m√∂chten in der obigen Abbildung einen virtuellen Speicherbereich von 1000 KB erstellen, um beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eine Datei im Speicher anzuzeigen</a> .  Wir k√∂nnen nicht mit der <code>28  KiB</code> Region beginnen, da sie bei <code>1004  KiB</code> auf einer bereits belegten Seite liegt.  Daher m√ºssen Sie weiter suchen, bis wir ein geeignetes gro√ües Fragment finden, beispielsweise mit <code>1008  KiB</code> .  Es gibt das gleiche Fragmentierungsproblem wie im segmentierten Speicher. <br><br>  Dar√ºber hinaus ist die Erstellung neuer Seitentabellen viel komplizierter, da physische Frames gefunden werden m√ºssen, deren entsprechende Seiten noch nicht verwendet werden.  F√ºr unsere Datei haben wir beispielsweise einen Bereich von 1000 KB <i>virtuellem</i> Speicher reserviert, beginnend bei der Adresse <code>1008  KiB</code> .  Jetzt k√∂nnen wir keinen Frame mit einer physischen Adresse zwischen <code>1000  KiB</code> und <code>2008  KiB</code> , da dieser nicht identisch angezeigt werden kann. <br><br>  2. Eine andere M√∂glichkeit besteht darin <b>, Seitentabellen nur vor√ºbergehend</b> zu <b>senden,</b> wenn Sie darauf zugreifen m√ºssen.  F√ºr tempor√§re Vergleiche ist eine identische Anzeige nur der Tabelle der ersten Ebene erforderlich: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84e/177/978/84e177978079c02224d4032fa02f053b.png"></div><br><br>  In dieser Abbildung verwaltet eine Tabelle der Ebene 1 die ersten 2 MiB des virtuellen Adressraums.  Dies ist m√∂glich, weil der Zugriff vom CR3-Register √ºber Null-Eintr√§ge in den Tabellen der Ebenen 4, 3 und 2 erfolgt. Der Datensatz mit Index <b>8</b> √ºbersetzt die virtuelle Seite mit <code>32 KiB</code> in einen physischen Rahmen mit <code>32 KiB</code> , wodurch die Tabelle der Ebene 1 selbst identifiziert wird. In der Abbildung ist dies durch einen horizontalen Pfeil dargestellt. <br><br>  Durch Schreiben in die identisch zugeordnete Tabelle der Ebene 1 kann unser Kernel bis zu 511 Zeitvergleiche erstellen (512 abz√ºglich des f√ºr die Identit√§tszuordnung erforderlichen Datensatzes).  Im obigen Beispiel hat der Kernel den Nulldatensatz einer Tabelle der Ebene 1 mit einem Frame bei <code>24 KiB</code> abgeglichen.  Dies erzeugte eine tempor√§re Zuordnung der virtuellen Seite bei <code>0 KiB</code> zu dem physischen Rahmen der Seitentabelle der Seite 2, der durch den gepunkteten Pfeil angezeigt wird.  Jetzt kann der Kernel auf die Tabelle der Ebene 2 zugreifen, indem er auf eine Seite schreibt, die bei <code>0 KiB</code> beginnt. <br><br>  Der Zugriff auf einen beliebigen Rahmen der Seitentabelle mit tempor√§ren Zuordnungen besteht daher aus den folgenden Aktionen: <br><br><ul><li>  Suchen Sie einen freien Eintrag in der identisch angezeigten Tabelle der Ebene 1. <br></li><li>  Ordnen Sie diesen Eintrag dem physischen Rahmen der Seitentabelle zu, auf die wir zugreifen m√∂chten. <br></li><li>  Greifen Sie √ºber die dem Eintrag zugeordnete virtuelle Seite auf diesen Frame zu. <br></li><li>  Setzen Sie den Datensatz wieder auf nicht verwendet, wodurch die tempor√§re Zuordnung entfernt wird. </li></ul><br>  Bei diesem Ansatz bleibt der virtuelle Adressraum sauber, da st√§ndig dieselben 512 virtuellen Seiten verwendet werden.  Der Nachteil ist eine gewisse Umst√§ndlichkeit, insbesondere da f√ºr einen neuen Vergleich m√∂glicherweise mehrere Tabellenebenen ge√§ndert werden m√ºssen, dh der beschriebene Vorgang mehrmals wiederholt werden muss. <br><br>  3. Obwohl beide oben genannten Ans√§tze funktionieren, gibt es eine dritte Methode: <b>rekursive Seitentabellen</b> .  Es kombiniert die Vorteile beider Ans√§tze: Es vergleicht st√§ndig alle Frames der Seitentabellen, ohne tempor√§re Vergleiche zu erfordern, und h√§lt auch benachbarte Seiten nebeneinander, um eine Fragmentierung des virtuellen Adressraums zu vermeiden.  Dies ist die Methode, die wir verwenden werden. <br><br><h2>  Rekursive Seitentabellen </h2><br>  Die Idee ist, einige Datens√§tze aus der Tabelle der vierten Ebene in sie selbst zu √ºbersetzen.  Daher reservieren wir tats√§chlich einen Teil des virtuellen Adressraums und ordnen diesem Raum alle aktuellen und zuk√ºnftigen Tabellenrahmen zu. <br><br>  Schauen wir uns ein Beispiel an, um zu verstehen, wie das alles funktioniert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/779/ee6/d9b/779ee6d9bf771dec8e6d22c0440e503d.png"></div><br><br>  Der einzige Unterschied zum Beispiel am Anfang des Artikels besteht in einem zus√§tzlichen Datensatz mit dem Index <code>511</code> in der Tabelle der Ebene 4, der dem physischen Frame <code>4 KiB</code> , der sich in dieser Tabelle selbst befindet. <br><br>  Wenn die CPU in diesen Datensatz wechselt, bezieht sie sich nicht auf die Tabelle der Ebene 3, sondern erneut auf die Tabelle der Ebene 4. Dies √§hnelt einer rekursiven Funktion, die sich selbst aufruft.  Es ist wichtig, dass der Prozessor davon ausgeht, dass jeder Eintrag in der Tabelle der Ebene 4 auf eine Tabelle der Ebene 3 verweist. Daher wird die Tabelle der Ebene 4 jetzt als Tabelle der Ebene 3 behandelt. Dies funktioniert, da die Tabellen aller Ebenen in x86_64 dieselbe Struktur haben. <br><br>  Indem Sie einem rekursiven Datensatz ein oder mehrere Male folgen, bevor Sie mit der eigentlichen Konvertierung beginnen, k√∂nnen Sie die Anzahl der Ebenen, die der Prozessor durchl√§uft, effektiv reduzieren.  Wenn wir beispielsweise dem rekursiven Datensatz einmal folgen und dann zur Tabelle der Ebene 3 wechseln, denkt der Prozessor, dass die Tabelle der Ebene 3 eine Tabelle der Ebene 2 ist. Im weiteren Verlauf betrachtet er die Tabelle der Ebene 2 als Tabelle der Ebene 1 und die Tabelle der Ebene 1 als zugeordnet Frame im physischen Speicher.  Dies bedeutet, dass wir jetzt in die Tabelle der Seitenebene 1 lesen und schreiben k√∂nnen, da der Prozessor dies f√ºr einen zugeordneten Frame h√§lt.  Die folgende Abbildung zeigt die f√ºnf Schritte einer solchen √úbersetzung: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/ac7/191/bdaac719103c574c655efa3604d0b842.png"></div><br><br>  Ebenso k√∂nnen wir einem rekursiven Eintrag zweimal folgen, bevor wir mit der Konvertierung beginnen, um die Anzahl der √ºbergebenen Ebenen auf zwei zu reduzieren: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/b9a/c47/7f4b9ac47fce9552dead4e551b804256.png"></div><br><br>  Lassen Sie uns diese Prozedur Schritt f√ºr Schritt durchgehen.  Zuerst folgt die CPU einem rekursiven Eintrag in der Tabelle der Ebene 4 und denkt, dass sie die Tabelle der Ebene 3 erreicht hat. Dann folgt sie erneut dem rekursiven Datensatz und denkt, dass sie die Ebene 2 erreicht hat. In Wirklichkeit befindet sie sich jedoch immer noch auf Ebene 4. Dann geht die CPU zur neuen Adresse und gelangt in die Level 3-Tabelle, denkt jedoch, dass sie sich bereits in der Level 1-Tabelle befindet. Schlie√ülich glaubt der Prozessor am n√§chsten Einstiegspunkt in der Level 2-Tabelle, auf den physischen Speicherrahmen zugegriffen zu haben.  Dies erm√∂glicht uns das Lesen und Schreiben in eine Tabelle der Ebene 2. <br><br>  Auf die Tabellen der Ebenen 3 und 4 wird ebenfalls zugegriffen. Um auf die Tabelle der Ebene 3 zuzugreifen, folgen wir dreimal einem rekursiven Datensatz: Der Prozessor glaubt, dass er sich bereits in der Tabelle der Ebene 1 befindet, und im n√§chsten Schritt erreichen wir die Ebene 3, die die CPU als zugeordneten Frame betrachtet.  Um auf die Level 4-Tabelle selbst zuzugreifen, folgen wir einfach viermal dem rekursiven Datensatz, bis der Prozessor die Level 4-Tabelle selbst als zugeordneten Frame verarbeitet (in der folgenden Abbildung blau). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/487/a82/92c/487a8292cf8fe673f1914f5f198c0956.png"></div><br><br>  Das Konzept ist zun√§chst schwer zu verstehen, aber in der Praxis funktioniert es ziemlich gut. <br><br><h4>  Adressberechnung </h4><br>  Wir k√∂nnen also auf Tabellen aller Ebenen zugreifen, indem wir einem oder mehreren rekursiven Datens√§tzen folgen.  Da Indizes in Tabellen mit vier Ebenen direkt von der virtuellen Adresse abgeleitet werden, m√ºssen f√ºr diese Methode spezielle virtuelle Adressen erstellt werden.  Wie wir uns erinnern, werden Seitentabellenindizes wie folgt aus der Adresse extrahiert: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Angenommen, wir m√∂chten auf eine Tabelle der Ebene 1 zugreifen, in der eine bestimmte Seite angezeigt wird.  Wie wir oben erfahren haben, m√ºssen Sie einmal einen rekursiven Datensatz und dann die Indizes der 4., 3. und 2. Ebene durchlaufen.  Dazu verschieben wir alle Adressbl√∂cke einen Block nach rechts und setzen den Index des rekursiven Datensatzes an die Stelle des Anfangsindex der Ebene 4: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/d82/b54/62ad82b54b233a37e40b964953a16bf8.svg"></div><br><br>  Um auf die Tabelle der Ebene 2 dieser Seite zuzugreifen, verschieben wir alle Indexbl√∂cke zwei Bl√∂cke nach rechts und setzen den rekursiven Index an die Stelle beider Quellbl√∂cke: Ebene 4 und Ebene 3: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d9/ae5/7c8/1d9ae57c8c68a0b239e5b37397a4d0f7.svg"></div><br><br>  Um auf die Tabelle der Ebene 3 zuzugreifen, machen wir dasselbe, wir verschieben einfach bereits drei Adressbl√∂cke nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6ee/c9f/4b86eec9fd1df3445718ed8246fd4473.svg"></div><br><br>  Um auf die Tabelle der Ebene 4 zuzugreifen, verschieben Sie alle vier Bl√∂cke nach rechts. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36b/6b0/29b/36b6b029b31578b143ff1e7605e358fb.svg"></div><br><br>  Jetzt k√∂nnen Sie virtuelle Adressen f√ºr Seitentabellen aller vier Ebenen berechnen.  Wir k√∂nnen sogar eine Adresse berechnen, die genau auf einen bestimmten Seitentabelleneintrag verweist, indem wir dessen Index mit 8 multiplizieren, der Gr√∂√üe des Seitentabelleneintrags. <br><br>  Die folgende Tabelle zeigt die Struktur der Adressen f√ºr den Zugriff auf verschiedene Arten von Frames: <br><br><table><thead><tr><th>  Virtuelle Adresse f√ºr </th><th>  Adressstruktur ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oktal</a> ) </th></tr></thead><tbody><tr><td>  Seite </td><td> <code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code> </td> </tr><tr><td>  Eintrag in Level 1 Tabelle </td><td> <code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code> </td> </tr><tr><td>  Eintrag in eine Level 2 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code> </td> </tr><tr><td>  Eintrag in eine Level 3 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code> </td> </tr><tr><td>  Eintrag in Level 4 Tabelle </td><td> <code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code> </td> </tr></tbody></table><br>  Hier ist <code></code> der Level 4-Index, <code></code> ist Level 3, <code></code> ist Level 2 und <code>DDD</code> ist Level 1-Index f√ºr den angezeigten Frame, <code>EEEE</code> ist sein Offset.  <code>RRR</code> ist der Index des rekursiven Datensatzes.  Ein Index (drei Ziffern) wird durch Multiplikation mit 8 (der Gr√∂√üe des Seitentabelleneintrags) in einen Versatz (vier Ziffern) umgewandelt.  Mit diesem Versatz zeigt die resultierende Adresse direkt auf den entsprechenden Seitentabelleneintrag. <br><br>  <code>SSSS</code> sind Erweiterungsbits der vorzeichenbehafteten Ziffer, <code>SSSS</code> sie sind alle Kopien von Bit 47. Dies ist eine spezielle Anforderung f√ºr g√ºltige Adressen in der x86_64-Architektur, die wir in einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> er√∂rtert haben. <br><br>  Die Adressen sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">oktal</a> , da jedes Oktalzeichen drei Bits darstellt, wodurch Sie die 9-Bit-Indizes von Tabellen auf verschiedenen Ebenen klar trennen k√∂nnen.  Dies ist im Hexadezimalsystem nicht m√∂glich, bei dem jedes Zeichen vier Bits darstellt. <br><br><h2>  Implementierung </h2><br>  Nach all dieser Theorie k√∂nnen wir endlich mit der Implementierung fortfahren.  Praktischerweise hat der Loader nicht nur Seitentabellen generiert, sondern auch eine rekursive Anzeige im letzten Datensatz der Level 4-Tabelle. Der Loader hat dies getan, da sonst ein Henne-Ei-Problem auftreten w√ºrde: Wir m√ºssen auf die Level 4-Tabelle zugreifen, um eine rekursive Karte zu erstellen aber wir k√∂nnen nicht ohne Anzeige darauf zugreifen. <br><br>  Wir haben diese rekursive Zuordnung bereits am Ende des vorherigen Artikels verwendet, um √ºber die fest codierte Adresse <code>0xffff_ffff_ffff_f000</code> auf die Tabelle der Ebene 4 <code>0xffff_ffff_ffff_f000</code> .  Wenn wir diese Adresse in Oktal konvertieren und sie mit der obigen Tabelle vergleichen, werden wir sehen, dass sie genau der Struktur des Datensatzes in der Tabelle der Ebene 4 mit <code>RRR</code> = <code>0o777</code> , <code>AAAA</code> = <code>0</code> und den Erweiterungsbits des Vorzeichens <code>1</code> : <br><br><pre>  Struktur: 0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA
 Adresse: 0o_177777_777_777_777_777_0000 </pre><br>  Dank der Kenntnis rekursiver Tabellen k√∂nnen wir jetzt virtuelle Adressen erstellen, um auf alle aktiven Tabellen zuzugreifen.  Und machen Sie die Broadcast-Funktion. <br><br><h3>  Adress√ºbersetzung </h3><br>  Erstellen Sie als ersten Schritt eine Funktion, die eine virtuelle Adresse in eine physische Adresse konvertiert und dabei die Hierarchie der Seitentabellen durchl√§uft: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/lib.rs pub mod memory;</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::PhysAddr; use x86_64::structures::paging::PageTable; /// Returns the physical address for the given virtual address, or `None` if the /// virtual address is not mapped. pub fn translate_addr(addr: usize) -&gt; Option&lt;PhysAddr&gt; { // introduce variables for the recursive index and the sign extension bits // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Don't hardcode these values let r = 0o777; // recursive index let sign = 0o177777 &lt;&lt; 48; // sign extension // retrieve the page table indices of the address that we want to translate let l4_idx = (addr &gt;&gt; 39) &amp; 0o777; // level 4 index let l3_idx = (addr &gt;&gt; 30) &amp; 0o777; // level 3 index let l2_idx = (addr &gt;&gt; 21) &amp; 0o777; // level 2 index let l1_idx = (addr &gt;&gt; 12) &amp; 0o777; // level 1 index let page_offset = addr &amp; 0o7777; // calculate the table addresses let level_4_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (r &lt;&lt; 12); let level_3_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (r &lt;&lt; 21) | (l4_idx &lt;&lt; 12); let level_2_table_addr = sign | (r &lt;&lt; 39) | (r &lt;&lt; 30) | (l4_idx &lt;&lt; 21) | (l3_idx &lt;&lt; 12); let level_1_table_addr = sign | (r &lt;&lt; 39) | (l4_idx &lt;&lt; 30) | (l3_idx &lt;&lt; 21) | (l2_idx &lt;&lt; 12); // check that level 4 entry is mapped let level_4_table = unsafe { &amp;*(level_4_table_addr as *const PageTable) }; if level_4_table[l4_idx].addr().is_null() { return None; } // check that level 3 entry is mapped let level_3_table = unsafe { &amp;*(level_3_table_addr as *const PageTable) }; if level_3_table[l3_idx].addr().is_null() { return None; } // check that level 2 entry is mapped let level_2_table = unsafe { &amp;*(level_2_table_addr as *const PageTable) }; if level_2_table[l2_idx].addr().is_null() { return None; } // check that level 1 entry is mapped and retrieve physical address from it let level_1_table = unsafe { &amp;*(level_1_table_addr as *const PageTable) }; let phys_addr = level_1_table[l1_idx].addr(); if phys_addr.is_null() { return None; } Some(phys_addr + page_offset) }</span></span></code> </pre> <br>  Zun√§chst f√ºhren wir Variablen f√ºr den rekursiven Index (511 = <code>0o777</code> ) und die Vorzeichenerweiterungsbits (jeweils 1) ein.  Dann berechnen wir die Indizes der Seitentabellen und den Versatz durch bitweise Operationen, wie in der Abbildung gezeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c44/33c/8f9/c4433c8f99b6fcb54d4b79983ca35dbc.svg"></div><br><br>  Der n√§chste Schritt besteht darin, die virtuellen Adressen der vier Seitentabellen zu berechnen, wie im vorherigen Abschnitt beschrieben.  Als N√§chstes konvertieren wir in der Funktion jede dieser Adressen in <code>PageTable</code> Links.  Dies sind unsichere Vorg√§nge, da der Compiler nicht wissen kann, dass diese Adressen g√ºltig sind. <br><br>  Nach der Berechnung der Adresse verwenden wir den Indexierungsoperator, um den Datensatz in der Tabelle der Ebene 4 anzuzeigen. Wenn dieser Datensatz Null ist, gibt es keine Tabelle der Ebene 3 f√ºr diesen Datensatz der Ebene 4. Dies bedeutet, dass <code>addr</code> keinem physischen Speicher zugeordnet ist.  Also geben wir <code>None</code> .  Ansonsten wissen wir, dass eine Level 3-Tabelle existiert.  Dann wiederholen wir den Vorgang wie auf der vorherigen Ebene. <br><br>  Nachdem wir drei Seiten einer h√∂heren Ebene √ºberpr√ºft haben, k√∂nnen wir endlich den Datensatz der Tabelle der Ebene 1 lesen, der uns den physischen Frame angibt, mit dem die Adresse zugeordnet ist.  F√ºgen Sie als letzten Schritt den Seitenversatz hinzu - und geben Sie die Adresse zur√ºck. <br><br>  Wenn wir sicher w√§ren, dass die Adresse zugeordnet ist, k√∂nnen wir direkt auf die Tabelle der Ebene 1 zugreifen, ohne auf die Seiten einer h√∂heren Ebene zu schauen.  Da wir dies jedoch nicht wissen, m√ºssen wir zuerst pr√ºfen, ob eine Tabelle der Ebene 1 vorhanden ist. Andernfalls gibt unsere Funktion einen Fehler f√ºr fehlende Adressen zur√ºck. <br><br><h4>  Versuchen Sie es </h4><br>  Versuchen wir, die √úbersetzungsfunktion f√ºr virtuelle Adressen in unserer <code>_start</code> Funktion zu verwenden: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::translate_addr; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br><br>  Nach dem Start sehen wir folgendes Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bd/e62/054/1bde620549428279e6c1f1647d88a062.png"></div><br><br>  Wie erwartet wird die dem Bezeichner zugeordnete Adresse 0xb8000 in dieselbe physikalische Adresse √ºbersetzt.  Die Codepage und die Stapelseite werden in beliebige physikalische Adressen konvertiert, die davon abh√§ngen, wie der Loader die anf√§ngliche Zuordnung f√ºr unseren Kernel erstellt hat. <br><br><h4> <code> RecursivePageTable</code> </h4> <br>  x86_64 bietet einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>RecursivePageTable</code></a> Typ, der sichere Abstraktionen f√ºr verschiedene Seitentabellenoperationen implementiert.  Mit diesem Typ k√∂nnen Sie die Funktion <code>translate_addr</code> viel pr√§gnanter implementieren: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{Mapper, Page, PageTable, RecursivePageTable}; use x86_64::{VirtAddr, PhysAddr}; /// Creates a RecursivePageTable instance from the level 4 address. /// /// This function is unsafe because it can break memory safety if an invalid /// address is passed. pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = &amp;mut *level_4_table_ptr; RecursivePageTable::new(level_4_table).unwrap() } /// Returns the physical address for the given virtual address, or `None` if /// the virtual address is not mapped. pub fn translate_addr(addr: u64, recursive_page_table: &amp;RecursivePageTable) -&gt; Option&lt;PhysAddr&gt; { let addr = VirtAddr::new(addr); let page: Page = Page::containing_address(addr); // perform the translation let frame = recursive_page_table.translate_page(page); frame.map(|frame| frame.start_address() + u64::from(addr.page_offset())) }</span></span></code> </pre> <br>  Der Typ <code>RecursivePageTable</code> kapselt das unsichere Crawlen von Seitentabellen vollst√§ndig ein, sodass der <code>unsafe</code> Code in der Funktion <code>translate_addr</code> nicht mehr ben√∂tigt wird.  Die <code>init</code> Funktion bleibt unsicher, da die Richtigkeit der √ºbergebenen <code>level_4_table_addr</code> garantiert werden <code>level_4_table_addr</code> . <br><br>  Unsere <code>_start</code> Funktion muss aktualisiert werden, um die Funktion wie folgt neu zu signieren: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::{self, translate_addr}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; // the identity-mapped vga buffer page println!("0xb8000 -&gt; {:?}", translate_addr(0xb8000, &amp;recursive_page_table)); // some code page println!("0x20010a -&gt; {:?}", translate_addr(0x20010a, &amp;recursive_page_table)); // some stack page println!("0x57ac001ffe48 -&gt; {:?}", translate_addr(0x57ac001ffe48, &amp;recursive_page_table)); println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>  Anstatt <code>LEVEL_4_TABLE_ADDR</code> an <code>translate_addr</code> und √ºber unsichere <code>LEVEL_4_TABLE_ADDR</code> auf die Seitentabellen zuzugreifen, √ºbergeben wir jetzt Verweise auf den Typ <code>RecursivePageTable</code> .  Somit haben wir jetzt eine sichere Abstraktion und eine klare Semantik des Eigentums.  Dies stellt sicher, dass wir die Seitentabelle beim gemeinsamen Zugriff nicht versehentlich √§ndern k√∂nnen, da f√ºr deren √Ñnderung der ausschlie√üliche Besitz von <code>RecursivePageTable</code> erforderlich ist. <br><br>  Diese Funktion liefert das gleiche Ergebnis wie die manuell geschriebene Original√ºbersetzungsfunktion. <br><br><h4>  Unsichere Funktionen sicherer machen </h4><br> <code>memory::init</code>   :      <code>unsafe</code> ,       .       ,            4. <br><br>   <code>unsafe</code>     ,          <code>unsafe</code> .         <code>level_4_table_ptr</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(level_4_table_addr: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; RecursivePageTable&lt;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table_ptr = level_4_table_addr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> PageTable; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> level_4_table = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *level_4_table_ptr; <span class="hljs-comment"><span class="hljs-comment">// &lt;- this operation is unsafe RecursivePageTable::new(level_4_table).unwrap() }</span></span></code> </pre> <br>   ,     ,   . ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> <code>RecursivePageTable::new</code>    ,     .      -  . <br><br>    ,     : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub unsafe fn init(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { /// Rust currently treats the whole body of unsafe functions as an unsafe /// block, which makes it difficult to see which operations are unsafe. To /// limit the scope of unsafe we use a safe inner function. fn init_inner(level_4_table_addr: usize) -&gt; RecursivePageTable&lt;'static&gt; { let level_4_table_ptr = level_4_table_addr as *mut PageTable; let level_4_table = unsafe { &amp;mut *level_4_table_ptr }; RecursivePageTable::new(level_4_table).unwrap() } init_inner(level_4_table_addr) }</span></span></code> </pre> <br>   <code>unsafe</code>     <code>level_4_table_ptr</code> ,    ,     .     Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC</a>       . <br><br><h2>    </h2><br>         ,   ‚Äî       . <br><br>       ,    .             1,       .         ,       3,        3,  2   1. <br><br>    ,      .        ,   ,         1.            , ,    <code>0x1000</code> .      <code>0xb8000</code> ,    VGA.   ,     . <br><br>      <code>create_maping</code>   <code>memory</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use x86_64::structures::paging::{FrameAllocator, PhysFrame, Size4KiB}; pub fn create_example_mapping( recursive_page_table: &amp;mut RecursivePageTable, frame_allocator: &amp;mut impl FrameAllocator&lt;Size4KiB&gt;, ) { use x86_64::structures::paging::PageTableFlags as Flags; let page: Page = Page::containing_address(VirtAddr::new(0x1000)); let frame = PhysFrame::containing_address(PhysAddr::new(0xb8000)); let flags = Flags::PRESENT | Flags::WRITABLE; let map_to_result = unsafe { recursive_page_table.map_to(page, frame, flags, frame_allocator) }; map_to_result.expect("map_to failed").flush(); }</span></span></code> </pre> <br>      <code>RecursivePageTable</code> (   )  <code>FrameAllocator</code> ,   .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map_to</code></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Mapper</code></a>      <code>0x1000</code>      <code>0xb8000</code> .  ,        . <br><br>   <code>page</code>  <code>frame</code> ,  <code>map_to</code>    .   ‚Äî      .    <code>PRESENT</code> ,     ,   <code>WRITABLE</code>   . <br><br>      ,   <code>FrameAllocator</code> .     <code>map_to</code> ,          .      <code>Size4KiB</code> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>Page</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PhysFrame</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>PageSize</code></a> ,      4 ,       2 M / 1 . <br><br>  <code>map_to</code>   ,   <code>Result</code> .      ,     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>expect</code></a>     .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MapperFlush</code></a> ,             (TLB)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>flush</code></a> .   <code>Result</code> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>#[must_use]</code></a>   ,      . <br><br>   ,    <code>0x1000</code>     ,  <code>FrameAllocator</code>    <code>None</code> .      <code>EmptyFrameAllocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs /// A FrameAllocator that always returns `None`. pub struct EmptyFrameAllocator; impl FrameAllocator&lt;Size4KiB&gt; for EmptyFrameAllocator { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { None } }</span></span></code> </pre> <br> (   'method <code>allocate_frame</code> is not a member of trait <code>FrameAllocator</code> ',   <code>x86_64</code>   0.4.0.) <br><br>      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use blog_os::memory::{create_example_mapping, EmptyFrameAllocator}; const LEVEL_4_TABLE_ADDR: usize = 0o_177777_777_777_777_777_0000; let mut recursive_page_table = unsafe { memory::init(LEVEL_4_TABLE_ADDR) }; create_example_mapping(&amp;mut recursive_page_table, &amp;mut EmptyFrameAllocator); unsafe { (0x1900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>        <code>0x1000</code> ,   <code>create_example_mapping</code>      <code>RecursivePageTable</code> .    <code>0x1000</code>    VGA,    -   . <br><br>       <code>0xf021f077f065f04e</code> ,    <i>‚ÄúNew!‚Äù</i>   .            <code>0x1000</code> ,         <code>println</code> ,      <code>0x900</code> ,     .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">¬´  VGA¬ª</a> ,    VGA   ,    <code>write_volatile</code> . <br><br>     QEMU,  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef9/1bc/672/ef91bc672e33cbec8847b77028b7624e.png"></div><br><br>   . <br><br>  ,       1    <code>0x1000</code> .     ,       ,  <code>map_to</code>  ,           <code>EmptyFrameAllocator</code> .   ,     <code>0xdeadbeaf000</code>  <code>0x1000</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub fn create_example_mapping(‚Ä¶) { [‚Ä¶] let page: Page = Page::containing_address(VirtAddr::new(0xdeadbeaf000)); [‚Ä¶] } // in src/main.rs #[no_mangle] pub extern "C" fn _start() -&gt; ! { [‚Ä¶] unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; [‚Ä¶] }</span></span></code> </pre> <br>         : <br><br><pre> panicked at 'map_to failed: FrameAllocationFailed', /‚Ä¶/result.rs:999:5 </pre><br>   ,        1,    <code>FrameAllocator</code> .   ,        ? <br><br><h2>   </h2><br>          ,  ,   VGA.   BIOS  UEFI  ,     ,   .           ,         .       ( )   BIOS. <br><br>     ,        <code>_start</code>      .      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::bootinfo::BootInfo; #[cfg(not(test))] #[no_mangle] pub extern "C" fn _start(boot_info: &amp;'static BootInfo) -&gt; ! { // new argument [‚Ä¶] }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>BootInfo</code></a>  ,           , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   semver</a> .        <code>p4_table_addr</code> , <code>memory_map</code>  <code>package</code> : <br><br><ul><li>  <code>p4_table_addr</code>        4.        <code>0o_177777_777_777_777_777_0000</code> . <br></li><li>  <code>memory_map</code>   ,           (,   ). <br></li><li>  <code>package</code>         .   ,     . </li></ul><br>     <code>memory_map</code>    <code>FrameAllocator</code> ,       <code>boot_info</code> . <br><br><h4>  <code>entry_point</code> </h4><br>  <code>_start</code>  ,     .  ,        ,          . <br><br>   ,  <code>bootloader</code>    Rust       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>entry_point</code></a>   .      : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs use bootloader::{bootinfo::BootInfo, entry_point}; entry_point!(kernel_main); #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; [‚Ä¶] // create and test example mapping println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>        <code>extern "C"</code>  <code>no_mangle</code> ,         <code>_start</code> .  <code>kernel_main</code>      Rust,        . ,    ,     ,    , ,      . <br><br> ,      <code>memory::init</code>    ,  <code>boot_info.p4_table_addr</code> .  ,   ,               4. <br><br><h2>   </h2><br>     BIOS        ,       .    : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs pub struct BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { frames: I, } impl&lt;I&gt; FrameAllocator&lt;Size4KiB&gt; for BootInfoFrameAllocator&lt;I&gt; where I: Iterator&lt;Item = PhysFrame&gt; { fn allocate_frame(&amp;mut self) -&gt; Option&lt;PhysFrame&gt; { self.frames.next() } }</span></span></code> </pre> <br>  <code>frames</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> .      <code>alloc</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterator::next</a> . <br><br>  <code>BootInfoFrameAllocator</code>     <code>init_frame_allocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/memory.rs use bootloader::bootinfo::{MemoryMap, MemoryRegionType}; /// Create a FrameAllocator from the passed memory map pub fn init_frame_allocator( memory_map: &amp;'static MemoryMap, ) -&gt; BootInfoFrameAllocator&lt;impl Iterator&lt;Item = PhysFrame&gt;&gt; { // get usable regions from memory map let regions = memory_map .iter() .filter(|r| r.region_type == MemoryRegionType::Usable); // map each region to its address range let addr_ranges = regions.map(|r| r.range.start_addr()..r.range.end_addr()); // transform to an iterator of frame start addresses let frame_addresses = addr_ranges.flat_map(|r| r.into_iter().step_by(4096)); // create `PhysFrame` types from the start addresses let frames = frame_addresses.map(|addr| { PhysFrame::containing_address(PhysAddr::new(addr)) }); BootInfoFrameAllocator { frames } }</span></span></code> </pre> <br>               : <br><br><ul><li>    <code>iter</code>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>MemoryRegion</code></a> .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>filter</code></a> ,      .          ,  ,    (,   )     ,    <code>InUse</code>  .  ,    ,      - . <br></li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>map</code></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> range</a> Rust          . <br></li><li>     :          <code>into_iter</code> ,     4096-    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>step_by</code></a> .    4096  (4 ),      .       ,         .  <code>map</code>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>flat_map</code></a> ,   <code>Iterator&lt;Item = u64&gt;</code>  <code>Iterator&lt;Item = Iterator&lt;Item = u64&gt;&gt;</code> . <br></li><li>         <code>PhysFrame</code> ,    <code>Iterator&lt;Item = PhysFrame&gt;</code> .          <code>BootInfoFrameAllocator</code> . </li></ul><br>      <code>kernel_main</code> ,     <code>BootInfoFrameAllocator</code>  <code>EmptyFrameAllocator</code> : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// in src/main.rs #[cfg(not(test))] fn kernel_main(boot_info: &amp;'static BootInfo) -&gt; ! { [‚Ä¶] // initialize GDT, IDT, PICS use x86_64::structures::paging::{PageTable, RecursivePageTable}; let mut recursive_page_table = unsafe { memory::init(boot_info.p4_table_addr as usize) }; // new let mut frame_allocator = memory::init_frame_allocator(&amp;boot_info.memory_map); blog_os::memory::create_mapping(&amp;mut recursive_page_table, &amp;mut frame_allocator); unsafe { (0xdeadbeaf900 as *mut u64).write_volatile(0xf021f077f065f04e)}; println!("It did not crash!"); blog_os::hlt_loop(); }</span></span></code> </pre> <br>      ‚Äî       -  <i>‚ÄûNew!‚Äù</i>  .    <code>map_to</code>      : <br><br><ul><li>     <code>frame_allocator</code> . <br></li><li>        .       . <br></li><li>     ,   . <br></li><li>     . </li></ul><br>    <code>create_maping</code> ‚Äî   ,         .            . <br><br><h1>  Zusammenfassung </h1><br>     ,      4        .                . <br><br>  ,           .          BIOS,     . <br><br><h1>  Was weiter </h1><br>          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439066/">https://habr.com/ru/post/de439066/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439050/index.html">Schulung Cisco 200-125 CCNA v3.0. Cisco Certified Network Specialist (CCNA). Tag 2. OSI- und TCP-IP-Modelle</a></li>
<li><a href="../de439056/index.html">Integration der Zementmarke</a></li>
<li><a href="../de439060/index.html">7 Arten von Kunden</a></li>
<li><a href="../de439062/index.html">Anisoprint Composer: Hochfester 3D-Druck</a></li>
<li><a href="../de439064/index.html">Ein typischer Rasterfehler (Bootstrap-Raster) oder warum sich Designer und Layout-Designer nicht verstehen</a></li>
<li><a href="../de439068/index.html">Die Spam-Kampagne "Love you" wurde nach Japan weitergeleitet</a></li>
<li><a href="../de439070/index.html">China wird das Anti-Korruptions-KI-System Zero Trust wegen seiner hohen Effizienz aufgeben</a></li>
<li><a href="../de439072/index.html">Manifest des Smart Home-Entwicklers: 15 Prinzipien</a></li>
<li><a href="../de439076/index.html">In welchen Anwendungen soll auf unbekannten Schadcode gewartet werden?</a></li>
<li><a href="../de439078/index.html">Perm-Programmierer verhaftet, weil er eine mobile Anwendung erstellt hat, √ºber die P√§dophile gehandelt haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>