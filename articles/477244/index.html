<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå≠ üë®üèº‚Äçüöí üôá RayTracing comprensible en 256 l√≠neas de C ++ desnudo üïí üå°Ô∏è üò®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RayTracing comprensible en 256 l√≠neas de C ++ desnudo 


 Este es otro cap√≠tulo de mi breve curso de conferencias sobre gr√°ficos por computadora . Est...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RayTracing comprensible en 256 l√≠neas de C ++ desnudo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477244/"><h1 id="understandable-raytracing-in-256-lines-of-bare-c">  RayTracing comprensible en 256 l√≠neas de C ++ desnudo </h1><br><p> Este es otro cap√≠tulo de mi <a href="https://github.com/ssloy/tinyrenderer/wiki">breve curso de conferencias sobre gr√°ficos por computadora</a> .  Esta vez estamos hablando del trazado de rayos.  Como de costumbre, trato de evitar las bibliotecas de terceros, ya que creo que hace que los estudiantes verifiquen lo que sucede debajo del cap√≥.  Consulte tambi√©n el <a href="https://github.com/ssloy/tinykaboom/wiki">proyecto tinykaboom</a> . </p><br><p>  Hay muchos art√≠culos de trazado de rayos en la web;  sin embargo, el problema es que casi todos muestran software terminado que puede ser bastante dif√≠cil de entender.  Tomemos, por ejemplo, el muy famoso desaf√≠o de <a href="https://www.taylorpetrick.com/blog/post/business-rt">trazado de rayos de la tarjeta de negocios</a> .  Produce programas muy impresionantes, pero es muy dif√≠cil entender c√≥mo funciona esto.  En lugar de mostrar que puedo hacer renders, quiero contarte en detalle c√≥mo puedes hacerlo t√∫ mismo. </p><br><p>  <i>Nota: no tiene sentido mirar mi c√≥digo ni leer este art√≠culo con una taza de t√© en la mano.</i>  <i>Este art√≠culo est√° dise√±ado para que usted tome el teclado e implemente su propio motor de renderizado.</i>  <i>Seguramente ser√° mejor que el m√≠o.</i>  <i>¬°Al menos cambie el lenguaje de programaci√≥n!</i> </p><br><p>  Por lo tanto, el objetivo de hoy es aprender a representar esas im√°genes: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><a name="habracut"></a><br><h1>  Paso 1: escribe una imagen en el disco </h1><br><p>  No quiero molestarme con los administradores de ventanas, el procesamiento del mouse / teclado y cosas as√≠.  El resultado de nuestro programa ser√° una simple imagen guardada en el disco.  Entonces, lo primero que debemos poder hacer es guardar la imagen en el disco.  <a href="https://github.com/ssloy/tinyraytracer/tree/bd36c9857305b3cbd06f5b768bb48a92df9ae68b">Aqu√≠</a> puede encontrar el c√≥digo que nos permite hacer esto.  D√©jame enumerar el archivo principal: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br><p>  Solo se llama a render () en la funci√≥n principal y nada m√°s.  ¬øQu√© hay dentro de la funci√≥n render ()?  En primer lugar, defino el framebuffer como una matriz unidimensional de valores Vec3f, esos son simples vectores tridimensionales que nos dan valores (r, g, b) para cada p√≠xel.  La clase de vectores vive en el archivo geometry.h, no lo describir√© aqu√≠: es realmente una manipulaci√≥n trivial de vectores bidimensionales y tridimensionales (suma, resta, asignaci√≥n, multiplicaci√≥n por un producto escalar, escalar). </p><br><p>  Guardo la imagen en <a href="https://en.wikipedia.org/wiki/Netpbm_format">formato ppm</a> .  Es la forma m√°s f√°cil de guardar im√°genes, aunque no siempre es la forma m√°s conveniente de verlas m√°s.  Si desea guardar en otros formatos, le recomiendo que vincule una biblioteca de terceros, como <a href="https://github.com/nothings/stb">stb</a> .  Esta es una gran biblioteca: solo necesita incluir un archivo de encabezado stb_image_write.h en el proyecto, y le permitir√° guardar im√°genes en los formatos m√°s populares. </p><br><p>  <b>Advertencia:</b> mi c√≥digo est√° lleno de errores, los soluciono en el flujo ascendente, pero las confirmaciones anteriores se ven afectadas.  Revisa <a href="https://github.com/ssloy/tinyraycaster/issues/9">este problema</a> . </p><br><p>  Entonces, el objetivo de este paso es asegurarnos de que podemos a) crear una imagen en la memoria + asignar diferentes colores yb) guardar el resultado en el disco.  Luego puede verlo en un software de terceros.  Aqu√≠ est√° el resultado: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg" alt="imagen"></p><br><h1>  Paso 2, el crucial: trazado de rayos </h1><br><p>  Este es el paso m√°s importante y dif√≠cil de toda la cadena.  Quiero definir una esfera en mi c√≥digo y dibujarla sin estar obsesionada con los materiales o la iluminaci√≥n.  As√≠ es como deber√≠a verse nuestro resultado: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg" alt="imagen"></p><br><p>  Por conveniencia, tengo un commit por paso en mi repositorio;  Github hace que sea muy f√°cil ver los cambios realizados.  <a href="https://github.com/ssloy/tinyraytracer/commit/5806eb45e93dab225ab335824cbc3f537d511b28">Aqu√≠, por ejemplo</a> , lo que cambi√≥ la segunda confirmaci√≥n. </p><br><p>  Para empezar, ¬øqu√© necesitamos para representar la esfera en la memoria de la computadora?  Cuatro n√∫meros son suficientes: un vector tridimensional para el centro de la esfera y un escalar que describe el radio: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre> <br><p>  Lo √∫nico no trivial en este c√≥digo es una funci√≥n que le permite verificar si un rayo dado (que se origina en orig en la direcci√≥n de dir) se cruza con nuestra esfera.  Puede encontrar una descripci√≥n detallada del algoritmo para la intersecci√≥n de la esfera de rayos <a href="http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/">aqu√≠</a> , le recomiendo que haga esto y verifique mi c√≥digo. </p><br><p>  ¬øC√≥mo funciona el trazado de rayos?  Es bastante simple  En el primer paso, simplemente llenamos la imagen con un degradado de colores: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><p>  Ahora para cada p√≠xel formaremos un rayo que viene del origen y pasa a trav√©s de nuestro p√≠xel, y luego verificaremos si este rayo se cruza con la esfera: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><p>  Si no hay intersecci√≥n con la esfera, dibujamos el p√≠xel con color1, de lo contrario con color2: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { Ôøº [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } Ôøº [...] }</span></span></code> </pre> <br><p>  En este punto, le recomiendo que tome un l√°piz y verifique en papel todos los c√°lculos (la intersecci√≥n de la esfera de rayos y el barrido de la imagen con los rayos).  Por si acaso, nuestra c√°mara est√° determinada por lo siguiente: </p><br><ul><li>  ancho de la imagen </li><li>  altura de la imagen </li><li>  √°ngulo del campo de visi√≥n </li><li>  ubicaci√≥n de la c√°mara, Vec3f (0.0.0) </li><li>  ver la direcci√≥n, a lo largo del eje z, en la direcci√≥n de menos infinito </li></ul><br><p>  Perm√≠tanme ilustrar c√≥mo calculamos la direcci√≥n inicial del rayo para trazar.  En el bucle principal tenemos esta f√≥rmula: </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = (<span class="hljs-number"><span class="hljs-number">2</span></span>*(i + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>)*width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y = -(<span class="hljs-number"><span class="hljs-number">2</span></span>*(j + <span class="hljs-number"><span class="hljs-number">0.5</span></span>)/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height - <span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">tan</span></span>(fov/<span class="hljs-number"><span class="hljs-number">2.</span></span>);</code> </pre> <br><p>  De donde viene?  Bastante simple  Nuestra c√°mara se coloca en el origen y se enfrenta a la direcci√≥n -z.  Perm√≠tanme ilustrar las cosas, esta imagen muestra la c√°mara desde arriba, el eje y apunta fuera de la pantalla: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e00/5c1/b99/e005c1b996cc7eb9978bc434f6773196.png" alt="imagen"></p><br><p>  Como dije, la c√°mara se coloca en el origen y la escena se proyecta en la pantalla que se encuentra en el plano z = -1.  El campo de visi√≥n especifica qu√© sector del espacio ser√° visible en la pantalla.  En nuestra imagen, la pantalla tiene 16 p√≠xeles de ancho;  ¬øPuedes calcular su longitud en coordenadas mundiales?  Es bastante simple: centr√©monos en el tri√°ngulo formado por la l√≠nea discontinua roja, gris y gris.  Es f√°cil ver que el bronceado (campo de visi√≥n / 2) = (ancho de pantalla) <em>0.5 / (distancia de pantalla-c√°mara).</em>  <em>Colocamos la pantalla a la distancia de 1 de la c√°mara, por lo tanto (ancho de pantalla) = 2</em> tan (campo de visi√≥n / 2). </p><br><p>  Ahora digamos que queremos proyectar un vector a trav√©s del centro del duod√©cimo p√≠xel de la pantalla, es decir, queremos calcular el vector azul.  ¬øC√≥mo podemos hacer eso?  ¬øCu√°l es la distancia desde la izquierda de la pantalla hasta la punta del vector azul?  En primer lugar, tiene 12 + 0.5 p√≠xeles.  Sabemos que 16 p√≠xeles de la pantalla corresponden a 2 <em>unidades mundiales tan (fov / 2).</em>  <em>Por lo tanto, la punta del vector est√° ubicada en (12 + 0.5) / 16</em> 2 <em>unidades mundiales (tan (fov / 2)) desde el borde izquierdo, o en la distancia de (12 + 0.5)</em> 2/16 * tan (fov / 2) - tan (fov / 2) desde la intersecci√≥n entre la pantalla y el eje -z.  Agregue la relaci√≥n de aspecto de la pantalla a los c√°lculos y encontrar√° exactamente las f√≥rmulas para la direcci√≥n del rayo. </p><br><h1>  Paso 3: agrega m√°s esferas </h1><br><p>  La parte m√°s dif√≠cil ha terminado, y ahora nuestro camino est√° despejado.  Si sabemos c√≥mo dibujar una esfera, no nos llevar√° mucho tiempo agregar algunas m√°s.  <a href="https://github.com/ssloy/tinyraytracer/commit/c19c430151cb659372b4988876173b022164e371">Verifique los cambios</a> en el c√≥digo, y esta es la imagen resultante: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg" alt="imagen"></p><br><h1>  Paso 4: iluminaci√≥n </h1><br><p>  La imagen es perfecta en todos los aspectos, excepto por la falta de luz.  En el resto del art√≠culo hablaremos sobre iluminaci√≥n.  Agreguemos algunas fuentes de luz puntuales: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre> <br><p>  Calcular la iluminaci√≥n global real es una tarea muy, muy dif√≠cil, por lo que, como todos los dem√°s, enga√±aremos al ojo dibujando resultados completamente no f√≠sicos, pero visualmente plausibles.  Para empezar: ¬øpor qu√© hace fr√≠o en invierno y calor en verano?  Porque el calentamiento de la superficie de la Tierra depende del √°ngulo de incidencia de los rayos solares.  Cuanto m√°s alto sale el sol sobre el horizonte, m√°s brillante es la superficie.  Por el contrario, cuanto m√°s bajo est√° por encima del horizonte, m√°s tenue es.  Y despu√©s de que el sol se pone en el horizonte, los fotones ni siquiera nos alcanzan. </p><br><p>  Retroceda nuestras esferas: emitimos un rayo desde la c√°mara (¬°sin relaci√≥n con los fotones!) Cuando se detiene en una esfera.  ¬øC√≥mo sabemos la intensidad de la iluminaci√≥n del punto de intersecci√≥n?  De hecho, es suficiente verificar el √°ngulo entre un vector normal en este punto y el vector que describe una direcci√≥n de la luz.  Cuanto m√°s peque√±o es el √°ngulo, mejor se ilumina la superficie.  Recuerde que el producto escalar entre dos vectores ayb es igual al producto de normas de vectores multiplicado por el coseno del √°ngulo entre los vectores: a * b = | a |  | b |  cos (alfa (a, b)).  Si tomamos vectores de longitud unitaria, el producto de puntos nos dar√° la intensidad de la iluminaci√≥n de la superficie. </p><br><p>  Por lo tanto, en la funci√≥n cast_ray, en lugar de un color constante, devolveremos el color teniendo en cuenta las fuentes de luz: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre> <br><p>  Las modificaciones del paso anterior <a href="https://github.com/ssloy/tinyraytracer/commit/9a728fff2bbebb1eedd86e1ac89f657d43191609">est√°n disponibles aqu√≠</a> , y aqu√≠ est√° el resultado: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg" alt="imagen"></p><br><h1>  Paso 5: iluminaci√≥n especular </h1><br><p>  El truco del producto de puntos ofrece una buena aproximaci√≥n de la iluminaci√≥n de superficies mate, en la literatura se llama iluminaci√≥n difusa.  ¬øQu√© debemos hacer si queremos dibujar superficies brillantes?  Quiero obtener una foto como esta: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg" alt="imagen"></p><br><p>  Comprueba <a href="https://github.com/ssloy/tinyraytracer/commit/f5ec45c2541feb86b6a30cc3bb04917d60d13e9b">las pocas modificaciones</a> necesarias.  En resumen, cuanto m√°s brillante sea la luz en las superficies brillantes, menor ser√° el √°ngulo entre la direcci√≥n de la vista y la direcci√≥n de la luz <i>reflejada</i> . </p><br><p>  Este truco con iluminaci√≥n de superficies mates y brillantes se conoce como <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">modelo de reflexi√≥n de Phong</a> .  La wiki tiene una descripci√≥n bastante detallada de este modelo de iluminaci√≥n.  Puede ser agradable leerlo junto con el c√≥digo fuente.  Aqu√≠ est√° la imagen clave para entender la magia: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png" alt="imagen"></p><br><h1>  Paso 6: sombras </h1><br><p>  ¬øPor qu√© tenemos la luz, pero no las sombras?  No esta bien!  Quiero esta foto: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg" alt="imagen"></p><br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/ef70d1356169dacb3183ad4fcb4c23f1d7003e1b">Solo seis l√≠neas de c√≥digo</a> nos permiten lograr esto: al dibujar cada punto, solo nos aseguramos de que el segmento entre el punto actual y la fuente de luz no se cruza con los objetos de nuestra escena.  Si hay una intersecci√≥n, omitimos la fuente de luz actual.  Solo hay una peque√±a sutileza: perturbo el punto movi√©ndolo en la direcci√≥n normal: </p><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre> <br><p>  ¬øPor qu√© es eso?  Es solo que nuestro punto se encuentra en la superficie del objeto y (a excepci√≥n de la cuesti√≥n de los errores num√©ricos) cualquier rayo de este punto se cruzar√° con el objeto mismo. </p><br><h1>  Paso 7: reflexiones </h1><br><p>  Es incre√≠ble, pero para agregar reflexiones a nuestro render, solo necesitamos agregar tres l√≠neas de c√≥digo: </p><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre> <br><p>  <a href="https://github.com/ssloy/tinyraytracer/commit/c80479d1d22fe98f41b584972affeb43422a23a6">V√©alo usted mismo:</a> al intersecar la esfera, simplemente calculamos el rayo reflejado (¬°con la ayuda de la misma funci√≥n que usamos para los reflejos especulares!) Y llamamos recursivamente a la funci√≥n cast_ray en la direcci√≥n del rayo reflejado.  Aseg√∫rate de jugar con <a href="">la profundidad de recursi√≥n</a> , la configur√© en 4, prueba diferentes valores que comienzan con 0, ¬øqu√© cambiar√° en la imagen?  Aqu√≠ est√° mi resultado con reflexiones y una profundidad de recursi√≥n de 4: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg" alt="imagen"></p><br><h1>  Paso 8: refracciones </h1><br><p>  Si sabemos hacer reflexiones, las <a href="https://github.com/ssloy/tinyraytracer/commit/b69793bf6e8be54973cad1b18185a67dbf11bad1">refracciones son f√°ciles</a> .  Necesitamos agregar una funci√≥n para calcular el rayo refractado ( <a href="https://en.wikipedia.org/wiki/Snell%2527s_law">usando la ley de Snell</a> ), y tres l√≠neas m√°s de c√≥digo en nuestra funci√≥n recursiva cast_ray.  Aqu√≠ est√° el resultado donde la bola m√°s cercana est√° "hecha de vidrio", refleja y refracta la luz al mismo tiempo: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg" alt="imagen"></p><br><h1>  Steo 9: m√°s all√° de las esferas </h1><br><p>  Hasta este momento, representamos solo esferas porque es uno de los objetos matem√°ticos no triviales m√°s simples.  Agreguemos un plano.  El tablero de ajedrez es una opci√≥n cl√°sica.  Para este prop√≥sito, es suficiente agregar <a href="https://github.com/ssloy/tinyraytracer/commit/5e0da1f09fdbc585caa16df4c7b2f527d61536ef">una docena de l√≠neas</a> . </p><br><p>  Y aqu√≠ est√° el resultado: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><p>  Seg√∫n lo prometido, el c√≥digo tiene 256 l√≠neas de c√≥digo, ¬° <a href="https://github.com/ssloy/tinyraytracer">compru√©belo usted mismo</a> ! </p><br><h1>  Paso 10: asignaci√≥n de casa </h1><br><p>  Hemos recorrido un largo camino: hemos aprendido c√≥mo agregar objetos a una escena, c√≥mo calcular una iluminaci√≥n bastante complicada.  D√©jame dejarte dos tareas como tarea.  Absolutamente todo el trabajo preparatorio ya se ha hecho en la sucursal <a href="https://github.com/ssloy/tinyraytracer/tree/homework_assignment">tarea_asignaci√≥n</a> .  Cada tarea requerir√° diez l√≠neas de c√≥digo superior. </p><br><h3>  Tarea 1: mapa del entorno </h3><br><p>  Por el momento, si el rayo no se cruza con ning√∫n objeto, simplemente configuramos el p√≠xel con el color de fondo constante.  ¬øY por qu√©, en realidad, es constante?  ¬°Tomemos una foto esf√©rica (archivo <a href="">envmap.jpg</a> ) y <a href="">√∫sela</a> como fondo!  Para facilitar la vida, vincul√© nuestro proyecto con la biblioteca stb para la conveniencia de trabajar con el formato jpg.  Deber√≠a darnos esa imagen: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg" alt="imagen"></p><br><h3>  Tarea 2: quack-quack! </h3><br><p>  Podemos representar tanto esferas como planos (ver el tablero de ajedrez).  ¬°Entonces dibujemos mallas triangulares!  Escrib√≠ un c√≥digo que le permite leer un archivo .obj y le agregu√© una funci√≥n de intersecci√≥n de tri√°ngulo de rayos.  Ahora agregar el pato a nuestra escena deber√≠a ser bastante trivial: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg" alt="imagen"></p><br><h1>  Conclusi√≥n </h1><br><p>  Mi objetivo principal es mostrar proyectos que sean interesantes (¬°y f√°ciles!) De programar.  Estoy convencido de que para convertirse en un buen programador hay que hacer muchos proyectos paralelos.  No s√© sobre ti, pero personalmente no me atraen el software de contabilidad y el juego de buscaminas, incluso si la complejidad del c√≥digo es bastante comparable. </p><br><p>  Pocas horas y doscientas cincuenta l√≠neas de c√≥digo nos dan un trazador de rayos.  <a href="https://github.com/ssloy/tinyrenderer/wiki">Se pueden hacer quinientas l√≠neas</a> del rasterizador de software en unos pocos d√≠as.  ¬°Los gr√°ficos son realmente geniales para aprender la programaci√≥n! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/477244/">https://habr.com/ru/post/477244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../477238/index.html">Adem√°s de Karma: por qu√© se critica el desbordamiento de pila y por qu√© muchos se quejan de la toxicidad comunitaria</a></li>
<li><a href="../477242/index.html">C√≥mo elegimos ServiceDesk. Parte 3</a></li>
<li><a href="../477248/index.html">Mi primera experiencia recuperando una base de datos Postgres despu√©s de un bloqueo (p√°gina no v√°lida en el bloque 4123007 de relatton base / 16490)</a></li>
<li><a href="../477250/index.html">¬øEntonces quieres ejecutar Windows 10 en una calculadora? Esta bien</a></li>
<li><a href="../477252/index.html">C√≥mo se desarrollaron las incubadoras y los aceleradores de negocios: del laboratorio de Thomas Edison al combinador Y</a></li>
<li><a href="../477254/index.html">Autenticaci√≥n XSS, CSRF y Flash. Resoluci√≥n de problemas con r0ot-mi Web - Cliente. Parte 2</a></li>
<li><a href="../477256/index.html">El primer lanzamiento completo de OneWeb en el veh√≠culo de lanzamiento Soyuz se pospone el pr√≥ximo a√±o, as√≠ como el lanzamiento del veh√≠culo de lanzamiento Angara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>