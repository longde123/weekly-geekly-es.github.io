<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§† üßõüèª ü§òüèø Infraestrutura de chave p√∫blica Cadeia de certificados raiz X509 v.3 üîâ üï¥üèΩ üë®‚Äçüë®‚Äçüëß‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A hora "H" est√° inexoravelmente se aproximando: "o uso do esquema de assinaturas GOST R 34.10-2001 para gerar uma assinatura ap√≥s 31 de dezembro de 20...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Infraestrutura de chave p√∫blica Cadeia de certificados raiz X509 v.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436370/"><img src="https://habrastorage.org/webt/tk/9x/m3/tk9xm3b0z6etzpbcvbk2qypdgmo.png" align="left"><blockquote>  A hora "H" est√° inexoravelmente se aproximando: "o uso do esquema de assinaturas GOST R 34.10-2001 para gerar uma assinatura ap√≥s 31 de dezembro de 2018 n√£o √© permitido!". </blockquote><a name="habracut"></a>  No entanto, algo deu errado, algu√©m n√£o estava pronto e o uso do GOST R 34.10-2001 foi estendido para 2019.  Mas, de repente, todos correram para transferir a CA para o GOST R 34.10-2012 e para transferir cidad√£os comuns para novos certificados.  As pessoas t√™m v√°rios certificados em suas m√£os.  Ao verificar certificados ou assinaturas eletr√¥nicas, come√ßaram a surgir perguntas e onde obter certificados raiz para instalar no armazenamento de certificados raiz confi√°veis. <br><br>  Isso se aplica aos armazenamentos de certificados no Windows e armazenamentos de certificados no Firefox e Google Chrome, GnuPG, LibreOffice, clientes de email e at√© OpenSSL.  Obviamente, era necess√°rio cuidar disso ao receber o certificado na CA e gravar a cadeia de certificados na unidade flash USB.  Por outro lado, temos uma sociedade digital e, a qualquer momento, devemos conseguir essa cadeia da rede.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">O Simpleadmin</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mostrou</a> como fazer isso nas p√°ginas da Habr.  No entanto, para um cidad√£o comum ainda √© dif√≠cil (especialmente se voc√™ levar em conta que a grande maioria deles est√° no Windows): voc√™ precisa ter algum tipo de openssl, um utilit√°rio de busca que eu n√£o tinha no meu computador e nem todo mundo sabe que voc√™ pode usar o wget.  E quantas a√ß√µes precisam ser executadas.  √â claro que existe uma sa√≠da, escreva um script, mas n√£o apenas um script sobre o openssl e seu tipo, mas empacotado em um m√≥dulo execut√°vel independente para v√°rias plataformas. <br><br>  N√£o havia d√∫vida sobre o que escrever - no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tcl e no Python</a> .  E come√ßamos com Tcl e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">√© por isso</a> : <br><blockquote>  * porra de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki,</a> onde existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">at√© brinquedos</a> (voc√™ pode ver coisas interessantes l√° :) <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folhas de dicas</a> <br>  * <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compila√ß√µes</a> normais do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tclkit</a> (1,5 - 2 MB como taxa para plataformas reais reais) <br>  * e minha montagem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eTcl</a> favorita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">da Evolane</a> (cuidadosamente preservada do local do falecido :( <br>  manter uma classifica√ß√£o Tcl / Tk alta na minha lista de kits de ferramentas pessoais <br>  e, sim, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki.tcl.tk/16867</a> (um pequeno servidor web de cgi para Tcl, usado periodicamente com const√¢ncia invej√°vel no tclkit) <br>  e tamb√©m √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lindo</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lindo</a> :) </blockquote>  Para isso, acrescentaria a disponibilidade do utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">freewrap</a> , que nos ajudar√° a criar utilit√°rios aut√¥nomos para Linux e MS Windows.  Como resultado, teremos o utilit√°rio chainfromcert: <br><br><pre><code class="bash hljs">bash-4.3$ ./chainfromcert_linux64 Copyright(C)2019 Usage: chainfromcert &lt;file with certificate&gt; &lt;directory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chain certificate&gt; Bad usage! bash-4.3$</code> </pre> <br>  Como par√¢metros, o utilit√°rio define um arquivo com um certificado de usu√°rio (tanto no formato PEM quanto no formato DER) e o diret√≥rio no qual os certificados de CA inclu√≠dos na cadeia ser√£o salvos: <br><br><pre> <code class="bash hljs">bash-4.3$ ./chainfromcert_linux64 ./cert_test.der /tmp Loading file: cert_test.der Directory <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> chain: . cert 1 from http://ca.ekey.ru/cdp/ekeyUC2012.cer cert 2 from http://reestr-pki.ru/cdp/guc_gost12.crt Goodby! Length chain=2 Copyright(C) 2019 bash-4.3$</code> </pre> <br>  Agora considere como o utilit√°rio funciona. <br>  As informa√ß√µes sobre a autoridade de certifica√ß√£o que emitiu o certificado para o usu√°rio s√£o armazenadas na extens√£o com oid 1.3.6.1.5.5.7.1.1.  Essa extens√£o pode armazenar o local do certificado da CA (oid 1.3.6.1.5.5.7.48.2) e as informa√ß√µes sobre o servi√ßo de CA do OCSP (oid 1.3.6.1.5.5.7.48.1): <br><br><img src="https://habrastorage.org/webt/v2/rg/n5/v2rgn5yw6sjb3pygp-vziqcvrys.png"><br><br>  E informa√ß√µes, por exemplo, sobre o per√≠odo de uso da chave de assinatura eletr√¥nica s√£o armazenadas na extens√£o com oid 2.5.29.16. <br><br>  Para analisar o certificado e acessar as extens√µes de certificado, usaremos o pacote pki: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh -f package require pki</code> </pre> <br>  Tamb√©m precisaremos do pacote base64: <br><br><pre> <code class="plaintext hljs">package require base64</code> </pre> <br>  O pacote pki, assim como o pacote asn e o pacote base64 que ele carrega, nos ajudar√£o a converter certificados de uma codifica√ß√£o PEM para DER, analisar estruturas ASN e acessar informa√ß√µes sobre a localiza√ß√£o dos certificados da CA. <br><br>  O utilit√°rio come√ßa com a verifica√ß√£o dos par√¢metros e o download do arquivo com o certificado: <br><br><pre> <code class="plaintext hljs">proc usage {use } { puts "Copyright(C) 2011-2019" if {$use == 1} { puts "Usage:\nchainfromcert &lt;file with certificate&gt; &lt;directory for chain certificate&gt;\n" } } if {[llength $argv] != 2 } { usage 1 puts "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { puts "File $file not exist" usage 1 exit } puts "Loading file: $file" set dir [lindex $argv 1] if {![file exists $dir]} { puts "Dir $dir not exist" usage 1 exit } puts "Directory for chain: $dir" set fd [open $file] chan configure $fd -translation binary set data [read $fd] close $fd if {$data == "" } { puts "Bad file with certificate=$file" usage 1 exit }</code> </pre> <br>  Tudo est√° claro aqui e observamos apenas uma coisa - o arquivo com o certificado √© considerado como um arquivo bin√°rio: <br><br><pre> <code class="plaintext hljs">chan configure $fd -translation binary</code> </pre> <br>  Isso ocorre porque o certificado pode ser armazenado no formato DER (c√≥digo bin√°rio) e no formato PEM (codifica√ß√£o base64). <br><br>  Depois que o arquivo √© carregado, o procedimento chainfromcert √© chamado: <br><br><pre> <code class="plaintext hljs">set depth [chainfromcert $data $dir]</code> </pre>  que efetivamente baixa os certificados raiz: <br><br><pre> <code class="plaintext hljs">proc chainfromcert {cert dir} { if {$cert == "" } { exit } set asndata [cert_to_der $cert] if {$asndata == "" } { #    ,    return -1 } array set cert_parse [::pki::x509::parse_cert $asndata] array set extcert $cert_parse(extensions) if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} { #    return 0 } set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0] # if {$a == "false"} { # puts $a # } # ASN1-   Hex- set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1] #    set c [binary format H* $b] #Sequence 1.3.6.1.5.5.7.1.1 ::asn::asnGetSequence c c_par_first #     1.3.6.1.5.5.7.1.1 while {[string length $c_par_first] &gt; 0 } { #   (sequence) ::asn::asnGetSequence c_par_first c_par # oid   ::asn::asnGetObjectIdentifier c_par c_type set tas1 [::pki::_oid_number_to_name $c_type] #   ::asn::asnGetContext c_par c_par_two # oid     if {$tas1 == "1.3.6.1.5.5.7.48.2" } { #    set certca [readca $c_par $dir] if {$certca == ""} { #   .      continue } else { global count #      set f [file join $dir [file tail $c_par]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $certca close $fd incr count puts "cert $count from $c_par" #     chainfromcert $certca $dir continue } } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } { # puts "OCSP server (oid=$tas1)=$c_par" } } #   return $count }</code> </pre> <br>  N√£o h√° nada a acrescentar aos coment√°rios, mas ainda n√£o consideramos o procedimento readca: <br><pre> <code class="plaintext hljs">proc readca {url dir} { set cer "" #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer }</code> </pre> <br>  Este procedimento √© baseado no uso do pacote http: <br><br><pre> <code class="plaintext hljs">package require http</code> </pre> <br>  Para ler o certificado, usamos a seguinte fun√ß√£o: <br><br><pre> <code class="plaintext hljs">set token [http::geturl $url -binary 1]</code> </pre> <br>  O objetivo das demais fun√ß√µes utilizadas √© claro nos coment√°rios.  Apenas forneceremos uma descriptografia de c√≥digos de retorno para a fun√ß√£o http :: ncodel: <br><blockquote>  200 Pedido conclu√≠do com sucesso <br>  206 Pedido conclu√≠do com sucesso, mas apenas parte do arquivo foi baixada <br>  301 Arquivo movido para outro local. <br>  302 Arquivo movido temporariamente para outro local. <br>  401 autentica√ß√£o de servidor necess√°ria <br>  403 O acesso a este recurso foi negado <br>  404 O recurso especificado n√£o pode ser encontrado. <br>  500 Erro interno </blockquote>  Um procedimento ainda precisa ser considerado, a saber cert_to_der: <br><br><pre> <code class="plaintext hljs">proc cert_to_der {data} { set lines [split $data \n] set hlines 0 set total 0 set first 0 # PEM-   foreach line $lines { incr total if {[regexp {^-----BEGIN CERTIFICATE-----$} $line]} { if {$first} { incr total -1 break } else { set first 1 incr hlines } } if {[regexp {^(.*):(.*)$} $line ]} { incr hlines } } if { $first == 0 &amp;&amp; [string range $data 0 0 ] == "0" } { #   DER- "0" == 0x30 return $data } if {$first == 0} {return ""} set block [join [lrange $lines $hlines [expr {$total-1}]]] #from PEM to DER set asnblock [base64::decode $block] return $asnblock }</code> </pre> <br>  O procedimento √© muito simples.  Se este for um arquivo PEM com um certificado ("----- BEGIN CERTIFICATE -----"), o corpo desse arquivo ser√° selecionado e convertido em um c√≥digo de bin√°rios: <br><br><pre> <code class="plaintext hljs">set asnblock [base64::decode $block]</code> </pre> <br>  Se este n√£o √© um arquivo PEM, essa ‚Äúsemelhan√ßa‚Äù com a codifica√ß√£o asn √© verificada (o bit zero deve ser 0x30). <br><br>  Isso √© tudo, resta adicionar as linhas finais: <br><br><pre> <code class="plaintext hljs">if {$depth == -1} { puts "Bad file with certificate=$file" usage 1 exit } puts "Goodby!\nLength chain=$depth" usage 0 exit</code> </pre><br>  Agora coletamos tudo em um arquivo com o nome <br><br><div class="spoiler">  <b class="spoiler_title">chainfromcert.tcl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#!/usr/bin/tclsh encoding system utf-8 package require pki package require base64 #package require asn package require http global count set count 0 proc chainfromcert {cert dir} { if {$cert == "" } { exit } set asndata [cert_to_der $cert] if {$asndata == "" } { #    ,    return -1 } array set cert_parse [::pki::x509::parse_cert $asndata] array set extcert $cert_parse(extensions) if {![info exists extcert(1.3.6.1.5.5.7.1.1)]} { #    return 0 } set a [lindex $extcert(1.3.6.1.5.5.7.1.1) 0] # if {$a == "false"} { # puts $a # } # ASN1-   Hex- set b [lindex $extcert(1.3.6.1.5.5.7.1.1) 1] #    set c [binary format H* $b] #Sequence 1.3.6.1.5.5.7.1.1 ::asn::asnGetSequence c c_par_first #     1.3.6.1.5.5.7.1.1 while {[string length $c_par_first] &gt; 0 } { #   (sequence) ::asn::asnGetSequence c_par_first c_par # oid   ::asn::asnGetObjectIdentifier c_par c_type set tas1 [::pki::_oid_number_to_name $c_type] #   ::asn::asnGetContext c_par c_par_two # oid     if {$tas1 == "1.3.6.1.5.5.7.48.2" } { #    set certca [readca $c_par $dir] if {$certca == ""} { #   .      continue } else { global count #      set f [file join $dir [file tail $c_par]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $certca close $fd incr count puts "cert $count from $c_par" #     chainfromcert $certca $dir continue } } elseif {$tas1 == "1.3.6.1.5.5.7.48.1" } { # puts "OCSP server (oid=$tas1)=$c_par" } } #   return $count } proc readca {url dir} { set cer "" #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer } proc cert_to_der {data} { set lines [split $data \n] set hlines 0 set total 0 set first 0 # PEM-   foreach line $lines { incr total # if {[regexp {^-----(.*?)-----$} $line]} {} if {[regexp {^-----BEGIN CERTIFICATE-----$} $line]} { if {$first} { incr total -1 break } else { set first 1 incr hlines } } if {[regexp {^(.*):(.*)$} $line ]} { incr hlines } } if { $first == 0 &amp;&amp; [string range $data 0 0 ] == "0" } { #   DER- "0" == 0x30 return $data } if {$first == 0} {return ""} set block [join [lrange $lines $hlines [expr {$total-1}]]] #from PEM to DER set asnblock [base64::decode $block] return $asnblock } proc usage {use } { puts "Copyright(C) Orlov Vladimir 2011-2019" if {$use == 1} { puts "Usage:\nchainfromcert &lt;file with certificate&gt; &lt;directory for chain certificate&gt;\n" } } if {[llength $argv] != 2 } { usage 1 puts "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { puts "File $file not exist" usage 1 exit } puts "Loading file: $file" set dir [lindex $argv 1] if {![file exists $dir]} { puts "Dir $dir not exist" usage 1 exit } puts "Directory for chain: $dir" set fd [open $file] chan configure $fd -translation binary set data [read $fd] close $fd if {$data == "" } { puts "Bad file with certificate=$file" usage 1 exit } set depth [chainfromcert $data $dir] if {$depth == -1} { puts "Bad file with certificate=$file" usage 1 exit } puts "Goodby!\nLength chain=$depth" usage 0 exit</code> </pre><br></div></div><br>  Voc√™ pode verificar a opera√ß√£o desse arquivo usando o interpretador tclsh: <br><br><pre> <code class="plaintext hljs">$ tclsh ./chainfromcert.tcl cert_orlov.der /tmp Loading file: cert_test.der Directory for chain: /tmp cert 1 from http://ca.ekey.ru/cdp/ekeyUC2012.cer cert 2 from http://reestr-pki.ru/cdp/guc_gost12.crt Goodby! Length chain=2 Copyright(C) 2019 $</code> </pre> <br>  Como resultado, obtivemos uma cadeia de dois certificados no diret√≥rio / tmp. <br><br>  Mas quer√≠amos obter m√≥dulos execut√°veis ‚Äã‚Äãpara as plataformas Linux e Windows, para que os usu√°rios n√£o pensassem em nenhum int√©rprete. <br><br>  Para esse fim, usaremos o utilit√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">freewrapTCLSH</a> .  Usando esse utilit√°rio, criaremos m√≥dulos execut√°veis ‚Äã‚Äãde nosso utilit√°rio para plataformas Linux e Windows, de 32 e 64 bits.  Utilit√°rios podem ser criados para todas as plataformas em qualquer plataforma.  Desculpe pela tautologia.  Vou construir no linux_x86_64 (Mageia). <br><br>  Para construir, voc√™ precisar√° de: <br><blockquote>  1. O utilit√°rio freewrapTCLSH para a plataforma linux_x86_64; <br>  2. O arquivo freewrapTCLSH com este utilit√°rio para cada plataforma: <br>  - freewrapTCLSH_linux32 <br>  - freewrapTCLSH_linux64 <br>  - freewrapTCLSH_win32 <br>  - freewrapTCLSH_win64 <br>  3. O arquivo de origem do nosso utilit√°rio: chainfromcert.tcl </blockquote>  Portanto, o execut√°vel chainfromcerty_linuxx86 montado para a plataforma Linux x86: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$freewrapTCLSH</span></span> chainfromcert.tcl ‚Äìw freewrapTCLSH_linux32 ‚Äìo chainfromcerty_linuxx86 $</code> </pre> <br>  A montagem do utilit√°rio para a plataforma Windows de 64 bits √© assim: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$freewrapTCLSH</span></span> chainfromcert.tcl ‚Äìw freewrapTCLSH_win64 ‚Äìo chainfromcerty_win64.exe $</code> </pre> <br>  Etc.  Os utilit√°rios est√£o prontos para uso.  Eles absorveram tudo o necess√°rio para o seu trabalho. <br>  O c√≥digo √© escrito da mesma maneira em Python. <br><br>  Nos pr√≥ximos dias, estou pensando em complementar o pacote <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fsb795</a> (escrito em Python) com a fun√ß√£o de obter a cadeia de certificados raiz. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt436370/">https://habr.com/ru/post/pt436370/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436354/index.html">Militares dos EUA negligenciam quest√µes de seguran√ßa cibern√©tica</a></li>
<li><a href="../pt436356/index.html">[Interessante por tr√°s da colina] Como paramos a depend√™ncia tecnol√≥gica?</a></li>
<li><a href="../pt436358/index.html">Por que os desenvolvedores seniores ensinam os alunos</a></li>
<li><a href="../pt436360/index.html">Preciso ir r√°pido: Criando velocidade no iOS. Parte 1</a></li>
<li><a href="../pt436364/index.html">O Liveprof mostrar√° quando e por que o desempenho do seu aplicativo PHP mudou</a></li>
<li><a href="../pt436372/index.html">Plug-in isom√©trico para Unity3D</a></li>
<li><a href="../pt436374/index.html">Tend√™ncias de design da interface do usu√°rio e do UX 2019</a></li>
<li><a href="../pt436376/index.html">Vis√£o geral do rob√¥ todo-o-terreno EZ-Robot Roli Rover</a></li>
<li><a href="../pt436378/index.html">bobaos.pub - KNX TP / UART, Raspberry Pi e Redis</a></li>
<li><a href="../pt436380/index.html">In√≠cio r√°pido na impress√£o 3D: impressoras econ√¥micas para iniciantes ou tecnologia para as massas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>