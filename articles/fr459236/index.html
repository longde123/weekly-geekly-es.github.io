<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏽 🛷 🍲 SQL: solution de tâche de temps de travail 🐳 👩🏽‍💻 👨🏼‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Radio SQL est à nouveau diffusée! Aujourd'hui, nous avons une solution au problème que nous avions transmis lors de notre précédente émission...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL: solution de tâche de temps de travail</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459236/"><p>  Bonjour, Radio SQL est à nouveau diffusée!  Aujourd'hui, nous avons une solution au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème</a> que nous avions transmis lors de notre précédente émission et que nous avions promis de distinguer la prochaine fois.  Et cette prochaine fois est venue. </p><br><p>  La tâche a suscité une réponse vive parmi les humanoïdes de la galaxie de la Voie lactée (et sans surprise, avec leur esclavage de travail, qu'ils respectent toujours au profit de la civilisation).  Malheureusement, sur la troisième planète, le lancement de l'observatoire spatial Spektr-RG a été reporté fin juillet 2019, la RC (chronologie locale), à ​​l'aide de laquelle il était prévu de diffuser cette émission.  J'ai dû chercher des voies de transmission alternatives, ce qui a entraîné un léger retard dans le signal.  Mais tout va bien qui se termine bien. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rc/a6/z4/rca6z4cduxlps2le_c4l_3rwnrg.png"></div><br><p>  Je dois dire tout de suite qu'il n'y aura pas de magie dans l'analyse de la tâche, il n'est pas nécessaire de chercher des révélations ici ou d'attendre une mise en œuvre particulièrement efficace (ou surtout certaines dans un autre sens).  Ce n'est qu'une tâche d'analyse.  Ceux qui ne savent pas comment aborder la solution de ces problèmes pourront voir comment les résoudre.  De plus, il n'y a rien de terrible ici. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Permettez-moi de vous rappeler la condition.</b> <div class="spoiler_text"><p>  Il y a plusieurs intervalles de temps spécifiés par la date-heure de son début et de sa fin (un exemple dans la syntaxe PostgreSQL): </p><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:07:12'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>), (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) )</code> </pre> <br><p>  Il est requis dans une requête SQL (c) pour calculer la durée de chaque intervalle en heures de travail.  Nous pensons que nous travaillons en semaine du lundi au vendredi, les heures de travail sont toujours de 10h00 à 19h00.  En outre, conformément au calendrier de production de la Fédération de Russie, un certain nombre de jours fériés officiels ne sont pas des jours ouvrables, et certains jours de congé, au contraire, sont des jours ouvrables en raison du report de ces mêmes jours fériés.  Le raccourcissement des jours de pré-vacances n'est pas nécessaire, nous les considérons comme complets.  Étant donné que les vacances varient d'une année à l'autre, c'est-à-dire qu'elles sont fixées par une liste explicite, nous nous limiterons aux dates uniquement de 2018 et 2019.  Je suis sûr que, si nécessaire, la solution peut être facilement complétée. </p><br><p>  Il est nécessaire d'ajouter une colonne avec la durée en heures de travail aux périodes initiales des <em>périodes</em> .  Voici le résultat: </p><br><pre> <code class="pgsql hljs"> id | start_time | stop_time | work_hrs <span class="hljs-comment"><span class="hljs-comment">----+---------------------+---------------------+---------- 1 | 2019-03-29 07:00:00 | 2019-04-08 14:00:00 | 58:00:00 2 | 2019-04-10 07:00:00 | 2019-04-10 20:00:00 | 09:00:00 3 | 2019-04-11 12:00:00 | 2019-04-12 16:07:12 | 13:07:12 4 | 2018-12-28 12:00:00 | 2019-01-16 16:00:00 | 67:00:00</span></span></code> </pre> <br><p>  Nous ne vérifions pas l'exactitude des données initiales; nous considérons toujours <em>start_time &lt;= stop_time</em> . </p><br><p>  La fin de la condition, l'original est ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://habr.com/en/company/postgrespro/blog/448368/</a> . </p></div></div><br><p>  La tâche donne un léger piquant au fait que j'ai donné consciemment une bonne moitié de la condition sous une forme descriptive (comme c'est généralement le cas dans la vie réelle), laissant à la discrétion de la mise en œuvre technique la façon dont le calendrier de travail doit être fixé.  D'une part, cela nécessite certaines compétences de réflexion architecturale.  Et d'autre part, le format prêt à l'emploi de ce calendrier aurait incité une certaine utilisation de modèle de celui-ci.  Et si vous omettez, alors la pensée et la fantaisie fonctionneront plus pleinement.  L'accueil a porté ses fruits, ce qui m'a permis de trouver également des approches intéressantes dans les solutions publiées. </p><br><p>  Ainsi, pour résoudre le problème d'origine de cette manière, deux sous-tâches devront être résolues: </p><br><ol><li>  Déterminez comment définir le plus rapidement possible un horaire de travail, et même de manière à ce qu'il soit pratique à utiliser pour une solution. </li><li>  Calculez réellement la durée de chaque période source en heures de travail en fonction de l'horaire de travail de la sous-tâche précédente. </li></ol><br><p>  Et il vaut mieux commencer par le second, afin de comprendre sous quelle forme il faut résoudre le premier.  Résolvez ensuite le premier et revenez de nouveau au second afin d'obtenir le résultat final. <br>  Nous collecterons le résultat progressivement, en utilisant la syntaxe CTE, qui nous permet de mettre tous les échantillons de données nécessaires dans des sous-requêtes nommées distinctes, puis de tout lier ensemble. </p><br><p>  Eh bien, allons-y. </p><br><h3 id="poschitat-dlitelnost-v-rabochih-chasah">  Calculez la durée en heures de travail </h3><br><p>  Pour calculer la durée de chacune des périodes en heures de travail sur le front, vous devez croiser la période initiale (couleur verte sur le diagramme) avec les intervalles qui décrivent le temps de travail (orange).  Les intervalles d'heures de travail sont les lundis de 10h00 à 19h00, les mardis de 10h00 à 19h00 et ainsi de suite.  Le résultat est affiché en bleu: </p><br><p><img src="https://habrastorage.org/webt/o4/yh/6_/o4yh6_ca7loarlvtghe572p6zdo.png" alt="image"></p><br><p>  Soit dit en passant, afin de devenir moins confus, je continuerai à appeler les périodes initiales des périodes initiales, et j'appellerai des intervalles d'heures de travail. </p><br><p>  La procédure doit être répétée pour chaque période initiale.  Les périodes initiales pour nous sont déjà définies dans l' <em>onglet périodes (start_time, stop_time)</em> , nous représenterons les heures de travail sous la forme d'un tableau, disons, <em>horaire (strat_time, stop_time)</em> , où chaque jour ouvrable est présent.  Le résultat est un produit cartésien complet de toutes les périodes et intervalles initiaux du temps de travail. </p><br><p>  Les intersections peuvent être comptées de manière classique, après avoir considéré toutes les options possibles pour les intervalles d'intersection - nous intersectons le vert avec l'orange, le résultat est le bleu: </p><br><p><img src="https://habrastorage.org/webt/fx/aq/wo/fxaqwo7uud0kyzismeqn6cqeap0.png" alt="image"></p><br><p>  et en prenant dans chaque cas la valeur souhaitée pour le début et la fin du résultat: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.start_time, s.stop_time <span class="hljs-comment"><span class="hljs-comment">-- case #1 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &gt; s.stop_time union all select p.start_time, s.stop_time -- case #2 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &gt; s.stop_time and p.start_time &lt; s.stop_time union all select s.start_time, p.stop_time -- case #3 from periods p, schedule s where p.start_time &lt;= s.start_time and p.stop_time &lt; s.stop_time and p.stop_time &gt; s.start_time union all select p.start_time, p.stop_time -- case #4 from periods p, schedule s where p.start_time &gt;= s.start_time and p.stop_time &lt; s.stop_time</span></span></code> </pre> <br><p>  Étant donné que pour chaque intersection, nous ne pouvons avoir qu'une seule des quatre options, toutes sont combinées en une seule demande en utilisant <em>union all</em> . </p><br><p>  Vous pouvez faire autrement en utilisant le type de plage <em>tsrange</em> disponible dans PostgreSQL et l'opération d'intersection déjà disponible pour lui: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s</code> </pre> <br><p>  D'accord, alors - euh - un peu plus facile.  En général, il y a beaucoup de petites choses aussi pratiques dans PostgreSQL, donc écrire des requêtes dessus est très agréable. </p><br><h3 id="sgenerirovat-kalendar">  Générer un calendrier </h3><br><p>  Revenons maintenant à la sous-tâche avec le calendrier des heures de travail. </p><br><p>  Nous devons obtenir l'horaire de travail sous forme d'intervalles de temps de travail de 10h00 à 19h00 pour chaque jour ouvrable, quelque chose comme l' <em>horaire (start_time, stop_time)</em> .  Comme nous l'avons compris, il sera commode de résoudre notre problème.  Dans la vraie vie, un tel calendrier devrait être établi, pendant deux ans, il ne s'agit que d'environ 500 enregistrements, pour des raisons pratiques, il sera nécessaire de définir même dix ans - c'est un couple et demi mille enregistrements, de vrais déchets pour les bases de données modernes.  Mais nous avons un problème qui sera résolu en une seule demande, et lister l'ensemble de ce tableau n'est pas très pratique.  Essayons de l'implémenter de manière plus compacte. </p><br><p>  Dans tous les cas, nous avons besoin de jours fériés pour les supprimer de l'horaire de base, et ici seule la liste convient: </p><br><pre> <code class="pgsql hljs"> dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) )</span></span></code> </pre> <br><p>  et jours ouvrables supplémentaires à ajouter: </p><br><pre> <code class="pgsql hljs"> dates_include(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> <span class="hljs-comment"><span class="hljs-comment">--  2018,  2019  ('2018-04-28'::date), ('2018-06-09'::date), ('2018-12-29'::date) )</span></span></code> </pre> <br><p>  La séquence de jours ouvrables pendant deux ans peut être générée par une fonction spéciale et très appropriée <em>generate_series ()</em> , lançant immédiatement les samedis et dimanches en cours de route: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--    </span></span></code> </pre> <br><p>  Nous obtenons les jours ouvrables en connectant tout ensemble: nous générons une séquence de tous les jours ouvrables sur deux ans, ajoutons des jours ouvrables supplémentaires à <em>dates_include</em> et <em>supprimons</em> tous les jours supplémentaires à <em>dates_exclude</em> : </p><br><pre> <code class="pgsql hljs"> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series( <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span> , <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-comment"><span class="hljs-comment">--     union select d from dates_include --     except select d from dates_exclude --     )</span></span></code> </pre> <br><p>  Et maintenant, nous obtenons les intervalles de temps dont nous avons besoin: </p><br><pre> <code class="pgsql hljs"> schedule(start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>, d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base )</code> </pre> <br><p>  Donc, nous avons le calendrier. </p><br><h3 id="sobiraem-vsyo-vmeste">  Tout mettre ensemble </h3><br><p>  Nous allons maintenant obtenir les intersections: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time)</code> </pre> <br><p>  Faites attention à la condition de jointure <em>ON</em> , elle ne correspond pas à deux enregistrements correspondants des tables jointes, il n'y a pas une telle correspondance, mais une optimisation est introduite qui coupe les intervalles de temps de travail avec lesquels notre période initiale ne se coupe pas.  Cela se fait à l'aide de l'opérateur <em>&amp;&amp;</em> , qui vérifie l'intersection des intervalles <em>tsrange</em> .  Cela supprime beaucoup d'intersections vides afin de ne pas gêner les yeux, mais, d'autre part, supprime les informations sur les périodes initiales qui tombent entièrement en dehors des heures.  Nous admirons donc que notre approche fonctionne et réécrivons la demande comme suit: </p><br><pre> <code class="pgsql hljs"> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p , schedule s ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , sum(upper(wrkh)-lower(wrkh)) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Dans <em>périodes_wrk, nous</em> décomposons chaque période source en intervalles de travail, puis nous considérons leur durée totale.  Le résultat a été un produit cartésien complet de toutes les périodes et intervalles, mais pas une seule période n'a été perdue. </p><br><p>  Tout, le résultat est reçu.  Je n'aimais pas les valeurs <em>NULL</em> pour les intervalles vides, laissez la requête afficher un intervalle de longueur nulle mieux.  Enveloppez le montant en <em>fusion ()</em> : </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> id, start_time, stop_time , coalesce(sum(upper(wrkh)-lower(wrkh)), <span class="hljs-string"><span class="hljs-string">'0 sec'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> id, start_time, stop_time</code> </pre> <br><p>  Tous ensemble donne le résultat final: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-03-29 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-08 14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 07:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-10 20:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-11 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-04-12 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) , (<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-string"><span class="hljs-string">'2018-12-28 12:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-01-16 16:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamp</span></span>) ), dates_exclude(d) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>(<span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>), <span class="hljs-comment"><span class="hljs-comment">-- 2018 ('2018-01-02'::date), ('2018-01-03'::date), ('2018-01-04'::date), ('2018-01-05'::date), ('2018-01-08'::date), ('2018-02-23'::date), ('2018-03-08'::date), ('2018-03-09'::date), ('2018-05-01'::date), ('2018-05-02'::date), ('2018-05-09'::date), ('2018-06-11'::date), ('2018-06-12'::date), ('2018-11-05'::date), ('2018-12-31'::date), ('2019-01-01'::date), -- 2019 ('2019-01-02'::date), ('2019-01-03'::date), ('2019-01-04'::date), ('2019-01-07'::date), ('2019-01-08'::date), ('2019-03-08'::date), ('2019-05-01'::date), ('2019-05-02'::date), ('2019-05-03'::date), ('2019-05-09'::date), ('2019-05-10'::date), ('2019-06-12'::date), ('2019-11-04'::date) ), dates_include(start_time, stop_time) as ( values --  2018,  2019  ('2018-04-28 10:00:00'::timestamp, '2018-04-28 19:00:00'::timestamp), ('2018-06-09 10:00:00'::timestamp, '2018-06-09 19:00:00'::timestamp), ('2018-12-29 10:00:00'::timestamp, '2018-12-29 19:00:00'::timestamp) ) ), schedule_base(start_time, stop_time) as ( select d::timestamp + '10:00:00', d::timestamp + '19:00:00' from generate_series( (select min(start_time) from periods)::date::timestamp , (select max(stop_time) from periods)::date::timestamp , '1 day'::interval ) as days(d) where extract(dow from d) not in (0,6) ), schedule as ( select * from schedule_base where start_time::date not in (select d from dates_exclude) union select * from dates_include ), periods_wrk as ( select p.* , tsrange(p.start_time, p.stop_time) * tsrange(s.start_time, s.stop_time) as wrkh from periods p , schedule s ) select id, start_time, stop_time , sum(coalesce(upper(wrkh)-lower(wrkh), '0 sec'::interval)) from periods_wrk group by id, start_time, stop_time</span></span></code> </pre> <br><p>  Hourra! .. Cela pourrait être terminé, mais pour être complet, nous examinerons quelques sujets plus connexes. </p><br><h3 id="dalneyshee-razvitie-temy">  Poursuite du développement du sujet </h3><br><p>  Jours de pré-vacances raccourcis, pauses déjeuner, horaires différents pour différents jours de la semaine ... En principe, tout est clair, vous devez fixer la définition de l' <em>horaire</em> , donnez juste quelques exemples. </p><br><p>  Voici comment définir des heures de début et de fin différentes pour une journée de travail, selon le jour de la semaine: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d) <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-comment"><span class="hljs-comment">--  when 2 then '11:00:00'::time --  when 3 then '11:00:00'::time --  --        else '10:00:00'::time end , d + case extract(dow from d) --   19   when 5 then '14:00:00'::time --  else '19:00:00'::time end from schedule_base</span></span></code> </pre> <br><p>  Si vous devez prendre en compte les pauses déjeuner de 13h00 à 14h00, alors au lieu d'un intervalle par jour, faites deux: </p><br><pre> <code class="pgsql hljs"> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'13:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d + <span class="hljs-string"><span class="hljs-string">'14:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> , d + <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base</code> </pre> <br><p>  Eh bien et ainsi de suite. </p><br><h3 id="proizvoditelnost">  Performances </h3><br><p>  Je vais dire quelques mots sur les performances, car il y a toujours des questions à ce sujet.  Je ne vais pas déjà mâcher beaucoup, c'est une section avec un astérisque. </p><br><p>  En général, l'optimisation prématurée est mauvaise.  D'après mes nombreuses années d'observation, la lisibilité du code est son avantage le plus important.  Si le code est bien lu, il est plus facile à maintenir et à développer.  Un code bien lisible nécessite implicitement à la fois une bonne architecture de solution, des commentaires appropriés et de bons noms de variables, une compacité sans sacrifier la lisibilité, etc., c'est-à-dire tout ce pour quoi le code est appelé bon. </p><br><p>  Par conséquent, la demande est toujours écrite aussi lisible que possible, et nous commençons à l'optimiser si et seulement s'il s'avère que les performances sont insuffisantes.  De plus, nous l'optimiserons précisément là où les performances sont insuffisantes et exactement dans la mesure où elles deviennent suffisantes.  Si vous appréciez certainement votre temps et que vous avez quelque chose à faire. </p><br><p>  Mais ne pas faire de travail inutile dans la demande est juste; vous devez toujours essayer de prendre cela en compte. </p><br><p>  Sur cette base, nous inclurons immédiatement une optimisation dans la requête - laissez chaque période source ne croiser qu'avec les intervalles de temps de travail avec lesquels elle a des points communs (au lieu d'une longue condition classique sur les limites de la plage, il est plus pratique d'utiliser l'opérateur <em>&amp;&amp;</em> <em>intégré</em> pour le type <em>tsrange</em> ).  Cette optimisation est déjà apparue dans la demande, mais a conduit au fait que les périodes initiales totalement tombées en dehors des heures de travail ont disparu des résultats. </p><br><p>  Ramenez cette optimisation.  Pour ce faire, utilisez <em>LEFT JOIN</em> , qui enregistrera tous les enregistrements de la table des <em>périodes</em> .  Maintenant, la sous-requête <em>period_wrk</em> ressemblera à ceci: </p><br><pre> <code class="pgsql hljs">, periods_wrk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) * <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrkh <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p <span class="hljs-keyword"><span class="hljs-keyword">left join</span></span> schedule s <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(p.start_time, p.stop_time) &amp;&amp; <span class="hljs-type"><span class="hljs-type">tsrange</span></span>(s.start_time, s.stop_time))</code> </pre> <br><p>  L'analyse de la demande montre que le temps consacré aux données de test a diminué d'environ la moitié.  Étant donné que le temps d'exécution dépend de ce que le serveur faisait en même temps, j'ai pris quelques mesures et donné un résultat «typique», pas le plus grand, pas le plus petit, du milieu. </p><br><p>  Ancienne requête: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=334.42..338.39 rows=397 width=36) (actual time=10.724..10.731 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Nouveau: </p><br><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyse</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> periods(id, start_time, stop_time) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( ... QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------ HashAggregate (cost=186.37..186.57 rows=20 width=36) (actual time=5.431..5.440 rows=4 loops=1) ...</span></span></code> </pre> <br><p>  Mais le plus important est qu'une telle demande évoluera également mieux, nécessitant moins de ressources serveur, car le produit cartésien complet se développe très rapidement. </p><br><p>  Et là-dessus, je m'arrêterais avec des optimisations.  Lorsque j'ai résolu ce problème par moi-même, j'avais suffisamment de performances même dans une forme beaucoup plus terrible de cette demande, mais il n'y avait vraiment pas besoin d'optimiser.  Pour obtenir un rapport sur mes données une fois par trimestre, je peux attendre dix secondes supplémentaires.  L'heure supplémentaire consacrée à l'optimisation dans de telles conditions ne sera jamais payante. </p><br><p>  Mais cela s'avère sans intérêt; réfléchissons encore à la façon dont les événements pourraient se développer si l'optimisation en termes de temps d'exécution était vraiment nécessaire.  Par exemple, nous voulons surveiller ce paramètre en temps réel pour chacun de nos enregistrements dans la base de données, c'est-à-dire que pour chaque éternuement, une telle demande sera appelée.  Eh bien, ou venez avec votre propre raison, pourquoi auriez-vous besoin d'optimiser. </p><br><p>  La première chose qui me vient à l'esprit est de compter une fois et de mettre dans la base de données une table avec des intervalles de travail.  Il peut y avoir des contre-indications: si la base de données ne peut pas être modifiée, ou si des difficultés sont attendues avec la prise en charge des données pertinentes dans un tel tableau.  Ensuite, vous devrez laisser la génération de temps de travail «à la volée» dans la demande elle-même, car il ne s'agit pas d'une sous-requête très lourde. </p><br><p>  L'approche suivante et la plus puissante (mais pas toujours applicable) est l'optimisation algorithmique.  Certaines de ces approches ont déjà été présentées dans les commentaires de l'article avec l'état du problème. </p><br><p>  J'aime celui-ci surtout.  Si vous créez un tableau avec tous les jours (non seulement de travail) du calendrier et calculez le total cumulé du nombre d'heures de travail chaque jour d'une certaine «création du monde», vous pouvez obtenir le nombre d'heures de travail entre deux dates avec une opération de soustraction.  Il ne reste plus qu'à prendre correctement en compte les heures de travail du premier et du dernier jour - et vous avez terminé.  Voici ce que j'ai obtenu dans cette approche: </p><br><pre> <code class="pgsql hljs"> schedule_base(d, is_working) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-string"><span class="hljs-string">'2018-01-01'</span></span>::<span class="hljs-type"><span class="hljs-type">date</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> extract(<span class="hljs-type"><span class="hljs-type">dow</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">all</span></span>(<span class="hljs-string"><span class="hljs-string">'{2019-01-01,2019-01-02,2019-01-03,2019-01-04,2019-01-07,2019-01-08,2019-03-08,2019-05-01,2019-05-02,2019-05-03,2019-05-09,2019-05-10,2019-06-12,2019-11-04,2018-01-01,2018-01-02,2018-01-03,2018-01-04,2018-01-05,2018-01-08,2018-02-23,2018-03-08,2018-03-09,2018-04-30,2018-05-01,2018-05-02,2018-05-09,2018-06-11,2018-06-12,2018-11-05,2018-12-31}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> d+<span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>(<span class="hljs-string"><span class="hljs-string">'{2018-04-28,2018-06-09,2018-12-29}'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> d &lt; <span class="hljs-string"><span class="hljs-string">'2020-01-01'</span></span> ), schedule(d, is_working, work_hours) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> d, is_working , sum(is_working*<span class="hljs-string"><span class="hljs-string">'9 hours'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> schedule_base ) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.* , s2.work_hours - s1.work_hours + (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.start_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s1.is_working - (<span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span> - least(greatest(p.stop_time::<span class="hljs-type"><span class="hljs-type">time</span></span>, <span class="hljs-string"><span class="hljs-string">'10:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>), <span class="hljs-string"><span class="hljs-string">'19:00:00'</span></span>::<span class="hljs-type"><span class="hljs-type">time</span></span>)) * s2.is_working <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wrk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> periods p, schedule s1, schedule s2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s1.d = p.start_time::<span class="hljs-type"><span class="hljs-type">date</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s2.d = p.stop_time::<span class="hljs-type"><span class="hljs-type">date</span></span></code> </pre> <br><p>  Je vais expliquer brièvement ce qui se passe ici.  Dans la sous-requête <em>schedule_base</em> , nous générons tous les jours du calendrier pendant deux ans et nous déterminons chaque jour le signe si le jour ouvrable (= 1) ou non (= 0).  De plus, dans la sous-requête de <em>planification</em> , nous considérons la fonction de fenêtre comme le nombre total cumulé d'heures de travail à partir du 2018-01-01.  Il serait possible de tout faire dans une seule sous-requête, mais cela s'avérerait plus lourd, ce qui nuirait à la lisibilité.  Ensuite, dans la demande principale, nous considérons la différence entre le nombre d'heures de travail à la fin et au début de la période et, quelque peu fleuri, prenons en compte les heures de travail du premier et du dernier jour de la période.  La floridité est associée au décalage de l'heure avant le début de la journée de travail vers son début et de l'heure après la fin de la journée de travail à sa fin.  De plus, si la partie de la demande avec <em>shedule_base</em> et <em>planning est</em> supprimée dans une table pré-calculée distincte (comme suggéré précédemment), cette demande deviendra complètement triviale. </p><br><p>  Comparons l'exécution sur un échantillon plus grand afin de mieux montrer l'optimisation effectuée, pour quatre périodes à partir de la condition de tâche, plus de temps est consacré à la génération d'un horaire de travail. </p><br><p>  J'ai pris environ 3 000 règles.  Je ne donnerai que la ligne de résumé supérieure dans EXPLAIN, les valeurs typiques sont les suivantes. </p><br><p>  Option d'origine: </p><br><pre> <code class="pgsql hljs">GroupAggregate (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">265790.95</span></span>.<span class="hljs-number"><span class="hljs-number">.296098</span></span><span class="hljs-number"><span class="hljs-number">.23</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">144320</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">656.654</span></span>.<span class="hljs-number"><span class="hljs-number">.894</span></span><span class="hljs-number"><span class="hljs-number">.383</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Optimisé: </p><br><pre> <code class="pgsql hljs">Hash <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">45.01</span></span>.<span class="hljs-number"><span class="hljs-number">.127</span></span><span class="hljs-number"><span class="hljs-number">.52</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">70</span></span> width=<span class="hljs-number"><span class="hljs-number">36</span></span>) (actual <span class="hljs-type"><span class="hljs-type">time</span></span>=<span class="hljs-number"><span class="hljs-number">1.620</span></span>.<span class="hljs-number"><span class="hljs-number">.5</span></span><span class="hljs-number"><span class="hljs-number">.385</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">2898</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p>  Le gain de temps était de quelques ordres de grandeur.  Avec l'augmentation du nombre de périodes et leur durée en années, l'écart ne fera que s'élargir. </p><br><p>  Tout semblait aller bien, mais pourquoi, après avoir fait une telle optimisation, j'ai laissé la première version de la demande pour moi jusqu'à ce que ses performances soient suffisantes?  Oui, car la version optimisée est sans aucun doute plus rapide, mais elle nécessite beaucoup plus de temps pour comprendre comment elle fonctionne, c'est-à-dire que la lisibilité s'est détériorée.  Autrement dit, la prochaine fois que je devrai réécrire la demande dans mes conditions modifiées, je devrai (ou pas moi) passer beaucoup plus de temps à comprendre comment fonctionne la demande. </p><br><p>  C'est tout pour aujourd'hui, gardez les tentacules au chaud, et je vous dis au revoir jusqu'à la prochaine version de Radio SQL. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr459236/">https://habr.com/ru/post/fr459236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr459224/index.html">D'un agent immobilier à un développeur de jeux 2. «Opération: Android»</a></li>
<li><a href="../fr459226/index.html">«Fast-PoE et Perpetual-PoE - sont-ce ou non de nouvelles normes?»</a></li>
<li><a href="../fr459230/index.html">Un voyage au centre d'appels et au Product Backlog à travers les yeux du développeur</a></li>
<li><a href="../fr459232/index.html">Entourer, mordre, couper: la nouvelle compétition Mini AI Cup # 4</a></li>
<li><a href="../fr459234/index.html">Smem - Rapports sur l'allocation de mémoire entre les processus et les utilisateurs sous Linux</a></li>
<li><a href="../fr459238/index.html">D'une fonction mathématique magique - une solution pour les gouverner tous</a></li>
<li><a href="../fr459240/index.html">10 ans en TI diagnostiqués avec schizophrénie, conseils de survie</a></li>
<li><a href="../fr459242/index.html">Suite à la conférence T + Conf 2019</a></li>
<li><a href="../fr459244/index.html">Gestionnaire de produits Notes: comportement des utilisateurs sur les pages de jeu de l'App Store. Combien de temps faut-il pour télécharger un jeu</a></li>
<li><a href="../fr459246/index.html">Pourquoi la conversion de sites diminue-t-elle? Exemples de 60 erreurs de conception et d'utilisation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>