<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔫 🤴🏻 🖍️ Cara saya mempartisi di PostgreSQL 💂🏼 👩🏻‍🤝‍👨🏾 🥡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat kami berhenti mengontrol ukuran tabel, mempertahankan dan menyediakan data menjadi tugas yang tidak sepele. Saya sudah mengalami masalah seperti ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara saya mempartisi di PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/barsgroup/blog/481694/"><img src="https://habrastorage.org/webt/eq/ez/mc/eqezmc8xs8hlpvqjkqf4lapysig.jpeg"><br><br>  Saat kami berhenti mengontrol ukuran tabel, mempertahankan dan menyediakan data menjadi tugas yang tidak sepele.  Saya sudah mengalami masalah seperti itu dalam produksi, ada lebih banyak data setiap hari, tabel tidak sesuai dengan memori, server merespons untuk waktu yang lama, tetapi sebuah solusi ditemukan. <br><br>  Halo, Habr!  Nama saya Diamond dan sekarang saya ingin berbagi metode yang membantu saya mengimplementasikan partisi. <br><a name="habracut"></a><br><h3>  Partisi dalam PostgreSql </h3><br>  <b><a href="https://postgrespro.ru/docs/postgresql/11/ddl-partitioning">Partisi</a></b> (atau, demikian mereka menyebutnya, mempartisi) adalah proses pemisahan satu tabel logis besar menjadi beberapa bagian fisik yang lebih kecil.  Inilah yang membantu kami mengelola data kami. <br><br>  Contoh: kami memiliki tabel "penjualan", yang dipartisi dengan selang waktu satu bulan, dan bagian ini dapat dibagi menjadi sub-bagian yang lebih kecil berdasarkan wilayah. <br><br><img src="https://habrastorage.org/webt/-e/ea/u0/-eeau0dg8afydkft1jq2tmc2lly.jpeg"><br>  <i>Skema “penjualan” tabel yang dipartisi</i> <br><br>  Kekurangan dari pendekatan ini: <br><br>  - Struktur database yang rumit.  Setiap bagian dalam definisi basis data adalah sebuah tabel, walaupun itu adalah bagian dari satu entitas logis. <br>  - Anda tidak dapat mengonversi tabel yang ada ke yang dipartisi dan sebaliknya. <br>  - Tidak ada dukungan penuh di Postgres versi 11. <br><br>  Pro: <br><br>  + Performa.  Dalam kasus tertentu, kita dapat bekerja dengan kumpulan bagian terbatas tanpa melalui seluruh tabel, bahkan pencarian indeks untuk tabel besar akan lebih lambat.  Meningkatkan ketersediaan data. <br>  + Unggah massal dan hapus data dengan perintah ATTACH / DETACH.  Ini menyelamatkan kita dari overhead dalam bentuk VACUUM.  yang memungkinkan Anda untuk lebih efektif memelihara basis data. <br>  + Kemampuan untuk menentukan TABLESPACE untuk bagian tersebut.  Ini memberi kita peluang untuk mentransfer data ke bagian lain, tetapi kami masih bekerja dalam instance yang sama dan metadata dari direktori utama akan berisi informasi tentang bagian-bagian. (Jangan bingung dengan sharding) <br><br><h3>  2 cara untuk mengimplementasikan partisi di PostgreSql: </h3><br><br>  <b>1. Warisan tabel (Warisan)</b> <br>  Saat membuat tabel, kita mengatakan "mewarisi dari tabel (induk) lain".  Pada saat yang sama, kami menambahkan batasan untuk manajemen data dalam tabel.  Dengan ini kami mendukung logika pemisahan data, tetapi ini adalah tabel yang berbeda secara logis. <br><br>  Di sini perlu dicatat ekstensi yang dikembangkan oleh Postgres Professional pg_pathman, yang mengimplementasikan partisi, juga melalui pewarisan tabel. <br><br><pre><code class="plaintext hljs">CREATE TABLE orders_y2010 ( CHECK (log_date &gt;= DATE '2010-01-01) ) INHERITS (orders);</code> </pre> <br>  <b>2. Pendekatan deklaratif (PARTISI)</b> <br><br>  Tabel didefinisikan sebagai dipartisi secara deklaratif.  Solusi ini muncul dalam versi 10 dari PostgreSql. <br><br><pre> <code class="plaintext hljs">CREATE TABLE orders (log_date date not null, …) PARTITION BY RANGE(log_date);</code> </pre> <br><br>  Saya telah memilih pendekatan deklaratif.  Ini memberikan keuntungan besar - kekerabatan, lebih banyak fitur yang didukung oleh kernel.  Pertimbangkan pengembangan PostgreSQL ke arah ini: <br><br><img src="https://habrastorage.org/webt/sw/gj/j4/swgjj4u2yjuzhbuoebbdcqi7uj4.jpeg"><br>  <i><a href="https://www.2ndquadrant.com/en/blog/partitioning-evolution-postgresql-11/">Sumber</a></i> <br><br>  Tetapi PostgreSql terus berkembang, dan versi 12 memiliki dukungan untuk menautkan ke tabel yang dipartisi.  Ini adalah terobosan besar. <br><br><h3>  Cara saya </h3><br>  Diberikan di atas, <a href="">skrip</a> ditulis dalam PL / pgSQL, yang membuat tabel dipartisi berdasarkan yang sudah ada dan "melempar" semua tautan ke tabel baru.  Jadi, kita mendapatkan tabel dipartisi berdasarkan yang sudah ada dan terus bekerja dengannya seperti dengan tabel biasa. <br>  Script tidak memerlukan dependensi tambahan dan berjalan dalam sirkuit terpisah yang dibuatnya sendiri.  Juga log ulang dan kembalikan tindakan.  Script ini memecahkan dua tugas utama: membuat tabel dipartisi dan mengimplementasikan tautan eksternal ke sana melalui pemicu. <br><br>  Persyaratan skrip: PostgreSql v.:11 dan lebih tinggi. <br><br>  <b>Sekarang mari kita telusuri skripnya dengan lebih detail.</b>  Antarmukanya sangat sederhana: <br>  Ada dua prosedur yang melakukan semua pekerjaan. <br><br>  1. Tantangan utama - pada tahap ini kami tidak mengubah tabel utama, tetapi semua yang diperlukan untuk bagian akan dibuat dalam skema terpisah: <br><br><pre> <code class="plaintext hljs"> call partition_run();</code> </pre> <br><br>  2. Panggil tugas yang ditangguhkan yang direncanakan selama pekerjaan utama: <br><br><pre> <code class="plaintext hljs"> call partition_run_jobs();</code> </pre> <br><br>  Pekerjaan dapat diluncurkan di beberapa utas.  Jumlah utas optimal mendekati jumlah tabel yang dipartisi. <br><br>  <b>Parameter input untuk skrip</b> (catatan _pt) <br><br><img src="https://habrastorage.org/webt/8k/pk/pa/8kpkpahwbko3gxpvym9tqnacaxi.jpeg"><br><br>  Script dari dalam, tindakan utama: <br><br>  - Buat tabel yang dipartisi <br><pre> <code class="plaintext hljs"> perform _partition_create_parent_table(_pt);</code> </pre> <br>  - Buat bagian <br><pre> <code class="plaintext hljs"> perform _partition_create_child_tables(_pt);</code> </pre> <br>  - Salin data di bagian <br><pre> <code class="plaintext hljs"> perform _partition_copy_data(_pt);</code> </pre> <br>  - Tambahkan batasan (pekerjaan) <br><pre> <code class="plaintext hljs"> perform _partition_add_constraints(_pt);</code> </pre> <br>  - Kembalikan tautan ke tabel eksternal <br><pre> <code class="plaintext hljs"> perform _partition_restore_referrences(_pt);</code> </pre> <br>  - Kembalikan pemicu <br><pre> <code class="plaintext hljs"> perform _partition_restore_triggers(_pt);</code> </pre> <br>  - Buat pemicu acara <br><pre> <code class="plaintext hljs"> perform _partition_def_tr_on_delete(_pt);</code> </pre> <br>  - Buat indeks (pekerjaan) <br><pre> <code class="plaintext hljs"> perform _partition_create_index(_pt);</code> </pre> <br>  - Ganti tampilan, tautan bagian (pekerjaan) <br><pre> <code class="plaintext hljs"> perform _partition_replace_view(_pt);</code> </pre> <br><br>  Waktu berjalan skrip tergantung pada banyak faktor, tetapi yang utama adalah ukuran tabel target, jumlah hubungan, indeks dan karakteristik server.  Dalam kasus saya, tabel 300Gb dipartisi dalam waktu kurang dari satu jam. <br><br><br><h3>  Hasil </h3><br>  Apa yang kita dapatkan?  Mari kita lihat rencana permintaan: <br><br><pre> <code class="plaintext hljs"> EXPLAIN ANALYZE select * from “sales” where dt BETWEEN '01.01.2019'::date and '14.01.2019'::date</code> </pre> <br><br><img src="https://habrastorage.org/webt/gp/__/ga/gp__gatnm2fks5bte3osf7__jow.jpeg"><br><br>  Kami mendapat hasil dari tabel dipartisi lebih cepat dan menggunakan lebih sedikit sumber daya server kami dibandingkan dengan kueri ke tabel biasa. <br><br>  Dalam contoh ini, tabel reguler dan dipartisi berada di pangkalan yang sama dan memiliki sekitar 200 juta catatan.  Ini adalah hasil yang baik, mengingat bahwa kami, tanpa menulis ulang kode aplikasi, mendapat akselerasi.  Kueri pada indeks lain juga berfungsi dengan baik, tetapi ingat: setiap kali kita dapat menentukan bagian, hasilnya akan beberapa kali lebih cepat, karena  PostgreSql dapat membuang bagian tambahan pada tahap perencanaan permintaan ( <i>atur enable_partition_pruning ke on</i> ). <br><br><h3>  Ringkasan </h3><br>  Saya berhasil menerapkan partisi pada tabel yang memiliki banyak hubungan dan memastikan integritas basis data.  Script tidak tergantung pada struktur data tertentu dan dapat digunakan kembali. <br><br>  <i>PostgreSQL adalah basis data relasional open source paling canggih di dunia!</i> <br><br>  Terima kasih semuanya! <br><br>  <a href="">Tautan ke sumber</a> <br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id481694/">https://habr.com/ru/post/id481694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id481676/index.html">Minggu Keamanan 52: Keamanan untuk Speaker Cerdas dan Kamera IP</a></li>
<li><a href="../id481680/index.html">Menulis TodoMVC di dap. Bagian 2</a></li>
<li><a href="../id481684/index.html">Laptop dari Powerbank?</a></li>
<li><a href="../id481688/index.html">Mengapa mempelajari Java dan bagaimana melakukannya dengan efisien. Laporan Yandex</a></li>
<li><a href="../id481692/index.html">Menggunakan Pelacakan Prosesor Intel untuk Melacak Kode Mode Manajemen Sistem</a></li>
<li><a href="../id481696/index.html">ruleeguard: pemeriksaan dinamis untuk Go</a></li>
<li><a href="../id481698/index.html">Streaming WebRTC di dan sekitar realitas virtual</a></li>
<li><a href="../id481700/index.html">Tentang seorang bibi</a></li>
<li><a href="../id481702/index.html">Dari pemanggang ke drone. Bagaimana Internet bisa terjadi dan mengapa Internet hanya menyala 30 tahun kemudian</a></li>
<li><a href="../id481704/index.html">Ini adalah norma - 2: bagaimana peta normal dipanggang</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>