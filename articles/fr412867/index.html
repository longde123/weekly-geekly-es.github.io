<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍✈️ 👏🏼 👨🏼‍🔬 Comment compiler un fichier DOS COM par le compilateur GCC 🚕 👉🏽 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Article publié le 9 décembre 2014 
 Mise à jour pour 2018: RenéRebe a réalisé une vidéo intéressante basée sur cet article ( partie 2 ) 

 Le week-end...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment compiler un fichier DOS COM par le compilateur GCC</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412867/"> <font color="gray">Article publié le 9 décembre 2014</font> <br>  <i>Mise à jour pour 2018: RenéRebe a réalisé une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidéo intéressante</a> basée sur cet article ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie 2</a> )</i> <br><br>  Le week-end dernier, j'ai participé à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ludum Dare # 31</a> .  Mais avant même que la conférence ne soit annoncée, à cause de mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récent passe-temps,</a> je voulais faire un jeu à l'ancienne sous DOS.  La plate-forme cible est DOSBox.  C'est le moyen le plus pratique pour exécuter des applications DOS, malgré le fait que tous les processeurs x86 modernes sont entièrement rétrocompatibles avec les anciens, jusqu'au 8086 16 bits. <br><br>  J'ai créé et montré avec succès le jeu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DOS Defender</a> lors de la conférence.  Le programme fonctionne dans le mode réel du 8038 32 bits. Toutes les ressources sont intégrées dans le fichier COM exécutable, sans dépendances externes, donc le jeu entier est emballé dans un binaire de 10 kilo-octets. <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/skeeto/dosdefender-ld31</a> </li><li>  <a href="">DOSDEF.COM</a> (10 Ko, v1.1.0, fonctionne dans DOSBox) </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ay/na/qs/aynaqsaenvt32x5oa8y7z4fmnfy.gif"></div><a name="habracut"></a><br>  Vous aurez besoin d'un joystick ou d'une manette pour jouer.  J'ai inclus la prise en charge de la souris dans la version de Ludum Dare à des fins de présentation, mais je l'ai ensuite supprimée car cela ne fonctionnait pas très bien. <br><br>  La partie la plus intéressante techniquement est <b><i>qu'aucun</i> outil de développement DOS n'était nécessaire pour créer le jeu</b> !  J'ai utilisé uniquement le compilateur Linux C standard (gcc).  En réalité, vous ne pouvez même pas créer un défenseur DOS pour DOS.  Je vois DOS uniquement comme une plate-forme embarquée, qui est la seule forme sous laquelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DOS existe encore aujourd'hui</a> .  Avec DOSBox et DOSEMU, il s'agit d'un ensemble d'outils assez pratique. <br><br>  Si vous n'êtes intéressé que par la partie pratique du développement, allez dans la section «Cheat on GCC», où nous écrirons le programme DOS COM «Hello, World» avec GCC Linux. <br><br><h1>  Trouver les bons outils </h1><br>  Quand j'ai commencé ce projet, je ne pensais pas à GCC.  En réalité, je suis allé de cette façon lorsque j'ai découvert le paquet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">bcc</a> (Bruce's C Compiler) pour Debian, qui collecte des binaires 16 bits pour 8086. Il est utilisé pour la compilation de chargeurs de démarrage x86 et d'autres choses, mais bcc peut également être utilisé pour compiler des fichiers COM COM DOS.  Ça m'a intéressé. <br><br>  Pour référence: le microprocesseur Intel 8086 16 bits est sorti en 1978.  Il n'avait aucune caractéristique bizarre des processeurs modernes: pas de protection de la mémoire, pas d'instructions en virgule flottante et seulement 1 Mo de RAM adressable.  Tous les ordinateurs de bureau et portables x86 modernes peuvent toujours prétendre être ce processeur 16 bits 8086 il y a quarante ans, avec le même adressage limité et tout cela.  Il s'agit d'une compatibilité assez ancienne.  Une telle fonction est appelée <i>mode réel</i> .  Il s'agit du mode dans lequel tous les ordinateurs x86 démarrent.  Les systèmes d'exploitation modernes passent immédiatement en <i>mode protégé</i> avec un adressage virtuel et un multitâche sécurisé.  DOS ne l'a pas fait. <br><br>  Malheureusement, bcc n'est pas un compilateur ANSI C. Il prend en charge un sous-ensemble de K&amp;R C, ainsi que le code assembleur x86 intégré.  Contrairement aux autres compilateurs 8086 C, il n'a pas le concept de pointeurs «éloignés» ou «longs», donc un code assembleur intégré est nécessaire pour accéder à d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres segments de mémoire</a> (VGA, horloges, etc.).  Remarque: les restes de ces "longs pointeurs" 8086 sont toujours conservés dans l'API Win32: <code>LPSTR</code> , <code>LPWORD</code> , <code>LPDWORD</code> , etc. Cet assembleur intégré ne se compare même pas étroitement avec l'assembleur intégré GCC.  Dans l'assembleur, vous devez charger manuellement les variables à partir de la pile, et puisque bcc prend en charge deux conventions d'appel différentes, les variables dans le code doivent être codées en dur conformément à l'une ou l'autre convention. <br><br>  Compte tenu de ces limites, j'ai décidé de chercher des alternatives. <br><br><h1>  DJGPP </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DJGPP</a> - Port GCC sous DOS.  Un projet vraiment très impressionnant qui transfère presque tout le POSIX sous DOS.  De nombreux programmes sous DOS sont créés sur DJGPP.  Mais il ne crée que des programmes 32 bits pour le mode protégé.  Si en mode protégé vous devez travailler avec du matériel (par exemple, VGA), le programme fait des requêtes au service de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'interface DOS en mode protégé</a> (DPMI).  Si je prenais DJGPP, je n'aurais pas pu me limiter à un seul binaire autonome, car je devrais avoir un serveur DPMI.  Les performances souffrent également des demandes de DPMI. <br><br>  Obtenir les outils nécessaires pour DJGPP est pour le moins difficile.  Heureusement, j'ai trouvé un projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">build-djgpp</a> utile qui exécute tout, au moins sous Linux. <br><br>  Soit il y a eu une grave erreur, soit les binaires officiels de DJGPP ont été à nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">infectés par le virus</a> , mais lorsque j'ai démarré mes programmes dans DOSBox, l'erreur «Not COFF: check for virus» est constamment apparue.  Pour vérifier davantage que les virus ne sont pas sur ma propre machine, j'ai configuré l'environnement DJGPP sur mon Raspberry Pi, qui agit comme une salle blanche.  Ce périphérique ARM ne peut pas être infecté par le virus x86.  Et toujours le même problème se posait, et tous les hachages binaires étaient les mêmes entre les machines, donc ce n'est pas de ma faute. <br><br>  Donc, étant donné cela et le problème DPMI, j'ai commencé à chercher plus loin. <br><br><h1>  Fooling gcc </h1><br>  Ce sur quoi je me suis finalement fixé était l'astuce de "tricher" GCC pour construire des fichiers DOS COM en mode réel.  L'astuce fonctionne jusqu'à 80386 (ce qui est généralement ce dont vous avez besoin).  Le processeur 80386 a été lancé en 1985 et est devenu le premier microprocesseur x86 32 bits.  GCC adhère toujours à cet ensemble d'instructions, même dans les environnements x86-64.  Malheureusement, GCC ne peut en aucun cas produire du code 16 bits, j'ai donc dû abandonner l'objectif initial de créer un jeu pour 8086.  Cependant, cela n'a pas d'importance, car la plate-forme DOSBox cible est essentiellement un émulateur 80386. <br><br>  En théorie, l'astuce devrait également fonctionner dans le compilateur MinGW, mais il existe une erreur de longue date qui l'empêche de fonctionner correctement («ne peut pas effectuer d'opérations PE sur un fichier de sortie non PE»).  Cependant, vous pouvez le contourner, et je l'ai fait moi-même: vous devez supprimer la directive <code>OUTPUT_FORMAT</code> et ajouter une étape <code>objcopy</code> supplémentaire ( <code>objcopy -O binary</code> ). <br><br><h3>  Hello World sur DOS </h3><br>  Pour démonstration, nous allons créer le programme COM COM "Hello, World" en utilisant GCC sous Linux. <br><br>  Il y a un obstacle majeur et significatif à cette méthode: <b>il n'y aura pas de bibliothèque standard</b> .  C'est comme écrire un système d'exploitation à partir de zéro, à l'exception de quelques services fournis par DOS.  Cela signifie pas de <code>printf()</code> ou similaire.  Au lieu de cela, nous demandons à DOS d'imprimer la chaîne sur la console.  La création d'une requête DOS nécessite une interruption, ce qui signifie du code assembleur en ligne! <br><br>  Le DOS a neuf interruptions: 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x2F.  La chose la plus importante qui nous intéresse est 0x21, la fonction 0x09 (imprimer une ligne).  Entre DOS et BIOS, il existe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">milliers de fonctions nommées d'après ce modèle</a> .  Je ne vais pas essayer d'expliquer l'assembleur x86, mais en un mot, le numéro de la fonction est coincé dans le registre <code>ah</code> - et l'interruption 0x21 se déclenche.  La fonction 0x09 prend également un argument - un pointeur vers une ligne pour l'impression, qui est passée dans les registres <code>dx</code> et <code>ds</code> . <br><br>  Voici la fonction <code>print()</code> de l'assembleur en ligne GCC.  Les lignes passées à cette fonction doivent se terminer par le caractère $.  Pourquoi?  Parce que DOS. <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov $0x09, %%ah\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"int $0x21\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no output */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"d"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ah"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; }</code> </pre> <br>  Le code est déclaré <code>volatile</code> car il a un effet secondaire (impression de ligne).  Pour GCC, le code assembleur est opaque et l'optimiseur s'appuie sur les restrictions de sortie / entrée / clobber (trois dernières lignes).  Pour de tels programmes DOS, tout assembleur intégré aura des effets secondaires.  C'est parce qu'il est écrit non pas pour l'optimisation, mais pour l'accès aux ressources matérielles et au DOS - des choses inaccessibles au simple C. <br><br>  Vous devez également prendre soin de l'instruction appelante, car GCC ne sait pas que la mémoire pointée par la <code>string</code> a déjà été lue.  Il est probable qu'un tableau qui prend en charge la chaîne devra également être déclaré <code>volatile</code> .  Tout cela laisse présager l'inévitable: toute action dans un tel environnement se transforme en une lutte sans fin avec l'optimiseur.  Toutes ces batailles ne peuvent pas être gagnées. <br><br>  Passons maintenant à la fonction principale.  Son nom n'est pas important en principe, mais j'évite de l'appeler <code>main()</code> , car MinGW a des idées amusantes sur la façon de traiter ces caractères spécifiquement, même s'ils lui demandent de ne pas le faire. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosmain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { print(<span class="hljs-string"><span class="hljs-string">"Hello, World!\n$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  La taille des fichiers COM est limitée à 65279 octets.  En effet, le segment de mémoire x86 fait 64 Ko et DOS télécharge simplement les fichiers COM à l'adresse du segment 0x0100 et s'exécute.  Pas de titres, juste un binaire propre.  Étant donné que le programme COM, en principe, ne peut pas avoir une taille significative, alors aucune mise en page réelle (autonome) ne doit se produire, le tout est compilé comme une seule unité de traduction.  Ce sera un appel GCC avec un tas de paramètres. <br><br><h3>  Options du compilateur </h3><br>  Voici les principales options du compilateur. <br><br> <code>-std=gnu99 -Os -nostdlib -m32 -march=i386 -ffreestanding</code> <br> <br>  Comme les bibliothèques standard ne sont pas utilisées, la seule différence entre gnu99 et c99 est les trigraphes désactivés (comme il se doit), et l'assembleur intégré peut être écrit en <code>asm</code> au lieu de <code>__asm__</code> .  Ce n'est pas le bac de Newton.  Le projet sera si étroitement lié à GCC que je ne suis toujours pas préoccupé par les extensions de GCC. <br><br>  L'option <code>-Os</code> réduit autant que possible le résultat de la compilation.  Le programme fonctionnera donc plus rapidement.  Ceci est important en vue de DOSBox, car l'émulateur par défaut s'exécute lentement comme une machine des années 80.  Je veux m'intégrer dans cette limitation.  Si l'optimiseur cause des problèmes, <code>-O0</code> temporairement <code>-O0</code> pour déterminer si votre erreur ou l'optimiseur est là. <br><br>  Comme vous pouvez le voir, l'optimiseur ne comprend pas que le programme fonctionnera en mode réel avec les restrictions d'adressage correspondantes.  <b>Il effectue toutes sortes d'optimisations invalides qui cassent vos programmes parfaitement valides.</b>  Ce n'est pas un bug de GCC, car nous faisons nous-mêmes des choses folles ici.  J'ai dû refaire le code plusieurs fois pour empêcher l'optimiseur de casser le programme.  Par exemple, nous avons dû éviter de renvoyer des structures complexes à partir de fonctions car elles étaient parfois remplies de déchets.  Le vrai danger est que la future version de GCC deviendra encore plus intelligente et cassera encore plus de code.  Voici votre ami <code>volatile</code> . <br><br>  Le paramètre suivant est <code>-nostdlib</code> , car nous ne pourrons pas lier à des bibliothèques valides, même statiquement. <br><br>  Les paramètres <code>-m32-march=i386</code> compilateur d'émettre le code 80386. Si j'écrivais le chargeur de démarrage pour un ordinateur moderne, la vue sur 80686 serait également normale, mais la DOSBox est 80386. <br><br>  L'argument <code>-ffreestanding</code> requiert que GCC ne <code>-ffreestanding</code> pas de code qui accède aux fonctions d'assistance de la bibliothèque standard intégrée.  Parfois, au lieu de travailler réellement sur du code, il produit un code pour appeler une fonction en ligne, en particulier avec des opérateurs mathématiques.  J'ai eu l'un des principaux problèmes avec bcc, où ce comportement ne peut pas être désactivé.  Cette option est le plus souvent utilisée lors de l'écriture de chargeurs de démarrage et de noyaux de système d'exploitation.  Et maintenant les fichiers dos dos .com. <br><br><h3>  Options de l'éditeur de liens </h3><br>  L' <code>-Wl</code> utilisée pour passer des arguments à l'éditeur de liens ( <code>ld</code> ).  Nous en avons besoin parce que nous faisons tout en un seul appel au CCG. <br><br><pre> <code class="hljs powershell"><span class="hljs-literal"><span class="hljs-literal">-Wl</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-nmagic</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-script</span></span>=com.ld</code> </pre> <br>  <code>--nmagic</code> désactive l'alignement des pages de section.  Premièrement, nous n'en avons pas besoin.  Deuxièmement, il gaspille un espace précieux.  Dans mes tests, cela ne semble pas être une mesure nécessaire, mais juste au cas où, je laisse cette option. <br><br>  Le paramètre <code>--script</code> indique que nous voulons utiliser un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">script de l'éditeur de liens</a> spécial.  Cela vous permet de placer avec précision les sections ( <code>text</code> , <code>data</code> , <code>bss</code> , <code>rodata</code> ) de notre programme.  Voici le script <code>com.ld</code> <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">OUTPUT_FORMAT</span></span>(binary) <span class="hljs-type"><span class="hljs-type">SECTIONS</span></span> { . = <span class="hljs-number"><span class="hljs-number">0x0100</span></span>; .text : { *(.text); } .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> : { *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">); *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bss</span></span></span><span class="hljs-class">); *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rodata</span></span></span><span class="hljs-class">); } _heap = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ALIGN</span></span></span><span class="hljs-class">(4); }</span></span></code> </pre> <br>  <code>OUTPUT_FORMAT(binary)</code> vous dit de ne pas le mettre dans un fichier ELF (ou PE, etc.).  L'éditeur de liens doit simplement réinitialiser le code propre.  Un fichier COM est juste du code propre, c'est-à-dire que nous donnons la commande à l'éditeur de liens pour créer un fichier COM! <br><br>  J'ai dit que les fichiers COM sont téléchargés sur <code>0x0100</code> .  La quatrième ligne y déplace le binaire.  Le premier octet du fichier COM est toujours le premier octet du code, mais sera lancé à partir de ce décalage de mémoire. <br><br>  Ensuite, toutes les sections suivent: <code>text</code> (programme), <code>data</code> ( <code>data</code> statiques), <code>bss</code> (données avec initialisation zéro), <code>rodata</code> (chaînes).  Enfin, je marque la fin du binaire avec le symbole <code>_heap</code> .  Cela nous sera utile plus tard lors de l'écriture de <code>sbrk()</code> lorsque nous aurons terminé avec «Hello, World».  J'ai indiqué d'aligner <code>_heap</code> avec 4 octets. <br><br>  Presque terminé. <br><br><h3>  Lancement du programme </h3><br>  L'éditeur de liens connaît généralement notre point d'entrée ( <code>main</code> ) et le configure pour nous.  Mais puisque nous avons demandé un problème «binaire», nous devrons le découvrir nous-mêmes.  Si la fonction <code>print()</code> est la première à s'exécuter, le programme démarrera, ce qui est faux.  Le programme a besoin d'une petite rubrique pour commencer. <br><br>  Il y a une option <code>STARTUP</code> dans le script de l'éditeur de liens pour de telles choses, mais pour plus de simplicité, nous allons l'implémenter directement dans le programme.  Habituellement, de telles choses sont appelées <code>crt0.o</code> ou <code>Boot.o</code> , au cas où vous <code>Boot.o</code> dessus quelque part.  Notre code <i>doit</i> commencer par cet assembleur intégré, avant toutes les inclusions et autres.  DOS effectuera la majeure partie de l'installation pour nous, nous avons juste besoin d'aller au point d'entrée. <br><br><pre> <code class="hljs perl">asm (<span class="hljs-string"><span class="hljs-string">".code16gcc\n"</span></span> <span class="hljs-string"><span class="hljs-string">"call dosmain\n"</span></span> <span class="hljs-string"><span class="hljs-string">"mov $0x4C, %ah\n"</span></span> <span class="hljs-string"><span class="hljs-string">"int $0x21\n"</span></span>);</code> </pre> <br>  <code>.code16gcc</code> indique à l'assembleur que nous allons travailler en mode réel, afin qu'il fasse la configuration correcte.  Malgré son nom, il <i>ne</i> produira <i>pas de</i> code 16 bits!  Tout d'abord, la fonction <code>dosmain</code> , que nous avons écrite plus tôt, est appelée.  Il indique ensuite à DOS à l'aide de la fonction 0x4C («terminer avec le code retour») que nous avons terminé en passant le code de sortie au registre à 1 octet (déjà défini par <code>dosmain</code> ).  Cet assembleur intégré est automatiquement <code>volatile</code> car il n'a pas d'entrées et de sorties. <br><br><h3>  Tous ensemble </h3><br>  Voici l'ensemble du programme en C. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> (<span class="hljs-string"><span class="hljs-string">".code16gcc\n"</span></span> <span class="hljs-string"><span class="hljs-string">"call dosmain\n"</span></span> <span class="hljs-string"><span class="hljs-string">"mov $0x4C,%ah\n"</span></span> <span class="hljs-string"><span class="hljs-string">"int $0x21\n"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mov $0x09, %%ah\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"int $0x21\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* no output */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"d"</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">) : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ah"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dosmain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ print(<span class="hljs-string"><span class="hljs-string">"Hello, World!\n$"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Je ne répéterai pas <code>com.ld</code>  Voici le défi du CCG. <br><br><pre> <code class="hljs powershell">gcc <span class="hljs-literal"><span class="hljs-literal">-std</span></span>=gnu99 <span class="hljs-literal"><span class="hljs-literal">-Os</span></span> <span class="hljs-literal"><span class="hljs-literal">-nostdlib</span></span> <span class="hljs-literal"><span class="hljs-literal">-m32</span></span> <span class="hljs-literal"><span class="hljs-literal">-march</span></span>=i386 <span class="hljs-literal"><span class="hljs-literal">-ffreestanding</span></span> \ <span class="hljs-literal"><span class="hljs-literal">-o</span></span> hello.com <span class="hljs-literal"><span class="hljs-literal">-Wl</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-nmagic</span></span>,-<span class="hljs-literal"><span class="hljs-literal">-script</span></span>=com.ld hello.c</code> </pre> <br>  Et ses tests dans DOSBox: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c5/478/358/4c5478358be0cdd9cc05eafd66bd44d2.png"><br><br>  Ensuite, si vous voulez de beaux graphismes, la seule question est d'appeler l'interruption et d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">écrire dans la mémoire VGA</a> .  Si vous voulez du son, utilisez l'interruption du haut-parleur PC.  Je n'ai pas compris comment appeler Sound Blaster.  À partir de ce moment, DOS Defender a grandi. <br><br><h1>  Allocation de mémoire </h1><br>  Pour couvrir un autre sujet, rappelez-vous que <code>_heap</code> ?  Nous pouvons l'utiliser pour implémenter <code>sbrk()</code> et allouer dynamiquement de la mémoire dans la section principale du programme.  Il s'agit d'un mode réel et il n'y a pas de mémoire virtuelle, nous pouvons donc écrire sur n'importe quelle mémoire à laquelle nous pouvons accéder à tout moment.  Certaines zones sont réservées (par exemple, la mémoire inférieure et supérieure) pour l'équipement.  Il n'y a donc pas <i>vraiment</i> besoin d'utiliser sbrk (), mais il est intéressant d'essayer. <br><br>  Comme d'habitude sur x86, votre programme et vos partitions sont dans la mémoire inférieure (0x0100 dans ce cas), et la pile est dans la mémoire supérieure (dans notre cas, dans la région 0xffff).  Sur les systèmes de type Unix, la mémoire renvoyée par <code>malloc()</code> vient de deux endroits: <code>sbrk()</code> et <code>mmap()</code> .  Ce que fait <code>sbrk()</code> est d'allouer de la mémoire juste au-dessus des segments programme / données, en l'incrémentant «vers le haut» vers la pile.  Chaque appel à <code>sbrk()</code> augmentera cet espace (ou le laissera exactement le même).  Cette mémoire sera gérée par <code>malloc()</code> et similaires. <br><br>  Voici comment implémenter <code>sbrk()</code> dans un programme COM.  Veuillez noter que vous devez définir votre propre <code>size_t</code> , car nous n'avons pas de bibliothèque standard. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> _heap; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *hbreak = &amp;_heap; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sbrk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = hbreak; hbreak += size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }</code> </pre> <br>  Il définit simplement le pointeur sur <code>_heap</code> et l'incrémente selon les besoins.  Un peu plus intelligent <code>sbrk()</code> fera également attention à l'alignement. <br><br>  Une chose intéressante s'est produite lors de la création de DOS Defender.  J'ai (à tort) considéré que la mémoire de mon <code>sbrk()</code> réinitialisée.  C'était donc après le premier match.  Cependant, DOS ne réinitialise pas cette mémoire entre les programmes.  Quand j'ai recommencé le jeu, <i>il a continué exactement là où je m'étais arrêté</i> , car les mêmes structures de données avec le même contenu ont été chargées en place.  Coïncidence assez cool!  Cela fait partie de ce qui rend cette plate-forme intégrée amusante. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr412867/">https://habr.com/ru/post/fr412867/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr412855/index.html">Les vulnérabilités CSRF sont toujours d'actualité</a></li>
<li><a href="../fr412859/index.html">Authentification à deux facteurs dans Windows et chiffrement des données sans autorité de certification ni domaine</a></li>
<li><a href="../fr412861/index.html">Création d'une carte de parcours utilisateur pour les nuls</a></li>
<li><a href="../fr412863/index.html">Dialogflower - Google Dialogflow pour Yandex Alice</a></li>
<li><a href="../fr412865/index.html">Comment filmer une caméra Motion Eye sur le Sony Xperia XZ2</a></li>
<li><a href="../fr412869/index.html">Entretien avec un expert en ingénierie tissulaire et médecine régénérative, le professeur Tal Tal Dvir</a></li>
<li><a href="../fr412871/index.html">Eclair - Bibliothèque de journalisation déclarative Java Spring</a></li>
<li><a href="../fr412873/index.html">Disques durs gâtés par le son des haut-parleurs d'ordinateur portable ordinaire</a></li>
<li><a href="../fr412877/index.html">Ruthénium (Ru) - le quatrième élément aux propriétés ferromagnétiques à température ambiante</a></li>
<li><a href="../fr412879/index.html">Numéro 24: Formation informatique - problèmes et défis actuels des grandes entreprises</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>