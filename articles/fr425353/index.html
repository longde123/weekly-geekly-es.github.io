<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß‚Äçüë¶ ‚õÑÔ∏è ü§º Toute la v√©rit√© sur RTOS. Article # 13. Structures de donn√©es de t√¢che et appels d'API non pris en charge üòç üë®üèø‚Äçüîß ‚úãüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans ce troisi√®me et dernier article de t√¢che, je vais examiner les structures de donn√©es Nucleus SE et d√©crire les appels d'API RTOS qui ne sont pas ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la v√©rit√© sur RTOS. Article # 13. Structures de donn√©es de t√¢che et appels d'API non pris en charge</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425353/"><img src="https://habrastorage.org/webt/a2/hi/au/a2hiaum17nhh6_ibldqgahpgaxo.jpeg"><br><br>  Dans ce troisi√®me et dernier article de t√¢che, je vais examiner les structures de donn√©es Nucleus SE et d√©crire les appels d'API RTOS qui ne sont pas impl√©ment√©s dans Nucleus SE, ainsi que d'autres probl√®mes de compatibilit√©. <br><a name="habracut"></a><br>  Articles pr√©c√©dents de la s√©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Services pour travailler avec des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches: configuration et introduction √† l'API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: fonctionnalit√©s avanc√©es et pr√©servation du contexte</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Scheduler: impl√©mentation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: conception interne et d√©ploiement</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nucleus SE: Introduction</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Autres services RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Interaction et synchronisation des t√¢ches</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches, changement de contexte et interruptions</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">T√¢ches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps r√©el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br><h2>  Structures de donn√©es </h2><br>  Les t√¢ches utilisent diff√©rentes structures de donn√©es (√† la fois en RAM et en ROM), qui, comme d'autres objets Nucleus SE, sont un ensemble de tables dont la taille correspond au nombre de t√¢ches et de param√®tres s√©lectionn√©s. <br><br>  Je recommande fortement que le code d'application acc√®de √† ces structures de donn√©es √† l'aide de fonctions API, et non directement.  Cela √©vite les effets secondaires ind√©sirables, l'incompatibilit√© avec les futures versions de Nucleus SE et simplifie √©galement le portage de l'application vers Nucleus RTOS.  Pour une meilleure compr√©hension du code d'appel de service et du processus de d√©bogage, une description d√©taill√©e des structures de donn√©es est donn√©e ci-dessous. <br><br><h3>  Structures de donn√©es du noyau h√©berg√©es dans la RAM </h3><br>  Ces structures de donn√©es comprennent: <br><br>  <b>NUSE_Task_Context [] []</b> - un tableau bidimensionnel de type <b>ADDR</b> , a une ligne pour chaque t√¢che.  Le nombre de colonnes d√©pend de l'architecture du contr√¥leur et est d√©termin√© par le symbole <b>NUSE_REGISTERS</b> , qui est d√©fini dans <b>nuse_types.h</b> .  Ce tableau est utilis√© par le planificateur pour enregistrer le contexte de chaque t√¢che et a √©t√© d√©crit en d√©tail dans la section ¬´Enregistrement du contexte¬ª de l'article # 10.  Non cr√©√© si le planificateur RTC est utilis√©. <br>  <b>NUSE_Task_Signal_Flags []</b> - un tableau de type <b>U8</b> , cr√©√© si les signaux sont activ√©s, et contient 8 drapeaux de signal pour chaque t√¢che.  Les signaux seront discut√©s dans l'un des articles suivants. <br>  <b>NUSE_Task_Timeout_Counter []</b> est un tableau de type <b>U16</b> , consiste √† soustraire des compteurs pour chaque t√¢che et est cr√©√© si l'appel √† l'API <b>NUSE_Task_Sleep () est</b> activ√©. <br>  <b>NUSE_Task_Status []</b> - un tableau de type U8, contient les statuts de chaque t√¢che - <b>NUSE_READY</b> ou suspend les statuts.  Cr√©√© uniquement si la suspension de t√¢che est activ√©e. <br>  <b>NUSE_Task_Blocking_Return []</b> - un tableau de type U8, cr√©√© si le blocage d'appels API est activ√©.  Il contient un code retour qui sera utilis√© apr√®s le blocage des appels d'API.  Il contient g√©n√©ralement <b>NUSE_SUCCESS</b> ou un code indiquant que l'objet a √©t√© r√©initialis√© (par exemple, <b>NUSE_MAILBOX_WAS_RESET</b> ). <br>  <b>NUSE_Task_Schedule_Count []</b> - un tableau de type <b>U16</b> , contient un compteur pour chaque t√¢che et est cr√©√© uniquement si le d√©compte du planificateur a √©t√© activ√©. <br><br>  <b>NUSE_Task_Context [] [] est</b> initialis√© principalement par des z√©ros, √† l'exception des entr√©es correspondant au registre d'√©tat (registre d'√©tat, SR), au compteur de programme (compteur de programme, PC) et au pointeur de pile (pointeur de pile, SP), auxquels sont affect√©es des valeurs initiales (voir "Donn√©es dans la ROM "ci-dessous), et toutes les autres structures de donn√©es <b>NUSE_Init_Task ()</b> re√ßoivent des z√©ros lors du d√©marrage de Nucleus SE.  L'un des articles suivants contiendra une liste compl√®te des proc√©dures de d√©marrage de Nucleus SE avec leur description. <br><br>  Voici les d√©finitions des structures de donn√©es contenues dans le fichier nuse_init.c. <br><br><img src="https://habrastorage.org/webt/fj/hr/le/fjhrlehn7si_hkt5lnnyk6dosno.jpeg"><br><br><h3>  Donn√©es utilisateur RAM </h3><br>  L'utilisateur doit d√©finir une pile pour chaque t√¢che (si le planificateur RTC n'est pas utilis√©).  Il doit s'agir de tableaux <b>ADDR</b> , g√©n√©ralement d√©finis dans <b>nuse_config.c</b> .  Les adresses et les tailles de pile doivent √™tre plac√©es dans les entr√©es de t√¢che <b>NUSE_Task_Stack_Base []</b> et <b>NUSE_Task_Stack_Size [],</b> respectivement (voir. Donn√©es dans la ROM). <br><br><h3>  Donn√©es ROM </h3><br>  Une ROM stocke de une √† quatre structures de donn√©es li√©es aux t√¢ches.  Le montant exact d√©pend des param√®tres s√©lectionn√©s: <br><br>  <b>NUSE_Task_Start_Address []</b> est un tableau de type <b>ADDR</b> qui a une entr√©e pour chaque t√¢che, qui est un pointeur vers le point d'entr√©e de code pour la t√¢che. <br>  <b>NUSE_Task_Stack_Base []</b> est un tableau de type <b>ADDR</b> qui a une entr√©e pour chaque t√¢che, qui est un pointeur vers l'adresse de base de la pile pour la t√¢che.  Ce tableau est cr√©√© si un planificateur autre que RTC est utilis√©. <br>  <b>NUSE_Task_Stack_Size []</b> est un tableau de type <b>U16</b> qui a une entr√©e pour chaque t√¢che, qui montre la taille de la pile de la t√¢che (en mots).  Ce tableau est cr√©√© si un planificateur autre que RTC est utilis√©. <br>  <b>NUSE_Task_Initial_State []</b> est un tableau de type <b>U8</b> , ayant une entr√©e pour chaque t√¢che, qui montre l'√©tat initial de la t√¢che.  Il peut s'agir de <b>NUSE_READY</b> ou <b>NUSE_PURE_SUSPEND</b> .  Ce tableau est cr√©√© si la prise en charge de l'√©tat initial de la t√¢che est s√©lectionn√©e. <br><br>  Ces structures de donn√©es sont d√©clar√©es et initialis√©es (statiquement) dans <b>nuse_config.c</b> : <br><br><img src="https://habrastorage.org/webt/2g/pp/bu/2gppbu3zs8wc0gipo3kggntvxek.jpeg"><br><br><h3>  La quantit√© de m√©moire pour stocker les donn√©es de t√¢che (empreinte de donn√©es de t√¢che) </h3><br>  Comme tous les objets principaux de Nucleus SE, la quantit√© de m√©moire requise pour stocker les donn√©es est pr√©visible. <br><br>  Taille de la ROM (en octets) requise pour toutes les t√¢ches d'application: <br>  <b>NUSE_TASK_NUMBER * sizeof (ADDR)</b> <br><br>  De plus, si un planificateur autre que RTC est s√©lectionn√©: <br>  <b>NUSE_TASK_NUMBER * (taille de (ADDR) +2)</b> <br><br>  De plus, si la prise en charge de l'√©tat initial de la t√¢che est s√©lectionn√©e: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  Pour stocker des donn√©es dans la RAM, la quantit√© de m√©moire (en octets) est d√©termin√©e par les param√®tres s√©lectionn√©s, et elle peut avoir une valeur nulle si aucun des param√®tres n'est s√©lectionn√©. <br>  Si un planificateur autre que RTC est s√©lectionn√©: <br>  <b>NUSE_TASK_NUMBER * NUSE REGISTRES * sizeof (ADDR)</b> <br><br>  De plus, si la prise en charge du signal est s√©lectionn√©e: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  De plus, si l'appel √† l'API NUSE_Task_Sleep () est activ√©: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br>  De plus, si la suspension des t√¢ches est activ√©e: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  De plus, si le blocage des appels API est activ√©: <br>  <b>NUSE_TASK_NUMBER</b> <br><br>  De plus, si le compteur du planificateur est activ√©: <br>  <b>NUSE_TASK_NUMBER * 2</b> <br><br><h2>  Appels d'API non impl√©ment√©s dans Nucleus SE </h2><br>  Vous trouverez ci-dessous sept appels d'API disponibles dans Nucleus RTOS qui ne sont pas impl√©ment√©s dans Nucleus SE. <br><br><h3>  Cr√©er une t√¢che </h3><br>  Cet appel d'API cr√©e une t√¢che d'application.  Nucleus SE n'a pas besoin de cette fonctionnalit√© car les t√¢ches sont cr√©√©es statiquement. <br><br>  Prototype d'appel: <br><br>  <b>STATUS NU_Create_Task (t√¢che NU_TASK *, nom CHAR *, VOID (* entr√©e_t√¢che) (UNSIGNED, VOID *), UNSIGNED argc, VOID * argv, VOID * stack_address, UNSIGNED stack_size, priorit√© OPTION, UNSIGNED time_slice, priorit√© OPTION</b> <br><br>  Param√®tres: <br><br>  <b>t√¢che</b> - un pointeur vers un bloc de contr√¥le de t√¢che utilisateur, peut √™tre utilis√© comme descripteur / lien (¬´descripteur¬ª) d'une t√¢che dans d'autres appels d'API; <br>  <b>nom</b> - pointe vers le nom de la t√¢che, une cha√Æne de 7 caract√®res avec un z√©ro de fin; <br>  <b>task_entry</b> - indique la fonction d'entr√©e pour la t√¢che; <br>  <b>argc</b> - √©l√©ment de donn√©es <b>UNSIGNED</b> qui peut √™tre utilis√© pour transmettre les informations initiales √† la t√¢che; <br>  <b>argv</b> - un pointeur qui peut √™tre utilis√© pour transmettre des informations √† la t√¢che; <br>  <b>stack_address</b> - d√©finit le secteur initial de la m√©moire pour la pile de t√¢ches; <br>  <b>stack_size</b> - indique le nombre d'octets dans la pile; <br>  <b>priorit√©</b> - indique la valeur de priorit√© de la t√¢che: de 0 √† 255, o√π les nombres inf√©rieurs correspondent √† la priorit√© la plus √©lev√©e; <br>  <b>time_slice</b> - indique le nombre maximum de <b>tranches</b> de temps qui peuvent s'√©couler pendant cette t√¢che.  Une valeur de "0" d√©sactive le d√©coupage temporel pour cette t√¢che; <br>  <b>pr√©emption</b> - indique si la t√¢che est remplac√©e ou non.  Peut avoir des valeurs <b>NU_PREEMPT</b> et <b>NU_NO_PREEMPT</b> ; <br>  <b>auto_start</b> - affiche l'√©tat initial de la t√¢che.  <b>NU_START</b> signifie que la t√¢che est pr√™te √† √™tre ex√©cut√©e et <b>NU_NO_START signifie</b> que la t√¢che est suspendue. <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - indique la r√©ussite du service; <br>  <b>NU_INVALID_TASK</b> - indique que le pointeur vers l'unit√© de contr√¥le des t√¢ches est <b>NULL</b> ; <br>  <b>NU_INVALID_ENTRY</b> - indique que le pointeur vers la fonction d'entr√©e de la t√¢che est <b>NULL</b> ; <br>  <b>NU_INVALID_MEMORY</b> - indique que le secteur de m√©moire affect√© par le param√®tre stack_address est z√©ro ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - indique que la taille de pile sp√©cifi√©e est insuffisante; <br>  <b>NU_INVALID_PREEMPT</b> - indique que le param√®tre de <b>pr√©emption n'est pas</b> d√©fini correctement; <br>  <b>NU_INVALID_START</b> - indique que le param√®tre <b>auto_start n'est pas</b> d√©fini correctement. <br><br><h3>  Supprimer la t√¢che </h3><br>  Cet appel d'API supprime une t√¢che d'application cr√©√©e pr√©c√©demment qui doit √™tre <i>termin√©e</i> ou <i>arr√™t√©e</i> .  Cet appel n'est √©galement pas n√©cessaire pour Nucleus SE, car les t√¢ches sont cr√©√©es statiquement et ne peuvent pas √™tre supprim√©es. <br><br>  Prototype d'appel: <br><br>  <b>STATUS NU_Delete_Task (t√¢che NU_TASK *);</b> <br><br>  Param√®tres: <br><br>  <b>task</b> - pointeur vers le bloc de contr√¥le des t√¢ches <br><br>  Valeur de retour: <br><br>  <b>NU_SUCCESS</b> - indique la r√©ussite du service; <br>  <b>NU_INVALID_TASK</b> - indique que le pointeur vers la t√¢che n'est pas d√©fini correctement; <br>  <b>NU_INVALID_DELETE</b> - Indique que la t√¢che n'est pas √† l'√©tat Termin√© ou Termin√©. <br><br><h3>  Obtenez des pointeurs de t√¢che </h3><br>  Cet appel d'API constitue une liste s√©quentielle de pointeurs vers toutes les t√¢ches du syst√®me.  Il n'est pas n√©cessaire dans Nucleus SE, car les t√¢ches sont identifi√©es √† l'aide d'un simple index, et non d'un pointeur. <br><br>  Prototype d'appel: <br><br>  <b>UNSIGNED NU_Task_Pointers (NU_TASK ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Param√®tres: <br><br>  <b>pointer_list</b> - pointeur vers un tableau de pointeurs <b>NU_TASK</b> .  Ce tableau sera rempli de pointeurs vers les t√¢ches install√©es dans le syst√®me; <br>  <b>maximum_pointers</b> - le nombre maximum de pointeurs pouvant √™tre plac√©s dans le tableau. <br><br>  Valeur de retour: <br><br>  Nombre de pointeurs <b>NU_TASK</b> plac√©s dans le tableau. <br><br><h3>  Modifier la priorit√© des t√¢ches </h3><br>  Cet appel d'API donne √† la t√¢che une nouvelle priorit√©.  Dans Nucleus SE, ce n'est pas obligatoire, car les priorit√©s des t√¢ches sont constantes. <br><br>  Prototype d'appel: <br><br>  <b>OPTION NU_Change_Priority (t√¢che NU_TASK *, OPTION new_priority);</b> <br><br>  Param√®tres: <br><br>  <b>t√¢che</b> - un pointeur vers un bloc de contr√¥le de t√¢che; <br>  <b>new_priority</b> - d√©finit la priorit√© de 0 √† 255. <br><br>  Valeur de retour: <br>  La valeur de priorit√© de t√¢che pr√©c√©dente. <br><br><h3>  Changer l'algorithme de pr√©emption des t√¢ches </h3><br>  Cet appel API modifie l'ordre dans lequel la t√¢che en cours est √©vinc√©e.  Nucleus SE n'en a pas besoin car il utilise un algorithme de planification plus simple. <br><br>  Prototype d'appel: <br>  <b>OPTION NU_Change_Preemption (OPTION pr√©emption);</b> <br><br>  Param√®tres: <br>  <b>preempt</b> - nouvel algorithme <b>pr√©emptif</b> , accepte <b>NU_PREEMPT</b> ou <b>NU_NO_PREEMPT</b> <br><br>  Valeur de retour: <br>  L'algorithme pr√©c√©dent pour √©vincer une t√¢che. <br><br><h3>  Modifier la tranche de temps des t√¢ches </h3><br>  Cet appel d'API modifie la tranche de temps d'une t√¢che sp√©cifique.  Nucleus SE n'en a pas besoin, car les tranches de temps des t√¢ches sont fixes. <br><br>  Prototype d'appel: <br>  <b>UNSIGNED NU_Change_Time_Slice (t√¢che NU_TASK *, UNSIGNED time_slice);</b> <br><br>  Param√®tres: <br>  <b>t√¢che</b> - un pointeur vers un bloc de contr√¥le de t√¢che; <br>  <b>time_slice</b> - le nombre maximum de <b>tranches</b> de temps qui peuvent s'√©couler pendant cette t√¢che; une valeur nulle de ce champ d√©sactive la quantification du temps pour cette t√¢che. <br><br>  Valeur de retour: <br>  La valeur pr√©c√©dente du quantum de temps de t√¢che. <br><br><h3>  Terminer la t√¢che </h3><br>  Cet appel d'API termine une t√¢che sp√©cifique.  Nucleus SE n'en a pas besoin car l'√©tat <i>Termin√©</i> n'est pas pris en charge. <br><br>  Prototype d'appel: <br>  <b>STATUS NU_Terminate_Task (t√¢che NU_TASK *);</b> <br><br>  Param√®tres: <br>  <b>t√¢che</b> - un pointeur vers un bloc de contr√¥le de t√¢che. <br><br>  Valeur de retour: <br>  <b>NU_SUCCESS</b> - indique la r√©ussite du service; <br>  <b>NU_INVALID_TASK</b> - Indique que le pointeur de t√¢che est incorrect. <br><br><h2>  Compatible avec Nucleus RTOS </h2><br>  Lors du d√©veloppement de Nucleus SE, l'une des principales t√¢ches consistait √† garantir un haut niveau de compatibilit√© du code avec Nucleus RTOS.  Les t√¢ches ne font pas exception et, du point de vue de l'utilisateur, elles sont impl√©ment√©es de la m√™me mani√®re que dans Nucleus RTOS.  Il y a des domaines incompatibles o√π je suis arriv√© √† la conclusion qu'une telle incompatibilit√© serait acceptable, √©tant donn√© que le code final est plus facile √† comprendre et peut utiliser la m√©moire plus efficacement.  Cependant, en plus de ces incompatibilit√©s, le reste des appels de l'API Nucleus RTOS peut √™tre utilis√© presque directement comme appels Nucleus SE.  L'un des articles suivants fournira plus de d√©tails sur la transition de Nucleus RTOS √† Nucleus SE <br><br><h3>  Identificateurs d'objet </h3><br>  Dans Nucleus RTOS, tous les objets sont d√©crits par une structure de donn√©es (unit√©s de contr√¥le) d'un type sp√©cifique.  Un pointeur vers cette unit√© de contr√¥le sert d'identifiant pour la t√¢che.  Chez Nucleus SE, j'ai d√©cid√© qu'une approche diff√©rente √©tait n√©cessaire pour une utilisation efficace de la m√©moire.  Tous les objets du noyau sont d√©crits par un ensemble de tables en RAM et / ou ROM.  La taille de ces tables est d√©termin√©e par le nombre de types d'objets.  L'identifiant d'un objet sp√©cifique est l'index dans ces tables.  J'ai donc d√©fini <b>NUSE_TASK</b> comme l'√©quivalent de <b>U8</b> .  Une variable de ce type (pas un pointeur) sert d'identifiant pour les t√¢ches.  Il s'agit d'une petite incompatibilit√© qui est facile √† d√©terminer si le code est port√© vers ou depuis Nucleus RTOS.  Les identifiants d'objets sont g√©n√©ralement stock√©s et transmis inchang√©s. <br><br>  Nucleus RTOS prend √©galement en charge la d√©nomination des t√¢ches.  Ces noms sont utilis√©s uniquement pour le d√©bogage.  Je les ai exclus de Nucleus SE pour √©conomiser de la m√©moire. <br><br><h3>  √âtats des t√¢ches </h3><br>  Dans Nucleus RTOS, les t√¢ches peuvent √™tre dans l'un des √©tats suivants: <i>Ex√©cution</i> , <i>Pr√™t</i> , <i>Suspendu</i> (ce qui conduit √† l'incertitude: la t√¢che est en attente ou bloqu√©e par un appel d'API), <i>Termin√©e</i> ou Termin√©e. <br><br>  Nucleus SE prend √©galement en charge les √©tats <i>Ex√©cution</i> et <i>Pr√™t</i> .  Les trois options <i>suspendues</i> sont prises en charge en option.  Termin√© et termin√© ne sont pas pris en charge.  Aucun appel d'API pour terminer les t√¢ches.  Une fonction de t√¢che externe ne doit jamais renvoyer une valeur de mani√®re explicite ou implicite (cela entra√Ænera un √©tat <i>Termin√©</i> dans Nucleus RTOS). <br><br><h3>  Appels d'API non r√©alis√©s </h3><br>  Nucleus RTOS prend en charge 16 appels de bureau pour travailler avec des t√¢ches.  Parmi ceux-ci, 7 ne sont pas impl√©ment√©s dans Nucleus SE.  Leur description, ainsi que la raison de leur exclusion sont d√©crites ci-dessus. <br><br>  Dans le prochain article, nous allons commencer √† examiner la gestion de la m√©moire RTOS. <br><br>  <b>√Ä propos de l'auteur:</b> Colin Walls travaille dans l'industrie √©lectronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.  Il est maintenant ing√©nieur firmware chez Mentor Embedded (une division de Mentor Graphics).  Colin Walls intervient souvent lors de conf√©rences et s√©minaires, auteur de nombreux articles techniques et de deux livres sur le firmware.  Vit au Royaume-Uni.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Blog</a> professionnel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de Colin</a> , e-mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr425353/">https://habr.com/ru/post/fr425353/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr425343/index.html">25 outils Kubernetes utiles: d√©ploiement et gestion</a></li>
<li><a href="../fr425345/index.html">Simplification des noms: le 802.11ax devient Wi-Fi 6</a></li>
<li><a href="../fr425347/index.html">Masque de vidage: mythe ou r√©alit√©</a></li>
<li><a href="../fr425349/index.html">Le forum Positive Hack Days 9 se tiendra les 21 et 22 mai √† Crocus Expo</a></li>
<li><a href="../fr425351/index.html">Les programmeurs de bricolage perdent leur emploi</a></li>
<li><a href="../fr425355/index.html">Cote de s√©curit√© du projet ICO</a></li>
<li><a href="../fr425357/index.html">Comment nous avons constitu√© une pile technologique de 12 √©tages et ne sommes pas devenus fous</a></li>
<li><a href="../fr425359/index.html">Les Chinois ont utilis√© une puce pour contr√¥ler les ordinateurs am√©ricains</a></li>
<li><a href="../fr425361/index.html">Blocage de contenu, extension pour les navigateurs au chrome</a></li>
<li><a href="../fr425363/index.html">Conseils pour les √©tudiants programmeurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>