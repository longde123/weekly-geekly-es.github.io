<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“ˆ ğŸ—£ï¸ ğŸ‘€ Unreal Engine4 - Efek pemindaian PostProcess ğŸ¤±ğŸ¼ ğŸ’˜ ğŸ¤ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Akhir pekan ini saya memiliki waktu luang antar kelas (perhatikan penulis menerima gelar Master of Science pada saat artikel) , dan saya memutuskan un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unreal Engine4 - Efek pemindaian PostProcess</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435240/"><img src="https://habrastorage.org/webt/eb/kt/at/ebktatsje1u5a3pyfbaqwl39u1w.png"><br><br>  Akhir pekan ini saya memiliki waktu luang antar kelas <i>(perhatikan penulis menerima gelar Master of Science pada saat artikel)</i> , dan saya memutuskan untuk kembali membuat shader dengan menciptakan efek pemindaian pasca-proses ini.  Saya membayangkan bahwa itu digunakan dalam permainan sebagai semacam efek pemindaian jarak.  Kami juga menggunakan beberapa distorsi kebisingan sederhana untuk membuat efeknya terlihat sedikit lebih menarik. <br><br>  Pada artikel ini saya akan memberi tahu Anda bagaimana menerapkan efek ini pada UE4.  Ada beberapa cara di mana Anda dapat membuat efek ini.  Salah satu metode ini dipilih oleh saya. <br><a name="habracut"></a><br><blockquote>  Anda dapat membuka gambar di tab baru untuk melihatnya dalam resolusi yang lebih tinggi. </blockquote><br><h2>  Komponen utama </h2><br>  Gagasan utama dari efek ini adalah untuk membuat versi render adegan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">operator Sobel</a> , dan kemudian mencampurnya dengan render adegan berbasis SphereMask yang biasa, yang kami akan buat untuk membuat efek pemindaian. <br><br>  Efek ini terdiri dari 3 komponen utama: <br><br><ul><li>  Bidang scalable SphereMask </li><li>  Fungsi Sobel-Edge (saya tidak akan menjelaskan bagaimana fungsi ini bekerja, karena ini adalah topik yang terpisah, tetapi saya akan merujuk pada kode yang saya gunakan) </li><li>  Overlay tekstur yang diproyeksikan di kisi dunia </li></ul><br><h2>  Bidang scalable SphereMask </h2><br>  Bagian ini adalah tentang bagaimana kita membuat SphereMask yang dapat diskalakan.  Untuk melakukan ini, kami mentransfer posisi cetak biru ke set parameter material, setelah itu kami menggunakannya sebagai berikut <br><br><img src="https://habrastorage.org/webt/jz/-d/fk/jz-dfkjptn55desctdqp4t45olw.jpeg"><br><br>  Hubungkan hasil node <b>Clamp</b> ke output <b>memancarkan</b> materi Anda dan Anda akan melihat sesuatu seperti ini <br><br><img src="https://habrastorage.org/webt/h3/qf/oe/h3qfoekicbzn3kxngd84oryuhyq.jpeg"><br><br>  "TexLoc" adalah <b>vektor3</b> yang menentukan lokasi sumber bola, dalam kasus saya ini dibaca dari serangkaian parameter material, sehingga dapat dibaca dari permainan itu sendiri, misalnya, untuk menentukan posisi pemain. <br><br>  Seperangkat parameter simpul yang ditentukan di atas menciptakan bidang dengan radius bola 1024 unit.  Saya hanya menggunakannya untuk menampilkan hasilnya di jendela pratinjau.  Jika Anda ingin mempelajari lebih lanjut tentang bekerja dengan fungsi jarak jauh dan memahami cara menggunakannya, saya sangat merekomendasikan untuk memeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">situs web Inigo Quilez</a> . <br><br>  Sekarang kita akan menggunakan <b>Waktu</b> untuk skala bola dengan interval waktu yang telah ditentukan. <br><br><img src="https://habrastorage.org/webt/cn/sd/7j/cnsd7j2jzs1k5igdjrz0yz5tuae.png"><br><br>  Ini akan memberi kita hasil berikut <br><br><img src="https://habrastorage.org/webt/b5/v3/wm/b5v3wmsatvch4ezgkzfwvrtz8hy.gif"><br><br>  <b>Frac</b> (waktu) pada dasarnya memberi kita periode konstan yang terus berjalan 0-1.0-1.0-1.  Kami mengalikan waktu dengan 0,25 untuk mengontrol kecepatan penskalaan, dan kemudian mengalikan hasilnya dengan jari-jari bola, yang mengarah ke perubahan jari-jari dari 0 hingga 1024, dan memberi kami topeng animasi. <br><br>  Ini adalah hasil yang baik, tetapi ini bukan yang kita inginkan dari efeknya.  Kami membutuhkan cincin penskalaan.  Ini dapat dengan mudah dilakukan dengan menggunakan perhitungan sederhana. <br><br><img src="https://habrastorage.org/webt/ms/vc/et/msvcetcx-nbivesju-m9hi10vum.png"><br><br>  Ini akan memberi kita apa yang kita inginkan, cincin yang sedang tumbuh, dengan gradasi gradien yang baik yang dapat dikendalikan. <br><br><img src="https://habrastorage.org/webt/wj/qf/bi/wjqfbikt-dezu6jcd_hnwjfqct8.gif"><br><br>  Operasi matematika di blok Edge_Mask pada dasarnya memilih posisi dalam mask gradien, dalam hal ini nilainya 0,5, dan menentukan tepi mask dari posisi saat ini dengan lebar yang diberikan, yang memungkinkan kita untuk mendapatkan cincin.  Saya tidak akan masuk ke detail teknis untuk mendapatkan tepi topeng, kemungkinan besar saya akan membicarakan hal ini di salah satu posting berikut. <br><br>  Seperti yang Anda lihat, Anda memiliki kontrol penuh atas lebar cincin tanpa parameter skalar, dan jika kami ingin, kami bahkan dapat mengontrol pelemahan tepi, tetapi kami tidak memerlukan ini dalam efek ini. <br><br>  Langkah selanjutnya adalah menggunakan noise untuk membuat versi cincin yang menarik secara visual. <br><br>  Untuk ini, kita akan menggunakan simpul <b>Vector Noise</b> , yang merupakan bagian dari UE4.  Anda dapat membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , atau Anda dapat menggunakan tekstur noise yang berisi koordinat UV World Aligned. <br><br>  Di shader saya, saya menetapkan parameter <b>Function</b> di Cellnoise di <b>simpul</b> <b>Noise Vector</b> , silakan bereksperimen dengan tipe parameter ini untuk mendapatkan efek unik Anda sendiri. <br><br><img src="https://habrastorage.org/webt/pt/pz/ty/ptpztyghnv7d1eehiegmrtncxlg.png"><br><br>  Hasilnya akan terlihat sebagai berikut <br><br><img src="https://habrastorage.org/webt/xb/em/pa/xbemparkbyjeaya1lldu8aikd_s.gif"><br><br>  Ini adalah tahap pertama shader kami selesai, maka kami akan mempertimbangkan implementasi fungsi Sobel-Edge. <br><h2>  Fungsi Sobel-Edge </h2><br>  Ada banyak opsi berbeda untuk fitur ini, beberapa di antaranya lebih dioptimalkan daripada yang lain, saya tidak akan menjelaskan esensinya, karena ini adalah topik yang terpisah, tetapi pencarian Google secara teratur dengan kata kunci "Sobel Edge" atau "Sobel Operator" akan memberi Anda banyak pilihan .  Atau gunakan artikel di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">hub</a> dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Gepard_vvk</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma untuk memilih kontur gambar</a> . <br><br>  Gagasan utama dari operator Sobel adalah ini: kami mengambil <b>RenderTarget</b> adegan (bayangkan bahwa itu adalah tekstur yang berisi apa yang saat ini Anda lihat di viewport Anda) dan membandingkan setiap piksel dengan semua piksel tetangga di sekitarnya.  Selanjutnya, kami membandingkan perbedaan kecerahan, dan jika perbedaannya di atas ambang tertentu, kami menandainya sebagai tepi, dan dalam proses ini kami mendapatkan <b>topeng</b> tekstur <b>Target RenderTarget</b> hitam dan putih, di mana topeng disesuaikan di tepi. <br><br>  Kode di bawah ini adalah contoh sederhana dari fungsi operator Sobel yang dibuat RebelMoogle di situs web Shadertoy (kemungkinan besar opsi ini tidak sepenuhnya dioptimalkan, sehingga Anda dapat mencoba implementasi lain), kami akan membuatnya kembali di UE4 dalam materi kami. <br><br><pre><code class="plaintext hljs">void mainImage( out vec4 fragColor, in vec2 fragCoord ) { vec2 uv = fragCoord.xy / iResolution.xy; vec3 TL = texture(iChannel0, uv + vec2(-1, 1)/ iResolution.xy).rgb; vec3 TM = texture(iChannel0, uv + vec2(0, 1)/ iResolution.xy).rgb; vec3 TR = texture(iChannel0, uv + vec2(1, 1)/ iResolution.xy).rgb; vec3 ML = texture(iChannel0, uv + vec2(-1, 0)/ iResolution.xy).rgb; vec3 MR = texture(iChannel0, uv + vec2(1, 0)/ iResolution.xy).rgb; vec3 BL = texture(iChannel0, uv + vec2(-1, -1)/ iResolution.xy).rgb; vec3 BM = texture(iChannel0, uv + vec2(0, -1)/ iResolution.xy).rgb; vec3 BR = texture(iChannel0, uv + vec2(1, -1)/ iResolution.xy).rgb; vec3 GradX = -TL + TR - 2.0 * ML + 2.0 * MR - BL + BR; vec3 GradY = TL + 2.0 * TM + TR - BL - 2.0 * BM - BR; fragColor.r = length(vec2(GradX.r, GradY.r)); fragColor.g = length(vec2(GradX.g, GradY.g)); fragColor.b = length(vec2(GradX.b, GradY.b)); }</code> </pre> <br><br>  Di UE4, terlihat seperti ini <br><br><img src="https://habrastorage.org/webt/fi/eb/ib/fiebib30po02dkdnichwx2cf024.png"><br><br>  Catatan <b>singkat</b> tentang implementasi fungsi - pastikan node <b>SceneTexture</b> Anda dikonfigurasi untuk menggunakan <b>PostProcessInput0</b> <br><br><img src="https://habrastorage.org/webt/ov/jr/vf/ovjrvfg2ifgorbtscy3k8haowg0.png"><br><br>  Dua <b>Custom</b> node <b>GradX</b> dan <b>GradY</b> , konfigurasikan dengan cara yang sama <br><br><img src="https://habrastorage.org/webt/gn/zu/wx/gnzuwx4ri_uwhpm53i78mksu85c.png"><br><br>  <b>GradX</b> : <br><br><pre> <code class="plaintext hljs">return -TL + TR - 2.0 * ML + 2.0 * MR - BL + BR;</code> </pre> <br>  <b>Grady</b> : <br><br><pre> <code class="plaintext hljs">return TL + 2.0 * TM + TR - BL - 2.0 * BM - BR;</code> </pre> <br>  Ini tidak harus dilakukan di <b>Custom</b> , saya menggunakannya hanya untuk kenyamanan, karena kalau tidak akan ada terlalu banyak node dan spaghetti akan terbentuk. <br><br>  Jika Anda menyambungkan hasil fungsi ke keluaran material yang <b>memancarkan</b> , Anda akan melihat yang berikut ini <br><br><img src="https://habrastorage.org/webt/_n/3w/qt/_n3wqteobpqlyz11yeynr_b-lbm.png"><br><br>  Kami juga mengalikan hasilnya dengan <b>vektor3</b> biasa untuk membuat tepi warna apa pun yang kita inginkan. <br><br><img src="https://habrastorage.org/webt/lf/ds/xm/lfdsxmpztfwvruscn3d8qvzuyvw.png"><br><br>  Hasilnya, warna tepi berubah. <br><br><img src="https://habrastorage.org/webt/pn/qw/uf/pnqwufgzqldvv6oaktj7r4hk5uw.jpeg"><br><br><h2>  Dunia overlay tekstur kotak </h2><br>  Bagian paling sederhana: kami hanya menggunakan tekstur mesh dan memproyeksikannya ke seluruh dunia, dan kemudian menggabungkannya dengan fungsi Sobel-Edge untuk mendapatkan efek keren. <br><br><img src="https://habrastorage.org/webt/by/v3/j0/byv3j0lb_k-uigmefr3i0wr6_n0.png"><br><br>  Jika Anda menghubungkan hasil fungsi ke output <b>emissive</b> , Anda akan melihat <br><br><img src="https://habrastorage.org/webt/m0/0a/nx/m00anxzujqqnujris_krdkkc6s8.png"><br><br><h2>  Menyatukan semuanya </h2><br>  Sekarang kita akan menyatukan ketiga bagian untuk efek posting kita! <br><br>  Pertama, kami menggabungkan fitur Sobel-Edge dan World-Aligned-Grid, menyatukannya <br><br><img src="https://habrastorage.org/webt/-a/vb/zw/-avbzwdxn7c50pqhjdnnveqiezm.png"><br><br>  Kemudian kita membuat simpul <b>SceneTexture</b> dan menambahkan hasilnya dari Sobel-Edge dan World-Aligned-Grid ke sana. <br><br>  Lalu kami menyisipkan antara adegan normal dan yang ditambahkan, menggunakan hasil dari topeng cincin yang kami buat di bagian pertama <br><br><img src="https://habrastorage.org/webt/mb/r_/bs/mbr_bsbhkbyvsz3xskjmshfwf4e.png"><br><br>  Dan voila, kami berhasil.  Hasil akhirnya akan terlihat seperti ini.  Anda tentu saja dapat menyesuaikan parameter dan mencoba mengubah nilainya untuk mendapatkan opsi yang lebih menarik. <br><br><img src="https://habrastorage.org/webt/oe/ar/9f/oear9ft9pqe7cjbjfpvizihi3mu.gif"><br><br>  Saya harap Anda menemukan informasi ini berguna, semua yang terbaik :) <br><br>  Contoh proyek dengan shader ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435240/">https://habr.com/ru/post/id435240/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435224/index.html">Cara berkomunikasi di kantor berbahasa Inggris: 14 idiom yang bermanfaat</a></li>
<li><a href="../id435226/index.html">Kembalikan data dari awal</a></li>
<li><a href="../id435228/index.html">Kubernetes cluster untuk $ 20 per bulan</a></li>
<li><a href="../id435234/index.html">Lebih cerdas, lebih jauh, lebih tepatnya: bagaimana AI mengubah penerbangan ke ruang angkasa</a></li>
<li><a href="../id435236/index.html">Mesin byte untuk benteng (dan tidak hanya) di Native American (bagian 3)</a></li>
<li><a href="../id435242/index.html">Mengapa saya takut menjadi "pria yang dipompa"</a></li>
<li><a href="../id435244/index.html">Proyek ITER pada 2018</a></li>
<li><a href="../id435246/index.html">Tesla telah membuka pre-order untuk Model 3 di Eropa dan Cina</a></li>
<li><a href="../id435248/index.html">Navigasi di dalam aplikasi Android</a></li>
<li><a href="../id435250/index.html">Bagaimana Universitas ITMO bekerja: tur laboratorium cyberphysical kami</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>