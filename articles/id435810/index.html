<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ò™Ô∏è üßô üÖ∞Ô∏è GABUNGLAH koleksi lokal dan DbSet dalam Entity Framework ‚ñ´Ô∏è üê° ü§¥üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sedikit lebih dari setahun dengan partisipasi saya, "dialog" berikut ini terjadi: 


 Aplikasi .Net : Hey Entity Framework, mohon beri saya banyak dat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GABUNGLAH koleksi lokal dan DbSet dalam Entity Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435810/"><p>  Sedikit lebih dari setahun dengan partisipasi saya, "dialog" berikut ini terjadi: </p><br><p>  <strong>Aplikasi .Net</strong> : Hey Entity Framework, mohon beri saya banyak data! <br>  <strong>Kerangka Entitas</strong> : Maaf, saya tidak mengerti Anda.  Apa maksudmu <br>  <strong>Aplikasi Net</strong> : Ya, saya baru saja mendapat koleksi 100 ribu transaksi.  Dan sekarang kita perlu dengan cepat memeriksa kebenaran harga sekuritas yang ditunjukkan di sana. <br>  <strong>Kerangka Entitas</strong> : Ahh, well, mari kita coba ... <br>  <strong>Aplikasi .Net</strong> : Berikut ini kodenya: </p><br><pre><code class="cpp hljs">var query = from p in context.Prices join t in transactions on <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { p.Ticker, p.TradedOn, p.PriceSourceId } equals <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t.Ticker, t.TradedOn, t.PriceSourceId } select p; query.ToList();</code> </pre> <br><p>  <strong>Kerangka Entitas</strong> : </p><br><p><img src="https://habrastorage.org/webt/kc/jh/lp/kcjhlpnggo_fhkdgik481svjuea.png"></p><br><p>  Klasik  Saya pikir banyak orang yang akrab dengan situasi ini: ketika saya benar-benar ingin "cantik" dan cepat melakukan pencarian di database menggunakan <em>GABUNG</em> koleksi lokal dan <em>DbSet</em> .  Biasanya pengalaman ini mengecewakan. </p><br><p>  Dalam artikel ini (yang merupakan <em>terjemahan bebas dari artikel saya yang lain</em> ) saya akan melakukan serangkaian percobaan dan mencoba berbagai cara untuk mengatasi batasan ini.  Akan ada kode (tidak rumit), pikiran dan sesuatu seperti akhir yang bahagia. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Semua orang tahu tentang <em>Entity Framework</em> , banyak yang menggunakannya setiap hari, dan ada banyak artikel bagus tentang cara memasaknya dengan benar (gunakan kueri yang lebih sederhana, gunakan parameter di Lewati dan Ambil, gunakan VIEW, minta hanya bidang yang diperlukan, pantau caching permintaan dan lainnya), namun, tema <em>GABUNG</em> dari koleksi lokal dan <em>DbSet</em> masih merupakan titik lemah. </p><br><h2 id="zadacha">  Tantangan </h2><br><p>  Misalkan ada database dengan harga dan ada koleksi transaksi yang Anda perlu memeriksa kebenaran harga.  Dan anggaplah kita memiliki kode berikut. </p><br><pre> <code class="cpp hljs">var localData = GetDataFromApiOrUser(); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in localData on <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { s.Ticker, p.TradedOn, p.PriceSourceId } equals <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { t.Ticker, t.TradedOn, t.PriceSourceId } select p; var result = query.ToList();</code> </pre> <br><p>  Kode ini tidak berfungsi di <em>Entity Framework 6</em> sama sekali.  Dalam <em>Entity Framework Core</em> - ini berfungsi, tetapi semuanya akan dilakukan di sisi klien dan dalam kasus ketika ada jutaan catatan dalam database - ini bukan pilihan. </p><br><p>  Seperti yang saya katakan, saya akan mencoba berbagai cara untuk mengatasi ini.  Dari yang sederhana hingga yang kompleks.  Untuk percobaan saya, saya menggunakan kode dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> berikut.  Kode ini ditulis menggunakan: <em>C #</em> , <em>.Net Core</em> , <em>EF Core</em> dan <em>PostgreSQL</em> . </p><br><p>  Saya juga memotret beberapa metrik: waktu yang dihabiskan dan konsumsi memori.  Penafian: jika tes dilakukan selama lebih dari 10 menit, saya memotongnya (batasannya dari atas).  Mesin uji Intel Core i5, 8 GB RAM, SSD. </p><br><div class="spoiler">  <b class="spoiler_title">Skema DB</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/getpro/habr/post_images/1d5/f8c/cec/1d5f8ccec6ef1b7361195c18ac139d09.png" alt="gambar"></p><br><p>  Hanya 3 tabel: <em>harga</em> , <em>surat berharga</em> , dan <em>sumber harga</em> .  <em>Harga</em> - berisi 10 juta entri. </p></div></div><br><h4 id="sposob-1-naive">  Metode 1. Naif </h4><br><p>  Mari mulai sederhana dan gunakan kode berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Kode untuk metode 1</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { foreach (var testElement in TestData) { result.AddRange(context.Prices.Where( x =&gt; x.Security.Ticker == testElement.Ticker &amp;&amp; x.TradedOn == testElement.TradedOn &amp;&amp; x.PriceSourceId == testElement.PriceSourceId)); } }</code> </pre> </div></div><br><p>  Idenya sederhana: dalam satu lingkaran kita membaca catatan dari database satu per satu dan menambah koleksi yang dihasilkan.  Kode ini hanya memiliki satu keunggulan - kesederhanaan.  Dan satu kelemahan adalah kecepatan rendah: bahkan jika ada indeks dalam database, sebagian besar waktu akan mengambil komunikasi dengan server database.  Metriknya adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/985/61c/b6a/98561cb6a2566faff490fc2bf7432fb9.png" alt="gambar"></p><br><p>  Konsumsi memori kecil.  Koleksi besar membutuhkan waktu 1 menit.  Sebagai permulaan, tidak buruk, tapi saya ingin lebih cepat. </p><br><h4 id="sposob-2-naive-parallel">  Metode 2: Paralel naif </h4><br><p>  Mari kita coba tambahkan paralelisme.  Idenya adalah untuk mengakses database dari banyak utas. </p><br><div class="spoiler">  <b class="spoiler_title">Kode untuk metode 2</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentBag&lt;Price&gt;(); var partitioner = Partitioner.Create(<span class="hljs-number"><span class="hljs-number">0</span></span>, TestData.Count); Parallel.ForEach(partitioner, range =&gt; { var subList = TestData.Skip(range.Item1) .Take(range.Item2 - range.Item1) .ToList(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { foreach (var testElement in subList) { var query = context.Prices.Where( x =&gt; x.Security.Ticker == testElement.Ticker &amp;&amp; x.TradedOn == testElement.TradedOn &amp;&amp; x.PriceSourceId == testElement.PriceSourceId); foreach (var el in query) { result.Add(el); } } } });</code> </pre> </div></div><br><p>  Hasil: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/916/d22/428/916d224282a3020dc31df6c67a18b070.png" alt="gambar"></p><br><p>  Untuk koleksi kecil, pendekatan ini bahkan lebih lambat dari metode pertama.  Dan untuk yang terbesar - 2 kali lebih cepat.  Menariknya, 4 utas dihasilkan di mesin saya, tetapi ini tidak menghasilkan akselerasi 4x.  Ini menunjukkan bahwa overhead dalam metode ini signifikan: baik di sisi klien dan di sisi server.  Konsumsi memori meningkat, tetapi tidak signifikan. </p><br><h4 id="sposob-3-multiple-contains">  Metode 3: Berisi Banyak </h4><br><p>  Saatnya mencoba sesuatu yang lain dan mencoba mengurangi tugas menjadi satu kueri.  Itu bisa dilakukan sebagai berikut: </p><br><ol><li>  Siapkan 3 koleksi unik <em>Ticker</em> , <em>PriceSourceId,</em> dan <em>Date</em> </li><li>  Jalankan permintaan dan gunakan 3 <em>Berisi</em> </li><li>  Periksa kembali hasil secara lokal </li></ol><br><div class="spoiler">  <b class="spoiler_title">Kode untuk metode 3</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { <span class="hljs-comment"><span class="hljs-comment">//   var tickers = TestData.Select(x =&gt; x.Ticker).Distinct().ToList(); var dates = TestData.Select(x =&gt; x.TradedOn).Distinct().ToList(); var ps = TestData.Select(x =&gt; x.PriceSourceId).Distinct().ToList(); //    3 Contains var data = context.Prices .Where(x =&gt; tickers.Contains(x.Security.Ticker) &amp;&amp; dates.Contains(x.TradedOn) &amp;&amp; ps.Contains(x.PriceSourceId)) .Select(x =&gt; new { Price = x, Ticker = x.Security.Ticker, }) .ToList(); var lookup = data.ToLookup(x =&gt; $"{x.Ticker}, {x.Price.TradedOn}, {x.Price.PriceSourceId}"); //  foreach (var el in TestData) { var key = $"{el.Ticker}, {el.TradedOn}, {el.PriceSourceId}"; result.AddRange(lookup[key].Select(x =&gt; x.Price)); } }</span></span></code> </pre> </div></div><br><p>  Masalahnya di sini adalah bahwa waktu eksekusi dan jumlah data yang dikembalikan sangat tergantung pada data itu sendiri (baik dalam kueri dan dalam database).  Artinya, satu set hanya data yang diperlukan yang dapat kembali, dan catatan tambahan dapat dikembalikan (bahkan 100 kali lebih banyak). </p><br><p>  Ini dapat dijelaskan dengan menggunakan contoh berikut.  Misalkan ada tabel berikut dengan data: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3f/2bb/ea5/f3f2bbea5148127963cab9010d2b2f10.png" alt="gambar"></p><br><p>  Misalkan saya membutuhkan harga untuk <em>Ticker1</em> dengan <em>TradedOn</em> = <em>2018-01-01</em> dan untuk <em>Ticker2</em> dengan <em>TradedOn</em> = <em>2018-01-02</em> . </p><br><p>  Kemudian nilai unik untuk <em>Ticker</em> = ( <em>Ticker1</em> , <em>Ticker2</em> ) <br>  Dan nilai unik untuk <em>TradedOn</em> = ( <em>2018-01-01</em> , <em>2018-01-02</em> ) </p><br><p>  Namun, 4 catatan akan dikembalikan sebagai hasilnya, karena mereka benar-benar sesuai dengan kombinasi ini.  Yang buruk adalah bahwa semakin banyak bidang yang digunakan, semakin besar peluang untuk mendapatkan catatan tambahan sebagai hasilnya. </p><br><p>  Untuk alasan ini, data yang diperoleh dengan metode ini juga harus difilter di sisi klien.  Dan ini adalah kelemahan terbesar. <br>  Metriknya adalah sebagai berikut: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd5/078/5ef/dd50785efd38900c4d18467607b87a1e.png" alt="gambar"></p><br><p>  Konsumsi memori lebih buruk daripada semua metode sebelumnya.  Jumlah baris yang dibaca jauh lebih besar dari jumlah yang diminta.  Tes untuk koleksi besar terhenti karena mereka berjalan selama lebih dari 10 menit.  Metode ini tidak baik. </p><br><h4 id="sposob-4-predicate-builder">  Metode 4. Predicate builder </h4><br><p>  Mari kita coba di sisi lain: <em>Ekspresi</em> tua yang baik.  Dengan menggunakannya, Anda dapat membuat 1 kueri besar dalam formulir berikut: </p><br><p> <code>‚Ä¶ (.. AND .. AND ..) OR (.. AND .. AND ..) OR (.. AND .. AND ..) ‚Ä¶</code> </p> <br><p>  Ini memberi harapan bahwa akan dimungkinkan untuk membangun 1 permintaan dan hanya mendapatkan data yang diperlukan untuk 1 panggilan.  Kode: </p><br><div class="spoiler">  <b class="spoiler_title">Kode untuk metode 4</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { var baseQuery = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId select <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestData() { Ticker = s.Ticker, TradedOn = p.TradedOn, PriceSourceId = p.PriceSourceId, PriceObject = p }; var tradedOnProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>); var priceSourceIdProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>); var tickerProperty = typeof(TestData).GetProperty(<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>); var paramExpression = Expression.Parameter(typeof(TestData)); Expression wholeClause = null; foreach (var td in TestData) { var elementClause = Expression.AndAlso( Expression.Equal( Expression.MakeMemberAccess( paramExpression, tradedOnProperty), Expression.Constant(td.TradedOn) ), Expression.AndAlso( Expression.Equal( Expression.MakeMemberAccess( paramExpression, priceSourceIdProperty), Expression.Constant(td.PriceSourceId) ), Expression.Equal( Expression.MakeMemberAccess( paramExpression, tickerProperty), Expression.Constant(td.Ticker)) )); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wholeClause == null) wholeClause = elementClause; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> wholeClause = Expression.OrElse(wholeClause, elementClause); } var query = baseQuery.Where( (Expression&lt;Func&lt;TestData, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt;)Expression.Lambda( wholeClause, paramExpression)).Select(x =&gt; x.PriceObject); result.AddRange(query); }</code> </pre> </div></div><br><p>  Kode tersebut ternyata lebih rumit daripada metode sebelumnya.  Membangun <em>Ekspresi</em> secara manual bukanlah operasi yang termudah dan tercepat. </p><br><p>  Metrik: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/312/373/4fc/3123734fc82c4fc4d783f4f9ce2cf225.png" alt="gambar"></p><br><p>  Hasil sementara bahkan lebih buruk daripada metode sebelumnya.  Tampaknya overhead selama konstruksi dan ketika berjalan melalui pohon ternyata jauh lebih banyak daripada keuntungan menggunakan satu permintaan. </p><br><h4 id="sposob-5-shared-query-data-table">  Metode 5: Tabel data kueri yang dibagikan </h4><br><p>  Mari kita coba opsi lain: <br>  Saya membuat tabel baru dalam database di mana saya akan menulis data yang diperlukan untuk menyelesaikan permintaan (secara implisit saya memerlukan <em>DbSet</em> baru dalam konteks). </p><br><p>  Sekarang, untuk mendapatkan hasil yang Anda butuhkan: </p><br><ol><li>  Mulai transaksi </li><li>  Unggah data kueri ke tabel baru </li><li>  Jalankan kueri itu sendiri (menggunakan tabel baru) </li><li>  Kembalikan transaksi (untuk menghapus tabel data untuk kueri) </li></ol><br><p>  Kode ini terlihat seperti ini: </p><br><div class="spoiler">  <b class="spoiler_title">Kode untuk metode 5</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { context.Database.BeginTransaction(); var reducedData = TestData.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SharedQueryModel() { PriceSourceId = x.PriceSourceId, Ticker = x.Ticker, TradedOn = x.TradedOn }).ToList(); <span class="hljs-comment"><span class="hljs-comment">//      context.QueryDataShared.AddRange(reducedData); context.SaveChanges(); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in context.QueryDataShared on new { s.Ticker, p.TradedOn, p.PriceSourceId } equals new { t.Ticker, t.TradedOn, t.PriceSourceId } select p; result.AddRange(query); context.Database.RollbackTransaction(); }</span></span></code> </pre> </div></div><br><p>  Metrik pertama: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/df0/ab7/d7d/df0ab7d7d01b0aeaeebf2b9a41f5e75b.png" alt="gambar"></p><br><p>  Semua tes bekerja dan bekerja dengan cepat!  Konsumsi memori juga dapat diterima. <br>  Dengan demikian, melalui penggunaan transaksi, tabel ini dapat digunakan secara bersamaan oleh beberapa proses.  Dan karena ini adalah tabel nyata yang ada, semua fitur dari <em>Entity Framework</em> tersedia untuk kami: Anda hanya perlu memuat data ke dalam tabel, membangun kueri menggunakan <em>GABUNG,</em> dan jalankan.  Pada pandangan pertama, inilah yang Anda butuhkan, tetapi ada kerugian signifikan: </p><br><ul><li>  Anda harus membuat tabel untuk tipe kueri tertentu </li><li>  Penting untuk menggunakan transaksi (dan menyia-nyiakan sumber daya DBMS) </li><li>  Dan gagasan bahwa Anda perlu MENULIS sesuatu, ketika Anda perlu BACA, terlihat aneh.  Dan pada Baca Replika, itu tidak akan berhasil. <br>  Dan sisanya adalah solusi kerja yang lebih atau kurang yang sudah dapat digunakan. </li></ul><br><h4 id="sposob-6-memoryjoin-extension">  Metode 6. Ekstensi MemoryJoin </h4><br><p>  Sekarang Anda dapat mencoba meningkatkan pendekatan sebelumnya.  Pikirannya adalah: </p><br><ul><li>  Alih-alih menggunakan tabel yang khusus untuk satu jenis kueri, Anda bisa menggunakan beberapa opsi umum.  Yaitu, buat tabel dengan nama seperti <em>shared_query_data</em> , dan tambahkan beberapa bidang <em>Guid</em> , beberapa <em>Long</em> , beberapa <em>String</em> , dll ke dalamnya.  Nama-nama sederhana dapat diambil: <em>Guid1</em> , <em>Guid2</em> , <em>String1</em> , <em>Long1</em> , <em>Date2</em> , dll.  Maka tabel ini dapat digunakan untuk 95% tipe kueri.  Nama properti dapat "disesuaikan" nanti menggunakan perspektif <strong>Select</strong> . </li><li>  Selanjutnya Anda perlu menambahkan <em>DbSet</em> untuk <em>shared_query_data</em> . </li><li>  Tetapi bagaimana jika, alih-alih menulis data ke database, meneruskan nilai menggunakan konstruk <strong>VALUES</strong> ?  Artinya, perlu bahwa dalam query SQL final, alih-alih mengakses <em>shared_query_data, harus</em> ada banding ke <strong>VALUES</strong> .  Bagaimana cara melakukannya? <br><ul><li>  Dalam Entity Framework Core - hanya menggunakan <em>FromSql</em> . </li><li>  Di Entity Framework 6 - Anda harus menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DbInterception</a> - yaitu, ubah SQL yang dihasilkan dengan menambahkan konstruksi <strong>VALUES</strong> tepat sebelum eksekusi.  Ini akan menghasilkan batasan: dalam satu permintaan, tidak lebih dari satu konstruksi <strong>NILAI</strong> .  Tapi itu akan berhasil! </li></ul></li><li>  Karena kita tidak akan menulis ke database, maka kita mendapatkan tabel <em>shared_query_data yang</em> dibuat pada langkah pertama, apakah itu tidak diperlukan sama sekali?  Jawab: ya, tidak diperlukan, tetapi <em>DbSet</em> masih diperlukan, karena Kerangka Entitas harus mengetahui skema data untuk membangun kueri.  Ternyata kita membutuhkan <em>DbSet</em> untuk beberapa model umum yang tidak ada dalam database dan hanya digunakan untuk menginspirasi Kerangka Entitas, yang mengetahui apa yang dilakukannya. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Konversi IEnumerable ke Contoh IQueryable</b> <div class="spoiler_text"><ol><li>  Input menerima koleksi objek dari tipe berikut: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeQueryData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Ticker {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTimeTradedOn {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PriceSourceId {get; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>;} }</code> </pre> </li><li>  Kami memiliki <em>DbSet yang</em> kami miliki dengan bidang <em>String1</em> , <em>String2</em> , <em>Date1</em> , <em>Long1</em> , <em>dll</em> </li><li>  Biarkan <em>Ticker</em> disimpan di <em>String1</em> , <em>TradedOn</em> di <em>Date1</em> , dan <em>PriceSourceId</em> di <em>Long1</em> ( <em>int</em> mapps in <em>long</em> , agar tidak membuat bidang untuk <em>int</em> dan terpisah <em>lama</em> ) </li><li>  Maka <em>FromSql</em> + <em>VALUES</em> akan seperti ini: <br><pre> <code class="cpp hljs">var query = context.QuerySharedData.FromSql( <span class="hljs-string"><span class="hljs-string">"SELECT * FROM ( VALUES (1, 'Ticker1', @date1, @id1), (2, 'Ticker2', @date2, @id2) ) AS __gen_query_data__ (id, string1, date1, long1)"</span></span>)</code> </pre> </li><li>  Sekarang Anda dapat membuat proyeksi dan mengembalikan <em>IQueryable</em> nyaman menggunakan jenis yang sama pada input: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> query.Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeQueryData() { Ticker = x.String1, TradedOn = x.Date1, PriceSourceId = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x.Long1 });</code> </pre> </li></ol></div></div><br><p>  Saya berhasil menerapkan pendekatan ini dan bahkan mendesainnya sebagai paket NuGet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">EntityFrameworkCore.MemoryJoin</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode ini</a> juga tersedia).  Terlepas dari kenyataan bahwa nama tersebut mengandung kata <em>Core</em> , <em>Entity Framework</em> 6 juga didukung.  Saya menyebutnya <strong>MemoryJoin</strong> , tetapi sebenarnya ia mengirimkan data lokal ke DBMS dalam konstruksi <em>VALUES</em> dan semua pekerjaan dilakukan di sana. </p><br><p>  Kode tersebut adalah sebagai berikut: </p><br><div class="spoiler">  <b class="spoiler_title">Kode untuk metode 6</b> <div class="spoiler_text"><pre> <code class="cpp hljs">var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Price&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (var context = CreateContext()) { <span class="hljs-comment"><span class="hljs-comment">// :    ,      var reducedData = TestData.Select(x =&gt; new { x.Ticker, x.TradedOn, x.PriceSourceId }).ToList(); //  IEnumerable&lt;&gt;   IQueryable&lt;&gt; var queryable = context.FromLocalList(reducedData); var query = from p in context.Prices join s in context.Securities on p.SecurityId equals s.SecurityId join t in queryable on new { s.Ticker, p.TradedOn, p.PriceSourceId } equals new { t.Ticker, t.TradedOn, t.PriceSourceId } select p; result.AddRange(query); }</span></span></code> </pre> </div></div><br><p>  Metrik: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a7/d72/bb2/6a7d72bb265d9dedbc8e54d94fe16a4f.png" alt="gambar"></p><br><p>  Ini adalah hasil terbaik yang pernah saya coba.  Kode ini sangat sederhana dan mudah, dan pada saat yang sama berfungsi untuk Baca Replika. </p><br><div class="spoiler">  <b class="spoiler_title">Contoh permintaan yang dihasilkan untuk menerima 3 elemen</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"ClosePrice"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"OpenPrice"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span>, <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-string"><span class="hljs-string">"Price"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> <span class="hljs-string"><span class="hljs-string">"Security"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"s"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span> = <span class="hljs-string"><span class="hljs-string">"s"</span></span>.<span class="hljs-string"><span class="hljs-string">"SecurityId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"string1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>, <span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"date1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"TradedOn"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(<span class="hljs-string"><span class="hljs-string">"x"</span></span>.<span class="hljs-string"><span class="hljs-string">"long1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> int4) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, @__gen_q_p0, @__gen_q_p1, @__gen_q_p2), (<span class="hljs-number"><span class="hljs-number">2</span></span>, @__gen_q_p3, @__gen_q_p4, @__gen_q_p5), (<span class="hljs-number"><span class="hljs-number">3</span></span>, @__gen_q_p6, @__gen_q_p7, @__gen_q_p8) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> __gen_query_data__ (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, string1, date1, long1) ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"x"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">"t"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> ((<span class="hljs-string"><span class="hljs-string">"s"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span> = <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"Ticker"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (<span class="hljs-string"><span class="hljs-string">"p"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span> = <span class="hljs-string"><span class="hljs-string">"t"</span></span>.<span class="hljs-string"><span class="hljs-string">"PriceSourceId"</span></span>)</code> </pre> <br><p>  Di sini Anda juga dapat melihat bagaimana model umum (dengan bidang <em>String1</em> , <em>Date1</em> , <em>Long1</em> ) menggunakan Pilih berubah menjadi salah satu yang digunakan dalam kode (dengan bidang <em>Ticker</em> , <em>TradedOn</em> , <em>PriceSourceId</em> ). </p></div></div><br><p>  Semua pekerjaan dilakukan dalam 1 kueri di server SQL.  Dan ini adalah akhir yang kecil, yang saya bicarakan di awal.  Meskipun demikian, penggunaan metode ini membutuhkan pemahaman dan langkah-langkah berikut: </p><br><ul><li>  Anda perlu menambahkan <em>DbSet</em> tambahan ke konteks Anda (meskipun tabel itu sendiri dapat <em>dihilangkan</em> ) </li><li>  Dalam model umum, yang digunakan secara default, 3 bidang tipe <em>Guid</em> , <em>String</em> , <em>Double</em> , <em>Long</em> , <em>Date</em> , dll dideklarasikan.  Itu harus cukup untuk 95% jenis permintaan.  Dan jika Anda meneruskan koleksi objek dengan 20 bidang ke <em>FromLocalList</em> , <em>Pengecualian</em> akan dilempar, mengatakan bahwa objek itu terlalu kompleks.  Ini adalah batasan lunak dan dapat dielakkan - Anda dapat mendeklarasikan tipe Anda dan menambahkan setidaknya 100 bidang di sana.  Namun, lebih banyak bidang lebih lambat untuk berfungsi. </li><li>  Rincian teknis lainnya dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> saya. </li></ul><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Dalam artikel ini, saya mempresentasikan pemikiran saya tentang topik GABUNGAN koleksi lokal dan DbSet.  Tampaknya bagi saya bahwa pengembangan saya menggunakan <em>VALUES</em> mungkin menarik bagi masyarakat.  Setidaknya saya tidak menemui pendekatan seperti itu ketika saya memecahkan masalah ini sendiri.  Secara pribadi, metode ini membantu saya untuk mengatasi sejumlah masalah kinerja dalam proyek saya saat ini, mungkin itu akan membantu Anda juga. </p><br><p>  Seseorang akan mengatakan bahwa penggunaan <em>MemoryJoin</em> terlalu "musykil" dan perlu dikembangkan lebih lanjut, dan sampai saat itu tidak boleh digunakan.  Inilah alasan mengapa saya sangat ragu dan selama hampir satu tahun saya tidak menulis artikel ini.  Saya setuju bahwa saya ingin bekerja lebih mudah (saya berharap suatu hari nanti akan), tetapi saya juga mengatakan bahwa optimasi tidak pernah menjadi tugas Juniors.  Optimalisasi selalu membutuhkan pemahaman tentang cara alat bekerja.  Dan jika ada kesempatan untuk mendapatkan akselerasi hingga ~ 8 kali ( <em>Naive Parallel</em> vs <em>MemoryJoin</em> ), maka saya akan menguasai 2 poin dan dokumentasi. </p><br><p>  Dan akhirnya, diagram: </p><br><p>  Waktu yang dihabiskan.  Hanya 4 metode menyelesaikan tugas dalam waktu kurang dari 10 menit, dan <em>MemoryJoin</em> adalah satu-satunya cara yang menyelesaikan tugas dalam waktu kurang dari 10 detik. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/720/256/846/72025684620477d221c0f113a6cb354f.png" alt="gambar"></p><br><p>  Konsumsi memori.  Semua metode menunjukkan konsumsi memori yang kira-kira sama, kecuali untuk <em>Multiple Contains</em> .  Ini karena jumlah data yang dikembalikan. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e07/a91/b63/e07a91b63375d49a21adb81e8213ffdb.png" alt="gambar"></p><br><p>  Terima kasih sudah membaca! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id435810/">https://habr.com/ru/post/id435810/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id435798/index.html">Sony WH-1000XM3 - headphone nirkabel terbaik?</a></li>
<li><a href="../id435800/index.html">Surat Desembris 11</a></li>
<li><a href="../id435802/index.html">OpenVPN, tentang yang Anda tahu sangat sedikit</a></li>
<li><a href="../id435804/index.html">Intel Cyclone tidak menyimpan konfigurasi setelah reboot</a></li>
<li><a href="../id435806/index.html">Uji klinis tambalan bioteknologi pada jantung diumumkan di Jepang</a></li>
<li><a href="../id435812/index.html">Teori kebahagiaan. Statistik sebagai cara ilmiah untuk tidak tahu apa-apa</a></li>
<li><a href="../id435814/index.html">[The Old New Thing] Bisakah saya menggunakan tumpukan saya sesuka saya?</a></li>
<li><a href="../id435816/index.html">Rumah Sakit Massachusetts dan DeepMind secara independen membuka kotak hitam AI dalam bidang kedokteran</a></li>
<li><a href="../id435822/index.html">Cara mengontrol perangkat keras di pusat data menggunakan suara</a></li>
<li><a href="../id435824/index.html">Apa yang perlu Anda ketahui sebelum memulai karier di industri audio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>