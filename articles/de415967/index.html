<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👲 💀 🐲 SolidFire - Speicher für diejenigen, die Hassspeicher haben 😁 🍨 🤹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es entstehen immer mehr Lösungen, die sich vom traditionellen Unified Storage-Ansatz entfernen. Hierbei handelt es sich um spezialisierte Speicher, di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SolidFire - Speicher für diejenigen, die Hassspeicher haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/415967/">  Es entstehen immer mehr Lösungen, die sich vom traditionellen Unified Storage-Ansatz entfernen.  Hierbei handelt es sich um spezialisierte Speicher, die auf die Aufgaben eines bestimmten Geschäftsbereichs zugeschnitten sind.  Zuvor habe ich über das Infinidat InfiniBox F2230-System gesprochen.  Heute im Zentrum meiner SolidFire-Überprüfung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5x/9z/gx/5x9zgx1i1z61iu-ipqb6hdvakzm.jpeg"></div>  <i>"Wer fickt Hassspeicher" @ Dave Heats, Gründer von NetApp</i> <br><a name="habracut"></a><br>  Ende 2015 gab NetApp den Kauf des 2010 gegründeten SolidFire-Startups bekannt.  Das Interesse an diesen Systemen beruht auf ihrem unterschiedlichen Ansatz bei der Verwaltung von Data Warehouses und ihrer vorhersehbaren Leistung. <br><br>  SolidFire-Lösungen ergänzten die NetApp-Produktlinie, die die Serien All Flash FAS (AFF), EF und E umfasste.  Eineinhalb Jahre später konnte ein neues Produkt auf den Markt gebracht werden - NetApp HCI (Hyper Converged Infrastructure), das SolidFire als Speichersubsystem verwendet. <br><br><blockquote>  „Wir entwickeln ein neues Speichersystem für sehr große Cloud-Computing-Rechenzentren.  Grundsätzlich besteht die Idee darin, dass viele Unternehmen Computer von ihren Büros oder ihren eigenen Rechenzentren in diese großen Cloud-Computing-Rechenzentren übertragen, in denen sie Zehntausende von Kunden mit all ihren Informationen an einem Ort haben.  Aus diesem Grund entwickeln wir ein neues Speichersystem für diese großen Rechenzentren. “ <br><br>  <i>Dave Wright, CEO von SolidFire, 2012</i> </blockquote>  In letzter Zeit gibt es immer mehr Lösungen, die vom traditionellen Ansatz einheitlicher Speicher, mit denen Probleme gelöst werden können, zu spezialisierten Speichern übergehen, die zur Lösung von Problemen eines bestimmten Geschäftsbereichs entwickelt wurden. <br><br>  Vor nicht allzu langer Zeit habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich bereits über das Infinidat InfiniBox F2230-System gesprochen</a> , das sich perfekt für die Aufgaben von Dienstleistern eignet.  Der heutige Teilnehmer an unserem SolidFire-Test kann auch dieser Geräteklasse zugeordnet werden.  Der Gründer von SolidFire, Dave Wright, und sein Team stammen von RackSpace, wo sie ein effizientes Speichersystem entwickelten, das in einer Umgebung mit vielen Benutzern eine lineare Leistung bietet, das einfach, leicht skalierbar und mit flexiblen Automatisierungsfunktionen ausgestattet ist.  Um dieses Problem zu lösen, wurde SolidFire geboren. <br><br>  Bisher besteht die SolidFire-Reihe aus vier Modellen mit unterschiedlichen IOPS / TB-Verhältnissen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tw/dx/is/twdxis3ff2_j47g5thl3s9klwb0.jpeg"></div><br>  10 (MLC) SSDs werden zur Datenspeicherung und Radian RMS-200 als NVRAM verwendet.  Es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stimmt</a> , es gibt bereits Pläne, auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NVDIMM-</a> Module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">umzusteigen</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/am/re/7a/amre7ajob7dd2eircxqkb3ewmps.jpeg"></div><br>  Interessant ist hier, wie SolidFire Daten abruft und speichert.  Wir alle kennen die begrenzten Ressourcen von SSD-Laufwerken. Daher ist es logisch, dass die Komprimierung und Deduplizierung vor der Aufnahme auf SSD im laufenden Betrieb erfolgen sollte.  Wenn SolidFire Daten vom Host empfängt, werden diese in 4K-Blöcke unterteilt. Anschließend wird dieser Block komprimiert und im NVRAM gespeichert.  Dann erfolgt eine synchrone Replikation dieses Blocks im NVRAM auf den "benachbarten" Knoten des Clusters.  Danach empfängt SolidFire den Hash dieses komprimierten Blocks und sucht nach diesem Hashwert in seinem Index der gespeicherten Daten im gesamten Cluster.  Wenn ein Block mit einem solchen Hash bereits vorhanden ist, aktualisiert SolidFire nur seine Metadaten mit einem Link zu diesem Block. Wenn der Block eindeutige Daten enthält, wird er auf die SSD geschrieben, und Metadaten werden auch dafür geschrieben.  Dieser Mechanismus zum Speichern von Daten und Metadaten ist dem Funktionsmechanismus der Objektspeicherung sehr ähnlich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5g/q1/ag/5gq1agixufujwftmymlmcqz4bka.png"></div>  <i>Unser Testcluster aus vier Knoten</i> <br><br>  Es gab bereits Gerüchte, dass diese Zeile bald aktualisiert wird.  Es ist erwähnenswert, dass der SolidFire-Cluster mit Knoten mit unterschiedlichen „IOPs / TB-Dichten“ arbeiten und Knoten verschiedener Generationen in einem Cluster kombinieren kann.  Erstens macht es die Verwendung dieses Systems hinsichtlich der Hardwareunterstützung vorhersehbarer und erleichtert auch den Übergang von alten zu neuen Knoten, wenn Sie einfach neue hinzufügen und alte in Echtzeit aus dem Cluster löschen (nur darauf warten, dass der Cluster neu erstellt wird), ohne Ausfallzeiten. weil  Es gibt Unterstützung für Scale Out und Scale Back. <br><br>  SolidFire kann als drei Lösungen geliefert werden: <br><br><ul><li>  SolidFire als eigenständiges Produkt auf Basis von Dell / EMC-Servern, </li><li>  als Teil des FlexPod SF auf Cisco-Servern </li><li>  als Teil von NetApp HCI auf seiner Plattform. </li></ul><br>  Wie Sie der Merkmalstabelle entnehmen können, unterstützen Knoten nur die iSCSI-Verbindung, und für die FC-Verbindung gibt es einen separaten Knotentyp - Fabric Interconnect, der wiederum vier Ports für FC-Daten und vier iSCSI-Ports für die Verbindung mit Knoten enthält 64 GB nativer Systemspeicher / Lese-Cache. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zh/8d/2g/zh8d2gkcmii6pa7ucftp4tjhacw.png"></div><br>  Die Merkmalstabelle zeigt auch die Leistung jedes Knotens.  Dies ist einer der Fälle, in denen Sie die Leistung Ihres Speichersystems zum Zeitpunkt des Kaufs kennen.  Diese Leistung ist für jeden Knoten garantiert (mit einem Lastprofil von 4 KB, 80/20). <br><br>  Wenn Sie also einen Cluster von X-Knoten kaufen oder eine vorhandene Lösung erweitern, wissen Sie, wie viel Volumen und welche Leistung Sie am Ende erhalten.  Natürlich können Sie unter bestimmten Bedingungen mehr Leistung von jedem Knoten herausholen, aber dafür wurde diese Lösung nicht entwickelt.  Wenn Sie Millionen von IOPS in 2U auf einem einzigen Volume erhalten möchten, sollten Sie Ihre Aufmerksamkeit besser auf andere Produkte wie AFF lenken.  Die größte Leistung unter SolidFire kann mit einer großen Anzahl von Volumes und Sitzungen erzielt werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zu/nu/-e/zunu-ebo5wy07krqpj76zm6al8m.png"></div>  <i>Schnittstelle Home</i> <br><br>  Die Speicherverwaltung ist ziemlich einfach.  Tatsächlich haben wir zwei Ressourcenpools: Volume und IOPS.  Indem wir einen der Ressourcentypen identifizieren und deren endgültige Anzahl kennen, verstehen wir die anderen Funktionen unseres Systems klar.  Dies macht das Erweitern des Systems wiederum zu einer äußerst einfachen Aufgabe.  Benötigen Sie mehr Leistung?  Betrachten Sie SF4805 oder SF19210 mit einem „weniger dichten“ IOPS / TB-Verhältnis.  Benötigen Sie Volumen?  Wir schauen auf SF9605 und SF38410, die weniger IOPS auf Gb bieten. <br><br>  Aus Sicht des Speicheradministrators sieht das System ziemlich langweilig aus.  Dinge wie Deduplizierung und Komprimierung funktionieren standardmäßig. <br><br>  Replikation und Snapshots sind ebenfalls verfügbar, und die Replikation kann für die gesamte Palette der NetApp-Produkte (mit Ausnahme der E-Serie) organisiert werden.  Es ist diese Einfachheit, die meiner Meinung nach hinter dem Zitat von Dave Heats aus dem Titel des Artikels offenbart wird.  Angesichts der Tatsache, dass dieses System die Integration in verschiedene Systeme zur dynamischen Zuweisung von Ressourcen ohne Beteiligung eines Administrators und ohne zusätzliche Arbeitskosten umfasst, werden Sie in der Regel bald vergessen, wie die SolidFire-Oberfläche aussieht.  Wir werden jedoch mehr über Integration sprechen. <br><br>  Wir bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Onlanta haben</a> Stresstests durchgeführt, um sicherzustellen, dass die versprochenen 200.000 IOPS eingehalten werden.  Nicht, dass wir dem Verkäufer nicht glauben, aber wir sind es gewohnt, alles selbst auszuprobieren.  Wir haben uns nicht das Ziel gesetzt, mehr als angegeben aus dem System herauszudrücken.  Wir konnten auch aus eigener Erfahrung überprüfen, dass das System mit einer großen Anzahl von Flüssen genau ein gutes Ergebnis liefert.  Zu diesem Zweck haben wir 10 Volumes mit 1 TB in SolidFire organisiert, auf denen wir eine virtuelle Testmaschine platziert haben.  Bereits in der Phase der Vorbereitung der Testumgebung waren wir von der Deduplizierungsarbeit angenehm überrascht.  Trotz der Tatsache, dass das Schema seiner Arbeit ziemlich Standard ist, erwies sich die Qualität der Arbeit innerhalb des Clusters als äußerst effektiv.  Die Scheiben vor den Tests wurden mit zufälligen Daten gefüllt. <br><br>  Um es schneller zu machen, haben wir einen Block von 10 MB generiert, dann haben sie ihn gefüllt.  Darüber hinaus wurde dieser Block auf jeder virtuellen Maschine separat erzeugt, d.h.  Bei allen Autos ist das Muster unterschiedlich.  Von 10 TB, die mit Daten gefüllt waren, betrug der tatsächlich belegte Speicherplatz auf dem Array 4 TB.  Die Deduplizierungseffizienz beträgt 1: 2,5, bei FAS mit diesem Ansatz tendierte die Inline-Deduplizierungseffizienz zu 0. Wir konnten 190.000 IOPS mit einer Antwort von ~ 1 ms auf unserem Prüfstand erzielen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/o8/58/nvo8582cdpomfyx7dozgmw7bhem.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t8/4y/nl/t84ynlfmfw3hmmokdwoszehtp7i.png"></div><br>  Ich möchte darauf hinweisen, dass die architektonischen Merkmale der Lösung es nicht ermöglichen, ein hohes Leistungsniveau für eine kleine Anzahl von Threads zu erzielen.  Ein kleiner Mond oder nur eine virtuelle Testmaschine kann keine hohen Ergebnisse zeigen.  Wir konnten diese Menge an IOPS erhalten, indem wir die gesamte Kapazität des Systems nutzten und die Anzahl der virtuellen Maschinen, die mit fio eine Last erzeugen, schrittweise zunahmen.  Wir haben ihre Anzahl erhöht, bis die Verzögerungen 1,5 ms nicht überschritten haben. Danach haben wir angehalten und die Leistungsindikatoren entfernt. <br><br>  Die Fülle des Festplattensubsystems wirkt sich auch auf die Leistung aus.  Wie ich bereits sagte, haben wir vor dem Ausführen der Tests die Datenträger mit zufälligen Daten gefüllt.  Wenn Sie den Test ausführen, ohne zuerst die Festplatten zu füllen, ist die Leistung bei gleicher Verzögerung viel höher. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/pj/5w/ghpj5wytdsiicetdjjyjjn3w9sk.jpeg"></div><br>  Wir haben auch unseren bevorzugten Fehlertoleranztest durchgeführt, indem wir einen der Knoten ausgeschaltet haben.  Um den besten Effekt zu erzielen, wurde ein Masterknoten zum Deaktivieren ausgewählt.  Aufgrund der Tatsache, dass jeder Client-Server beim Trennen eines der Knoten eine eigene Sitzung mit dem Clusterknoten erstellt und nicht über einen einzelnen Punkt, werden nicht alle virtuellen Maschinen beeinträchtigt, sondern nur diejenigen, die mit diesem Knoten gearbeitet haben.  Dementsprechend sehen wir von der Seite des Speichers nur einen teilweisen Leistungsabfall. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sa/qo/lt/saqoltogypq8tebvbthq4dlsv8m.png"></div><br>  Bei Virtualisierungshosts lag der Leistungsabfall in einigen Datenspeichern natürlich bei bis zu 0. Innerhalb von 30 Sekunden wurde die Leistung jedoch ohne Leistungseinbußen wiederhergestellt (es sollte berücksichtigt werden, dass die Last zum Zeitpunkt des Abfalls bei 120.000 iops lag, die drei möglicherweise erzeugen könnten Von vier Knoten hätten wir keinen Leistungsverlust sehen dürfen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gt/rg/p_/gtrgp_xy7_wwe5dfd3jrees-kya.png"></div>  <i>Auf der SolidFire-Seite begann der Wiederaufbau des Arrays.</i>  <i>Der Timer lügt ein wenig und der Vorgang dauerte ungefähr 55 Minuten, was in die vom Verkäufer versprochene Stunde passt.</i>  <i>Gleichzeitig entfernte niemand die Last aus dem Speichersystem und sie blieb auf dem gleichen Niveau von 120.000 IOPS.</i> <br><br>  Fehlertoleranz wird nicht nur auf Plattenebene, sondern auch auf Knotenebene bereitgestellt.  Der Cluster unterstützt den gleichzeitigen Ausfall eines Knotens. Danach wird der Cluster-Wiederherstellungsprozess gestartet.  In Anbetracht der Verwendung von SSD und der Tatsache, dass alle Knoten an der Neuerstellung beteiligt sind, dauert die Clusterwiederherstellung etwa eine Stunde (die Neuerstellung bei einem Festplattenfehler dauert etwa 10 Minuten).  Es sollte beachtet werden, dass Sie bei einem Ausfall eines Knotens sowohl an Leistung als auch an nutzbarem Speicherplatz verlieren.  Dementsprechend müssen Sie immer freien Speicherplatz in Höhe eines Knotens haben.  Die minimale Clustergröße beträgt vier Knoten.  Mit dieser Konfiguration können Sie Probleme vermeiden, wenn einer der Knoten ausfällt, bevor Sie auf das Eintreffen des Ersatzes warten. <br><br>  Wie bei den meisten Speichersystemen wird die Leistungsüberwachung hier nur in Echtzeit angezeigt.  Um auf historische Daten zugreifen zu können, müssen Sie den sogenannten Verwaltungsknoten bereitstellen, der API-Daten aus SolidFire entnimmt und in Active IQ hochlädt.  Wenn Sie bereits mit NetApp-Systemen gearbeitet haben, sind Sie möglicherweise bereits auf dieses Portal gestoßen.  Sie haben die Möglichkeit, mit Daten zu Produktivität, Effizienz und Wachstumsprognosen zu arbeiten.  Zu welchem ​​Zeitpunkt können Sie auf diese Daten auch von Ihrem mobilen Gerät aus zugreifen, überall auf der Welt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vx/ah/ky/vxahkyzk1s86_uscokgqhsr5mou.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vs/ar/oi/vsaroie8co62wjlikgnqdka4rxs.jpeg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/4d/qo/nv4dqovbteuzgyej4arsx3hvvjk.jpeg"></div><br><br>  Da ich die Arbeit der Inline-Deduplizierung erwähnt habe, werde ich auch auf die Speichereffizienz im Allgemeinen eingehen.  Wie bei der AFF-Serie bietet NetApp ein garantiertes Speichereffizienzverhältnis basierend auf der Art der gespeicherten Daten. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/6u/tr/g66utrdwhzdindk54xh_lcs-lis.jpeg"></div><br>  Wie Sie sehen können, unterscheiden sich die Datentypen und garantierten Koeffizienten geringfügig.  Zum Beispiel hat SolidFire genau unseren Fall - Virtuelle Infrastruktur mit einem Koeffizienten von 4: 1.  Dabei wird die Verwendung von Schnappschüssen nicht berücksichtigt. <br><br>  Die Architektur der Lösung basiert auf Quality of Service (QoS), die tatsächlich eine garantierte Leistung für jedes Volume gewährleistet. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/kw/8y/x7/kw8yx7kxycyax6xk14s2jwcwz7e.png"></a> </div><br>  QoS ist eine der entscheidenden Funktionen für Dienstanbieter und andere Unternehmen, die eine garantierte Speicherleistung bereitstellen müssen.  Jemand wird sagen, dass QoS nichts Neues ist und von vielen anderen Anbietern implementiert wird.  Eine andere Frage ist, wie es funktioniert.  Wenn es bei herkömmlichem Speicher wahrscheinlicher ist, Prioritäten zu setzen und die Geschwindigkeit zu begrenzen, verwendet SolidFire wiederum einen integrierten Ansatz, um eine garantierte Leistung zu erzielen. <br><br><ul><li>  Durch die Verwendung einer All-SSD können Sie eine geringe Latenz für E / A erzielen. </li><li>  Scale-out sagt Leistungsmetriken leicht voraus. </li><li>  Mangel an klassischem RAID - vorhersehbare Leistung mit </li><li>  Hardwarefehler </li><li>  Eine ausgewogene Lastverteilung beseitigt Engpässe im System. </li><li>  QoS hilft, "laute Nachbarn" zu vermeiden. </li></ul><br>  Zusätzlich zu der Möglichkeit, die maximale und minimale Leistung festzulegen, ist es möglich, diese Leistung über die maximale Grenze (Burst) hinaus bereitzustellen.  Jeder Band hat ein bestimmtes bedingtes Kreditsystem.  Wenn seine Produktivität unter der Höchstgrenze liegt, werden ihm diese Kredite gutgeschrieben, dank derer er für einen bestimmten Zeitraum die Höchstgrenze der Produktivität überwinden kann.  Mit diesem Ansatz können Sie eine große Anzahl von Anwendungen, die eine hohe Leistung erfordern, im Speicher platzieren und gleichzeitig vor negativen Auswirkungen auf einander schützen.  Das Interessanteste ist, dass QoS nicht nur auf der Volume-Ebene des Arrays unterstützt wird, sondern auch auf der Ebene der VMware VVs, wodurch eine granulare Zuweisung von Ressourcen für jede virtuelle Maschine ermöglicht wird.  Die vollständige Unterstützung von VAAI und der VASA-API ermöglicht eine enge Array-Integration mit dem Virtualizer. <br><br>  Apropos Integration: Die Lösung von VMware ist noch lange nicht vorbei. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4d/vg/zk/4dvgzk7qrxiv7eq2pzer-l9qfqo.png"></div><br>  Vielleicht kann SolidFire als das am meisten automatisierte Speichersystem bezeichnet werden, das in alle modernen Systeme, Virtualisierungs- / Containerisierungssysteme integriert werden kann, Konfigurationsmanagementsysteme unterstützt und SDK für verschiedene Sprachen verfügbar ist. <br><br>  Ich schaue wie immer auf das erste, was das SDK für Python ist, mit dem ich meine eigenen Workflows automatisiere.  Daher müssen wir 15 Volumes mit 1 TB erstellen und iqn an der Ausgabe abrufen, die wir an VMware-Administratoren weitergeben, um Datenspeicher hinzuzufügen.  Wir haben bereits vorab erstellte Zugriffsgruppen, in denen unsere VMware-Hosts und vorab erstellten QoS-Richtlinien registriert sind. <br><br><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env python # -*- coding:utf-8 -*- from solidfire.factory import ElementFactory sfe = ElementFactory.create('ip', 'log', 'pass') for i in range(1,51): create_volume_result = sfe.create_volume(name='vol'+str(i), account_id=2, total_size=1099511627776, enable512e=True, qos_policy_id=1) id = create_volume_result.volume_id sfe.add_volumes_to_volume_access_group(volume_access_group_id=2, volumes=[id]) volumes = sfe.list_volumes(accounts=[2], limit=100).volumes for volume in volumes: print volume.iqn</span></span></code> </pre> <br>  Oder hier ist ein detaillierteres Python SDK-Demo-Video von SolidFire selbst: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3g028LYmiN4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dieser Ansatz zur Automatisierung macht SolidFire nicht nur für Cloud-Anbieter und ähnliche Aufgaben praktisch, sondern ermöglicht es Ihnen auch, gemäß dem Konzept der kontinuierlichen Integration und Bereitstellung (CI / CD) den Entwicklungsprozess zu optimieren. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/webt/nx/f4/pq/nxf4pq2mndlhfm4uaqdz0tqvapk.png"></a> </div>  <i>Wie bereits erwähnt, funktioniert die WebUI über die API, und Sie können alle Anforderungen und Antworten über das API-Protokoll anzeigen.</i> <br><br>  Wenn Sie mehr über SolidFire, den Vergleich mit Mitbewerbern, die Arbeit mit dem System usw. erfahren möchten, empfehle ich den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">YouTube-Kanal</a> , der eine relativ große Anzahl nützlicher Videos enthält, von nützlich.  Zum Beispiel der Zyklus „Vergleich moderner All-Flash-Architekturen“. <br><br>  Zu den netten Funktionen des Systems gehört der integrierte Mechanismus zum Sichern von Snapshots in einem externen S3-kompatiblen Speicher.  Auf diese Weise können Sie Snapshots als Backups verwenden und diese in externen Repositorys sowohl auf Ihrer Site als auch auf externen Ressourcen, beispielsweise in Amazon, speichern.  Natürlich kann dieser Ansatz unter dem Gesichtspunkt der Datenwiederherstellung kaum als flexibel bezeichnet werden, aber in einigen Fällen kann diese Lösung nützlich und durchaus anwendbar sein.  Es gibt noch einen weiteren interessanten Punkt: Sie können Daten auf zwei Arten in den S3-Speicher hochladen: <br><br><ul><li>  Native - In diesem Fall werden bereits deduplizierte Daten gegossen. Gleichzeitig kann dieses Volume jedoch nur auf demselben System wiederhergestellt werden, mit dem es gegossen wird. </li><li>  Unkomprimiert - Hier ist bereits ein vollständiger Satz von Blöcken eingefüllt, mit denen Sie diesen Mond in jedem anderen SolidFire-Cluster wiederherstellen können. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/l7/hy/ts/l7hytspq7ikcr9ffduitsl7yw9q.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ve/mk/z-/vemkz-ngzlo2kgatvlc22nsrjxk.png"></div><br>  Im Allgemeinen waren wir mit unserer Kommunikation mit SolidFire mehr als zufrieden.  Wir haben die versprochene Leistung erhalten, die Inline-Deduplizierungsarbeit ist nicht zu loben, auch die Integrations- und Automatisierungsfunktionen haben einen äußerst positiven Eindruck hinterlassen.  Der Einfluss des Ausfalls der Knoten oder vielmehr seine minimale Auswirkung auf die Leistung des Gesamtsystems, die Lastverteilung und das Fehlen eines einzelnen Fehlerpunkts, der die Leistung stark beeinträchtigen könnte, machen dieses System äußerst attraktiv.  Trotz der Tatsache, dass der Cluster nur mit iSCSI arbeiten kann, macht das Vorhandensein des FC-Transportknotens dieses System universeller. <br><br>  Ich möchte Jewgeni Krasikow von NetApp und Arthur Alikulow von Merlion bei den Tests meinen besonderen Dank aussprechen.  Übrigens, Arthur, hat einen wunderbaren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telegrammkanal</a> für alle, die über Neuigkeiten aus der Speicherrichtung und insbesondere von NetApp auf dem Laufenden bleiben möchten.  Sie können eine große Menge nützlicher Materialien darin finden, und wer nur lesen muss, aber auch reden möchte, es gibt auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chat-Diskussionen</a> . <br><br>  Wenn Sie noch Fragen haben oder plötzlich neue auftauchen, lade ich Sie ein, NetApp Directions 2018 zu besuchen, die am 17. Juli 2018 im Hyatt Regency Petrovsky Park stattfinden wird, wo Arthur und ich bei einer der Sitzungen über SolidFire sprechen werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anmeldung zur Veranstaltung</a> und alle Details. <br><br><div class="spoiler">  <b class="spoiler_title">Und in unserer Firma gibt es eine freie Stelle.</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teamleiter</a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415967/">https://habr.com/ru/post/de415967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415957/index.html">Wir brauchen mehr Rucksäcke: Bobby XL von XD Design</a></li>
<li><a href="../de415959/index.html">Wie wir den Netzwerkcode des mobilen PvP-Shooters geschrieben haben: Player-Synchronisation auf dem Client</a></li>
<li><a href="../de415961/index.html">Russischer verteilter Speicher. Wie es funktioniert</a></li>
<li><a href="../de415963/index.html">Naive Bayes oder wie Sie mit Mathematik Spam filtern können</a></li>
<li><a href="../de415965/index.html">Was im Juli zu lesen ist: 19 neue Bücher für Digitalprofis</a></li>
<li><a href="../de415969/index.html">HyperX Pulsefire Surge RGB - ein natürlich geborener Killer</a></li>
<li><a href="../de415973/index.html">So brechen Sie den Apache Ignite-Cluster nicht von Anfang an</a></li>
<li><a href="../de415975/index.html">Die Chinesen führten eine Laserpistole mit einer Reichweite von fast einem Kilometer ein</a></li>
<li><a href="../de415977/index.html">DPI-resistente Tunnel und VPNs</a></li>
<li><a href="../de415979/index.html">Sicherheitswoche 24: Rowhammer unter Android und die Komplexität von Hardware-Schwachstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>