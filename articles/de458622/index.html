<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöº üêâ üë©‚Äçüî¨ Automatisierung f√ºr die Kleinsten. Teil eins (der nach Null liegt). Netzwerkvirtualisierung üë©‚Äçüé® üç≤ üÜó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der vorherigen Version habe ich das Framework f√ºr die Netzwerkautomatisierung beschrieben. Nach Einsch√§tzung einiger Leute hat bereits diese erste ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisierung f√ºr die Kleinsten. Teil eins (der nach Null liegt). Netzwerkvirtualisierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458622/">  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Version habe</a> ich das Framework f√ºr die Netzwerkautomatisierung beschrieben.  Nach Einsch√§tzung einiger Leute hat bereits diese erste Herangehensweise an das Problem bereits einige Fragen in die Regale gestellt.  Und das freut mich sehr, denn unser Ziel im Zyklus ist es nicht, das Ansible mit Python-Skripten abzudecken, sondern ein System aufzubauen. <br><br>  Der gleiche Rahmen legt die Reihenfolge fest, in der wir uns mit der Frage befassen. <br>  Und die Netzwerkvirtualisierung, der dieses Problem gewidmet ist, passt nicht wirklich in das ADSM-Thema, in dem wir die Automatisierung analysieren. <br><br>  Aber schauen wir es uns aus einem anderen Blickwinkel an. <br><br>  Schon lange nutzen viele Dienste ein Netzwerk.  Bei einem Netzbetreiber handelt es sich beispielsweise um 2G, 3G, LTE, Breitband und B2B.  Im Fall von DC: Konnektivit√§t f√ºr verschiedene Clients, Internet, Blockspeicher, Objektspeicher. <br><br>  Und alle Dienste m√ºssen voneinander isoliert sein.  Es erschienen also Overlay-Netzwerke. <br><br>  Und alle Dienste m√∂chten nicht darauf warten, dass eine Person sie manuell konfiguriert.  So erschienen Orchestratoren und SDN. <br><br>  Der erste Ansatz zur systematischen Automatisierung des Netzwerks oder vielmehr von Teilen davon wurde lange Zeit verfolgt und an vielen Stellen implementiert: VMWare, OpenStack, Google Compute Cloud, AWS, Facebook. <br><br>  Hier besch√§ftigen wir uns heute mit ihm. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b14/278/742/b142787424b1da02432df0291faaca95.jpg" width="800"></a> <br><a name="habracut"></a><br><h1>  Inhalt </h1><br><ul><li>  <b>Gr√ºnde</b> </li><li>  <b>Terminologie</b> </li><li>  <b>Unterlage - Physikalisches Netzwerk</b> </li><li>  <b>Overlay - virtuelles Netzwerk</b> <br><br><ul><li>  √úberlagerung mit ToR </li><li>  √úberlagerung vom Host </li><li>  Fallstudie Wolframgewebe <br><br><ul><li>  Kommunikation innerhalb einer physischen Maschine </li><li>  Kommunikation zwischen VMs auf verschiedenen physischen Computern </li><li>  Gehe nach au√üen </li></ul><br></li></ul><br></li><li>  <b>FAQ</b> </li><li>  <b>Fazit</b> </li><li>  <b>N√ºtzliche Links</b> </li></ul><br><hr><br><br><h1>  Gr√ºnde </h1><br>  Und da wir dar√ºber gesprochen haben, sollten die Voraussetzungen f√ºr die Netzwerkvirtualisierung erw√§hnt werden.  Tats√§chlich hat dieser Prozess gestern nicht begonnen. <br><br>  Sie haben wahrscheinlich mehr als einmal geh√∂rt, dass das Netzwerk immer der inerteste Teil eines Systems war.  Und das ist in jeder Hinsicht wahr.  Ein Netzwerk ist die Basis, auf der alles basiert, und es ist ziemlich schwierig, √Ñnderungen daran vorzunehmen - Dienste tolerieren es nicht, wenn das Netzwerk liegt.  Die Au√üerbetriebnahme eines einzelnen Knotens kann h√§ufig die meisten Anwendungen summieren und viele Clients betreffen.  Dies ist teilweise der Grund, warum das Netzwerkteam √Ñnderungen widerstehen kann - denn jetzt funktioniert es irgendwie ( <i>wir wissen vielleicht nicht einmal wie</i> ), aber hier m√ºssen wir etwas Neues konfigurieren, und es ist nicht bekannt, wie sich dies auf das Netzwerk auswirkt. <br><br>  Um nicht darauf zu warten, dass Netzwerkanbieter VLANs weiterleiten und keine Dienste auf jedem Netzwerkknoten registrieren, haben sich die Benutzer f√ºr Overlays entschieden - √ºberlagerte Netzwerke - von denen es eine gro√üe Vielfalt gibt: GRE, IPinIP, MPLS, MPLS L2 / L3VPN, VXLAN, GENEVE, MPLSoverUDP, MPLSoverGRE usw. <br><br>  Ihre Anziehungskraft liegt in zwei einfachen Dingen: <br><br><ul><li>  Es werden nur Endknoten konfiguriert - Sie m√ºssen keine Transitknoten ber√ºhren.  Dies beschleunigt den Prozess erheblich und erm√∂glicht es Ihnen manchmal sogar, die Netzwerkinfrastrukturabteilung von der Einf√ºhrung neuer Dienste auszuschlie√üen. </li><li>  Die Last ist tief in den Headern versteckt - Transitknoten m√ºssen nichts dar√ºber wissen, √ºber die Adressierung auf Hosts, Routen des auferlegten Netzwerks.  Dies bedeutet, dass Sie weniger Informationen in den Tabellen speichern m√ºssen. Nehmen Sie also ein einfacheres / billigeres Ger√§t. </li></ul><br>  In dieser nicht ganz vollst√§ndigen Ausgabe habe ich nicht vor, alle m√∂glichen Technologien zu analysieren, sondern den Rahmen f√ºr den Betrieb von Overlay-Netzwerken in DCs zu beschreiben. <br><br>  Die gesamte Serie beschreibt ein Rechenzentrum, das aus Reihen √§hnlicher Racks besteht, in denen dieselbe Serverausr√ºstung installiert ist. <br><br>  Auf diesem Ger√§t werden virtuelle Maschinen / Container / Serverless ausgef√ºhrt, die Dienste implementieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f03/525/54b/f0352554b58d82955bd7c08f3034cd4f.jpg" width="600" title="Dataline nord dc"><br><br><hr><br><br><h1>  Terminologie </h1><br>  In der Schleife werde ich den <b>Server als</b> Programm bezeichnen, das die Serverseite der Client-Server-Kommunikation implementiert. <br><br>  Physische Maschinen in Racks werden <b>nicht</b> als Server bezeichnet. <br><br>  <b>Die physische Maschine</b> ist ein x86-Rack-Computer.  Am h√§ufigsten verwenden wir den Begriff <b>Host</b> .  Also werden wir es " <b>Maschine</b> " oder <b>Host nennen</b> . <br><br>  <b>Ein Hypervisor</b> ist eine Anwendung, die auf einem physischen Computer ausgef√ºhrt wird und die physischen Ressourcen emuliert, auf denen virtuelle Maschinen ausgef√ºhrt werden.  Manchmal wird in der Literatur und im Netzwerk das Wort "Hypervisor" als Synonym f√ºr "Host" verwendet. <br><br>  <b>Eine virtuelle Maschine</b> ist ein Betriebssystem, das auf einer physischen Maschine √ºber einem Hypervisor ausgef√ºhrt wird.  F√ºr uns ist es im Rahmen dieses Zyklus nicht so wichtig, ob es sich tats√§chlich um eine virtuelle Maschine oder nur um einen Container handelt.  Wir werden es " <b>VM</b> " nennen <br><br>  <b>Mandant</b> ist ein umfassendes Konzept, das ich in diesem Artikel als separaten Service oder separaten Client definieren werde. <br><br>  <b>Mandantenf√§higkeit</b> oder Mandantenf√§higkeit - die Verwendung derselben Anwendung durch verschiedene Clients / Dienste.  Gleichzeitig wird durch die Architektur der Anwendung und nicht durch separat ausgef√ºhrte Instanzen eine Isolierung der Clients voneinander erreicht. <br><br>  <b>ToR - Top of the Rack-Switch</b> - Ein am Rack montierter Switch, an den alle physischen Maschinen angeschlossen sind. <br><blockquote>  Zus√§tzlich zur ToR-Topologie praktizieren verschiedene Anbieter End of Row (EoR) oder Middle of Row (obwohl letzteres eine abweisende Seltenheit ist und ich die Abk√ºrzungen MoR nicht gesehen habe). <br></blockquote>  <b>Underlay-Netzwerk</b> oder zugrunde liegendes Netzwerk oder Underlay - physische Netzwerkinfrastruktur: Switches, Router, Kabel. <br><br>  <b>Overlay-Netzwerk</b> oder Overlay-Netzwerk oder Overlay - ein virtuelles Netzwerk von Tunneln, das √ºber einem physischen Netzwerk ausgef√ºhrt wird. <br><br>  <b>L3-Factory oder IP-Factory</b> ist eine enorme Erfindung der Menschheit, die es Interviews erm√∂glicht, STP nicht zu wiederholen und TRILL nicht zu lernen.  Ein Konzept, bei dem das gesamte Netzwerk bis zur Zugriffsebene ausschlie√ülich L3 ist, ohne VLANs und entsprechend gro√üe gestreckte Broadcast-Dom√§nen.  Woher kommt das Wort "Fabrik" im n√§chsten Teil? <br><br>  <b>SDN</b> - Software Defined Network.  Braucht kaum eine Einf√ºhrung.  Ein Ansatz zur Netzwerkverwaltung, wenn √Ñnderungen am Netzwerk nicht von einer Person, sondern von einem Programm durchgef√ºhrt werden.  Normalerweise bedeutet dies, dass die Steuerebene √ºber die Endnetzwerkger√§te hinaus zur Steuerung verschoben wird. <br><br>  <b>NFV</b> - Network Function Virtualization - Virtualisierung von Netzwerkger√§ten, bei der davon ausgegangen wird, dass ein Teil der Netzwerkfunktionen in Form von virtuellen Maschinen oder Containern gestartet werden kann, um die Implementierung neuer Dienste zu beschleunigen, die Verkettung von Diensten zu organisieren und die horizontale Skalierbarkeit zu vereinfachen. <br><br>  <b>VNF</b> - Virtuelle Netzwerkfunktion.  Spezifisches virtuelles Ger√§t: Router, Switch, Firewall, NAT, IPS / IDS usw. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca9/501/33c/ca950133ca98bd1e2ca613342432c535.png" width="700"><br><blockquote>  Ich vereinfache jetzt absichtlich die Beschreibung auf eine bestimmte Implementierung, um den Leser nicht viel zu verwirren.  F√ºr eine gr√ºndlichere Lekt√ºre senden Sie es an den Abschnitt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Links</a> .  Dar√ºber hinaus verspricht Roma Gorge, der diesen Artikel wegen Ungenauigkeiten kritisiert, ein separates Problem zu Server- und Netzwerkvirtualisierungstechnologien zu schreiben, das sich eingehender und detaillierter mit Details befasst. </blockquote><br><hr><br>  Die meisten Netzwerke k√∂nnen heute klar in zwei Teile unterteilt werden: <br><br>  <b>Unterlage</b> - ein physisches Netzwerk mit einer stabilen Konfiguration. <br>  <b>√úberlagerung</b> - Abstraktion √ºber Unterlage, um Mieter zu isolieren. <br><br>  Dies gilt sowohl f√ºr den Fall von DC (den wir in diesem Artikel analysieren werden) als auch f√ºr ISP (den wir nicht analysieren werden, da er bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SDSM enthalten war</a> ).  Bei Unternehmensnetzwerken ist die Situation nat√ºrlich etwas anders. <br><br>  Netzwerkfokus Bild: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/133/b41/5f8/133b415f8b32264e2fa877f4a4139267.png" width="800"><br><br><hr><br><br><h1>  Unterlage </h1><br>  Unterlage ist ein physisches Netzwerk: Hardware-Switches und Kabel.  Ger√§te in der Unterlage wissen, wie sie zu physischen Maschinen gelangen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/117/d04/880/117d04880232fa2c00ef303cf5f059a0.png" width="800"><br><br>  Es basiert auf Standardprotokollen und -technologien.  Nicht zuletzt, weil die Hardwareger√§te immer noch mit propriet√§rer Software arbeiten, die weder die Chipprogrammierung noch die Implementierung ihrer Protokolle erm√∂glicht, sind Kompatibilit√§t mit anderen Anbietern und Standardisierung erforderlich. <br><blockquote>  Aber jemand wie Google kann es sich leisten, eigene Switches zu entwickeln und die allgemein akzeptierten Protokolle aufzugeben.  LAN_DC ist jedoch nicht Google. <br></blockquote>  Die Unterlage wird relativ selten ge√§ndert, da ihre Aufgabe die grundlegende IP-Konnektivit√§t zwischen physischen Maschinen ist.  Underlay wei√ü nichts √ºber darauf laufende Services, Clients, Mandanten - es muss nur ein Paket von einem Computer auf einen anderen geliefert werden. <br>  Die Unterlage kann folgenderma√üen aussehen: <br><br><ul><li>  IPv4 + OSPF </li><li>  IPv6 + ISIS + BGP + L3VPN </li><li>  L2 + TRILL </li><li>  L2 + STP </li></ul><br>  Das Underlay-Netzwerk wird auf klassische Weise konfiguriert: CLI / GUI / NETCONF. <br><br>  Manuell Skripte, propriet√§re Dienstprogramme. <br><br>  Im Detail wird der n√§chste Artikel der Reihe der Unterlage gewidmet sein. <br><br><hr><br><h1>  √úberlagerung </h1><br>  Overlay - Ein virtuelles Tunnelnetzwerk, das sich √ºber Underlay erstreckt und es den VMs eines Clients erm√∂glicht, miteinander zu kommunizieren und gleichzeitig von anderen Clients isoliert zu sein. <br><br>  Clientdaten werden in beliebigen Tunnel-Headern zur √úbertragung √ºber ein gemeinsam genutztes Netzwerk gekapselt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c1/3ed/8d2/9c13ed8d2e6cec8f1b9fe500660f1c47.png" width="800"><br><br>  So k√∂nnen die VMs eines Clients (eines Dienstes) √ºber Overlay miteinander kommunizieren, ohne zu wissen, was das Paket tats√§chlich enth√§lt. <br><br>  Die √úberlagerung kann beispielsweise dieselbe sein wie oben erw√§hnt: <br><br><ul><li>  GRE-Tunnel </li><li>  VXLAN </li><li>  EVPN </li><li>  L3VPN </li><li>  GENF </li></ul><br>  Ein Overlay-Netzwerk wird normalerweise √ºber eine zentrale Steuerung konfiguriert und verwaltet.  Daraus werden die Konfiguration, die Steuerebene und die Datenebene an Ger√§te geliefert, die den Clientverkehr weiterleiten und kapseln.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im Folgenden werden</a> wir dies anhand von Beispielen analysieren. <br><br>  <b>Ja, das ist reines SDN.</b> <br><br>  Es gibt zwei grundlegend unterschiedliche Ans√§tze zum Organisieren eines Overlay-Netzwerks: <br><br><ol><li>  √úberlagerung mit ToR </li><li>  √úberlagerung vom Host </li></ol><br><br><h2>  √úberlagerung mit ToR </h2><br>  Die √úberlagerung kann bei einem am Rack montierten Zugriffsschalter (ToR) beginnen, wie dies beispielsweise bei einer VXLAN-Factory der Fall ist. <br><br>  Dies ist ein bew√§hrter Mechanismus in ISP-Netzwerken, den alle Anbieter von Netzwerkger√§ten unterst√ºtzen. <br><br>  In diesem Fall muss der ToR-Switch jedoch jeweils unterschiedliche Dienste gemeinsam nutzen k√∂nnen, und der Netzwerkadministrator muss in gewissem Umfang mit den Administratoren virtueller Maschinen zusammenarbeiten und √Ñnderungen (wenn auch automatisch) an der Ger√§tekonfiguration vornehmen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e3/0a1/87d/5e30a187dd5796e2a4232cb4e9db0b97.png" width="600"><br><br>  Hier verweise ich den Leser auf einen Artikel √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VxLAN im Hub</a> unseres alten Freundes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">@bormoglotx</a> . <br>  In dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation mit ENOG</a> werden Ans√§tze zum Aufbau eines DC-Netzwerks mit einer EVPN VXLAN-Factory ausf√ºhrlich beschrieben. <br><br>  Und f√ºr ein vollst√§ndigeres Eintauchen in die Realit√§t k√∂nnen Sie das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">A Modern, Open and Scalable Fabric: VXLAN EVPN lesen</a> . <br><blockquote>  Ich stelle fest, dass VXLAN nur eine Kapselungsmethode ist und die Tunnelbeendigung nicht auf ToR, sondern auf dem Host erfolgen kann, wie dies beispielsweise bei OpenStack der Fall ist. <br><br>  Die VXLAN-Factory, in der Overlay auf ToR beginnt, ist jedoch eines der etablierten Overlay-Netzwerkdesigns. <br></blockquote><br><h2>  √úberlagerung vom Host </h2><br>  Ein anderer Ansatz besteht darin, Tunnel auf den Endhosts zu starten und zu beenden. <br>  In diesem Fall bleibt das Netzwerk (Underlay) so einfach und statisch wie m√∂glich. <br>  Und der Host selbst f√ºhrt alle erforderlichen Kapselungen durch. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d7/400/c60/5d7400c60036ba0b6666bb0f733c172f.png" width="600"><br><br>  Dazu m√ºssen Sie sicherlich eine spezielle Anwendung auf den Hosts ausf√ºhren, aber es lohnt sich. <br><br>  Erstens ist das Ausf√ºhren eines Clients auf einem Linux-Computer einfacher oder, sagen wir, allgemein m√∂glich, w√§hrend Sie sich auf dem Switch befinden, m√ºssen Sie sich h√∂chstwahrscheinlich vorerst an propriet√§re SDN-L√∂sungen wenden, was die Idee eines Multi-Anbieters zunichte macht. <br><br>  Zweitens kann der ToR-Schalter in diesem Fall sowohl aus Sicht der Steuerebene als auch der Datenebene so einfach wie m√∂glich belassen werden.  In der Tat - dann muss er nicht mit dem SDN-Controller kommunizieren und die Netzwerke / ARPs aller verbundenen Clients speichern - kennt er auch nur die IP-Adresse der physischen Maschine, was die Switching- / Routing-Tabellen erheblich vereinfacht. <br><br><hr><br>  In der ADSM-Serie w√§hle ich den Overlay-Ansatz vom Host aus - dann sprechen wir nur dar√ºber und werden nicht zur VXLAN-Factory zur√ºckkehren. <br><br><hr><br>  Der einfachste Weg, um die Beispiele zu betrachten.  Als Testperson nehmen wir die OpenSource SDN OpenContrail-Plattform, die jetzt als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tungsten Fabric bekannt ist</a> . <br><blockquote>  Am Ende des Artikels werde ich einige Gedanken zur Analogie mit OpenFlow und OpenvSwitch machen. <br></blockquote><br><h2>  Fallstudie Wolframgewebe </h2><br>  Jede physische Maschine verf√ºgt √ºber einen <b>vRouter</b> - einen virtuellen Router, der die mit ihr verbundenen Netzwerke kennt und wei√ü, zu welchen Clients sie geh√∂ren - tats√§chlich ein PE-Router.  F√ºr jeden Client wird eine isolierte Routing-Tabelle verwaltet (VRF lesen).  Und tats√§chlich f√ºhrt vRouter Overlay-Tunneling durch. <br><br>  Ein wenig mehr √ºber vRouter finden Sie am Ende des Artikels. <br><br>  Jede auf dem Hypervisor befindliche VM ist √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">TAP-Schnittstelle</a> mit dem vRouter dieses Computers verbunden. <br><br>  <b>TAP</b> - Terminal Access Point - eine virtuelle Schnittstelle im Linux-Kernel, die die Vernetzung erm√∂glicht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a2/fc4/20f/7a2fc420f086b1588236ddc7d4f1c97e.png" width="500"><br><br>  Befinden sich hinter dem vRouter mehrere Netzwerke, wird f√ºr jedes Netzwerk eine virtuelle Schnittstelle erstellt, der eine IP-Adresse zugewiesen ist. Dies ist die Standard-Gateway-Adresse. <br>  Alle Netzwerke eines Clients werden in einer <b>VRF</b> (einer Tabelle) platziert, unterschiedlich - in unterschiedlich. <br>  <i>Ich werde hier eine Reservierung machen, dass es nicht so einfach ist, und den neugierigen Leser an das Ende des Artikels schicken</i> . <br><br>  Damit vRouter'y miteinander kommunizieren kann und dementsprechend hinter ihnen befindliche VMs, tauschen sie Routing-Informationen √ºber einen <b>SDN-Controller aus</b> . <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/3cd/6c5/c73/3cd6c5c7399e314b779a4b9ecf18e17e.png" width="900"></a> <br><br>  Um in die Au√üenwelt zu gelangen, gibt es einen Austrittspunkt aus der Matrix - das virtuelle Netzwerk-Gateway <b>VNGW</b> - Virtual Network GateWay ( <i>mein Begriff</i> ). <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d8/75f/a55/4d875fa552a4f144fb9338fa0093235c.png" width="900"></a> <br><br><hr><br>  Betrachten Sie nun die Beispiele f√ºr Kommunikation - und es wird Klarheit geben. <br><br><br><h3>  Kommunikation innerhalb einer physischen Maschine </h3><br>  VM0 m√∂chte ein Paket an VM2 senden.  Angenommen, dies ist eine einzelne Client-VM. <br><br><h4>  Datenebene </h4><br><ol><li>  VM-0 hat eine Standardroute in seiner eth0-Schnittstelle.  Das Paket wird dorthin gesendet. <br>  Diese eth0-Schnittstelle ist √ºber die tap0-TAP-Schnittstelle virtuell mit dem virtuellen vRouter-Router verbunden. </li><li>  vRouter analysiert, zu welcher Schnittstelle das Paket gelangt ist, dh zu welchem ‚Äã‚ÄãClient (VRF) es geh√∂rt, und √ºberpr√ºft die Empf√§ngeradresse anhand der Routing-Tabelle dieses Clients. </li><li>  Nachdem vRouter festgestellt hat, dass sich der Empf√§nger auf demselben Computer hinter einem anderen Port befindet, sendet er das Paket einfach ohne zus√§tzliche Header an ihn. In diesem Fall verf√ºgt der vRouter bereits √ºber einen ARP-Eintrag. </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/6be/2e5/1f0/6be2e51f0530a6fc7e9f2c6370c6e0d2.png" width="700"><br><br>  In diesem Fall gelangt das Paket nicht in das physische Netzwerk, sondern wird in vRouter weitergeleitet. <br><br><br><h4>  Steuerebene </h4><br>  Wenn die virtuelle Maschine gestartet wird, teilt der Hypervisor ihr Folgendes mit: <br><br><ul><li>  Ihre eigene IP-Adresse. </li><li>  Die Standardroute f√ºhrt √ºber die IP-Adresse des vRouter in diesem Netzwerk. </li></ul><br>  √úber eine spezielle API berichtet der Hypervisor an vRouter: <br><br><ul><li>  Was Sie ben√∂tigen, um eine virtuelle Schnittstelle zu erstellen. </li><li>  Welche (VM) ben√∂tigt, um ein virtuelles Netzwerk zu erstellen. </li><li>  An welche VRF soll es gebunden werden (VN). </li><li>  Der statische ARP-Datensatz f√ºr diese VM gibt an, an welche Schnittstelle die IP-Adresse und an welche MAC-Adresse sie angeh√§ngt ist. </li></ul><br><blockquote>  Auch hier wird das eigentliche Interaktionsverfahren vereinfacht, um das Konzept zu verstehen. <br></blockquote><img src="https://habrastorage.org/getpro/habr/post_images/e14/f52/d49/e14f52d4935eb6d5fd5213c1bd3baeec.png" width="800"><br><br>  Somit sieht vRouter alle VMs eines Clients auf einem bestimmten Computer als direkt verbundene Netzwerke an und kann zwischen ihnen selbst routen. <br><br><hr><br>  VM0 und VM1 geh√∂ren jedoch zu unterschiedlichen Clients und befinden sich in unterschiedlichen Tabellen vRouter'a. <br><br>  Ob sie direkt miteinander kommunizieren k√∂nnen, h√§ngt von den vRouter-Einstellungen und dem Netzwerkdesign ab. <br>  Wenn beispielsweise die VMs beider Clients √∂ffentliche Adressen verwenden oder NAT auf dem vRouter selbst auftritt, kann auch ein direktes Routing an vRouter durchgef√ºhrt werden. <br><br>  In der umgekehrten Situation ist es m√∂glich, Adressr√§ume zu √ºberqueren - Sie m√ºssen einen NAT-Server durchlaufen, um eine √∂ffentliche Adresse zu erhalten - dies √§hnelt dem Zugriff auf externe Netzwerke, die unten beschrieben werden. <br><br><hr><br><br><h3>  Kommunikation zwischen VMs auf verschiedenen physischen Computern </h3><br><h4>  Datenebene </h4><br><ol><li>  Der Anfang ist genau der gleiche: VM-0 sendet standardm√§√üig ein Paket mit dem Ziel VM-7 (172.17.3.2). </li><li>  vRouter empf√§ngt es und sieht diesmal, dass sich das Ziel auf einem anderen Computer befindet und √ºber den Tunneltunnel0 erreichbar ist. </li><li>  Zun√§chst wird das MPLS-Etikett zur Identifizierung der Remote-Schnittstelle aufgeh√§ngt, sodass auf der R√ºckseite von vRouter festgelegt werden kann, wo dieses Paket ohne zus√§tzliche Hooks abgelegt werden soll. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/322/f94/328/322f943287f0e8956acc02654bdae580.png" width="1000"></a> <br></li><li>  Tunnel0 hat eine Quelle von 10.0.0.2, der Empf√§nger: 10.0.1.2. <br>  vRouter f√ºgt dem urspr√ºnglichen Paket GRE- (oder UDP-) Header und eine neue IP hinzu. </li><li>  Die vRouter-Routing-Tabelle enth√§lt eine Standardroute √ºber die Adresse ToR1 10.0.0.1.  Dort und sendet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9a/696/b8a/b9a696b8a0e97aba81107a3ad112f001.png" width="700"><br><br></li><li>  ToR1 als Mitglied des Underlay-Netzwerks wei√ü (z. B. √ºber OSPF), wie man zu 10.0.1.2 gelangt, und sendet ein Paket entlang der Route.  Bitte beachten Sie, dass ECMP hier enthalten ist.  In der Abbildung gibt es zwei Nexsthops, in denen durch Hash unterschiedliche Streams angeordnet sind.  Im Falle einer echten Fabrik wird es wahrscheinlich 4 Nextops geben. <br><br>  Gleichzeitig muss er nicht wissen, was sich unter dem externen IP-Header befindet.  Das hei√üt, unter IP kann es ein Sandwich von IPv6 √ºber MPLS √ºber Ethernet √ºber MPLS √ºber GRE √ºber √ºber Griechisch geben. </li><li>  Dementsprechend entfernt vRouter auf der Empfangsseite GRE und versteht anhand des MPLS-Labels, an welche Schnittstelle dieses Paket gesendet werden soll, entfernt es und sendet es in seiner urspr√ºnglichen Form an den Empf√§nger. </li></ol><br><br><h4>  Steuerebene </h4><br>  Wenn Sie die Maschine starten, ist alles, was passiert, oben beschrieben. <br><br>  Und dazu noch Folgendes: <br><br><ul><li>  VRouter weist jedem Client ein MPLS-Tag zu.  Dies ist das L3VPN-Service-Label, bei dem Kunden auf dieselbe physische Maschine aufgeteilt werden. <br><blockquote>  Tats√§chlich wird das MPLS-Tag immer vom vRouter'om zugewiesen - schlie√ülich ist nicht im Voraus bekannt, dass der Computer nur mit anderen Computern hinter demselben vRouter'om interagiert, und dies ist h√∂chstwahrscheinlich nicht einmal der Fall. <br></blockquote></li><li>  vRouter stellt √ºber BGP eine Verbindung zum SDN-Controller her (oder √§hnlich - im Fall von TF ist dies XMPP 0_o). </li><li>  W√§hrend dieser Sitzung teilt vRouter dem SDN-Controller die Routen zu den verbundenen Netzwerken mit: <br><br><ul><li>  Netzwerkadresse </li><li>  Verkapselungsmethode (MPLSoGRE, MPLSoUDP, VXLAN) </li><li>  Client-MPLS-Label </li><li>  Ihre IP-Adresse als Nexthop </li></ul><br></li><li>  Der SDN-Controller empf√§ngt solche Routen von allen verbundenen vRouter'ov und gibt sie an andere weiter.  Das hei√üt, er fungiert als Routenreflektor. </li></ul><br>  Das gleiche passiert in die entgegengesetzte Richtung. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5aa/e3a/b17/5aae3ab177a4ed58279e4c767618f770.png" width="1000"></a> <br><br>  Die √úberlagerung kann sich mindestens jede Minute √§ndern.  So etwas passiert in √∂ffentlichen Clouds, wenn Clients ihre virtuellen Maschinen regelm√§√üig starten und ausschalten. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zentrale Steuerung √ºbernimmt alle Schwierigkeiten bei der Pflege der Konfiguration und der Steuerung der Switching- / Routing-Tabellen auf vRouter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grob gesagt f√§hrt der Controller mit allen vRoutern √ºber BGP (oder ein √§hnliches Protokoll) herunter und √ºbertr√§gt einfach Routing-Informationen. </font><font style="vertical-align: inherit;">BGP verf√ºgt beispielsweise bereits √ºber eine Adressfamilie zum √úbertragen der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MPLS-in-GRE-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MPLS-in-UDP-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kapselungsmethode </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichzeitig √§ndert sich die Konfiguration des Underlay-Netzwerks in keiner Weise, was im √úbrigen viel schwieriger zu automatisieren ist und es einfacher ist, mit einer unangenehmen Bewegung zu brechen.</font></font><br><br><hr><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gehe nach au√üen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irgendwo sollte die Simulation enden und von der virtuellen Welt aus m√ºssen Sie in die reale gehen. </font><font style="vertical-align: inherit;">Und Sie brauchen ein </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√ºnztelefon-</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gateway. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es werden zwei Ans√§tze praktiziert:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Hardware-Router ist installiert. </font></font></li><li>  - appliance,    (-,   SDN    VNF ).    . </li></ol><br><blockquote>        ‚Äî    ‚Äî      .    ,     , ,  ,   ,  , , , ,         . <br><br>       ,           ,   ,      ,    ( <i></i> ).     ,  -   ,   ,          ‚Äî    . <br></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit einem Fu√ü blickt das Gateway wie eine normale virtuelle Maschine in das virtuelle Overlay-Netzwerk und kann mit allen anderen VMs interagieren. </font><font style="vertical-align: inherit;">Gleichzeitig kann es die Netzwerke aller Clients auf sich selbst terminieren und dementsprechend ein Routing zwischen ihnen durchf√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit dem anderen Fu√ü schaut das Gateway bereits auf das Backbone-Netzwerk und wei√ü, wie man zum Internet gelangt.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/930/3d2/d1a/9303d2d1a6777510d3bc87bc19349da2.png" width="800"><br><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Datenebene </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das hei√üt, der Prozess sieht folgenderma√üen aus: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VM-0 sendet standardm√§√üig alle im selben vRouter und sendet ein Paket mit einem Ziel in der Au√üenwelt (185.147.83.177) an die eth0-Schnittstelle. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vRouter empf√§ngt dieses Paket und sucht in der Routing-Tabelle nach der Zieladresse. Es findet die Standardroute durch das VNGW1-Gateway durch Tunnel 1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Er sieht auch, dass dies ein GRE-Tunnel mit SIP 10.0.0.2 und DIP 10.0.255.2 ist, und legt zuerst MPLS auf. Das Label dieses Clients, das VNGW1 erwartet.</font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vRouter packt das Originalpaket in die MPLS-, GRE- und neuen IP-Header und sendet es standardm√§√üig an ToR1 10.0.0.1. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Unterlage-Netzwerk liefert das Paket an das VNGW1-Gateway. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das VNGW1-Gateway entfernt die GRE- und MPLS-Tunnel-Header, sieht die Zieladresse, konsultiert die Routing-Tabelle und versteht, dass es an das Internet gerichtet ist - dies bedeutet √ºber Vollansicht oder Standard. </font><font style="vertical-align: inherit;">F√ºhrt bei Bedarf eine NAT-√úbersetzung durch.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Von VNGW bis zur Grenze kann es ein regul√§res IP-Netzwerk geben, was unwahrscheinlich ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann sich um ein klassisches MPLS-Netzwerk (IGP + LDP / RSVP TE), eine Fabrik mit einer BGP-LU oder einen GRE-Tunnel von VNGW zur Grenze durch das IP-Netzwerk handeln. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie auch immer, VNGW1 f√ºhrt die erforderlichen Kapselungen durch und sendet das Originalpaket an die Grenze.</font></font></li></ol><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d9e/49b/c01/d9e49bc0141200d07b7dbd6710495c83.png" width="1000"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Verkehr in die entgegengesetzte Richtung durchl√§uft dieselben Schritte in der entgegengesetzten Reihenfolge. </font></font><br><br><ol><li>     VNGW1 </li><li>   ,      ,      Tunnel1 (MPLSoGRE  MPLSoUDP). </li><li> ,   MPLS,  GRE/UDP   IP     ToR3 10.0.255.1. <br>    ‚Äî IP- vRouter',      ‚Äî 10.0.0.2. </li><li>       vRouter'. </li><li>  vRouter  GRE/UDP,  MPLS-      IP-   TAP-,   eth0 . </li></ol><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d4d/f49/892/d4df4989216a42c06343ba883b8f5db2.png" width="1000"></a> <br><br><br><h4> Control Plane </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VNGW1 erstellt mit dem SDN-Controller eine BGP-Nachbarschaft, von der es alle Routing-Informationen zu Clients empf√§ngt: Welche IP-Adresse (vRouter'om) ist welcher Client und mit welchem ‚Äã‚ÄãMPLS-Label identifiziert es sich? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In √§hnlicher Weise teilt er dem SDN-Controller die Standardroute mit der Bezeichnung dieses Clients mit und gibt sich als Nexthop an. Und dann kommt diese Standardeinstellung zu vRouter'y. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VNGWs leiten normalerweise die Aggregation oder NAT-√úbersetzung weiter. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und in die entgegengesetzte Richtung gibt er genau diese aggregierte Route zu einer Sitzung mit Boardern oder Route Reflectors. Und von ihnen erh√§lt eine Standardroute oder Vollansicht oder etwas anderes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Bezug auf Kapselung und Verkehrsaustausch unterscheidet sich VNGW nicht von vRouter.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie den Bereich etwas erweitern, k√∂nnen Sie VNGW und vRouter weitere Netzwerkger√§te hinzuf√ºgen, z. B. Firewalls, Farmen zur Verkehrsbereinigung oder -anreicherung, IPS usw. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mithilfe der sukzessiven Erstellung von VRF und der korrekten Ank√ºndigung von Routen k√∂nnen Sie eine beliebige Verkehrsschleife erstellen, die als Service Chaining bezeichnet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das hei√üt, hier fungiert der SDN-Controller als Routenreflektor zwischen VNGW, vRouter'ami und anderen Netzwerkger√§ten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tats√§chlich gibt der Controller jedoch auch Informationen zu ACLs und PBRs (Policy Based Routing) frei, wodurch einzelne Verkehrsstr√∂me gezwungen werden, anders zu verlaufen, als es die Route vorschreibt.</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/917/7f6/97a/9177f697a1ff4a7560153286ac04f287.png" width="1000"></a> <br><br><hr><br><br><h1>  FAQ </h1><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum machst du immer eine GRE / UDP-Bemerkung?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nun, im Allgemeinen kann man sagen, dass es spezifisch f√ºr Wolframgewebe ist - man kann es √ºberhaupt ignorieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber wenn Sie es nehmen, dann unterst√ºtzt TF selbst, obwohl es noch ein OpenContrail ist, beide Kapselungen: MPLS in GRE und MPLS in UDP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDP ist gut, da es im Quellport in seinem Header sehr einfach ist, eine Hash-Funktion vom urspr√ºnglichen IP + Proto + Port zu codieren, die einen Ausgleich erm√∂glicht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Fall von GRE gibt es leider nur externe IP- und GRE-Header, die f√ºr den gesamten gekapselten Verkehr gleich sind, und es ist nicht von einem Ausgleich die Rede - nur wenige Menschen k√∂nnen so tief in das Paket schauen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu einiger Zeit lernten Router, wenn sie wussten, wie man dynamische Tunnel verwendet, nur in MPLSoGRE und erst vor kurzem in MPLSoUDP. Daher m√ºssen Sie immer eine Bemerkung √ºber die M√∂glichkeit von zwei verschiedenen Einkapselungen machen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fairerweise ist anzumerken, dass TF die L2-Konnektivit√§t mit VXLAN vollst√§ndig unterst√ºtzt. </font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie haben versprochen, Parallelen zu OpenFlow zu ziehen.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie betteln wirklich. vSwitch im selben OpenStack macht sehr √§hnliche Dinge mit VXLAN, das √ºbrigens auch einen UDP-Header hat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der Datenebene funktionieren sie ungef√§hr gleich, die Kontrollebene unterscheidet sich erheblich. Tungsten Fabric verwendet XMPP, um Routeninformationen an vRouter zu √ºbermitteln, w√§hrend Openflow in OpenStack funktioniert. </font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kann ich etwas mehr √ºber vRouter erfahren?</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist in zwei Teile unterteilt: vRouter Agent und vRouter Forwarder. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die erste wird im Benutzerbereich des Host-Betriebssystems gestartet und kommuniziert mit dem SDN-Controller, wobei Informationen zu Routen, VRF und ACL ausgetauscht werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die zweite implementiert Data Plane - normalerweise im Kernel Space, kann aber auch auf SmartNICs gestartet werden - Netzwerkkarten mit einer CPU und einem separaten programmierbaren Switching-Chip, mit denen Sie die Last von der CPU des Host-Computers entfernen und das Netzwerk schneller und vorhersehbarer machen k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein anderes Szenario ist m√∂glich, wenn vRouter eine DPDK-Anwendung im User Space ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der vRouter Agent l√∂scht die Einstellungen in vRouter Forwarder. </font></font><br><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist ein virtuelles Netzwerk?</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe am Anfang des Artikels √ºber VRF erw√§hnt, dass jeder Mieter an seine VRF gebunden ist. Und wenn dies f√ºr ein oberfl√§chliches Verst√§ndnis der Arbeit des Overlay-Netzwerks ausreichte, m√ºssen bereits bei der n√§chsten Iteration Klarstellungen vorgenommen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalerweise wird in Virtualisierungsmechanismen die virtuelle Netzwerkeinheit (Sie k√∂nnen sie als Eigennamen verwenden) getrennt von Clients / Mandanten / virtuellen Maschinen eingef√ºhrt - dies ist eine ziemlich unabh√§ngige Sache. Und dieses virtuelle Netzwerk √ºber die Schnittstellen kann bereits in einem Mandanten, im anderen in zwei, aber zumindest wo verbunden werden. So wird beispielsweise die Dienstverkettung implementiert, wenn Datenverkehr in der gew√ºnschten Reihenfolge √ºber bestimmte Knoten geleitet werden muss, indem einfach virtuelle Netzwerke in der richtigen Reihenfolge erstellt und aufgerufen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daher besteht keine direkte Korrespondenz zwischen dem virtuellen Netzwerk und dem Mandanten.</font></font><br><br><hr><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist eine sehr oberfl√§chliche Beschreibung des Betriebs eines virtuellen Netzwerks mit einer √úberlagerung vom Host und vom SDN-Controller. Unabh√§ngig davon, welche Virtualisierungsplattform Sie heute verwenden, funktioniert sie auf √§hnliche Weise, sei es VMWare, ACI, OpenStack, CloudStack, Tungsten Fabric oder Juniper Contrail. Sie unterscheiden sich in den Arten der Kapselung und den Headern sowie in den Protokollen zur √úbermittlung von Informationen an Endnetzwerkger√§te. Das Prinzip eines auf Software abgestimmten Overlay-Netzwerks, das auf einem relativ einfachen und statischen Underlay-Netzwerk basiert, bleibt jedoch dasselbe.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen sagen, dass die Bereiche der Erstellung einer privaten Cloud bis heute das SDN basierend auf dem Overlay-Netzwerk gewonnen haben. </font><font style="vertical-align: inherit;">Dies bedeutet jedoch nicht, dass Openflow keinen Platz in der modernen Welt hat - es wird in OpenStacke und in derselben VMWare NSX verwendet, soweit ich wei√ü, verwendet Google es, um das Unterlagennetzwerk zu konfigurieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Folgenden habe ich Links zu detaillierteren Materialien angegeben, wenn Sie das Thema genauer untersuchen m√∂chten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und was ist unsere Unterlage? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber im Allgemeinen nichts. </font><font style="vertical-align: inherit;">Er hat sich nicht den ganzen Weg ver√§ndert. </font><font style="vertical-align: inherit;">Alles, was er im Falle einer √úberlagerung vom Host tun muss, ist, Routen und ARPs zu aktualisieren, wenn vRouter / VNGW erscheint und verschwindet, und Pakete zwischen ihnen zu ziehen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulieren wir eine Liste der Anforderungen f√ºr ein Underlay-Netzwerk.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um in unserer Situation ein Routing-Protokoll durchf√ºhren zu k√∂nnen - BGP. </font></font></li><li>   ,   ,     - . </li><li>  ECMP ‚Äî   . </li><li>   QoS,     ,  ECN. </li><li>  NETCONF ‚Äî   . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe hier sehr wenig Zeit f√ºr die Arbeit des Underlay-Netzwerks selbst aufgewendet. </font><font style="vertical-align: inherit;">Dies liegt daran, dass ich mich sp√§ter in der Serie darauf konzentrieren werde und Overlay nur nebenbei ber√ºhren werde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich schr√§nke ich uns alle stark ein, indem ich als Beispiel das in der Klose-Fabrik aufgebaute DC-Netzwerk mit reinem IP-Routing und Overlay vom Host verwende. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich bin jedoch sicher, dass jedes Netzwerk, das ein Design hat, formal beschrieben und automatisiert werden kann. </font><font style="vertical-align: inherit;">Es ist nur so, dass ich das Ziel verfolge, die Ans√§tze zur Automatisierung zu verstehen und nicht alle zu verwirren, um das Problem allgemein zu l√∂sen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Rahmen von ADSM lag Roman Gorge und ich, eine separate Ausgabe zur Virtualisierung der Rechenleistung und ihrer Perspektive mit der Netzwerkvirtualisierung zu geh√∂ren. </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bleib in Kontakt.</font></font></font></font><br><br><br><h1>  N√ºtzliche Links </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wolframgewebe-Architektur</font></font></font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√ºber: Wolke</font></font></font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6 Stunden √ºber Yandex.Cloud, wo auch das virtuelle Netzwerk auf TFwerden ist.</font></font></font></font></li><li><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'de', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist Open vSwitch?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung in VxLAN</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC 7348. Virtual eXtensible Local Area Network (VXLAN): Ein Framework zum √úberlagern von virtualisierten Layer 2-Netzwerken √ºber Layer 3-Netzwerke.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scaleway-Ansatz f√ºr VXLAN EVPN Fabric</a> .  Es informiert √ºber das gesamte Netzwerk von DCs, einschlie√ülich Underlay, Overlay, Ans√§tze f√ºr Multi-Homing und Management. </li></ul><br><h5>  Danke </h5><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Roman Gorge</a> , ehemaliger Hauptmoderator des Linkmeup-Podcasts und jetzt Experte auf dem Gebiet der Cloud-Plattformen.  F√ºr Kommentare und √Ñnderungen.  Nun, wir freuen uns auf einen tieferen Artikel √ºber Virtualisierung in naher Zukunft. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Shalimov</a> , mein Kollege und Experte f√ºr die Entwicklung virtueller Netzwerke.  F√ºr Kommentare und √Ñnderungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Valentina Sinitsyna</a> , meine Kollegin und Wolfram-Stoff-Expertin.  F√ºr Kommentare und √Ñnderungen. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artyom Chernobay</a> - Illustrator Linkmeup.  F√ºr KDPV. </li><li>  Alexander Limonov.  F√ºr das Mem "Automat". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458622/">https://habr.com/ru/post/de458622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458604/index.html">Warum sich die beiden gr√∂√üten Elektronikhersteller zu einem neuen GPU-Projekt zusammengeschlossen haben</a></li>
<li><a href="../de458606/index.html">F√ºhren Sie OpenVPN in Docker in 2 Sekunden aus</a></li>
<li><a href="../de458608/index.html">Node.js Entwicklertools Jobwarteschlange</a></li>
<li><a href="../de458612/index.html">Kosmos. 7 Jahre</a></li>
<li><a href="../de458614/index.html">Erstellen eines Reactive UsePosition () - Hooks zum Abrufen und Verfolgen von Browserkoordinaten</a></li>
<li><a href="../de458624/index.html">Wie wir gelernt haben, Texte auf Leinwand zu zeichnen</a></li>
<li><a href="../de458626/index.html">StealthWatch: Grundkonzepte und Mindestanforderungen. Teil 1</a></li>
<li><a href="../de458630/index.html">Eine kleine Geschichte der Entwicklung Ihres Spiels auf reinem Windows Forms + C # in meinen 16 Jahren</a></li>
<li><a href="../de458632/index.html">Wirklich tippen vue</a></li>
<li><a href="../de458634/index.html">"Sei nicht b√∂se" oder was Facebook vor uns verbirgt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>