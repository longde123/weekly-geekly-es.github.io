<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤛🏾 🙌🏼 👍🏾 Arsitektur layanan antrian pesan terdistribusi di Yandex.Cloud 🧜🏾 📋 ℹ️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai, nama saya Vasily Bogonatov. Saya adalah salah satu dari mereka yang meletakkan tangan dan kepala saya dan menempatkan jiwa saya ke dalam layanan ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arsitektur layanan antrian pesan terdistribusi di Yandex.Cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/455642/"> Hai, nama saya Vasily Bogonatov.  Saya adalah salah satu dari mereka yang meletakkan tangan dan kepala saya dan menempatkan jiwa saya ke dalam layanan antrian pesan persisten yang didistribusikan dari Antrian Pesan Yandex.  Layanan ini go public pada akhir Mei, tetapi di dalam Yandex telah lama digunakan secara aktif dalam berbagai produk. <br><br>  Hari ini saya ingin memberi tahu pembaca Habr tentang antrian pesan secara umum dan tentang Antrian Pesan Yandex pada khususnya.  Pertama, saya ingin menjelaskan apa "antrian pesan tetap yang didistribusikan" dan mengapa itu diperlukan.  Tunjukkan nilai praktisnya, mekanisme bekerja dengan pesan, berbicara tentang API dan kegunaan.  Pada paruh kedua artikel, kita akan melihat sisi teknis: bagaimana Yandex Database digunakan dalam antrian kami (ini adalah dasar yang dapat diandalkan dari layanan kami), bagaimana pendekatan yang naif dan lebih baik untuk membangun tampilan arsitektur, masalah apa yang disebabkan oleh distribusi dan bagaimana mereka dapat dipecahkan. <br><br><img src="https://habrastorage.org/webt/xy/ht/eb/xyhtebqslkofciotlmohtwlopb4.png"><br><a name="habracut"></a><br><h3>  Apa itu antrian pesan persisten yang didistribusikan? </h3><br>  Wikipedia mendefinisikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antrian pesan</a> sebagai "komponen rekayasa perangkat lunak yang digunakan untuk interaksi antar proses atau antar-threaded dalam satu proses".  Bahkan, konsep ini agak lebih luas: proses berinteraksi menggunakan antrian dapat ditemukan di server yang berbeda dan bahkan di pusat data yang berbeda. <br><br>  Kami akan sedikit menjelaskan persyaratannya. <br><br>  <b>Antrian pesan</b> adalah repositori yang menyediakan penempatan dan pembacaan data dalam urutan tertentu. <br><br>  Dua jenis entitas biasanya berinteraksi dengan antrian: <br><br><ul><li>  <b>penulis (produsen)</b> - mengirim pesan ke antrian; </li><li>  <b>pembaca (konsumen)</b> - menerima (baca) pesan dari antrian. </li></ul><br>  Saat menggunakan antrian, pembaca dan penulis saling independen.  Mereka dapat bekerja dengan kinerja, keandalan, ketersediaan yang berbeda dan bahkan dapat ditulis dalam bahasa pemrograman yang berbeda. <br><br>  Skenario utama untuk antrian: andal dan cepat mengirimkan pesan dari penulis ke pembaca.  Tidak seperti database, antrian tidak dimaksudkan untuk penyimpanan pesan jangka panjang.  Dalam banyak implementasi populer, ada parameter yang sesuai - "Periode penyimpanan pesan".  Ini menentukan berapa lama pesan disimpan sampai dihapus secara permanen. <br><br>  Kami menemukan konsep antrian, pergi ke "distribusi" dan "ketekunan". <br><br><ul><li>  <b>Distribusi</b> dalam kasus kami berarti adanya cluster yang menyimpan dan memproses data dan antrian metadata, menggabungkan semua node menjadi satu keseluruhan menggunakan jaringan komputer. </li><li>  <b>Kegigihan</b> menyiratkan bahwa semua pesan dalam antrian ditulis ke disk, dan penulis menerima konfirmasi pengiriman hanya setelah rekaman berhasil. </li></ul><br>  Distribusi dan ketekunan tidak mempengaruhi fungsi utama dari antrian, mereka memberikan toleransi kesalahan dan keandalan penyimpanan data.  Jenis kegagalan apa yang dapat terjadi dalam sistem kami, kami akan pertimbangkan sedikit kemudian.  Namun, saya tidak dapat menyangkal kesenangan diri dan sedikit membuka kartu: dalam seluruh sejarah keberadaan layanan, kami tidak kehilangan satu pesan pun yang disimpan dari klien. <br><br><h3>  Untuk apa antrian pesan? </h3><br>  Antrian memungkinkan Anda untuk memisahkan bagian-bagian layanan yang secara logis independen dari satu sama lain, yaitu, ia menyediakan <b>decoupling</b> , yang sangat diminati dalam layanan-layanan microsoft yang sekarang populer.  Ini meningkatkan skalabilitas dan keandalan: Anda selalu dapat meningkatkan aliran rekaman dalam antrian dan menambahkan lebih banyak pembaca - penangan pesan, sedangkan kegagalan pembaca tidak mempengaruhi pekerjaan penulis. <br><br>  Antrian meratakan beban puncak: mereka bertindak sebagai penyangga bagi pembaca.  Jika kapasitas pembaca saat ini tidak mencukupi untuk pemrosesan instan semua pesan yang masuk, pesan yang antri akan diproses nanti ketika beban menurun.  Buffer berguna untuk layanan dengan beban yang tidak stabil, di mana peristiwa masuk instan tidak diperlukan. <br><br>  Mari kita lihat cara kerjanya, menggunakan contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">robot pencarian</a> (setelah semua, Yandex mulai dengan pencarian!), Yang mengunduh, memproses dan menempatkan halaman web ke dalam database.  Mari kita ambil arsitektur seperti itu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/oe/dh/zooedh0t0qs4uu1lhpdc0psa2qi.png" width="600" height="778"></div><br><br>  Antrian pesan memecahkan masalah berikut di sini: <br><br><ol><li>  Robot bekerja jauh lebih cepat daripada pekerja yang bertanggung jawab untuk parsing dan memuat halaman ke dalam database.  Di luar jalur, tautan akan menumpuk dan mengisi memori atau disk yang tersedia.  Hal yang sama akan terjadi jika pekerja sementara tidak tersedia. </li><li>  Tanpa antrian, robot perlu "mengetahui" antarmuka kerja para pekerja untuk menetapkan tugas kepada mereka.  Antarmuka dapat berubah saat produk berkembang. </li><li>  Seorang pekerja individu memiliki keandalan yang cukup rendah, sehingga tidak ada jaminan bahwa tautan yang ditransmisikan akan sepenuhnya diproses olehnya. </li></ol><br>  Antrian menyediakan penyimpanan data yang andal dengan penskalaan, memungkinkan Anda untuk menunda pemrosesan tautan.  Jika satu pekerja gagal, tautan mentah setelah jangka waktu tertentu akan dikembalikan ke antrian untuk diproses oleh pekerja lain.  Antrian memiliki antarmuka sendiri, yang diuji dan dijelaskan dalam dokumentasi, sehingga robot pencarian dan sistem pekerja dapat mengembangkan tim yang berbeda dalam bahasa pemrograman yang berbeda.  Ini tidak akan memengaruhi kinerja secara keseluruhan. <br><br><h3>  Bagaimana Antrian Pesan Yandex berfungsi dengan pesan </h3><br>  Tiga tahap utama dapat dibedakan di sini: <br><br><ul><li>  <b>menulis</b> pesan ke antrian; </li><li>  <b>membaca</b> pesan dari antrian; </li><li>  <b>Menghapus</b> pesan dari antrian. </li></ul><br>  Catatan dianggap berhasil jika pesan telah disimpan dengan aman dan akan segera tersedia untuk pembaca.  Rekaman deduplikasi dimungkinkan: ketika upaya yang berulang untuk merekam pesan terkirim diabaikan. <br><br>  Pada saat membaca pesan disembunyikan dari antrian untuk jangka waktu yang disebut Visibilitas Timeout, dan menjadi tidak dapat diakses oleh pembaca lain.  Jika batas waktu visibilitas berakhir, pesan kembali ke antrian dan tersedia untuk diproses lagi.  Urutan pembacaan pesan ditentukan oleh antrian, bukan oleh pembaca. <br><br>  Pembaca itu sendiri dan koneksi jaringan dengannya berpotensi tidak dapat diandalkan.  Waktu tunggu visibilitas diperlukan untuk dapat mengembalikan pesan ke antrian ketika pembaca macet atau koneksi terputus.  Kalau tidak, kemungkinan satu pesan tidak akan pernah diproses dengan benar. <br><br>  Setelah berhasil membaca, pesan dikirim ke klien dengan tanda pengenal ReceiptHandle.  Identifier menunjukkan data spesifik yang harus dihapus dari antrian pesan. <br><br><h3>  Jenis antrian dalam Antrian Pesan Yandex </h3><br>  Jenis pertama dan paling umum digunakan adalah Antrian Standar.  Ini ditandai dengan throughput yang tinggi (ribuan pesan per detik), kinerja luar biasa dan waktu pelaksanaan operasi dasar yang singkat.  Antrian standar terdiri dari pecahan logis dan mendukung penskalaan bandwidth yang hampir linier. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/p0/jp/wyp0jpi_pmhorpq2mikwm_mgl-u.png"></div><br>  Antrian standar tidak mendukung deduplikasi pesan saat menulis ke antrian dan tidak menjamin urutan pembacaan.  Karena penggunaan sharding, permintaan baca mungkin tidak mengembalikan satu pesan, bahkan jika mereka dalam antrian.  Paling sering ini terjadi dalam mode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">polling pendek</a> , ketika membaca berasal dari satu beling yang dipilih secara acak. <br><br>  Tipe kedua - <abbr title="Pertama masuk pertama keluar">FIFO</abbr> - adalah kebalikan dari antrian standar.  Ini memberikan urutan pembacaan yang ketat, mendukung deduplikasi saat menulis dan upaya berulang untuk membaca pesan.  Kinerja dan skalabilitas lebih rendah dari standar.  Kinerja antrian FIFO terbatas hingga 30 permintaan per detik.  FIFO direkomendasikan untuk digunakan ketika Anda perlu mencoba memastikan semantik pengiriman “tepat sekali”.  Biasanya, kata "antrian" berarti FIFO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yr/jy/l5/yrjyl5kbyfzqzkruqhaoqdrsxzs.png" width="421" height="801"></div><br><h3>  API Antrian Pesan Yandex </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API</a> adalah komponen yang sangat penting dari produk apa pun.  Antarmuka perangkat lunak yang baik harus sederhana dan mudah, membutuhkan pengenalan minimal dengan dokumentasi untuk penggunaan yang efektif.  Seharusnya tidak membiarkan melakukan tindakan aneh atau tidak perlu dan melindungi dari kesalahan bodoh, melaporkan pelanggaran "kontrak" tepat waktu. <br><br>  Jika sistem memiliki API seperti itu, ia dengan cepat menerima pengguna yang setia dan dikelilingi oleh “pembungkus” yang nyaman untuk berbagai platform dan bahasa pemrograman. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API Layanan Antrian Sederhana Amazon (AWS SQS API)</a> adalah contoh dari antarmuka semacam itu, diuji oleh waktu dan sejumlah besar klien.  Oleh karena itu, kami memutuskan untuk tidak membuat antarmuka unik untuk Antrian Pesan Yandex, tetapi menerapkan dukungan untuk AWS SQS API, dan dengan sangat hati-hati. <br><br>  Dalam kebanyakan kasus, cukup bagi pengguna SQS untuk mengubah titik akhir (alamat layanan), wilayah (saat ini kami hanya menggunakan "ru-central1") dan mendapatkan kredensial baru dalam Yandex.Cloud.  Segala sesuatu yang lain, misalnya, skrip yang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baris perintah AWS</a> , kode yang menggunakan AWS SDK, atau layanan yang sudah jadi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seledri</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">boto</a> , kemungkinan besar tidak akan disentuh.  Logika dan fungsionalitas layanan antrian akan tetap sama. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/td/kn/_rtdknyixiytyqo63khne5gz4uq.png"></div><br>  Penjelasan terperinci tentang metode Antrian Pesan Yandex ada dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi layanan</a> . <br><br><h3>  Sedikit tentang kenyamanan </h3><br>  Antrian Pesan Yandex adalah layanan terkelola, yaitu, Yandex. Cloud bertanggung jawab atas pengoperasian server dan perangkat lunak.  Tim layanan memantau kesehatan antrian, dengan cepat mengganti disk yang gagal, menghilangkan jeda jaringan dan meluncurkan pembaruan.  Pembaruan tidak menghentikan layanan: sementara kami menginstal versi baru YMQ pada satu kelompok server, penyeimbang beban dengan hati-hati mengalihkan lalu lintas ke yang lain.  Jadi pengguna tidak memperhatikan apa pun. <br><br>  Untuk membuatnya lebih nyaman bagi Anda untuk mengontrol operasi antrian, kami telah menambahkan sejumlah besar grafik visual ke YMQ, hanya sebagian kecil dari mereka yang ditampilkan di sini.  Grafik terletak di konsol Yandex.Cloud, di bagian "Statistik". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/cp/nn/bicpnn5tjwzqustzy9ye5abnrho.png"></div><br>  Kami akan memberi tahu Anda tentang empat grafik paling berguna menurut kami: <br><br><ul><li>  Grafik <b>"Pesan Antrian"</b> membantu Anda memantau akumulasi data dalam antrian.  Pertumbuhan dalam grafik dapat berarti bahwa penangan tidak mengelola beban atau pemrosesan telah berhenti. </li><li>  Grafik <b>"Usia pesan tertua dalam antrian"</b> : nilai besar menunjukkan masalah dengan pemrosesan pesan.  Jika semuanya berfungsi dengan benar, pesan tidak boleh dalam antrian untuk waktu yang lama. </li><li>  Grafik <b>"Jumlah upaya untuk membaca pesan"</b> menunjukkan kapan pesan mulai dibaca beberapa kali.  Ini mungkin berarti bahwa penangan macet ketika mereka menerima beberapa pesan. </li><li>  Grafik <b>"Waktu antrian" menunjukkan</b> berapa lama waktu berlalu sejak pesan dikirim ke antrian sampai pawang menerimanya. </li></ul><br>  Grafik membantu untuk secara instan mengevaluasi dinamika antrian dan adanya kegagalan tanpa perlu melihat log. <br><br>  Kami membahas lebih atau kurang poin-poin umum, sekarang mari kita beralih ke detailnya. <br><br><h3>  Bagaimana Antrian Basis Data Yandex menggunakan Basis Data Yandex </h3><br>  Layanan Antrian Pesan Yandex dibangun di atas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">basis data Yandex Database (YDB) yang</a> toleran terhadap kesalahan yang didistribusikan secara geografis, yang memberikan konsistensi dan dukungan ketat untuk transaksi ACID.  Kami sekarang tidak akan membongkar perangkat dan karakteristiknya, kami akan membatasi diri pada skema umum. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/5m/o3/uq5mo3fm83hovqxkgt7no-yjevg.png" width="742" height="860"></div><br>  Antrian di YMQ terdiri dari pecahan logis, diwakili oleh beberapa set tetap tabel YDB.  Setiap tabel menyimpan informasi sendiri.  Misalnya, ada tabel keadaan umum yang disebut negara, yang menyimpan dan jumlah sebenarnya pesan.  Ada tabel dengan metadata data dan pesan.  Ada tabel dengan atribut terkait. <br><br>  Semua operasi utama dengan antrian - bekerja dengan pesan, mengubah atribut, membuat dan menghapus - ini berfungsi dengan hierarki tabel dan direktori YDB, atau kueri transaksional ke satu atau lebih tabel antrian.  Data di dalam tabel antrian adalah sumber kebenaran absolut.  Oleh karena itu, selain operasi database yang benar dan stabil, perlu untuk memastikan penyimpanan yang andal dan ketersediaan data yang tinggi. <br><br>  Informasi kami disimpan dalam beberapa replika: satu salinan di masing-masing dari tiga pusat data Yandex.  Jika salah satu pusat data tidak tersedia, jumlah replika yang tersisa berlipat ganda.  Dengan demikian, tingkat keandalan yang diperlukan dipulihkan.  Bahkan jika seluruh pusat data dan satu meja layanan di tempat lain gagal, data akan sepenuhnya dapat diakses. <br><br><h3>  Versi pertama dari arsitektur Antrian Pesan Yandex </h3><br>  Versi pertama dari arsitektur YMQ, yang kami sebut naif, tampak seperti ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aj/qc/eu/ajqceuaoisynocw4u3ffek3epjo.png"></div><br>  Diagram menunjukkan jalur permintaan HTTPS dari klien YMQ ke repositori YDB.  Mari kita lihat komponen-komponen utamanya: <br><br><ol><li>  L3-balancer mengirimkan permintaan ke pusat data Yandex yang terdekat dengan pengguna.  Ini mengurangi latensi jaringan, meskipun beban didistribusikan secara tidak merata. </li><li>  Nginx pada mesin virtual Yandex.Cloud mengakhiri koneksi HTTPS, memberikan perlindungan terhadap serangan jaringan dan proksi permintaan lebih lanjut ke server YMQ, sudah dalam HTTP. </li><li>  Server HTTP YMQ mengimplementasikan logika SQS HTTP API, memvalidasi dan menerjemahkan permintaan ke dalam format protobuf yang sangat diketik. </li><li>  Sistem Aktor YMQ - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem Aktor</a> .  Secara bersamaan meluncurkan ribuan aktor yang berbeda bertukar informasi.  Sistem aktor dari setiap host adalah bagian dari sebuah cluster.  Semua aktor di cluster hidup dan bertindak sebagai satu kesatuan.  Logika bisnis YMQ diimplementasikan di berbagai pelaku yang terlibat dalam permintaan transaksi ke YDB. </li><li>  Tablet YDB ("tablet") - bagian dari inti YDB, yang bertanggung jawab untuk bekerja dengan tabel dalam kueri dan transaksi.  Tablet itu sendiri tidak menyimpan data.  Ini adalah struktur kontrol dalam memori yang dapat memulihkan keadaan jika terjadi kegagalan perangkat keras. </li><li>  Penyimpanan adalah penyimpanan yang andal, didistribusikan, dan tahan terhadap kesalahan. </li></ol><br>  Arsitektur ini memiliki kelemahan: semua server di gugus bekerja secara independen dengan tabel dari antrian yang sama.  Ini memengaruhi kinerja secara negatif dan mencegah pengaturan cache pesan tersembunyi dan dapat dibaca yang dapat diandalkan.  Sulit untuk membatasi aliran permintaan, dan ini sangat penting untuk layanan yang sangat dimuat. <br><br><h3>  Arsitektur Antrian Pesan Yandex dengan master antrian </h3><br>  Load firing menunjukkan bahwa versi pertama arsitektur bertahan sekitar 450 pesan per detik per antrian dengan satu beling.  Itu sangat kecil. <br>  Masalah utama adalah pertanyaan pertengkaran.  Sejumlah besar transaksi yang bertentangan secara logis dengan cepat membawa cache pesan tersembunyi ke keadaan yang tidak konsisten.  Untuk mengatasi masalah tersebut, kami memperkenalkan entitas khusus - master antrian. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gc/b4/om/gcb4omkmhk28uhwe2hrlewhzsig.png"></div><br>  <b>Master antrian</b> adalah aktor yang, dalam kondisi normal, ada dalam satu cluster dalam satu instance dan melewati semua permintaan yang terkait dengan antrian tertentu.  Jika permintaan ke antrian tiba di server di mana master yang diinginkan tidak ada, aktor proxy khusus mengalihkan permintaan dan kemudian menerjemahkan respons yang diterima kembali dari master. <br><br>  Saat menggunakan Antrian Wizard, cache yang benar dari pesan yang tidak dikunci mengurangi pertikaian ketika bekerja dengan tabel.  Implementasi pembatasan aliran permintaan disederhanakan, misalnya, melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ember Leaky</a> .  Metrik antrian cepat dan akurat tersedia: jumlah pesan, lalu lintas total, dan sejenisnya.  Anda dapat mengelompokkan permintaan serupa. <br><br>  Secara teori, arsitektur semacam itu memiliki kelemahan tertentu yang terkait dengan sentralisasi: <br><br><ol><li>  Mengurangi toleransi kesalahan: jika mesin virtual dengan master gagal, semua antrian dengan master di atasnya tidak akan tersedia.  Namun, mekanisme khusus YDB memungkinkan Anda untuk meningkatkan master baru di dalam cluster hanya dalam beberapa detik.  Ini sebagian besar memecahkan masalah. </li><li>  Skalabilitas terbatas: semua permintaan melalui satu host.  Kerugiannya adalah tablet YDB diratakan.  Mereka melakukan semua kerja keras dengan data.  Dan master secara tidak sinkron mengirimkan permintaan dan memproses hasil yang diterima.  Ini membuatnya menjadi entitas "ringan" yang tidak menciptakan efek "bottleneck" selama pengujian stres. </li></ol><br><h3>  Antrian Wisaya Antrian </h3><br>  Transaksi terdistribusi dengan tabel database menyebabkan biaya tambahan tertentu, sehingga ide untuk mengurangi jumlah kueri tampak logis bagi kami.  Seratus transaksi untuk merekam pesan satu per satu lebih baik untuk berubah menjadi satu transaksi untuk merekam seratus pesan sekaligus.  Dengan master antrian, menerapkan pemrosesan batch (batching) seperti itu jauh lebih mudah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/rn/0j/ycrn0j7obrbg0_cimvkyzj5izr4.png"></div><br>  Batching sedikit meningkatkan latensi selama operasi.  Sebaliknya, bandwidth meningkat secara signifikan.  Dengan batching, antrian single-shard dapat memproses hingga 30.000 permintaan per detik. <br><br>  Secara umum, pemuatan antrian bisa sangat berbeda: ribuan pesan per detik dan beberapa pesan per hari.  Kami perlu mengoptimalkan pekerjaan dengan antrian menggunakan algoritma yang fleksibel.  Opsi frontal dengan akumulasi pesan dalam buffer ke nomor ambang batas atau reset timer tidak cocok untuk kita.  Oleh karena itu, kami mengembangkan algoritma batching adaptif untuk YMQ yang bekerja dengan baik dalam kedua kasus.  Karyanya ditampilkan dalam format grafik waktu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/g2/rx/qmg2rx2e8pllaxuajav0gyxe2kg.png"></div><br>  Di sini, ketika pesan baru tiba, satu dari tiga skenario dimungkinkan: <br><br><ol><li>  Transaksi dimulai secara instan jika tidak ada transaksi lain dari jenis ini yang berjalan. </li><li>  Jika sudah ada transaksi yang berjalan, pesan ditambahkan ke buffer dan menunggu transaksi selesai. </li><li>  Jika ukuran buffer melebihi nilai ambang batas, transaksi paralel lain diluncurkan.  Jumlah transaksi bersamaan terbatas. </li></ol><br>  Gagasan batching adaptif menyerupai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Nagle</a> untuk TCP / IP.    :      ,      latency .    ,        .               . <br><br><h3>        </h3><br>  Yandex Message Queue,      ,    .  ,  ,      -. <br><br>    YDB               .   YMQ     . <br><br>           ,   ,     ,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/yb/ay/olybayeljh8jcdbcmod9dpylopw.png" width="808" height="712"></div><br>  YMQ   .                    .   «»        . <br><br><h3>        </h3><br>  YDB           .    ,  ,     ,   «».             ,       .          . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/em/eg/egemegamvnhmv-c5t8pw4im73u0.png" width="661" height="685"></div><br>   :              .    ,    «»      .  -,   «»  ,   «»,    . <br><br>     «  »               .    ,  ,     . <br><br><h3>   Yandex Message Queue     </h3><br> Yandex Message Queue –  - .      .       ,  .     . <br><br><ul><li> <b>-</b>    ,  ,   .      . </li><li> <b> </b>       API   ,    .  ,        . </li><li> <b> </b>  ,     :    ,           . ,       .          .     boto,    24/7,     -    . </li><li> <b> </b>    ,   ,         .        . </li></ul><br>        .       -         .   .       . <br><br>     : <br><br><ul><li>     5,       ; </li><li>    YDB; </li><li>  , , ,   ; </li><li>      ,    ; </li><li>    .       . </li></ul><br>                  . <br><br><h3>  Kesimpulannya </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas tim infrastruktur di Yandex adalah menciptakan dan memelihara solusi yang andal, dapat diskalakan, dan produktif, berdasarkan pada produk-produk baru yang dapat diluncurkan dengan cepat dan berhasil yang meningkatkan kehidupan pengguna akhir. </font><font style="vertical-align: inherit;">Di dalam perusahaan, layanan antrian kami telah lama membuktikan kegunaannya dan telah menjadi bagian dari arsitektur Yandex.Video, Yandex.Market, Yandex.Pendidikan, Yandex.Taxi, dan layanan lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang tersedia di ekosistem Yandex.Cloud dan dapat digunakan untuk membangun layanan di dalam dan di luar Cloud itu sendiri. </font><font style="vertical-align: inherit;">Sekarang pengguna baru saat pendaftaran menerima </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hibah uang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk sosialisasi, sehingga Anda dapat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mencoba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Antrean Pesan Yandex secara gratis.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455642/">https://habr.com/ru/post/id455642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455632/index.html">Perhatian! Bug berbahaya dalam implementasi C ++ std :: map :: merge dan std :: set :: merge di Visual Studio 2017</a></li>
<li><a href="../id455634/index.html">Matematika dan game "Set"</a></li>
<li><a href="../id455636/index.html">Gelombang pertama dipengaruhi oleh kerentanan Exim. Script untuk perawatan</a></li>
<li><a href="../id455638/index.html">Alan Kay tidak menemukan benda</a></li>
<li><a href="../id455640/index.html">“Mesin Emosi” Marvin Minsky: Bab 4. “Bagaimana Kita Mengenali Kesadaran”</a></li>
<li><a href="../id455644/index.html">Kami menggunakan data dalam praktik</a></li>
<li><a href="../id455646/index.html">Security Week 24: backdoors pabrik di smartphone Android</a></li>
<li><a href="../id455648/index.html">Siklus Hidup ML</a></li>
<li><a href="../id455650/index.html">Bagaimana kami melatih jaringan saraf untuk mengklasifikasikan sekrup</a></li>
<li><a href="../id455652/index.html">Deep Learning vs akal sehat: mengembangkan bot obrolan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>