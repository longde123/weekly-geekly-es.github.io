<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♍️ 🖖🏿 🙋🏾 Einführung in C. Botschaft aus dem letzten Jahrhundert ▶️ 💥 👩🏾‍🤝‍👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 
 In meinen Kommentaren bezog ich mich mehrmals auf Andrew Tanenbaums Buch Operating Systems Design and Implementation, seine erste Ausgabe, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in C. Botschaft aus dem letzten Jahrhundert</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464075/"><h3>  Vorwort </h3><br>  In meinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentaren</a> bezog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich mich</a> mehrmals auf Andrew Tanenbaums Buch Operating Systems Design and Implementation, seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste Ausgabe,</a> und wie C darin dargestellt wird.  Und diese Kommentare waren schon immer von Interesse.  Ich entschied, dass es Zeit war, eine Übersetzung dieser Einführung in C zu veröffentlichen.  Es ist immer noch relevant.  Zwar gibt es sicherlich diejenigen, die noch nichts über die Programmiersprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL / 1</a> und vielleicht sogar über das Betriebssystem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minix gehört haben</a> . <br><br>  Diese Beschreibung ist auch aus historischer Sicht interessant und um zu verstehen, wie weit die C-Sprache seit ihrer Geburt und die IT-Branche insgesamt gegangen ist. <br><a name="habracut"></a><br>  Ich möchte sofort reservieren, dass meine zweite Sprache Französisch ist: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/467/5a3/9614675a3883bf417fa2505dada57690.png" alt="Bild"><br><br>  Dies wird jedoch durch 46 Jahre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmiererfahrung</a> ausgeglichen. <br>  Also, fangen wir an, Andrew Tanenbaum ist an der Reihe. <br><br><h3>  Einführung in die C-Sprache (S. 350 - 362) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png"></div><br><br>  Die Programmiersprache C wurde von Dennis Ritchie von AT &amp; T Bell Laboratories als übergeordnete Programmiersprache für die Entwicklung des UNIX-Betriebssystems erstellt.  Derzeit ist die Sprache in verschiedenen Bereichen weit verbreitet.  C ist besonders bei Systemprogrammierern beliebt, da Sie damit Programme einfach und präzise schreiben können. <br><br>  Das Hauptbuch, das die C-Sprache beschreibt, ist Brian Kernigan und Dennis Ritchies Buch The C Programming Language (1978).  Bücher über die C-Sprache wurden von Bolon (1986), Gehani (1984), Hancock und Krieger (1986), Harbison und Steele (1984) und vielen anderen geschrieben. <br><br>  In diesem Anhang werden wir versuchen, eine ziemlich vollständige Einführung in C zu geben, damit diejenigen, die mit Hochsprachen wie Pascal, PL / 1 oder Modula 2 vertraut sind, den größten Teil des in diesem Buch enthaltenen MINIX-Codes verstehen können.  C-Funktionen, die in MINIX nicht verwendet werden, werden hier nicht behandelt.  Zahlreiche subtile Punkte wurden weggelassen.  Der Schwerpunkt liegt auf dem Lesen von C-Programmen und nicht auf dem Schreiben von Code. <br><br><h3>  A.1.  C Sprachgrundlagen </h3><br>  Ein C-Programm besteht aus einer Reihe von Prozeduren (oft als Funktionen bezeichnet, auch wenn sie keine Werte zurückgeben).  Diese Verfahren enthalten Deklarationen, Operatoren und andere Elemente, die dem Computer gemeinsam mitteilen, was zu tun ist.  Abbildung A-1 zeigt eine kleine Prozedur, bei der drei ganzzahlige Variablen deklariert und Werte zugewiesen werden.  Der Name der Prozedur ist main.  Die Prozedur hat keine formalen Parameter, was durch das Fehlen von Bezeichnern zwischen den Klammern hinter dem Prozedurnamen angezeigt wird.  Der Hauptteil der Prozedur ist in geschweiften Klammern ({}) eingeschlossen.  Dieses Beispiel zeigt, dass C Variablen hat und dass diese Variablen vor der Verwendung deklariert werden müssen.  C hat auch Operatoren, in diesem Beispiel sind dies Zuweisungsoperatoren.  Alle Anweisungen müssen mit einem Semikolon enden (im Gegensatz zu Pascal, bei dem Doppelpunkte zwischen Anweisungen verwendet werden, nicht danach). <br><br>  Kommentare beginnen mit den Zeichen "/ *" und enden mit den Zeichen "* /" und können mehrere Zeilen umfassen. <br><br><pre><code class="cpp hljs">main () <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; <span class="hljs-comment"><span class="hljs-comment">/*  3   */</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  i  10 ( ) */</span></span> j = i + <span class="hljs-number"><span class="hljs-number">015</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  j  i + 015 ( ) */</span></span> k = j * j + <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  k  j * j + 0xFF ( ) */</span></span> } . Al.    .</code> </pre> <br>  Die Prozedur enthält drei Konstanten.  Konstante 10 in der ersten Zuordnung <br>  Es ist eine gewöhnliche Dezimalkonstante.  Die 015-Konstante ist eine Oktalkonstante <br>  (gleich 13 in Dezimalzahl).  Oktalkonstanten beginnen immer bei Null.  Die Konstante 0xFF ist eine hexadezimale Konstante (entspricht 255 Dezimalstellen).  Hexadezimale Konstanten beginnen immer mit 0x.  Alle drei Typen werden in C verwendet. <br><br><h3>  A.2.  Grundlegende Datentypen </h3><br>  C hat zwei Haupttypen von Daten (Variablen): eine Ganzzahl und ein Zeichen, die als int bzw. char deklariert sind.  Es gibt keine separate boolesche Variable.  Die int-Variable wird als boolesche Variable verwendet.  Wenn diese Variable 0 enthält, bedeutet dies falsch / falsch, und jeder andere Wert bedeutet wahr / wahr.  C hat auch Gleitkommatypen, aber MINIX verwendet sie nicht. <br><br>  Sie können kurze, lange oder vorzeichenlose „Adjektive“ auf einen int-Typ anwenden, der einen Wertebereich (vom Compiler abhängig) definiert.  Die meisten 8088-Prozessoren verwenden 16-Bit-Ganzzahlen für int und short int und 32-Bit-Ganzzahlen für long int.  Ganzzahlen ohne Vorzeichen (int ohne Vorzeichen) auf dem 8088-Prozessor haben einen Bereich von 0 bis 65535 und nicht von -32768 bis +32767, wie dies bei normalen Ganzzahlen (int) der Fall ist.  Ein Zeichen benötigt 8 Bits. <br><br>  Der Registerspezifizierer ist auch für int und char zulässig und ist ein Hinweis für den Compiler, dass die deklarierte Variable im Register abgelegt werden sollte, damit das Programm schneller arbeitet. <br><br>  Einige Anzeigen sind in Abb. 1 dargestellt.  A - 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1, z2; / *    */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag_poll; <span class="hljs-comment"><span class="hljs-comment">/* 'int'    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> . <span class="hljs-number"><span class="hljs-number">-2.</span></span>  .</code> </pre> <br>  Die Konvertierung zwischen Typen ist zulässig.  Zum Beispiel der Bediener <br><br><pre> <code class="cpp hljs">flag_pole = i;</code> </pre> <br>  erlaubt, auch wenn i vom Typ int ist und flag_pole lang ist.  In vielen Fällen <br>  Es ist notwendig oder nützlich, Konvertierungen zwischen Datentypen zu erzwingen.  Für die erzwungene Konvertierung reicht es aus, den Zieltyp in Klammern vor dem Ausdruck für die Konvertierung zu setzen.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"> ( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) i);</code> </pre> <br>  weist an, die Ganzzahl i in long zu konvertieren, bevor sie als Parameter an die Prozedur p übergeben wird, die den long-Parameter erwartet. <br><br>  Achten Sie beim Konvertieren zwischen Typen auf das Zeichen. <br>  Bei der Konvertierung eines Zeichens in eine Ganzzahl behandeln einige Compiler Zeichen als signiert, dh von - 128 bis +127, während andere sie als behandeln <br>  vorzeichenlos, dh von 0 bis 255. In MINIX sind Ausdrücke wie <br><br><pre> <code class="cpp hljs">i = c &amp; <span class="hljs-number"><span class="hljs-number">0377</span></span>;</code> </pre> <br>  Dies konvertiert von (Zeichen) in eine Ganzzahl und führt dann ein logisches UND aus <br>  (kaufmännisches Und) mit der Oktalkonstante 0377. Das Ergebnis ist, dass die hohen 8 Bits <br>  werden auf Null gesetzt, wodurch c gezwungen wird, als vorzeichenlose 8-Bit-Zahl im Bereich von 0 bis 255 betrachtet zu werden. <br><br><h3>  A.3.  Verbindungstypen und Zeiger </h3><br>  In diesem Abschnitt werden vier Möglichkeiten zum Erstellen komplexerer Datentypen beschrieben: Arrays, Strukturen, Vereinigungen und Zeiger.  Ein Array ist eine Sammlung / Menge von Elementen desselben Typs.  Alle Arrays in C beginnen mit Element 0. <br><br>  Ankündigung <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a [<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br>  deklariert ein Array a mit 10 Ganzzahlen, die in den Elementen des Arrays von [0] bis a [9] gespeichert werden sollen.  Zweitens können Arrays drei oder mehr Dimensionen haben, werden jedoch in MINIX nicht verwendet. <br>  Eine Struktur ist eine Sammlung von Variablen, normalerweise verschiedener Typen.  Die Struktur in C ähnelt der Aufzeichnung in Pascal.  Betreiber <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} s;</code> </pre> <br>  deklariert s als eine Struktur, die zwei Elemente enthält, die Ganzzahl i und das Zeichen c. <br><br>  Um das Mitglied i der Struktur s 6 zuzuweisen, schreiben Sie den folgenden Ausdruck: <br><br><pre> <code class="cpp hljs">si = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  wobei der Punktoperator angibt, dass das Element i zur Struktur s gehört. <br>  Eine Gewerkschaft ist auch eine Gruppe von Mitgliedern, ähnlich einer Struktur, mit der Ausnahme, dass zu jedem Zeitpunkt nur einer von ihnen einer Gewerkschaft angehören kann.  Ankündigung <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} u;</code> </pre> <br>  bedeutet, dass Sie eine Ganzzahl oder ein Zeichen haben können, aber nicht beide.  Der Compiler sollte genügend Platz zum Kombinieren reservieren, damit er das größte (aus Sicht des belegten Speichers) Kombinationselement aufnehmen kann.  Vereinigungen werden in MINIX nur an zwei Stellen verwendet (um eine Nachricht als Vereinigung mehrerer verschiedener Strukturen zu definieren und um einen Plattenblock als Vereinigung eines Datenblocks, eines i-Node-Blocks, eines Katalogblocks usw. zu definieren). <br><br>  Zeiger werden verwendet, um Maschinenadressen in C zu speichern.  Sie werden sehr, sehr oft verwendet.  Ein Sternchen (*) kennzeichnet einen Zeiger in Anzeigen.  Ankündigung <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, *pi, a [<span class="hljs-number"><span class="hljs-number">10</span></span>], *b[<span class="hljs-number"><span class="hljs-number">10</span></span>], **ppi;</code> </pre> <br>  deklariert eine Ganzzahl i, einen Zeiger auf eine Ganzzahl pi, ein Array a mit 10 Elementen, ein Array b mit 10 Zeigern auf Ganzzahlen und einen Zeiger auf einen Zeiger ppi auf eine Ganzzahl. <br><br>  Die genauen Syntaxregeln für komplexe Deklarationen, die Arrays, Zeiger und andere Typen kombinieren, sind etwas komplex.  Glücklicherweise verwendet MINIX nur einfache Deklarationen. <br><br>  Abbildung A-3 zeigt die Deklaration eines Arrays z von Strukturtabellenstrukturen, von denen jede hat <br>  drei Mitglieder, Ganzzahl i, Zeiger cp auf Zeichen und Zeichen c. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; / *  */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, c; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } z [<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    20  */</span></span> .  - <span class="hljs-number"><span class="hljs-number">3.</span></span>  .</code> </pre> <br>  Arrays von Strukturen sind in MINIX üblich.  Ferner kann die Namenstabelle als Strukturtabellenstruktur deklariert werden, die in nachfolgenden Deklarationen verwendet werden kann.  Zum Beispiel <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  deklariert p als Zeiger auf eine Strukturtabellenstruktur und schlägt vor, diese zu speichern <br>  im Register.  Während der Programmausführung kann p beispielsweise z [4] oder anzeigen <br>  zu jedem anderen Element in z, von dem alle 20 Elemente Strukturen vom Typ Strukturtabelle sind. <br><br>  Um p zu einem Zeiger auf z [4] zu machen, schreiben Sie einfach <br><br><pre> <code class="cpp hljs">p = &amp;z[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br>  wobei das kaufmännische Und als unärer (monadischer) Operator bedeutet "nimm die Adresse dessen, was darauf folgt".  Kopieren Sie den Wert von Element i in die Ganzzahlvariable n <br>  Die Struktur, auf die p zeigt, kann wie folgt ausgeführt werden: <br><br><pre> <code class="cpp hljs">n = p-&gt;i;</code> </pre> <br>  Beachten Sie, dass der Pfeil verwendet wird, um über einen Zeiger auf ein Mitglied der Struktur zuzugreifen.  Wenn wir die Variable z verwenden, müssen wir den Punktoperator verwenden: <br><br><pre> <code class="cpp hljs">n = z [<span class="hljs-number"><span class="hljs-number">4</span></span>] .i;</code> </pre> <br>  Der Unterschied besteht darin, dass z [4] eine Struktur ist und der Punktoperator die Elemente auswählt <br>  von zusammengesetzten Typen (Strukturen, Arrays) direkt.  Mithilfe von Zeigern wählen wir keinen Teilnehmer direkt aus.  Der Zeiger weist an, zuerst eine Struktur und erst dann ein Mitglied dieser Struktur auszuwählen. <br><br>  Manchmal ist es praktisch, einem zusammengesetzten Typ einen Namen zu geben.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unshort;</code> </pre> <br>  definiert unshort als unsigned short (unsigned short integer).  Jetzt kann unshort im Programm als Haupttyp verwendet werden.  Zum Beispiel <br><br><pre> <code class="cpp hljs">unshort ul, *u2, u3[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  deklariert eine kurze vorzeichenlose Ganzzahl, einen Zeiger auf eine kurze vorzeichenlose Ganzzahl und <br>  ein Array von kurzen Ganzzahlen ohne Vorzeichen. <br><br><h3>  A.4.  Betreiber </h3><br>  Prozeduren in C enthalten Erklärungen und Anweisungen.  Wir haben die Erklärungen bereits gesehen, daher werden wir jetzt die Operatoren betrachten.  Der Zweck der Bedingungs- und Schleifenoperatoren ist im Wesentlichen der gleiche wie in anderen Sprachen.  Abbildung A - 4 zeigt einige Beispiele dafür.  Das einzige, worauf Sie achten sollten, ist, dass geschweifte Klammern verwendet werden, um Operatoren zu gruppieren, und die while-Anweisung hat zwei Formen, von denen die zweite der Wiederholungsanweisung von Pascal ähnlich ist. <br><br>  C hat auch eine for-Anweisung, sieht aber in keiner anderen Sprache wie eine for-Anweisung aus.  Die for-Anweisung hat die folgende Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (&lt;&gt;; &lt;&gt;; &lt;&gt;) ;</code> </pre> <br>  Dasselbe kann durch die while-Anweisung ausgedrückt werden: <br><br><pre> <code class="cpp hljs">&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(&lt;&gt;) { &lt;&gt;; &lt;&gt; }</code> </pre> <br>  Betrachten Sie als Beispiel die folgende Aussage: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;n; i = i+l) a[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Dieser Operator setzt die ersten n Elemente des Arrays a auf Null.  Die Ausführung des Operators beginnt mit dem Setzen von i auf Null (dies erfolgt außerhalb der Schleife).  Dann wird der Operator wiederholt, bis i &lt;n ist, während die Zuweisung und Erhöhung von i durchgeführt wird.  Anstelle des Operators, dem aktuellen Element eines Null-Arrays einen Wert zuzuweisen, kann natürlich ein zusammengesetzter Operator (Block) in geschweiften Klammern stehen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) k = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) { <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j + l, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;y) { <span class="hljs-comment"><span class="hljs-comment">/*  if-else */</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  while */</span></span> k = k + k; n = n - l; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { / *    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> */ k = k + k; n = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); . A<span class="hljs-number"><span class="hljs-number">-4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>  C.</code> </pre> <br>  C hat auch einen Operator ähnlich dem Falloperator in Pascal.  Dies ist eine switch-Anweisung.  Ein Beispiel ist in Abbildung A-5 dargestellt.  Abhängig vom Wert des in switch angegebenen Ausdrucks wird die eine oder andere case-Anweisung ausgewählt. <br><br>  Wenn der Ausdruck keiner der case-Anweisungen entspricht, wird die Standardanweisung ausgewählt. <br><br>  Wenn der Ausdruck keiner case-Anweisung zugeordnet ist und die Standardanweisung fehlt, wird die Ausführung ab der nächsten Anweisung nach der switch-Anweisung fortgesetzt. <br><br>  Es ist zu beachten, dass Sie die break-Anweisung verwenden, um den case-Block zu verlassen.  Wenn keine break-Anweisung vorhanden ist, wird der nächste case-Block ausgeführt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (k) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   case 20, ..    switch */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>: i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; / *   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>* / <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: j = <span class="hljs-number"><span class="hljs-number">5</span></span>; } . A<span class="hljs-number"><span class="hljs-number">-5.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span></code> </pre> <br>  Die break-Anweisung wirkt auch innerhalb der for- und while-Schleifen.  Es ist zu beachten, dass die Ausgabe nur eine Ebene höher ist, wenn sich die break-Anweisung in einer Reihe verschachtelter Schleifen befindet. <br><br>  Eine verwandte Anweisung ist die continue-Anweisung, die die Schleife nicht verlässt. <br>  bewirkt jedoch den Abschluss der aktuellen Iteration und den Beginn der nächsten Iteration <br>  sofort.  Dies ist im Wesentlichen eine Rückkehr zum Anfang der Schleife. <br><br>  C verfügt über Prozeduren, die mit oder ohne Parameter aufgerufen werden können. <br>  Laut Kernigan und Ritchie (S. 121) ist es nicht gestattet, Arrays zu übertragen. <br>  Strukturen oder Prozeduren als Parameter, obwohl Zeiger auf all dies übergeben werden <br>  erlaubt.  Gibt es ein Buch oder nicht (es wird in meinem Gedächtnis auftauchen: - „Wenn es Leben auf dem Mars gibt, wenn es kein Leben auf dem Mars gibt“), erlauben viele C-Compiler Strukturen als Parameter. <br>  Der Name des Arrays bedeutet, wenn er ohne Index geschrieben ist, einen Zeiger auf ein Array, was die Übertragung eines Array-Zeigers vereinfacht.  Wenn also a der Name eines Arrays eines beliebigen Typs ist, kann es durch Schreiben an g übergeben werden <br><br><pre> <code class="cpp hljs">g();</code> </pre> <br>  Diese Regel gilt nur für Arrays, diese Regel gilt nicht für Strukturen. <br>  Prozeduren können Werte zurückgeben, indem sie eine return-Anweisung ausführen.  Diese Anweisung kann einen Ausdruck enthalten, dessen Ergebnis als Wert der Prozedur zurückgegeben wird, aber der Aufrufer kann den Rückgabewert sicher ignorieren.  Wenn die Prozedur einen Wert zurückgibt, wird der Typwert vor den Prozedurnamen geschrieben, wie in Abb.  A-6.  Prozeduren können wie Parameter keine Arrays, Strukturen oder Prozeduren zurückgeben, sondern Zeiger darauf zurückgeben.  Diese Regel ist für eine effizientere Implementierung ausgelegt - alle Parameter und Ergebnisse entsprechen immer einem Maschinenwort (in dem die Adresse gespeichert ist).  Compiler, die die Verwendung von Strukturen als Parameter ermöglichen, ermöglichen normalerweise auch deren Verwendung als Rückgabewerte. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i, j </span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i + j); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } . <span class="hljs-number"><span class="hljs-number">-6.</span></span>   ,   .</code> </pre> <br>  C hat keine eingebauten E / A.  Die Eingabe / Ausgabe wird durch Aufrufen von Bibliotheksfunktionen implementiert, von denen die häufigsten unten dargestellt sind: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> («x=% dy = %oz = %x \n», x, y, z);</code> </pre> <br>  Der erste Parameter ist die Zeichenfolge zwischen Anführungszeichen (tatsächlich ist dies ein Array von Zeichen). <br><br>  Jedes Zeichen, das kein Prozentsatz ist, wird einfach so gedruckt, wie es ist. <br><br>  Wenn ein Prozentsatz auftritt, wird der folgende Parameter in der Form gedruckt, die durch den Buchstaben nach dem Prozentsatz definiert ist: <br><blockquote>  d - Drucken als Dezimalzahl <br>  o - als oktale Ganzzahl drucken <br>  u - Drucken als vorzeichenlose Dezimalzahl <br>  x - als hexadezimale Ganzzahl drucken <br>  s - als Zeichenfolge drucken <br>  c - als ein Zeichen drucken </blockquote>  Die Buchstaben D, 0 und X sind auch für den Dezimal-, Oktal- und Hexadezimaldruck langer Zahlen zulässig. <br><br><h3>  A.5.  Ausdrücke </h3><br>  Ausdrücke werden durch Kombinieren von Operanden und Operatoren erstellt. <br><br>  Arithmetische Operatoren wie + und - und Vergleichsoperatoren wie &lt; <br>  und&gt; ähnlich wie ihre Gegenstücke in anderen Sprachen.  % Operator <br>  Modulo verwendet.  Es ist erwähnenswert, dass der Gleichheitsoperator == ist und der Ungleichheitsoperator!  =.  Um zu überprüfen, ob a und b gleich sind, können Sie wie folgt schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;&gt;;</code> </pre> <br>  Mit C können Sie den Zuweisungsoperator daher auch mit anderen Operatoren kombinieren <br><br><pre> <code class="cpp hljs">a += <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  entspricht der Aufnahme <br><br><pre> <code class="cpp hljs"> =  + <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Auf diese Weise können auch andere Operatoren kombiniert werden. <br><br>  C hat Operatoren zum Bearbeiten von Wortbits.  Sowohl Verschiebungen als auch bitweise logische Operationen sind zulässig.  Die linken und rechten Schichtoperatoren sind &lt;&lt; <br>  bzw. &gt;&gt;.  Bitweise logische Operatoren &amp;, |  und ^, die logisches UND (UND) sind, einschließlich ODER (ODER) bzw. exklusives ODER (XOP).  Wenn i den Wert 035 (oktal) hat, hat der Ausdruck i &amp; 06 den Wert 04 (oktal).  Ein anderes Beispiel, wenn i = 7, dann <br><br><pre> <code class="cpp hljs">j = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">014</span></span>;</code> </pre> <br>  und bekomme 074 für j. <br>  Eine weitere wichtige Gruppe von Operatoren sind unäre Operatoren, von denen jeder nur einen Operanden akzeptiert.  Als unärer Operator erhält kaufmännisches Und &amp; die Adresse einer Variablen. <br><br>  Wenn p ein Zeiger auf eine ganze Zahl ist und i eine ganze Zahl ist, der Operator <br><br><pre> <code class="cpp hljs">p = &amp;i;</code> </pre> <br>  berechnet die Adresse i und speichert sie in der Variablen p. <br>  Das Gegenteil von einer Adresse ist ein Operator, der einen Zeiger als Eingabe verwendet und den Wert an dieser Adresse berechnet.  Wenn wir dem Zeiger p gerade die Adresse i zugewiesen haben, hat * p die gleiche Bedeutung wie i. <br><br>  Mit anderen Worten, als unärer Operator folgt auf ein Sternchen ein Zeiger (oder <br>  Ausdruck mit einem Zeiger) und gibt den Wert des Elements zurück, auf das es zeigt.  Wenn i einen Wert von 6 hat, dann der Operator <br><br><pre> <code class="cpp hljs">j = *;</code> </pre> <br>  wird j die Nummer 6 zuweisen. <br>  Der Betreiber!  (das Ausrufezeichen ist der Negationsoperator) gibt 0 zurück, wenn sein Operand ungleich Null ist, und 1, wenn sein Operator 0 ist. <br><br>  Es wird zum Beispiel hauptsächlich in if-Anweisungen verwendet <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) k=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  prüft den Wert von x.  Wenn x Null (falsch) ist, wird k der Wert 0 zugewiesen. Eigentlich ist der Operator!  bricht die darauf folgende Bedingung ab, genau wie der Operator not in Pascal. <br><br>  Der Operator ~ ist ein bitweiser Komplementoperator.  Jede 0 in ihrem Operanden <br>  wird 1 und jede 1 wird 0. <br><br>  Der Operator sizeof gibt die Größe seines Operanden in Bytes an.  In Bezug auf <br>  Ein Array von 20 Ganzzahlen a auf einem Computer mit 2-Byte-Ganzzahlen, z. B. Größe von a, hat einen Wert von 40. <br><br>  Die letzte Gruppe von Operatoren sind die Operatoren für Zunahme und Abnahme. <br><br>  Betreiber <br><br><pre> <code class="cpp hljs">++;</code> </pre> <br>  bedeutet eine Erhöhung von p.  Wie viel p zunimmt, hängt von seinem Typ ab. <br>  Ganzzahlen oder Zeichen werden um 1 erhöht, Zeiger jedoch um 1 <br>  die Größe des Objekts, auf das auf diese Weise gezeigt wird, wenn a ein Array von Strukturen ist und p ein Zeiger auf eine dieser Strukturen ist, und wir schreiben <br><br><pre> <code class="cpp hljs">p = &amp;a[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br>  um p auf eine der Strukturen im Array zu zeigen, dann nach dem Erhöhen von p <br>  zeigt auf a [4], egal wie groß die Strukturen sind.  Betreiber <br><br><pre> <code class="cpp hljs">p--;</code> </pre> <br>  ähnlich dem p ++ - Operator, außer dass der Wert des Operanden eher verringert als erhöht wird. <br><br>  In Aussage <br><br><pre> <code class="cpp hljs">n = k++;</code> </pre> <br>  Wenn beide Variablen ganze Zahlen sind, wird der ursprüngliche Wert von k n und zugewiesen <br>  erst dann steigt k an.  In Aussage <br><br><pre> <code class="cpp hljs">n = ++ k;</code> </pre> <br>  k steigt zuerst an, dann wird sein neuer Wert in n gespeichert. <br><br>  Somit kann ein ++ (oder -) Operator vor oder nach seinem Operanden geschrieben werden, was zu verschiedenen Werten führt. <br><br>  Die letzte Aussage ist das?  (Fragezeichen), das eine von zwei Alternativen auswählt <br>  durch einen Doppelpunkt getrennt.  Zum Beispiel ein Operator, <br><br><pre> <code class="cpp hljs">i = (x &lt; y ? <span class="hljs-number"><span class="hljs-number">6</span></span> : k + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  vergleicht x mit y.  Wenn x kleiner als y ist, bekomme ich den Wert 6;  Andernfalls erhält die Variable i den Wert k + 1. Die Klammern sind optional. <br><br><h3>  A.6.  Programmstruktur </h3><br>  Ein C-Programm besteht aus einer oder mehreren Dateien, die Prozeduren und Deklarationen enthalten. <br>  Diese Dateien können einzeln zu Objektdateien kompiliert werden, die dann (mithilfe des Linkers) miteinander verknüpft werden, um ein ausführbares Programm zu bilden. <br>  Im Gegensatz zu Pascal können Prozedurdeklarationen nicht verschachtelt werden, daher werden alle auf der „obersten Ebene“ in der Programmdatei geschrieben. <br><br>  Es ist zulässig, Variablen außerhalb der Prozeduren zu deklarieren, z. B. am Anfang der Datei vor der ersten Deklaration der Prozedur.  Diese Variablen sind global und können in jeder Prozedur im gesamten Programm verwendet werden, es sei denn, das statische Schlüsselwort steht vor der Deklaration.  In diesem Fall können diese Variablen nicht in einer anderen Datei verwendet werden.  Die gleichen Regeln gelten für Verfahren.  Innerhalb einer Prozedur deklarierte Variablen sind lokal für die Prozedur. <br>  Die Prozedur kann auf die in einer anderen Datei deklarierte Ganzzahlvariable v zugreifen (vorausgesetzt, die Variable ist nicht statisch) und sie als extern deklarieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v;</code> </pre> <br>  Jede globale Variable muss genau einmal ohne das Attribut extern deklariert werden, um Speicher dafür zuzuweisen. <br><br>  Variablen können initialisiert werden, wenn sie deklariert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Arrays und Strukturen können ebenfalls initialisiert werden.  Globale Variablen, die nicht explizit initialisiert werden, erhalten den Standardwert Null. <br><br><h3>  A.7.  C Präprozessor </h3><br>  Bevor die Quelldatei an den C-Compiler übertragen wird, wird sie automatisch verarbeitet <br>  ein Programm namens Präprozessor.  Es ist die Ausgabe des Präprozessors, nicht <br>  Das ursprüngliche Programm wird dem Eingang des Compilers zugeführt.  Präprozessor führt aus <br>  Drei grundlegende Konvertierungen in einer Datei, bevor sie an den Compiler übergeben werden: <br><br>  1. Aufnahme von Dateien. <br>  2. Definition und Ersetzung von Makros. <br>  3. Bedingte Kompilierung. <br><br>  Alle Präprozessoranweisungen beginnen mit einem Nummernzeichen (#) in der 1. Spalte. <br>  Bei einer Ansichtsrichtlinie <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prog.h"</span></span></span></span></code> </pre> <br>  Vom Präprozessor erfüllt, enthält es die Datei prog.h Zeile für Zeile in <br>  das Programm, das an den Compiler übergeben werden soll.  Wenn die Direktive #include als geschrieben ist <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;prog.h&gt;</span></span></span></span></code> </pre> <br>  Anschließend wird die enthaltene Datei im Verzeichnis / usr / include anstelle des Arbeitsverzeichnisses durchsucht.  In C ist es üblich, die von mehreren Dateien verwendeten Deklarationen in einer Header-Datei (normalerweise mit dem Suffix .h) zu gruppieren und gegebenenfalls einzuschließen. <br>  Der Präprozessor erlaubt auch Makrodefinitionen.  Zum Beispiel <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 1024</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert das BLOCK_SIZE-Makro und weist ihm den Wert 1024 zu. Von nun an wird </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedes Vorkommen einer Zeichenfolge mit 10 Zeichen "BLOCK_SIZE" in der Datei </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch eine 4- </font><font style="vertical-align: inherit;">stellige </font><font style="vertical-align: inherit;">Zeichenfolge "1024" ersetzt, bevor der Compiler die Datei mit dem Programm sieht. Konventionell werden Makronamen in Großbuchstaben geschrieben. Makros können Parameter haben, in der Praxis jedoch nur wenige. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das dritte Merkmal des Präprozessors ist die bedingte Kompilierung. MINIX verfügt über mehrere </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen, an denen Code speziell für den 8088-Prozessor geschrieben wurde. Dieser Code sollte beim Kompilieren für einen anderen Prozessor nicht berücksichtigt werden. Diese Abschnitte sehen folgendermaßen aus:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> i8088 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;   8088&gt; #endif</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Zeichen i8088 definiert ist, sind die Anweisungen zwischen den beiden Präprozessoranweisungen #ifdef i8088 und #endif in der Präprozessorausgabe enthalten. </font><font style="vertical-align: inherit;">Andernfalls werden sie übersprungen. </font><font style="vertical-align: inherit;">Aufruf des Compilers mit dem Befehl</font></font><br><br><pre> <code class="cpp hljs">cc -c -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder durch Aufnahme einer Anweisung in das Programm </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> i8088</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir definieren das Symbol i8088, damit alle abhängigen Codes für 8088 enthalten sind. </font><font style="vertical-align: inherit;">Während der Entwicklung von MINIX wird möglicherweise spezieller Code für 68000er und andere Prozessoren erworben, die ebenfalls verarbeitet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie als Beispiel für die Funktionsweise des Präprozessors das Programm Abb. </font><font style="vertical-align: inherit;">A-7 (a). </font><font style="vertical-align: inherit;">Es enthält eine prog.h-Datei, deren Inhalt wie folgt lautet:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXAELEMENTS 100</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie sich vor, der Compiler wurde von einem Befehl aufgerufen </font></font><br><br><pre> <code class="bash hljs">cc -E -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem die Datei den Präprozessor durchlaufen hat, erfolgt die Ausgabe wie in Abb. </font><font style="vertical-align: inherit;">A-7 (b). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist diese Ausgabe und nicht die Quelldatei, die als Eingabe an den C-Compiler übergeben wird.</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include prog.h int x; main () main (); { { int a[MAX_ELEMENTS]; int a [100];  = 4;  = 4; a[x] = 6; [] = 6; #ifdef i8088 printf("8088. a[x]:% d\n", a[x]); printf ("8088. a[x]:% d\n", a[x]); #endif } #ifdef m68000 printf ("68000. x=%d\n", x); #endif } () (b) . -7. (a)   prog.c. (b)  .</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass der Präprozessor seine Arbeit erledigt und alle Zeilen gelöscht hat, die mit dem # -Zeichen beginnen. </font><font style="vertical-align: inherit;">Wenn der Compiler so aufgerufen würde</font></font><br><br><pre> <code class="bash hljs">cc -c -Dm68000 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann wäre ein weiterer Druck enthalten. </font><font style="vertical-align: inherit;">Wenn es so heißen würde:</font></font><br><br><pre> <code class="bash hljs">cc -c prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann wäre kein Druck enthalten. </font><font style="vertical-align: inherit;">(Der Leser kann darüber nachdenken, was passieren würde, wenn der Compiler mit beiden Flags -D-Flags aufgerufen würde.)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A.8. </font><font style="vertical-align: inherit;">Redewendungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Abschnitt werden einige Konstrukte betrachtet, die typisch für C sind, aber in anderen Programmiersprachen nicht üblich sind. </font><font style="vertical-align: inherit;">Betrachten Sie zunächst die Schleife:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = *q++;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Variablen p und q sind normalerweise Zeichenzeiger, und n ist ein Zähler. </font><font style="vertical-align: inherit;">Die Schleife kopiert die n-Zeichenfolge von wo q zeigt auf wo p zeigt. </font><font style="vertical-align: inherit;">Bei jeder Iteration der Schleife nimmt der Zähler ab, bis er 0 erreicht, und jeder der Zeiger nimmt zu, so dass sie nacheinander auf Speicherzellen mit einer höheren Zahl zeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres gängiges Design:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies setzt die ersten N Elemente von a auf 0. Eine alternative Möglichkeit, diese Schleife zu schreiben, ist wie folgt: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; p &lt; &amp;a[N]; p++) *p = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Anweisung wird der ganzzahlige Zeiger p so initialisiert, dass er auf das Nullelement des Arrays zeigt. </font><font style="vertical-align: inherit;">Die Schleife wird fortgesetzt, bis p die Adresse des N-ten Elements des Arrays erreicht. </font><font style="vertical-align: inherit;">Ein Zeigerkonstrukt ist viel effizienter als ein Arraykonstrukt und wird daher normalerweise verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisungsoperatoren können an unerwarteten Stellen angezeigt werden.</font></font> Zum Beispiel <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = f (x)) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruft zuerst die Funktion f auf, weist dann das Ergebnis des Aufrufs der Funktion a zu und </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prüft schließlich, ob es wahr (nicht Null) oder falsch (Null) ist. </font><font style="vertical-align: inherit;">Wenn a ungleich Null ist, ist die Bedingung erfüllt.</font></font> Betreiber <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem wird zuerst der Wert der Variablen b der Variablen a überprüft und dann a geprüft, ob der Wert ungleich Null ist. </font><font style="vertical-align: inherit;">Und dieser Operator ist völlig anders als</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dadurch werden zwei Variablen verglichen und der Operator ausgeführt, wenn sie gleich sind. </font></font><br><br><h3>  Nachwort </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles. </font><font style="vertical-align: inherit;">Sie werden nicht glauben, wie sehr ich es genossen habe, diesen Text vorzubereiten. </font><font style="vertical-align: inherit;">Wie viel ich mich aus derselben C-Sprache als nützlich erinnerte. </font><font style="vertical-align: inherit;">Ich hoffe, auch Sie werden es genießen, in die wunderbare Welt der C-Sprache einzutauchen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464075/">https://habr.com/ru/post/de464075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464053/index.html">Hinweis: Spurauswahl- und Rotationsalgorithmus</a></li>
<li><a href="../de464055/index.html">Wir untersuchen die von Xiaomi Mi Band für das Jahr gesammelten Daten</a></li>
<li><a href="../de464057/index.html">Hilbert, Lebesgue ... und die Leere</a></li>
<li><a href="../de464063/index.html">Kabel 2019 abschneiden</a></li>
<li><a href="../de464071/index.html">Revolution oder Schmerz? Yandex React Hooks-Bericht</a></li>
<li><a href="../de464077/index.html">Nein, Sie brauchen kein Delta mit 50 km / s. Sie benötigen additive Technologien (Teil 1)</a></li>
<li><a href="../de464079/index.html">Wie man ein horizontales Start- und Landungsraumschiff ohne Wundertechnologie baut</a></li>
<li><a href="../de464083/index.html">Wie ITSM hilft und wer diese Methode anwendet</a></li>
<li><a href="../de464089/index.html">Automatisierung von HTTP-Anforderungen im Kontext von Spring</a></li>
<li><a href="../de464091/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 311 (vom 12. bis 18. August)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>