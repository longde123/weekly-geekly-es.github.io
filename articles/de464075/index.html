<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôçÔ∏è üññüèø üôãüèæ Einf√ºhrung in C. Botschaft aus dem letzten Jahrhundert ‚ñ∂Ô∏è üí• üë©üèæ‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vorwort 
 In meinen Kommentaren bezog ich mich mehrmals auf Andrew Tanenbaums Buch Operating Systems Design and Implementation, seine erste Ausgabe, u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in C. Botschaft aus dem letzten Jahrhundert</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464075/"><h3>  Vorwort </h3><br>  In meinen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentaren</a> bezog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich mich</a> mehrmals auf Andrew Tanenbaums Buch Operating Systems Design and Implementation, seine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erste Ausgabe,</a> und wie C darin dargestellt wird.  Und diese Kommentare waren schon immer von Interesse.  Ich entschied, dass es Zeit war, eine √úbersetzung dieser Einf√ºhrung in C zu ver√∂ffentlichen.  Es ist immer noch relevant.  Zwar gibt es sicherlich diejenigen, die noch nichts √ºber die Programmiersprache <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL / 1</a> und vielleicht sogar √ºber das Betriebssystem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minix geh√∂rt haben</a> . <br><br>  Diese Beschreibung ist auch aus historischer Sicht interessant und um zu verstehen, wie weit die C-Sprache seit ihrer Geburt und die IT-Branche insgesamt gegangen ist. <br><a name="habracut"></a><br>  Ich m√∂chte sofort reservieren, dass meine zweite Sprache Franz√∂sisch ist: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/467/5a3/9614675a3883bf417fa2505dada57690.png" alt="Bild"><br><br>  Dies wird jedoch durch 46 Jahre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Programmiererfahrung</a> ausgeglichen. <br>  Also, fangen wir an, Andrew Tanenbaum ist an der Reihe. <br><br><h3>  Einf√ºhrung in die C-Sprache (S. 350 - 362) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png"></div><br><br>  Die Programmiersprache C wurde von Dennis Ritchie von AT &amp; T Bell Laboratories als √ºbergeordnete Programmiersprache f√ºr die Entwicklung des UNIX-Betriebssystems erstellt.  Derzeit ist die Sprache in verschiedenen Bereichen weit verbreitet.  C ist besonders bei Systemprogrammierern beliebt, da Sie damit Programme einfach und pr√§zise schreiben k√∂nnen. <br><br>  Das Hauptbuch, das die C-Sprache beschreibt, ist Brian Kernigan und Dennis Ritchies Buch The C Programming Language (1978).  B√ºcher √ºber die C-Sprache wurden von Bolon (1986), Gehani (1984), Hancock und Krieger (1986), Harbison und Steele (1984) und vielen anderen geschrieben. <br><br>  In diesem Anhang werden wir versuchen, eine ziemlich vollst√§ndige Einf√ºhrung in C zu geben, damit diejenigen, die mit Hochsprachen wie Pascal, PL / 1 oder Modula 2 vertraut sind, den gr√∂√üten Teil des in diesem Buch enthaltenen MINIX-Codes verstehen k√∂nnen.  C-Funktionen, die in MINIX nicht verwendet werden, werden hier nicht behandelt.  Zahlreiche subtile Punkte wurden weggelassen.  Der Schwerpunkt liegt auf dem Lesen von C-Programmen und nicht auf dem Schreiben von Code. <br><br><h3>  A.1.  C Sprachgrundlagen </h3><br>  Ein C-Programm besteht aus einer Reihe von Prozeduren (oft als Funktionen bezeichnet, auch wenn sie keine Werte zur√ºckgeben).  Diese Verfahren enthalten Deklarationen, Operatoren und andere Elemente, die dem Computer gemeinsam mitteilen, was zu tun ist.  Abbildung A-1 zeigt eine kleine Prozedur, bei der drei ganzzahlige Variablen deklariert und Werte zugewiesen werden.  Der Name der Prozedur ist main.  Die Prozedur hat keine formalen Parameter, was durch das Fehlen von Bezeichnern zwischen den Klammern hinter dem Prozedurnamen angezeigt wird.  Der Hauptteil der Prozedur ist in geschweiften Klammern ({}) eingeschlossen.  Dieses Beispiel zeigt, dass C Variablen hat und dass diese Variablen vor der Verwendung deklariert werden m√ºssen.  C hat auch Operatoren, in diesem Beispiel sind dies Zuweisungsoperatoren.  Alle Anweisungen m√ºssen mit einem Semikolon enden (im Gegensatz zu Pascal, bei dem Doppelpunkte zwischen Anweisungen verwendet werden, nicht danach). <br><br>  Kommentare beginnen mit den Zeichen "/ *" und enden mit den Zeichen "* /" und k√∂nnen mehrere Zeilen umfassen. <br><br><pre><code class="cpp hljs">main () <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; <span class="hljs-comment"><span class="hljs-comment">/*  3   */</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  i  10 ( ) */</span></span> j = i + <span class="hljs-number"><span class="hljs-number">015</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  j  i + 015 ( ) */</span></span> k = j * j + <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  k  j * j + 0xFF ( ) */</span></span> } . Al.    .</code> </pre> <br>  Die Prozedur enth√§lt drei Konstanten.  Konstante 10 in der ersten Zuordnung <br>  Es ist eine gew√∂hnliche Dezimalkonstante.  Die 015-Konstante ist eine Oktalkonstante <br>  (gleich 13 in Dezimalzahl).  Oktalkonstanten beginnen immer bei Null.  Die Konstante 0xFF ist eine hexadezimale Konstante (entspricht 255 Dezimalstellen).  Hexadezimale Konstanten beginnen immer mit 0x.  Alle drei Typen werden in C verwendet. <br><br><h3>  A.2.  Grundlegende Datentypen </h3><br>  C hat zwei Haupttypen von Daten (Variablen): eine Ganzzahl und ein Zeichen, die als int bzw. char deklariert sind.  Es gibt keine separate boolesche Variable.  Die int-Variable wird als boolesche Variable verwendet.  Wenn diese Variable 0 enth√§lt, bedeutet dies falsch / falsch, und jeder andere Wert bedeutet wahr / wahr.  C hat auch Gleitkommatypen, aber MINIX verwendet sie nicht. <br><br>  Sie k√∂nnen kurze, lange oder vorzeichenlose ‚ÄûAdjektive‚Äú auf einen int-Typ anwenden, der einen Wertebereich (vom Compiler abh√§ngig) definiert.  Die meisten 8088-Prozessoren verwenden 16-Bit-Ganzzahlen f√ºr int und short int und 32-Bit-Ganzzahlen f√ºr long int.  Ganzzahlen ohne Vorzeichen (int ohne Vorzeichen) auf dem 8088-Prozessor haben einen Bereich von 0 bis 65535 und nicht von -32768 bis +32767, wie dies bei normalen Ganzzahlen (int) der Fall ist.  Ein Zeichen ben√∂tigt 8 Bits. <br><br>  Der Registerspezifizierer ist auch f√ºr int und char zul√§ssig und ist ein Hinweis f√ºr den Compiler, dass die deklarierte Variable im Register abgelegt werden sollte, damit das Programm schneller arbeitet. <br><br>  Einige Anzeigen sind in Abb. 1 dargestellt.  A - 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1, z2; / *    */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag_poll; <span class="hljs-comment"><span class="hljs-comment">/* 'int'    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> . <span class="hljs-number"><span class="hljs-number">-2.</span></span>  .</code> </pre> <br>  Die Konvertierung zwischen Typen ist zul√§ssig.  Zum Beispiel der Bediener <br><br><pre> <code class="cpp hljs">flag_pole = i;</code> </pre> <br>  erlaubt, auch wenn i vom Typ int ist und flag_pole lang ist.  In vielen F√§llen <br>  Es ist notwendig oder n√ºtzlich, Konvertierungen zwischen Datentypen zu erzwingen.  F√ºr die erzwungene Konvertierung reicht es aus, den Zieltyp in Klammern vor dem Ausdruck f√ºr die Konvertierung zu setzen.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"> ( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) i);</code> </pre> <br>  weist an, die Ganzzahl i in long zu konvertieren, bevor sie als Parameter an die Prozedur p √ºbergeben wird, die den long-Parameter erwartet. <br><br>  Achten Sie beim Konvertieren zwischen Typen auf das Zeichen. <br>  Bei der Konvertierung eines Zeichens in eine Ganzzahl behandeln einige Compiler Zeichen als signiert, dh von - 128 bis +127, w√§hrend andere sie als behandeln <br>  vorzeichenlos, dh von 0 bis 255. In MINIX sind Ausdr√ºcke wie <br><br><pre> <code class="cpp hljs">i = c &amp; <span class="hljs-number"><span class="hljs-number">0377</span></span>;</code> </pre> <br>  Dies konvertiert von (Zeichen) in eine Ganzzahl und f√ºhrt dann ein logisches UND aus <br>  (kaufm√§nnisches Und) mit der Oktalkonstante 0377. Das Ergebnis ist, dass die hohen 8 Bits <br>  werden auf Null gesetzt, wodurch c gezwungen wird, als vorzeichenlose 8-Bit-Zahl im Bereich von 0 bis 255 betrachtet zu werden. <br><br><h3>  A.3.  Verbindungstypen und Zeiger </h3><br>  In diesem Abschnitt werden vier M√∂glichkeiten zum Erstellen komplexerer Datentypen beschrieben: Arrays, Strukturen, Vereinigungen und Zeiger.  Ein Array ist eine Sammlung / Menge von Elementen desselben Typs.  Alle Arrays in C beginnen mit Element 0. <br><br>  Ank√ºndigung <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a [<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br>  deklariert ein Array a mit 10 Ganzzahlen, die in den Elementen des Arrays von [0] bis a [9] gespeichert werden sollen.  Zweitens k√∂nnen Arrays drei oder mehr Dimensionen haben, werden jedoch in MINIX nicht verwendet. <br>  Eine Struktur ist eine Sammlung von Variablen, normalerweise verschiedener Typen.  Die Struktur in C √§hnelt der Aufzeichnung in Pascal.  Betreiber <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} s;</code> </pre> <br>  deklariert s als eine Struktur, die zwei Elemente enth√§lt, die Ganzzahl i und das Zeichen c. <br><br>  Um das Mitglied i der Struktur s 6 zuzuweisen, schreiben Sie den folgenden Ausdruck: <br><br><pre> <code class="cpp hljs">si = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  wobei der Punktoperator angibt, dass das Element i zur Struktur s geh√∂rt. <br>  Eine Gewerkschaft ist auch eine Gruppe von Mitgliedern, √§hnlich einer Struktur, mit der Ausnahme, dass zu jedem Zeitpunkt nur einer von ihnen einer Gewerkschaft angeh√∂ren kann.  Ank√ºndigung <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} u;</code> </pre> <br>  bedeutet, dass Sie eine Ganzzahl oder ein Zeichen haben k√∂nnen, aber nicht beide.  Der Compiler sollte gen√ºgend Platz zum Kombinieren reservieren, damit er das gr√∂√üte (aus Sicht des belegten Speichers) Kombinationselement aufnehmen kann.  Vereinigungen werden in MINIX nur an zwei Stellen verwendet (um eine Nachricht als Vereinigung mehrerer verschiedener Strukturen zu definieren und um einen Plattenblock als Vereinigung eines Datenblocks, eines i-Node-Blocks, eines Katalogblocks usw. zu definieren). <br><br>  Zeiger werden verwendet, um Maschinenadressen in C zu speichern.  Sie werden sehr, sehr oft verwendet.  Ein Sternchen (*) kennzeichnet einen Zeiger in Anzeigen.  Ank√ºndigung <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, *pi, a [<span class="hljs-number"><span class="hljs-number">10</span></span>], *b[<span class="hljs-number"><span class="hljs-number">10</span></span>], **ppi;</code> </pre> <br>  deklariert eine Ganzzahl i, einen Zeiger auf eine Ganzzahl pi, ein Array a mit 10 Elementen, ein Array b mit 10 Zeigern auf Ganzzahlen und einen Zeiger auf einen Zeiger ppi auf eine Ganzzahl. <br><br>  Die genauen Syntaxregeln f√ºr komplexe Deklarationen, die Arrays, Zeiger und andere Typen kombinieren, sind etwas komplex.  Gl√ºcklicherweise verwendet MINIX nur einfache Deklarationen. <br><br>  Abbildung A-3 zeigt die Deklaration eines Arrays z von Strukturtabellenstrukturen, von denen jede hat <br>  drei Mitglieder, Ganzzahl i, Zeiger cp auf Zeichen und Zeichen c. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; / *  */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, c; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } z [<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    20  */</span></span> .  - <span class="hljs-number"><span class="hljs-number">3.</span></span>  .</code> </pre> <br>  Arrays von Strukturen sind in MINIX √ºblich.  Ferner kann die Namenstabelle als Strukturtabellenstruktur deklariert werden, die in nachfolgenden Deklarationen verwendet werden kann.  Zum Beispiel <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  deklariert p als Zeiger auf eine Strukturtabellenstruktur und schl√§gt vor, diese zu speichern <br>  im Register.  W√§hrend der Programmausf√ºhrung kann p beispielsweise z [4] oder anzeigen <br>  zu jedem anderen Element in z, von dem alle 20 Elemente Strukturen vom Typ Strukturtabelle sind. <br><br>  Um p zu einem Zeiger auf z [4] zu machen, schreiben Sie einfach <br><br><pre> <code class="cpp hljs">p = &amp;z[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br>  wobei das kaufm√§nnische Und als un√§rer (monadischer) Operator bedeutet "nimm die Adresse dessen, was darauf folgt".  Kopieren Sie den Wert von Element i in die Ganzzahlvariable n <br>  Die Struktur, auf die p zeigt, kann wie folgt ausgef√ºhrt werden: <br><br><pre> <code class="cpp hljs">n = p-&gt;i;</code> </pre> <br>  Beachten Sie, dass der Pfeil verwendet wird, um √ºber einen Zeiger auf ein Mitglied der Struktur zuzugreifen.  Wenn wir die Variable z verwenden, m√ºssen wir den Punktoperator verwenden: <br><br><pre> <code class="cpp hljs">n = z [<span class="hljs-number"><span class="hljs-number">4</span></span>] .i;</code> </pre> <br>  Der Unterschied besteht darin, dass z [4] eine Struktur ist und der Punktoperator die Elemente ausw√§hlt <br>  von zusammengesetzten Typen (Strukturen, Arrays) direkt.  Mithilfe von Zeigern w√§hlen wir keinen Teilnehmer direkt aus.  Der Zeiger weist an, zuerst eine Struktur und erst dann ein Mitglied dieser Struktur auszuw√§hlen. <br><br>  Manchmal ist es praktisch, einem zusammengesetzten Typ einen Namen zu geben.  Zum Beispiel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unshort;</code> </pre> <br>  definiert unshort als unsigned short (unsigned short integer).  Jetzt kann unshort im Programm als Haupttyp verwendet werden.  Zum Beispiel <br><br><pre> <code class="cpp hljs">unshort ul, *u2, u3[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  deklariert eine kurze vorzeichenlose Ganzzahl, einen Zeiger auf eine kurze vorzeichenlose Ganzzahl und <br>  ein Array von kurzen Ganzzahlen ohne Vorzeichen. <br><br><h3>  A.4.  Betreiber </h3><br>  Prozeduren in C enthalten Erkl√§rungen und Anweisungen.  Wir haben die Erkl√§rungen bereits gesehen, daher werden wir jetzt die Operatoren betrachten.  Der Zweck der Bedingungs- und Schleifenoperatoren ist im Wesentlichen der gleiche wie in anderen Sprachen.  Abbildung A - 4 zeigt einige Beispiele daf√ºr.  Das einzige, worauf Sie achten sollten, ist, dass geschweifte Klammern verwendet werden, um Operatoren zu gruppieren, und die while-Anweisung hat zwei Formen, von denen die zweite der Wiederholungsanweisung von Pascal √§hnlich ist. <br><br>  C hat auch eine for-Anweisung, sieht aber in keiner anderen Sprache wie eine for-Anweisung aus.  Die for-Anweisung hat die folgende Form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (&lt;&gt;; &lt;&gt;; &lt;&gt;) ;</code> </pre> <br>  Dasselbe kann durch die while-Anweisung ausgedr√ºckt werden: <br><br><pre> <code class="cpp hljs">&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(&lt;&gt;) { &lt;&gt;; &lt;&gt; }</code> </pre> <br>  Betrachten Sie als Beispiel die folgende Aussage: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;n; i = i+l) a[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Dieser Operator setzt die ersten n Elemente des Arrays a auf Null.  Die Ausf√ºhrung des Operators beginnt mit dem Setzen von i auf Null (dies erfolgt au√üerhalb der Schleife).  Dann wird der Operator wiederholt, bis i &lt;n ist, w√§hrend die Zuweisung und Erh√∂hung von i durchgef√ºhrt wird.  Anstelle des Operators, dem aktuellen Element eines Null-Arrays einen Wert zuzuweisen, kann nat√ºrlich ein zusammengesetzter Operator (Block) in geschweiften Klammern stehen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) k = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) { <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j + l, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;y) { <span class="hljs-comment"><span class="hljs-comment">/*  if-else */</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  while */</span></span> k = k + k; n = n - l; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { / *    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> */ k = k + k; n = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); . A<span class="hljs-number"><span class="hljs-number">-4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>  C.</code> </pre> <br>  C hat auch einen Operator √§hnlich dem Falloperator in Pascal.  Dies ist eine switch-Anweisung.  Ein Beispiel ist in Abbildung A-5 dargestellt.  Abh√§ngig vom Wert des in switch angegebenen Ausdrucks wird die eine oder andere case-Anweisung ausgew√§hlt. <br><br>  Wenn der Ausdruck keiner der case-Anweisungen entspricht, wird die Standardanweisung ausgew√§hlt. <br><br>  Wenn der Ausdruck keiner case-Anweisung zugeordnet ist und die Standardanweisung fehlt, wird die Ausf√ºhrung ab der n√§chsten Anweisung nach der switch-Anweisung fortgesetzt. <br><br>  Es ist zu beachten, dass Sie die break-Anweisung verwenden, um den case-Block zu verlassen.  Wenn keine break-Anweisung vorhanden ist, wird der n√§chste case-Block ausgef√ºhrt. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (k) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   case 20, ..    switch */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>: i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; / *   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>* / <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: j = <span class="hljs-number"><span class="hljs-number">5</span></span>; } . A<span class="hljs-number"><span class="hljs-number">-5.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span></code> </pre> <br>  Die break-Anweisung wirkt auch innerhalb der for- und while-Schleifen.  Es ist zu beachten, dass die Ausgabe nur eine Ebene h√∂her ist, wenn sich die break-Anweisung in einer Reihe verschachtelter Schleifen befindet. <br><br>  Eine verwandte Anweisung ist die continue-Anweisung, die die Schleife nicht verl√§sst. <br>  bewirkt jedoch den Abschluss der aktuellen Iteration und den Beginn der n√§chsten Iteration <br>  sofort.  Dies ist im Wesentlichen eine R√ºckkehr zum Anfang der Schleife. <br><br>  C verf√ºgt √ºber Prozeduren, die mit oder ohne Parameter aufgerufen werden k√∂nnen. <br>  Laut Kernigan und Ritchie (S. 121) ist es nicht gestattet, Arrays zu √ºbertragen. <br>  Strukturen oder Prozeduren als Parameter, obwohl Zeiger auf all dies √ºbergeben werden <br>  erlaubt.  Gibt es ein Buch oder nicht (es wird in meinem Ged√§chtnis auftauchen: - ‚ÄûWenn es Leben auf dem Mars gibt, wenn es kein Leben auf dem Mars gibt‚Äú), erlauben viele C-Compiler Strukturen als Parameter. <br>  Der Name des Arrays bedeutet, wenn er ohne Index geschrieben ist, einen Zeiger auf ein Array, was die √úbertragung eines Array-Zeigers vereinfacht.  Wenn also a der Name eines Arrays eines beliebigen Typs ist, kann es durch Schreiben an g √ºbergeben werden <br><br><pre> <code class="cpp hljs">g();</code> </pre> <br>  Diese Regel gilt nur f√ºr Arrays, diese Regel gilt nicht f√ºr Strukturen. <br>  Prozeduren k√∂nnen Werte zur√ºckgeben, indem sie eine return-Anweisung ausf√ºhren.  Diese Anweisung kann einen Ausdruck enthalten, dessen Ergebnis als Wert der Prozedur zur√ºckgegeben wird, aber der Aufrufer kann den R√ºckgabewert sicher ignorieren.  Wenn die Prozedur einen Wert zur√ºckgibt, wird der Typwert vor den Prozedurnamen geschrieben, wie in Abb.  A-6.  Prozeduren k√∂nnen wie Parameter keine Arrays, Strukturen oder Prozeduren zur√ºckgeben, sondern Zeiger darauf zur√ºckgeben.  Diese Regel ist f√ºr eine effizientere Implementierung ausgelegt - alle Parameter und Ergebnisse entsprechen immer einem Maschinenwort (in dem die Adresse gespeichert ist).  Compiler, die die Verwendung von Strukturen als Parameter erm√∂glichen, erm√∂glichen normalerweise auch deren Verwendung als R√ºckgabewerte. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i, j </span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i + j); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } . <span class="hljs-number"><span class="hljs-number">-6.</span></span>   ,   .</code> </pre> <br>  C hat keine eingebauten E / A.  Die Eingabe / Ausgabe wird durch Aufrufen von Bibliotheksfunktionen implementiert, von denen die h√§ufigsten unten dargestellt sind: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (¬´x=% dy = %oz = %x \n¬ª, x, y, z);</code> </pre> <br>  Der erste Parameter ist die Zeichenfolge zwischen Anf√ºhrungszeichen (tats√§chlich ist dies ein Array von Zeichen). <br><br>  Jedes Zeichen, das kein Prozentsatz ist, wird einfach so gedruckt, wie es ist. <br><br>  Wenn ein Prozentsatz auftritt, wird der folgende Parameter in der Form gedruckt, die durch den Buchstaben nach dem Prozentsatz definiert ist: <br><blockquote>  d - Drucken als Dezimalzahl <br>  o - als oktale Ganzzahl drucken <br>  u - Drucken als vorzeichenlose Dezimalzahl <br>  x - als hexadezimale Ganzzahl drucken <br>  s - als Zeichenfolge drucken <br>  c - als ein Zeichen drucken </blockquote>  Die Buchstaben D, 0 und X sind auch f√ºr den Dezimal-, Oktal- und Hexadezimaldruck langer Zahlen zul√§ssig. <br><br><h3>  A.5.  Ausdr√ºcke </h3><br>  Ausdr√ºcke werden durch Kombinieren von Operanden und Operatoren erstellt. <br><br>  Arithmetische Operatoren wie + und - und Vergleichsoperatoren wie &lt; <br>  und&gt; √§hnlich wie ihre Gegenst√ºcke in anderen Sprachen.  % Operator <br>  Modulo verwendet.  Es ist erw√§hnenswert, dass der Gleichheitsoperator == ist und der Ungleichheitsoperator!  =.  Um zu √ºberpr√ºfen, ob a und b gleich sind, k√∂nnen Sie wie folgt schreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;&gt;;</code> </pre> <br>  Mit C k√∂nnen Sie den Zuweisungsoperator daher auch mit anderen Operatoren kombinieren <br><br><pre> <code class="cpp hljs">a += <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  entspricht der Aufnahme <br><br><pre> <code class="cpp hljs"> =  + <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  Auf diese Weise k√∂nnen auch andere Operatoren kombiniert werden. <br><br>  C hat Operatoren zum Bearbeiten von Wortbits.  Sowohl Verschiebungen als auch bitweise logische Operationen sind zul√§ssig.  Die linken und rechten Schichtoperatoren sind &lt;&lt; <br>  bzw. &gt;&gt;.  Bitweise logische Operatoren &amp;, |  und ^, die logisches UND (UND) sind, einschlie√ülich ODER (ODER) bzw. exklusives ODER (XOP).  Wenn i den Wert 035 (oktal) hat, hat der Ausdruck i &amp; 06 den Wert 04 (oktal).  Ein anderes Beispiel, wenn i = 7, dann <br><br><pre> <code class="cpp hljs">j = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">014</span></span>;</code> </pre> <br>  und bekomme 074 f√ºr j. <br>  Eine weitere wichtige Gruppe von Operatoren sind un√§re Operatoren, von denen jeder nur einen Operanden akzeptiert.  Als un√§rer Operator erh√§lt kaufm√§nnisches Und &amp; die Adresse einer Variablen. <br><br>  Wenn p ein Zeiger auf eine ganze Zahl ist und i eine ganze Zahl ist, der Operator <br><br><pre> <code class="cpp hljs">p = &amp;i;</code> </pre> <br>  berechnet die Adresse i und speichert sie in der Variablen p. <br>  Das Gegenteil von einer Adresse ist ein Operator, der einen Zeiger als Eingabe verwendet und den Wert an dieser Adresse berechnet.  Wenn wir dem Zeiger p gerade die Adresse i zugewiesen haben, hat * p die gleiche Bedeutung wie i. <br><br>  Mit anderen Worten, als un√§rer Operator folgt auf ein Sternchen ein Zeiger (oder <br>  Ausdruck mit einem Zeiger) und gibt den Wert des Elements zur√ºck, auf das es zeigt.  Wenn i einen Wert von 6 hat, dann der Operator <br><br><pre> <code class="cpp hljs">j = *;</code> </pre> <br>  wird j die Nummer 6 zuweisen. <br>  Der Betreiber!  (das Ausrufezeichen ist der Negationsoperator) gibt 0 zur√ºck, wenn sein Operand ungleich Null ist, und 1, wenn sein Operator 0 ist. <br><br>  Es wird zum Beispiel haupts√§chlich in if-Anweisungen verwendet <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) k=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  pr√ºft den Wert von x.  Wenn x Null (falsch) ist, wird k der Wert 0 zugewiesen. Eigentlich ist der Operator!  bricht die darauf folgende Bedingung ab, genau wie der Operator not in Pascal. <br><br>  Der Operator ~ ist ein bitweiser Komplementoperator.  Jede 0 in ihrem Operanden <br>  wird 1 und jede 1 wird 0. <br><br>  Der Operator sizeof gibt die Gr√∂√üe seines Operanden in Bytes an.  In Bezug auf <br>  Ein Array von 20 Ganzzahlen a auf einem Computer mit 2-Byte-Ganzzahlen, z. B. Gr√∂√üe von a, hat einen Wert von 40. <br><br>  Die letzte Gruppe von Operatoren sind die Operatoren f√ºr Zunahme und Abnahme. <br><br>  Betreiber <br><br><pre> <code class="cpp hljs">++;</code> </pre> <br>  bedeutet eine Erh√∂hung von p.  Wie viel p zunimmt, h√§ngt von seinem Typ ab. <br>  Ganzzahlen oder Zeichen werden um 1 erh√∂ht, Zeiger jedoch um 1 <br>  die Gr√∂√üe des Objekts, auf das auf diese Weise gezeigt wird, wenn a ein Array von Strukturen ist und p ein Zeiger auf eine dieser Strukturen ist, und wir schreiben <br><br><pre> <code class="cpp hljs">p = &amp;a[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br>  um p auf eine der Strukturen im Array zu zeigen, dann nach dem Erh√∂hen von p <br>  zeigt auf a [4], egal wie gro√ü die Strukturen sind.  Betreiber <br><br><pre> <code class="cpp hljs">p--;</code> </pre> <br>  √§hnlich dem p ++ - Operator, au√üer dass der Wert des Operanden eher verringert als erh√∂ht wird. <br><br>  In Aussage <br><br><pre> <code class="cpp hljs">n = k++;</code> </pre> <br>  Wenn beide Variablen ganze Zahlen sind, wird der urspr√ºngliche Wert von k n und zugewiesen <br>  erst dann steigt k an.  In Aussage <br><br><pre> <code class="cpp hljs">n = ++ k;</code> </pre> <br>  k steigt zuerst an, dann wird sein neuer Wert in n gespeichert. <br><br>  Somit kann ein ++ (oder -) Operator vor oder nach seinem Operanden geschrieben werden, was zu verschiedenen Werten f√ºhrt. <br><br>  Die letzte Aussage ist das?  (Fragezeichen), das eine von zwei Alternativen ausw√§hlt <br>  durch einen Doppelpunkt getrennt.  Zum Beispiel ein Operator, <br><br><pre> <code class="cpp hljs">i = (x &lt; y ? <span class="hljs-number"><span class="hljs-number">6</span></span> : k + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  vergleicht x mit y.  Wenn x kleiner als y ist, bekomme ich den Wert 6;  Andernfalls erh√§lt die Variable i den Wert k + 1. Die Klammern sind optional. <br><br><h3>  A.6.  Programmstruktur </h3><br>  Ein C-Programm besteht aus einer oder mehreren Dateien, die Prozeduren und Deklarationen enthalten. <br>  Diese Dateien k√∂nnen einzeln zu Objektdateien kompiliert werden, die dann (mithilfe des Linkers) miteinander verkn√ºpft werden, um ein ausf√ºhrbares Programm zu bilden. <br>  Im Gegensatz zu Pascal k√∂nnen Prozedurdeklarationen nicht verschachtelt werden, daher werden alle auf der ‚Äûobersten Ebene‚Äú in der Programmdatei geschrieben. <br><br>  Es ist zul√§ssig, Variablen au√üerhalb der Prozeduren zu deklarieren, z. B. am Anfang der Datei vor der ersten Deklaration der Prozedur.  Diese Variablen sind global und k√∂nnen in jeder Prozedur im gesamten Programm verwendet werden, es sei denn, das statische Schl√ºsselwort steht vor der Deklaration.  In diesem Fall k√∂nnen diese Variablen nicht in einer anderen Datei verwendet werden.  Die gleichen Regeln gelten f√ºr Verfahren.  Innerhalb einer Prozedur deklarierte Variablen sind lokal f√ºr die Prozedur. <br>  Die Prozedur kann auf die in einer anderen Datei deklarierte Ganzzahlvariable v zugreifen (vorausgesetzt, die Variable ist nicht statisch) und sie als extern deklarieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v;</code> </pre> <br>  Jede globale Variable muss genau einmal ohne das Attribut extern deklariert werden, um Speicher daf√ºr zuzuweisen. <br><br>  Variablen k√∂nnen initialisiert werden, wenn sie deklariert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Arrays und Strukturen k√∂nnen ebenfalls initialisiert werden.  Globale Variablen, die nicht explizit initialisiert werden, erhalten den Standardwert Null. <br><br><h3>  A.7.  C Pr√§prozessor </h3><br>  Bevor die Quelldatei an den C-Compiler √ºbertragen wird, wird sie automatisch verarbeitet <br>  ein Programm namens Pr√§prozessor.  Es ist die Ausgabe des Pr√§prozessors, nicht <br>  Das urspr√ºngliche Programm wird dem Eingang des Compilers zugef√ºhrt.  Pr√§prozessor f√ºhrt aus <br>  Drei grundlegende Konvertierungen in einer Datei, bevor sie an den Compiler √ºbergeben werden: <br><br>  1. Aufnahme von Dateien. <br>  2. Definition und Ersetzung von Makros. <br>  3. Bedingte Kompilierung. <br><br>  Alle Pr√§prozessoranweisungen beginnen mit einem Nummernzeichen (#) in der 1. Spalte. <br>  Bei einer Ansichtsrichtlinie <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prog.h"</span></span></span></span></code> </pre> <br>  Vom Pr√§prozessor erf√ºllt, enth√§lt es die Datei prog.h Zeile f√ºr Zeile in <br>  das Programm, das an den Compiler √ºbergeben werden soll.  Wenn die Direktive #include als geschrieben ist <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;prog.h&gt;</span></span></span></span></code> </pre> <br>  Anschlie√üend wird die enthaltene Datei im Verzeichnis / usr / include anstelle des Arbeitsverzeichnisses durchsucht.  In C ist es √ºblich, die von mehreren Dateien verwendeten Deklarationen in einer Header-Datei (normalerweise mit dem Suffix .h) zu gruppieren und gegebenenfalls einzuschlie√üen. <br>  Der Pr√§prozessor erlaubt auch Makrodefinitionen.  Zum Beispiel <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 1024</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert das BLOCK_SIZE-Makro und weist ihm den Wert 1024 zu. Von nun an wird </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedes Vorkommen einer Zeichenfolge mit 10 Zeichen "BLOCK_SIZE" in der Datei </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durch eine 4- </font><font style="vertical-align: inherit;">stellige </font><font style="vertical-align: inherit;">Zeichenfolge "1024" ersetzt, bevor der Compiler die Datei mit dem Programm sieht. Konventionell werden Makronamen in Gro√übuchstaben geschrieben. Makros k√∂nnen Parameter haben, in der Praxis jedoch nur wenige. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das dritte Merkmal des Pr√§prozessors ist die bedingte Kompilierung. MINIX verf√ºgt √ºber mehrere </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen, an denen Code speziell f√ºr den 8088-Prozessor geschrieben wurde. Dieser Code sollte beim Kompilieren f√ºr einen anderen Prozessor nicht ber√ºcksichtigt werden. Diese Abschnitte sehen folgenderma√üen aus:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> i8088 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;   8088&gt; #endif</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn das Zeichen i8088 definiert ist, sind die Anweisungen zwischen den beiden Pr√§prozessoranweisungen #ifdef i8088 und #endif in der Pr√§prozessorausgabe enthalten. </font><font style="vertical-align: inherit;">Andernfalls werden sie √ºbersprungen. </font><font style="vertical-align: inherit;">Aufruf des Compilers mit dem Befehl</font></font><br><br><pre> <code class="cpp hljs">cc -c -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder durch Aufnahme einer Anweisung in das Programm </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> i8088</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir definieren das Symbol i8088, damit alle abh√§ngigen Codes f√ºr 8088 enthalten sind. </font><font style="vertical-align: inherit;">W√§hrend der Entwicklung von MINIX wird m√∂glicherweise spezieller Code f√ºr 68000er und andere Prozessoren erworben, die ebenfalls verarbeitet werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Betrachten Sie als Beispiel f√ºr die Funktionsweise des Pr√§prozessors das Programm Abb. </font><font style="vertical-align: inherit;">A-7 (a). </font><font style="vertical-align: inherit;">Es enth√§lt eine prog.h-Datei, deren Inhalt wie folgt lautet:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXAELEMENTS 100</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stellen Sie sich vor, der Compiler wurde von einem Befehl aufgerufen </font></font><br><br><pre> <code class="bash hljs">cc -E -Di8088 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem die Datei den Pr√§prozessor durchlaufen hat, erfolgt die Ausgabe wie in Abb. </font><font style="vertical-align: inherit;">A-7 (b). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist diese Ausgabe und nicht die Quelldatei, die als Eingabe an den C-Compiler √ºbergeben wird.</font></font><br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include prog.h int x; main () main (); { { int a[MAX_ELEMENTS]; int a [100];  = 4;  = 4; a[x] = 6; [] = 6; #ifdef i8088 printf("8088. a[x]:% d\n", a[x]); printf ("8088. a[x]:% d\n", a[x]); #endif } #ifdef m68000 printf ("68000. x=%d\n", x); #endif } () (b) . -7. (a)   prog.c. (b)  .</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beachten Sie, dass der Pr√§prozessor seine Arbeit erledigt und alle Zeilen gel√∂scht hat, die mit dem # -Zeichen beginnen. </font><font style="vertical-align: inherit;">Wenn der Compiler so aufgerufen w√ºrde</font></font><br><br><pre> <code class="bash hljs">cc -c -Dm68000 prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann w√§re ein weiterer Druck enthalten. </font><font style="vertical-align: inherit;">Wenn es so hei√üen w√ºrde:</font></font><br><br><pre> <code class="bash hljs">cc -c prog.c</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann w√§re kein Druck enthalten. </font><font style="vertical-align: inherit;">(Der Leser kann dar√ºber nachdenken, was passieren w√ºrde, wenn der Compiler mit beiden Flags -D-Flags aufgerufen w√ºrde.)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A.8. </font><font style="vertical-align: inherit;">Redewendungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Abschnitt werden einige Konstrukte betrachtet, die typisch f√ºr C sind, aber in anderen Programmiersprachen nicht √ºblich sind. </font><font style="vertical-align: inherit;">Betrachten Sie zun√§chst die Schleife:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = *q++;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Variablen p und q sind normalerweise Zeichenzeiger, und n ist ein Z√§hler. </font><font style="vertical-align: inherit;">Die Schleife kopiert die n-Zeichenfolge von wo q zeigt auf wo p zeigt. </font><font style="vertical-align: inherit;">Bei jeder Iteration der Schleife nimmt der Z√§hler ab, bis er 0 erreicht, und jeder der Zeiger nimmt zu, so dass sie nacheinander auf Speicherzellen mit einer h√∂heren Zahl zeigen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein weiteres g√§ngiges Design:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies setzt die ersten N Elemente von a auf 0. Eine alternative M√∂glichkeit, diese Schleife zu schreiben, ist wie folgt: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; p &lt; &amp;a[N]; p++) *p = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Anweisung wird der ganzzahlige Zeiger p so initialisiert, dass er auf das Nullelement des Arrays zeigt. </font><font style="vertical-align: inherit;">Die Schleife wird fortgesetzt, bis p die Adresse des N-ten Elements des Arrays erreicht. </font><font style="vertical-align: inherit;">Ein Zeigerkonstrukt ist viel effizienter als ein Arraykonstrukt und wird daher normalerweise verwendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisungsoperatoren k√∂nnen an unerwarteten Stellen angezeigt werden.</font></font> Zum Beispiel <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = f (x)) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ruft zuerst die Funktion f auf, weist dann das Ergebnis des Aufrufs der Funktion a zu und </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√ºft schlie√ülich, ob es wahr (nicht Null) oder falsch (Null) ist. </font><font style="vertical-align: inherit;">Wenn a ungleich Null ist, ist die Bedingung erf√ºllt.</font></font> Betreiber <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem wird zuerst der Wert der Variablen b der Variablen a √ºberpr√ºft und dann a gepr√ºft, ob der Wert ungleich Null ist. </font><font style="vertical-align: inherit;">Und dieser Operator ist v√∂llig anders als</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;  &gt;;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dadurch werden zwei Variablen verglichen und der Operator ausgef√ºhrt, wenn sie gleich sind. </font></font><br><br><h3>  Nachwort </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles. </font><font style="vertical-align: inherit;">Sie werden nicht glauben, wie sehr ich es genossen habe, diesen Text vorzubereiten. </font><font style="vertical-align: inherit;">Wie viel ich mich aus derselben C-Sprache als n√ºtzlich erinnerte. </font><font style="vertical-align: inherit;">Ich hoffe, auch Sie werden es genie√üen, in die wunderbare Welt der C-Sprache einzutauchen.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464075/">https://habr.com/ru/post/de464075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464053/index.html">Hinweis: Spurauswahl- und Rotationsalgorithmus</a></li>
<li><a href="../de464055/index.html">Wir untersuchen die von Xiaomi Mi Band f√ºr das Jahr gesammelten Daten</a></li>
<li><a href="../de464057/index.html">Hilbert, Lebesgue ... und die Leere</a></li>
<li><a href="../de464063/index.html">Kabel 2019 abschneiden</a></li>
<li><a href="../de464071/index.html">Revolution oder Schmerz? Yandex React Hooks-Bericht</a></li>
<li><a href="../de464077/index.html">Nein, Sie brauchen kein Delta mit 50 km / s. Sie ben√∂tigen additive Technologien (Teil 1)</a></li>
<li><a href="../de464079/index.html">Wie man ein horizontales Start- und Landungsraumschiff ohne Wundertechnologie baut</a></li>
<li><a href="../de464083/index.html">Wie ITSM hilft und wer diese Methode anwendet</a></li>
<li><a href="../de464089/index.html">Automatisierung von HTTP-Anforderungen im Kontext von Spring</a></li>
<li><a href="../de464091/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 311 (vom 12. bis 18. August)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>