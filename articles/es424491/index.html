<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ñ´Ô∏è üåì üïô Mapas del hex√°gono de la unidad: asperezas, r√≠os y caminos üì† üòº üíáüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes 1-3: malla, colores y alturas de celda 

 Partes 4-7: baches, r√≠os y caminos 

 Partes 8-11: agua, accidentes geogr√°ficos y murallas 

 Partes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mapas del hex√°gono de la unidad: asperezas, r√≠os y caminos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424491/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/b6b/8a9/716b6b8a9d024dc87b2d645b5d4bdbb6.jpg" alt="imagen"></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 1-3: malla, colores y alturas de celda</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 4-7: baches, r√≠os y caminos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 8-11: agua, accidentes geogr√°ficos y murallas</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 12-15: guardar y cargar, texturas, distancias</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 16-19: encontrar el camino, escuadrones de jugadores, animaciones</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 20-23: niebla de guerra, investigaci√≥n de mapas, generaci√≥n de procedimientos</a> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Partes 24-27: ciclo del agua, erosi√≥n, biomas, mapa cil√≠ndrico</a> <br><br><h1>  Parte 4: Rugosidades </h1><br><h2>  Tabla de contenidos </h2><br><ul><li>  Muestra la textura del ruido. </li><li>  Mueve los v√©rtices. </li><li>  Preservamos la planeidad de las c√©lulas. </li><li>  Subdividir los bordes de las celdas. </li></ul><br>  Si bien nuestra cuadr√≠cula era un patr√≥n estricto de panales.  En esta parte, agregaremos protuberancias para que el mapa se vea m√°s natural. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/034/982/e33034982aafb942e1e656b76dde0981.png"></div><br>  <i>No m√°s ni siquiera hex√°gonos.</i> <br><br><h2>  El ruido </h2><br>  Para agregar protuberancias, necesitamos aleatorizaci√≥n, pero no aleatoriedad verdadera.  Queremos que todo sea consistente al cambiar el mapa.  De lo contrario, cuando realice alg√∫n cambio, los objetos saltar√°n.  Es decir, necesitamos alguna forma de ruido pseudoaleatorio reproducible. <br><br>  Un buen candidato es el ruido de Perlin.  Es reproducible en cualquier lugar.  Cuando se combinan varias frecuencias, tambi√©n crea ruido, que puede variar mucho a grandes distancias, pero permanece casi igual a distancias peque√±as.  Gracias a esto, se pueden crear distorsiones relativamente suaves.  Los puntos adyacentes entre s√≠ generalmente permanecen cerca y no est√°n dispersos en direcciones opuestas. <br><br>  Podemos generar ruido de Perlin mediante programaci√≥n.  En el tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ruido</a> , explico c√≥mo hacer esto.  Pero tambi√©n podemos tomar muestras de una textura de ruido pregenerada.  La ventaja de usar textura es que es m√°s simple y mucho m√°s r√°pido que calcular el ruido de m√∫ltiples frecuencias de Perlin.  Su desventaja es que la textura ocupa m√°s memoria y cubre solo un √°rea peque√±a de ruido.  Por lo tanto, debe estar perfectamente conectado y ser lo suficientemente grande como para que la repetici√≥n no sea sorprendente. <br><br><h3>  Textura de ruido </h3><br>  Usaremos la textura, por lo que el tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ruido</a> es opcional.  Entonces necesitamos una textura.  Aqu√≠ esta: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbd/8e8/5d7/fbd8e85d783626c737decd6bc69a2519.png"></div><br>  <i>Conecte perfectamente la textura de ruido perlin.</i> <br><br>  La textura que se muestra arriba contiene el ruido de frecuencias m√∫ltiples perfectamente acoplado de Perlin.  Esta es una imagen en escala de grises.  Su valor promedio es 0.5, y los valores extremos tienden a 0 y 1. <br><br>  Pero espera, solo hay un valor para cada punto.  Si necesitamos distorsi√≥n 3D, ¬°entonces necesitamos al menos tres muestras pseudoaleatorias!  Por lo tanto, necesitamos dos texturas m√°s con ruido diferente. <br><br>  Podemos crearlos o almacenar diferentes valores de ruido en cada uno de los canales de color.  Esto nos permitir√° almacenar hasta cuatro patrones de ruido en una textura.  Aqu√≠ est√° esta textura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/509/aca/a1d509acaf05d64de002829afc59cb90.png"></div><br>  <i>Cuatro en uno</i> <br><br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo crear tal textura?</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Us√© NumberFlow</a> .  Este es el editor de texturas de procedimiento que cre√© para Unity. </div></div><br>  Descarga esta textura e imp√≥rtala en tu proyecto de Unity.  Como vamos a muestrear la textura a trav√©s del c√≥digo, deber√≠a ser legible.  Cambie <em>Tipo de textura</em> a <em>Avanzado</em> y habilite <em>Lectura / Escritura habilitada</em> .  Esto guardar√° los datos de textura en la memoria y se puede acceder desde el c√≥digo C #.  Establezca <em>Formato</em> en <em>Truecolor autom√°tico</em> ; de lo contrario, nada funcionar√°.  No queremos que la compresi√≥n de textura destruya nuestro patr√≥n de ruido. <br><br>  Puede deshabilitar <em>Generar mapas Mip</em> , porque no los necesitamos.  Tambi√©n habilite <em>Bypass sRGB Sampling</em> .  No necesitaremos esto, pero ser√° as√≠.  Este par√°metro indica que la textura no contiene datos de color en el espacio gamma. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/c36/e45/3aac36e45d7ead64823dc57b55afe67e.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5fe/6c8/99a/5fe6c899a966eecb34046d5c243036b7.png"></div><br>  Textura de ruido importada. <br><br><div class="spoiler">  <b class="spoiler_title">¬øCu√°ndo es importante el muestreo sRGB?</b> <div class="spoiler_text">  Si quisi√©ramos usar una textura en un sombreador, eso marcar√≠a la diferencia.  Cuando se utiliza el modo de representaci√≥n lineal, el muestreo de textura convierte autom√°ticamente los datos de color de gamma a espacio de color lineal.  En el caso de nuestra textura de ruido, esto conducir√° a resultados incorrectos, por lo que no necesitamos esto. </div></div><br><div class="spoiler">  <b class="spoiler_title">¬øPor qu√© mi configuraci√≥n de importaci√≥n de texturas se ve diferente?</b> <div class="spoiler_text">  Se cambiaron despu√©s de escribir este tutorial.  Debe usar la configuraci√≥n predeterminada de textura 2D, <em>sRGB (Textura de color)</em> debe estar deshabilitado y la <em>Compresi√≥n</em> debe estar configurada en <em>Ninguno</em> . </div></div><br><h3>  Muestreo de ruido </h3><br>  <code>HexMetrics</code> funcionalidad de muestreo de ruido a <code>HexMetrics</code> para que pueda usarlo en cualquier lugar.  Esto significa que <code>HexMetrics</code> debe contener una referencia a la textura de ruido. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Texture2D noiseSource;</code> </pre> <br>  Como este no es un componente, no podemos asignarle una textura a trav√©s del editor.  Por lo tanto, como intermediario, utilizamos <code>HexGrid</code> .  Dado que <code>HexGrid</code> actuar√° primero, estar√° bien si pasamos la textura al comienzo de su m√©todo <code>Awake</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Texture2D noiseSource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; ‚Ä¶ }</code> </pre> <br>  Sin embargo, este enfoque no sobrevivir√° a la recompilaci√≥n en el modo Play.  El motor de Unity no serializa las variables est√°ticas.  Para resolver este problema, reasigne la textura en el m√©todo de evento <code>OnEnable</code> .  Este m√©todo se llamar√° despu√©s de la recompilaci√≥n. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnable</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d87/4fd/3a5/d874fd3a57faad4e57e5af830b202a19.png"></div><br>  <i>Asigna una textura de ruido.</i> <br><br>  Ahora que <code>HexMetrics</code> tiene acceso a la textura, agreguemos un m√©todo de muestreo de ruido conveniente.  Este m√©todo toma una posici√≥n en el mundo y crea un vector 4D que contiene cuatro muestras de ruido. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br>  Las muestras se crearon muestreando la textura usando un filtro bilineal, en el que las coordenadas del mundo X y Z se usaron como coordenadas UV. Dado que nuestra fuente de ruido es bidimensional, ignoramos la tercera coordenada del mundo.  Si la fuente de ruido fuera tridimensional, tambi√©n usar√≠amos la coordenada Y. <br><br>  Como resultado, obtenemos un color que se puede convertir en un vector 4D.  Tal reducci√≥n puede ser indirecta, es decir, podemos devolver el color directamente, sin incluir expl√≠citamente <code>(Vector4)</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear(position.x, position.z); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øC√≥mo funciona el filtrado bilineal?</b> <div class="spoiler_text">  Para obtener una explicaci√≥n de las coordenadas UV y el filtrado de texturas, consulte el tutorial de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rendering 2, Fundamentos de Shader</a> </div></div><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Movimiento de v√©rtices </h2><br>  Vamos a distorsionar nuestra grilla suave de panales, moviendo individualmente cada uno de los v√©rtices.  Para hacer esto, agreguemos el m√©todo <code>Perturb</code> a <code>Perturb</code> .  Toma un punto inm√≥vil y devuelve el movido.  Para hacer esto, usa un punto no desplazado al muestrear ruido. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); }</code> </pre> <br>  Simplemente agreguemos las muestras de ruido X, Y y Z directamente a las coordenadas de puntos correspondientes y us√©moslas como resultado. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x; position.y += sample.y; position.z += sample.z; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br>  ¬øC√≥mo cambiamos r√°pidamente <code>HexMesh</code> para mover todos los v√©rtices?  <code>AddTriangle</code> cambiar cada v√©rtice al agregar v√©rtices a la lista en los <code>AddQuad</code> <code>AddTriangle</code> y <code>AddQuad</code> .  Hag√°moslo <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(Perturb(v1)); vertices.Add(Perturb(v2)); vertices.Add(Perturb(v3)); vertices.Add(Perturb(v4)); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øLos cuadr√°ngulos permanecer√°n planos despu√©s de mover sus v√©rtices?</b> <div class="spoiler_text">  Lo m√°s probable es que no.  Consisten en dos tri√°ngulos que ya no estar√°n en el mismo plano.  Sin embargo, dado que estos tri√°ngulos tienen dos v√©rtices comunes, las normales de estos v√©rtices se suavizar√°n.  Esto significa que no tendremos transiciones bruscas entre dos tri√°ngulos.  Si la distorsi√≥n no es demasiado grande, a√∫n percibiremos los cuadr√°ngulos como planos. </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/589/55c/47d/58955c47d221104096d943df9f9b948c.png"></div><br>  <i>Los v√©rtices se mueven o no.</i> <br><br>  Si bien los cambios no son muy notables, solo las etiquetas de las celdas han desaparecido.  Esto sucedi√≥ porque agregamos muestras de ruido a los puntos, y siempre son positivos.  Por lo tanto, como resultado, todos los tri√°ngulos se elevaron por encima de sus marcas, cerr√°ndolos.  Debemos centrar los cambios para que ocurran en ambas direcciones.  Cambie el intervalo de la muestra de ruido de 0‚Äì1 a ‚àí1‚Äì1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.y += sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; position.z += sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f0/bd6/83a/1f0bd683ad92592fa6c5df171eab646c.png"></div><br>  <i>Desplazamiento centrado.</i> <br><br><h3>  La magnitud (fuerza) del desplazamiento. </h3><br>  Ahora es obvio que distorsionamos la cuadr√≠cula, pero el efecto apenas se nota.  El cambio en cada dimensi√≥n no es m√°s de 1 unidad.  Es decir, el desplazamiento m√°ximo te√≥rico es ‚àö3 ‚âà 1.73 unidades, lo que ocurrir√° extremadamente raramente, si es que lo hace.  Dado que el radio exterior de las celdas es de 10 unidades, los desplazamientos son relativamente peque√±os. <br><br>  La soluci√≥n es agregar un par√°metro de <code>HexMetrics</code> a <code>HexMetrics</code> para que pueda escalar los movimientos.  Tratemos de usar la fuerza 5. En este caso, el desplazamiento m√°ximo te√≥rico ser√° ‚àö75 ‚âà 8.66 unidades, lo cual es mucho m√°s notable. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">5f</span></span>;</code> </pre> <br>  Aplicamos la fuerza multiplic√°ndola por muestras en <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.y += (sample.y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa8/2ef/fc0/fa82effc05a418729e81ee54f0922f26.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b19/fc8/3f0/b19fc83f0828160b2100a346083f1047.png"></div><br>  <i>Aumento de la fuerza.</i> <br><br><h3>  Escala de ruido </h3><br>  Aunque la cuadr√≠cula se ve bien antes del cambio, todo puede salir mal despu√©s de que aparezcan las repisas.  Sus picos pueden distorsionarse en direcciones impredeciblemente diferentes, creando caos.  Cuando se usa el ruido Perlin, esto no deber√≠a suceder. <br><br>  El problema surge porque usamos directamente las coordenadas del mundo para muestrear el ruido.  Debido a esto, la textura se oculta a trav√©s de cada unidad, y las celdas son mucho m√°s grandes que este valor.  De hecho, la textura se muestrea en puntos arbitrarios, destruyendo su integridad existente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/bd1/717/f3fbd1717515fdf4e500e9674d82a08f.png"></div><br>  <i>Filas de 10 por 10 celdas superpuestas de cuadr√≠cula.</i> <br><br>  Tendremos que escalar el muestreo de ruido para que la textura cubra un √°rea mucho m√°s grande.  <code>HexMetrics</code> esta escala a <code>HexMetrics</code> y as√≠gnele un valor de 0.003, y luego <code>HexMetrics</code> las coordenadas de las muestras por este factor. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> noiseScale = <span class="hljs-number"><span class="hljs-number">0.003f</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleNoise</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> noiseSource.GetPixelBilinear( position.x * noiseScale, position.z * noiseScale ); }</code> </pre> <br>  De repente resulta que nuestra textura cubre 333 y frac13;  unidades cuadradas, y su integridad local se hace evidente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/219/e7a/9de219e7ae0495bcc9dfc2eca4ce52d6.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53c/0fc/e14/53c0fce142f96daecfd5001ac45e2222.png"></div><br>  <i>Ruido escalado.</i> <br><br>  Adem√°s, una nueva escala aumenta la distancia entre las juntas de ruido.  De hecho, dado que las celdas tienen un di√°metro interno de 10‚àö3 unidades, nunca se colocar√° exactamente en mosaico en la dimensi√≥n X. Sin embargo, debido a la integridad local del ruido, en una escala mayor, a√∫n podremos reconocer patrones repetitivos, aproximadamente cada 20 celdas, incluso si los detalles no coinciden.  Pero ser√°n obvios solo en el mapa sin otros rasgos caracter√≠sticos. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Alinear centros celulares </h2><br>  Mover todos los v√©rtices le da al mapa un aspecto m√°s natural, pero hay varios problemas.  Como las celdas ahora son irregulares, sus etiquetas se cruzan con la malla.  Y en las uniones de las repisas con acantilados, surgen grietas.  Dejaremos las grietas para m√°s tarde, pero ahora nos centraremos en las superficies de las c√©lulas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/320/626/85f/32062685fe221819ba4d9375175f66ee.png"></div><br>  <i>El mapa se volvi√≥ menos estricto, pero aparecieron m√°s problemas.</i> <br><br>  La forma m√°s f√°cil de resolver el problema de la intersecci√≥n es hacer que los centros de las celdas sean planos.  Simplemente no cambiemos la coordenada Y en <code>HexMesh.Perturb</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = HexMetrics.SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.cellPerturbStrength; <span class="hljs-comment"><span class="hljs-comment">// position.y += (sample.y * 2f - 1f) * HexMetrics.cellPerturbStrength; position.z += (sample.z * 2f - 1f) * HexMetrics.cellPerturbStrength; return position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfb/6f6/38e/bfb6f638e8cdb45d6178d1f18cdb723b.png"></div><br>  <i>Celdas alineadas.</i> <br><br>  Con este cambio, todas las posiciones verticales permanecer√°n sin cambios, tanto en los centros de las celdas como en los escalones de las repisas.  Cabe se√±alar que esto reduce el desplazamiento m√°ximo a ‚àö50 ‚âà 7.07 solo en el plano XZ. <br><br>  Este es un buen cambio, porque simplifica la identificaci√≥n de c√©lulas individuales y no permite que las repisas se vuelvan demasiado ca√≥ticas.  Pero a√∫n as√≠ ser√≠a bueno agregar un peque√±o movimiento vertical. <br><br><h3>  Mover la altura de la celda </h3><br>  En lugar de aplicar movimiento vertical a cada v√©rtice, podemos aplicarlo a una celda.  En este caso, cada celda permanecer√° plana, pero la variabilidad permanecer√° entre las celdas.  Tambi√©n ser√≠a l√≥gico usar una escala diferente para mover la altura, as√≠ que agr√©guela a <code>HexMetrics</code> .  Una fuerza de 1.5 unidades crea una ligera variaci√≥n, aproximadamente igual a la altura de un escal√≥n de la repisa. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationPerturbStrength = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br>  Cambie la propiedad <code>HexCell.Elevation</code> para que <code>HexCell.Elevation</code> este movimiento a la posici√≥n vertical de la celda. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { elevation = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Vector3 position = transform.localPosition; position.y = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * HexMetrics.elevationStep; position.y += (HexMetrics.SampleNoise(position).y * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * HexMetrics.elevationPerturbStrength; transform.localPosition = position; Vector3 uiPosition = uiRect.localPosition; uiPosition.z = -position.y; uiRect.localPosition = uiPosition; } }</code> </pre> <br>  Para que el movimiento se aplique inmediatamente, necesitamos establecer expl√≠citamente la altura de cada celda en <code>HexGrid.CreateCell</code> .  De lo contrario, la cuadr√≠cula inicialmente ser√° plana.  Hag√°moslo al final, despu√©s de crear la interfaz de usuario. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ cell.Elevation = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4f/dd7/15c/d4fdd715c130c8cd8b2519ff37c837de.png"></div><br>  <i>Alturas desplazadas con grietas.</i> <br><br><h3>  Usando las mismas alturas </h3><br>  Muchas grietas aparecieron en la malla, porque cuando triangulamos la malla, no usamos las mismas alturas de celda.  <code>HexCell</code> una propiedad a <code>HexCell</code> para obtener su posici√≥n para que pueda usarla en cualquier lugar. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transform.localPosition; } }</code> </pre> <br>  Ahora podemos usar esta propiedad en <code>HexMesh.Triangulate</code> para determinar el centro de la celda. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; ‚Ä¶ }</code> </pre> <br>  Y podemos usarlo en <code>TriangulateConnection</code> al definir las posiciones verticales de las celdas vecinas. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; ‚Ä¶ HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; ‚Ä¶ } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/69b/9a2/d90/69b9a2d90b7f29ef57f658f8206f6dda.png"></div><br>  <i>Uso constante de la altura de la celda.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Unidad de borde de celda </h2><br>  Aunque las celdas tienen una hermosa variaci√≥n, todav√≠a se ven como hex√°gonos obvios.  Esto en s√≠ mismo no es un problema, pero podemos mejorar su apariencia. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/895/e86/6d5895e8650286653b532d9c6fa1c10d.png"></div><br>  <i>C√©lulas hexagonales claramente visibles.</i> <br><br>  Si tuvi√©ramos m√°s v√©rtices, entonces habr√≠a una mayor variabilidad local.  Entonces, dividamos cada borde de la celda en dos partes agregando la parte superior del borde en el medio entre cada par de esquinas.  Esto significa que <code>HexMesh.Triangulate</code> debe agregar no uno, sino dos tri√°ngulos. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction); Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction); Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, v2); AddTriangleColor(cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, v2); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b09/03c/d20/b0903cd20983599abdc064f04c95aa4f.png"></div><br>  <i>Doce lados en lugar de seis.</i> <br><br>  Doblar v√©rtices y tri√°ngulos agrega m√°s variabilidad a los bordes de la celda.  Hag√°moslos a√∫n m√°s desiguales triplicando el n√∫mero de v√©rtices. <br><br><pre> <code class="cs hljs"> Vector3 e1 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e2 = Vector3.Lerp(v1, v2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); AddTriangle(center, v1, e1); AddTriangleColor(cell.color); AddTriangle(center, e1, e2); AddTriangleColor(cell.color); AddTriangle(center, e2, v2); AddTriangleColor(cell.color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/852/e6c/ad2852e6ccbf3db0adca140818545bb3.png"></div><br>  <i>18 lados</i> <br><br><h3>  Divisi√≥n de costillas </h3><br>  Por supuesto, tambi√©n necesitamos subdividir las juntas de borde.  Por lo tanto, pasaremos los nuevos bordes de v√©rtice a <code>TriangulateConnection</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, v1, e1, e2, v2); }</code> </pre> <br>  Agregue los par√°metros apropiados a <code>TriangulateConnection</code> para que pueda funcionar con v√©rtices adicionales. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2 </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br>  Tambi√©n necesitamos calcular los bordes adicionales de los bordes para las celdas vecinas.  Podemos calcularlos despu√©s de conectar el puente al otro lado. <br><br><pre> <code class="cs hljs"> Vector3 bridge = HexMetrics.GetBridge(direction); Vector3 v3 = v1 + bridge; Vector3 v4 = v2 + bridge; v3.y = v4.y = neighbor.Position.y; Vector3 e3 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); Vector3 e4 = Vector3.Lerp(v3, v4, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>);</code> </pre> <br>  Luego necesitamos cambiar la triangulaci√≥n de la costilla.  Hasta que ignoremos las pendientes con las repisas, solo agregue tres en lugar de un quad. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddQuad(v1, e1, v3, e3); AddQuadColor(cell.color, neighbor.color); AddQuad(e1, e2, e3, e4); AddQuadColor(cell.color, neighbor.color); AddQuad(e2, v2, e4, v4); AddQuadColor(cell.color, neighbor.color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afa/9d6/708/afa9d67080045b6ea2951a715c569003.png"></div><br>  <i>Conexiones subdivididas.</i> <br><br><h3>  La uni√≥n de los bordes de los bordes. </h3><br>  Dado que para describir los bordes ahora necesitamos cuatro v√©rtices, ser√≠a l√≥gico combinarlos en un conjunto.  Esto es m√°s conveniente que trabajar con cuatro v√©rtices independientes.  Cree una estructura de <code>EdgeVertices</code> simple para esto.  Debe contener cuatro v√©rtices que van en sentido horario a lo largo del borde de la celda. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> EdgeVertices { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">¬øNo deber√≠an ser serializables?</b> <div class="spoiler_text">  Usaremos esta estructura solo para triangulaci√≥n.  En esta etapa, no necesitamos almacenar los v√©rtices de los bordes, por lo que no es necesario que sean serializables. </div></div><br>  Agregue un m√©todo de construcci√≥n conveniente, que se ocupar√° del c√°lculo de los puntos intermedios del borde. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); v4 = corner2; }</code> </pre> <br>  Ahora podemos agregar un m√©todo de triangulaci√≥n separado a <code>HexMesh</code> para crear un abanico de tri√°ngulos entre el centro de la celda y uno de sus bordes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); }</code> </pre> <br>  Y un m√©todo para triangular una tira de cuadr√°ngulos entre dos bordes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); }</code> </pre> <br>  Esto nos permitir√° simplificar el m√©todo <code>Triangulate</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); TriangulateEdgeFan(center, e, cell.color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br>  Pasemos a <code>TriangulateConnection</code> .  Ahora podemos usar <code>TriangulateEdgeStrip</code> , pero se deben hacer otros reemplazos.  Donde sol√≠amos usar <code>v1</code> , necesitamos usar <code>e1.v1</code> .  Del mismo modo, <code>v2</code> convierte en <code>e1.v4</code> , <code>v3</code> convierte en <code>e2.v1</code> y <code>v4</code> convierte en <code>e2.v4</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v4 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1.v1, e1.v4, cell, e2.v1, e2.v4, neighbor); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip(e1, cell.color, e2, neighbor.color); } HexCell nextNeighbor = cell.GetNeighbor(direction.Next()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Vector3 v5 = e1.v4 + HexMetrics.GetBridge(direction.Next()); v5.y = nextNeighbor.Position.y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= neighbor.Elevation) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e1.v4, cell, e2.v4, neighbor, v5, nextNeighbor ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor.Elevation &lt;= nextNeighbor.Elevation) { TriangulateCorner( e2.v4, neighbor, v5, nextNeighbor, e1.v4, cell ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateCorner( v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor ); } }</code> </pre> <br><h3>  Divisi√≥n de la repisa </h3><br>  Necesitamos dividir las repisas.  Por lo tanto, pasamos los bordes a <code>TriangulateEdgeTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces(e1, cell, e2, neighbor); }</code> </pre> <br>  Ahora necesitamos modificar <code>TriangulateEdgeTerraces</code> para que se interpole entre aristas y no entre pares de v√©rtices.  Supongamos que <code>EdgeVertices</code> tiene un m√©todo est√°tico conveniente para hacer esto.  Esto nos permitir√° simplificar <code>TriangulateEdgeTerraces</code> lugar de complicarlo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.color, e2, c2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i); TriangulateEdgeStrip(e1, c1, e2, c2); } TriangulateEdgeStrip(e2, c2, end, endCell.color); }</code> </pre> <br>  El m√©todo <code>EdgeVertices.TerraceLerp</code> simplemente interpola las repisas entre los cuatro pares de v√©rtices de dos bordes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7d/ead/906/a7dead9066cbd1f7ddd29ca751d81cb0.png"></div><br>  <i>Repisas subdivididas.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow">paquete de la unidad</a> <br><br><h2>  Reconecta acantilados y repisas </h2><br>  Hasta ahora, hemos ignorado las grietas en la uni√≥n de acantilados y repisas.  Es hora de resolver este problema.  Primero veamos los casos de acantilado-pendiente-pendiente (OSS) y pendiente-acantilado-pendiente (SOS). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/402/951/0fa/4029510fa08226cc4e4aee18faf1959b.png"></div><br>  <i>Agujeros de malla.</i> <br><br>  El problema surge porque las partes superiores de las fronteras se han movido.  Esto significa que ahora no se encuentran exactamente del lado del acantilado, lo que conduce a una grieta.  A veces estos agujeros son invisibles, y a veces llamativos. <br><br>  La soluci√≥n es no mover la parte superior del borde.  Esto significa que necesitamos controlar si el punto se mover√°.  La forma m√°s f√°cil ser√≠a crear una alternativa <code>AddTriangle</code> que no mueva los v√©rtices en absoluto. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUnperturbed</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 v1, Vector3 v2, Vector3 v3</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertexIndex = vertices.Count; vertices.Add(v1); vertices.Add(v2); vertices.Add(v3); triangles.Add(vertexIndex); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">1</span></span>); triangles.Add(vertexIndex + <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  Cambie el <code>TriangulateBoundaryTriangle</code> para que use este m√©todo.  Esto significa que tendr√° que mover expl√≠citamente todos los v√©rtices, excepto los l√≠mites. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), Perturb(v2), boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = HexMetrics.TerraceLerp(begin, left, i); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(Perturb(v1), Perturb(v2), boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(Perturb(v2), Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br>  Vale la pena se√±alar lo siguiente: como no usamos <code>v2</code> para obtener otro punto, podemos moverlo de inmediato.  Esta es una optimizaci√≥n simple y reduce la cantidad de c√≥digo, as√≠ que vamos a presentarlo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateBoundaryTriangle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 begin, HexCell beginCell, Vector3 left, HexCell leftCell, Vector3 boundary, Color boundaryColor </span></span></span><span class="hljs-function">)</span></span> { Vector3 v2 = Perturb(HexMetrics.TerraceLerp(begin, left, <span class="hljs-number"><span class="hljs-number">1</span></span>)); Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="hljs-number"><span class="hljs-number">1</span></span>); AddTriangleUnperturbed(Perturb(begin), v2, boundary); AddTriangleColor(beginCell.color, c2, boundaryColor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { Vector3 v1 = v2; Color c1 = c2; v2 = Perturb(HexMetrics.TerraceLerp(begin, left, i)); c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i); AddTriangleUnperturbed(v1, v2, boundary); AddTriangleColor(c1, c2, boundaryColor); } AddTriangleUnperturbed(v2, Perturb(left), boundary); AddTriangleColor(c2, leftCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/221/0ed/3fd2210ed0a8148ba9d39ef1655848e8.png"></div><br>  <i>Fronteras inm√≥viles.</i> <br><br>  Se ve mejor, pero a√∫n no hemos terminado.  Dentro del m√©todo <code>TriangulateCornerTerracesCliff</code> , el punto l√≠mite se interpola entre los puntos izquierdo y derecho.  Sin embargo, estos puntos a√∫n no se han movido.  Para que el punto l√≠mite corresponda con el acantilado resultante, necesitamos interpolar entre los puntos movidos. <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(right), b);</code> </pre> <br>  Lo mismo es cierto para el m√©todo <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(left), b);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c18/917/670/c189176704e7ebcdfd92bc6a1cffaee3.png"></div><br>  <i>Los agujeros se han ido.</i> <br><br><h3>  Acantilados dobles y pendiente </h3><br>  En todos los casos problem√°ticos restantes, dos acantilados y una pendiente est√°n presentes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/408/f2f/4a6/408f2f4a6fca5fffd8659b4380f59e51.png"></div><br>  <i>Gran agujero debido a un solo tri√°ngulo.</i> <br><br>  Este problema se resuelve moviendo manualmente un solo tri√°ngulo en el bloque <code>else</code> al final de <code>TriangulateCornerTerracesCliff</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br>  Lo mismo ocurre con <code>TriangulateCornerCliffTerraces</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary); AddTriangleColor(leftCell.color, rightCell.color, boundaryColor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ff/b34/64a/9ffb3464a6de3dc443cede9d42797022.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desh√°gase de las √∫ltimas grietas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finalizaci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos una malla distorsionada completamente correcta. </font><font style="vertical-align: inherit;">Su apariencia depende del ruido espec√≠fico, su escala y las fuerzas de distorsi√≥n. </font><font style="vertical-align: inherit;">En nuestro caso, la distorsi√≥n puede parecer demasiado fuerte. </font><font style="vertical-align: inherit;">Aunque este desnivel se ve hermoso, no queremos que las celdas se desv√≠en demasiado de la cuadr√≠cula uniforme. </font><font style="vertical-align: inherit;">Al final, todav√≠a lo usamos para definir la celda a cambiar de tama√±o. </font><font style="vertical-align: inherit;">Y si el tama√±o de las celdas var√≠a demasiado, entonces ser√° m√°s dif√≠cil para nosotros colocar el contenido en ellas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/32e/d06/35f32ed066f03b1079ed0bec70ba83ca.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eac/3f5/d6c/eac3f5d6cd6a1e65185d1aec48e8abb0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mallas no distorsionadas y distorsionadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que la fuerza 5 para distorsionar las c√©lulas es demasiado grande.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distorsi√≥n de las celdas es de 0 a 5.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reduzcamos a 4 para aumentar la conveniencia de la cuadr√≠cula, sin que sea demasiado correcta. </font><font style="vertical-align: inherit;">Esto asegura que el desplazamiento m√°ximo de XZ ser√° ‚àö32 ‚âà 5.66 unidades.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/803/2f6/b8d/8032f6b8d0cf048f5d55c30e2d0e465d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuerza de distorsi√≥n celular 4.</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Otro valor que se puede cambiar es el coeficiente de integridad. </font><font style="vertical-align: inherit;">Si lo aumentamos, los centros planos de las celdas se agrandar√°n, es decir, habr√° m√°s espacio para contenido futuro. </font><font style="vertical-align: inherit;">Por supuesto, al hacerlo se volver√°n m√°s hexagonales.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coeficiente de integridad de 0,75 a 0,95. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un ligero aumento en el coeficiente de integridad a 0.8 simplificar√° ligeramente nuestra vida en el futuro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> solidFactor = <span class="hljs-number"><span class="hljs-number">0.8f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/9a2/036/a9a9a2036fbcd0e4e5f11e56078911c1.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coeficiente de integridad 0.8. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, puede notar que las diferencias entre los niveles de elevaci√≥n son demasiado agudas. </font><font style="vertical-align: inherit;">Esto es conveniente cuando necesita asegurarse de que la malla se genera correctamente, pero ya hemos terminado con esto. </font><font style="vertical-align: inherit;">Vamos a reducirlo a 1 unidad por paso, es decir, a 3.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> elevationStep = <span class="hljs-number"><span class="hljs-number">3f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cc/4b0/028/5cc4b002843f822556c7ced67b9f54db.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tono se reduce a 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambi√©n podemos cambiar la intensidad de la distorsi√≥n del tono. </font><font style="vertical-align: inherit;">Pero ahora tiene un valor de 1.5, que es igual a medio paso de altura, lo que nos conviene. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peque√±os pasos de altura permiten un uso m√°s l√≥gico de los siete niveles de altura. </font><font style="vertical-align: inherit;">Esto aumenta la variabilidad del mapa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f63/9b3/aac/f639b3aac128c4c72c28fa85d68cc0e4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos siete niveles de altura. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 5: tarjetas m√°s grandes </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dividimos la cuadr√≠cula en fragmentos. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nosotros controlamos la c√°mara. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colorea los colores y las alturas por separado. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usa el pincel ampliado de las celdas. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora hemos estado trabajando con un mapa muy peque√±o. </font><font style="vertical-align: inherit;">Es hora de aumentarlo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c8/11c/4b4/0c811c4b480c13b584a2b824fdae1cee.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es hora de acercarse.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmentos de malla </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No podemos hacer que la cuadr√≠cula sea demasiado grande, porque nos topamos con los l√≠mites de lo que cabe en una malla. </font><font style="vertical-align: inherit;">¬øC√≥mo resolver este problema? </font><font style="vertical-align: inherit;">Usa m√∫ltiples mallas. </font><font style="vertical-align: inherit;">Para hacer esto, necesitamos dividir nuestra cuadr√≠cula en varios fragmentos. </font><font style="vertical-align: inherit;">Utilizamos fragmentos rectangulares de tama√±o constante.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/423/453/db2/423453db217ed74da2457198c576ef63.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dividiendo la cuadr√≠cula en 3 por 3 segmentos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usemos 5 por 5 bloques, es decir, 25 celdas por fragmento. </font><font style="vertical-align: inherit;">Def√≠nalos en </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkSizeX = <span class="hljs-number"><span class="hljs-number">5</span></span>, chunkSizeZ = <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© tama√±o de fragmento puede considerarse adecuado?</font></font></b> <div class="spoiler_text">  .       ,     .      .      ,       (frustum culling),       .            . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora no podemos usar ning√∫n tama√±o para la malla; debe ser un m√∫ltiplo del tama√±o del fragmento. </font><font style="vertical-align: inherit;">Por lo tanto, cambiemos </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que establezca su tama√±o no en celdas separadas, sino en fragmentos. </font><font style="vertical-align: inherit;">Establezca el tama√±o predeterminado en 4 por 3 fragmentos, es decir, solo 12 fragmentos o 300 celdas. </font><font style="vertical-align: inherit;">Entonces obtenemos una tarjeta de prueba conveniente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkCountX = <span class="hljs-number"><span class="hljs-number">4</span></span>, chunkCountZ = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todav√≠a usamos </font></font><code>width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>height</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero ahora deber√≠an volverse privados. </font><font style="vertical-align: inherit;">Y ren√≥mbralos a </font></font><code>cellCountX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>cellCountZ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Use el editor para cambiar el nombre de todas las apariciones de estas variables a la vez. </font><font style="vertical-align: inherit;">Ahora quedar√° claro cuando tratemos con la cantidad de fragmentos o c√©lulas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public int width = 6; // public int height = 6; int cellCountX, cellCountZ;</span></span></code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/ff4/160/227ff41602f115787a8a0e5d98ca89c9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especifique el tama√±o en fragmentos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que, si es necesario, el n√∫mero de celdas se calcule a partir del n√∫mero de fragmentos. </font><font style="vertical-align: inherit;">Destacamos la creaci√≥n de celdas en un m√©todo separado, para no obstruir </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { HexMetrics.noiseSource = noiseSource; gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cellCountX = chunkCountX * HexMetrics.chunkSizeX; cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ; CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[cellCountZ * cellCountX]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; cellCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; cellCountX; x++) { CreateCell(x, z, i++); } } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fragmento prefabricado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para describir los fragmentos de malla, necesitamos un nuevo tipo de componente. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.UI; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n crearemos un fragmento prefabricado. </font><font style="vertical-align: inherit;">Haremos esto duplicando el objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y renombr√°ndolo como </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid Chunk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Elimine su componente </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y agregue un componente en su lugar </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego convi√©rtalo en una casa prefabricada y elimine el objeto de la escena.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/a02/bea/106a02bead67c37151be26d5f6a4bea9.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cb/586/7a3/1cb5867a3851159ce2bf1747a4e213bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un fragmento prefabricado con su propio lienzo y malla. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como crear√° instancias de estos fragmentos </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le daremos un enlace a la prefabricaci√≥n del fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunkPrefab;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a9/6b8/882/2a96b8882c5d6cc5bdb6345d5217ae83.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora con fragmentos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crear instancias de fragmentos es muy parecido a crear instancias de celdas. </font><font style="vertical-align: inherit;">Los rastrearemos con la ayuda de una matriz y usaremos un bucle doble para llenarlo.</font></font><br><br><pre> <code class="cs hljs"> HexGridChunk[] chunks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ CreateChunks(); CreateCells(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateChunks</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexGridChunk[chunkCountX * chunkCountZ]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = <span class="hljs-number"><span class="hljs-number">0</span></span>, i = <span class="hljs-number"><span class="hljs-number">0</span></span>; z &lt; chunkCountZ; z++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; chunkCountX; x++) { HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab); chunk.transform.SetParent(transform); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializar un fragmento es similar a c√≥mo inicializamos una cuadr√≠cula de hex√°gonos. </font><font style="vertical-align: inherit;">Ella establece todo </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y realiza la triangulaci√≥n </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Requiere una referencia a su lienzo y malla, as√≠ como una matriz para las celdas. </font><font style="vertical-align: inherit;">Sin embargo, el fragmento no crear√° estas celdas. </font><font style="vertical-align: inherit;">La cuadr√≠cula continuar√° haciendo esto.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexGridChunk</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { HexCell[] cells; HexMesh hexMesh; Canvas gridCanvas; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asignaci√≥n de celdas a fragmentos </font></font></h3><br> <code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todav√≠a crea todas las celdas. </font><font style="vertical-align: inherit;">Esto es normal, pero ahora necesitamos agregar cada celda a un fragmento adecuado y no configurarlas con nuestra propia malla y lienzo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ HexCell cell = cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab); <span class="hljs-comment"><span class="hljs-comment">// cell.transform.SetParent(transform, false); cell.transform.localPosition = position; cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z); cell.color = defaultColor; ‚Ä¶ Text label = Instantiate&lt;Text&gt;(cellLabelPrefab); // label.rectTransform.SetParent(gridCanvas.transform, false); label.rectTransform.anchoredPosition = new Vector2(position.x, position.z); label.text = cell.coordinates.ToStringOnSeparateLines(); cell.uiRect = label.rectTransform; cell.Elevation = 0; AddCellToChunk(x, z, cell); } void AddCellToChunk (int x, int z, HexCell cell) { }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos encontrar el fragmento correcto usando la divisi√≥n de enteros </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por tama√±o de fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando resultados intermedios, tambi√©n podemos determinar el √≠ndice local de la c√©lula en este fragmento. </font><font style="vertical-align: inherit;">Despu√©s de eso, puede agregar una celda al fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCellToChunk</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkX = x / HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> chunkZ = z / HexMetrics.chunkSizeZ; HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localX = x - chunkX * HexMetrics.chunkSizeX; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localZ = z - chunkZ * HexMetrics.chunkSizeZ; chunk.AddCell(localX + localZ * HexMetrics.chunkSizeX, cell); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego </font></font><code>HexGridChunk.AddCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coloca la celda en su propia matriz, y luego establece los elementos principales para la celda y su interfaz de usuario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barrer </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este punto, </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede deshacerse del lienzo y la malla hexagonal de sus hijos, as√≠ como del c√≥digo.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Canvas gridCanvas; // HexMesh hexMesh; void Awake () { HexMetrics.noiseSource = noiseSource; // gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); ‚Ä¶ } // void Start () { // hexMesh.Triangulate(cells); // } // public void Refresh () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde que nos deshicimos </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ya </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no </font><font style="vertical-align: inherit;">deber√≠amos </font><font style="vertical-align: inherit;">usarlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cell.color = activeColor; cell.Elevation = activeElevation; <span class="hljs-comment"><span class="hljs-comment">// hexGrid.Refresh(); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a0/f4b/c99/5a0f4bc99bce766e53ff1a0192abd16e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La rejilla limpia de hex√°gonos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de iniciar el modo de juego, la tarjeta todav√≠a se ve igual. </font><font style="vertical-align: inherit;">Pero la jerarqu√≠a de los objetos ser√° diferente. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Grid</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ahora crea fragmentos de objetos secundarios que contienen celdas, as√≠ como su malla y lienzo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/bc4/f8e/a7fbc4f8e4898504bc34a4a918ebb567.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos de ni√±os en modo Play. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiz√°s tengamos algunos problemas con las etiquetas de las celdas. </font><font style="vertical-align: inherit;">Inicialmente, configuramos el ancho de la etiqueta en 5. Esto fue suficiente para mostrar los dos caracteres que eran suficientes para nosotros en un peque√±o mapa. </font><font style="vertical-align: inherit;">Pero ahora podemos tener coordenadas como ‚àí10, en las que hay tres caracteres. </font><font style="vertical-align: inherit;">No encajar√°n y se recortar√°n. </font><font style="vertical-align: inherit;">Para solucionar esto, aumente el ancho de la etiqueta de la celda a 10, o incluso m√°s.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e7/fd3/4a5/2e7fd34a5b649256e326b73a3aa9227a.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7c/926/fae/f7c926fae8356aa8d2402a21359fea8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etiquetas de celda extendidas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ahora podemos crear mapas mucho m√°s grandes! </font><font style="vertical-align: inherit;">Dado que generamos la cuadr√≠cula completa al inicio, puede llevar mucho tiempo crear mapas grandes. </font><font style="vertical-align: inherit;">Pero despu√©s de la finalizaci√≥n, tendremos un gran espacio para la experimentaci√≥n.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fix cell edit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La edici√≥n no parece funcionar en la etapa actual, porque ya no actualizamos la cuadr√≠cula. </font><font style="vertical-align: inherit;">Necesitamos actualizar fragmentos individuales, as√≠ que agregue un m√©todo </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Triangulate(cells); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°ndo deber√≠amos llamar a este m√©todo? </font><font style="vertical-align: inherit;">Actualizamos toda la cuadr√≠cula cada vez porque solo ten√≠amos una malla. </font><font style="vertical-align: inherit;">Pero ahora tenemos muchos fragmentos. </font><font style="vertical-align: inherit;">En lugar de actualizarlos todos cada vez, ser√° mucho m√°s eficiente actualizar los fragmentos modificados. </font><font style="vertical-align: inherit;">De lo contrario, cambiar las tarjetas grandes se convertir√° en una operaci√≥n muy lenta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero, ¬øc√≥mo sabemos qu√© fragmento actualizar? </font><font style="vertical-align: inherit;">La forma m√°s f√°cil es hacer que cada c√©lula sepa a qu√© fragmento pertenece. </font><font style="vertical-align: inherit;">Entonces la celda podr√° actualizar su fragmento al cambiar esta celda. </font><font style="vertical-align: inherit;">Entonces, demos un </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace a su fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGridChunk chunk;</code> </pre> <br> <code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> puede agregarse a la celda al agregar. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { cells[index] = cell; cell.chunk = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; cell.transform.SetParent(transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); cell.uiRect.SetParent(gridCanvas.transform, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al conectarlos, agregamos al </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cada vez que se actualiza una celda, simplemente actualizar√° su fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No necesitamos hacerlo </font></font><code>HexCell.Refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com√∫n, porque la c√©lula en s√≠ misma sabe mejor cuando se cambi√≥. </font><font style="vertical-align: inherit;">Por ejemplo, despu√©s de que se haya cambiado su altura.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, necesitamos actualizarlo solo cuando su altura ha cambiado a un valor diferente. </font><font style="vertical-align: inherit;">Ni siquiera necesita volver a calcular nada si le asignamos la misma altura que antes. </font><font style="vertical-align: inherit;">Por lo tanto, podemos salir del comienzo del setter.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (elevation == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ‚Ä¶ } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, tambi√©n omitiremos los c√°lculos por primera vez cuando la altura se establezca en 0, porque este es el valor predeterminado de altura de malla. </font><font style="vertical-align: inherit;">Para evitar esto, haremos el valor inicial tal como nunca lo usamos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elevation = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MinValue;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© es int.MinValue?</font></font></b> <div class="spoiler_text">   ,    integer.    C# integer ‚Äî <br>  32- ,   2 <sup>32</sup>  integer,    ,    .       . <br><br>  ‚Äî  ‚àí2 <sup>31</sup> = ‚àí2 147 483 648.        ! <br><br>   2 <sup>31</sup> ‚àí 1 = 2 147 483 647.     2 <sup>31</sup> - . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para reconocer el cambio de color de la celda, tambi√©n debemos convertirlo en una propiedad. </font><font style="vertical-align: inherit;">Cambie el nombre a </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may√∫sculas y luego convi√©rtalo en una propiedad con una variable privada </font></font><code>color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">El valor de color predeterminado ser√° negro transparente, lo que nos conviene.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Color Color { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (color == <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } color = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Refresh(); } } Color color;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora, cuando comenzamos el modo Play, obtenemos excepciones de referencia nula. </font><font style="vertical-align: inherit;">Esto sucede porque establecemos el color y la altura a sus valores predeterminados antes de asignar una celda a su fragmento. </font><font style="vertical-align: inherit;">Es normal que no actualicemos los fragmentos en esta etapa, porque los triangulamos despu√©s de que se complete toda la inicializaci√≥n. </font><font style="vertical-align: inherit;">En otras palabras, actualizamos un fragmento solo si est√° asignado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Finalmente podemos cambiar las c√©lulas nuevamente! </font><font style="vertical-align: inherit;">Sin embargo, surge un problema. </font><font style="vertical-align: inherit;">Al dibujar a lo largo de los bordes de los fragmentos, aparecen las costuras.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/94f/50c/41a94f50c430ce8f13fb1a3be274b520.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Errores en los l√≠mites de los fragmentos.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto es l√≥gico, porque cuando cambia una sola celda, todas las conexiones con sus vecinos tambi√©n cambian. Y estos vecinos pueden estar en otros fragmentos. La soluci√≥n m√°s simple es actualizar todas las celdas vecinas si son diferentes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunk) { chunk.Refresh(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { HexCell neighbor = neighbors[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; neighbor.chunk != chunk) { neighbor.chunk.Refresh(); } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque esto funciona, puede resultar que actualicemos un fragmento varias veces. Y cuando comenzamos a colorear varias celdas a la vez, todo empeorar√°. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero no estamos obligados a triangular inmediatamente despu√©s de actualizar el fragmento. En cambio, simplemente escribimos que se necesita una actualizaci√≥n y triangulamos despu√©s de que se completa el cambio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como no </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hace nada m√°s, podemos usar su estado habilitado para indicar la necesidad de actualizaciones. Al actualizarlo, incluimos el componente. Encenderlo varias veces no cambiar√° nada. El componente se actualiza m√°s tarde. Triangularemos en este punto y deshabilitaremos el componente nuevamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usamos en su </font></font><code>LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lugar</font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para garantizar que se produce la triangulaci√≥n despu√©s de completar el cambio para el marco actual. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Refresh</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = true; } void LateUpdate () { hexMesh.Triangulate(cells); enabled = false; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCu√°l es la diferencia entre Update y LateUpdate?</font></font></b> <div class="spoiler_text">     <code>Update</code>    -     .          <code>LateUpdate</code> .      ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que nuestro componente est√° habilitado por defecto, ya no necesitamos triangular expl√≠citamente </font></font><code>Start</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, este m√©todo puede eliminarse.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// void Start () { // hexMesh.Triangulate(cells); // }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6f/104/7c3/a6f1047c34bb9cf9b69360343ab53aac.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmentos de 20 por 20 que contienen 10,000 c√©lulas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Listas generalizadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque hemos cambiado significativamente la forma en que se triangula la cuadr√≠cula, </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sigue siendo la misma. </font><font style="vertical-align: inherit;">Todo lo que necesita para trabajar es una matriz de c√©lulas. </font><font style="vertical-align: inherit;">No le importa si hay una malla de hex√°gonos, o varias. </font><font style="vertical-align: inherit;">Pero a√∫n no hemos considerado usar m√∫ltiples mallas. </font><font style="vertical-align: inherit;">Tal vez algo se puede mejorar aqu√≠? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">listas </font><font style="vertical-align: inherit;">utilizadas </font><font style="vertical-align: inherit;">son esencialmente memorias intermedias temporales. </font><font style="vertical-align: inherit;">Se usan solo para triangulaci√≥n. </font><font style="vertical-align: inherit;">Y los fragmentos se triangulan uno a la vez. </font><font style="vertical-align: inherit;">Por lo tanto, de hecho, solo necesitamos un conjunto de listas, y no un conjunto para cada objeto de malla hexagonal. </font><font style="vertical-align: inherit;">Esto se puede lograr haciendo que las listas sean est√°ticas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Vector3&gt; vertices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector3&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;Color&gt; colors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Color&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// vertices = new List&lt;Vector3&gt;(); // colors = new List&lt;Color&gt;(); // triangles = new List&lt;int&gt;(); }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øSon realmente tan importantes las listas est√°ticas?</font></font></b> <div class="spoiler_text">           .    ,   ,       . <br><br>     ,           .    20  20     100. </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Control de la c√°mara </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La c√°mara grande es maravillosa, pero es in√∫til si no podemos verla. Para inspeccionar todo el mapa, necesitamos mover la c√°mara. El zoom tambi√©n es √∫til. Por lo tanto, creemos una c√°mara para realizar estas acciones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea un objeto ficticio y ll√°malo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hex Map Camera</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Suelte su componente de transformaci√≥n para que se mueva al origen sin cambiar su rotaci√≥n y escala. Agregue un ni√±o llamado </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Giratorio</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y agregue un ni√±o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stick</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Convierta la c√°mara principal en un elemento secundario del Stick y restablezca su componente de transformaci√≥n.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a8/33f/3d9/0a833f3d9eea9b9fef1682ef63a7f372.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La jerarqu√≠a de la c√°mara. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo de la bisagra de la c√°mara (Giratorio) es controlar el √°ngulo en el que la c√°mara mira el mapa. </font><font style="vertical-align: inherit;">Vamos a darle una vuelta (45, 0, 0). </font><font style="vertical-align: inherit;">El asa (Stick) controla la distancia a la que se encuentran las c√°maras. </font><font style="vertical-align: inherit;">Vamos a ponerle una posici√≥n (0, 0, -45). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora necesitamos un componente para controlar este sistema. </font><font style="vertical-align: inherit;">Asigne este componente a la ra√≠z de la jerarqu√≠a de la c√°mara. </font><font style="vertical-align: inherit;">Dale un enlace a la bisagra y al mango, introduci√©ndolos </font></font><code>Awake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">HexMapCamera</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Transform swivel, stick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { swivel = transform.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); stick = swivel.GetChild(<span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb6/2e5/44b/eb62e544b9e00bc558dfbc504802cfba.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C√°mara de mapa hexagonal.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zoom </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera funci√≥n que crearemos es el zoom (zoom). </font><font style="vertical-align: inherit;">Podemos controlar el nivel de zoom actual usando la variable flotante. </font><font style="vertical-align: inherit;">Un valor de 0 significa que estamos completamente distantes, y un valor de 1 significa que estamos completamente cerca. </font><font style="vertical-align: inherit;">Comencemos con el zoom m√°ximo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoom = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El zoom generalmente se realiza con la rueda del mouse o el control anal√≥gico. </font><font style="vertical-align: inherit;">Podemos implementarlo usando el eje de entrada </font><font style="vertical-align: inherit;">predeterminado de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mouse ScrollWheel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Agregue un m√©todo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que verifique la presencia de un delta de entrada y, si existe, llama al m√©todo de cambio de zoom.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para cambiar el nivel de zoom, simplemente le agregamos un delta y luego limitamos el valor (pinza) para permanecer en el rango 0-1. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al acercar y alejar, la distancia a la c√°mara debe cambiar en consecuencia. </font><font style="vertical-align: inherit;">Esto se puede hacer cambiando la posici√≥n del controlador en Z. Agregue dos variables flotantes comunes para ajustar la posici√≥n del controlador con el zoom m√≠nimo y m√°ximo. </font><font style="vertical-align: inherit;">Como estamos desarrollando un mapa relativamente peque√±o, establezca los valores en -250 y -45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> stickMinZoom, stickMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de cambiar el zoom, realizamos una interpolaci√≥n lineal entre estos dos valores en funci√≥n del nuevo valor de zoom. </font><font style="vertical-align: inherit;">Luego actualice la posici√≥n del mango.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cec/f4c/f07/cecf4cf07d627d6eaab94ecdc2953d30.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valores m√≠nimos y m√°ximos de Stick. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el zoom funciona, pero hasta ahora no es muy √∫til. </font><font style="vertical-align: inherit;">Por lo general, cuando el zoom est√° m√°s lejos, la c√°mara entra en una vista superior. </font><font style="vertical-align: inherit;">Podemos darnos cuenta de esto girando la bisagra. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos las variables min y max para la bisagra. </font><font style="vertical-align: inherit;">Vamos a establecer los valores 90 y 45.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> swivelMinZoom, swivelMaxZoom;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que con la posici√≥n del mango, interpolamos para encontrar un √°ngulo de zoom adecuado. </font><font style="vertical-align: inherit;">Luego establecemos la rotaci√≥n de la bisagra.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustZoom</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { zoom = Mathf.Clamp01(zoom + delta); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom); stick.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, distance); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.Lerp(swivelMinZoom, swivelMaxZoom, zoom); swivel.localRotation = Quaternion.Euler(angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/766/0c3/fcd/7660c3fcd621567398ea7c013fae549c.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El valor m√≠nimo y m√°ximo de Swivel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La tasa de cambio del zoom se puede ajustar cambiando la sensibilidad de los par√°metros de entrada de la rueda del mouse. </font><font style="vertical-align: inherit;">Se pueden encontrar en </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Edici√≥n / Configuraci√≥n del proyecto / Entrada</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por ejemplo, al cambiarlos de 0.1 a 0.025, obtenemos un cambio de zoom m√°s lento y suave.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d43/f86/ef3/d43f86ef3587be1bfd15ca208eec418f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opciones de entrada de la rueda del mouse.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En movimiento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora pasemos a mover la c√°mara. </font><font style="vertical-align: inherit;">El movimiento en la direcci√≥n de X y Z debemos implementarlo </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como en el caso del zoom. </font><font style="vertical-align: inherit;">Podemos usar ejes de entrada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">horizontal</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para esto </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Esto nos permitir√° mover la c√°mara con las flechas y las teclas WASD.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El enfoque m√°s simple es obtener la posici√≥n actual del sistema de c√°mara, agregarle deltas X y Z, y asignar el resultado a la posici√≥n del sistema. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta); transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debido a esto, la c√°mara se mover√° mientras mantiene presionadas las flechas o WASD, pero no a una velocidad constante. </font><font style="vertical-align: inherit;">Depender√° de la velocidad de fotogramas. </font><font style="vertical-align: inherit;">Para determinar la distancia que necesita moverse, usamos el tiempo delta, as√≠ como la velocidad requerida. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos una variable com√∫n </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y la establecemos en 100, y luego la multiplicamos por el delta de tiempo para obtener la posici√≥n delta.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> moveSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta) * distance; transform.localPosition = position; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6da/1bc/307/6da1bc3074dc31868b934a35aaa31b10.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidad de movimiento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos movernos a una velocidad constante a lo largo de los ejes X o Z. Pero cuando nos movemos a lo largo de ambos ejes al mismo tiempo (en diagonal) el movimiento ser√° m√°s r√°pido. </font><font style="vertical-align: inherit;">Para solucionar esto, necesitamos normalizar el vector delta. </font><font style="vertical-align: inherit;">Esto le permitir√° usarlo como destino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El movimiento diagonal ahora se implementa correctamente, pero de repente resulta que la c√°mara contin√∫a movi√©ndose durante un tiempo bastante largo incluso despu√©s de soltar todas las teclas. Esto sucede porque los ejes de entrada no saltan instant√°neamente a los valores l√≠mite inmediatamente despu√©s de presionar las teclas. Necesitan algo de tiempo para esto. Lo mismo es cierto para la liberaci√≥n de claves. Lleva tiempo volver a los valores del eje cero. Sin embargo, dado que normalizamos los valores de entrada, la velocidad m√°xima se mantiene constantemente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ajustar los par√°metros de entrada para eliminar los retrasos, pero dan una sensaci√≥n de suavidad que vale la pena guardar. Podemos aplicar el valor m√°s extremo de los ejes como el coeficiente de movimiento de amortiguaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> Vector3 direction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance = moveSpeed * damping * Time.deltaTime;</code> </pre><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Movimiento con atenuaci√≥n. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora el movimiento funciona bien, al menos con un aumento en el zoom. </font><font style="vertical-align: inherit;">Pero a cierta distancia resulta ser demasiado lento. </font><font style="vertical-align: inherit;">Con el zoom reducido, necesitamos acelerar. </font><font style="vertical-align: inherit;">Esto se puede hacer reemplazando una variable </font></font><code>moveSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con dos para un zoom m√≠nimo y m√°ximo, y luego interpolando. </font><font style="vertical-align: inherit;">Asignarles valores de 400 y 100.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// public float moveSpeed; public float moveSpeedMinZoom, moveSpeedMaxZoom; void AdjustPosition (float xDelta, float zDelta) { Vector3 direction = new Vector3(xDelta, 0f, zDelta).normalized; float damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta)); float distance = Mathf.Lerp(moveSpeedMinZoom, moveSpeedMaxZoom, zoom) * damping * Time.deltaTime; Vector3 position = transform.localPosition; position += direction * distance; transform.localPosition = position; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/cb8/65e/5a9cb865ee0a67d4b3ad056317faf479.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La velocidad de movimiento var√≠a con el nivel de zoom. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ahora podemos movernos r√°pidamente por el mapa! </font><font style="vertical-align: inherit;">De hecho, podemos movernos mucho m√°s all√° del mapa, pero esto no es deseable. </font><font style="vertical-align: inherit;">La c√°mara debe permanecer dentro del mapa. </font><font style="vertical-align: inherit;">Para garantizar esto, necesitamos conocer los l√≠mites del mapa, por lo que se necesita un enlace a la cuadr√≠cula. </font><font style="vertical-align: inherit;">Agregar y conectarlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexGrid grid;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e71/f87/68e/e71f8768e16aee250700a7bd694a0e6b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesita solicitar el tama√±o de la cuadr√≠cula. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de pasar a una nueva posici√≥n, la limitaremos usando el nuevo m√©todo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localPosition = ClampPosition(position); } <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La posici√≥n X tiene un valor m√≠nimo de 0, y el m√°ximo est√° determinado por el tama√±o del mapa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lo mismo se aplica a la posici√≥n Z. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClampPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = grid.chunkCountZ * HexMetrics.chunkSizeZ * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, esto es un poco inexacto. </font><font style="vertical-align: inherit;">El punto de partida est√° en el centro de la celda, no a la izquierda. </font><font style="vertical-align: inherit;">Por lo tanto, queremos que la c√°mara se detenga en el centro de las celdas m√°s a la derecha. </font><font style="vertical-align: inherit;">Para hacer esto, reste la mitad de la celda del m√°ximo de X.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xMax = (grid.chunkCountX * HexMetrics.chunkSizeX - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * (<span class="hljs-number"><span class="hljs-number">2f</span></span> * HexMetrics.innerRadius); position.x = Mathf.Clamp(position.x, <span class="hljs-number"><span class="hljs-number">0f</span></span>, xMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por la misma raz√≥n, necesitamos reducir la Z m√°xima. Dado que las m√©tricas son ligeramente diferentes, necesitamos restar la celda completa. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zMax = (grid.chunkCountZ * HexMetrics.chunkSizeZ - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (<span class="hljs-number"><span class="hljs-number">1.5f</span></span> * HexMetrics.outerRadius); position.z = Mathf.Clamp(position.z, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zMax);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Con el movimiento que hemos terminado, solo queda un peque√±o detalle. </font><font style="vertical-align: inherit;">A veces, la interfaz de usuario reacciona a las teclas de flecha, y esto lleva al hecho de que cuando mueve la c√°mara, el control deslizante se mueve. </font><font style="vertical-align: inherit;">Esto sucede cuando la IU se considera activa, despu√©s de hacer clic en ella y el cursor contin√∫a sobre ella. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede evitar que la IU escuche la entrada del teclado. </font><font style="vertical-align: inherit;">Esto se puede hacer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instruyendo al</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objeto </font><em><font style="vertical-align: inherit;">EventSystem para</font></em><font style="vertical-align: inherit;"> que </font><font style="vertical-align: inherit;">no ejecute </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enviar eventos de navegaci√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/008/313/35c/00831335c530f6fcb06d4fe15890c316.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No m√°s eventos de navegaci√≥n.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Girar </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQuieres ver qu√© hay detr√°s del acantilado? </font><font style="vertical-align: inherit;">¬°Ser√≠a conveniente poder girar la c√°mara! </font><font style="vertical-align: inherit;">Agreguemos esta caracter√≠stica. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El nivel de zoom no es importante para la rotaci√≥n, solo la velocidad es suficiente. </font><font style="vertical-align: inherit;">Agregue una variable com√∫n </font></font><code>rotationSpeed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y config√∫rela en 180 grados. </font><font style="vertical-align: inherit;">Verifique el delta de rotaci√≥n </font></font><code>Update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al muestrear el eje de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotaci√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y cambiar la rotaci√≥n si es necesario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationSpeed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zoomDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Mouse ScrollWheel"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zoomDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustZoom(zoomDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Rotation"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustRotation(rotationDelta); } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> xDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Horizontal"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> zDelta = Input.GetAxis(<span class="hljs-string"><span class="hljs-string">"Vertical"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span> || zDelta != <span class="hljs-number"><span class="hljs-number">0f</span></span>) { AdjustPosition(xDelta, zDelta); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c17/189/c8f/c17189c8f16ef3e50aa8af32f7ff34c8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Velocidad de giro </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, el eje de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotaci√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><font style="vertical-align: inherit;">es </font><font style="vertical-align: inherit;">por defecto. </font><font style="vertical-align: inherit;">Tendremos que crearlo nosotros mismos. </font><font style="vertical-align: inherit;">Vaya a los par√°metros de entrada y duplique la entrada superior </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertical</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cambie el nombre del duplicado a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotaci√≥n</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y cambie las claves a QE y una coma (,) con un punto (.).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/549/6a8/50a/5496a850af906515b57a0d0fd1aea7b5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gire el eje de entrada.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Descargu√© unitypackage, ¬øpor qu√© no tengo esta entrada?</font></font></b> <div class="spoiler_text">     .       Unity.  ,     .    ,    ,     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El √°ngulo de rotaci√≥n que rastrearemos y cambiaremos </font></font><code>AdjustRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Despu√©s de lo cual giraremos todo el sistema de c√°mara.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> rotationAngle; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Como el c√≠rculo completo es de 360 ‚Äã‚Äãgrados, giramos el √°ngulo de rotaci√≥n para que est√© en el rango de 0 a 360. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta</span></span></span><span class="hljs-function">)</span></span> { rotationAngle += delta * rotationSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span>) { rotationAngle += <span class="hljs-number"><span class="hljs-number">360f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rotationAngle &gt;= <span class="hljs-number"><span class="hljs-number">360f</span></span>) { rotationAngle -= <span class="hljs-number"><span class="hljs-number">360f</span></span>; } transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, rotationAngle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convi√©rtete en acci√≥n. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora la rotaci√≥n est√° funcionando. </font><font style="vertical-align: inherit;">Si lo marca, puede ver que el movimiento es absoluto. </font><font style="vertical-align: inherit;">Por lo tanto, despu√©s de girar 180 grados, el movimiento ser√° lo contrario de lo que se esperaba. </font><font style="vertical-align: inherit;">Ser√≠a mucho m√°s conveniente para el usuario que el movimiento se realice en relaci√≥n con el √°ngulo de visi√≥n de la c√°mara. </font><font style="vertical-align: inherit;">Podemos hacer esto multiplicando la rotaci√≥n actual por la direcci√≥n del movimiento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AdjustPosition</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> xDelta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zDelta</span></span></span><span class="hljs-function">)</span></span> { Vector3 direction = transform.localRotation * <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(xDelta, <span class="hljs-number"><span class="hljs-number">0f</span></span>, zDelta).normalized; ‚Ä¶ }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desplazamiento relativo. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edici√≥n avanzada </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que tenemos un mapa m√°s grande, puede mejorar las herramientas de edici√≥n de mapas. </font><font style="vertical-align: inherit;">Cambiar una celda a la vez es demasiado largo, por lo que ser√≠a bueno crear un pincel m√°s grande. </font><font style="vertical-align: inherit;">Tambi√©n ser√° conveniente si puede elegir pintar o cambiar la altura, dejando todo lo dem√°s sin cambios.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Color y altura opcionales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos hacer que los colores sean opcionales agregando una opci√≥n de selecci√≥n vac√≠a al grupo de alternar. </font><font style="vertical-align: inherit;">Duplique uno de los conmutadores de color y reemplace su etiqueta con </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">---</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> o algo similar para indicar que no es un color. </font><font style="vertical-align: inherit;">Luego cambie el argumento de su evento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Value Changed</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a ‚àí1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/786/485/b0c/786485b0cbbae8edee6c80873f19afc3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√çndice de color no v√°lido </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, este √≠ndice no es v√°lido para una variedad de colores. </font><font style="vertical-align: inherit;">Podemos usarlo para determinar si el color debe aplicarse a las celdas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyColor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { applyColor = index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { activeColor = colors[index]; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } cell.Elevation = activeElevation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La altura est√° controlada por un control deslizante, por lo que no podemos agregarle un interruptor. </font><font style="vertical-align: inherit;">En cambio, podemos usar un interruptor separado para habilitar o deshabilitar la edici√≥n de altura. </font><font style="vertical-align: inherit;">Por defecto, estar√° habilitado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> applyElevation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un nuevo interruptor de altura a la interfaz de usuario. </font><font style="vertical-align: inherit;">Tambi√©n pondr√© todo en un nuevo panel y har√© que el control deslizante de altura sea horizontal para que la interfaz de usuario sea m√°s hermosa.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/cab/84d/07dcab84d8e8fe4daac4b6120df34d60.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color y altura opcionales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para habilitar la altura, necesitamos un nuevo m√©todo, que conectaremos con la interfaz de usuario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetApplyElevation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toggle</span></span></span><span class="hljs-function">)</span></span> { applyElevation = toggle; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al conectarlo al interruptor de altura, aseg√∫rese de que el m√©todo bool din√°mico se use en la parte superior de la lista de m√©todos. </font><font style="vertical-align: inherit;">Las versiones correctas no muestran una marca de verificaci√≥n en el inspector.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/887/d5b/1b2/887d5b1b275cb18957b63bcbecf145d4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transmitimos el estado del interruptor de altura. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos elegir solo colorear con flores o solo altura. </font><font style="vertical-align: inherit;">O ambos, como siempre. </font><font style="vertical-align: inherit;">Incluso podemos elegir no cambiar uno u otro, pero hasta ahora no es particularmente √∫til para nosotros.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar entre color y altura.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© la altura se apaga al elegir un color?</font></font></b> <div class="spoiler_text">  ,       toggle group. ,          ,     toggle group. </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tama√±o del pincel </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para admitir el tama√±o de pincel redimensionable, agregue una variable entera </font></font><code>brushSize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y un m√©todo para configurarlo a trav√©s de la interfaz de usuario. </font><font style="vertical-align: inherit;">Usaremos el control deslizante, por lo que nuevamente tendremos que convertir el valor de float a int.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> brushSize; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetBrushSize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span> { brushSize = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)size; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/794/bfb/60f/794bfb60f2f1c777fa0363ede3f19540.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Control deslizante del tama√±o del pincel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede crear un nuevo control deslizante duplicando el control deslizante de altura. </font><font style="vertical-align: inherit;">Cambie su valor m√°ximo a 4 y adj√∫ntelo al m√©todo correspondiente. </font><font style="vertical-align: inherit;">Tambi√©n le agregu√© una etiqueta.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88e/8b2/f58/88e8b2f58abfd48657387e6670c51215.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuraci√≥n del control deslizante del tama√±o del pincel. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que podemos editar varias celdas al mismo tiempo, necesitamos usar el m√©todo </font></font><code>EditCells</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este m√©todo llamar√° </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a todas las c√©lulas involucradas. </font><font style="vertical-align: inherit;">La celda seleccionada inicialmente se considerar√° el centro del pincel.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El tama√±o del pincel determina el radio de la edici√≥n. </font><font style="vertical-align: inherit;">Con un radio de 0, esta ser√° solo una celda central. </font><font style="vertical-align: inherit;">Con un radio de 1, este ser√° el centro y sus vecinos. </font><font style="vertical-align: inherit;">En un radio de 2, se activan los vecinos del centro y sus vecinos inmediatos.</font></font> Y as√≠ sucesivamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/612/14d/b65/61214db6508869c0ceda156c103ca032.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta el radio 3.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para editar celdas, debe recorrerlas en un bucle. </font><font style="vertical-align: inherit;">Primero necesitamos las coordenadas X y Z del centro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encontramos la coordenada Z m√≠nima restando el radio. </font><font style="vertical-align: inherit;">Entonces definimos la l√≠nea cero. </font><font style="vertical-align: inherit;">Comenzando en esta l√≠nea, hacemos un bucle hasta que cubrimos la l√≠nea en el centro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La primera celda en la fila inferior tiene la misma coordenada X que la celda central. </font><font style="vertical-align: inherit;">Esta coordenada disminuye al aumentar el n√∫mero de l√≠nea. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima celda siempre tiene una coordenada X igual a la coordenada central m√°s el radio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos recorrer cada fila y obtener celdas por sus coordenadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todav√≠a no tenemos un m√©todo </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con un par√°metro de coordenadas, as√≠ que cr√©elo. </font><font style="vertical-align: inherit;">Convierte a las coordenadas de los desplazamientos y obt√©n la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/490/9f2/b594909f28de1c2d52c954d312d7b90f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La parte inferior del pincel, tama√±o 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cubrimos el resto del pincel, realizando un ciclo de arriba a abajo hacia el centro. </font><font style="vertical-align: inherit;">En este caso, la l√≥gica se refleja y la fila central debe excluirse.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCells</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell center</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerX = center.coordinates.X; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> centerZ = center.coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - r; x &lt;= centerX + brushSize; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>, z = centerZ + brushSize; z &gt; centerZ; z--, r++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = centerX - brushSize; x &lt;= centerX + r; x++) { EditCell(hexGrid.GetCell(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCoordinates(x, z))); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/add/c7c/9e8addc7cf0012210cdd5dc0588bc6cf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo el pincel, tama√±o 2.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Esto funciona, a menos que nuestro pincel vaya m√°s all√° de los bordes de la cuadr√≠cula. </font><font style="vertical-align: inherit;">Cuando esto sucede, obtenemos una excepci√≥n de √≠ndice fuera de rango. </font><font style="vertical-align: inherit;">Para evitar esto, verifique los l√≠mites </font></font><code>HexGrid.GetCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y regrese </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando se solicite una celda inexistente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HexCell </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z = coordinates.Z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || z &gt;= cellCountZ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = coordinates.X + z / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || x &gt;= cellCountX) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cells[x + z * cellCountX]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar una excepci√≥n de referencia nula, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe comprobar antes de editar si la celda realmente existe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando m√∫ltiples tama√±os de pincel. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alternar visibilidad de etiqueta de celda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mayor√≠a de las veces, no necesitamos ver las etiquetas de las celdas. </font><font style="vertical-align: inherit;">As√≠ que hag√°moslos opcionales. </font><font style="vertical-align: inherit;">Como cada fragmento controla su propio lienzo, agregue un m√©todo </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Cuando la IU debe estar visible, activamos el lienzo. </font><font style="vertical-align: inherit;">De lo contrario, desact√≠velo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { gridCanvas.gameObject.SetActive(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ocultemos la IU por defecto. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que la visibilidad de la interfaz de usuario se cambia para todo el mapa, agregamos el m√©todo </font></font><code>ShowUI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>HexGrid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Simplemente pasa la solicitud a sus fragmentos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunks.Length; i++) { chunks[i].ShowUI(visible); } }</code> </pre> <br> <code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtiene el mismo m√©todo, pasando la solicitud a la cuadr√≠cula. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible</span></span></span><span class="hljs-function">)</span></span> { hexGrid.ShowUI(visible); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finalmente, podemos agregar un interruptor a la interfaz de usuario y conectarlo. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/120/637/740/120637740d174168d298407ec129c0d3.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interruptor de visibilidad de etiqueta. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 6: r√≠os </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar r√≠os a las c√©lulas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Soporte de arrastrar y soltar para dibujar r√≠os. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creando cauces. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando m√∫ltiples mallas por fragmento. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea un grupo de listas compartidas. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulaci√≥n y animaci√≥n del agua que fluye. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la parte anterior, hablamos sobre el soporte de mapas grandes. </font><font style="vertical-align: inherit;">Ahora podemos pasar a elementos de relieve m√°s grandes. </font><font style="vertical-align: inherit;">Esta vez hablaremos de los r√≠os.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/e66/4fb/56ae664fb799dd59d5d8e85397945937.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los r√≠os fluyen desde las monta√±as.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√©lulas de los r√≠os </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hay tres formas de agregar r√≠os a una cuadr√≠cula de hex√°gonos. La primera forma es dejarlos fluir de celda en celda. As√≠ es como se implementa en Endless Legend. La segunda forma es permitirles fluir entre las celdas, de borde a borde. Por lo tanto, se implementa en Civilization 5. La tercera forma no es crear estructuras especiales de r√≠os, sino utilizar celdas de agua para sugerirlas. Entonces, los r√≠os se implementan en Age of Wonders 3. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestro caso, los bordes de las celdas ya est√°n ocupados por laderas y acantilados. Esto deja poco espacio para los r√≠os. Por lo tanto, haremos que fluyan de una celda a otra. Esto significa que en cada celda no habr√° r√≠o, o un r√≠o fluir√° a lo largo de √©l, o habr√° un principio o un final del r√≠o en √©l. En aquellas celdas a lo largo de las cuales fluye el r√≠o, puede fluir en l√≠nea recta, girar uno o dos pasos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/db2/2a4/e7fdb22a4346f9281865ad95a1946f75.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinco posibles configuraciones fluviales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No admitiremos la ramificaci√≥n o fusi√≥n de r√≠os. </font><font style="vertical-align: inherit;">Esto complicar√° a√∫n m√°s las cosas, especialmente el flujo de agua. </font><font style="vertical-align: inherit;">Adem√°s, no nos dejar√°n perplejos los grandes vol√∫menes de agua. </font><font style="vertical-align: inherit;">Los consideraremos en otro tutorial.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguimiento del r√≠o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La celda a lo largo de la cual fluye el r√≠o puede considerarse simult√°neamente que tiene un r√≠o entrante y saliente. </font><font style="vertical-align: inherit;">Si contiene el comienzo de un r√≠o, entonces solo tiene un r√≠o saliente. </font><font style="vertical-align: inherit;">Y si contiene el final del r√≠o, entonces solo tiene un r√≠o entrante. </font><font style="vertical-align: inherit;">Podemos almacenar esta informaci√≥n </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usando dos valores booleanos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero esto no es suficiente. </font><font style="vertical-align: inherit;">Tambi√©n necesitamos saber la direcci√≥n de estos r√≠os. </font><font style="vertical-align: inherit;">En el caso de un r√≠o saliente, indica d√≥nde se est√° moviendo. </font><font style="vertical-align: inherit;">En el caso de un r√≠o entrante, indica de d√≥nde vino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasIncomingRiver, hasOutgoingRiver; HexDirection incomingRiver, outgoingRiver;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitaremos esta informaci√≥n cuando triangulemos celdas, por lo que agregaremos propiedades para tener acceso a ella. </font><font style="vertical-align: inherit;">No apoyaremos asignarlos directamente. </font><font style="vertical-align: inherit;">Para hacer esto, agregaremos un m√©todo adicional.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasIncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasOutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasOutgoingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection IncomingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> incomingRiver; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection OutgoingRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una pregunta importante es si hay un r√≠o en la celda, independientemente de los detalles. </font><font style="vertical-align: inherit;">Por lo tanto, agreguemos una propiedad para esto tambi√©n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiver { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver || hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra pregunta l√≥gica: es el principio o el final del r√≠o en la celda. </font><font style="vertical-align: inherit;">Si el estado del r√≠o entrante y saliente es diferente, entonces este es el caso. </font><font style="vertical-align: inherit;">Por lo tanto, haremos de esta otra propiedad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRiverBeginOrEnd { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver != hasOutgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y finalmente, ser√° √∫til saber si el r√≠o fluye a trav√©s de cierta cresta, ya sea entrante o saliente. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRiverThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver &amp;&amp; incomingRiver == direction || hasOutgoingRiver &amp;&amp; outgoingRiver == direction; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Remoci√≥n de r√≠os </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de comenzar a agregar un r√≠o a una celda, primero implementemos soporte para la eliminaci√≥n del r√≠o. </font><font style="vertical-align: inherit;">Para comenzar, escribiremos un m√©todo para eliminar solo la parte saliente del r√≠o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no hay un r√≠o saliente en la celda, entonces no se necesita hacer nada. </font><font style="vertical-align: inherit;">De lo contrario, ap√°guelo y realice la actualizaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero eso no es todo. </font><font style="vertical-align: inherit;">El r√≠o saliente debe moverse a alguna parte. </font><font style="vertical-align: inherit;">Por lo tanto, debe haber un vecino con el r√≠o entrante. </font><font style="vertical-align: inherit;">Tambi√©n tenemos que deshacernos de ella.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Refresh(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.Refresh(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo puede salir un r√≠o de un mapa?</font></font></b> <div class="spoiler_text">      ,     .     ,   . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminar un r√≠o de una celda solo cambia la apariencia de esa celda. </font><font style="vertical-align: inherit;">A diferencia de la altura o el color de edici√≥n, no afecta a los vecinos. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos actualizar solo la celda en s√≠, pero no sus vecinos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasOutgoingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(outgoingRiver); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este m√©todo </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplemente actualiza el fragmento al que pertenece la celda. </font><font style="vertical-align: inherit;">Como no cambiamos el r√≠o durante la inicializaci√≥n de la grilla, no debemos preocuparnos si ya se ha asignado un fragmento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefreshSelfOnly</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { chunk.Refresh(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminar los r√≠os entrantes funciona de la misma manera. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveIncomingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasIncomingRiver) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; RefreshSelfOnly(); HexCell neighbor = GetNeighbor(incomingRiver); neighbor.hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbor.RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y la eliminaci√≥n de todo el r√≠o simplemente significa la eliminaci√≥n de las partes entrantes y salientes del r√≠o. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RemoveOutgoingRiver(); RemoveIncomingRiver(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar r√≠os </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para apoyar la creaci√≥n de r√≠os, necesitamos un m√©todo para especificar el r√≠o saliente de la c√©lula. </font><font style="vertical-align: inherit;">Debe redefinir todos los r√≠os salientes anteriores y establecer el r√≠o entrante correspondiente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para empezar, no necesitamos hacer nada si el r√≠o ya existe.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, debemos asegurarnos de que haya un vecino en la direcci√≥n correcta. </font><font style="vertical-align: inherit;">Adem√°s, los r√≠os no pueden fluir hacia arriba. </font><font style="vertical-align: inherit;">Por lo tanto, debemos completar la operaci√≥n si el vecino es m√°s alto.</font></font><br><br><pre> <code class="cs hljs"> HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego tenemos que limpiar el r√≠o saliente anterior. </font><font style="vertical-align: inherit;">Y tambi√©n necesitamos eliminar el r√≠o entrante, si se superpone a un nuevo r√≠o saliente.</font></font><br><br><pre> <code class="cs hljs"> RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora podemos pasar a configurar el r√≠o de salida. </font></font><br><br><pre> <code class="cs hljs"> hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; RefreshSelfOnly();</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y no olvide configurar el r√≠o entrante para otra celda despu√©s de eliminar su r√≠o entrante actual, si existe. </font></font><br><br><pre> <code class="cs hljs"> neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; neighbor.incomingRiver = direction.Opposite(); neighbor.RefreshSelfOnly();</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deshacerse de los r√≠os que fluyen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que hemos hecho posible agregar solo los r√≠os correctos, otras acciones a√∫n pueden crear los incorrectos. </font><font style="vertical-align: inherit;">Cuando cambiamos la altura de la celda, nuevamente debemos asegurarnos de que los r√≠os solo puedan descender. </font><font style="vertical-align: inherit;">Todos los r√≠os irregulares deben ser eliminados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasOutgoingRiver &amp;&amp; elevation &lt; GetNeighbor(outgoingRiver).elevation ) { RemoveOutgoingRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( hasIncomingRiver &amp;&amp; elevation &gt; GetNeighbor(incomingRiver).elevation ) { RemoveIncomingRiver(); } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiar r√≠os </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para admitir la edici√≥n de r√≠os, debemos agregar un interruptor de r√≠o a la interfaz de usuario. </font><font style="vertical-align: inherit;">De hecho </font><font style="vertical-align: inherit;">Necesitamos soporte para tres modos de edici√≥n. </font><font style="vertical-align: inherit;">Necesitamos ignorar los r√≠os, agregarlos o eliminarlos. </font><font style="vertical-align: inherit;">Podemos usar una simple enumeraci√≥n auxiliar de conmutadores para rastrear el estado. </font><font style="vertical-align: inherit;">Como lo usaremos solo dentro del editor, podemos definirlo dentro de la clase </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, junto con el campo del modo r√≠o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OptionalToggle { Ignore, Yes, No } OptionalToggle riverMode;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y necesitamos un m√©todo para cambiar el r√©gimen del r√≠o a trav√©s de la interfaz de usuario. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para controlar el r√©gimen del r√≠o, agregue tres interruptores a la interfaz de usuario y con√©ctelos al nuevo grupo de alternancia, como hicimos con los colores. </font><font style="vertical-align: inherit;">Configur√© los interruptores para que sus etiquetas est√©n debajo de las casillas de verificaci√≥n. </font><font style="vertical-align: inherit;">Debido a esto, seguir√°n siendo lo suficientemente delgadas como para adaptarse a las tres opciones en una l√≠nea.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/1bf/d9c/0f51bfd9ce2a73bc23f1ef99cbd4b24e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≠os UI</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© no usar una lista desplegable?</font></font></b> <div class="spoiler_text">  ,    .   dropdown list  Unity        Play.    ,      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arrastrar y soltar reconocimiento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear un r√≠o, necesitamos tanto una celda como una direcci√≥n. </font><font style="vertical-align: inherit;">Por el momento, </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no nos proporciona esta informaci√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos agregar soporte para arrastrar y soltar de una celda a otra. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos saber si este arrastre ser√° correcto y tambi√©n determinar su direcci√≥n. </font><font style="vertical-align: inherit;">Y para reconocer el arrastrar y soltar, debemos recordar la celda anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isDrag; HexDirection dragDirection; HexCell previousCell;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, cuando no se realiza el arrastre, la celda anterior no. </font><font style="vertical-align: inherit;">Es decir, cuando no hay entrada o no interactuamos con la tarjeta, debe asignarle un valor </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Input.GetMouseButton(<span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject() ) { HandleInput(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { EditCells(hexGrid.GetCell(hit.point)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La celda actual es la que encontramos al cruzar el haz con la malla. </font><font style="vertical-align: inherit;">Despu√©s de editar celdas, se actualiza y se convierte en la celda anterior para una nueva actualizaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); EditCells(currentCell); previousCell = currentCell; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { previousCell = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de determinar la celda actual, podemos compararla con la celda anterior, si la hay. </font><font style="vertical-align: inherit;">Si obtenemos dos celdas diferentes, es posible que tengamos la funci√≥n de arrastrar y soltar correcta y necesitamos verificar esto. </font><font style="vertical-align: inherit;">De lo contrario, definitivamente no se trata de arrastrar y soltar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(inputRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { HexCell currentCell = hexGrid.GetCell(hit.point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell &amp;&amp; previousCell != currentCell) { ValidateDrag(currentCell); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } EditCells(currentCell); previousCell = currentCell; isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo verificamos el arrastrar y soltar? </font><font style="vertical-align: inherit;">Comprobando si la celda actual es vecina de la anterior. </font><font style="vertical-align: inherit;">Verificamos esto al eludir a sus vecinos en un ciclo. </font><font style="vertical-align: inherit;">Si encontramos una coincidencia, tambi√©n reconocemos inmediatamente la direcci√≥n del arrastre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidateDrag</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell currentCell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( dragDirection = HexDirection.NE; dragDirection &lt;= HexDirection.NW; dragDirection++ ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousCell.GetNeighbor(dragDirection) == currentCell) { isDrag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } isDrag = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øCrearemos drags desiguales?</font></font></b> <div class="spoiler_text">       ,          .         ¬´¬ª ,     . <br><br>    ,   .            . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cambiar celdas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que podemos reconocer arrastrar y soltar, podemos definir r√≠os salientes. </font><font style="vertical-align: inherit;">Tambi√©n podemos eliminar r√≠os; para esto, no se requiere soporte de arrastrar y soltar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { previousCell.SetOutgoingRiver(dragDirection); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este c√≥digo dibujar√° el r√≠o desde la celda anterior a la actual. </font><font style="vertical-align: inherit;">Pero ignora el tama√±o del pincel. </font><font style="vertical-align: inherit;">Esto es bastante l√≥gico, pero dibujemos los r√≠os para todas las celdas cerradas por el pincel. </font><font style="vertical-align: inherit;">Esto se puede hacer realizando operaciones en la celda editada. </font><font style="vertical-align: inherit;">En nuestro caso, debemos asegurarnos de que realmente exista otra c√©lula.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { otherCell.SetOutgoingRiver(dragDirection); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos editar los r√≠os, pero a√∫n no los vemos. </font><font style="vertical-align: inherit;">Podemos verificar que esto funciona examinando las celdas modificadas en el inspector de depuraci√≥n.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/927/46f/4fe92746f97fc517dc0d1da7c0aeee62.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una celda con un r√≠o en el inspector de depuraci√≥n.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© es un inspector de depuraci√≥n?</font></font></b> <div class="spoiler_text">             .        .    ,     . </div></div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cauces entre celdas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al triangular un r√≠o, debemos considerar dos partes: la ubicaci√≥n del lecho del r√≠o y el agua que fluye a trav√©s de √©l. </font><font style="vertical-align: inherit;">Primero, crearemos un canal y dejaremos el agua para m√°s tarde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La parte m√°s simple del r√≠o es donde fluye en uniones entre celdas. </font><font style="vertical-align: inherit;">Mientras estamos triangulando esta √°rea con una tira de tres quad. </font><font style="vertical-align: inherit;">Podemos agregarle un lecho de r√≠o bajando el quad central y agregando dos paredes de canal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/545/b3c/b93/545b3cb9373e9479011916513c3c51da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar un r√≠o a una tira de costilla. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para esto, en el caso del r√≠o, se requerir√°n dos quads adicionales y se crear√° un canal con dos paredes verticales. </font><font style="vertical-align: inherit;">Un enfoque alternativo es usar cuatro quad. </font><font style="vertical-align: inherit;">Luego bajamos el pico medio para crear una cama con paredes inclinadas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/7d9/ac1/7577d9ac1978be05cbdda0f8925c75d0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siempre cuatro quad. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El uso constante del mismo n√∫mero de cuadr√°ngulos es conveniente, as√≠ que elija esta opci√≥n.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar bordes de borde </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transici√≥n de tres a cuatro por borde requiere la creaci√≥n de un v√©rtice adicional del borde. </font><font style="vertical-align: inherit;">Reescribimos </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renombrando primero </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>v5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y luego renombrando </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Las acciones en este orden aseguran que todo el c√≥digo contin√∫e haciendo referencia a los v√©rtices correctos. </font><font style="vertical-align: inherit;">Use la opci√≥n de cambio de nombre o refactorizaci√≥n de su editor para que los cambios se apliquen en todas partes. </font><font style="vertical-align: inherit;">De lo contrario, tendr√° que inspeccionar manualmente todo el c√≥digo y realizar cambios.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de renombrar todo, agregue uno nuevo </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 v1, v2, v3, v4, v5;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un nuevo v√©rtice al constructor. </font><font style="vertical-align: inherit;">Se encuentra en el medio entre los picos de las esquinas. </font><font style="vertical-align: inherit;">Adem√°s, otros v√©rtices ahora deber√≠an estar en ¬Ω y ¬æ, y no en &amp; frac13; </font><font style="vertical-align: inherit;">y &amp; frac23;.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar </font></font><code>v3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y adentro </font></font><code>TerraceLerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EdgeVertices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TerraceLerp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices a, EdgeVertices b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> step</span></span></span><span class="hljs-function">)</span></span> { EdgeVertices result; result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step); result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step); result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step); result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step); result.v5 = HexMetrics.TerraceLerp(a.v5, b.v5, step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debo incluir un v√©rtice adicional en los abanicos de los tri√°ngulos de la costilla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeFan</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, EdgeVertices edge, Color color</span></span></span><span class="hljs-function">)</span></span> { AddTriangle(center, edge.v1, edge.v2); AddTriangleColor(color); AddTriangle(center, edge.v2, edge.v3); AddTriangleColor(color); AddTriangle(center, edge.v3, edge.v4); AddTriangleColor(color); AddTriangle(center, edge.v4, edge.v5); AddTriangleColor(color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Y tambi√©n en sus franjas de cuadr√°ngulos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2 </span></span></span><span class="hljs-function">)</span></span> { AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); AddQuadColor(c1, c2); AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); AddQuadColor(c1, c2); AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); AddQuadColor(c1, c2); AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); AddQuadColor(c1, c2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/89d/599/81989d5996d7c2832e3dd7f61b4a9bb1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/9b1/6a2/6259b16a2776344c51725d32d70001e8.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaci√≥n de cuatro y cinco v√©rtices por borde.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La altura del lecho del r√≠o </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creamos el canal bajando la parte superior inferior de la costilla. </font><font style="vertical-align: inherit;">Determina la posici√≥n vertical del lecho del r√≠o. </font><font style="vertical-align: inherit;">Aunque la posici√≥n vertical exacta de cada celda est√° distorsionada, debemos mantener la misma altura del lecho del r√≠o en celdas con la misma altura. </font><font style="vertical-align: inherit;">Gracias a esta agua, no tiene que fluir corriente arriba. </font><font style="vertical-align: inherit;">Adem√°s, la cama debe ser lo suficientemente baja como para permanecer debajo, incluso en el caso de las celdas verticales m√°s desviadas, y al mismo tiempo dejar suficiente espacio para el agua. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos a establecer este desplazamiento </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y expresarlo como altura. </font><font style="vertical-align: inherit;">Las compensaciones de un nivel ser√°n suficientes.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos usar esta m√©trica para agregar propiedades </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para obtener la posici√≥n vertical del lecho del r√≠o celular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> StreamBedY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.streamBedElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Creando un canal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una de las seis partes triangulares de una celda se triangula, podemos determinar si un r√≠o fluye a lo largo de su borde. </font><font style="vertical-align: inherit;">Si es as√≠, entonces podemos bajar el pico medio de la costilla a la altura del lecho del r√≠o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; } TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0d/a57/028/d0da570288985442d990858b2831c07a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambia el v√©rtice medio de la costilla. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos ver c√≥mo aparecen los primeros signos del r√≠o, pero surgen agujeros en el relieve. </font><font style="vertical-align: inherit;">Para cerrarlos, necesitamos cambiar otro borde y luego triangular la conexi√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateConnection</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, EdgeVertices e1 </span></span></span><span class="hljs-function">)</span></span> { HexCell neighbor = cell.GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbor == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 bridge = HexMetrics.GetBridge(direction); bridge.y = neighbor.Position.y - cell.Position.y; EdgeVertices e2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( e1.v1 + bridge, e1.v5 + bridge ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4c/aa9/5f4/b4caa95f424004569e7876bc19c73a20.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canales completos de costillas. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cauces que pasan por una celda </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora tenemos los cauces correctos entre las celdas. Pero cuando el r√≠o fluye a trav√©s de la celda, los canales siempre terminan en su centro. Para resolver este problema tendr√° que funcionar. Comencemos con el caso cuando un r√≠o fluye a trav√©s de una celda directamente, de un borde al otro. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no hay r√≠o, entonces cada parte de la celda puede ser un simple abanico de tri√°ngulos. Pero cuando el r√≠o fluye directamente, es necesario insertar un canal. De hecho, necesitamos estirar el v√©rtice central en una l√≠nea, convirtiendo los dos tri√°ngulos del medio en cuadr√°ngulos. Entonces el abanico de tri√°ngulos se convierte en un trapecio.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a9/919/ffb/9a9919ffbb99bcded8d44f45e62c3955.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insertamos el canal en el tri√°ngulo. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dichos canales ser√°n mucho m√°s largos que los que pasan a trav√©s de la conexi√≥n de las c√©lulas. </font><font style="vertical-align: inherit;">Esto se hace evidente cuando las posiciones de los v√©rtices est√°n distorsionadas. </font><font style="vertical-align: inherit;">Por lo tanto, dividamos el trapecio en dos segmentos insertando otro conjunto de bordes de v√©rtice en el medio entre el centro y el borde.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/f94/109/650f9410923cb781f145b5211dbe4950.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulaci√≥n de canales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como la triangulaci√≥n con un r√≠o ser√° muy diferente de la triangulaci√≥n sin un r√≠o, creemos un m√©todo separado para ello. </font><font style="vertical-align: inherit;">Si tenemos un r√≠o, entonces usamos este m√©todo, de lo contrario dejaremos un abanico de tri√°ngulos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector3 center = cell.Position; EdgeVertices e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( center + HexMetrics.GetFirstSolidCorner(direction), center + HexMetrics.GetSecondSolidCorner(direction) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (direction &lt;= HexDirection.SE) { TriangulateConnection(direction, cell, e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/f0f/526/928f0f526852960fce6c37bdb480b5bc.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agujeros en los que deber√≠a haber r√≠os. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para ver mejor lo que sucede, desactive temporalmente la distorsi√≥n celular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">0f</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 4f;</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2aa/f49/ae3/2aaf49ae366805585727f1a1ed11c2aa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Picos sin distorsi√≥n.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulaci√≥n directamente a trav√©s de la c√©lula. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para crear un canal directamente a trav√©s de parte de la celda, necesitamos estirar el centro en una l√≠nea. </font><font style="vertical-align: inherit;">Esta l√≠nea debe tener el mismo ancho que el canal. </font><font style="vertical-align: inherit;">Podemos encontrar el v√©rtice izquierdo moviendo ¬º de la distancia desde el centro hasta la primera esquina de la parte anterior.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Del mismo modo para el v√©rtice derecho. </font><font style="vertical-align: inherit;">En este caso, necesitamos la segunda esquina de la siguiente parte.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; Vector3 centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La l√≠nea media se puede encontrar creando bordes de v√©rtice entre el centro y el borde. </font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A continuaci√≥n, cambie el v√©rtice medio de la costilla media, as√≠ como el centro, porque se convertir√°n en los puntos m√°s bajos del canal. </font></font><br><br><pre> <code class="cs hljs"> m.v3.y = center.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para llenar el espacio entre la l√≠nea media y la l√≠nea de borde.</font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ab/050/b30/3ab050b301f8815479142c5b8feae26e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canales comprimidos</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desafortunadamente, los canales se ven comprimidos. Esto sucede porque los v√©rtices medios de la costilla est√°n demasiado cerca uno del otro. ¬øPor qu√© sucedi√≥ esto? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si suponemos que la longitud del borde exterior es 1, entonces la longitud de la l√≠nea central ser√° ¬Ω. Dado que el borde medio est√° en el medio entre ellos, su longitud debe ser igual a ¬æ. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ancho del canal es ¬Ω y debe permanecer constante. Como la longitud del borde medio es ¬æ, solo queda ¬º, seg√∫n &amp; frac18; a ambos lados del canal.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e1/25f/037/2e125f03727f078ccfd094a29ad4d596.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Longitudes relativas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como la longitud del borde medio es ¬æ, entonces &amp; frac18; </font><font style="vertical-align: inherit;">se vuelve relativo a la longitud de la costilla media igual a &amp; frac16;. </font><font style="vertical-align: inherit;">Esto significa que sus v√©rtices segundo y cuarto deben interpolarse con sextos, no con cuartos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos proporcionar soporte para dicha interpolaci√≥n alternativa agregando a </font></font><code>EdgeVertices</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">otro constructor. </font><font style="vertical-align: inherit;">En lugar de interpolaciones fijas para </font></font><code>v2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>v4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usemos un par√°metro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EdgeVertices</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 corner1, Vector3 corner2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outerStep</span></span></span><span class="hljs-function">)</span></span> { v1 = corner1; v2 = Vector3.Lerp(corner1, corner2, outerStep); v3 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); v4 = Vector3.Lerp(corner1, corner2, <span class="hljs-number"><span class="hljs-number">1f</span></span> - outerStep); v5 = corner2; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usarlo con &amp; frac16; </font><font style="vertical-align: inherit;">c </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(centerL, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(centerR, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), <span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">6f</span></span> );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4a/df8/cb5/c4adf8cb5aa6b1685f6d5c592976ea3b.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canales directos </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una vez hecho el canal recto, podemos ir a la segunda parte del trapecio. </font><font style="vertical-align: inherit;">En este caso, no podemos usar la tira el√°stica, por lo que debemos hacerlo manualmente. </font><font style="vertical-align: inherit;">Primero creemos tri√°ngulos en los lados.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10b/dc7/a5b/10bdc7a5b1d32d03dbc155a2d00bbfb5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri√°ngulos laterales </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se ve bien, as√≠ que llenemos el espacio restante con dos cuadr√°ngulos, creando la √∫ltima parte del canal.</font></font><br><br><pre> <code class="cs hljs"> AddTriangle(centerL, m.v1, m.v2); AddTriangleColor(cell.Color); AddQuad(centerL, center, m.v2, m.v3); AddQuadColor(cell.Color); AddQuad(center, centerR, m.v3, m.v4); AddQuadColor(cell.Color); AddTriangle(centerR, m.v4, m.v5); AddTriangleColor(cell.Color);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De hecho, no tenemos una alternativa que </font></font><code>AddQuadColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requiera solo un par√°metro. </font><font style="vertical-align: inherit;">Si bien no lo necesitamos. </font><font style="vertical-align: inherit;">As√≠ que vamos a crearlo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadColor</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Color color</span></span></span><span class="hljs-function">)</span></span> { colors.Add(color); colors.Add(color); colors.Add(color); colors.Add(color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af0/b62/c32/af0b62c3232b36cd0a136b1fc009b7dd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canales rectos completados.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicio y fin de triangulaci√≥n </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La triangulaci√≥n de una parte que solo tiene el principio o el final de un r√≠o es bastante diferente y, por lo tanto, requiere su propio m√©todo. </font><font style="vertical-align: inherit;">Por lo tanto, revisaremos esto </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y llamaremos al m√©todo apropiado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este caso, queremos completar el canal en el centro, pero a√∫n utilizamos dos etapas para esto. </font><font style="vertical-align: inherit;">Por lo tanto, crearemos nuevamente el borde medio entre el centro o el borde. </font><font style="vertical-align: inherit;">Como queremos completar el canal, estamos muy contentos de que se comprima.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para que el canal no sea poco profundo demasiado r√°pido, asignaremos la altura del lecho del r√≠o al pico medio. </font><font style="vertical-align: inherit;">Pero el centro no necesita ser cambiado.</font></font><br><br><pre> <code class="cs hljs"> m.v3.y = e.v3.y;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos triangular con una tira de costilla y un abanico. </font></font><br><br><pre> <code class="cs hljs"> TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16b/0c5/9e0/16b0c59e0999f2a505e709648c1e1af7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puntos de inicio y fin.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Giros de un paso </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego, considere las curvas cerradas que zigzaguean entre las celdas adyacentes. </font><font style="vertical-align: inherit;">Nosotros tambi√©n los manejaremos </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos determinar con qu√© tipo de r√≠o estamos trabajando.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/523/c03/e37/523c03e370096f804df6b84a97dbdfbf.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√≠o Zigzag </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la celda tiene un r√≠o que fluye en la direcci√≥n opuesta, as√≠ como en la direcci√≥n con la que estamos trabajando, entonces este deber√≠a ser un r√≠o recto. </font><font style="vertical-align: inherit;">En este caso, podemos guardar la l√≠nea central que ya hemos calculado. </font><font style="vertical-align: inherit;">De lo contrario, vuelve a un punto, doblando la l√≠nea central.</font></font><br><br><pre> <code class="cs hljs"> Vector3 centerL, centerR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90c/992/4c0/90c9924c049cf8033e7480c90b74b903.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzags rizados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos reconocer giros bruscos comprobando si la celda tiene un r√≠o que pasa por la parte siguiente o anterior de la celda. </font><font style="vertical-align: inherit;">Si lo hay, entonces debemos alinear la l√≠nea central con el borde entre esta y la parte vecina. </font><font style="vertical-align: inherit;">Podemos hacer esto colocando el lado correspondiente de la l√≠nea en el medio entre el centro y el √°ngulo com√∫n. </font><font style="vertical-align: inherit;">El otro lado de la l√≠nea se convierte en el centro.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habiendo decidido d√≥nde est√°n los puntos izquierdo y derecho, podemos determinar el centro resultante promediando. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { ‚Ä¶ } center = Vector3.Lerp(centerL, centerR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f14/cc6/4f9/f14cc64f953da69fb270ff2adf613b2e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Costilla central desplazada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque el canal tiene el mismo ancho en ambos lados, se ve bastante comprimido. </font><font style="vertical-align: inherit;">Esto es causado al girar la l√≠nea central 60 ¬∞. </font><font style="vertical-align: inherit;">Puede suavizar este efecto aumentando ligeramente el ancho de la l√≠nea central. </font><font style="vertical-align: inherit;">En lugar de interpolar con ¬Ω, usamos &amp; frac23;.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/c01/ea3/28cc01ea3d203243a1dfe49cde5e9802.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzag sin compresi√≥n.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Giros de dos etapas. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los casos restantes son entre zigzags y r√≠os rectos. </font><font style="vertical-align: inherit;">Estas son curvas de dos etapas que crean r√≠os suavemente curvados.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/67d/bab/9b2/67dbab9b235833d69b3201c9b38ac653.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El r√≠o serpenteante. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para distinguir entre dos orientaciones posibles, necesitamos usar </font></font><code>direction.Next().Next()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero vamos a hacer que sea m√°s conveniente mediante la adici√≥n de </font></font><code>HexDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todos de extensi√≥n </font></font><code>Next2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Previous2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Previous2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction -= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &gt;= HexDirection.NE ? direction : (direction + <span class="hljs-number"><span class="hljs-number">6</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HexDirection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Next2</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { direction += <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction &lt;= HexDirection.NW ? direction : (direction - <span class="hljs-number"><span class="hljs-number">6</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De vuelta a </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ahora podemos reconocer la direcci√≥n de nuestro r√≠o serpenteante con </font></font><code>direction.Next2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Opposite())) { centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { centerL = center; centerR = Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { centerL = Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">2f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = centerR = center; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En estos dos √∫ltimos casos, necesitamos desplazar la l√≠nea central a la parte de la celda que se encuentra en el interior de la curva. </font><font style="vertical-align: inherit;">Si tuvi√©ramos un vector en el medio de un borde s√≥lido, entonces podr√≠amos usarlo para colocar el punto final. </font><font style="vertical-align: inherit;">Imaginemos que tenemos un m√©todo para esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; centerR = center; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, ahora necesitamos agregar dicho m√©todo a </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Solo tiene que promediar dos vectores de √°ngulos adyacentes y aplicar el coeficiente de integridad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSolidEdgeMiddle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] + corners[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction + <span class="hljs-number"><span class="hljs-number">1</span></span>]) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * solidFactor); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be1/058/429/be1058429e3d36cd25b8e1da0c1be77a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curvas ligeramente comprimidas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestras l√≠neas centrales ahora est√°n rotadas correctamente 30 ¬∞. </font><font style="vertical-align: inherit;">Pero no son lo suficientemente largos, por eso los canales est√°n un poco comprimidos. </font><font style="vertical-align: inherit;">Esto sucede porque el punto medio de la costilla est√° m√°s cerca del centro que el √°ngulo de la costilla. </font><font style="vertical-align: inherit;">Su distancia es igual al radio interno, no al externo. </font><font style="vertical-align: inherit;">Es decir, estamos trabajando en la escala incorrecta. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya estamos convirtiendo de radio externo a interno en </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Necesitamos realizar la operaci√≥n inversa. </font><font style="vertical-align: inherit;">As√≠ que hagamos disponibles ambos factores de conversi√≥n a trav√©s de </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerToInner = <span class="hljs-number"><span class="hljs-number">0.866025404f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerToOuter = <span class="hljs-number"><span class="hljs-number">1f</span></span> / outerToInner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> outerRadius = <span class="hljs-number"><span class="hljs-number">10f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> innerRadius = outerRadius * outerToInner;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos pasar a la escala correcta </font></font><code>HexMesh.TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Los canales seguir√°n un poco apretados debido a su turno, pero esto es mucho menos pronunciado que en el caso de los zigzags. </font><font style="vertical-align: inherit;">Por lo tanto, no necesitamos compensar esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next2())) { centerL = center; centerR = center + HexMetrics.GetSolidEdgeMiddle(direction.Next()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { centerL = center + HexMetrics.GetSolidEdgeMiddle(direction.Previous()) * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> * HexMetrics.innerToOuter); centerR = center; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a2/849/49c/2a284949c066c558391613611b93d093.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curvas suaves. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulaci√≥n en las cercan√≠as de los r√≠os. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestros r√≠os est√°n listos. </font><font style="vertical-align: inherit;">Pero a√∫n no hemos triangulado otras partes de las c√©lulas que contienen los r√≠os. </font><font style="vertical-align: inherit;">Ahora cerraremos estos agujeros.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f47/5fd/74d/f475fd74d147a577e8adb72cd1ff63fb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agujeros cerca de los canales. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la celda tiene un r√≠o, pero no fluye en la direcci√≥n actual, </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamaremos a un nuevo m√©todo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e.v3.y = cell.StreamBedY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { TriangulateWithRiverBeginOrEnd(direction, cell, center, e); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateAdjacentToRiver(direction, cell, center, e); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeFan(center, e, cell.Color); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este m√©todo, llenamos el tri√°ngulo de la celda con una tira y un abanico. </font><font style="vertical-align: inherit;">Solo un abanico no ser√° suficiente para nosotros, porque los picos deben corresponder al borde medio de las partes que contienen el r√≠o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) ); TriangulateEdgeStrip(m, cell.Color, e, cell.Color); TriangulateEdgeFan(center, m, cell.Color); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/059/4df/7bb/0594df7bb3225d20852c9e0d0d708101.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superposici√≥n en curvas y r√≠os rectos.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coincide con el canal </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, tenemos que hacer que el centro que utilizamos coincida con la parte central utilizada por las partes del r√≠o. </font><font style="vertical-align: inherit;">Con los zigzags, todo est√° en orden, y las curvas y los r√≠os rectos requieren atenci√≥n. </font><font style="vertical-align: inherit;">Por lo tanto, necesitamos determinar tanto el tipo de r√≠o como su orientaci√≥n relativa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comencemos por verificar si estamos dentro de la curva. </font><font style="vertical-align: inherit;">En este caso, tanto la direcci√≥n anterior como la siguiente contienen el r√≠o. </font><font style="vertical-align: inherit;">Si es as√≠, entonces necesitamos mover el centro al borde.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } } EdgeVertices m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EdgeVertices( Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/016/620/d89/016620d89847368d487d49bb1c81cdc7.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se corrigi√≥ un caso en el que el r√≠o flu√≠a desde ambos lados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si tenemos un r√≠o en una direcci√≥n diferente, pero no en la anterior, entonces verificamos si es recto. </font><font style="vertical-align: inherit;">Si es as√≠, mueva el centro a la primera esquina.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1d/85a/366/a1d85a3669a55984eb69a43af5e8631f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se corrigi√≥ la mitad superpuesta con un r√≠o recto. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces resolvimos el problema con la mitad de las partes adyacentes a los r√≠os rectos. </font><font style="vertical-align: inherit;">El √∫ltimo caso: tenemos un r√≠o en la direcci√≥n anterior, y es recto. </font><font style="vertical-align: inherit;">En este caso, debe mover el centro a la siguiente esquina.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { center += HexMetrics.GetSolidEdgeMiddle(direction) * (HexMetrics.innerToOuter * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous2()) ) { center += HexMetrics.GetFirstSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cell.HasRiverThroughEdge(direction.Previous()) &amp;&amp; cell.HasRiverThroughEdge(direction.Next2()) ) { center += HexMetrics.GetSecondSolidCorner(direction) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9d/d1a/20c/c9dd1a20c213658aeed27b9065e6bf58.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No m√°s superposiciones. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generalizaci√≥n HexMesh </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hemos completado la triangulaci√≥n de canales. </font><font style="vertical-align: inherit;">Ahora podemos llenarlos con agua. </font><font style="vertical-align: inherit;">Como el agua es diferente de la tierra, necesitaremos usar una malla diferente con diferentes datos de v√©rtice y material diferente. </font><font style="vertical-align: inherit;">Ser√≠a bastante conveniente si pudi√©ramos usar </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tanto sushi como agua. </font><font style="vertical-align: inherit;">As√≠ que generalicemos </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convirti√©ndolo en una clase que se ocupe de estas mallas, independientemente de para qu√© se use. </font><font style="vertical-align: inherit;">Vamos a pasar la tarea de triangular sus celdas </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moviendo el M√©todo Perturb </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como el m√©todo es </font></font><code>Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bastante generalizado y se usar√° en diferentes lugares, vamos a moverlo a </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Primero, c√°mbiele el nombre a </font></font><code>HexMetrics.Perturb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Este es un nombre de m√©todo incorrecto, pero refactoriza todo el c√≥digo para su uso correcto. </font><font style="vertical-align: inherit;">Si su editor de c√≥digo tiene una funcionalidad especial para mover m√©todos, √∫selo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al mover el m√©todo hacia adentro </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, h√°galo general y est√°tico, y luego corrija su nombre.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Perturb</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 position</span></span></span><span class="hljs-function">)</span></span> { Vector4 sample = SampleNoise(position); position.x += (sample.x * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; position.z += (sample.z * <span class="hljs-number"><span class="hljs-number">2f</span></span> - <span class="hljs-number"><span class="hljs-number">1f</span></span>) * cellPerturbStrength; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position; }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√©todos de triangulaci√≥n en movimiento </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reemplazar la variable </font></font><code>hexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con una variable com√∫n </font></font><code>terrain</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain; <span class="hljs-comment"><span class="hljs-comment">// HexMesh hexMesh; void Awake () { gridCanvas = GetComponentInChildren&lt;Canvas&gt;(); // hexMesh = GetComponentInChildren&lt;HexMesh&gt;(); cells = new HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ]; ShowUI(false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A continuaci√≥n, refactorizamos todos los m√©todos </font></font><code>Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>terrain.Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Luego mueva todos los m√©todos </font></font><code>Triangulate‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A continuaci√≥n, puede corregir los nombres de los m√©todos </font></font><code>Add‚Ä¶</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y hacerlos com√∫n. </font><font style="vertical-align: inherit;">Como resultado, se encontrar√°n todos los m√©todos de triangulaci√≥n complejos </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se mantendr√°n m√©todos simples para agregar datos a la malla </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A√∫n no hemos terminado. </font><font style="vertical-align: inherit;">Ahora </font></font><code>HexGridChunk.LateUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deber√≠a llamar a su propio m√©todo </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Adem√°s, ya no deber√≠a pasar celdas como argumento. </font><font style="vertical-align: inherit;">Por lo tanto, </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puede perder su par√°metro. </font><font style="vertical-align: inherit;">Y debe delegar la limpieza y la aplicaci√≥n de los datos de malla </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Triangulate(); <span class="hljs-comment"><span class="hljs-comment">// hexMesh.Triangulate(cells); enabled = false; } public void Triangulate () { terrain.Clear(); // hexMesh.Clear(); // vertices.Clear(); // colors.Clear(); // triangles.Clear(); for (int i = 0; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); // hexMesh.vertices = vertices.ToArray(); // hexMesh.colors = colors.ToArray(); // hexMesh.triangles = triangles.ToArray(); // hexMesh.RecalculateNormals(); // meshCollider.sharedMesh = hexMesh; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A√±adir los m√©todos necesarios </font></font><code>Clear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>Apply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices.Clear(); colors.Clear(); triangles.Clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); hexMesh.SetColors(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa con SetVertices, SetColors y SetTriangles?</font></font></b> <div class="spoiler_text">        <code>Mesh</code> .        .  ,           . <br><br>  <code>SetTriangles</code>    integer,    .      ,    . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finalmente, adjunte manualmente el elemento secundario de la malla al fragmento prefabricado. </font><font style="vertical-align: inherit;">Ya no podemos hacer esto autom√°ticamente porque pronto agregaremos un segundo hijo a la malla. </font><font style="vertical-align: inherit;">C√°mbiele el nombre a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terreno</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para indicar su prop√≥sito.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/614/3b4/0dc/6143b40dc88ecec6761348d9e6208944.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asignar un alivio.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambiar el nombre de un ni√±o prefabricado no funciona?</font></font></b> <div class="spoiler_text">          .    ,   .  ,     <em>Apply</em> ,       .        . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crear grupos de listas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque hemos movido bastante c√≥digo, nuestro mapa a√∫n deber√≠a funcionar igual que antes. </font><font style="vertical-align: inherit;">Agregar otra malla al fragmento no cambiar√° esto. </font><font style="vertical-align: inherit;">Pero si hacemos esto con el presente </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pueden surgir errores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El problema es que asumimos que solo trabajar√≠amos con una malla a la vez. </font><font style="vertical-align: inherit;">Esto nos permiti√≥ usar listas est√°ticas para almacenar datos temporales de malla. </font><font style="vertical-align: inherit;">Pero despu√©s de agregar agua, trabajaremos simult√°neamente con dos mallas, por lo que ya no podremos usar listas est√°ticas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, no volveremos a los conjuntos de listas para cada instancia </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">En su lugar, usamos un grupo de listas est√°ticas. </font><font style="vertical-align: inherit;">Por defecto, esta agrupaci√≥n no existe, as√≠ que comencemos creando una clase com√∫n de agrupaci√≥n de listas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo funciona ListPool &lt;T&gt;?</font></font></b> <div class="spoiler_text">     ,  <code>List&lt;int&gt;</code>    .  <code>&lt;T&gt;</code>    <code>ListPool</code> ,  ,    .      ,    <code>T</code> (  template). </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para almacenar una colecci√≥n de listas en un grupo, podemos usar la pila. </font><font style="vertical-align: inherit;">Por lo general, no uso listas porque Unity no las serializa, pero en este caso no importa.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListPool</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Stack&lt;List&lt;T&gt;&gt; stack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;List&lt;T&gt;&gt;(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© significa stack &lt;list &lt;t&gt;&gt;?</font></font></b> <div class="spoiler_text">     .  ,     .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un m√©todo est√°tico com√∫n para obtener la lista del grupo. </font><font style="vertical-align: inherit;">Si la pila no est√° vac√≠a, extraeremos la lista superior y devolveremos esta. </font><font style="vertical-align: inherit;">De lo contrario, crearemos una nueva lista en su lugar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stack.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stack.Pop(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;T&gt;(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para reutilizar las listas, debe agregarlas al grupo despu√©s de que termine de trabajar con ellas. </font></font><code>ListPool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borrar√° la lista y la empujar√° a la pila.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;T&gt; list</span></span></span><span class="hljs-function">)</span></span> { list.Clear(); stack.Push(list); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar las piscinas en </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Reemplace las listas est√°ticas con enlaces privados no est√°ticos. </font><font style="vertical-align: inherit;">Vamos a marcarlos </font></font><code>NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que Unity no los conserve durante la compilaci√≥n. </font><font style="vertical-align: inherit;">O escriba </font></font><code>System.NonSerialized</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o agregue </font></font><code>using System;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al comienzo del gui√≥n.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">NonSerialized</span></span>] List&lt;Vector3&gt; vertices; [NonSerialized] List&lt;Color&gt; colors; [NonSerialized] List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; triangles; <span class="hljs-comment"><span class="hljs-comment">// static List&lt;Vector3&gt; vertices = new List&lt;Vector3&gt;(); // static List&lt;Color&gt; colors = new List&lt;Color&gt;(); // static List&lt;int&gt; triangles = new List&lt;int&gt;();</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dado que la malla se limpia justo antes de agregarle nuevos datos, es aqu√≠ donde debe obtener listas de los grupos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); colors = ListPool&lt;Color&gt;.Get(); triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Despu√©s de aplicar estas mallas, ya no las necesitamos, as√≠ que aqu√≠ podemos agregarlas a las piscinas. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); hexMesh.SetTriangles(triangles, <span class="hljs-number"><span class="hljs-number">0</span></span>); ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Add(triangles); hexMesh.RecalculateNormals(); meshCollider.sharedMesh = hexMesh; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As√≠ que implementamos el uso m√∫ltiple de listas, independientemente de cu√°ntas mallas llenemos al mismo tiempo. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colisionador opcional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque nuestro terreno necesita un colisionador, no es realmente necesario para los r√≠os. </font><font style="vertical-align: inherit;">Los rayos simplemente pasar√°n por el agua y se cruzar√°n con el canal debajo. </font><font style="vertical-align: inherit;">Hag√°moslo para que podamos configurar la presencia de un colisionador para </font></font><code>HexMesh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nos damos cuenta de esto agregando un campo com√∫n </font></font><code>bool useCollider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para el terreno, lo activamos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e7/f19/a3c/4e7f19a3c7eb01a1432618a8be6903e5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando un colisionador de malla. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos crear y asignar el colisionador solo cuando est√° activado.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mesh(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;(); } hexMesh.name = <span class="hljs-string"><span class="hljs-string">"Hex Mesh"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useCollider) { meshCollider.sharedMesh = hexMesh; } ‚Ä¶ }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colores opcionales </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los colores de v√©rtice tambi√©n pueden ser opcionales. </font><font style="vertical-align: inherit;">Los necesitamos para demostrar varios tipos de alivio, pero el agua no cambia de color. </font><font style="vertical-align: inherit;">Podemos hacerlos opcionales al igual que hicimos que el colisionador sea opcional.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por supuesto, el terreno debe usar los colores de los v√©rtices, as√≠ que act√≠valos. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/624/c01/bbd/624c01bbda8ad0250747b9c1af852590.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uso de colores.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UV opcional </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mientras hacemos esto, tambi√©n podemos agregar soporte para coordenadas UV opcionales. </font><font style="vertical-align: inherit;">Aunque el alivio no los usa, los necesitaremos para el agua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useCollider, useColors, useUVCoordinates; [NonSerialized] List&lt;Vector2&gt; uvs; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.Clear(); vertices = ListPool&lt;Vector3&gt;.Get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { colors = ListPool&lt;Color&gt;.Get(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { uvs = ListPool&lt;Vector2&gt;.Get(); } triangles = ListPool&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.Get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { hexMesh.SetVertices(vertices); ListPool&lt;Vector3&gt;.Add(vertices); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useColors) { hexMesh.SetColors(colors); ListPool&lt;Color&gt;.Add(colors); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (useUVCoordinates) { hexMesh.SetUVs(<span class="hljs-number"><span class="hljs-number">0</span></span>, uvs); ListPool&lt;Vector2&gt;.Add(uvs); } ‚Ä¶ }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/a99/559/b01a9955989cdc83a2e8de2582c1cbeb.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No utilizamos coordenadas UV. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para usar esta funci√≥n, cree m√©todos para agregar coordenadas UV a tri√°ngulos y cuadr√°ngulos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddTriangleUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2 uv1, Vector2 uv2, Vector3 uv3, Vector3 uv4</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(uv1); uvs.Add(uv2); uvs.Add(uv3); uvs.Add(uv4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agreguemos un m√©todo adicional </font></font><code>AddQuadUV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para agregar convenientemente un √°rea rectangular de UV. </font><font style="vertical-align: inherit;">Este es el caso est√°ndar cuando el quad y su textura son iguales, lo usaremos para el agua del r√≠o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddQuadUV</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uMax, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vMax</span></span></span><span class="hljs-function">)</span></span> { uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMin)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMin, vMax)); uvs.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(uMax, vMax)); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√≠os actuales </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Finalmente es hora de crear agua! </font><font style="vertical-align: inherit;">Haremos esto con un quad, que indicar√° la superficie del agua. </font><font style="vertical-align: inherit;">Y como trabajamos con r√≠os, el agua debe fluir. </font><font style="vertical-align: inherit;">Para hacer esto, usamos coordenadas UV que indican la orientaci√≥n del r√≠o. </font><font style="vertical-align: inherit;">Para visualizar esto, necesitamos un nuevo sombreador. </font><font style="vertical-align: inherit;">Por lo tanto, cree un nuevo sombreador est√°ndar y ll√°melo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">C√°mbielo para que las coordenadas UV se registren en los canales de albedo verde y rojo.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/River" { ‚Ä¶ <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex) * _Color; o.Albedo = c.rgb * <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.color; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A√±adir al </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo general </font></font><code>HexMesh rivers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lo limpiamos y lo aplicamos de la misma manera que en el caso del alivio.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øTendremos llamadas adicionales, incluso si no tenemos r√≠os?</font></font></b> <div class="spoiler_text">  Unity  ,        .     ,  -  . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambie el prefab (a trav√©s de la instancia), duplicando su objeto de terreno, renombr√°ndolo a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y conect√°ndolo.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/0d6/680/efd0d66801d78d636d07f59b34e5c615.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e46/119/b43/e46119b43f4cd398d96261715975a36a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmento prefabricado con r√≠os. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crea el material </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">River</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> usando nuestro nuevo sombreador y haz que el objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers lo</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> use </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tambi√©n configuramos el componente de malla hexagonal del objeto para que use coordenadas UV, pero no use colores de v√©rtice ni el colisionador.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7df/db6/134/7dfdb6134b4dc27d843db92492b61708.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Subobjeto R√≠os.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agua triangular </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de poder triangular el agua, necesitamos determinar el nivel de su superficie. </font><font style="vertical-align: inherit;">Hagamos un cambio de altura </font></font><code>HexMetrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, como hicimos con el lecho del r√≠o. </font><font style="vertical-align: inherit;">Como la distorsi√≥n vertical de la celda es igual a la mitad del desplazamiento de altura, us√©mosla para desplazar la superficie del r√≠o. </font><font style="vertical-align: inherit;">Por lo tanto, garantizamos que el agua nunca estar√° por encima de la topograf√≠a de la celda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> riverSurfaceElevationOffset = <span class="hljs-number"><span class="hljs-number">-0.5f</span></span>;</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© no hacerlo un poco m√°s bajo?</font></font></b> <div class="spoiler_text">          ,   . ,         . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue una </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad para obtener la posici√≥n vertical de la superficie de su r√≠o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RiverSurfaceY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (elevation + HexMetrics.riverSurfaceElevationOffset) * HexMetrics.elevationStep; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Ahora podemos trabajar </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">! </font><font style="vertical-align: inherit;">Como crearemos muchos cuadr√°ngulos de r√≠os, agreguemos un m√©todo separado para esto. </font><font style="vertical-align: inherit;">Vamos a darle cuatro v√©rtices y una altura como par√°metros. </font><font style="vertical-align: inherit;">Esto nos permitir√° establecer convenientemente la posici√≥n vertical de los cuatro v√©rtices simult√°neamente antes de agregar quad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregaremos aqu√≠ las coordenadas UV del cuadril√°tero. </font><font style="vertical-align: inherit;">Simplemente vaya de izquierda a derecha y de abajo hacia arriba.</font></font><br><br><pre> <code class="cs hljs"> rivers.AddQuad(v1, v2, v3, v4); rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>);</code> </pre> <br> <code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Este es el primer m√©todo al que agregaremos los cuadr√°ngulos de los r√≠os. </font><font style="vertical-align: inherit;">El primer quad est√° entre el centro y el medio. </font><font style="vertical-align: inherit;">El segundo es entre el medio y la costilla. </font><font style="vertical-align: inherit;">Solo usamos los v√©rtices que ya tenemos. </font><font style="vertical-align: inherit;">Como estos picos se subestimar√°n, el agua como resultado estar√° parcialmente debajo de las paredes inclinadas del canal. </font><font style="vertical-align: inherit;">Por lo tanto, no necesitamos preocuparnos por la posici√≥n exacta del borde del agua.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ TriangulateRiverQuad(centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY); TriangulateRiverQuad(m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/418/a40/e9c/418a40e9c73fd3da885ce467e475ff63.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Los primeros signos de agua. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPor qu√© cambia el ancho del agua?</font></font></b> <div class="spoiler_text">  ,     ,      ‚Äî .           .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Movi√©ndose con la corriente </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualmente, las coordenadas UV no son consistentes con la direcci√≥n del r√≠o. </font><font style="vertical-align: inherit;">Necesitamos mantener la coherencia aqu√≠. </font><font style="vertical-align: inherit;">Suponga que la coordenada U es 0 en el lado izquierdo del r√≠o y 1 en el derecho, cuando se mira aguas abajo. </font><font style="vertical-align: inherit;">Y la coordenada V debe variar de 0 a 1 en la direcci√≥n del r√≠o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando esta especificaci√≥n, los UV ser√°n correctos cuando el r√≠o saliente sea triangulado, pero resultar√°n incorrectos y deber√°n cambiarse cuando el r√≠o entrante sea triangulado. </font><font style="vertical-align: inherit;">Para simplificar el trabajo, agregue al </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metro </font></font><code>bool reversed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">√öselo para voltear los rayos UV si es necesario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = v3.y = v4.y = y; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sabemos que necesitamos invertir la direcci√≥n cuando se trata de un r√≠o entrante.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.IncomingRiver == direction; TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed );</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/546/c86/e9d/546c86e9d2d8752caa30523098283542.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La direcci√≥n acordada de los r√≠os.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El principio y el fin del r√≠o. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el interior, </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo necesitamos verificar si tenemos un r√≠o entrante para determinar la direcci√≥n del flujo. </font><font style="vertical-align: inherit;">Luego podemos insertar otro r√≠o cu√°druple entre el medio y la costilla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithRiverBeginOrEnd</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reversed = cell.HasIncomingRiver; TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, reversed ); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La parte entre el centro y el medio es un tri√°ngulo, por lo que no podemos usarlo </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La √∫nica diferencia significativa aqu√≠ es que el pico central est√° en el medio del r√≠o. </font><font style="vertical-align: inherit;">Por lo tanto, su coordenada U siempre es igual a ¬Ω.</font></font><br><br><pre> <code class="cs hljs"> center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c04/07f/539/c0407f539ce2ff6a91081e84062a4097.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agua al principio y al final.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øFaltan porciones de agua en los extremos?</font></font></b> <div class="spoiler_text">       ,   quad  ,     .           .           . <br><br>      ,  .     ,      .      . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flujo entre celdas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al agregar agua entre las celdas, debemos tener cuidado con la diferencia de altura. </font><font style="vertical-align: inherit;">Para que el agua pueda fluir por laderas y acantilados, </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debe soportar dos par√°metros de altura. </font><font style="vertical-align: inherit;">As√≠ que agreguemos una segunda.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { v1.y = v2.y = y1; v3.y = v4.y = y2; rivers.AddQuad(v1, v2, v3, v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, para mayor comodidad, agreguemos una opci√≥n que recibir√° una altura. </font><font style="vertical-align: inherit;">Simplemente llamar√° a otro m√©todo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, reversed); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos agregar quad river y adentro </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Al estar entre las celdas, no podemos saber de inmediato con qu√© tipo de r√≠o estamos tratando. </font><font style="vertical-align: inherit;">Para determinar si es necesario un giro, debemos verificar si tenemos un r√≠o entrante y si se est√° moviendo en nuestra direcci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction)) { e2.v3.y = neighbor.StreamBedY; TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/283/1f2/62e/2831f262ed46e82bebabf45d0a8215f2.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El r√≠o completado.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estiramiento de coordenadas V </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ahora, en cada segmento del r√≠o, tenemos coordenadas V que van de 0 a 1. Es decir, solo hay cuatro de ellas en la celda. Cinco si tambi√©n agregamos conexiones entre celdas. Cualquier cosa que usemos para texturizar el r√≠o, debe repetirse la misma cantidad de veces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos reducir el n√∫mero de repeticiones estirando las coordenadas V para que pasen de 0 a 1 en toda la celda m√°s una conexi√≥n. Esto se puede hacer aumentando la coordenada V en cada segmento en 0.2. Si ponemos 0.4 en el centro, entonces en el medio se convertir√° en 0.6, y en el borde llegar√° a 0.8. Luego, en la conexi√≥n celular, el valor ser√° 1.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si el r√≠o fluye en la direcci√≥n opuesta, todav√≠a podemos poner 0.4 en el centro, pero en el medio se convierte en 0.2, y en el borde - 0. Si continuamos esto hasta que la celda se una, obtenemos -0.2 como resultado. </font><font style="vertical-align: inherit;">Esto es normal porque es similar a 0,8 para una textura con modo de filtrado de repetici√≥n, del mismo modo que 0 es equivalente a 1.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22e/4de/cd9/22e4decd99e9c2f0c9312be9eaaceb9a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambio de coordenadas V.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para crear soporte para esto, necesitamos agregar </font></font><code>TriangulateRiverQuad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un par√°metro m√°s.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { TriangulateRiverQuad(v1, v2, v3, v4, y, y, v, reversed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRiverQuad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reversed </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cuando la direcci√≥n no se invierte, simplemente usamos la coordenada transmitida en la parte inferior del cuadr√°ngulo y agregamos 0.2 en la parte superior. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, v, v + <span class="hljs-number"><span class="hljs-number">0.2f</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Podemos trabajar con una direcci√≥n invertida restando la coordenada de 0.8 y 0.6. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span> - v, <span class="hljs-number"><span class="hljs-number">0.6f</span></span> - v); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora debemos transmitir las coordenadas correctas, como si estuvi√©ramos tratando con un r√≠o saliente. </font><font style="vertical-align: inherit;">Vamos a comenzar con </font></font><code>TriangulateWithRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( centerL, centerR, m.v2, m.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>, reversed ); TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambie de la siguiente manera.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( e1.v2, e1.v4, e2.v2, e2.v4, cell.RiverSurfaceY, neighbor.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, cell.HasIncomingRiver &amp;&amp; cell.IncomingRiver == direction );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por √∫ltimo </font></font><code>TriangulateWithRiverBeginOrEnd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> TriangulateRiverQuad( m.v2, m.v4, e.v2, e.v4, cell.RiverSurfaceY, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>, reversed ); center.y = m.v2.y = m.v4.y = cell.RiverSurfaceY; rivers.AddTriangle(center, m.v2, m.v4); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reversed) { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rivers.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0.6f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44e/786/63f/44e78663f2d77264660f30917a5e1a94.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenadas V estiradas.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para visualizar correctamente el plegado de las coordenadas V, aseg√∫rese de que sigan siendo positivas en el sombreador del r√≠o.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; } o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aec/30e/a84/aec30ea849af0c8ba42cd6e0cef44635.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenadas </font></font></i> <font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">contra√≠das </font></a><i><font style="vertical-align: inherit;">V. </font></i></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unitpackage</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Animaci√≥n del r√≠o </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habiendo terminado con las coordenadas UV, podemos pasar a animar los r√≠os. El sombreador de r√≠os har√° esto para que no tengamos que actualizar constantemente la malla. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No crearemos un sombreador de r√≠o complejo en este tutorial, pero lo haremos m√°s adelante. Por ahora, crearemos un efecto simple que permita comprender c√≥mo funciona la animaci√≥n. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La animaci√≥n se crea cambiando las coordenadas V en funci√≥n del tiempo del juego. Unity le permite obtener su valor utilizando una variable </font></font><code>_Time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Su componente Y contiene el tiempo sin cambios, que usamos. Otros componentes contienen diferentes escalas de tiempo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminaremos el plegado a lo largo de V, porque ya no lo necesitamos. En cambio, restamos el tiempo actual de la coordenada V. Esto desplaza la coordenada hacia abajo, lo que crea la ilusi√≥n de la corriente que fluye aguas abajo del r√≠o.</font></font><br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y += <span class="hljs-number"><span class="hljs-number">1</span></span>; // } <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En un segundo, la coordenada V en todos los puntos ser√° inferior a cero, por lo que ya no veremos la diferencia. </font><font style="vertical-align: inherit;">Nuevamente, esto es normal cuando se usa el filtrado en el modo de repetici√≥n de textura. </font><font style="vertical-align: inherit;">Pero para ver qu√© sucede, podemos tomar la parte fraccionaria de la coordenada V.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y -= _Time.y; <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y = frac(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.y); o.Albedo.rg = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coordenadas animadas V.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Uso de ruido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora nuestro r√≠o est√° animado, pero en la direcci√≥n y velocidad hay transiciones bruscas. </font><font style="vertical-align: inherit;">Nuestro patr√≥n UV los hace bastante obvios, pero ser√° m√°s dif√≠cil de reconocer si usa un patr√≥n m√°s parecido al agua. </font><font style="vertical-align: inherit;">Entonces, en lugar de mostrar UV en bruto, muestreemos la textura. </font><font style="vertical-align: inherit;">Podemos usar nuestra textura de ruido existente. </font><font style="vertical-align: inherit;">Lo muestreamos y multiplicamos el color del material por el primer canal de ruido.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.y -= _Time.y; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); fixed4 c = _Color * noise.r; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asigne la textura de ruido al material del r√≠o y aseg√∫rese de que sea blanco. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc8/dd4/e4e/dc8dd4e4ee9b92f2f104ba3107da30ce.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3f/0ca/319/b3f0ca31928fd594a715868ebbb7265c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando textura de ruido. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como las coordenadas V est√°n muy estiradas, la textura del ruido tambi√©n se extiende a lo largo del r√≠o. </font><font style="vertical-align: inherit;">Lamentablemente, el curso no es muy bonito. </font><font style="vertical-align: inherit;">Tratemos de estirarlo de otra manera, reduciendo en gran medida la escala de las coordenadas de U. Un dieciseisavo ser√° suficiente. </font><font style="vertical-align: inherit;">Esto significa que solo tomaremos muestras de una banda estrecha de textura de ruido.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x *= <span class="hljs-number"><span class="hljs-number">0.0625</span></span>; uv.y -= _Time.y;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa9/957/2a9/aa99572a9c0ad3daaa7b5b4eb3978cc0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estirar la coordenada U.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tambi√©n reduzcamos la velocidad a un cuarto por segundo para que la finalizaci√≥n del ciclo de textura tome cuatro segundos.</font></font><br><br><pre> <code class="hljs"> uv.y -= _Time.y * 0.25;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ruido actual.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mezcla de ruido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo ya se ve mucho mejor, pero el patr√≥n siempre sigue siendo el mismo. El agua no se comporta as√≠. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como usamos solo una peque√±a banda de ruido, podemos variar el patr√≥n cambiando esta banda a lo largo de la textura. Esto se hace agregando tiempo a la coordenada U. Debemos hacerlo lentamente, de lo contrario el r√≠o parecer√° fluir de lado. Probemos el coeficiente de 0.005. Esto significa que lleva 200 segundos completar el patr√≥n.</font></font><br><br><pre> <code class="hljs markdown"> uv.x = uv.x <span class="hljs-bullet"><span class="hljs-bullet">* 0.0625 + _Time.y *</span></span> 0.005;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruido en movimiento. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, esto no se ve muy hermoso. </font><font style="vertical-align: inherit;">El agua todav√≠a parece est√°tica y el cambio es claramente notable, aunque es muy lento. </font><font style="vertical-align: inherit;">Podemos ocultar el cambio combinando dos muestras de ruido y desplaz√°ndolas en direcciones opuestas. </font><font style="vertical-align: inherit;">Y si usamos valores ligeramente diferentes para mover la segunda muestra, crearemos una animaci√≥n ligera del cambio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, nunca superponemos el mismo patr√≥n de ruido, usamos un canal diferente para la segunda muestra.</font></font><br><br><pre> <code class="hljs pgsql"> float2 uv = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv.x = uv.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> + _Time.y * <span class="hljs-number"><span class="hljs-number">0.005</span></span>; uv.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.25</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, uv); float2 uv2 = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex; uv2.x = uv2.x * <span class="hljs-number"><span class="hljs-number">0.0625</span></span> - _Time.y * <span class="hljs-number"><span class="hljs-number">0.0052</span></span>; uv2.y -= _Time.y * <span class="hljs-number"><span class="hljs-number">0.23</span></span>; <span class="hljs-type"><span class="hljs-type">float4</span></span> noise2 = tex2D(_MainTex, uv2); fixed4 c = _Color * (noise.r * noise2.a);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Una combinaci√≥n de dos patrones de ruido cambiantes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agua transl√∫cida </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuestro patr√≥n se ve bastante din√°mico. </font><font style="vertical-align: inherit;">El siguiente paso es hacerlo transl√∫cido. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, aseg√∫rese de que el agua no arroje sombras. </font><font style="vertical-align: inherit;">Puede deshabilitarlos a trav√©s del componente de representaci√≥n del objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el prefabricado.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a61/894/e14/a61894e14d9999315d59b5ff0c0de517.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La proyecci√≥n de sombras est√° desactivada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora cambie el sombreador al modo transparente. </font><font style="vertical-align: inherit;">Para indicar esto, use etiquetas de sombreador. </font><font style="vertical-align: inherit;">Luego agregue la </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">palabra clave </font><font style="vertical-align: inherit;">a la l√≠nea </font></font><code>alpha</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mientras estamos aqu√≠, puede eliminar la palabra clave </font></font><code>fullforwardshadows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque todav√≠a no proyectamos sombras.</font></font><br><br><pre> <code class="hljs cs"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard alpha // fullforwardshadows #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> target 3.0</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora cambiaremos la forma en que establecemos el color del r√≠o. </font><font style="vertical-align: inherit;">En lugar de multiplicar el ruido por el color, le agregaremos ruido. </font><font style="vertical-align: inherit;">Luego usamos la funci√≥n </font></font><code>saturate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para limitar el resultado para que no exceda 1.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = saturate(_Color + noise.r * noise2.a);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto nos permitir√° usar el color del material como color base. </font><font style="vertical-align: inherit;">El ruido aumentar√° su brillo y opacidad. </font><font style="vertical-align: inherit;">Intentemos usar un color azul con una opacidad bastante baja. </font><font style="vertical-align: inherit;">Como resultado, obtenemos agua azul transl√∫cida con salpicaduras blancas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/3f7/5a1/af83f75a143aabdd3b83525e4114fc3b.png"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agua transl√∫cida coloreada. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finalizaci√≥n </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que todo parece estar funcionando, es hora de distorsionar los picos nuevamente. </font><font style="vertical-align: inherit;">Adem√°s de deformar los bordes de las celdas, esto har√° que nuestros r√≠os sean desiguales.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cellPerturbStrength = <span class="hljs-number"><span class="hljs-number">4f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c8/ff5/96b/8c8ff596bc247be79a30122e49ca27f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ca/664/808/6ca66480859e94d00e2e558caa17cbf4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Picos distorsionados y distorsionados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinemos el terreno en busca de problemas que hayan surgido debido a la distorsi√≥n. </font><font style="vertical-align: inherit;">Parece que son! </font><font style="vertical-align: inherit;">Echemos un vistazo a las cascadas altas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df1/95b/a33/df195ba33947744e97173412373f5ad4.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agua truncada por acantilados.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> El agua que cae de una cascada alta desaparece detr√°s de un acantilado. Cuando esto sucede, es muy notable, por lo que debemos hacer algo al respecto. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mucho menos obvio es que las cascadas pueden ser inclinadas, en lugar de descender directamente hacia abajo. Aunque el agua en realidad no fluye as√≠, no es particularmente notable. Nuestro cerebro lo interpretar√° de tal manera que nos parezca normal. As√≠ que ign√≥ralo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s f√°cil de evitar la p√©rdida de agua es profundizando los cauces de los r√≠os. Entonces crearemos m√°s espacio entre la superficie del agua y el lecho del r√≠o. Tambi√©n har√° que las paredes del canal sean m√°s verticales, por lo que no debe ir demasiado profundo. Preguntemos</font></font><code>HexMetrics.streamBedElevationOffset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor -1.75. </font><font style="vertical-align: inherit;">Esto resolver√° la mayor parte de los problemas y la cama no ser√° demasiado profunda. </font><font style="vertical-align: inherit;">Parte del agua seguir√° cortada, pero no todas las cascadas.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> streamBedElevationOffset = <span class="hljs-number"><span class="hljs-number">-1.75f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57b/80c/d26/57b80cd2687ff6afb9be83176e984b7d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canales en profundidad. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parte 7: caminos </font></font></h1><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A√±adir soporte vial. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangular el camino. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combinamos caminos y r√≠os. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mejora del aspecto de las carreteras. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f7/b24/05e/9f7b2405e5ceed9842cc1ebd7b549b0a.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los primeros signos de civilizaci√≥n.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Celdas con caminos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que los r√≠os, los caminos van de celda en celda, a trav√©s de los bordes de la celda. </font><font style="vertical-align: inherit;">La gran diferencia es que no fluye agua en las carreteras, por lo que son bidireccionales. </font><font style="vertical-align: inherit;">Adem√°s, se requieren intersecciones para una red de carreteras funcional, por lo que debemos admitir m√°s de dos carreteras por celda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si permite que los caminos vayan en las seis direcciones, la celda puede contener de cero a seis caminos. </font><font style="vertical-align: inherit;">Eso es un total de catorce posibles configuraciones de carreteras. </font><font style="vertical-align: inherit;">Esto es mucho m√°s que cinco configuraciones posibles de r√≠os. </font><font style="vertical-align: inherit;">Para manejar esto, necesitamos usar un enfoque m√°s general que pueda manejar todas las configuraciones.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d46/965/5b7/d469655b7efdbab33a6cac1c42e61a7e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14 posibles configuraciones de carreteras.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seguimiento de carreteras </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s sencilla de rastrear carreteras en una celda es usar una matriz de valores booleanos. </font><font style="vertical-align: inherit;">Agregue el campo privado de la matriz </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y h√°galo serializable para que pueda verlo en el inspector. </font><font style="vertical-align: inherit;">Establezca el tama√±o de la matriz a trav√©s de la celda prefabricada para que admita seis caminos.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] roads;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/439/167/2c4/4391672c4c1de9075138eef3f1cafd73.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Celda prefabricada con seis caminos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue un m√©todo para verificar si la celda tiene una ruta en cierta direcci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasRoadThroughEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n ser√° conveniente saber si hay al menos un camino en la celda, por lo que agregaremos una propiedad para esto. </font><font style="vertical-align: inherit;">Simplemente recorra la matriz en el bucle y regrese </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tan pronto como encontremos el camino. </font><font style="vertical-align: inherit;">Si no hay caminos, regrese </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasRoads { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminaci√≥n de carreteras </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que con los r√≠os, agregaremos un m√©todo para eliminar todos los caminos de la celda. </font><font style="vertical-align: inherit;">Esto se puede hacer con un bucle que desconecta cada carretera que estaba habilitada anteriormente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por supuesto, tambi√©n debemos desactivar las costosas celdas correspondientes en los vecinos. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de eso, necesitamos actualizar cada una de las celdas. </font><font style="vertical-align: inherit;">Dado que los caminos son locales a las celdas, necesitamos actualizar solo las celdas sin sus vecinos.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { roads[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)i).Opposite()] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; neighbors[i].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agregar caminos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar carreteras es similar a eliminar carreteras. </font><font style="vertical-align: inherit;">La √∫nica diferencia es que asignamos un valor a Boolean </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Podemos crear un m√©todo privado que pueda realizar ambas operaciones. </font><font style="vertical-align: inherit;">Entonces ser√° posible usarlo tanto para agregar como para eliminar el camino.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveRoads</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; neighbors.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i]) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { roads[index] = state; neighbors[index].roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)((HexDirection)index).Opposite()] = state; neighbors[index].RefreshSelfOnly(); RefreshSelfOnly(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No podemos tener un r√≠o y una carretera yendo en la misma direcci√≥n al mismo tiempo. </font><font style="vertical-align: inherit;">Por lo tanto, antes de agregar el camino, verificaremos si hay un lugar para ello.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction)) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, las carreteras no se pueden combinar con acantilados porque son demasiado afiladas. </font><font style="vertical-align: inherit;">¬øO tal vez vale la pena allanar el camino a trav√©s de un acantilado bajo, pero no a trav√©s de un alto? </font><font style="vertical-align: inherit;">Para determinar esto, necesitamos crear un m√©todo que nos indique la diferencia de altura en cierta direcci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetElevationDifference</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> difference = elevation - GetNeighbor(direction).elevation; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> difference &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ? difference : -difference; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos hacer que las carreteras se sumen a una diferencia de altura suficientemente peque√±a. </font><font style="vertical-align: inherit;">Me limitar√© solo a las pendientes, es decir, un m√°ximo de 1 unidad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !roads[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction] &amp;&amp; !HasRiverThroughEdge(direction) &amp;&amp; GetElevationDifference(direction) &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ) { SetRoad((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eliminar las carreteras equivocadas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hicimos carreteras solo agregar cuando est√° permitido. </font><font style="vertical-align: inherit;">Ahora debemos asegurarnos de que se eliminen si luego se vuelven incorrectos, por ejemplo, al agregar un r√≠o. </font><font style="vertical-align: inherit;">Podemos prohibir la colocaci√≥n de r√≠os en la parte superior de las carreteras, pero los r√≠os no se ven interrumpidos por las carreteras. </font><font style="vertical-align: inherit;">Deja que laven el camino del camino. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√° suficiente para nosotros pedir el camino </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, independientemente de si era el camino. </font><font style="vertical-align: inherit;">Siempre se actualizar√° ambas c√©lulas, de modo que ya no hay necesidad de llamar expl√≠citamente </font></font><code>RefreshSelfOnly</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>SetOutgoingRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOutgoingRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } HexCell neighbor = GetNeighbor(direction); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbor || elevation &lt; neighbor.elevation) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } RemoveOutgoingRiver(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasIncomingRiver &amp;&amp; incomingRiver == direction) { RemoveIncomingRiver(); } hasOutgoingRiver = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; outgoingRiver = direction; <span class="hljs-comment"><span class="hljs-comment">// RefreshSelfOnly(); neighbor.RemoveIncomingRiver(); neighbor.hasIncomingRiver = true; neighbor.incomingRiver = direction.Opposite(); // neighbor.RefreshSelfOnly(); SetRoad((int)direction, false); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otra operaci√≥n que puede equivocar el camino es un cambio de altura. </font><font style="vertical-align: inherit;">En este caso, tendremos que buscar carreteras en todas las direcciones. </font><font style="vertical-align: inherit;">Si la diferencia de altura es demasiado grande, entonces se debe eliminar la carretera existente.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Elevation { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> elevation; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; roads.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roads[i] &amp;&amp; GetElevationDifference((HexDirection)i) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { SetRoad(i, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } } Refresh(); } }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Edici√≥n de carreteras </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editar carreteras funciona igual que editar r√≠os. </font><font style="vertical-align: inherit;">Por lo tanto </font></font><code>HexMapEditor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se requiere un interruptor m√°s, m√°s un m√©todo para establecer su estado.</font></font><br><br><pre> <code class="cs hljs"> OptionalToggle riverMode, roadMode; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRiverMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { riverMode = (OptionalToggle)mode; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetRoadMode</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode</span></span></span><span class="hljs-function">)</span></span> { roadMode = (OptionalToggle)mode; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El m√©todo </font></font><code>EditCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahora deber√≠a admitir la eliminaci√≥n con la adici√≥n de carreteras. </font><font style="vertical-align: inherit;">Esto significa que al arrastrar y soltar, puede realizar una de dos acciones posibles. </font><font style="vertical-align: inherit;">Estamos reestructurando un poco el c√≥digo para que, al realizar la operaci√≥n de arrastrar y soltar correcta, se verifiquen los estados de ambos interruptores.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EditCell</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexCell cell</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyColor) { cell.Color = activeColor; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (applyElevation) { cell.Elevation = activeElevation; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.No) { cell.RemoveRiver(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.No) { cell.RemoveRoads(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDrag) { HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (otherCell) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (riverMode == OptionalToggle.Yes) { otherCell.SetOutgoingRiver(dragDirection); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (roadMode == OptionalToggle.Yes) { otherCell.AddRoad(dragDirection); } } } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos agregar r√°pidamente una barra de ruta a la interfaz de usuario copiando la barra de r√≠o y cambiando el m√©todo llamado por los interruptores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado, tenemos una interfaz de usuario bastante alta. </font><font style="vertical-align: inherit;">Para solucionar esto, cambi√© el dise√±o del panel de color para que se ajuste a los paneles m√°s compactos de carreteras y r√≠os.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fd/de5/a8a/0fdde5a8a4abc86308b771f43b36bf4a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IU con carreteras. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ahora uso dos l√≠neas de tres opciones para los colores, hay espacio para otro color. </font><font style="vertical-align: inherit;">As√≠ que agregu√© un art√≠culo para naranja.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a06/9c6/08d/a069c608dfe531a5e1b2a8c59fef5846.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/12a/499/e9612a49993e3a2d4cb20790186ecf02.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cinco colores: amarillo, verde, azul, naranja y blanco. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos editar las carreteras, pero hasta ahora no son visibles. </font><font style="vertical-align: inherit;">Puede usar el inspector para asegurarse de que todo est√© funcionando.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/160/c4f/0e4/160c4f0e496acec2a2a2d739152a7cfa.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Celda con caminos en el inspector. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Triangulaci√≥n de carreteras </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mostrar carreteras, debe triangularlas. </font><font style="vertical-align: inherit;">Esto es similar a crear una malla para r√≠os, solo el cauce no aparecer√° en el relieve. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero, cree un nuevo sombreador est√°ndar que usar√° nuevamente las coordenadas UV para pintar la superficie de la carretera.</font></font><br><br><pre> <code class="hljs pgsql">Shader "Custom/Road" { Properties { _Color ("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex ("Albedo (RGB)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _Glossiness ("Smoothness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.5</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Standard fullforwardshadows #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> sampler2D _MainTex; struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = fixed4(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crea un material de carretera con este sombreador. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/973/9e3/2b8/9739e32b82ad2148c559b8f7c4caa868.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Camino material. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establezca la prefabricaci√≥n del fragmento para que reciba otra malla secundaria de hex√°gonos para las carreteras. </font><font style="vertical-align: inherit;">Esta malla no debe proyectar sombras y debe usar solo coordenadas UV. </font><font style="vertical-align: inherit;">La forma m√°s r√°pida de hacerlo es a trav√©s de una instancia prefabricada: duplicar el objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rivers</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y reemplazar su material.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/476/a9e/bf8476a9e950a13c69051a5cd43480c1.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a64/4d8/776/a644d8776f3c6f0ba64cf3aef666f475.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carreteras de objetos secundarios. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de eso, agr√©guelo al </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo general </font></font><code>HexMesh roads</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e incl√∫yalo en </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Con√©ctelo en el inspector con el objeto </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carreteras</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexMesh terrain, rivers, roads; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { terrain.Clear(); rivers.Clear(); roads.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cells.Length; i++) { Triangulate(cells[i]); } terrain.Apply(); rivers.Apply(); roads.Apply(); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a95/c0e/c2a/a95c0ec2ae59dccbb249e6a02ccdc7c5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objeto Roads est√° conectado.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caminos entre celdas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero veamos los segmentos de camino entre las celdas. </font><font style="vertical-align: inherit;">Al igual que los r√≠os, las carreteras est√°n cerradas por dos quad medianos. </font><font style="vertical-align: inherit;">Cubrimos completamente estos cuadr√°ngulos de conexi√≥n con los cuadr√°ngulos de carretera para que se puedan utilizar las posiciones de los mismos seis picos. </font><font style="vertical-align: inherit;">Agregue para esto al </font></font><code>HexGridChunk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©todo </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como ya no tenemos que preocuparnos por el flujo de agua, no se requiere la coordenada V, por lo que le asignamos el valor 0 en todas partes. Podemos usar la coordenada U para indicar si estamos en el medio de la carretera o de lado. </font><font style="vertical-align: inherit;">Sea igual a 1 en el medio e igual a 0 en ambos lados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadSegment</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4, Vector3 v5, Vector3 v6 </span></span></span><span class="hljs-function">)</span></span> { roads.AddQuad(v1, v2, v4, v5); roads.AddQuad(v2, v3, v5, v6); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); roads.AddQuadUV(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26a/730/868/26a73086896099b06098de0a25eb63ae.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un segmento de la carretera entre celdas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√≠a l√≥gico llamar a este m√©todo </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero solo si realmente hay un camino. </font><font style="vertical-align: inherit;">Agregue un par√°metro booleano al m√©todo para pasar esta informaci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por supuesto, ahora recibiremos errores del compilador, porque hasta ahora esta informaci√≥n a√∫n no se ha transmitido. </font><font style="vertical-align: inherit;">Como √∫ltimo argumento en todos los casos, </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se puede agregar </font><font style="vertical-align: inherit;">la llamada </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sin embargo, tambi√©n podemos declarar que el valor predeterminado de este par√°metro es igual </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Debido a esto, el par√°metro ser√° opcional y los errores de compilaci√≥n desaparecer√°n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øC√≥mo funcionan los par√°metros opcionales?</font></font></b> <div class="spoiler_text">        ,   . ,  <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }</code> </pre> <br>    <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(x, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyMethod</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MyMethod(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; }</code> </pre> <br>   .      .    .      . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para triangular el camino, solo llame </font></font><code>TriangulateRoadSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con los seis picos del medio, si es necesario.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeStrip</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices e1, Color c1, EdgeVertices e2, Color c2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">)</span></span> { terrain.AddQuad(e1.v1, e1.v2, e2.v1, e2.v2); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v2, e1.v3, e2.v2, e2.v3); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v3, e1.v4, e2.v3, e2.v4); terrain.AddQuadColor(c1, c2); terrain.AddQuad(e1.v4, e1.v5, e2.v4, e2.v5); terrain.AddQuadColor(c1, c2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoad) { TriangulateRoadSegment(e1.v2, e1.v3, e1.v4, e2.v2, e2.v3, e2.v4); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ es como manejamos las conexiones de celda plana. </font><font style="vertical-align: inherit;">Para apoyar los caminos en las repisas, tambi√©n necesitamos decir </font></font><code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√≥nde se debe agregar el camino. </font><font style="vertical-align: inherit;">√âl simplemente puede transmitir esta informaci√≥n </font></font><code>TriangulateEdgeStrip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateEdgeTerraces</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoad </span></span></span><span class="hljs-function">)</span></span> { EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="hljs-number"><span class="hljs-number">1</span></span>); Color c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, <span class="hljs-number"><span class="hljs-number">1</span></span>); TriangulateEdgeStrip(begin, beginCell.Color, e2, c2, hasRoad); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; HexMetrics.terraceSteps; i++) { EdgeVertices e1 = e2; Color c1 = c2; e2 = EdgeVertices.TerraceLerp(begin, end, i); c2 = HexMetrics.TerraceLerp(beginCell.Color, endCell.Color, i); TriangulateEdgeStrip(e1, c1, e2, c2, hasRoad); } TriangulateEdgeStrip(e2, c2, end, endCell.Color, hasRoad); }</code> </pre> <br> <code>TriangulateEdgeTerraces</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">llamado por dentro </font></font><code>TriangulateConnection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es aqu√≠ donde podemos determinar si realmente hay un camino que va en la direcci√≥n actual, tanto durante la triangulaci√≥n de la costilla como en la triangulaci√≥n de las repisas.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.GetEdgeType(direction) == HexEdgeType.Slope) { TriangulateEdgeTerraces( e1, cell, e2, neighbor, cell.HasRoadThroughEdge(direction) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateEdgeStrip( e1, cell.Color, e2, neighbor.Color, cell.HasRoadThroughEdge(direction) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7a/67d/e7d/d7a67de7d2edeb2d23b63e9b37bc7508.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segmentos de carretera entre celdas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Celda sobre renderizado </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al dibujar carreteras, ver√° que aparecen segmentos de carretera entre celdas. El centro de estos segmentos ser√° de color p√∫rpura con una transici√≥n a azul en los bordes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sin embargo, cuando mueve la c√°mara, los segmentos pueden parpadear y, a veces, desaparecer por completo. Esto se debe a que los tri√°ngulos de las carreteras se superponen exactamente a los tri√°ngulos del terreno. Los tri√°ngulos para renderizar se seleccionan aleatoriamente. Este problema se puede solucionar en dos etapas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, queremos dibujar los caminos despu√©s de que se dibuja el relieve. Esto se puede lograr renderiz√°ndolos despu√©s de renderizar la geometr√≠a habitual, es decir, coloc√°ndolos en una cola de renderizado posterior.</font></font><br><br><pre> <code class="hljs objectivec"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En segundo lugar, debemos asegurarnos de que las carreteras se dibujan sobre tri√°ngulos de terreno en la misma posici√≥n. </font><font style="vertical-align: inherit;">Esto se puede hacer agregando el desplazamiento de prueba de profundidad. </font><font style="vertical-align: inherit;">Permitir√° que la GPU suponga que los tri√°ngulos est√°n m√°s cerca de la c√°mara de lo que realmente est√°n.</font></font><br><br><pre> <code class="hljs powershell"> Tags { <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Opaque"</span></span> <span class="hljs-string"><span class="hljs-string">"Queue"</span></span> = <span class="hljs-string"><span class="hljs-string">"Geometry+1"</span></span> } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> Offset <span class="hljs-literal"><span class="hljs-literal">-1</span></span>, <span class="hljs-literal"><span class="hljs-literal">-1</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caminos a trav√©s de celdas </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al triangular r√≠os, tuvimos que lidiar con no m√°s de dos direcciones de r√≠o por celda. Podr√≠amos identificar cinco opciones posibles y triangularlas de manera diferente para crear los r√≠os de aspecto correcto. Sin embargo, en el caso de las carreteras, hay catorce opciones posibles. No utilizaremos enfoques separados para cada una de estas opciones. En su lugar, procesaremos cada una de las seis direcciones de celda de la misma manera, independientemente de la configuraci√≥n espec√≠fica del camino. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando una carretera pasa a lo largo de una parte de la celda, la dibujaremos directamente al centro de la celda, sin abandonar la zona de tri√°ngulos. Dibujaremos un segmento de la carretera desde el borde hasta la mitad en la direcci√≥n del centro. Luego usamos dos tri√°ngulos para cerrar el resto al centro.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df0/659/a13/df0659a13206731d401579ba8c7f3b8f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulaci√≥n de una parte del camino. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para triangular este esquema, necesitamos conocer el centro de la celda, los v√©rtices medios izquierdo y derecho y los v√©rtices del borde. </font><font style="vertical-align: inherit;">Agregue un m√©todo </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con los par√°metros apropiados.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para construir un segmento de carretera, necesitamos un pico adicional. </font><font style="vertical-align: inherit;">Se encuentra entre los picos medios izquierdo y derecho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ahora tambi√©n podemos agregar los dos tri√°ngulos restantes. </font></font><br><br><pre> <code class="cs hljs"> TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n necesitamos agregar las coordenadas UV de los tri√°ngulos. </font><font style="vertical-align: inherit;">Dos de sus picos est√°n en el medio del camino, y el resto est√° en el borde.</font></font><br><br><pre> <code class="cs hljs"> roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) );</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por ahora, limit√©monos a celdas en las que no hay r√≠os. </font><font style="vertical-align: inherit;">En estos casos, </font></font><code>Triangulate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplemente crea un abanico de tri√°ngulos. </font><font style="vertical-align: inherit;">Mueva este c√≥digo a un m√©todo separado. </font><font style="vertical-align: inherit;">Luego agregamos una llamada </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando el camino realmente es. </font><font style="vertical-align: inherit;">Los v√©rtices medios izquierdo y derecho se pueden encontrar por interpolaci√≥n entre el centro y los dos v√©rtices de la esquina.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Triangulate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateWithoutRiver(direction, cell, center, e); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29d/ae4/def/29dae4def1f841ae190e64b267f6e4ea.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos que pasan por las celdas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Costillas de carretera </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos ver los caminos, pero m√°s cerca del centro de las celdas se estrechan. Como no verificamos con cu√°l de las catorce opciones que estamos tratando, no podemos cambiar el centro del camino para crear formas m√°s hermosas. En cambio, podemos agregar bordes de carretera adicionales en otras partes de la celda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando las carreteras pasan a trav√©s de la celda, pero no en la direcci√≥n actual, agregaremos un tri√°ngulo a los bordes de la carretera. Este tri√°ngulo est√° definido por los v√©rtices medios central, izquierdo y derecho. En este caso, solo el pico central se encuentra en el medio del camino. Los otros dos yacen sobre su costilla.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadEdge</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 center, Vector3 mL, Vector3 mR</span></span></span><span class="hljs-function">)</span></span> { roads.AddTriangle(center, mL, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/293/6ec/bd12936ec0833f7d7da4e038158bb167.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte del borde de la carretera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando necesitamos triangular un camino completo o solo un borde, debemos dejarlo para </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para hacer esto, este m√©todo debe saber si el camino pasa a trav√©s de la direcci√≥n del borde actual de la celda. </font><font style="vertical-align: inherit;">Por lo tanto, agregamos un par√°metro para esto.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoad</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector3 center, Vector3 mL, Vector3 mR, EdgeVertices e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hasRoadThroughCellEdge </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hasRoadThroughCellEdge) { Vector3 mC = Vector3.Lerp(mL, mR, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); TriangulateRoadSegment(mL, mC, mR, e.v2, e.v3, e.v4); roads.AddTriangle(center, mL, mC); roads.AddTriangle(center, mC, mR); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); roads.AddTriangleUV( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">1f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TriangulateRoadEdge(center, mL, mR); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora </font></font><code>TriangulateWithoutRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tendr√° que llamar </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cuando alguna carretera pase por la celda. </font><font style="vertical-align: inherit;">Y tendr√° que transmitir informaci√≥n sobre si el camino pasa por el borde actual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoad( center, Vector3.Lerp(center, e.v1, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), Vector3.Lerp(center, e.v5, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/89e/f99/1a0/89ef991a0790911d140b68b1457fb9df.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos con costillas terminadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Suavizado de carreteras </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los caminos ya est√°n completos. </font><font style="vertical-align: inherit;">Desafortunadamente, este enfoque crea protuberancias en el centro de las c√©lulas. </font><font style="vertical-align: inherit;">Colocar los picos izquierdo y derecho en el medio entre el centro y las esquinas nos conviene cuando hay un camino adyacente a ellos. </font><font style="vertical-align: inherit;">Pero si no es as√≠, entonces hay un bulto. </font><font style="vertical-align: inherit;">Para evitar esto, en tales casos podemos colocar los v√©rtices m√°s cerca del centro. </font><font style="vertical-align: inherit;">M√°s espec√≠ficamente, luego interpolar con ¬º, no con ¬Ω. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creemos un m√©todo separado para determinar qu√© interpoladores usar. </font><font style="vertical-align: inherit;">Como hay dos de ellos, podemos poner el resultado </font></font><code>Vector2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Su componente X ser√° el interpolador del punto izquierdo, y el componente Y ser√° el interpolador del punto derecho.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si hay un camino en la direcci√≥n actual, podemos colocar los puntos en el medio. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De lo contrario, las opciones pueden ser diferentes. </font><font style="vertical-align: inherit;">Para el punto izquierdo, podemos usar ¬Ω si hay un camino en la direcci√≥n anterior. </font><font style="vertical-align: inherit;">Si no es as√≠, entonces debemos usar ¬º. </font><font style="vertical-align: inherit;">Lo mismo se aplica al punto correcto, pero teniendo en cuenta la siguiente direcci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">Vector2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRoadInterpolators</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HexDirection direction, HexCell cell</span></span></span><span class="hljs-function">)</span></span> { Vector2 interpolators; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoadThroughEdge(direction)) { interpolators.x = interpolators.y = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { interpolators.x = cell.HasRoadThroughEdge(direction.Previous()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; interpolators.y = cell.HasRoadThroughEdge(direction.Next()) ? <span class="hljs-number"><span class="hljs-number">0.5f</span></span> : <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> interpolators; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora puede usar este nuevo m√©todo para determinar qu√© interpoladores se usan. </font><font style="vertical-align: inherit;">Gracias a esto, los caminos se allanar√°n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateWithoutRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { TriangulateEdgeFan(center, e, cell.Color); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { Vector2 interpolators = GetRoadInterpolators(direction, cell); TriangulateRoad( center, Vector3.Lerp(center, e.v1, interpolators.x), Vector3.Lerp(center, e.v5, interpolators.y), e, cell.HasRoadThroughEdge(direction) ); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c9/d0b/d12/3c9d0bd1262c2d47a3efc2d300212efd.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/84c/5fa/4f8/84c5fa4f8ef27bd4f6d294d0bf50acf6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos lisos. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La combinaci√≥n de r√≠os y caminos. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En la etapa actual, tenemos caminos funcionales, pero solo si no hay r√≠os. </font><font style="vertical-align: inherit;">Si hay un r√≠o en la celda, entonces las carreteras no ser√°n trianguladas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5e/76f/814/f5e76f814407359057d0c1bb1688988c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hay caminos cerca de los r√≠os. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creemos un m√©todo </font></font><code>TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para manejar esta situaci√≥n. </font><font style="vertical-align: inherit;">Lo configuramos con los par√°metros habituales. </font><font style="vertical-align: inherit;">Lo llamaremos al comienzo del m√©todo </font></font><code>TriangulateAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRoads) { TriangulateRoadAdjacentToRiver(direction, cell, center, e); } ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para empezar, haremos lo mismo que para las carreteras sin r√≠os. </font><font style="vertical-align: inherit;">Verificaremos si el camino pasa por el borde actual, obtendremos interpoladores, crearemos picos intermedios y llamaremos </font></font><code>TriangulateRoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero como los r√≠os aparecer√°n en el camino, necesitamos alejar los caminos de ellos. </font><font style="vertical-align: inherit;">Como resultado, el centro de la carretera estar√° en una posici√≥n diferente. </font><font style="vertical-align: inherit;">Usamos una variable para almacenar esta nueva posici√≥n </font></font><code>roadCenter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Inicialmente, ser√° igual al centro de la celda.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TriangulateRoadAdjacentToRiver</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entonces crearemos caminos parciales en celdas con r√≠os. </font><font style="vertical-align: inherit;">Las direcciones a trav√©s de las cuales pasan los r√≠os atravesar√°n las brechas en los caminos.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95e/029/595/95e0295954967415965a3992ffd91882.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos con espacios.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Principio o fin del r√≠o. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primero veamos las celdas que contienen el principio o el final de un r√≠o. </font><font style="vertical-align: inherit;">Para que los caminos no se superpongan con el agua, muevamos el centro del camino desde el r√≠o. </font><font style="vertical-align: inherit;">Para obtener la direcci√≥n del r√≠o entrante o saliente, agregue la </font></font><code>HexCell</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propiedad.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> HexDirection RiverBeginOrEndDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasIncomingRiver ? incomingRiver : outgoingRiver; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar esta propiedad </font></font><code>HexGridChunk.TriangulateRoadAdjacentToRiver</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para mover el centro de la carretera en la direcci√≥n opuesta. </font><font style="vertical-align: inherit;">Ser√° suficiente mover un tercio de la costilla central en esta direcci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/12b/280/f1812b2807add77e4d173b85ad65e4da.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carreteras modificadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luego necesitamos cerrar las brechas. </font><font style="vertical-align: inherit;">Haremos esto agregando tri√°ngulos adicionales a los bordes de la carretera cuando estemos cerca del r√≠o. </font><font style="vertical-align: inherit;">Si hay un r√≠o en la direcci√≥n anterior, entonces agregamos un tri√°ngulo entre el centro de la carretera, el centro de la celda y el punto medio izquierdo. </font><font style="vertical-align: inherit;">Y si el r√≠o est√° en la siguiente direcci√≥n, entonces agregamos un tri√°ngulo entre el centro de la carretera, el punto medio derecho y el centro de la celda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haremos esto independientemente de la configuraci√≥n del r√≠o, as√≠ que coloque este c√≥digo al final del m√©todo.</font></font><br><br><pre> <code class="cs hljs"> Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Previous())) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverThroughEdge(direction.Next())) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øNo puedes usar la declaraci√≥n else?</font></font></b> <div class="spoiler_text">      .   ,     . </div></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93d/485/bc8/93d485bc8072e6fa8471fb98d084467a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carreteras preparadas.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√≠os rectos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las celdas con r√≠os rectos son particularmente dif√≠ciles porque esencialmente dividen el centro de la celda en dos. </font><font style="vertical-align: inherit;">Ya agregamos tri√°ngulos adicionales para llenar los espacios entre los r√≠os, pero tambi√©n tenemos que desconectar las carreteras en lados opuestos del r√≠o.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab6/203/055/ab62030558305530ed4aed038669ba9c.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos que se superponen a un r√≠o recto. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la celda no tiene el principio o el final del r√≠o, entonces podemos verificar si los r√≠os entrantes y salientes van en direcciones opuestas. </font><font style="vertical-align: inherit;">Si es as√≠, entonces tenemos un r√≠o directo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para determinar d√≥nde est√° el r√≠o en relaci√≥n con la direcci√≥n actual, necesitamos verificar las direcciones vecinas. </font><font style="vertical-align: inherit;">El r√≠o est√° a la izquierda o a la derecha. </font><font style="vertical-align: inherit;">Como hacemos esto al final del m√©todo, almacenamos en cach√© estas solicitudes en variables booleanas. </font><font style="vertical-align: inherit;">Esto tambi√©n simplificar√° la lectura de nuestro c√≥digo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> hasRoadThroughEdge = cell.HasRoadThroughEdge(direction); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> previousHasRiver = cell.HasRiverThroughEdge(direction.Previous()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> nextHasRiver = cell.HasRiverThroughEdge(direction.Next()); Vector2 interpolators = GetRoadInterpolators(direction, cell); Vector3 roadCenter = center; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { roadCenter += HexMetrics.GetSolidEdgeMiddle( cell.RiverBeginOrEndDirection.Opposite() ) * (<span class="hljs-number"><span class="hljs-number">1f</span></span> / <span class="hljs-number"><span class="hljs-number">3f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { } } Vector3 mL = Vector3.Lerp(roadCenter, e.v1, interpolators.x); Vector3 mR = Vector3.Lerp(roadCenter, e.v5, interpolators.y); TriangulateRoad(roadCenter, mL, mR, e, hasRoadThroughEdge); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { TriangulateRoadEdge(roadCenter, center, mL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { TriangulateRoadEdge(roadCenter, mR, center); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos cambiar el centro del camino a un vector angular que apunte en la direcci√≥n opuesta al r√≠o. </font><font style="vertical-align: inherit;">Si el r√≠o pasa por la direcci√≥n anterior, este es el segundo √°ngulo s√≥lido. </font><font style="vertical-align: inherit;">De lo contrario, este es el primer √°ngulo s√≥lido.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para mover el camino de manera que est√© adyacente al r√≠o, necesitamos mover el centro del camino la mitad de la distancia a esta esquina. </font><font style="vertical-align: inherit;">Luego tambi√©n tenemos que mover el centro de la celda un cuarto de la distancia en esa direcci√≥n.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { Vector3 corner; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { corner = HexMetrics.GetFirstSolidCorner(direction); } roadCenter += corner * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; center += corner * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/6bf/85b/e4c6bf85b3120697996ad75a3256a3a0.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos divididos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compartimos una red de carreteras dentro de esta celda. </font><font style="vertical-align: inherit;">Esto es normal cuando las carreteras est√°n a ambos lados del r√≠o. </font><font style="vertical-align: inherit;">Pero si en un lado no hay camino, tendremos un peque√±o pedazo de camino aislado. </font><font style="vertical-align: inherit;">Esto es il√≥gico, as√≠ que eliminemos esas partes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseg√∫rese de que haya una carretera en la direcci√≥n actual. </font><font style="vertical-align: inherit;">Si no es as√≠, verifique la otra direcci√≥n del mismo lado del r√≠o para ver la presencia de la carretera. </font><font style="vertical-align: inherit;">Si no hay una carretera de paso, ya sea all√≠ o all√≠, salimos del m√©todo antes de triangular.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetSecondSolidCorner(direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !hasRoadThroughEdge &amp;&amp; !cell.HasRoadThroughEdge(direction.Previous()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } corner = HexMetrics.GetFirstSolidCorner(direction); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09e/398/532/09e398532543dcd7f78987c23e012571.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carreteras truncadas.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øQu√© pasa con los puentes?</font></font></b> <div class="spoiler_text">     .         . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√≠os en zigzag </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El siguiente tipo de r√≠o son los zigzags. </font><font style="vertical-align: inherit;">Dichos r√≠os no comparten la red de carreteras, por lo que solo necesitamos mover el centro de la carretera.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/851/29b/f56/85129bf56e4948296b17916094fd9d8b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zigzags pasando por las carreteras. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La forma m√°s f√°cil de verificar si hay zigzags es comparando las direcciones de los r√≠os entrantes y salientes. </font><font style="vertical-align: inherit;">Si son adyacentes, entonces tenemos un zigzag. </font><font style="vertical-align: inherit;">Esto lleva a dos opciones posibles, dependiendo de la direcci√≥n del flujo.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.HasRiverBeginOrEnd) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Opposite()) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos mover el centro del camino usando una de las esquinas de la direcci√≥n del r√≠o entrante. </font><font style="vertical-align: inherit;">El √°ngulo que seleccione depende de la direcci√≥n del flujo. </font><font style="vertical-align: inherit;">Mueva el centro de la carretera desde este √°ngulo con un factor de 0.2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Previous()) { roadCenter -= HexMetrics.GetSecondCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { roadCenter -= HexMetrics.GetFirstCorner(cell.IncomingRiver) * <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fa/3c6/f27/1fa3c6f277079e277491027207f9398f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El camino se alej√≥ de los zigzags.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dentro de los r√≠os torcidos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La √∫ltima configuraci√≥n del r√≠o es una curva suave. </font><font style="vertical-align: inherit;">Al igual que con el r√≠o directo, este tambi√©n puede separar caminos. </font><font style="vertical-align: inherit;">Pero en este caso, las partes ser√°n diferentes. </font><font style="vertical-align: inherit;">Primero necesitamos trabajar con el interior de la curva.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/566/b8f/3db/566b8f3dbffec4cdc91556abe0f2bf5e.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un r√≠o curvo con caminos pavimentados. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando tenemos un r√≠o a ambos lados de la direcci√≥n actual, entonces estamos dentro de la curva.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cell.IncomingRiver == cell.OutgoingRiver.Next()) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Necesitamos mover el centro del camino hacia el borde actual de la celda, acortando un poco el camino. </font><font style="vertical-align: inherit;">Un coeficiente de 0.7 servir√°. </font><font style="vertical-align: inherit;">El centro de la celda tambi√©n debe cambiar con un coeficiente de 0.5.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2d/64f/a82/a2d64fa828544540d43856bf94e34f9d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carreteras acortadas. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como en el caso de los r√≠os rectos, tendremos que cortar las partes aisladas de las carreteras. </font><font style="vertical-align: inherit;">En este caso, es suficiente verificar solo la direcci√≥n actual.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!hasRoadThroughEdge) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } Vector3 offset = HexMetrics.GetSolidEdgeMiddle(direction) * HexMetrics.innerToOuter; roadCenter += offset * <span class="hljs-number"><span class="hljs-number">0.7f</span></span>; center += offset * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/30b/6a0/d9d/30b6a0d9db5fe0960265713c62ef2ae5.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cortar carreteras.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fuera de los r√≠os torcidos </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de verificar todos los casos anteriores, la √∫nica opci√≥n restante era la parte exterior del r√≠o curvo. </font><font style="vertical-align: inherit;">Afuera hay tres partes de la celda. </font><font style="vertical-align: inherit;">Necesitamos encontrar la direcci√≥n del medio. </font><font style="vertical-align: inherit;">Una vez recibido, podemos mover el centro del camino hacia esta costilla por un factor de 0.25.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver &amp;&amp; nextHasRiver) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/84c/a29/8b884ca29118c36e522674cd00ab8613.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambi√≥ el exterior de la carretera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como √∫ltimo paso, necesitamos truncar los caminos en este lado del r√≠o. </font><font style="vertical-align: inherit;">La forma m√°s f√°cil es verificar las tres direcciones de la carretera en relaci√≥n con el medio. </font><font style="vertical-align: inherit;">Si no hay carreteras, dejamos de trabajar.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HexDirection middle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (previousHasRiver) { middle = direction.Next(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextHasRiver) { middle = direction.Previous(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { middle = direction; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cell.HasRoadThroughEdge(middle) &amp;&amp; !cell.HasRoadThroughEdge(middle.Previous()) &amp;&amp; !cell.HasRoadThroughEdge(middle.Next()) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } roadCenter += HexMetrics.GetSolidEdgeMiddle(middle) * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56d/69a/d1b/56d69ad1b8d6ffdf74e9adb1c4800695.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/8c3/178/a9a8c3178c8a44738b4bbd01ef5f221d.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos antes y despu√©s del recorte. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despu√©s de procesar todas las opciones de r√≠o, nuestros r√≠os y carreteras pueden coexistir. </font><font style="vertical-align: inherit;">Los r√≠os ignoran los caminos, y los caminos se adaptan a los r√≠os.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b32/6e4/28b/b326e428b45df027cac2f99a336e71e9.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La combinaci√≥n de r√≠os y caminos. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La apariencia de los caminos. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasta ese momento, utilizamos sus coordenadas UV como colores de carretera. </font><font style="vertical-align: inherit;">Como solo cambi√≥ la coordenada U, en realidad mostramos la transici√≥n entre el centro y el borde de la carretera.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/084/cb2/8ac/084cb28ac448ddb258846c09d8b3b83a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualizaci√≥n de coordenadas UV. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora que las carreteras est√°n exactamente trianguladas correctamente, podemos cambiar el sombreador de carreteras para que represente algo m√°s parecido a las carreteras. </font><font style="vertical-align: inherit;">Como en el caso de los r√≠os, esta ser√° una visualizaci√≥n simple, sin lujos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comenzaremos utilizando colores s√≥lidos para carreteras. </font><font style="vertical-align: inherit;">Solo usa el color del material. </font><font style="vertical-align: inherit;">Lo hice rojo.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = ca; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/304/2e4/ab4/3042e4ab4b01b3389822072244208cb6.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos rojos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬°Y ya se ve mucho mejor! </font><font style="vertical-align: inherit;">Pero continuemos y mezclemos el camino con el terreno, usando la coordenada U como factor de mezcla.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">void</span></span> surf (<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputStandard o) { fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; o.Albedo = c.rgb; o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = blend; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parece que esto no ha cambiado nada. </font><font style="vertical-align: inherit;">Sucedi√≥ porque nuestro sombreador es opaco. </font><font style="vertical-align: inherit;">Ahora necesita una mezcla alfa. </font><font style="vertical-align: inherit;">En particular, necesitamos un sombreador para una superficie de calcoman√≠a de acoplamiento. </font><font style="vertical-align: inherit;">Podemos obtener el sombreador requerido agregando una </font></font><code>#pragma surface</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√≠nea </font><font style="vertical-align: inherit;">a la directiva </font></font><code>decal:blend</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs cs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows decal:blend</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a0/66c/501/7a066c5015ea14533f1b9ed881469323.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mezcla de caminos. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As√≠ que creamos una mezcla lineal suave de medio a borde que no se ve muy bonita. </font><font style="vertical-align: inherit;">Para que parezca una carretera, necesitamos un √°rea s√≥lida, seguida de una transici√≥n r√°pida a un √°rea opaca. </font><font style="vertical-align: inherit;">Puede usar la funci√≥n para esto </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Convierte una progresi√≥n lineal de 0 a 1 en una curva en forma de S.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b0/030/f57/2b0030f57819183470fc7fae72ea18bd.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Progresi√≥n lineal y paso suave. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La funci√≥n </font></font><code>smoothstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiene un par√°metro m√≠nimo y m√°ximo para ajustar la curva en un intervalo arbitrario. </font><font style="vertical-align: inherit;">Los valores de entrada fuera del rango est√°n limitados para mantener la curva plana. </font><font style="vertical-align: inherit;">Usemos 0.4 al comienzo de la curva y 0.7 al final. </font><font style="vertical-align: inherit;">Esto significa que la coordenada U de 0 a 0.4 ser√° completamente transparente. </font><font style="vertical-align: inherit;">Y las coordenadas U de 0.7 a 1 ser√°n completamente opacas. </font><font style="vertical-align: inherit;">La transici√≥n ocurre entre 0.4 y 0.7.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x; blend = smoothstep(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/543/fe1/4b4/543fe14b4d760b820ec106626230876f.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transici√≥n r√°pida entre √°reas opacas y transparentes.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Camino con ruido </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que la malla de la carretera estar√° distorsionada, las carreteras tienen diferentes anchuras. </font><font style="vertical-align: inherit;">Por lo tanto, el ancho de la transici√≥n en los bordes tambi√©n ser√° variable. </font><font style="vertical-align: inherit;">A veces es borroso, a veces duro. </font><font style="vertical-align: inherit;">Tal variabilidad nos conviene si percibimos los caminos como arenosos o terrosos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasemos al siguiente paso y agreguemos ruido a los bordes de la carretera. </font><font style="vertical-align: inherit;">Esto los har√° m√°s desiguales y menos poligonales. </font><font style="vertical-align: inherit;">Podemos hacer esto muestreando la textura de ruido. </font><font style="vertical-align: inherit;">Para el muestreo, puede usar las coordenadas del mundo XZ, tal como lo hicimos al distorsionar los v√©rtices de las celdas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para obtener acceso a la posici√≥n del mundo en el sombreador de superficie, agregue a la estructura de entrada </font></font><code>float3 worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="hljs swift"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span></span>{ float2 uv_MainTex; float3 worldPos; };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ahora podemos usar esta posici√≥n </font></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para muestrear la textura principal. </font><font style="vertical-align: inherit;">Alejar tambi√©n, de lo contrario la textura se repetir√° con demasiada frecuencia.</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">float4</span></span> noise = tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.worldPos.xz * <span class="hljs-number"><span class="hljs-number">0.025</span></span>); fixed4 c = _Color; <span class="hljs-type"><span class="hljs-type">float</span></span> blend = <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex.x;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distorsionamos la transici√≥n multiplicando la coordenada U por </font></font><code>noise.x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pero dado que los valores de ruido son en promedio 0.5, la mayor√≠a de las carreteras desaparecer√°n. </font><font style="vertical-align: inherit;">Para evitar esto, agregue 0.5 al ruido antes de la multiplicaci√≥n.</font></font><br><br><pre> <code class="hljs mel"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blend = IN.uv_MainTex.x; blend *= <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>.x + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; blend = <span class="hljs-keyword"><span class="hljs-keyword">smoothstep</span></span>(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, blend);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c08/b7d/e28/c08b7de2879b84c816286530871b6a6f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/bdf/28f/4bebdf28fc519b3f186f119b6e501261.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bordes distorsionados de la carretera. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para finalizar esto, tambi√©n distorsionaremos el color de las carreteras. </font><font style="vertical-align: inherit;">Esto le dar√° a las carreteras una sensaci√≥n de suciedad correspondiente a bordes borrosos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multiplique el color por otro canal de ruido, digamos por </font></font><code>noise.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Entonces obtenemos un promedio de la mitad del valor de color. </font><font style="vertical-align: inherit;">Como esto es demasiado, reduciremos ligeramente la escala de ruido y agregaremos una constante para que la suma pueda alcanzar 1.</font></font><br><br><pre> <code class="hljs swift"> fixed4 <span class="hljs-built_in"><span class="hljs-built_in">c</span></span> = _Color * (noise.y * <span class="hljs-number"><span class="hljs-number">0.75</span></span> + <span class="hljs-number"><span class="hljs-number">0.25</span></span>);</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d2/a25/d49/6d2a25d4929cf56f7c4059352b4ed70a.png"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caminos √°speros. </font></font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paquete de la unidad</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424491/">https://habr.com/ru/post/es424491/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424475/index.html">Informe del Centro de Monitoreo de Seguridad de la Informaci√≥n para la mitad I de 2018</a></li>
<li><a href="../es424477/index.html">La disponibilidad de juegos en pygame</a></li>
<li><a href="../es424481/index.html">Toda la verdad sobre RTOS. Art√≠culo # 11. Tareas: configuraci√≥n e introducci√≥n a la API</a></li>
<li><a href="../es424483/index.html">Acuerdo de $ 38 mil millones y sus implicaciones: c√≥mo Comcast y Disney luchan contra Amazon y Netflix con inversi√≥n</a></li>
<li><a href="../es424485/index.html">Bypass de fijaci√≥n SSL en la aplicaci√≥n iOS</a></li>
<li><a href="../es424495/index.html">Google Chrome agregar√° la capacidad de rechazar la sincronizaci√≥n autom√°tica de perfiles al iniciar sesi√≥n en los servicios de la compa√±√≠a *</a></li>
<li><a href="../es424497/index.html">Deja de sospechar de los desarrolladores de la impostura. Aprenda a entrevistar mejor</a></li>
<li><a href="../es424499/index.html">Bueno √©l, tu pentest</a></li>
<li><a href="../es424501/index.html">Terminales de diagn√≥stico para soldadores reales</a></li>
<li><a href="../es424503/index.html">Arranca t√∫ mismo, llega la primavera (Parte 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>