<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚽 🌭 🍶 Seguridad de la aplicación del cliente: consejos prácticos para un desarrollador front-end ♈️ 👉🏻 🎰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como saben, la mayoría de los ataques de los piratas informáticos de BlackHat están destinados a comprometer los datos del servidor de las aplicacione...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguridad de la aplicación del cliente: consejos prácticos para un desarrollador front-end</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445932/"><p>  Como saben, la mayoría de los ataques de los piratas informáticos de BlackHat están destinados a comprometer los datos del servidor de las aplicaciones y servicios web.  Al mismo tiempo, la parte del cliente es atacada al menos hoy.  Según la definición en seco, cualquier ataque es un conjunto de medidas por parte de un hacker dirigido a la red y la transferencia de datos, los datos y su sustitución, infraestructura y características técnicas de la implementación de la aplicación web.  Por lo tanto, las compañías internacionales requieren que los ingenieros de desarrollo adopten un enfoque más responsable y exhaustivo para la seguridad de las aplicaciones del cliente. </p><br><p> En el ejemplo de mi proyecto, hablaré sobre cómo las aplicaciones cliente atacan hoy y cómo puede evitar estas amenazas. </p><a name="habracut"></a><br><img alt="Las 10 principales amenazas de 2013 a 2017" src="https://habrastorage.org/webt/ys/zg/d7/yszgd7tqw75npl5bx9pliitikte.jpeg"><br>  <i>Las 10 principales amenazas para 2013-2017.</i> <br><br><p>  Como puede ver, entre las principales amenazas, la inyección, la activación de errores, la omisión de autenticación y los datos confidenciales inseguros ocupan el primer lugar.  La amenaza de usar componentes con vulnerabilidades conocidas sigue siendo relevante.  También aparecieron nuevas amenazas: piratería del mecanismo de control de acceso, deserialización y serialización inseguras de datos, registro y monitoreo insuficientemente detallados. </p><br><p>  En 2001, Mark Curfy y Dennis Groves fundaron el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OWASP</a> (Open Web Application Security Project).  Este es un proyecto internacional de código abierto para el intercambio de experiencias sobre el combate de vulnerabilidades en aplicaciones cliente, en el que participan una gran cantidad de ingenieros de seguridad de aplicaciones.  La comunidad OWASP llena el portal con una multitud de artículos con información de vulnerabilidad, materiales de capacitación, herramientas para probar y repeler ataques.  Se describen ataques reales, se revelan sus aspectos y se describe lo que hay que hacer para prevenir amenazas. </p><br><p>  Para comprender qué amenazas son peligrosas para un proyecto, debe probarlo a fondo.  Para hacer esto, la red tiene aplicaciones, marcos y servicios en línea que identifican automáticamente ciertas vulnerabilidades.  Para las pruebas locales, recomiendo usar aplicaciones y marcos, y para probar proyectos en funcionamiento, también es muy útil agregar servicios en línea. </p><br><img src="https://habrastorage.org/webt/zh/c7/ll/zhc7lln_b43msp-lkz7ah0iapmw.jpeg"><br><br><p>  Pero incluso si las herramientas de prueba no le informaron en informes sobre vulnerabilidades significativas (lo cual es poco probable), aún preste atención al almacenamiento de datos confidenciales en el sistema de control de versiones, la creación de la aplicación, el mecanismo de autenticación, el algoritmo de hash de contraseña, el cifrado de datos confidenciales y los sistemas de registro y monitoreando toda la aplicación web.  En este caso, es mejor ir a lo seguro y no confiar en la automatización ciega. </p><br><h2>  Git </h2><br><p>  Primero, hablemos de datos confidenciales en Git.  Idealmente, se asigna un depósito separado de secretos para almacenar datos confidenciales.  A partir de él, durante el ensamblaje para la puesta en marcha, los datos confidenciales se extraen y se cosen a la aplicación.  Hoy, Hashicorp Vault, Keywhiz, Docker secrets, Azure Key Vault y muchos otros son populares. </p><br><p>  Pero, ¿qué pasa si no tienes ese almacenamiento?  Puede usar herramientas para codificar y ocultar archivos con secretos que ampliarán las capacidades de los sistemas de control de versiones. </p><br><p> Lo primero que viene a la mente es la solución universal BlackBox.  Se puede usar con cualquier sistema de control de versiones, por ejemplo, Mercurial, Git, etc.  Además, hay dos extensiones para Git: git-crypt y git-secret.  Recomiendo usar el segundo, porque me pareció el más conveniente de usar y más comprensible en términos de descripción en la documentación oficial.  Después de instalar git-secret, debe inicializarlo en el repositorio de Git.  Recuerde especificar la extensión a usar en el archivo <b>.gitattributes</b> .  A continuación, configure la accesibilidad de los secretos: identifique los usuarios a los que desea proporcionar acceso a datos confidenciales.  Luego agregue archivos con datos confidenciales y <code>git-secret-hide</code> a través de <code>git-secret-hide</code> .  Puede obtener archivos ocultos a través de <code>git-secret-reveal.</code> </p><br> <code>brew install git-secret              //  <br> git secret init                      //  <br> git secret tell your@gpg.email       &amp;nbsp//   <br> git secret add &lt;files...&gt;             //   <br> git secret hide                      &amp;nbsp//   <br> git secret reveal                    &amp;nbsp//    <br></code> <br><h2>  Paquete web </h2><br><p>  Otra forma de eliminar amenazas es configurar el paquete web correctamente.  Para protegerse contra XSS, XEE y ataques similares, debe considerar adherirse a las políticas CORS (Intercambio de recursos de origen cruzado) y CSP (Política de seguridad de contenido).  En ambos casos, es importante seguir los encabezados para verificar la autenticidad de ciertos scripts que se utilizan en el proyecto.  Los navegadores tienen mecanismos para verificar la confiabilidad de una fuente en particular, por ejemplo, Safari emitirá advertencias en cada paso si CORS y CSP están configurados incorrectamente. </p><br><p>  Hay dos formas de cumplir con CORS y CSP.  El primero es configurar los encabezados para responder a las solicitudes en el lado del servidor.  El segundo es registrar ambas políticas a través de metaetiquetas y atributos.  Se recomienda este último método si tiene desarrolladores de back-end perezosos, siempre están ocupados y no están interesados ​​en las políticas de seguridad.  Las metaetiquetas se pueden registrar de inmediato al crear la aplicación.  Los complementos como html-webpack-plugin, html-webpack-exclude-assets-plugin, script-ext-html-webpack-plugin, csp-html-webpack-plugin y crypto nos ayudarán con esto.  Además, si tiene recursos de terceros en su proyecto (por ejemplo, enlaces a fuentes externas utilizadas en CSS; recursos cargados desde CDN, etc.), entonces también recomiendo usar el complemento webpack-subresource-INTEGMENT-INTEGRITY.  Por lo tanto, informará al navegador que los recursos cargados en el script son confiables, no hay inyecciones en ellos, son completos y están intactos.  E incluso si alguien inyectó datos maliciosos en el recurso, y usted lo cargó, debe estar preparado para esto y proteger su proyecto de tales amenazas. </p><br><p>  Quiero prestar <b>especial atención</b> al orden en que se crean las instancias de clase para los complementos.  El orden debería ser así: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SHA256 = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) =&gt;</span></span> CRYPTO.createHash(<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>).update( str, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>).digest(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sha256Str = SHA256( <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() ); […] <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackPlugin({   <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">'index.html'</span></span>,   <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-string"><span class="hljs-string">'public/index.html'</span></span> }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ScriptExtHtmlWebpackPlugin({    <span class="hljs-attr"><span class="hljs-attr">custom</span></span>: [{           <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.js$/</span></span>,           <span class="hljs-attr"><span class="hljs-attr">attribute</span></span>: <span class="hljs-string"><span class="hljs-string">'nonce'</span></span>,           <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'nonce-'</span></span> + sha256Str    }] }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HtmlWebpackExcludeAssetsPlugin(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CspHtmlWebpackPlugin({    <span class="hljs-string"><span class="hljs-string">'base-uri'</span></span>: <span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>,    <span class="hljs-string"><span class="hljs-string">'object-src'</span></span>: <span class="hljs-string"><span class="hljs-string">'\'none\''</span></span>,    <span class="hljs-string"><span class="hljs-string">'script-src'</span></span>: [<span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'unsafe-eval\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'nonce-'</span></span> + sha256Str + <span class="hljs-string"><span class="hljs-string">'\''</span></span>],    <span class="hljs-string"><span class="hljs-string">'style-src'</span></span>: [<span class="hljs-string"><span class="hljs-string">'\'unsafe-inline\''</span></span>, <span class="hljs-string"><span class="hljs-string">'\'self\''</span></span>] }, {    <span class="hljs-attr"><span class="hljs-attr">devAllowUnsafe</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>,    <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>,    <span class="hljs-attr"><span class="hljs-attr">hashingMethod</span></span>: <span class="hljs-string"><span class="hljs-string">'sha256'</span></span> }), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SriPlugin({    <span class="hljs-attr"><span class="hljs-attr">hashFuncNames</span></span>: [<span class="hljs-string"><span class="hljs-string">'sha256'</span></span>, <span class="hljs-string"><span class="hljs-string">'sha384'</span></span>],    <span class="hljs-attr"><span class="hljs-attr">enabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }), […]</code> </pre><br><p>  Luego, durante el ensamblaje, la <code>&lt;hed&gt;</code> mostrará la <code>&lt;hed&gt;</code> <code>http-equiv=content-security-policy</code> .  Las directivas se escribirán en el atributo de <code>content</code> , que dice en qué scripts y recursos se puede confiar. </p><br><p>  La directiva <code>base-uri</code> muestra qué URL base se usa para cargar scripts, CSS, imágenes y más. </p><br><p>  Los objetos generalmente no se cargan, por lo tanto, <code>none</code> configure <code>none</code> en la directiva <code>object-sr</code> c. </p><br><p>  La directiva <code>script-src</code> aplica a los scripts JS. </p><br><p>  No olvide registrar un atributo de tipo <code>nnce-&lt;hshVlue&gt;</code> cada vez.  Además, el hash debe calcularse utilizando el algoritmo SHA256 o SHA512. </p><br><p>  En cuanto a la directiva <code>style-src</code> , nuestro proyecto tiene una peculiaridad: utilizamos componentes con estilo para escribir CSS para cada componente y aislarlos unos de otros.  Y, por lo tanto, es necesario especificar que en us <code>style-src</code> <code>unsafe-inline</code> y <code>self</code> se usan en <code>style-src</code> , de lo contrario los componentes con estilo se caerán. </p><br><br><img src="https://habrastorage.org/webt/9x/di/ny/9xdinyh5msrmdszkkdayka1tqya.jpeg"><br><br><p>  La etiqueta del <code>script</code> se establecerá automáticamente en <code>nnce-&lt;hshVlue&gt;</code> , <code>integrity</code> y <code>cross-origin</code> .  Le dicen al navegador que los recursos se obtienen de fuentes confiables.  De lo contrario, si el navegador ve que el recurso no coincide con CSP o CORS, simplemente no cargará este script o archivo CSS, y escribirá algo en la consola como: <i>"Presta atención a este script, a esta línea donde inicializas el.</i>  <i>¡Mira, tienes algo mal!</i>  . </p><br><p>  La documentación de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">MDN</a> , OWASP y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">W3C</a> proporciona pautas para hacer cumplir las políticas de CSP y CORS.  Además, cualquier herramienta de prueba de penetración informará el cumplimiento de las normas CORS y CSP en el proyecto.  Cualquier marco o herramienta que realice pruebas automáticas de un proyecto señalará fallas. </p><br><h2>  Autenticación de usuario </h2><br><p>  Utilizamos OpenID Connect y el protocolo Kerberos.  Se utiliza un estándar OpenID bastante común para autenticar usuarios externos. </p><br><p>  Kerberos es más adecuado para la red interna, en el banco se usa para la autenticación automática de los empleados.  Supongamos que hay una máquina local en la que trabaja un empleado de la organización.  Se autenticó una vez en esta máquina y ya no necesitará ingresar nuevamente el nombre de usuario y la contraseña: el empleado inicia sesión en cualquier aplicación y el sistema la autentica de inmediato.  Kerberos tiene configuraciones sutiles para la máquina local, y esto es difícil porque tiene que configurarse para <b>cada computadora y cada navegador.</b>  Si Internet Explorer normalmente muestra la configuración predeterminada y Chrome muestra la configuración de IE, entonces Firefox tiene que configurarla por separado.  Safari en MacOS X encontrará la configuración en sí, pero para Safari en Windows deberá especificarlos manualmente. </p><br><p>  Debe verificar su aplicación en todos los navegadores, ya sea que funcione en todas partes como debería.  Por ejemplo, si trabajo en Windows, instalo Safari localmente y pruebo mi proyecto en él, y si trabajo en Mac, levanto Windows en una máquina virtual para ejecutar la aplicación en las versiones correspondientes de los navegadores. </p><br><p>  La autenticación se puede implementar en aplicaciones modernas utilizando Passport.js y paquetes de sesión rápida, así como el SDK Auth0. </p><br><p>  Si no puede desarrollar un servicio de autenticación a través de OpenID Connect o cualquier otro protocolo, utilice una capa proxy, como Auth0 y similares, para que la autenticación se realice a través de una empresa externa que se especialice en proporcionar a los usuarios acceso seguro a los recursos de Internet. </p><br><p>  Cuando actualizamos alguna aplicación a Node.js, recomendamos utilizar los paquetes Passport.js, express-session, etc. en el servidor.  Para garantizar la seguridad del cliente, elevamos de forma independiente el componente para la autenticación.  No olvide especificar el atributo de autocompletar en el formulario de autenticación para excluir la finalización automática de los campos del formulario. </p><br><h2>  Hashing de contraseña </h2><br><p>  El sitio web de OWASP recomienda que no utilice mecanismos de hash de contraseña integrados en la base de datos.  Para esto, es mejor usar paquetes como Argon2, PBKDF2, ccrypt y bcrypt.  En mi práctica, uso Argon2: este es un contenedor para algoritmos GCC, PGP / GPG, etc., pero requiere que primero instale el paquete GCC.  Esquema de uso de Argon2: </p><br><br><pre> <code class="bash hljs">1.  GCC &gt;= 4.8 install $ brew install gcc</code> </pre> <br><pre> <code class="bash hljs">2.     - $ npm install -g node-gyp</code> </pre> <br><pre> <code class="bash hljs">3.   Argon2 $ npm install argon2</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ARGON <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'argon2'</span></span>; ARGON.generateSalt().then( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">salt: string</span></span></span><span class="hljs-function">) =&gt;</span></span> {  ARGON.hash(<span class="hljs-string"><span class="hljs-string">'some-user-password'</span></span>, salt)    .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">hash : string</span></span></span><span class="hljs-function">) =&gt;</span></span> {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Successfully created Argon2 hash:'</span></span>, hash);       <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> store the hash in the user database  }); }); argon2.verify( 'previously-created-argon-hash-here', 'some-user-password').then(() =&gt; {  console.log('Successful password supplied!');  // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> log the user in }).catch(() =&gt; {  console.log('Invalid password supplied!'); });</span></span></code> </pre> <br><h2>  Ofuscación </h2><br><p>  La ofuscación le permite modificar el código para que no se pueda analizar en componentes.  Después de todo, los atacantes, y no solo ellos, a menudo usan ingeniería inversa: el programador toma un archivo JS y comienza a analizar las fuentes.  Por lo tanto, puede aprender los métodos utilizados o comprender el mecanismo de trabajo de un script en particular para implementar código malicioso.  O utilice estos mecanismos para hackear una aplicación web y realizar un ataque sigiloso. </p><br><p>  Los hackers no se meten en problemas.  Primero, realizan una exploración del recurso, determinan las vulnerabilidades y atacan el vector.  Por ejemplo, manipulan datos o explotan vulnerabilidades contenidas en protocolos de transporte.  El vector de ataque puede estar dirigido a las vulnerabilidades de un sistema operativo en particular; hay muchas de ellas en cualquier sistema UNIX.  Pero las vulnerabilidades solo se pueden usar si el administrador tiene políticas de seguridad mal configuradas, por ejemplo, establece incorrectamente las URL que salen. </p><br><p>  Entonces, para el reconocimiento, se usa ingeniería inversa.  Es imposible excluirlo por completo, pero puede ser muy difícil.  Para esto, se utilizan varios ofuscadores, en mi caso, javascript-ofuscador.  En base a ello, se crea un complemento para webpack: webpack-ofuscador.  También para webpack creado ofuscator-loader.  Este paquete tiene configuraciones recomendadas para diferentes niveles de paranoico: bajo, medio y alto, se pueden encontrar en el sitio web oficial.  Si usa este ofuscador, recuerde que funciona muy mal con el mecanismo de minificación integrado en el paquete web.  No use la minificación y la ofuscación juntas, de lo contrario, el ofuscador puede romper completamente el código del script. </p><br><p>  Además, el ofuscador aumenta el volumen del script y su carga.  Aquí debe decidir por sí mismo: o mejora la seguridad, la estabilidad y la confiabilidad, pero pierde en comodidad y velocidad;  o se preocupan por la velocidad, pero olvídate de la seguridad, de seguir cualquier guía </p><br><h2>  Registro de amenazas y monitoreo </h2><br><p>  Existe una amenaza tal como el uso de paquetes con vulnerabilidades ya conocidas.  Los analizadores de amenazas como npm audit, Snyk y LGTM ayudarán en tales situaciones.  Npm audit es una utilidad estándar que está integrada en npm, pero debe llamar constantemente a este comando o crear muletas.  Por lo tanto, le aconsejo que use Snyk.  Este proyecto tiene su propia base de datos con vulnerabilidades.  Cuando comienza la prueba, Snyk accede a esta base de datos y carga confidencialmente el informe a su proyecto Snyk, al que no pueden acceder personas externas.  Es cierto, puede verificar su proyecto de forma gratuita solo 300 veces, y cuando verifica cada confirmación previa, estos 300 intentos gratuitos terminan muy rápidamente.  Por lo tanto, es mejor ejecutar una prueba para los ganchos de pre-inserción o pre-fusión. </p><br><p>  El hombre es la vulnerabilidad más importante de cualquier sistema.  Por lo tanto, asegúrese de verificar el proyecto antes de comenzar a compilar la aplicación, ya que incluso el código fuente puede contener algo malicioso.  Es bueno cuando solo una persona tiene acceso al proyecto, pero generalmente trabajamos en equipo.  ¿Qué pasaría si apareciera algún tipo de "simpatizante" que decidiera dejar la empresa "maravillosamente" y dejar una marca?  Esto también debe tenerse en cuenta. </p><br><p>  Recomiendo usar el paquete Snyk desde el comienzo del proyecto e iniciar el escaneo desde la consola.  Aquí todo es simple: después de la instalación, configure el inicio de sesión y la contraseña para la cuenta, y la prueba en sí se puede realizar de esta manera: </p><br><ul><li>  Después de instalar la dependencia npm i snyk —D y especificar "snyk": verdadero en package.json, ejecute: </li></ul><br><pre> <code class="bash hljs">./node_modules/.bin/snyk wizard --dev</code> </pre> <br><ul><li>  En package.json agregue scripts y configuraciones: </li></ul><br><pre> <code class="javascript hljs">{ ... <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {  ...  <span class="hljs-string"><span class="hljs-string">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run test:snyk &amp;&amp; npm run test:jest"</span></span>,  ...  <span class="hljs-string"><span class="hljs-string">"test:snyk"</span></span>: <span class="hljs-string"><span class="hljs-string">"snyk test --dev"</span></span>,  ...  <span class="hljs-string"><span class="hljs-string">"prepare"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run prepare:snyk"</span></span>,  <span class="hljs-string"><span class="hljs-string">"prepare:snyk"</span></span>: <span class="hljs-string"><span class="hljs-string">"snyk protect"</span></span> }, <span class="hljs-string"><span class="hljs-string">"husky"</span></span>: {  <span class="hljs-string"><span class="hljs-string">"hooks"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"commit-msg"</span></span>: <span class="hljs-string"><span class="hljs-string">"commitlint -E HUSKY_GIT_PARAMS"</span></span>,   <span class="hljs-string"><span class="hljs-string">"pre-commit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run test:snyk &amp;&amp; npm run lint &amp;&amp; npm run test:jest"</span></span>,   <span class="hljs-string"><span class="hljs-string">"pre-push"</span></span>: [    <span class="hljs-string"><span class="hljs-string">"npm run test:snyk"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run lint"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run test:jest"</span></span>,    <span class="hljs-string"><span class="hljs-string">"npm run build:production"</span></span>   ],   ...  } }, <span class="hljs-string"><span class="hljs-string">"snyk"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Arriba, miramos un cheque local para amenazas de seguridad.  Para verificar paquetes de amenazas conocidas, también recomiendo usar LGTM.  Use este proyecto junto con GitHub o Bitbucket (hasta que lo haya probado, no era necesario), y el código se verificará inmediatamente con cada pulsación. </p><br><h2>  Monitoreo de la aplicación </h2><br><p>  En el ámbito de Front-end, las herramientas ya están bien establecidas; las herramientas para todos los gustos están disponibles para registrar y monitorear la parte del cliente.  Los más famosos son Sentry, TrackJS e InsightOps.  Sentry Server se puede implementar en sus servidores físicos.  Por ejemplo, en nuestros dos proyectos utilizamos un servidor separado, que estaba completamente configurado para registrar el funcionamiento de las aplicaciones.  Fuimos a la URL y soltamos todos los registros allí.  Si se produce un error en la aplicación, se envuelve en un bloque try catch y se envía al servidor Sentry a través de los métodos del paquete raven.  Todo es simple y conveniente.  Si ve URL oscuras en Sentry que no registró, si ve incrustaciones o mensajes oscuros, entonces están tratando de hackearlo.  En mi práctica, esto sucedió regularmente.  Por ejemplo, uno de los proyectos, un servicio para evitar los bloqueadores de anuncios y los antivirus, intentaba constantemente contrarrestarlo, descifrarlo. </p><br><p>  Para el monitoreo, también recomiendo usar Grafana.  Es importante considerar un sistema de criterios e indicadores que serán monitoreados por el sistema.  Nos sintonizamos en el tráfico, en el retorno de la publicidad, en el grado de presentación de anuncios, en la cantidad de pancartas que provenían de Yandex, etc.  (proyectos en Rambler Group).  Necesitábamos entender cómo funciona Yandex con nuestras solicitudes, porque es un servicio de terceros, lo que significa que debe ser monitoreado, porque si falla, todo el proyecto puede colapsar por completo. </p><br><p>  Si supervisa todas las comunicaciones con servicios de terceros, encontrará rápidamente cualquier error.  La historia es de mi práctica: vimos que desde Yandex, las respuestas publicitarias dejaron de llegar.  Resultó que tenían fallas técnicas y que toda la red de publicidad cayó con fuerza.  Y no fue Yandex quien nos informó primero, pero los llamamos y les pedimos que vieran qué estaba pasando con sus servicios. </p><br><p>  ¿Cuál es la mejor manera de monitorear?  Tome una URL pequeña, escriba los parámetros GET y envíe una solicitud GET a esta URL.  En el lado del servidor, procese esta URL, escriba el registro en la base de datos y aumente la supervisión a Grafana.  Todo es simple </p><br><p>  Eso es todo  En el futuro intentaré seguir escribiendo sobre el tema de proteger las aplicaciones web de las amenazas.  A todos los que han leído hasta el final: deseo seguridad para sus proyectos))) </p><br><h3>  Lista de fuentes para leer sobre el tema: </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.owasp.org/index.php/Main_Page</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tproger.ru/translations/webapp-security</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">S. Hawks.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aplicación de página única incluso más rápida: seguridad</a> </p><br><p>  Seacord, Robert C. El estándar de codificación segura CERT C / Robert C. Seacord.  - 2008 </p><br><p>  Chetan Karande.  Asegurar aplicaciones de nodo - 2017 </p><br><p>  Steven Palmer.  Detección, explotación, prevención de vulnerabilidades de aplicaciones web: 2011 </p><br><p>  Robert Shimonski, Sean-Philip Oriyano.  Ataques y defensa del lado del cliente - 2012 </p><br><p>  Marcus Pinto, Dafydd Stuttard.  El Manual del hacker de aplicaciones web: Encontrar y explotar fallas de seguridad, 2ª edición - 2011 </p><br><p>  Karl Duuna  Asegure su aplicación web Node.js - 2015 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445932/">https://habr.com/ru/post/445932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445920/index.html">Live: cómo frenar el desarrollo de iOS en equipos grandes</a></li>
<li><a href="../445922/index.html">¿Por qué ver transmisiones en línea si puedes leer a Habr?</a></li>
<li><a href="../445924/index.html">TESOROS: cuando los relojes inteligentes se vuelven raros</a></li>
<li><a href="../445926/index.html">El Programa secreto de ovnis de EE. UU. También ha estado investigando agujeros de gusano y dimensiones adicionales.</a></li>
<li><a href="../445928/index.html">Cómo aumentamos la productividad de servicio de Tensorflow en un 70%</a></li>
<li><a href="../445936/index.html">Desarrollo de electrónica. Sobre microcontroladores en los dedos</a></li>
<li><a href="../445940/index.html">AMA con Habr, v 7.0. Limón, Donuts y Noticias</a></li>
<li><a href="../445946/index.html">MWC: instrucciones de uso</a></li>
<li><a href="../445948/index.html">Herencia en C ++: principiante, intermedio, avanzado</a></li>
<li><a href="../445952/index.html">Un trillón de solteros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>