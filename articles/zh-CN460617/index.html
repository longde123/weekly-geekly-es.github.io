<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏐 🚶🏾 😌 关于RTOS的全部真相。 第30条。 Nucleus SE初始化和启动过程 🚅 🎟️ 👩🏼‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="任何操作系统都有特定的启动机制。 每个系统的这种机制的工作原理是不同的。 通常他们说系统启动（Eng。Boot），这是“ bootstrap”的缩写，它是指“用靴子将自己拉过篱笆”（越过篱笆，用鞋带拉自己）。系统如何独立地从内存为空的状态（ 译者注：如果绝对准确，则为垃圾 ）移动到稳定的程序执行。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于RTOS的全部真相。 第30条。 Nucleus SE初始化和启动过程</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460617/"><img src="https://habrastorage.org/webt/nr/me/cz/nrmeczn3tg-kdwyme6qgmd7ily4.jpeg"><br><br> 任何操作系统都有特定的启动机制。 每个系统的这种机制的工作原理是不同的。 通常他们说系统启动（Eng。Boot），这是“ bootstrap”的缩写，它是指“用靴子将自己拉过篱笆”（越过篱笆，用鞋带拉自己）。系统如何独立地从内存为空的状态（ <i>译者注：如果绝对准确，则为垃圾</i> ）移动到稳定的程序执行。 传统上，程序的一小部分被加载到内存中；它可以存储在ROM中。 过去，可以使用计算机正面的开关输入该密码。 该引导加载程序读取了一个已经加载了操作系统的更复杂的引导程序。 今天，台式计算机的启动方式如下：BIOS代码查找可以从中启动的设备（硬盘驱动器，CD-ROM，USB记忆棒），然后操作系统启动。 <br><br> 嵌入式系统的OS也可以用类似的方式初始化。 实际上，已经加载了基于桌面操作系统开发的嵌入式操作系统。 但是在大多数“经典” RTOS中，使用的方法要简单得多（因此更快）。 <br><a name="habracut"></a><br> 操作系统是软件的一部分。 如果此软件已经存在于内存中（例如，以ROM的一种形式或另一种形式），则只需确保复位后的CPU命令序列以执行OS初始化代码结束。 这就是大多数RTOS的工作方式，包括Nucleus SE（ <i>译者注：这也适用于我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS MAX</a></i> ）。 <br><br> 大多数嵌入式软件开发工具都包含必要的启动代码，以处理CPU复位并将控制转移到<b>main（）</b>函数中的Entry Point函数。  Nucleus SE可再发行代码不处理此过程，因为它必须尽可能地可移植。 相反，它包含<b>main（）</b>函数，该函数控制CPU并初始化并启动OS。 此功能将在下面详细讨论。 <br><br><div class="spoiler">  <b class="spoiler_title">该系列中的先前文章：</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第29条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE的中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第28条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">软件计时器</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第27条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">系统时间</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第26条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">渠道：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第25条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数据通道：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第24条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第23条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">队列：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第22条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第21条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">邮箱：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第20条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号量：辅助服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十九条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信号灯：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十八条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：助手服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十七条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件标志组：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十六条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讯号</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十五条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存分区：服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十四条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存部分：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十三条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务数据结构和不受支持的API调用</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十二条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务处理服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务：API的配置和介绍</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序：高级功能和上下文保留</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序：实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：内部设计和部署</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：简介</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他RTOS服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务交互和同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，上下文切换和中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务与计划</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：结构和实时模式</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：简介。</a> <br></div></div><br><h3> 内存初始化 </h3><br>  Nucleus SE代码中所有静态变量的声明均以<b>ROM</b>或<b>RAM</b>前缀开头，以指示应将其放置在何处。 这两个<b>#define</b>指令在<b>nuse_types.h</b>文件中定义，并且必须在配置时考虑所使用的一组开发工具（编译器和链接器）的详细信息。 通常， <b>ROM</b>应该是<b>const</b>类型（ <i>译者注：根据我的经验， <b>const</b>并不总是足够的， <b>static</b>更好</i> ），而<b>RAM</b>是空值。 <br><br> 所有<b>ROM</b>变量都是静态初始化的，这是合乎逻辑的。  <b>RAM</b>变量不是静态初始化的（因为这仅适用于某些配置为自动从ROM复制到RAM的工具箱）； 一个明确的初始化代码包含在应用程序中，下面将对其进行详细描述。 <br><br>  Nucleus SE不会在RAM中存储“恒定”数据，而在小型系统中，RAM通常供不应求。 无需使用复杂的数据结构来描述内核对象，而是使用表（数组）集，这些表集可以根据需要轻松地放置在ROM或RAM中。 <br><br><h2> 主要（）函数 </h2><br> 以下是Nucleus SE的<b>main（）</b>函数的完整代码： <br><br><pre><code class="plaintext hljs">void main(void) { NUSE_Init(); /* initialize kernel data */ /* user initialization code here */ NUSE_Scheduler(); /* start tasks */ }</code> </pre> <br> 操作顺序非常简单： <br><br><ul><li> 首先， <b>调用NUSE_Init（）</b>函数。 它会初始化所有Nucleus SE数据结构，下面将详细介绍。 </li><li> 然后，用户可以插入将在任务计划程序启动之前执行的任何应用程序初始化代码。 有关此代码可以实现的更多信息，请参见本文后面。 </li><li> 最后，Nucleus SE调度程序（ <b>NUSE_Scheduler（）</b> ）启动。 本文后面还将对此进行详细讨论。 </li></ul><br><h2>  NUSE_Init（）函数 </h2><br> 该函数初始化所有Nucleus SE内核变量和数据结构。 <br><br><div class="spoiler">  <b class="spoiler_title">以下是完整的功能代码：</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init(void) { U8 index; /* global data */ NUSE_Task_Active = 0; NUSE_Task_State = NUSE_STARTUP_CONTEXT; #if NUSE_SYSTEM_TIME_SUPPORT NUSE_Tick_Clock = 0; #endif #if NUSE_SCHEDULER_TYPE == NUSE_TIME_SLICE_SCHEDULER NUSE_Time_Slice_Ticks = NUSE_TIME_SLICE_TICKS; #endif /* tasks */ #if ((NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER) || NUSE_SIGNAL_SUPPORT || NUSE_TASK_SLEEP || NUSE_SUSPEND_ENABLE || NUSE_SCHEDULE_COUNT_SUPPORT) for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { NUSE_Init_Task(index); } #endif /* partition pools */ #if NUSE_PARTITION_POOL_NUMBER != 0 for (index=0; index&lt;NUSE_PARTITION_POOL_NUMBER; index++) { NUSE_Init_Partition_Pool(index); } #endif /* mailboxes */ #if NUSE_MAILBOX_NUMBER != 0 for (index=0; index&lt;NUSE_MAILBOX_NUMBER; index++) { NUSE_Init_Mailbox(index); } #endif /* queues */ #if NUSE_QUEUE_NUMBER != 0 for (index=0; index&lt;NUSE_QUEUE_NUMBER; index++) { NUSE_Init_Queue(index); } #endif /* pipes */ #if NUSE_PIPE_NUMBER != 0 for (index=0; index&lt;NUSE_PIPE_NUMBER; index++) { NUSE_Init_Pipe(index); } #endif /* semaphores */ #if NUSE_SEMAPHORE_NUMBER != 0 for (index=0; index&lt;NUSE_SEMAPHORE_NUMBER; index++) { NUSE_Init_Semaphore(index); } #endif /* event groups */ #if NUSE_EVENT_GROUP_NUMBER != 0 for (index=0; index&lt;NUSE_EVENT_GROUP_NUMBER; index++) { NUSE_Init_Event_Group(index); } #endif /* timers */ #if NUSE_TIMER_NUMBER != 0 for (index=0; index&lt;NUSE_TIMER_NUMBER; index++) { NUSE_Init_Timer(index); } #endif }</code> </pre><br></div></div><br> 首先，初始化全局变量： <br><ul><li>  <b>NUSE_Task_Active-</b>活动任务的索引，初始化为零； 稍后这可能会更改调度程序。 </li><li>  <b>NUSE_Task_State-</b>使用值<b>NUSE_STARTUP_CONTEXT</b>初始化，该值限制了任何后续应用程序初始化代码的API功能。 </li><li> 如果激活了系统时间支持，则<b>NUSE_Tick_Clock设置</b>为零。 </li><li> 如果激活了时间片调度程序， <b>则会为NUSE_Time_Slice_Ticks</b>分配配置值<b>NUSE_TIME_SLICE_TICKS</b> 。 </li></ul><br> 然后调用函数以初始化内核对象： <br><br><ul><li>  <b>调用NUSE_Init_Task（）</b>初始化每个任务的数据结构。 仅在使用“运行至完成”调度程序且未配置信号，任务暂停和调度计数器的情况下才跳过此调用（由于此功能组合将导致RAM中没有这些任务结构，因此将不执行初始化）。 </li><li>  <b>调用NUSE_Init_Partition_Pool（）</b>初始化每个分区池对象。 如果未配置分区池，则将跳过这些调用。 </li><li>  <b>调用NUSE_Init_Mailbox（）</b>初始化每个邮箱对象。 如果没有配置的邮箱，将跳过这些呼叫。 </li><li>  <b>调用NUSE_Init_Queue（）</b>初始化每个队列对象。 如果未配置队列，将跳过这些调用。 </li><li>  <b>调用NUSE_Init_Pipe（）</b>初始化每个通道对象。 如果未配置任何通道，将跳过这些呼叫。 </li><li>  <b>调用NUSE_Init_Semaphore（）</b>初始化每个信号量对象。 如果未配置任何信号灯，则将跳过这些调用。 </li><li>  <b>调用NUSE_Init_Event_Group（）</b>初始化每个事件组对象。 如果没有配置的事件组，将跳过这些调用。 </li><li>  <b>调用NUSE_Init_Timer（）</b>初始化每个计时器对象。 如果未配置任何计时器，将跳过这些调用。 </li></ul><br><h3> 任务初始化 </h3><br><div class="spoiler">  <b class="spoiler_title">以下是NUSE_Init_Task（）函数的完整代码：</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void NUSE_Init_Task(NUSE_TASK task) { #if NUSE_SCHEDULER_TYPE != NUSE_RUN_TO_COMPLETION_SCHEDULER NUSE_Task_Context[task][15] = /* SR */ NUSE_STATUS_REGISTER; NUSE_Task_Context[task][16] = /* PC */ NUSE_Task_Start_Address[task]; NUSE_Task_Context[task][17] = /* SP */ (U32 *)NUSE_Task_Stack_Base[task] + NUSE_Task_Stack_Size[task]; #endif #if NUSE_SIGNAL_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Signal_Flags[task] = 0; #endif #if NUSE_TASK_SLEEP || NUSE_INCLUDE_EVERYTHING NUSE_Task_Timeout_Counter[task] = 0; #endif #if NUSE_SUSPEND_ENABLE || NUSE_INCLUDE_EVERYTHING #if NUSE_INITIAL_TASK_STATE_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Status[task] = NUSE_Task_Initial_State[task]; #else NUSE_Task_Status[task] = NUSE_READY; #endif #endif #if NUSE_SCHEDULE_COUNT_SUPPORT || NUSE_INCLUDE_EVERYTHING NUSE_Task_Schedule_Count[task] = 0; #endif }</code> </pre><br></div></div><br> 如果尚未配置“运行至完成”调度程序，则将初始化<b>NUSE_Task_Context [task] []任务</b>的上下文块。 大多数元素未分配值，因为它们代表公用的机器寄存器，在启动任务时应具有中间值。 在Nucleus SE实现的示例（飞思卡尔ColdFire）中（但对于其他处理器，该机制类似），最后三个条目是明确设置的： <br><br><ul><li>  <b>NUSE_Task_Context [任务] [15]</b>包含状态寄存器（ <b>SR</b> ，状态寄存器），并具有<b>#define NUSE_STATUS_REGISTER</b>指令的值。 </li><li>  <b>NUSE_Task_Context [task] [16]</b>包含程序计数器（ <b>PC</b> ，程序计数器），并具有任务代码输入点的地址值： <b>NUSE_Task_Start_Address [task]</b> 。 </li><li>  <b>NUSE_Task_Context [task] [17]</b>包含堆栈指针（ <b>SP</b> ，堆栈指针），并使用作为任务堆栈的地址（ <b>NUSE_Task_Stack_Base [task]</b> ）和任务堆栈的大小（ <b>NUSE_Task_Stack_Size [task]</b> ）的总和进行初始化。 </li></ul><br> 如果激活了信号支持， <b>则将</b>任务信号标志（ <b>NUSE_Task_Signal_Flags [task]</b> ）设置为零。 <br><br> 如果激活了任务挂起（即<b>NUSE_Task_Sleep（）</b> API服务调用），则任务超时计数器（ <b>NUSE_Task_Timeout_Counter [task]</b> ）设置为零。 <br><br> 如果激活了任务挂起状态，则将初始化任务状态（ <b>NUSE_Task_Status [task]</b> ）。 如果激活了对任务初始状态的支持，则该初始值由用户设置（在<b>NUSE_Task_Initial_State [task]中</b> ）。 否则，将状态分配给<b>NUSE_READY</b> 。 <br><br> 如果激活了计划计数器，则任务计数器（ <b>NUSE_Task_Schedule_Count [task]</b> ）设置为零。 <br><br><h3> 初始化分区池 </h3><br> 以下是<b>NUSE_Init_Partition_Pool（）</b>函数的完整代码： <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Partition_Pool(NUSE_PARTITION_POOL pool) { NUSE_Partition_Pool_Partition_Used[pool] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Partition_Pool_Blocking_Count[pool] = 0; #endif }</code> </pre><br>  “已用”分区池计数器（ <b>NUSE_Partition_Pool__Partition_Used [pool]</b> ）设置为零。 <br><br> 如果激活了任务锁定，则分区池（ <b>NUSE_Partition_Pool_Blocking_Count [pool]）</b>的阻止任务计数器将<b>设置</b>为零。 <br><br><h3> 初始化邮箱 </h3><br> 以下是完整的<b>NUSE_Init_Mailbox（）</b>代码： <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Mailbox(NUSE_MAILBOX mailbox) { NUSE_Mailbox_Data[mailbox] = 0; NUSE_Mailbox_Status[mailbox] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Mailbox_Blocking_Count[mailbox] = 0; #endif }</code> </pre><br> 邮箱数据存储（ <b>NUSE_Mailbox_Data [mailbox]</b> ）设置为零，状态（ <b>NUSE_Mailbox_Status [mailbox]</b> ）变为“未使用”（即零）。 <br><br> 如果激活了任务锁定，则阻止的邮箱任务的计数器（ <b>NUSE_Mailbox_Blocking_Count [mailbox]</b> ）设置为零。 <br><br><h3> 队列初始化 </h3><br> 以下是<b>NUSE_Init_Queue（）</b>函数的完整代码： <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Queue(NUSE_QUEUE queue) { NUSE_Queue_Head[queue] = 0; NUSE_Queue_Tail[queue] = 0; NUSE_Queue_Items[queue] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Queue_Blocking_Count[queue] = 0; #endif }</code> </pre><br> 指向队列起点和终点的指针（实际上，它们是索引<b>NUSE_Queue_Head [queue</b> ]和<b>NUSE_Queue_Tail [queue]</b> ）被分配了一些值，这些值指示队列的数据区域的起点（即，它们的值为零）。 队列中的计数器（ <b>NUSE_Queue_Items [queue]</b> ）也设置为零。 <br><br> 如果激活了任务锁定，则阻塞队列任务的计数器（ <b>NUSE_Queue_Blocking_Count [queue]</b> ）设置为零。 <br><br><h3> 通道初始化 </h3><br> 以下是<b>NUSE_Init_Pipe（）</b>函数的完整代码： <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Pipe(NUSE_PIPE pipe) { NUSE_Pipe_Head[pipe] = 0; NUSE_Pipe_Tail[pipe] = 0; NUSE_Pipe_Items[pipe] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Pipe_Blocking_Count[pipe] = 0; #endif }</code> </pre><br> 指向通道起点和终点的指针（实际上是索引<b>-NUSE_Pipe_Head [pipe]</b>和<b>NUSE_Pipe_Tail [pipe]</b> ）被分配了一个值，该值指示通道数据区域的起点（即，它们为空值）。 通道<b>计数器</b> （ <b>NUSE_Pipe_Items [pipe]</b> ）也设置为零。 <br><br> 如果激活了任务锁定，则通道的阻止任务计数器（ <b>NUSE_Pipe_Blocking_Count [pipe]</b> ）设置为零。 <br><br><h3> 信号量初始化 </h3><br> 以下是<b>NUSE_Init_Semaphore（）</b>函数的完整代码： <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Semaphore(NUSE_SEMAPHORE semaphore) { NUSE_Semaphore_Counter[semaphore] = NUSE_Semaphore_Initial_Value[semaphore]; #if NUSE_BLOCKING_ENABLE NUSE_Semaphore_Blocking_Count[semaphore] = 0; #endif }</code> </pre><br> 信号量计数器（ <b>NUSE_Semaphore_Counter [semaphore]</b> ）使用用户设置的值（ <b>NUSE_Semaphore_Initial_Value [semaphore]</b> ）进行初始化。 <br><br> 如果激活了任务锁定，则锁定的信号量任务计数器（ <b>NUSE_Semaphore_Blocking_Count [semaphore]</b> ）设置为零。 <br><br><h3> 初始化事件组 </h3><br> 以下是<b>NUSE_Init_Event_Group（）</b>函数的完整代码： <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Event_Group(NUSE_EVENT_GROUP group) { NUSE_Event_Group_Data[group] = 0; #if NUSE_BLOCKING_ENABLE NUSE_Event_Group_Blocking_Count[group] = 0; #endif }</code> </pre><br> 事件组的标志被重置，即  <b>NUSE_Event_Group_Data [group]</b>分配了一个空值。 <br><br> 如果激活了任务锁定，则事件标志组（ <b>NUSE_Event_Group_Blocking_Count [group]</b> ）的已阻止任务计数器将设置为零。 <br><br><h3> 计时器初始化 </h3><br> 下面是<b>NUSE_Init_Timer（）</b>的完整代码； <br><br><pre> <code class="plaintext hljs">void NUSE_Init_Timer(NUSE_TIMER timer) { NUSE_Timer_Status[timer] = FALSE; NUSE_Timer_Value[timer] = NUSE_Timer_Initial_Time[timer]; NUSE_Timer_Expirations_Counter[timer] = 0; }</code> </pre><br> 计时器的状态（ <b>NUSE_Timer_Status [timer]</b> ）设置为“未使用”，即  <b>假</b> <br><br> 倒计时值（ <b>NUSE_Timer_Value [timer</b> ]）由用户设置的值（ <b>NUSE_Timer_Initial_Time [timer</b> ]）初始化。 <br><br> 完成计数器（ <b>NUSE_Timer_Expirations_Counter [timer]</b> ）设置为零。 <br><br><h2> 初始化应用程序代码 </h2><br> 在Nucleus SE数据结构初始化之后，可以在开始任务之前执行负责初始化应用程序的代码。 此功能对于以下任务可能有用： <br><br><ul><li> 应用程序数据结构的初始化。 与静态变量的自动初始化相比，显式填充数据结构更容易理解和调试。 </li><li> 内核对象的分配。 假设所有内核对象都是在构建阶段静态创建的，并使用索引值进行标识，则分配“所有者”或确定这些对象的使用可能很有用。 可以使用#define指令完成此操作，但是，如果有多个任务实例，则最好通过全局数组（由任务ID索引）分配对象索引。 </li><li> 设备初始化。 这对于外围设备的初始安装很有用。 </li></ul><br> 显然，在Nucleus SE初始化之前，可以实现许多目标，但是此处应用程序代码位置的优势在于，现在您可以使用内核服务（API调用）。 例如，队列或邮箱可能预填充了任务开始时需要处理的数据。 <br><br>  API调用有一个限制：禁止通常导致激活调度程序的所有操作（例如，暂停/阻止任务）。 全局变量<b>NUSE_Task_State</b>已设置为<b>NUSE_STARTUP_CONTEXT</b>以<b>指示</b>此限制。 <br><br><h2> 启动调度程序 </h2><br> 初始化完成后，仅需运行调度程序即可开始执行应用程序代码-任务。 在上一篇文章（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">＃9</a> ）中详细描述了调度程序的配置和各种类型的调度程序的工作，因此这里仅需要简要概述。 <br> 关键步骤的顺序如下： <br><br><ul><li>  <b>将</b>全局变量<b>NUSE_Task_State设置为</b> <b>NUSE_TASK_CONTEXT</b> 。 </li><li> 选择要运行的第一个任务的索引。 如果激活了对初始任务的支持，则将执行对第一个完成的任务的搜索，否则，将使用零值。 </li><li> 该调度程序<b>称为-NUSE_Scheduler（）</b> 。 </li></ul><br> 在最后一步中确切发生什么取决于选择哪个调度程序。 使用“运行至完成”计划程序时，计划周期开始，并且依次调用任务。 使用其他调度程序时，将加载第一个任务的上下文，并将控制权转移到该任务。 <br><br> 下面的文章将讨论诊断和错误检查。 <br><br>  <b>关于作者：</b> Colin Walls在电子行业工作了30多年，大部分时间用于固件。 他现在是Mentor Embedded（Mentor Graphics的一个部门）的固件工程师。  Colin Walls经常在会议和研讨会上发表演讲，他撰写了许多技术文章并撰写了两本有关固件的书。 居住在英国。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Colin的</a>专业<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客</a> ，电子邮件：colin_walls@mentor.com。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460617/">https://habr.com/ru/post/zh-CN460617/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460603/index.html">V2G。 电动汽车将有助于平衡电力的生产和消耗</a></li>
<li><a href="../zh-CN460605/index.html">自动照相馆，第1部分</a></li>
<li><a href="../zh-CN460607/index.html">具有Android黑客工具的Offensive Security应用商店</a></li>
<li><a href="../zh-CN460611/index.html">故障转移：完美主义毁了我们，并且……懒惰</a></li>
<li><a href="../zh-CN460615/index.html">在《工业忍者》问世之后：如何在Positive Hack Days 9中入侵PLC</a></li>
<li><a href="../zh-CN460621/index.html">井字游戏第4部分：使用HTTP与Flask后端交互</a></li>
<li><a href="../zh-CN460623/index.html">关于朱利安·阿桑奇的酷刑</a></li>
<li><a href="../zh-CN460625/index.html">因为我没有在Telegram的JavaScript开发人员竞赛中获得第一名</a></li>
<li><a href="../zh-CN460627/index.html">vGPU-使用不可忽略</a></li>
<li><a href="../zh-CN460629/index.html">2名矿工拥有相同世界的概率</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>