<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆 👩‍👧‍👧 🧗 Dungeons und Höhlen für mein Spiel generieren 🍼 👨‍🏫 🤯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Woche habe ich angefangen, an einem neuen Thema zu arbeiten: der Erzeugung von Dungeons und Höhlen. Ich habe Raumpartitionierung verwendet, um R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dungeons und Höhlen für mein Spiel generieren</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461087/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f40/e6c/e0bf40e6c33ed78da13006970a027378.gif" width="400"></div><br>  Diese Woche habe ich angefangen, an einem neuen Thema zu arbeiten: der Erzeugung von Dungeons und Höhlen.  Ich habe Raumpartitionierung verwendet, um Räume zu generieren, Labyrinth-Generierungsalgorithmen, um Korridore zu generieren, und zellulare Automaten, um den Höhlen ein natürlicheres Aussehen zu verleihen. <br><br><h1>  Raumaufteilung </h1><br>  Es gibt viele Möglichkeiten, Dungeonräume zu generieren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zufällige Platzierung</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">agentenbasierte Generierung</a> , Verwendung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trennungslenkverhaltens</a> oder einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">physischen Engine</a> usw.).  Aber meine Lieblingsmethode ist es, den Raum zu teilen, weil er leicht zu steuern und zu erweitern ist. <br><br>  Es gibt auch viele Möglichkeiten, den Raum zu teilen: Aufteilung in Gitter, binäre Aufteilung des Raums, Aufteilung des Raums durch einen Quadrantenbaum, Voronoi-Diagramme usw.  Ich habe mich für eine binäre Raumaufteilung entschieden, da sie sich gut zur Erzeugung rechteckiger Räume eignet.  Diese Methode hat dank eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikels</a> über RogueBasin an Popularität gewonnen. <br><br>  Die einzige Komplexität dieses Algorithmus ist die Wahl der Trennposition.  Wenn wir die Trennposition nicht einschränken, erhalten wir seltsame Raumpartitionen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/f0a/38c/699f0a38c5800499dad98b63e811ace3.gif" width="400"></div><br>  Es gibt verschiedene Möglichkeiten, um dieses Verhalten zu vermeiden.  Eine davon besteht darin, die Trennposition auf zwei Aspektverhältnisse zu beschränken, beispielsweise im Bereich von 30% bis 70% oder von 40% bis 60%.  Eine andere Möglichkeit besteht darin, anstelle einer gleichmäßigen Verteilung Normal- oder Binomialwerte zu verwenden, wodurch die Wahrscheinlichkeit einer Trennung in der Mitte der Seite und nicht an den Rändern erhöht wird.  Diese Methoden beheben das Problem, aber es ist schwer zu verstehen, wie genau sich die Parameter auf das Endergebnis auswirken. <br><a name="habracut"></a><br>  Daher habe ich eine andere Methode verwendet, deren Vorteil darin besteht, dass sie einen Parameter hat und leicht zu verstehen ist: das maximal zulässige Verhältnis zwischen Länge und Breite der Zellen.  Wenn ich eine neue Trennung abtaste, berechne ich zuerst die minimalen und maximalen Werte, die sie haben kann, damit das Verhältnis für zwei neue Zellen unter dem Grenzwert liegt, und führe dann eine einheitliche Abtastung zwischen diesen beiden Grenzen durch.  Hier ist das Ergebnis beim Variieren des maximal zulässigen Verhältnisses: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cff/6c0/eed/cff6c0eed66a7b26ddad9f3506fc0874.gif" width="400"></div><br>  Gute Ergebnisse werden mit einem maximalen Verhältnis von 2,0 zu 3,0 erzielt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/531/a66/805/531a66805a7c2e60db79e8eec25badd9.gif" width="400"></div><br><h1>  Raumgenerierung </h1><br>  Die nächste Stufe ist die Erzeugung in jeder Zelle des Raumes.  Hier gibt es keine besonderen Probleme, ich habe nur Grenzen gesetzt, damit die Räume nicht zu klein und nicht zu nahe an den Zellwänden sind. <br><br>  Hier sind die Ergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e9/609/782/4e960978275052a4669fda6e7e531ea6.gif" width="400"></div><br><h1>  Rippenauswahl </h1><br>  In binären Teilungs-Dungeon-Generatoren wird der im Teilungsschritt verwendete Binärbaum normalerweise wiederverwendet, um Korridore zu erzeugen.  Ich habe das nicht getan, weil mir ein solcher Ansatz einschränkend erscheint. <br><br>  Stattdessen baue ich beim Teilen des Raums die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Struktur einer doppelt verbundenen Liste von Kanten auf</a> , anhand derer wir erkennen können, welche Zellen sich nebeneinander befinden.  Auf diese Weise erhalte ich folgende Grafiken: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe1/a31/828/fe1a31828c8ee1abb2a6bb5921d65e07.gif" width="400"></div><br>  Dieser Ansatz bietet drei Vorteile.  Erstens: Wenn ich in Zukunft die Art der Raumteilung ändern möchte, bleibt der Rest des Generators gültig, da er am Eingang nur eine Halbkanten-Datenstruktur empfängt.  Zweitens: Um nun die Kanten auszuwählen, die zu Korridoren werden sollen, kann ich einen beliebigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Algorithmus zum Erzeugen von Labyrinthen verwenden</a> .  Drittens: Wenn ich dem Dungeon Schleifen hinzufügen möchte, kann ich dies einfach implementieren. <br><br>  Im Moment verwende ich nur den Kruskal-Algorithmus und den Abstand der Stadtblöcke, um Kanten auszuwählen.  Hier sind die Ergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/095/927/6a4/0959276a4b2a8e10f5a95d7c3c7417f2.gif" width="400"></div><br><h1>  Korridorgenerierung </h1><br>  Der nächste Schritt besteht darin, Korridore aus den ausgewählten Kanten zu generieren.  Dies ist wahrscheinlich der schwierigste Teil des Generators, da ich vorsichtig sein muss, damit sich kein Korridor mit einem anderen schneidet. <br><br>  Hier sind die Ergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/ac8/5cb/240ac85cb6edcf3a4cd91129b0c22c36.gif" width="400"></div><br><h1>  Höhlengeneration </h1><br>  Die vorherigen Ergebnisse waren für die Erstellung von Dungeons, Krypten und anderen künstlichen Strukturen geeignet, aber ich wollte den Höhlen und Minen ein natürlicheres Aussehen verleihen.  Die klassische Art, Höhlen zu erzeugen, ist die Verwendung eines zellularen Automaten, wie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem</a> RogueBasin- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel beschrieben</a> .  Das große Problem bei zellularen Automaten ist, dass ihre Ergebnisse nicht vollständig kontrolliert werden. <br><br>  Wie auch immer, ich entschied mich dafür, zellulare Automaten zu verwenden, um ein natürliches Erscheinungsbild zu erzeugen, aber ihnen Einschränkungen aufzuerlegen, um ein kontrolliertes Ergebnis zu erzielen.  Anstelle von nur zwei Zuständen: tot und lebendig verwende ich vier: absolut tot, tot, lebendig, definitiv lebendig.  "Perfekt genaue" Zustände können sich dabei nicht ändern, sie werden verwendet, um die Ergebnisse einzuschränken. <br><br>  Die in den vorherigen Schritten generierten Räume und Korridore sind mit „genau lebendigen“ Zellen gefüllt.  Das heißt, wir haben noch unterstützende Räume und wir garantieren, dass sie miteinander verbunden werden.  Die nicht ausgewählten Kanten werden mit „genau toten“ Zellen gefüllt, sodass keine neuen Pfade zwischen den Räumen angezeigt werden.  Schließlich machen wir in Räumen und Korridoren zufällig einige Zellen lebendig.  Hier ist die Erstkonfiguration: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/014/95f/b66/01495fb6695a82de2a9164864b27f08f.png" width="400"></div><br>  Dann starten wir den zellularen Automaten: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/408/05e/9e840805e01204122e2eb0252bded4f7.gif" width="400"></div><br><br>  Hier sind einige weitere Beispielergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3aa/bd6/c9d/3aabd6c9daa127050f84687ef1731e95.gif" width="400"></div><br>  Später werde ich eine Füllung hinzufügen, um nicht erreichbare Teile zu entfernen. <br><br>  Dies ist der erste Schritt auf einer langen Reise, um einen interessanten Dungeongenerator zu erstellen.  Ich bin mit den Ergebnissen zufrieden.  Ich bin besonders stolz auf die eingeschränkte Methode der zellularen Automaten, kontrollierte und natürliche Höhlen zu schaffen.  Ich mag auch die Tatsache, dass jede Generationsstufe von den anderen getrennt ist und individuell modifiziert werden kann. <br><br><h1>  Isolierte Zellen löschen </h1><br>  Dann habe ich eine Füllung implementiert, um unzugängliche Zellen zu entfernen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/4bb/f55/7c34bbf55808cd689bc3b7456ea8e2d7.gif" width="400"></div><br><h1>  Mehrere Korridore zwischen den Räumen </h1><br>  Beim Experimentieren mit den Parametern des Generators stellte ich fest, dass Sie interessante Ergebnisse erzielen, wenn Sie zwischen den Verbindungsräumen ein wenig Rauschen hinzufügen. <br><br>  Hier ist der Unterschied in den Ergebnissen vor dem Anlegen von Lärm an Verbindungsräume und unmittelbar danach ändert sich der Parameter nur um eine Einheit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/f26/263/f7bf2626343bcee26f2afc42e037d314.png" width="400"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a6/1de/10c/7a61de10c6b53dab00ede8554a4d78de.png" width="400"></div><br>  Wenn Sie die Räume etwas größer machen, wird das Ergebnis noch interessanter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/7a8/486/ebc7a8486cbfd1251ac03f87c4cf079b.png" width="400"></div><br>  Es ist großartig, dass wir einen Unfall haben und schöne Strukturen entstehen, aber gleichzeitig bleiben die Struktur der Grafik und die Bezeichnungen der Räume erhalten, was nützlich sein wird: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/818/658/0ed/8186580ed4aca49f61e2841c7afe043e.png" width="400"></div><br><h1>  Fliesenerzeugung für Höhlen </h1><br>  Ich habe die meiste Zeit damit verbracht, Fliesen zu generieren.  Es ist nicht sehr schwierig, aber für die korrekte Implementierung sind ein paar Tricks erforderlich. <br><br>  Hier sind Beispielergebnisse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/d48/470/7bcd484707cb39ee084496297c9856b4.gif" width="400"></div><br>  Das Tolle ist, dass Sie sehr einfach von einer Steinhöhle zu Sand oder Eis wechseln können: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12b/e53/825/12be53825f1d1c3d9156a98265bd7600.gif" width="400"></div><br>  Die nächsten Schritte bei der Erstellung des Dungeons sind das Hinzufügen von Landschaften und Monstern. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461087/">https://habr.com/ru/post/de461087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461077/index.html">Wie werden Pentester gekocht? Eingangstests für Praktikanten im Bereich digitale Sicherheit</a></li>
<li><a href="../de461079/index.html">Stadt ohne Stau</a></li>
<li><a href="../de461081/index.html">Der Tag, an dem Dodo aufgehört hat. Asynchrones Skript</a></li>
<li><a href="../de461083/index.html">Schreiben von Software mit der Funktionalität von Client-Server-Dienstprogrammen Windows, Teil 02</a></li>
<li><a href="../de461085/index.html">Wechseln Sie die Sprache in der Android App</a></li>
<li><a href="../de461091/index.html">LED Camelion Lampen</a></li>
<li><a href="../de461093/index.html">Nachrichten aus der Welt von OpenStreetMap Nr. 469 (07/09/2019 - 07/07/2019)</a></li>
<li><a href="../de461095/index.html">Apollo Guidance Computer - Architektur und Systemsoftware. Teil 1</a></li>
<li><a href="../de461099/index.html">Spiel AirAttack! - unsere erste VR-Entwicklungserfahrung</a></li>
<li><a href="../de461101/index.html">Android Jetpack Compose First Impression</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>