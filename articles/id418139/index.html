<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤶🏻 🍐 👨🏿‍🎤 Solusi numerik dari model matematika objek yang diberikan oleh sistem persamaan diferensial 🙌🏿 🧑🏻 🚞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan: 
 Dalam pemodelan matematika dari sejumlah perangkat teknis, sistem persamaan nonlinier diferensial digunakan. Model seperti itu digunaka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solusi numerik dari model matematika objek yang diberikan oleh sistem persamaan diferensial</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418139/"><h3>  Pendahuluan: </h3><br>  Dalam pemodelan matematika dari sejumlah perangkat teknis, sistem persamaan nonlinier diferensial digunakan.  Model seperti itu digunakan tidak hanya dalam teknologi, mereka digunakan dalam ekonomi, kimia, biologi, kedokteran, dan manajemen. <br><br>  Studi tentang fungsi alat-alat tersebut membutuhkan solusi dari sistem persamaan ini.  Karena sebagian besar persamaan tersebut nonlinier dan tidak stasioner, seringkali mustahil untuk mendapatkan solusi analitiknya. <br><br>  Ada kebutuhan untuk menggunakan metode numerik, yang paling terkenal adalah metode Runge - Kutta [1].  Adapun Python, dalam publikasi tentang metode numerik, misalnya [2,3], ada sangat sedikit data tentang penggunaan Runge - Kutta, dan tidak ada data tentang modifikasi pada metode Runge - Kutta - Felberg. <br><br>  Saat ini, berkat antarmuka yang sederhana, fungsi odeint dari modul scipy.integrate memiliki distribusi terbesar di Python.  Fungsi kedua dari modul ini mengimplementasikan beberapa metode, termasuk metode Runge-Kutta-Felberg lima peringkat yang disebutkan, tetapi karena sifatnya yang universal, kinerjanya terbatas. <br><br>  Tujuan dari publikasi ini adalah analisis komparatif dari sarana yang terdaftar untuk menyelesaikan sistem persamaan diferensial secara numerik dengan penulis yang dimodifikasi di bawah Python menggunakan metode Runge-Kutta-Felberg.  Publikasi ini juga menyediakan solusi untuk masalah nilai batas untuk sistem persamaan diferensial (SDE). <br><a name="habracut"></a><br><h3>  Data teoritis dan aktual singkat tentang metode dan perangkat lunak yang dipertimbangkan untuk solusi numerik CDS </h3><br>  <b>Masalah Cauchy</b> <br><br>  Untuk satu persamaan diferensial dari urutan ke-n, masalah Cauchy terdiri dalam menemukan fungsi yang memenuhi kesetaraan: <br><br><img src="https://habrastorage.org/webt/lt/b1/2t/ltb12ttbaok7cykpov2wr1ll2d8.png"><br><br>  dan kondisi awal <br><br><img src="https://habrastorage.org/webt/wu/hv/h6/wuhvh6vc6lvhbtjv9cpdt2ngwpk.png"><br><br>  Sebelum menyelesaikan masalah ini harus ditulis ulang dalam bentuk CDS berikut <br><br><img src="https://habrastorage.org/webt/of/ae/6d/ofae6da97foimjlsgplerdbgmw4.png">  (1) <br><br>  dengan kondisi awal <br><br><img src="https://habrastorage.org/webt/5h/yr/dx/5hyrdxv0rgrvdlb_wfqcx-xu8yc.png"><br><br>  <b>Modul Scipy.integrate</b> <br><br>  Modul ini memiliki dua fungsi ode () dan odeint (), yang dirancang untuk menyelesaikan sistem persamaan diferensial biasa (ODEs) dari urutan pertama dengan kondisi awal pada satu titik (masalah Cauchy).  Fungsi ode () lebih universal, dan fungsi odeint () (ODE integrator) memiliki antarmuka yang lebih sederhana dan menyelesaikan sebagian besar masalah dengan baik. <br><br>  <b>Odeint () berfungsi</b> <br><br>  Fungsi odeint () memiliki tiga argumen yang diperlukan dan banyak opsi.  Ini memiliki format berikut odeint (func, y0, t [, args = (), ...]) func func adalah nama Python dari fungsi dua variabel, yang pertama adalah daftar y = [y1, y2, ..., yn ], dan yang kedua adalah nama variabel independen. <br><br>  Fungsi fungsi harus mengembalikan daftar nilai fungsi n <img src="https://habrastorage.org/webt/px/uq/ut/pxuqutrevt661xvfc3wxjldgvem.png">  untuk nilai yang diberikan dari argumen independen t.  Faktanya, fungsi func (y, t) mengimplementasikan perhitungan sisi kanan sistem (1). <br><br>  Argumen kedua y0 dari odeint () adalah array (atau daftar) dari nilai awal <img src="https://habrastorage.org/webt/el/kx/j9/elkxj9mf1tffldehq2mqdvbl0mi.png">  pada t = t0. <br><br>  Argumen ketiga adalah berbagai titik waktu di mana Anda ingin mendapatkan solusi untuk masalah tersebut.  Dalam hal ini, elemen pertama dari array ini dianggap sebagai t0. <br><br>  Fungsi odeint () mengembalikan array ukuran len (t) x len (y0).  Fungsi odeint () memiliki banyak opsi yang mengontrol operasinya.  Opsi rtol (kesalahan relatif) dan atol (kesalahan absolut) menentukan kesalahan perhitungan ei untuk setiap nilai yi sesuai dengan rumus <br><br><img src="https://habrastorage.org/webt/qq/3a/pp/qq3appk_s2ck4bvifmd7mozxqyi.png"><br><br>  Mereka bisa menjadi vektor atau skalar.  Secara default <br><br><img src="https://habrastorage.org/webt/ha/lb/jo/halbjokez-c-a9ur0xeyp8pifew.png"><br><br>  <b>Ode () berfungsi</b> <br><br>  Fungsi kedua dari modul scipy.integrate, yang dirancang untuk menyelesaikan persamaan dan sistem diferensial, disebut ode ().  Itu menciptakan objek ODE (ketik scipy.integrate._ode.ode).  Memiliki tautan ke objek seperti itu, orang harus menggunakan metode-metodenya untuk menyelesaikan persamaan diferensial.  Serupa dengan fungsi odeint (), fungsi odeint (func) melibatkan pengurangan masalah ke sistem persamaan diferensial dari bentuk (1) dan menggunakan fungsinya di sisi kanan. <br><br>  Satu-satunya perbedaan adalah bahwa fungsi sisi kanan func (t, y) menerima variabel independen sebagai argumen pertama, dan daftar nilai fungsi yang diinginkan sebagai yang kedua.  Misalnya, urutan instruksi berikut ini membuat ODE yang mewakili tugas Cauchy. <br><br>  <b>Metode Runge - Kutta</b> <br><br>  Ketika membangun algoritma numerik, kami mengasumsikan bahwa solusi untuk masalah diferensial ini ada, itu unik dan memiliki sifat kelancaran yang diperlukan. <br><br>  Dalam solusi numerik masalah Cauchy <br><br><img src="https://habrastorage.org/webt/z6/sc/ag/z6scagau6_z8yjjazels3cibdlc.png">  (2) <br><br><img src="https://habrastorage.org/webt/cf/hp/p4/cfhpp4rxk8vhqnexgl3bgsaapeg.png">  (3) <br><br>  menurut solusi yang diketahui pada titik t = 0, perlu untuk menemukan solusi dari persamaan (3) untuk t lainnya.  Dalam solusi numerik masalah (2), (3), kita akan menggunakan kotak seragam, untuk kesederhanaan, dalam variabel t dengan langkah t&gt; 0. <br><br>  Solusi perkiraan untuk masalah (2), (3) pada intinya <img src="https://habrastorage.org/webt/j-/lc/cf/j-lccfwyp5vjoipcxlykp3dgbik.png">  menunjukkan <img src="https://habrastorage.org/webt/8s/g0/sj/8sg0sjhebyokeq5wuc7a8if2bqm.png">  .  Metode bertemu pada satu titik <img src="https://habrastorage.org/webt/b-/x8/0p/b-x80p4onflflxhl2lk1vadl3sg.png">  jika <img src="https://habrastorage.org/webt/ia/vi/8k/iavi8k482dcl150a2yxsd0gq-d0.png">  di <img src="https://habrastorage.org/webt/6b/sp/hq/6bsphqn74wsy9wdcniq4nibexfg.png">  .  Metode ini memiliki urutan akurasi ke-6 jika <img src="https://habrastorage.org/webt/jv/xz/j1/jvxzj1hz0rgs3key_wcinzror84.png">  , p&gt; 0 untuk <img src="https://habrastorage.org/webt/6b/sp/hq/6bsphqn74wsy9wdcniq4nibexfg.png">  .  Skema perbedaan paling sederhana untuk solusi perkiraan untuk masalah (2), (3) adalah <br><br><img src="https://habrastorage.org/webt/ao/-x/nx/ao-xnxhl01dfeg2znuupnwjqci8.png">  (4) <br><br>  Di <img src="https://habrastorage.org/webt/wn/xq/qq/wnxqqqiwt6jm375mk9jf2v0c_zs.png">  kami memiliki metode eksplisit dan dalam hal ini skema perbedaan mendekati persamaan (2) dengan urutan pertama.  Desain simetris <img src="https://habrastorage.org/webt/-t/sm/4h/-tsm4hzq9-agctksj5eahivdimq.png">  dalam (4) memiliki urutan aproksimasi kedua.  Skema ini milik kelas implisit - untuk menentukan solusi perkiraan pada layer baru, perlu untuk menyelesaikan masalah nonlinier. <br><br>  Lebih mudah untuk membangun skema pendekatan tingkat kedua dan tingkat atas yang eksplisit berdasarkan metode prediktor-korektor.  Pada tahap prediktor (prediksi), skema eksplisit digunakan. <br><br><img src="https://habrastorage.org/webt/yw/lf/an/ywlfancnmqu4smvvqozydtuw6qw.png">  (5) <br><br>  dan pada tahap korektor (penyempurnaan), diagram <br><br><img src="https://habrastorage.org/webt/vk/kx/sg/vkkxsg0mkht41hmefqo3krhkohw.png"><br><br>  Dalam metode Runge - Kutta satu langkah, gagasan prediktor-korektor diwujudkan sepenuhnya.  Metode ini ditulis dalam bentuk umum: <br><br><img src="https://habrastorage.org/webt/ou/dj/vf/oudjvfblha8fbsfvflq3qucylb0.png">  (6) <br><br>  dimana <br><br><img src="https://habrastorage.org/webt/of/gn/qh/ofgnqhxv2vlykcughxkzvvnzfm0.png"><br><br>  Formula (6) didasarkan pada perhitungan s dari fungsi f dan disebut s-stage.  Jika <img src="https://habrastorage.org/webt/5b/3e/om/5b3eomem0-kklkzcgc2_hy5ibyu.png">  di <img src="https://habrastorage.org/webt/ya/jx/d7/yajxd73qu-icfbj3_qte0sxoamk.png">  kami memiliki metode Runge - Kutta yang eksplisit.  Jika <img src="https://habrastorage.org/webt/5b/3e/om/5b3eomem0-kklkzcgc2_hy5ibyu.png">  untuk j&gt; 1 dan <img src="https://habrastorage.org/webt/sp/y9/l3/spy9l3eri4ug3bf4ec31kcqgjca.png">  lalu <img src="https://habrastorage.org/webt/m7/lj/ar/m7ljarovrnbr8ntzgbeekovygko.png">  ditentukan secara implisit dari persamaan: <br><br><img src="https://habrastorage.org/webt/md/2l/xs/md2lxstmkruwswxkb4hwqk3ejrm.png">  (7) <br><br>  Metode Runge - Kutta ini dikatakan implisit secara diagonal.  Parameter <img src="https://habrastorage.org/webt/yo/ud/im/youdimr4t898rol5a4naafrjbrk.png">  tentukan varian dari metode Runge - Kutta.  Representasi metode berikut digunakan (Butcher table) <br><br><img src="https://habrastorage.org/webt/qc/es/cx/qcescxh_lpjsra_3jqxghis4hz0.png"><br><br>  Salah satu yang paling umum adalah metode Runge - Kutta eksplisit urutan keempat. <br><br><img src="https://habrastorage.org/webt/b_/xb/6b/b_xb6bte_wppykllazhykapnppu.png">  (8) <br><br>  <b>Metode Runge - Kutta - Felberg</b> <br><br>  Saya memberikan nilai dari koefisien yang dihitung <img src="https://habrastorage.org/webt/m7/lj/ar/m7ljarovrnbr8ntzgbeekovygko.png">  metode <br><br><img src="https://habrastorage.org/webt/y6/v7/yk/y6v7yk2b6dabo8cfcz86kcbys2o.png">  (9) <br><br>  Mengingat (9), solusi umum memiliki bentuk: <br><br><img src="https://habrastorage.org/webt/8w/dk/av/8wdkavmydgbm1e94gfcjnm_kavm.png">  (10) <br><br>  Solusi ini memberikan urutan ke lima akurasi, tetap menyesuaikannya dengan Python. <br><br><h4>  Percobaan komputasi untuk menentukan kesalahan absolut dari solusi numerik dari persamaan diferensial nonlinear <img src="https://habrastorage.org/webt/ws/sh/r4/wsshr4edsklounxpocg4hd_mf70.png">  menggunakan kedua fungsi def odein (), def oden () dari modul scipy.integrate dan metode Runge - Kutta dan Runge - Kutta - Felberg diadaptasi ke Python </h4><br><br><div class="spoiler">  <b class="spoiler_title">Daftar program</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.integrate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odein</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#dy1/dt=y2 #dy2/dt=y1**2+1: def f(y,t): return y**2+1 t =arange(0,1,0.01) y0 =0.0 y=odeint(f, y0,t) y = array(y).flatten() return y,t def oden(): f = lambda t, y: y**2+1 ODE=ode(f) ODE.set_integrator('dopri5') ODE.set_initial_value(0, 0) t=arange(0,1,0.01) z=[] t=arange(0,1,0.01) for i in arange(0,1,0.01): ODE.integrate(i) q=ODE.y z.append(q[0]) return z,t def rungeKutta(f, to, yo, tEnd, tau): def increment(f, t, y, tau): if z==1: k0 =tau* f(t,y) k1 =tau* f(t+tau/2.,y+k0/2.) k2 =tau* f(t+tau/2.,y+k1/2.) k3 =tau* f(t+tau, y + k2) return (k0 + 2.*k1 + 2.*k2 + k3) / 6. elif z==0: k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = [] y= [] t.append(to) y.append(yo) while to &lt; tEnd: tau = min(tau, tEnd - to) yo = yo + increment(f, to, yo, tau) to = to + tau t.append(to) y.append(yo) return array(t), array(y) def f(t, y): f = zeros([1]) f[0] = y[0]**2+1 return f to = 0. tEnd = 1 yo = array([0.]) tau = 0.01 z=1 t, yn = rungeKutta(f, to, yo, tEnd, tau) y1n=[i[0] for i in yn] plt.figure() plt.title("   (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") plt.plot(t,abs(array(y1n)-array(tan(t))),label=' — \n\   -   ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) z=0 t, ym = rungeKutta(f, to, yo, tEnd, tau) y1m=[i[0] for i in ym] plt.figure() plt.title("   (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") plt.plot(t,abs(array(y1m)-array(tan(t))),label=' ——  \n\   -   ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.figure() plt.title("    (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") y,t=odein() plt.plot(t,abs(array(tan(t))-array(y)),label=' odein') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.figure() plt.title("    (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") z,t=oden() plt.plot(t,abs(tan(t)-z),label=' ode  ——  \n\  ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.show()</span></span></code> </pre> <br></div></div><br>  Kami mendapatkan: <br><br><img src="https://habrastorage.org/webt/rb/l6/-2/rbl6-2ookhhbihd9xnftqqknrc4.png"><br><br><img src="https://habrastorage.org/webt/od/pn/mp/odpnmp3qsgjttpzjikbu4ry34bk.png"><br><br><img src="https://habrastorage.org/webt/nt/vw/dv/ntvwdvd0hnwbgnfdgoox71in9pk.png"><br><br><img src="https://habrastorage.org/webt/-a/gl/os/-agloshtg1bvovezwdjex4ri2ac.png"><br><br>  <b>Kesimpulan:</b> <br><br>  Metode Python-adapted Runge - Kutta dan Runge - Kutta - Felberg memiliki absolut yang lebih rendah daripada solusi menggunakan fungsi odeint, tetapi lebih dari solusi menggunakan fungsi edu.  Perlu untuk melakukan studi kinerja. <br><br><h4>  Eksperimen numerik yang membandingkan kecepatan solusi numerik SDE menggunakan fungsi ode dengan atribut dopri5 (metode Runge - Kutta orde 5) dan menggunakan metode Runge - Kutta - Felberg yang disesuaikan dengan Python </h4><br><br>  Analisis komparatif dilakukan dengan menggunakan masalah model yang diberikan dalam [2] sebagai contoh.  Agar tidak mengulangi sumbernya, saya akan menyajikan formulasi dan solusi dari masalah model dari [2]. <br><br>  Mari kita selesaikan masalah Cauchy, yang menggambarkan gerakan benda yang dilemparkan dengan kecepatan awal v0 pada sudut α ke cakrawala dengan asumsi bahwa hambatan udara sebanding dengan kuadrat kecepatan.  Dalam bentuk vektor, persamaan gerak memiliki bentuk <br><br><img src="https://habrastorage.org/webt/2a/9w/f5/2a9wf5a2_ckuhlu2mypbya1euow.png"><br><br>  dimana <img src="https://habrastorage.org/webt/zi/gy/z5/zigyz50cgbqvfeos6rozby0xais.png">  Adalah jari-jari vektor tubuh yang bergerak, <img src="https://habrastorage.org/webt/v_/7w/rm/v_7wrmvexfdj_3j7kfyobvy0omi.png">  Apakah vektor kecepatan tubuh, <img src="https://habrastorage.org/webt/_-/jq/rq/_-jqrqt-dvbznpe_4l8htdsfybw.png">  - koefisien seret, vektor <img src="https://habrastorage.org/webt/px/au/zt/pxauztg_p8ldqkk3vuuzxgkzzhe.png">  kekuatan berat badan massa m, g - percepatan gravitasi. <br><br><img src="https://habrastorage.org/webt/ux/fy/xy/uxfyxyowu7xnhy-fvigwoeh436m.png"><br><br>  Keunikan dari tugas ini adalah bahwa gerakan berakhir pada titik yang sebelumnya tidak diketahui saat tubuh jatuh ke tanah.  Jika ditunjuk <img src="https://habrastorage.org/webt/ud/6h/hh/ud6hhhzd7lyf71noe8hpdlyrexi.png">  , maka dalam bentuk koordinat kami memiliki sistem persamaan: <br><br><img src="https://habrastorage.org/webt/jh/dd/rr/jhddrrguuy07d9hw9x5gvcylo2u.png"><br><br>  Kondisi awal harus ditambahkan ke sistem: <img src="https://habrastorage.org/webt/tr/de/l-/trdel-vxwgw3oy1ryv0k1nafch0.png">  (h ketinggian awal) <img src="https://habrastorage.org/webt/-g/zd/ft/-gzdft1d38m6x4f6vryof4jlwuu.png">  .  Taruh <img src="https://habrastorage.org/webt/l0/1r/cm/l01rcm17euagfjzj8gcet4xfhge.png">  .  Kemudian sistem ODE urutan pertama yang sesuai mengambil bentuk: <br><br><img src="https://habrastorage.org/webt/nh/zg/r5/nhzgr5att8_fao3l-majsjgcm7k.png"><br><br>  Untuk masalah model yang kami masukkan <img src="https://habrastorage.org/webt/2s/20/ov/2s20ovmvcahufaxyhihjev7rm8g.png">  .  Mengabaikan deskripsi yang agak luas dari program ini, saya hanya akan memberikan daftar dari komentar yang, saya pikir, prinsip operasinya akan menjadi jelas.  Program ini telah menambahkan hitungan mundur untuk analisis komparatif. <br><br><div class="spoiler">  <b class="spoiler_title">Daftar program</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time start = time.time() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.integrate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ode ts = [ ] ys = [ ] FlightTime, Distance, Height =<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> y4old=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, y)</span></span></span><span class="hljs-function">:</span></span><span class="hljs-comment"><span class="hljs-comment">#   global FlightTime, Distance, Height,y4old ts.append(t) ys.append(list(y.copy())) y1, y2, y3, y4 = y if y4*y4old&lt;=0: #    Height=y3 if y4&lt;0 and y3&lt;=0.0: #    FlightTime=t Distance=y1 return -1 y4old=y4 #      def f(t, y, k): #    k g=9.81 y1, y2, y3, y4 = y return [y2,-k*y2*np.sqrt(y2**2+y4**2), y4,-k*y4*np.sqrt(y2**2+y4**2)-g] tmax=1.41 #     alph=np.pi/4 #    v0=10.0 #   K=[0.1,0.2,0.3,0.5] #    y0,t0=[0, v0*np.cos(alph), 0, v0*np.sin(alph)], 0 #   ODE=ode(f) ODE.set_integrator('dopri5', max_step=0.01) ODE.set_solout(fout) fig, ax = plt.subplots() fig.set_facecolor('white') for k in K: #     ts, ys = [ ],[ ] ODE.set_initial_value(y0, t0) #    ODE.set_f_params(k) #    k #   f(t,y,k)     ODE.integrate(tmax) #   print('Flight time = %.4f Distance = %.4f Height =%.4f '% (FlightTime,Distance,Height)) Y=np.array(ys) plt.plot(Y[:,0],Y[:,2],linewidth=3,label='k=%.1f'% k) stop = time.time() plt.title("      \n    ode   dopri5 ") print ("   : %f"%(stop-start)) plt.grid(True) plt.xlim(0,8) plt.ylim(-0.1,2) plt.legend(loc='best') plt.show()</span></span></code> </pre> <br></div></div><br><br>  Kami mendapatkan: <br><br>  Waktu penerbangan = 1.2316 Jarak = 5.9829 Tinggi = 1.8542 <br>  Waktu penerbangan = 1.1016 Jarak = 4.3830 Tinggi = 1.5088 <br>  Waktu penerbangan = 1.0197 Jarak = 3.5265 Tinggi = 1.2912 <br>  Waktu penerbangan = 0.9068 Jarak = 2.5842 Tinggi = 1.0240 <br>  Waktu untuk masalah model: 0.454787 <br><br><img src="https://habrastorage.org/webt/z5/u5/xc/z5u5xc04tbd-_2idovqqosevlwi.png"><br><br>  Untuk mengimplementasikan solusi numerik CDS menggunakan alat Python tanpa menggunakan modul khusus, saya mengusulkan dan menyelidiki fungsi berikut: <br><br> <code>def increment(f, t, y, tau <br> k1=tau*f(t,y) <br> k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) <br> k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) <br> k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) <br> k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) <br> k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) <br> return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6</code> <br> <br>  Fungsi kenaikan (f, t, y, tau) menyediakan urutan kelima dari metode solusi numerik.  Fitur lain dari program ini dapat ditemukan dalam daftar berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Daftar program</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time start = time.time() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rungeKutta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, to, yo, tEnd, tau)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, t, y, tau)</span></span></span><span class="hljs-function">:</span></span><span class="hljs-comment"><span class="hljs-comment">#     ——. k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = []#   t y= []#   y t.append(to)#   t   to y.append(yo)#   y   yo while to &lt; tEnd:#     t,y tau = min(tau, tEnd - to)#   tau yo = yo + increment(f, to, yo, tau) #     t0,y0    to = to + tau #   t.append(to) #   t y.append(yo) #   y return array(t), array(y) def f(t, y): #      f = zeros([4]) f[0]=y[1] f[1]=-k*y[1]*sqrt(y[1]**2+y[3]**2) f[2]=y[3] f[3]=-k*y[3]*sqrt(y[1]**2+y[3]**2) -g if y[3]&lt;0 and y[2]&lt;=0.0: #    return -1 return f to = 0#     tEnd = 1.41#     alph=pi/4#    v0=10.0 #   K=[0.1,0.2,0.3,0.5]#     g=9.81 yo = array([0.,v0*cos(alph),0.,v0*sin(alph)]) #   tau =0.01#  for i in K: #      k=i t, y = rungeKutta(f, to, yo, tEnd, tau) y1=array([i[0] for i in y]) #     y y3=array([i[2] for i in y]) #    ""     s,h,t plt.plot(y1,y3,linewidth=2,label='k=%.1f h=%.3f s=%.2f t=%s' % (k,max(y3),max(y1),round(t[list(y1).index(max(y1))],3))) stop = time.time() plt.title("      \n     Python\n  —— ") print ("   : %f"%(stop-start)) plt.xlabel(' h') plt.ylabel(' s') plt.legend(loc='best') plt.xlim(0,8) plt.ylim(-0.1,2) plt.grid(True) plt.show()</span></span></code> </pre> <br></div></div><br>  Kami mendapatkan: <br><br>  Waktu untuk masalah model: 0.259927 <br><br><img src="https://habrastorage.org/webt/_i/c1/ta/_ic1ta5623kjqb1qazfpt3ut1ns.png"><br><br>  <b>Kesimpulan</b> <br><br>  Implementasi perangkat lunak yang diusulkan untuk masalah model tanpa menggunakan modul khusus memiliki kinerja hampir dua kali lebih cepat daripada dengan fungsi ode, tetapi kita tidak boleh lupa bahwa ode memiliki akurasi yang lebih tinggi dari solusi numerik dan kemungkinan memilih metode solusi. <br><br><h3>  Memecahkan masalah nilai batas dengan kondisi batas yang dipisahkan benang </h3><br>  Kami memberikan contoh masalah nilai batas tertentu dengan kondisi batas yang dipisahkan utas: <br><br><img src="https://habrastorage.org/webt/i4/x0/jt/i4x0jtfxfy57053vvu31tpyyvo4.png">  (11) <br><br>  Untuk mengatasi masalah (11), kami menggunakan algoritma berikut: <br><br>  1. Kami menyelesaikan tiga persamaan sistem homogen (11) yang pertama dengan kondisi awal <br><img src="https://habrastorage.org/webt/0w/b-/qj/0wb-qjfvaodszu5xyov9mqgddmi.png"><br>  Kami memperkenalkan notasi untuk menyelesaikan masalah Cauchy: <br><img src="https://habrastorage.org/webt/h1/am/zo/h1amzogvuzkyz3a6wpp95gd9rua.png"><br><br>  2. Kami menyelesaikan tiga persamaan homogen sistem pertama (11) dengan kondisi awal <br><img src="https://habrastorage.org/webt/ia/d6/yn/iad6ynerbilksk3kcjwudksg4ta.png"><br>  Kami memperkenalkan notasi untuk menyelesaikan masalah Cauchy: <br><img src="https://habrastorage.org/webt/3t/ib/ze/3tibzeyvnv-bsodoaivbfnycscc.png"><br><br>  3. Kami menyelesaikan tiga persamaan homogen sistem pertama (11) dengan kondisi awal <br><br><img src="https://habrastorage.org/webt/rl/vd/pc/rlvdpcnayrhhfasr9s4jpjpffja.png"><br><br>  Kami memperkenalkan notasi untuk menyelesaikan masalah Cauchy: <br><br><img src="https://habrastorage.org/webt/pq/dl/os/pqdlosn5xi7yxhoeg0yafuybtdy.png"><br><br>  4. Solusi umum masalah nilai batas (11) menggunakan solusi masalah Cauchy ditulis sebagai kombinasi linear dari solusi: <br><img src="https://habrastorage.org/webt/8n/_t/17/8n_t1751ck0jmg6oiv3cgaluskm.png"><br>  di mana p2, p3 adalah beberapa parameter yang tidak diketahui. <br><br>  5. Untuk menentukan parameter p2, p3, kami menggunakan kondisi batas dari dua persamaan terakhir (11), yaitu kondisi untuk x = b.  Mengganti, kita memperoleh sistem persamaan linear sehubungan dengan p2, p3 yang tidak diketahui: <br><img src="https://habrastorage.org/webt/0_/xe/_p/0_xe_pgiynf0ufquqah-k7llh18.png">  (12) <br>  Memecahkan (12), kita memperoleh relasi untuk p2, p3. <br><br>  Menggunakan algoritma di atas menggunakan metode Runge - Kutta - Felberg, kami mendapatkan program berikut: <br><br><div class="spoiler">  <b class="spoiler_title">Daftar program</b> <div class="spoiler_text"><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#   from numpy import* import matplotlib.pyplot as plt import matplotlib.font_manager as fm,os import matplotlib.patches as mpatches import matplotlib.lines as mlines from scipy.integrate import odeint from scipy import linalg import time start = time.time() c1 = 1.0 c2 = 0.8 c3 = 0.5 a =0.0 b = 1.0 nn =100 initial_state_0 =array( [a, c1, 0.0, 0.0]) initial_state_I =array( [a, 0.0, 1.0, 0.0]) initial_state_II =array( [a, 0.0, 0.0, 1.0]) to = a tEnd =b N = int(nn) tau=(ba)/N def rungeKutta(f, to, yo, tEnd, tau): def increment(f, t, y, tau): k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = [] y= [] t.append(to) y.append(yo) while to &lt; tEnd: tau = min(tau, tEnd - to) yo = yo + increment(f, to, yo, tau) to = to + tau t.append(to) y.append(yo) return array(t), array(y) def f(t, y): global theta f = zeros([4]) f[0] = 1 f[1] = -y [1]-y[2] +theta* sin(y[0]) f[2] = -y[2]+y[3] f[3] = -y[2] return f #    -- theta = 1 theta = 1.0 yo =initial_state_0 t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y20 = Y2(b), Y30 = Y3(b) Y20 = y2[N-1] Y30 = y3[N-1] #    -- theta = 0,  I theta = 0.0 yo= initial_state_I t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y21= Y2(b), Y31 = Y3(b) Y21= y2[N-1] Y31 = y3[N-1] #    -- theta = 0,  II theta = 0.0 yo =initial_state_II t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y211= Y2(b), Y311 = Y3(b) Y211= y2[N-1] Y311 = y3[N-1] #    #     p2, p3 b1 = c2 - Y20 b2 = c3 - Y30 A = array([[Y21, Y211], [Y31, Y311]]) bb = array([[b1], [b2]]) #   p2, p3 = linalg.solve(A, bb) #    #  , theta = 1 theta = 1.0 yo = array([a, c1, p2, p3]) t, y = rungeKutta(f, to, yo, tEnd, tau) y0=[i[0] for i in y] y1=[i[1] for i in y] y2=[i[2] for i in y] y3=[i[3] for i in y] #  print('y0[0]=', y0[0]) print('y1[0]=', y1[0]) print('y2[0]=', y2[0]) print('y3[0]=', y3[0]) print('y0[N-1]=', y0[N-1]) print('y1[N-1]=', y1[N-1]) print('y2[N-1]=', y2[N-1]) print('y3[N-1]=', y3[N-1]) j = N xx = y0[:j] yy1 = y1[:j] yy2 = y2[:j] yy3 = y3[:j] stop = time.time() print ("   : %f"%(stop-start)) plt.subplot(2, 1, 1) plt.plot([a], [c1], 'ro') plt.plot([b], [c2], 'go') plt.plot([b], [c3], 'bo') plt.plot(xx, yy1, color='r') #  plt.plot(xx, yy2, color='g') #  plt.plot(xx, yy3, color='b') #  plt.xlabel(r'$x$') #   x   TeX plt.ylabel(r'$y_k(x)$') #   y   TeX plt.title(r'  ', color='blue') plt.grid(True) # patch_y1 = mpatches.Patch(color='red', label='$y_1$') patch_y2 = mpatches.Patch(color='green', label='$y_2$') patch_y3 = mpatches.Patch(color='blue', label='$y_3$') plt.legend(handles=[patch_y1, patch_y2, patch_y3]) ymin, ymax = plt.ylim() xmin, xmax = plt.xlim() plt.subplot(2, 1, 2) font = {'family': 'serif', 'color': 'blue', 'weight': 'normal', 'size': 12, } plt.text(0.2, 0.8, r'$\frac{dy_1}{dx}= - y_1 - y_2 + \sin(x),$', fontdict=font) plt.text(0.2, 0.6,r'$\frac{dy_2}{dx}= - y_1 + y_3,$', fontdict=font) plt.text(0.2, 0.4, r'$\frac{dy_3}{dx}= - y_2 - y_2,$', fontdict=font) plt.text(0.2, 0.2, r'$y_1(a)=c_1, ' r'\quad y_2(b)=c_2, \quad y_3(b)=c_3.$', fontdict=font) plt.subplots_adjust(left=0.15) plt.show()</span></span></code> </pre><br></div></div><br>  Kami mendapatkan: <br><br>  y0 [0] = 0,0 <br>  y1 [0] = 1.0 <br>  y2 [0] = 0.7156448588231397 <br>  y3 [0] = 1.324566562303714 <br>  y0 [N-1] = 0.9900000000000007 <br>  y1 [N-1] = 0.1747719838716767 <br>  y2 [N-1] = 0,8 <br>  y3 [N-1] = 0,5000000000000001 <br>  Waktu untuk masalah model: 0,070878 <br><br><img src="https://habrastorage.org/webt/kj/g1/0c/kjg10co-rqc-pwbedzo56s4b3wy.png"><br><br><h3>  Kesimpulan </h3><br><br>  Program yang dikembangkan oleh saya berbeda dari kesalahan yang diberikan pada [3], yang mengkonfirmasi analisis komparatif dari fungsi odeint yang diberikan pada awal artikel dengan metode Runge - Kutta - Felberg diimplementasikan dalam Python. <br><br>  Referensi: <br><br>  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi numerik dari model matematika objek yang didefinisikan oleh sistem komposit persamaan diferensial.</a> <br><br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengantar Python ilmiah.</a> <br><br>  3. N.M.  Polyakova, E.V.  Shiryaeva Python 3. Membuat antarmuka pengguna grafis (menggunakan contoh penyelesaian masalah nilai batas untuk persamaan diferensial biasa linear dengan metode pemotretan).  Rostov-on-Don 2017. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418139/">https://habr.com/ru/post/id418139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418127/index.html">Kebenaran dan kepalsuan sistem pengenalan wajah</a></li>
<li><a href="../id418131/index.html">Pemrograman Lintas-Cloud dengan Go Cloud</a></li>
<li><a href="../id418133/index.html">Untuk membela PLO. 7 argumen yang tidak bisa dipertahankan dari lawan-lawannya</a></li>
<li><a href="../id418135/index.html">Cara mengatur repositori modul Node.js Anda sendiri dengan blackjack dan versi</a></li>
<li><a href="../id418137/index.html">Bloodlust: Wawancara dengan Pendiri DonorSearch</a></li>
<li><a href="../id418141/index.html">RE: Ghat / AFR Race Skipper Pemula</a></li>
<li><a href="../id418143/index.html">PVS-Studio sebagai solusi SAST</a></li>
<li><a href="../id418145/index.html">Gugatan pertama terhadap Roskomnadzor dari sebuah perusahaan yang menderita ketika Telegram diblokir</a></li>
<li><a href="../id418147/index.html">Silence of Ruby Executions: Transactional Rails / PostgreSQL Thriller</a></li>
<li><a href="../id418149/index.html">Phishing dengan tag judul</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>