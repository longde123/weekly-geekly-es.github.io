<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏍️ 🍡 💔 Juta panggilan video per hari atau "Hubungi ibu!" 👅 🤘🏾 💇🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari sudut pandang pengguna, layanan panggilan terlihat cukup sederhana: Anda pergi ke halaman ke pengguna lain, Anda menelepon, dia mengangkat telepo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Juta panggilan video per hari atau "Hubungi ibu!"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/428217/">  Dari sudut pandang pengguna, layanan panggilan terlihat cukup sederhana: Anda pergi ke halaman ke pengguna lain, Anda menelepon, dia mengangkat telepon, Anda berbicara dengannya.  Di luar sepertinya semuanya sederhana, tetapi sedikit yang tahu bagaimana membuat layanan seperti itu.  Namun Alexander Tobol ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">alatobol</a> ) tidak hanya tahu, tetapi juga rela berbagi pengalamannya. <br><br><img src="https://habrastorage.org/webt/rq/un/cx/rquncxhtqvyydpdbneoatkwfvke.jpeg"><br><br>  Selanjutnya versi teks laporan tentang HighLoad ++ Siberia, dari mana Anda akan belajar: <br><br><ul><li>  bagaimana layanan panggilan video bekerja di bawah tenda; </li><li>  betapa indahnya menembus NAT - ini akan menarik bagi spesialis game yang membutuhkan koneksi peer-to-peer; </li><li>  bagaimana WebRTC bekerja, protokol apa yang termasuk di dalamnya; </li><li>  bagaimana saya bisa menyetel WebRTC melalui BigData. </li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MnEXuKHjIOU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Alexander Tobol memimpin pengembangan platform Video dan Tape di ok.ru. <br><a name="habracut"></a><br><h2>  Riwayat panggilan video <br></h2><br>  Perangkat pertama untuk panggilan video muncul pada tahun 1960, itu disebut picherphone, menggunakan jaringan khusus dan sangat mahal.  Pada tahun 2006, Skype menambahkan panggilan video ke aplikasinya.  Pada 2010, Flash mendukung protokol RTMFP, dan kami di Odnoklassniki meluncurkan panggilan video Flash.  Pada 2016, Chrome berhenti mendukung Flash, dan pada Agustus 2017 kami memulai kembali panggilan dengan teknologi baru, yang akan saya bicarakan hari ini.  Setelah menyelesaikan layanan, selama enam bulan kami menerima peningkatan yang signifikan dalam panggilan yang berhasil diselesaikan.  Baru-baru ini, kami juga memiliki topeng dalam panggilan. <br><img src="https://habrastorage.org/webt/kn/9u/uy/kn9uuyg18yggcfabvmzgs-cfygg.jpeg"><br><br><h2>  Arsitektur dan TK <br></h2><br>  Karena kami bekerja di jejaring sosial, kami tidak memiliki tugas teknis, dan kami tidak tahu apa itu TK.  Biasanya seluruh ide cocok pada satu halaman dan terlihat seperti ini. <br><img src="https://habrastorage.org/webt/qf/9x/ju/qf9xjum4vvjczd3-momvzhht9cw.jpeg"><br><br>  Pengguna ingin memanggil pengguna lain menggunakan web atau aplikasi iOS / Android.  Pengguna lain mungkin memiliki beberapa perangkat.  Panggilan datang ke semua perangkat, pengguna mengangkat telepon pada salah satu dari mereka, mereka berbicara.  Semuanya sederhana. <br><br><h2>  Spesifikasi teknis <br></h2><br>  Untuk membuat layanan panggilan yang berkualitas, kita perlu memahami karakteristik apa yang ingin kita lacak.  Kami memutuskan untuk memulai dengan mencari apa yang paling mengganggu pengguna. <br><br>  Pengguna pasti kesal jika dia mengangkat telepon dan dipaksa untuk menunggu sampai sambungan dibuat. <br><img src="https://habrastorage.org/webt/8g/kk/qb/8gkkqbq6ioqxnn0ro6dcq9kwhno.jpeg"><br><br>  Pengguna terganggu jika kualitas panggilan buruk - ada yang terganggu, video tersebar, suaranya menggelegak. <br><img src="https://habrastorage.org/webt/2l/rt/ud/2lrtudpp-tw5cjsknhzamgj--pi.jpeg"><br><br>  Tetapi sebagian besar dari semua pengguna terganggu oleh keterlambatan panggilan.  Latensi adalah salah satu karakteristik penting panggilan.  Dengan latensi dalam percakapan dalam urutan 5 detik, sama sekali tidak mungkin untuk melakukan dialog. <br><img src="https://habrastorage.org/webt/z-/tn/lf/z-tnlfghw6laz3j25e3kbwob9mi.jpeg"><br><br>  Kami telah menentukan sendiri karakteristik yang dapat diterima: <br><br><ul><li>  <strong>Mulai</strong> - kami memutuskan bahwa baik untuk memulai panggilan dalam sedetik.  Yaitu  menghubungkan setelah pengguna menjawab, harus tidak lebih dari 1 detik. </li><li>  <strong>Kualitas</strong> adalah indikator yang sangat subyektif.  Anda dapat mengukur, misalnya, rasio signal-to-noise (SNR), tetapi masih ada bingkai yang hilang dan artefak lainnya.  Kami mengukur kualitas secara subyektif dan kemudian mengevaluasi kebahagiaan pengguna. </li><li>  <strong>Latensi</strong> harus kurang dari 0,5 detik.  Jika Latency lebih dari 0,5 detik, maka Anda sudah mendengar penundaan dan mulai saling mengganggu. </li></ul><br><img src="https://habrastorage.org/webt/cl/yx/j0/clyxj0ajsqq5coamt5orttz-kxc.jpeg"><br><br>  Polycom adalah sistem konferensi yang dipasang di kantor kami.  Kami memiliki latensi rata-rata polycom dalam urutan 1,3 detik.  Dengan penundaan seperti itu, Anda tidak selalu saling memahami.  Jika penundaan meningkat menjadi 2 detik, maka dialog tidak akan mungkin. <br><img src="https://habrastorage.org/webt/3_/yy/qq/3_yyqqbvvq5zoavfa5q9tzvqhiq.jpeg"><br><br>  Karena kami telah meluncurkan platform, kami memperkirakan bahwa kami akan memiliki sejuta panggilan per hari.  Ini seribu panggilan secara paralel.  Jika semua panggilan diluncurkan melalui server, akan ada seribu panggilan megabit per panggilan.  Ini hanya 1 gigabit / detik satu server besi sudah cukup. <br><br><h2>  Internet vs TTX <br></h2><br>  Apa yang bisa mencegah Anda mencapai fitur-fitur keren seperti itu?  Internet! <br><img src="https://habrastorage.org/webt/qb/aq/sy/qbaqsyfaf6vln4e882armfugx1g.jpeg"><br><br>  Di Internet, ada hal-hal seperti round-trip time (RTT), yang tidak bisa diatasi, ada bandwidth variabel, ada NAT. <br><br>  Sebelumnya, kami mengukur kecepatan transmisi di jaringan pengguna kami. <br><img src="https://habrastorage.org/webt/bm/ge/z6/bmgez6efih7z_lqwidcknso8edw.jpeg"><br><br>  Kami memecahnya berdasarkan jenis koneksi, melihat RTT rata-rata, kehilangan paket, kecepatan, dan memutuskan bahwa kami akan menguji panggilan pada nilai rata-rata dari masing-masing jaringan ini. <br><img src="https://habrastorage.org/webt/ui/o4/k8/uio4k8pmxmyxyclfwwawehqijes.jpeg"><br><br>  Ada masalah lain di Internet: <br><br><ul><li>  <strong>Paket hilang</strong> - kami mengukur 0,6% kehilangan paket acak (kami tidak memperhitungkan kehilangan paket kemacetan akun dengan jumlah paket yang berlebihan). </li><li>  <strong>Pengubahan</strong> urutan - Anda mengirim paket dalam urutan yang sama, dan jaringan mengurutkannya kembali. </li><li>  <strong>Jitter</strong> - mengirim aliran video atau audio pada interval tertentu, dan paket-paket berkumpul di sisi klien dalam bundel, misalnya, karena buffering pada perangkat jaringan. </li><li>  <strong>NAT</strong> - ternyata lebih dari 97% pengguna berada di belakang NAT.  Kami akan berbicara tentang mengapa, apa dan bagaimana. </li></ul><br><img src="https://habrastorage.org/webt/z_/uo/mc/z_uomck64smc12_beaupdnutgp4.jpeg"><br><br>  Pertimbangkan pengaturan jaringan yang tercantum di atas dengan contoh sederhana. <br><br>  Saya membuka situs web Universitas Negeri Novosibirsk dari kantor saya dan mendapat ping yang aneh. <br><img src="https://habrastorage.org/webt/wi/am/at/wiamatloo1eviw58g3zgzbrsc2e.jpeg"><br><br>  Jitter rata-rata dalam contoh ini adalah 30 ms, yaitu, interval rata-rata antara waktu ping yang berdekatan adalah sekitar 30 ms, dan ping rata-rata adalah 105 ms. <br><br>  Yang penting dalam panggilan, mengapa kita berjuang untuk p2p? <br><img src="https://habrastorage.org/webt/gb/ny/yx/gbnyyxij20hrfo96scwubxdzovu.jpeg"><br><br>  Jelas, jika kami berhasil membuat koneksi p2p antara pengguna kami yang mencoba berbicara satu sama lain di St. Petersburg, dan tidak melalui server yang berlokasi di Novosibirsk, kami akan menghemat sekitar 100 ms pulang pergi dan lalu lintas ke layanan ini. <br><br>  Karena itu, sebagian besar artikel dikhususkan untuk bagaimana membuat p2p yang baik. <br><br><h2>  Sejarah atau warisan <br></h2><br>  Seperti yang saya katakan, kami telah memiliki layanan panggilan sejak 2010, dan sekarang kami telah memulainya kembali. <br><img src="https://habrastorage.org/webt/si/ru/lu/sirulur_jaalnldpkmvbjx7ct-q.jpeg"><br><br>  Pada 2006, ketika Skype mulai, Flash membeli Amicima, yang menghasilkan RTMFP.  Flash sudah memiliki RTMP, yang pada prinsipnya dapat digunakan untuk panggilan, dan itu sering digunakan untuk streaming.  Flash kemudian membuka spesifikasi RTMP.  Saya heran mengapa mereka membutuhkan RTMFP?  Pada 2010, kami menggunakan RTMFP. <br><br>  Bandingkan persyaratan untuk protokol panggilan dan protokol streaming nyata dan lihat di mana perbatasan ini. <br><img src="https://habrastorage.org/webt/ih/j9/xi/ihj9xiris6praclbyxpxelwc1i4.jpeg"><br><br>  <strong>RTMP</strong> lebih merupakan protokol streaming video.  Menggunakan TCP, memiliki penundaan kumulatif.  Jika Anda memiliki koneksi internet yang baik, panggilan ke RTMP akan berfungsi. <br><br>  <strong>Protokol RTMFP</strong> , meskipun berbeda hanya dalam satu huruf, adalah protokol UDP.  Ini bebas dari masalah buffering - yang ada di TCP;  Ini dihilangkan dari pemblokiran head-of-line - ini adalah ketika Anda kehilangan satu paket, dan TCP tidak mengembalikan paket-paket berikut sampai tiba waktunya untuk mengirim ulang paket yang hilang.  RTMFP mampu menangani NAT dan mengalami perubahan dalam alamat IP klien.  Karena itu, kami meluncurkan web di RTMFP pada 2010. <br><img src="https://habrastorage.org/webt/pv/rx/16/pvrx163tvieetirsg8nkfrov7qm.jpeg"><br><br>  Kemudian hanya pada tahun 2011 muncul konsep awal WebRTC, yang belum sepenuhnya operasional.  Pada 2012, kami mulai mendukung panggilan di iOS / Android, kemudian sesuatu yang lain terjadi, dan pada 2016 Chrome berhenti mendukung Flash.  Kami harus melakukan sesuatu. <br><img src="https://habrastorage.org/webt/uu/ub/cs/uuubcssxa_w9-ost03_y6dqq6ic.jpeg"><br><br>  Kami melihat semua protokol VoIP: seperti biasa, untuk melakukan sesuatu, kami mulai dengan melihat pesaing. <br><br><h2>  Pesaing atau mulai dari mana <br></h2><br>  Kami memilih pesaing paling populer: Skype, WhatsApp, Google Duo (mirip dengan Hangouts) dan ICQ. <br><br>  Untuk mulai dengan, kami mengukur penundaan. <br><img src="https://habrastorage.org/webt/yv/br/d2/yvbrd2tluf9yzf-xqqibngdooh8.jpeg"><br><br>  Itu mudah dilakukan.  Di atas adalah foto di mana: <br><br><ul><li>  Stopwatch (lihat telepon di kiri atas), yang menunjukkan waktu (03:08). </li><li>  Telepon terdekat melakukan panggilan dan mengambil telepon pertama sebagai video.  Dari saat gambar masuk ke kamera ponsel, dan Anda melihatnya, butuh sekitar 100 ms. </li><li>  Panggilan ke telepon lain (putih) dan sekali lagi.  Di sini penundaannya sekitar 310 ms dengan Google Duo. </li></ul><br>  Saya belum akan mengungkapkan semua kartu, tetapi kami memastikan bahwa perangkat ini tidak dapat membuat koneksi P2P.  Tentu saja, pengukuran dilakukan di jaringan yang berbeda, dan ini hanyalah sebuah contoh. <br><img src="https://habrastorage.org/webt/rn/xz/ee/rnxzee4grukafmg0gu3cunpemsi.jpeg"><br><br>  Skype masih sedikit menyela.  Ternyata dengan Skype, jika gagal menghubungkan p2p, penundaannya adalah 1,1 detik. <br><br>  Lingkungan pengujian kami rumit.  Kami menguji dalam kondisi yang berbeda (EDGE, 3G, LTE, WiFi), memperhitungkan bahwa salurannya asimetris, dan saya memberikan nilai rata-rata dari semua pengukuran. <br><img src="https://habrastorage.org/webt/gb/pp/6s/gbpp6sc5jugssoov8nmzvajlifo.jpeg"><br><br>  Untuk memperkirakan konsumsi baterai, beban prosesor, dan yang lainnya, kami memutuskan bahwa Anda cukup mengukur suhu ponsel dengan pirometer dan berasumsi bahwa ini adalah beban rata-rata pada GPU ponsel per prosesor, baterai.  Pada prinsipnya, sangat tidak menyenangkan untuk membawa telepon panas ke telinga Anda, dan bahkan memegangnya di tangan Anda.  Tampaknya bagi pengguna bahwa sekarang aplikasi akan menghabiskan seluruh baterainya. <br><img src="https://habrastorage.org/webt/dl/ck/vd/dlckvdbr8we75haadv9qkgk1jxk.jpeg"><br><br>  Hasilnya adalah: <br><br><ul><li>  Yang paling lambat <strong>dalam penundaan</strong> itu adalah ICQ dan Skype, dan yang tercepat - Telegram.  Ini bukan perbandingan yang sepenuhnya benar, karena Telegram tidak memiliki panggilan video, tetapi mereka memiliki latensi minimal dalam audio.  WhatsApp (sekitar 200 ms) dan Hangouts - 390 ms berfungsi dengan baik. </li><li>  <strong>Berdasarkan suhu,</strong> Telegram makan paling sedikit tanpa video, dan Skype paling banyak. </li><li>  Dalam hal waktu <strong>respons</strong> , Telegram membangun koneksi <strong>untuk</strong> waktu yang lama, dan WhatsApp dan Google Duo tercepat. </li></ul><br>  Hebat, kami mendapat beberapa metrik! <br><img src="https://habrastorage.org/webt/t8/mb/n0/t8mbn0vv_g1utslspeeevk8g5ie.jpeg"><br><br>  Kami menguji kualitas video dan suara di jaringan yang berbeda, dengan tetesan yang berbeda dan yang lainnya.  Sebagai hasilnya, kami sampai pada kesimpulan bahwa <strong>video kualitas tertinggi adalah di Google Duo, dan suara ada di Skype</strong> , tetapi ini ada di jaringan "buruk" ketika sudah ada distorsi.  Secara umum, setiap orang bekerja kurang lebih biasa-biasa saja.  WhatsApp memiliki gambar yang paling kabur. <br><br>  Mari kita lihat apa yang sudah diimplementasikan. <br><img src="https://habrastorage.org/webt/ih/ap/1i/ihap1infndlvdjllso8eszhjnla.jpeg"><br><br>  Skype memiliki protokol miliknya sendiri, dan semua orang menggunakan modifikasi WebRTC, atau umumnya WebRTC secara langsung.  Hangouts, Google Duo, WhatsApp, Facebook Messenger dapat bekerja dengan web, dan mereka semua memiliki WebRTC di bawah tenda.  Mereka semua sangat berbeda, dengan karakteristik yang berbeda, dan mereka semua memiliki satu WebRTC!  Jadi, Anda harus bisa memasaknya dengan benar.  Plus ada Telegram, yang beberapa bagian WebRTC bertanggung jawab untuk bagian audio, ada ICQ, yang bercabang dengan WebRTC untuk waktu yang lama dan terus mengembangkan caranya sendiri. <br><br><h2>  WebRTC  Arsitektur <br></h2><br><img src="https://habrastorage.org/webt/3q/0x/-c/3q0x-cy-45bblq5lgoayq2awd5u.jpeg"><br><br>  WebRTC menyiratkan adanya server pensinyalan, perantara antara klien, yang digunakan untuk bertukar pesan selama pembuatan koneksi p2p di antara mereka.  Setelah membuat koneksi langsung, klien mulai saling bertukar data media satu sama lain. <br><br><h2>  WebRTC  Demo <br></h2><br>  Mari kita mulai dengan demo sederhana.  Ada 5 langkah sederhana untuk membuat koneksi WebRTC. <br><br><div class="spoiler">  <b class="spoiler_title">Kode contoh terperinci</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-comment"><span class="hljs-comment">// Step #1: Getting local video stream and initializing a peer connection with it (both caller and callee) 2. 3. var localStream = null; 4. var localVideo = document.getElementById('localVideo'); 5. 6. navigator 7. .mediaDevices 8. .getUserMedia({ audio: true, video: true }) 9. .then(stream =&gt; { 10. localVideo.srcObject = stream; 11. localStream = stream; 12. }); 13. 14. var pc = new RTCPeerConnection({ iceServers: [...] }); 15. 16. localStream 17. .getTracks() 18. .forEach(track =&gt; pc.addTrack(track, localStream)); 19. 20. // Step #2: Creating SDP offer (caller) 21. 22. pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }) 23. .then(offer =&gt; signaling.send('offer', offer)); 24. 25. // Step #3: Handling SDP offer and sending SDP answer (callee) 26. 27. signaling.on('offer', offer =&gt; { 28. pc.setRemoteDescription(offer) 29. .then(() =&gt; pc.createAnswer()) 30. .then(answer =&gt; signaling.send('answer', answer)) 31. }); 32. 33. // Step #4: Handling SDP answer (calleer) 34. 35. signaling.on('answer', answer =&gt; pc.setRemoteDescription(answer)); 36. 37. // Step #5: Exchanging ICE candidates 38. 39. pc.onicecandidate = event =&gt; signaling.send('candidate', event.candidate); 40. 41. signaling.on('candidate', candidate =&gt; pc.addIceCandidate(candidate)); 42. 43. // Step #6: Getting remote video stream (both caller and callee) 44. 45. var remoteVideo = document.getElementById('remoteVideo'); 46. 47. pc.onaddstream = event =&gt; remoteVideo.srcObject = event.streams[0];</span></span></code> </pre> <br></div></div><br>  Dikatakan sebagai berikut: <br><br><ol><li>  Ambil video dan buat koneksi peer, transfer semacam iceServers (tidak segera jelas apa itu). <br></li><li>  Buat penawaran SDP dan kirimkan ke signaling, dan signalling WebRTC tidak akan menerapkan untuk Anda dengan cara apa pun. <br></li><li>  Maka Anda perlu membuat pembungkus untuk yang berasal dari pensinyalan, dan ini juga bukan bagian dari WebRTC. <br></li><li>  Selanjutnya tukar beberapa kandidat. <br></li><li>  Akhirnya dapatkan streaming video jarak jauh. <br></li></ol><br>  Mari cari tahu apa yang terjadi di sana dan apa yang perlu kita terapkan sendiri. <br><img src="https://habrastorage.org/webt/wx/fz/fn/wxfzfnkuw7smjite-bdpmadb_ro.jpeg"><br><br>  Kami melihat gambar dari bawah ke atas.  Ada perpustakaan WebRTC yang sudah ada di dalam browser, didukung oleh Chrome, Firefox, dll. Anda dapat membangunnya di bawah Android / iOS dan berkomunikasi dengannya melalui API dan SDP (Session Description Protocol), yang menjelaskan sesi itu sendiri.  Di bawah ini saya akan memberi tahu Anda apa yang termasuk di dalamnya.  Untuk menggunakan perpustakaan ini di aplikasi Anda, Anda harus membuat koneksi antara pelanggan melalui pensinyalan.  Signaling juga merupakan layanan Anda yang harus Anda tulis sendiri, WebRTC tidak menyediakannya. <br><br>  Selanjutnya dalam artikel ini kita akan membahas jaringan secara berurutan, kemudian video / audio, dan pada akhirnya kita akan menulis pensinyalan kita. <br><br><h2>  Jaringan WebRTC atau p2p (sebenarnya c2s2c) <br></h2><br>  Menyiapkan koneksi P2P tampaknya cukup sederhana. <br><img src="https://habrastorage.org/webt/he/7h/so/he7hsoyzqklbzj715slypgychgc.jpeg"><br><br>  Kami memiliki Alice dan Bob yang ingin membuat koneksi P2P.  Mereka mengambil alamat IP mereka, mereka memiliki server pensinyalan yang keduanya terhubung, dan melalui mana mereka dapat bertukar alamat ini.  Mereka bertukar alamat, dan oh!  Mereka memiliki alamat yang sama, ada yang salah! <br><img src="https://habrastorage.org/webt/rn/hc/uj/rnhcujxoa5k0tni2oquj-tx3hfi.jpeg"><br><br>  Bahkan, kedua pengguna kemungkinan besar duduk di belakang router Wi-Fi dan ini adalah alamat IP abu-abu lokal mereka.  Router menyediakan mereka dengan fitur seperti Terjemahan Alamat Jaringan (NAT).  Bagaimana cara kerjanya? <br><img src="https://habrastorage.org/webt/yr/xu/r0/yrxur0s_xhoye3i36zod4ropbec.jpeg"><br><br>  Anda memiliki subnet abu-abu dan alamat IP eksternal.  Anda mengirim paket ke Internet dari alamat abu-abu Anda, NAT mengganti alamat abu-abu Anda dengan warna putih dan mengingat pemetaan: dari mana port itu dikirim, ke pengguna mana dan port mana yang cocok.  Ketika paket kembali tiba, itu diselesaikan dengan pemetaan ini dan mengirimkannya ke pengirim.  Semuanya sederhana. <br><br>  Di bawah ini adalah ilustrasi bagaimana tampilannya di tempat saya. <br><img src="https://habrastorage.org/webt/ud/ar/da/udardacyxvmzt5mq0modbosd-mc.jpeg"><br><br>  Ini adalah alamat IP internal saya dan alamat router (omong-omong, juga abu-abu).  Jika Anda melacak dan melihat rute, kita akan melihat router Wi-Fi saya: paket alamat penyedia abu-abu dan IP putih eksternal.  Jadi, pada kenyataannya, saya akan memiliki dua NAT: satu di mana saya berada di Wi-Fi, dan yang lain dari penyedia, kecuali, tentu saja, saya membeli sendiri alamat IP eksternal yang khusus. <br><br>  <strong>NAT sangat populer karena:</strong> <br><br><ul><li>  banyak IPv4 masih hilang, dan tidak ada cukup alamat; </li><li>  NAT tampaknya melindungi jaringan; </li><li>  ini adalah fungsi standar router: terhubung ke Wi-Fi, ada NAT di sana, itu berfungsi. </li></ul><br>  Oleh karena itu, hanya 3% pengguna yang duduk dengan IP eksternal, sedangkan sisanya melalui NAT. <br><br>  NAT memungkinkan Anda untuk dengan aman pergi ke alamat putih mana pun.  Tetapi jika Anda tidak pergi ke mana pun, maka tidak ada yang bisa mendatangi Anda. <br><img src="https://habrastorage.org/webt/j7/cl/j2/j7clj2pypnpwv_p-odndgflgzpk.jpeg"><br><br>  Untuk membuat koneksi P2P adalah masalah.  Faktanya, Alice dan Bob tidak dapat saling mengirim paket jika keduanya berada di belakang NAT. <br><br>  WebRTC memiliki <strong>protokol STUN</strong> untuk menyelesaikan masalah ini.  Diusulkan untuk menggunakan server STUN.  Kemudian Alice terhubung ke server STUN, mendapatkan alamat IP-nya, mengirimkannya ke Bob melalui pensinyalan.  Bob juga mendapatkan alamat IP-nya dan mengirimkannya ke Alice.  Mereka mengirim paket ke satu sama lain dan dengan demikian menerobos NAT. <br><img src="https://habrastorage.org/webt/1m/mq/iz/1mmqiz57zbyzzahdgng_y_3hywo.jpeg"><br><br>  <strong>Pertanyaan</strong> : Alice memiliki porta tertentu yang terbuka, NAT / Firewall telah diterobos ke porta ini, dan Bob terbuka.  Mereka tahu alamat masing-masing.  Alice mencoba mengirim paket ke Bob, dia mengirim paket ke Alice.  Apakah Anda pikir mereka dapat berbicara atau tidak? <br><br>  Bahkan, Anda benar dalam hal apa pun, hasilnya tergantung pada jenis pasangan NAT yang dimiliki pengguna. <br><img src="https://habrastorage.org/webt/te/hd/hj/tehdhjdvyvfv9dcrxng950n98h8.jpeg"><br><br><h3>  Terjemahan alamat jaringan <br></h3><br>  Ada 4 jenis NAT: <br><br><ol><li>  NAT kerucut penuh; <br></li><li>  NAT kerucut terbatas; <br></li><li>  Port cone NAT yang dibatasi; <br></li><li>  NAT simetris <br></li></ol><br>  Dalam versi dasar, Alice mengirimkan paket ke server STUN, ia membuka beberapa port.  Bob entah bagaimana mengetahui tentang portalnya dan mengirim paket balasan.  Jika ini adalah <strong>Full cone NAT</strong> - yang termudah yang hanya memetakan port eksternal ke port internal, maka Bob akan dapat segera mengirim paket Alice, membuat koneksi, dan mereka akan berbicara. <br><img src="https://habrastorage.org/webt/ph/kp/zr/phkpzrkuy3k2uzqsl4sub-sla7o.jpeg"><br><br>  Di bawah ini adalah skema interaksi: Alice dari beberapa port mengirim paket ke port STUN, STUN menjawabnya dengan alamat eksternalnya.  STUN dapat merespons dari alamat mana pun, jika itu adalah NAT kerucut penuh, itu masih akan menembus NAT, dan Bob dapat menanggapi alamat yang sama. <br><img src="https://habrastorage.org/webt/dl/pp/3a/dlpp3anl2az479kengmx5easix4.jpeg"><br><br>  Dalam kasus <strong>NAT kerucut Terbatas,</strong> hal-hal sedikit lebih rumit.  Ia mengingat tidak hanya port tempat Anda perlu memetakan ke alamat internal, tetapi juga alamat eksternal yang Anda tuju.  Yaitu, jika Anda telah membuat koneksi hanya ke server IP STUN, maka tidak ada orang lain di jaringan yang dapat menjawab Anda, dan kemudian paket Bob tidak akan menjangkau. <br><img src="https://habrastorage.org/webt/yt/-g/sg/yt-gsg5yyrf99ywt77j2ydntyzy.jpeg"><br><br>  Bagaimana mengatasi masalah ini?  Dalam skema sederhana (lihat ilustrasi di bawah) seperti ini: Alice mengirim paket ke STUN, ia menjawabnya dengan IP-nya.  STUN dapat meresponsnya dari port mana pun asalkan itu Dibatasi kerucut NAT.  Bob tidak dapat menjawab Alice karena dia memiliki alamat yang berbeda.  Alice merespons dengan sebuah paket, mengetahui alamat IP Bob.  Dia membuka NAT untuk Bob, Bob menjawabnya.  Hore, mereka berbicara. <br><img src="https://habrastorage.org/webt/iz/ji/ar/izjiare3mege16iftxwal3haqye.jpeg"><br><br>  Opsi yang sedikit lebih rumit adalah <strong>Port cone NAT</strong> .  Semua sama, hanya STUN yang harus merespons dengan tepat dari port yang diaksesnya.  Semuanya akan bekerja juga. <br><br>  Yang paling berbahaya adalah <strong>Symmetric NAT</strong> . <br><img src="https://habrastorage.org/webt/p-/se/fu/p-sefuxnvpapxpuf8-wqavqkd0u.jpeg"><br><br>  Pada awalnya, semuanya bekerja dengan cara yang persis sama - Alice mengirim paket ke server STUN, ia merespons dari port yang sama.  Bob tidak bisa menjawab Alice, tetapi ia mengirim paket ke Bob.  Dan di sini, terlepas dari kenyataan bahwa Alice mengirim paket ke port 4444, pemetaan mengalokasikan port baru untuknya.  Symmetric NAT berbeda dalam hal bahwa ketika setiap koneksi baru dibuat, setiap kali mengeluarkan port baru pada router.  Dengan demikian, Bob berdetak di pelabuhan tempat Alice pergi ke STUN, dan mereka tidak dapat terhubung. <br><br>  Di arah yang berlawanan, jika Bob memiliki alamat IP terbuka, Alice mungkin datang kepadanya dan mereka akan membuat koneksi. <br><br>  Semua opsi dikumpulkan dalam satu tabel di bawah ini. <br><img src="https://habrastorage.org/webt/-c/jf/o9/-cjfo9dclflwku9qz-2p4wl_hre.jpeg"><br><br>  Ini menunjukkan bahwa hampir semuanya mungkin kecuali ketika kami mencoba untuk membuat koneksi melalui Symmetric NAT dengan Port cone NAT atau NAT Symmetric di ujung lainnya. <br><img src="https://habrastorage.org/webt/gp/lk/_d/gplk_darehdjbaxktic84liuwto.jpeg"><br><br>  Seperti yang kami ketahui, p2p sangat berharga bagi kami dalam hal latensi, tetapi jika itu tidak mungkin untuk menginstalnya, maka WebRTC menawarkan kepada kami server TURN.  Ketika kami menyadari bahwa p2p tidak akan diinstal, kami dapat terhubung ke TURN, yang akan mem-proxy semua lalu lintas.  Namun, pada saat yang sama Anda akan membayar untuk lalu lintas, dan pengguna mungkin memiliki beberapa penundaan tambahan. <br><br><h2>  Berlatih <br></h2><br>  Google memiliki server STUN gratis.  Anda bisa meletakkannya di perpustakaan, itu akan berhasil. <br><br>  TURN server memiliki kredensial (login dan kata sandi).  Kemungkinan besar, Anda harus menaikkan sendiri, agak sulit ditemukan gratis. <br><br>  Contoh server STUN gratis dari Google: <br><br><ul><li>  stun: stun.l.google.com: 19302 </li><li>  stun: stun1.l.google.com: 19302 </li><li>  stun: stun2.l.google.com: 19302 </li><li>  stun: stun3.l.google.com: 19302 </li></ul><br>  Dan server MENGHIDUPKAN gratis dengan kata sandi: url: 'turn: 192.158.29.39: 3478? Transport = udp', kredensial: 'JZEOEt2V3Qb0y27GRntt2u2PAYA =', nama pengguna: '28224511: 1379330808 ′. <br><br>  Kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">coturn</a> . <br><img src="https://habrastorage.org/webt/yj/_d/zv/yj_dzvkvpkhmol2a8ryscucgoli.jpeg"><br><br>  Akibatnya, 34% lalu lintas melewati koneksi p2p, yang lainnya diproksi melalui server TURN. <br><br><h4>  Apa lagi yang menarik dalam protokol STUN? <br></h4><br>  STUN memungkinkan Anda untuk menentukan jenis NAT. <br><img src="https://habrastorage.org/webt/nj/lo/7h/njlo7h_sounawjxlwk-pxsiejy0.jpeg"><br><br>  <em>Slide</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>link</em></a> <br><br>  Saat mengirim paket, Anda dapat menunjukkan bahwa Anda ingin menerima respons dari port yang sama atau meminta STUN untuk merespons dari port yang berbeda, dari IP yang berbeda, atau bahkan dari IP dan port yang berbeda.  Jadi, <strong>untuk 4 pertanyaan ke server STUN, Anda dapat menentukan jenis NAT</strong> . <br><img src="https://habrastorage.org/webt/og/0m/2h/og0m2hawerjjdabsr43zwygz_cy.jpeg"><br><br>  Kami menghitung jenis-jenis NAT dan kami mendapatkan bahwa hampir semua pengguna memiliki NAT Simetris atau NAT yang dibatasi kerucut Port.  Oleh karena itu, ternyata hanya sepertiga pengguna yang dapat membuat koneksi p2p. <br><br>  Anda mungkin bertanya mengapa saya memberi tahu Anda semua ini jika Anda bisa mengambil STUN dari Google, memasukkannya ke WebRTC, dan sepertinya semuanya akan berhasil. <br><br>  Karena Anda sebenarnya dapat menentukan jenis NAT sendiri. <br><img src="https://habrastorage.org/webt/ih/qn/8j/ihqn8j2nm2dumsstvyopem7ljxk.jpeg"><br><br>  Ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ke aplikasi Java yang tidak melakukan apa pun yang rumit: itu hanya ping port yang berbeda dan server STUN berbeda, dan melihat port mana yang dilihatnya pada akhirnya.  Jika Anda memiliki Open Full cone NAT, maka STUN server akan memiliki port yang sama.  Dengan NAT kerucut Terbatas, Anda akan memiliki port yang berbeda untuk setiap permintaan STUN. <br><img src="https://habrastorage.org/webt/ve/qf/t1/veqft1dee6wstziwrkrbemxj5da.jpeg"><br><br>  Dengan Symmetric NAT, ternyata begini di kantorku.  Ada port yang sama sekali berbeda. <br><br>  Tetapi kadang-kadang ada pola yang menarik bahwa untuk setiap koneksi, nomor port bertambah satu. <br><img src="https://habrastorage.org/webt/2n/7e/ro/2n7ero_besx7rzunsjuzfjplfpy.jpeg"><br><br>  Yaitu, banyak NAT yang dikonfigurasi sehingga mereka menambah atau mengurangi port dengan konstanta.  Konstanta ini dapat ditemukan dan dengan demikian menerobos NAT Simetris. <br><img src="https://habrastorage.org/webt/te/6n/bf/te6nbfknmebcz7zmrtk35jqwfpk.jpeg"><br><br>  Jadi kami menerobos NAT - kami pergi ke satu server STUN, ke yang lain, melihat perbedaannya, membandingkan dan mencoba lagi untuk memberikan port kami dengan kenaikan atau penurunan ini.  Artinya, Alice mencoba memberikan Bob portalnya, sudah disesuaikan dengan konstanta, tahu bahwa lain kali itu akan terjadi. <br><img src="https://habrastorage.org/webt/l1/re/-m/l1re-mp1om6zkjqm0j1n5rfh004.jpeg"><br><br>  Jadi kami berhasil mengelas <strong>12% peer-to-peer lainnya</strong> . <br><br>  Bahkan, kadang-kadang router eksternal dengan IP yang sama berperilaku sama.  Oleh karena itu, jika Anda mengumpulkan statistik dan jika Symmetric NAT adalah fitur dari penyedia, dan bukan fitur dari router Wi-Fi pengguna, maka delta dapat diprediksi, segera kirim ke pengguna sehingga ia menggunakannya dan tidak menghabiskan terlalu banyak waktu untuk menentukannya. <br><br><h2>  Relay CDN atau apa yang harus dilakukan jika Anda tidak dapat membuat koneksi P2P <br></h2><br>  Jika kita masih menggunakan TURN server dan bekerja tidak di p2p, tetapi dalam mode real, melewati semua lalu lintas melalui server, kita masih bisa menambahkan CDN.  Kecuali, tentu saja, Anda memiliki taman bermain.  Kami memiliki situs CDN kami sendiri, jadi bagi kami itu cukup sederhana.  Tapi itu perlu untuk menentukan di mana lebih baik untuk mengirim seseorang: ke situs CDN atau, katakanlah, ke saluran ke Moskow.  Ini bukan tugas yang sangat sepele, jadi kami melakukan ini: <br><br><ol><li>  Sengaja dikeluarkan untuk beberapa pengguna situs Moskow, beberapa - jarak jauh. <br></li><li>  Kami mengumpulkan statistik pada IP pengguna, pada server dan pada karakteristik jaringan. <br></li><li>  Dengan maxMind, kami mengelompokkan subnet, melihat statistik dan dapat memahami dengan IP pengguna mana yang memiliki server HIDUP terdekat untuk koneksi. <br></li></ol><br><img src="https://habrastorage.org/webt/ql/dg/sy/qldgsyqtvaeqqdvyctilcipatau.jpeg"><br><br>  Ada CDN di Novosibirsk.  Jika semuanya bekerja untuk Anda melalui Moskow, maka persentil RTT ke-99 adalah 1,3 detik.  Melalui CDN, semuanya bekerja jauh lebih cepat (0,4 detik). <br><br>  Apakah selalu lebih baik menggunakan koneksi P2P dan tidak menggunakan server?  Contoh yang menarik adalah dua penyedia Krasnoyarsk Optibyte dan Mobra (nama mungkin telah berubah).  Untuk beberapa alasan, koneksi di antara mereka pada p2p jauh lebih buruk daripada melalui MSK.  Mungkin mereka tidak berteman satu sama lain. <br><img src="https://habrastorage.org/webt/yq/en/dm/yqendmksjs7vila8zpra1xu_2uc.jpeg"><br><br>  Kami menganalisis semua kasus seperti itu, secara acak mengirim pengguna ke p2p atau melalui MSK, mengumpulkan statistik dan membuat prediksi.  Kami tahu bahwa statistik perlu diperbarui, jadi untuk beberapa pengguna kami secara khusus membuat koneksi yang berbeda untuk memeriksa apakah ada sesuatu yang berubah di jaringan. <br><br>  Kami mengukur karakteristik sederhana seperti waktu bundar, kehilangan paket, bandwidth - tetap mempelajari cara membandingkannya dengan benar. <br><img src="https://habrastorage.org/webt/yu/l-/nb/yul-nbvpnw5za6ixc80wlgumrse.jpeg"><br><br>  Bagaimana memahami mana yang lebih baik: 2 Mbit / s Internet, 400 ms RTT dan paket Loss 5% atau 100 Kbit / s, keterlambatan 100 ms dan sedikit paket loss? <br><br>  Tidak ada jawaban yang pasti, penilaian kualitas panggilan video sangat subjektif.  Oleh karena itu, setelah panggilan berakhir, kami meminta pengguna untuk mengevaluasi kualitas tanda bintang dan mengatur konstanta sesuai dengan hasilnya.  Ternyata, misalnya, RTT kurang dari 300 ms - tidak masalah lagi, bitrate lebih penting. <br><br>  Peringkat pengguna yang lebih tinggi untuk Android dan iOS.  Terlihat bahwa pengguna iOS lebih cenderung untuk menempatkan unit dan lebih sering lima.  Saya tidak tahu mengapa, mungkin, spesifik dari platform.  Tapi kami menarik konstanta di sepanjang mereka, sehingga kami memiliki, sepertinya bagi kami, bagus. <br><br>  Kembali ke garis besar kami untuk artikel, kami masih mendiskusikan jaringan. <br><br>  <strong>Seperti apa pengaturan sambungan itu?</strong> <br><img src="https://habrastorage.org/webt/-o/0b/zz/-o0bzzfolvd5rhfysec57ebndda.jpeg"><br><br>  Kami mengirim STUN dan MENGHIDUPKAN server ke PeerConnection (), koneksi dibuat.  Alice mengetahui IP-nya, mengirimkannya ke pensinyalan;  Bob belajar tentang IP Alice.  Alice mendapat IP Bob.  Mereka bertukar paket, mungkin menerobos NAT, mungkin mengatur TURN dan berkomunikasi. <br><img src="https://habrastorage.org/webt/yz/oa/rv/yzoarv064wp3s6zwwjpy0ec68hk.jpeg"><br><br>  Dalam 5 langkah membangun koneksi yang kita bahas sebelumnya, kami menemukan server, menemukan di mana mendapatkannya, dan bahwa kandidat ICE adalah alamat IP eksternal yang kami bertukar melalui pensinyalan.  Alamat IP internal klien, jika mereka berada dalam jangkauan satu Wi-Fi, juga dapat dicoba untuk menerobos. <br><br>  Mari beralih ke bagian video. <br><br><h2>  Video dan audio <br></h2><br>  WebRTC mendukung satu set codec video dan audio tertentu, tetapi Anda dapat menambahkan codec Anda sendiri di sana.  Pada dasarnya didukung oleh <strong>H.264 dan VP8 untuk video</strong> .  VP8 adalah codec perangkat lunak, oleh karena itu ia menghabiskan banyak baterai.  H.264 tidak tersedia di semua perangkat (biasanya asli), jadi prioritas default adalah pada VP8. <br><br>  Di dalam SDP (Session Description Protocol), ada negosiasi codec: ketika satu klien mengirim daftar codec-nya, yang lain mengirimkan sendiri dengan prioritas, dan mereka menyetujui codec mana yang akan mereka gunakan untuk komunikasi.  Jika diinginkan, Anda dapat mengubah prioritas codec VP8 dan H.264, dan karenanya, Anda dapat menghemat baterai pada beberapa perangkat, tempat 264 adalah perangkat asli.  Berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh</a> bagaimana hal ini dapat dilakukan.  Kami melakukan ini, tampaknya bagi kami bahwa pengguna tidak mengeluh tentang kualitas, tetapi pada saat yang sama daya baterai dikonsumsi jauh lebih sedikit. <br><br>  Untuk audio, WebRTC memiliki <strong>OPUS atau G711</strong> , biasanya semua OPUS selalu berfungsi, tidak ada yang perlu dilakukan dengannya. <br><br>  Di bawah ini adalah pengukuran suhu setelah 10 menit penggunaan. <br><img src="https://habrastorage.org/webt/pf/-q/pj/pf-qpjvwi8myzm7_q1zlmpe2zbs.jpeg"><br><br>  Jelas bahwa kami menguji berbagai perangkat.  Ini adalah contoh iPhone, dan di atasnya, aplikasi OK menggunakan baterai paling sedikit, karena suhu perangkat paling sedikit. <br><br>  Hal kedua yang dapat Anda aktifkan jika menggunakan WebRTC adalah <strong>mematikan video secara otomatis saat koneksi sangat buruk</strong> . <br><img src="https://habrastorage.org/webt/xg/kx/ab/xgkxab9ccijdbomfmja0rtrhfpg.jpeg"><br><br>  Jika Anda memiliki kurang dari 40 Kbps, video akan mati.  Anda hanya perlu mencentang kotak saat membuat koneksi, nilai ambang batas dapat dikonfigurasi melalui antarmuka.  Anda juga dapat mengatur minimum dan maksimum mulai bitrate saat ini. <br><img src="https://habrastorage.org/webt/xw/7d/ts/xw7dtsmnuz7pe0ujabtjapnnkxg.jpeg"><br><br>  Ini adalah hal yang sangat berguna.  Jika ketika Anda membuat koneksi yang Anda ketahui sebelumnya berapa bitrate yang Anda harapkan, Anda dapat mentransfernya, panggilan akan dimulai darinya, dan Anda tidak perlu mengadaptasi bitrate tersebut.  Plus, jika Anda tahu bahwa Anda sering memiliki packet loss atau drawdowns bandwidth pada saluran Anda, maka nilai maksimumnya juga dapat dibatasi. <br><br>  WhatsApp bekerja dengan video yang sangat sabun, tetapi dengan penundaan kecil, karena secara agresif menekan bitrate dari atas. <br><br>  Kami mengumpulkan statistik menggunakan MaxMind dan memetakannya. <br><img src="https://habrastorage.org/webt/la/1b/kq/la1bkqswv6zqpbqdd7zrjarq0xu.jpeg"><br><br>  Ini adalah perkiraan kualitas awal yang kami gunakan untuk panggilan di berbagai wilayah di Rusia. <br><br><h2>  Pemberian sinyal <br></h2><br>  Anda kemungkinan besar harus menulis bagian ini jika ingin melakukan panggilan.  Ada segala macam jebakan.  Ingat bagaimana tampilannya. <br><img src="https://habrastorage.org/webt/ip/iv/er/ipiverlo5evjhsixis-obij86vs.jpeg"><br><br>  Ada aplikasi dengan pensinyalan yang menghubungkan dan bertukar dengan SDP, dan SDP di bawah ini adalah antarmuka ke WebRTC. <br><br>  Seperti inilah bentuk pensinyalan sederhana: <br><img src="https://habrastorage.org/webt/y3/zl/ih/y3zlihhnt8w32ukv-ms7sbelbgm.jpeg"><br><br>  Alice memanggil Bob.  Ini menghubungkan, misalnya, melalui koneksi soket web.  Bob menerima dorongan pada ponsel atau browsernya, atau dalam semacam koneksi terbuka, terhubung melalui soket web dan setelah itu ponsel mulai berdering di sakunya.  Bob mengangkat telepon, Alice mengiriminya codec dan fitur WebRTC lain yang didukungnya.  Bob menjawab hal yang sama, dan setelah itu mereka bertukar kandidat yang mereka lihat.  Hore, telepon! <br><br>  Semuanya terlihat cukup panjang.  Pertama, sampai Anda membuat koneksi soket-web, sampai dorongan datang dan yang lainnya, telepon Bob tidak akan berdering di sakunya.  Alice akan menunggu sepanjang waktu, berpikir di mana Bob berada, mengapa dia tidak mengangkat telepon.  Setelah konfirmasi, itu semua membutuhkan waktu beberapa detik, dan bahkan pada koneksi yang baik bisa 3-5 detik, dan pada koneksi yang buruk semua 10. <br><br>  Kita harus melakukan sesuatu tentang itu!  Anda akan memberi tahu saya bahwa semuanya dapat dilakukan dengan sangat sederhana. <br><br><img src="https://habrastorage.org/webt/kz/q0/ym/kzq0ymgejzqqpmlyso5ri8mvz-k.jpeg"><br><br>  Jika Anda sudah memiliki koneksi terbuka untuk aplikasi Anda, Anda dapat segera mengirim push untuk membuat koneksi, terhubung ke server signaling yang diinginkan dan segera mulai membuat panggilan. <br><br>  Lalu optimasi lain.  Bahkan jika telepon masih berdering di saku Anda dan Anda belum mengangkat telepon, Anda sebenarnya dapat bertukar informasi tentang codec yang didukung, alamat IP eksternal, mulai mengirim paket video kosong, dan secara umum semuanya akan menghangat.  Setelah Anda mengangkat telepon, semuanya akan menjadi luar biasa. <br><br>  Kami melakukannya, dan sepertinya semuanya keren.  Tapi tidak. <br><img src="https://habrastorage.org/webt/hh/m5/t6/hhm5t6dtihar96isxhtsm92pums.jpeg"><br><br>  Masalah pertama adalah bahwa pengguna sering membatalkan panggilan.  Mereka mengklik "Panggil" dan segera membatalkan.  Dengan demikian, dorongan masuk ke panggilan, dan pengguna menghilang (dia telah kehilangan Internet atau yang lainnya).  Sementara itu, telepon seseorang berdering, ia mengangkat telepon, dan ia tidak diharapkan di sana.  Karena itu, pengoptimalan primitif kami untuk mulai menelepon secepat mungkin tidak benar-benar berfungsi. <br><img src="https://habrastorage.org/webt/xy/we/gy/xywegygpnsrlns4osq7nn4i71f0.jpeg"><br><br>  Dengan pembatalan panggilan cepat, ada hal berbahaya kedua.  Jika Anda menghasilkan ID percakapan Anda di server, maka Anda harus menunggu jawaban.  Artinya, Anda membuat panggilan, mendapatkan ID, dan hanya setelah itu Anda dapat melakukan apa pun yang Anda inginkan: mengirim paket, bertukar, termasuk membatalkan panggilan.  Ini adalah cerita yang sangat buruk, karena ternyata sampai tanggapan telah tiba, Anda tidak dapat benar-benar membatalkan apa pun dari klien.  Oleh karena itu, yang terbaik adalah membuat beberapa jenis ID pada klien seperti GUID dan mengatakan bahwa Anda memulai panggilan.  Orang sering melakukan ini: mereka memanggil, membatalkan, dan segera menelepon lagi.  Untuk mencegah agar tidak berantakan, lakukan GUID dan kirimkan. <br><img src="https://habrastorage.org/webt/1e/he/ob/1eheobd8oyf6z-je6j0puuj7psy.jpeg"><br><br>  Tampaknya tidak ada apa-apa, tetapi ada masalah lain.  Jika Bob memiliki dua telepon, atau di tempat lain peramban tetap terbuka, maka seluruh skema sulap kami untuk bertukar paket, membuat sambungan tidak berfungsi jika ia tiba-tiba menjawab dari perangkat lain. <br><br>  Apa yang harus dilakukan  Mari kita kembali ke skema pensinyalan lambat dasar yang sederhana dan mengoptimalkannya, mengirim dorongan sedikit lebih awal.  Pengguna akan mulai terhubung lebih cepat, tetapi ini akan menghemat beberapa uang. <br><img src="https://habrastorage.org/webt/ap/k3/kx/apk3kx9qq3nsrzmrervqa548e-g.jpeg"><br><br>  Apa yang harus dilakukan dengan bagian terlama setelah dia mengangkat telepon dan memulai pertukaran? <br><img src="https://habrastorage.org/webt/ff/bj/qv/ffbjqvge9liirsi6spjc7ttlyby.jpeg"><br><br>  Anda dapat melakukan hal berikut.  Jelas bahwa Alice sudah mengetahui semua codec-nya dan dapat mengirimnya ke kedua ponsel Bob.  Dia dapat menyelesaikan semua alamat IP-nya dan juga mengirimnya ke pensinyalan, yang akan membuat mereka dalam antriannya, tetapi tidak akan mengirim ke klien mana pun sehingga mereka dapat mulai menghubungkannya terlebih dahulu. <br><br>   ?  offer,   ,    ,   , ,    ,   .     ,    codec negotiation,  signaling             ,   ,     . Candidates         signaling. <br><br>   ,   signaling               .    ,          ,       . <br><br>    .           Google Duo  WhatsApp. <br><img src="https://habrastorage.org/webt/qr/gs/ry/qrgsry_mx3ahy48v6gvw1l49uau.jpeg"><br><br> ,   -  . ,      signaling,     ,   ,  , ,  ,    .     . <br><br> <strong>    ?</strong> <br><img src="https://habrastorage.org/webt/tp/fn/p3/tpfnp3a3cqrv_pdv31x7m4tirxi.jpeg"><br><br>      :   ,    .   ,      , —   signaling  ,  ,   -  ,     ,     ,     . <br><img src="https://habrastorage.org/webt/so/mv/go/somvgopdt0c3zi5kksffvtpogz4.jpeg"><br><br>  ,   ,  ,      .          . ,     ,       ,   ,    .       ,    . <br><br>          ,     24/7,      -,      . <br><img src="https://habrastorage.org/webt/3a/uh/au/3auhaued9dsrfuwyhffcubvuqpy.jpeg"><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em></em></a> <em>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a></em> <br><br>    web-socket  - load balancer,    signaling-   -,       .  Zookeeper   Leader Election,     signaling,     conversation.       conversation,      . <br><br>      ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NewSQL  Cassandra</a> .     ,  .       ,    signaling,   ,    signaling,     - ,  Leader Election  Zookeeper,   ,   ,         . <br><br>   : <br><br><ul><li>   - , ,   IP  signaling </li><li> Signaling ,   . </li><li>  ,  ,   , ,     . </li><li>       . </li></ul><br>     ,   . <br><br>           Cassandra,       ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>    ). <br><br> <strong>,  :</strong> <br><br><ul><li>   iceServers    ; </li><li>   Session Description Protocol; </li><li>         ; </li><li>      signaling    WebRTC   ,   IP ; </li><li>    ! </li></ul><br><img src="https://habrastorage.org/webt/6j/hp/6k/6jhp6kn6luheqat6jepleauq1me.jpeg"><br><br> <strong> :</strong> <br><br><ul><li>   delay    ; </li><li>     ; </li><li>        . </li></ul><br>  Wow! <br><img src="https://habrastorage.org/webt/97/ru/zy/97ruzyu7gams8pyk2ktcoqb9yim.jpeg"><br><br><h2> Security. Man in the middle attack for WebRTC <br></h2><br>   man in the middle attack for WebRTC.   , WebRTC      ,     RTP,   1996 ,  SDP   1998  SIP. <br><img src="https://habrastorage.org/webt/yi/zm/7k/yizm7kvtjfnpnphvmuwiduk6yua.jpeg"><br><br>    —   RFC     RTP,    RTP WebRTC. <br><br>      RFC —       audio level,   ,     audio level  ,   . ,    SDP,   ,     .      congestion,       -. <br><br>  WebRTC  .  2011     ,  2013    Firefox,      iOS/Android,  2014 Opera.  , -   ,         . <br><img src="https://habrastorage.org/webt/53/s2/31/53s231p3esxh8vt9ls8dn8szgqi.jpeg"><br><br>       signaling,      ,  DTLS Handshake   .  ,       signaling,         «»   ,   ,      ,   . <br><img src="https://habrastorage.org/webt/i-/lq/uh/i-lquhbrd0eltgcqorvk1bu2gjs.jpeg"><br><br>       , , ,    HTTPS, WSS  ..     — ZRTP,  , , Telegram. <br><br>    Telegram ,   ,     .       ,    ,  ,     ,       p2p . <br><br>  Bagaimana cara kerjanya? <br><img src="https://habrastorage.org/webt/rx/0-/ws/rx0-wsjwmt6y8fboqtzsgyzpqos.jpeg"><br><br>          — .    ,    ,  .          .              K,    ,     ,        . <br><br>       ,       ,     K <sub>1</sub>  K <sub>2</sub> .       .    .   K <sub>1</sub>  K <sub>2</sub>     ,         .       K <sub>1</sub>  K <sub>2</sub>     :  ,   —  ,   —       ,  .        ,     ,  -    , ,   . <br><br><h2> <strong></strong> <br></h2><br><ul><li>  «» NAT type   symmetric NAT. </li><li>  ,  : 2  relay, , CDN;         . </li><li>   ,   . </li><li>    signaling. </li></ul><br><img src="https://habrastorage.org/webt/xr/h6/2i/xrh62iyyd4cb5ynwfa66atogljm.jpeg"><br><br>   ,       RTMFP, ,     WebRTC,   ,    .    !           4 . <br><br><h2> <strong> </strong> <br></h2><br>      ,    : <br><br><ul><li>   WebRTC  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://webrtc.org/native-code/development/</a> ),    iOS/Android,      ; </li><li>    coturn ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/coturn/coturn</a> ); </li><li>  signaling. </li></ul><br>   ,    . <br><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/MnEXuKHjIOU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br><blockquote>        HighLoad++  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>      4-. <br><br>     ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .    ,  19  (10    9    -)  ,   -    .  ,       ,   . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428217/">https://habr.com/ru/post/id428217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428203/index.html">Kami melihat grafik: perkiraan dan perkiraan untuk pasar cloud computing, data pada tahun 2018</a></li>
<li><a href="../id428205/index.html">Lifehacks NaviHaka</a></li>
<li><a href="../id428209/index.html">Buku masak pengembang: Resep Desain Berbasis Domain (Bagian 2, struktur dan interaksi)</a></li>
<li><a href="../id428211/index.html">Buku “Arsitektur evolusi. Dukungan untuk perubahan terus menerus "</a></li>
<li><a href="../id428213/index.html">Bagaimana menafsirkan prediksi model dalam SHAP</a></li>
<li><a href="../id428219/index.html">Dari mana praktik relokasi massal personel yang memenuhi syarat berasal?</a></li>
<li><a href="../id428221/index.html">Generasi AI dari wajah realistis</a></li>
<li><a href="../id428223/index.html">Kota dan Big Data mereka</a></li>
<li><a href="../id428225/index.html">Cara melakukan analisis web untuk SaaS melalui Google Analytics: memperkenalkan dan melacak corong</a></li>
<li><a href="../id428227/index.html">Pembelajaran Mesin: Memprediksi Harga Saham di Pasar Saham</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>