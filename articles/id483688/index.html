<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥜 🐨 🈶 Tentang 30x Peningkatan Konkurensi di Node.js 👩🏻‍🤝‍👨🏾 💐 🌌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa cara terbaik untuk meningkatkan konkurensi dalam layanan Node.js yang digunakan dalam produksi? Ini adalah pertanyaan yang perlu dijawab oleh tim ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang 30x Peningkatan Konkurensi di Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/483688/">  Apa cara terbaik untuk meningkatkan konkurensi dalam layanan Node.js yang digunakan dalam produksi?  Ini adalah pertanyaan yang perlu dijawab oleh tim saya beberapa bulan yang lalu. <br><br>  Kami telah meluncurkan 4000 kontainer Node (atau "pekerja"), yang memastikan pengoperasian layanan integrasi kami dengan bank.  Layanan ini awalnya dirancang sehingga setiap pekerja dirancang untuk memproses hanya satu permintaan pada suatu waktu.  Ini mengurangi dampak pada sistem operasi yang secara tak terduga dapat <a href="https://nodejs.org/ru/docs/guides/dont-block-the-event-loop/">memblokir</a> siklus peristiwa dan memungkinkan kami untuk mengabaikan perbedaan dalam penggunaan sumber daya oleh berbagai operasi serupa.  Tetapi, karena kapasitas kami terbatas pada eksekusi secara serentak hanya 4.000 permintaan, sistem tidak dapat diskalakan secara memadai.  Kecepatan respons terhadap sebagian besar permintaan tidak tergantung pada kapasitas peralatan, tetapi pada kemampuan jaringan.  Oleh karena itu, kami dapat meningkatkan sistem dan mengurangi biaya dukungannya jika kami dapat menemukan cara untuk memproses permintaan secara andal secara paralel. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/483688/"><img src="https://habrastorage.org/webt/dq/pm/0q/dqpm0qid51wd9njshhwhr-mi_ic.jpeg"></a> <br><br>  Setelah mempelajari masalah ini, kami tidak dapat menemukan panduan yang baik yang akan membahas transisi dari "kurangnya paralelisme" di Node.js ke "tingkat paralelisme yang tinggi".  Sebagai hasilnya, kami mengembangkan strategi migrasi kami sendiri, yang didasarkan pada perencanaan yang cermat, alat yang baik, alat pemantauan, dan dosis debugging yang sehat.  Sebagai hasilnya, kami berhasil meningkatkan tingkat paralelisme sistem kami sebanyak 30 kali.  Ini setara dengan mengurangi biaya pemeliharaan sistem sekitar 300 ribu dolar per tahun. <br><br>  Materi ini didedikasikan untuk kisah tentang bagaimana kami meningkatkan produktivitas dan efektivitas pekerja Node.js kami, dan tentang apa yang kami pelajari dengan menggunakan cara ini. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mengapa kami memutuskan untuk berinvestasi dalam paralelisme?</font> </h2><br>  Tampaknya mengejutkan bahwa kita telah tumbuh ke dimensi seperti itu tanpa menggunakan paralelisme.  Bagaimana itu terjadi?  Hanya 10% operasi pemrosesan data yang dilakukan oleh alat-alat Kotak-kotak dimulai oleh pengguna yang duduk di depan komputer dan telah menghubungkan akun mereka ke aplikasi.  Yang lainnya adalah transaksi untuk memperbarui transaksi secara berkala yang dilakukan tanpa kehadiran pengguna.  Logika ditambahkan ke sistem penyeimbangan beban yang kami gunakan untuk memastikan bahwa permintaan yang dibuat oleh pengguna diutamakan daripada permintaan pembaruan transaksi.  Ini memungkinkan kami untuk menangani ledakan aktivitas operasi akses API dalam 1000% atau bahkan lebih.  Ini dilakukan melalui transaksi yang bertujuan memperbarui data. <br><br>  Meskipun skema kompromi ini telah bekerja sejak lama, adalah mungkin untuk melihat beberapa momen yang tidak menyenangkan di dalamnya.  Kami tahu bahwa mereka, pada akhirnya, dapat mempengaruhi keandalan layanan. <br><br><ul><li>  Puncak permintaan API yang berasal dari klien semakin tinggi.  Kami khawatir bahwa lonjakan besar dalam aktivitas dapat menguras kemampuan pemrosesan permintaan kami. </li><li>  Peningkatan keterlambatan yang tiba-tiba dalam memenuhi permintaan ke bank juga menyebabkan penurunan kapasitas pekerja.  Karena kenyataan bahwa bank menggunakan berbagai solusi infrastruktur, kami menetapkan batas waktu yang sangat konservatif untuk permintaan keluar.  Akibatnya, diperlukan beberapa menit untuk menyelesaikan operasi pemuatan data tertentu.  Jika kebetulan keterlambatan dalam melakukan banyak permintaan ke bank tiba-tiba akan meningkat pesat, ternyata banyak pekerja yang hanya akan terjebak menunggu jawaban. </li><li>  Penempatan di ECS menjadi terlalu lambat, dan meskipun kami telah meningkatkan kecepatan penerapan sistem, kami tidak ingin terus meningkatkan ukuran cluster. </li></ul><br>  Kami memutuskan bahwa cara terbaik untuk mengatasi hambatan aplikasi dan meningkatkan keandalan sistem adalah dengan meningkatkan tingkat paralelisme dalam memproses permintaan.  Selain itu, kami berharap bahwa, sebagai efek samping, ini akan memungkinkan kami untuk mengurangi biaya infrastruktur dan membantu menerapkan alat yang lebih baik untuk memantau sistem.  Baik itu dan yang lain di masa depan akan berbuah. <br><br><h2>  <font color="#3AC1EF">Bagaimana kami memperkenalkan pembaruan, menjaga keandalan</font> </h2><br><h3>  <font color="#3AC1EF">▍ Alat dan Pemantauan</font> </h3><br>  Kami memiliki penyeimbang beban kami sendiri, yang mengalihkan permintaan ke pekerja Node.js.  Setiap pekerja menjalankan server gRPC yang digunakan untuk memproses permintaan.  Pekerja menggunakan Redis untuk memberi tahu penyeimbang beban bahwa ia tersedia.  Ini berarti bahwa menambahkan paralelisme ke sistem diturunkan hanya dengan mengubah beberapa baris kode.  Yaitu, pekerja itu, bukannya menjadi tidak dapat diakses setelah permintaan diajukan kepadanya, harus memberi tahu bahwa ia tersedia sampai ia ditemukan sibuk memproses N permintaan yang datang kepadanya (masing-masing dari mereka). diwakili oleh objek Janji sendiri). <br><br>  Benar, pada kenyataannya, tidak semuanya begitu sederhana.  Saat menggunakan pembaruan sistem, kami selalu menganggapnya sebagai tujuan utama kami untuk mempertahankan keandalannya.  Oleh karena itu, kami tidak bisa hanya mengambil dan, dipandu oleh sesuatu seperti prinsip YOLO, menempatkan sistem dalam mode pemrosesan kueri paralel.  Kami berharap bahwa peningkatan sistem seperti itu akan sangat berisiko.  Faktanya adalah bahwa ini akan memiliki efek yang tidak terduga pada penggunaan prosesor, memori, dan keterlambatan dalam melakukan tugas.  Karena <a href="https://v8.dev/">mesin V8 yang</a> digunakan di Node.js menangani tugas dalam loop acara, perhatian utama kami adalah bahwa mungkin ternyata kami melakukan terlalu banyak pekerjaan dalam loop acara dan dengan demikian mengurangi throughput sistem. <br><br>  Untuk mengurangi risiko ini, kami, bahkan sebelum pekerja paralel pertama mulai berproduksi, memastikan ketersediaan alat dan alat pemantauan berikut dalam sistem: <br><br><ul><li>  <a href="https://www.elastic.co/what-is/elk-stack">Tumpukan ELK yang</a> sudah digunakan oleh kami memberi kami informasi login yang cukup, yang dapat berguna untuk dengan cepat mengetahui apa yang terjadi dalam sistem. </li><li>  Kami telah menambahkan beberapa metrik <a href="https://prometheus.io/">Prometheus</a> ke sistem.  Termasuk yang berikut ini: <br><br><ul><li> Ukuran tumpukan V8 diperoleh menggunakan <code>process.memoryUsage()</code> . </li><li>  Informasi tentang operasi pengumpulan sampah menggunakan paket <a href="https://www.npmjs.com/package/gc-stats">gc-stats</a> . </li><li>  Data waktu yang dibutuhkan untuk menyelesaikan tugas, dikelompokkan berdasarkan jenis operasi yang terkait dengan integrasi dengan bank, dan menurut tingkat konkurensi.  Kami membutuhkan ini untuk mengukur andal bagaimana konkurensi mempengaruhi throughput sistem. </li></ul></li><li>  Kami menciptakan <a href="https://grafana.com/">panel</a> kontrol <a href="https://grafana.com/">Grafana</a> , yang dirancang untuk mempelajari tingkat dampak konkurensi pada sistem. </li><li>  Bagi kami, kemampuan untuk mengubah perilaku aplikasi tanpa perlu memindahkan layanan sangat penting.  Oleh karena itu, kami membuat satu set bendera <a href="https://launchdarkly.com/">LaunchDarkly yang</a> dirancang untuk mengontrol berbagai parameter.  Dengan pendekatan ini, pemilihan parameter pekerja, dihitung sehingga mereka akan mencapai tingkat paralelisme maksimum, memungkinkan kami untuk dengan cepat melakukan percobaan dan menemukan parameter terbaik, menghabiskan beberapa menit untuk ini. </li><li>  Untuk mengetahui bagaimana berbagai bagian aplikasi memuat prosesor, kami telah membangun alat pengumpulan data layanan produksi, berdasarkan diagram nyala api yang dibangun. <br><br><ul><li>  Kami menggunakan paket 0x karena alat Node.js mudah diintegrasikan ke dalam layanan kami, dan karena visualisasi data HTML akhir mendukung pencarian dan memberi kami tingkat detail yang baik. </li><li>  Kami menambahkan mode profil ke sistem ketika pekerja mulai dengan paket 0x dihidupkan dan, ketika keluar, menuliskan data akhir dalam S3.  Kemudian kita bisa mengunduh log yang kita butuhkan dari S3 dan melihatnya secara lokal menggunakan perintah dari form <code>0x --visualize-only ./flamegraph</code> . </li><li>  Kami, dalam periode waktu tertentu, mulai membuat profil hanya untuk satu pekerja.  Pembuatan profil meningkatkan konsumsi sumber daya dan mengurangi produktivitas, jadi kami ingin membatasi efek negatif ini untuk satu pekerja. </li></ul></li></ul><br><h3>  <font color="#3AC1EF">▍ Mulai Penempatan</font> </h3><br>  Setelah menyelesaikan persiapan awal, kami membuat cluster ECS baru untuk "pekerja paralel".  Ini adalah para pekerja yang menggunakan bendera LaunchDarkly untuk secara dinamis mengatur tingkat paralelisme maksimum mereka. <br><br>  Rencana penerapan sistem kami mencakup pengalihan bertahap pertumbuhan volume lalu lintas dari cluster lama ke yang baru.  Selama ini, kami akan memonitor kinerja cluster baru.  Di setiap tingkat beban, kami berencana untuk meningkatkan tingkat paralelisme setiap pekerja, membawanya ke nilai maksimum di mana tidak ada peningkatan dalam durasi tugas atau penurunan indikator lainnya.  Jika kami dalam masalah, kami dapat, dalam beberapa detik, secara dinamis mengarahkan lalu lintas ke cluster lama. <br><br>  Seperti yang diharapkan, kami mengalami beberapa masalah rumit.  Kami perlu menyelidiki dan menghilangkannya untuk memastikan operasi yang benar dari sistem yang diperbarui.  Di sinilah kesenangan dimulai. <br><br><h2>  <font color="#3AC1EF">Perluas, Jelajahi, Ulangi</font> </h2><br><h3>  <font color="#3AC1EF">▍Meningkatkan ukuran tumpukan maksimum Node.js</font> </h3><br>  Ketika kami mulai menerapkan sistem baru, kami mulai menerima pemberitahuan penyelesaian tugas dengan kode keluar yang tidak nol.  Apa yang bisa saya katakan - awal yang menjanjikan.  Kemudian kami mengubur di Kibana dan menemukan log yang diperlukan: <br><br><pre> <code class="javascript hljs">FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - Javascript heap out <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> memory <span class="hljs-number"><span class="hljs-number">1</span></span>: node::Abort() <span class="hljs-number"><span class="hljs-number">2</span></span>: node::FatalException(v8::Isolate*, <span class="hljs-attr"><span class="hljs-attr">v8</span></span>::Local, <span class="hljs-attr"><span class="hljs-attr">v8</span></span>::Local) <span class="hljs-number"><span class="hljs-number">3</span></span>: v8::internal::V8::FatalProcessOutOfMemory(char <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, bool) <span class="hljs-number"><span class="hljs-number">4</span></span>: v8::internal::Factory::NewFixedArray(int, <span class="hljs-attr"><span class="hljs-attr">v8</span></span>::internal::PretenureFlag)</code> </pre> <br>  Itu mengingatkan pada efek kebocoran memori yang telah kami temui ketika proses dihentikan tiba-tiba, memberikan pesan kesalahan yang sama.  Ini tampaknya cukup diharapkan: peningkatan tingkat paralelisme menyebabkan peningkatan tingkat penggunaan memori. <br><br>  Kami menyarankan bahwa meningkatkan ukuran maksimum tumpukan Node.js, yang diatur ke 1,7 GB secara default, dapat membantu menyelesaikan masalah ini.  Kemudian kami mulai menjalankan Node.js, mengatur ukuran heap maksimum menjadi 6 GB (menggunakan flag baris perintah <code>--max-old-space-size=6144</code> ).  Ini adalah nilai terbesar yang cocok untuk instance EC2 kami.  Kami senang, langkah seperti itu memungkinkan kami mengatasi kesalahan di atas yang terjadi dalam produksi. <br><br><h3>  <font color="#3AC1EF">▍ Memory Bottleneck Identification</font> </h3><br>  Setelah kami memecahkan masalah dengan alokasi memori, kami mulai menemukan throughput tugas yang buruk pada pekerja paralel.  Pada saat yang sama, salah satu grafik di panel kontrol segera menarik perhatian kami.  Ini adalah laporan tentang bagaimana proses pekerja paralel menggunakan banyak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/598/944/d59/598944d592326d9ac7b4027e686de3bd.png"></div><br>  <i><font color="#999999">Penumpukan penggunaan</font></i> <br><br>  Beberapa kurva grafik ini terus naik - sampai mereka berubah, pada tingkat ukuran tumpukan maksimum, menjadi garis hampir horizontal.  Kami benar-benar tidak menyukainya. <br><br>  Kami menggunakan metrik sistem di Prometheus untuk menghilangkan kebocoran deskriptor file atau soket jaringan dari penyebab perilaku sistem tersebut.  Asumsi kami yang paling tepat adalah bahwa pengumpulan sampah tidak cukup sering dilakukan untuk benda-benda tua.  Ini dapat mengarah pada fakta bahwa ketika tugas-tugas diproses, pekerja akan mengumpulkan semakin banyak memori yang dialokasikan untuk objek yang sudah tidak perlu.  Kami berasumsi bahwa operasi sistem, di mana throughputnya menurun, terlihat seperti ini: <br><br><ul><li>  Pekerja menerima tugas baru dan melakukan tindakan tertentu. </li><li>  Dalam proses menjalankan tugas, memori dialokasikan pada heap untuk objek. </li><li>  Karena fakta bahwa operasi tertentu yang mereka kerjakan pada prinsip "dilakukan dan dilupakan" (maka belum jelas yang mana) tidak lengkap, referensi ke objek disimpan bahkan setelah tugas selesai. </li><li>  Pengumpulan sampah melambat karena fakta bahwa V8 harus memindai semakin banyak objek di tumpukan. </li><li>  Karena V8 mengimplementasikan sistem pengumpulan sampah yang bekerja sesuai dengan skema <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">stop-the-world</a> (menghentikan program selama pengumpulan sampah), tugas-tugas baru pasti akan menerima lebih sedikit waktu prosesor, yang mengurangi throughput pekerja. </li></ul><br>  Kami mulai mencari dalam kode kami untuk operasi yang dilakukan berdasarkan prinsip "selesai dan dilupakan".  Mereka juga disebut "janji mengambang" ("janji mengambang").  Itu sederhana - itu cukup untuk menemukan garis-garis di mana aturan <a href="https://palantir.github.io/tslint/rules/no-floating-promises/">tanpa-mengambang-janji</a> dinonaktifkan.  Salah satu metode menarik perhatian kami.  Dia membuat panggilan untuk <code>compressAndUploadDebuggingPayload</code> tanpa menunggu hasil.  Tampaknya panggilan seperti itu dapat dengan mudah berlanjut untuk waktu yang lama bahkan setelah pemrosesan tugas selesai. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> postTaskDebugging = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (data: TypedData) =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> payload = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> generateDebuggingPayload(data);       <span class="hljs-comment"><span class="hljs-comment">//       ,    //        .    // tslint:disable-next-line:no-floating-promises    compressAndUploadDebuggingPayload(payload)        .catch((err) =&gt; logger.error('failed to upload data', err)); }</span></span></code> </pre> <br>  Kami ingin menguji hipotesis bahwa janji mengambang seperti itu adalah sumber utama masalah.  Jika Anda tidak memenuhi tantangan ini, yang tidak memengaruhi operasi sistem yang benar, dapatkah kami meningkatkan kecepatan tugas?  Inilah yang tampak seperti tumpukan informasi penggunaan setelah kami menyingkirkan <code>postTaskDebugging</code> panggilan <code>postTaskDebugging</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b5/899/652/9b5899652c40d7b349bcfe108b9f721c.png"></div><br>  <i><font color="#999999">Menggunakan heap setelah menonaktifkan postTaskDebugging</font></i> <br><br>  Ternyata!  Sekarang tingkat pemanfaatan tumpukan pekerja paralel tetap stabil selama periode waktu yang lama. <br><br>  Ada perasaan bahwa dalam sistem, saat tugas selesai, "hutang" panggilan <code>compressAndUploadDebuggingPayload</code> secara bertahap diakumulasikan.  Jika pekerja menerima tugas lebih cepat daripada dia mampu "melunasi" ini "hutang," maka objek di mana memori dialokasikan tidak dikenai operasi pengumpulan sampah.  Hal ini menyebabkan mengisi tumpukan ke bagian paling atas, yang kami pertimbangkan di atas, menganalisis grafik sebelumnya. <br><br>  Kami mulai bertanya-tanya apa yang membuat janji-janji mengambang ini begitu lambat.  Kami tidak ingin menghapus sepenuhnya <code>compressAndUploadDebuggingPayload</code> dari kode, karena panggilan ini sangat penting sehingga teknisi kami dapat men-debug tugas-tugas produksi pada mesin lokal mereka.  Dari sudut pandang teknis, kita bisa menyelesaikan masalah dengan menunggu hasil panggilan ini dan setelah itu menyelesaikan tugas, dengan demikian menyingkirkan janji mengambang.  Tetapi ini akan sangat meningkatkan waktu pelaksanaan setiap tugas yang kami proses. <br><br>  Setelah memutuskan bahwa kami akan menggunakan solusi untuk masalah hanya sebagai upaya terakhir, kami mulai berpikir untuk mengoptimalkan kode.  Bagaimana cara mempercepat operasi ini? <br><br><h3>  <font color="#3AC1EF">▍Fix bottleneck S3</font> </h3><br>  Logika dari <code>compressAndUploadDebuggingPayload</code> mudah diketahui.  Di sini kita kompres data debug, dan ini bisa sangat besar, karena itu termasuk lalu lintas jaringan.  Lalu kami mengunggah data yang dikompresi ke S3. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compressAndUploadDebuggingPayload = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (    logger: Logger,    <span class="hljs-attr"><span class="hljs-attr">data</span></span>: any, ) =&gt; {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> compressionStart = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now();    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> base64CompressedData = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> streamToString(        bfj.streamify(data)            .pipe(zlib.createDeflate())            .pipe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> b64.Encoder()),    );    logger.trace(<span class="hljs-string"><span class="hljs-string">'finished compressing data'</span></span>, {        <span class="hljs-attr"><span class="hljs-attr">compression_time_ms</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - compressionStart,    );           <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uploadStart = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now();    s3Client.upload({        <span class="hljs-attr"><span class="hljs-attr">Body</span></span>: base64CompressedData,        <span class="hljs-attr"><span class="hljs-attr">Bucket</span></span>: bucket,        <span class="hljs-attr"><span class="hljs-attr">Key</span></span>: key,    });    logger.trace(<span class="hljs-string"><span class="hljs-string">'finished uploading data'</span></span>, {        <span class="hljs-attr"><span class="hljs-attr">upload_time_ms</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - uploadStart,    ); }</code> </pre> <br>  Dari log Kibana, jelas bahwa mengunduh data ke S3, meskipun volumenya kecil, membutuhkan banyak waktu.  Kami awalnya tidak berpikir bahwa soket dapat menjadi hambatan dalam sistem, karena agen HTTPS Node.js standar menetapkan parameter <a href="&amp;xid=25657,15700021,15700186,15700190,15700259,15700271&amp;usg=ALkJrhiBsz6iOEr3zjS2bCU_lJLFRBENTg#">maxSockets</a> ke <code>Infinity</code> .  Namun, pada akhirnya, kami membaca dokumentasi AWS di Node.js dan menemukan sesuatu yang mengejutkan bagi kami: klien S3 mengurangi nilai parameter <code>maxSockets</code> menjadi <code>50</code> .  Tidak perlu dikatakan, perilaku ini tidak bisa disebut intuitif. <br><br>  Karena kami membawa pekerja ke keadaan di mana di dalamnya, dalam mode kompetitif, lebih dari 50 tugas dilakukan, langkah pengunduhan menjadi hambatan: menyediakan waktu tunggu soket untuk dilepas untuk mengunggah data ke S3.  Kami meningkatkan waktu pemuatan data dengan melakukan perubahan berikut pada kode inisialisasi klien S3: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> s3Client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AWS.S3({    <span class="hljs-attr"><span class="hljs-attr">httpOptions</span></span>: {        <span class="hljs-attr"><span class="hljs-attr">agent</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> https.Agent({            <span class="hljs-comment"><span class="hljs-comment">//                 //          S3.            maxSockets: 1024 * 20,        }),    },    region, });</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍ Mempercepat serialisasi JSON</font> </h3><br>  Peningkatan kode S3 telah memperlambat pertumbuhan ukuran tumpukan, tetapi tidak menyebabkan solusi lengkap untuk masalah ini.  Ada gangguan lain yang jelas: menurut metrik kami, langkah kompresi data dalam kode di atas pernah berlangsung 4 menit.  Itu jauh lebih lama dari waktu penyelesaian tugas biasa, yaitu 4 detik.  Tidak mempercayai mata kami, tidak mengerti bagaimana ini bisa memakan waktu 4 menit, kami memutuskan untuk menggunakan tolok ukur lokal dan mengoptimalkan blok kode lambat. <br><br>  Kompresi data terdiri dari tiga tahap (di sini, untuk membatasi penggunaan memori, Node.js <a href="https://nodejs.org/api/stream.html">stream</a> digunakan).  Yaitu, pada tahap pertama, data string JSON dihasilkan, pada tahap kedua, data dikompres menggunakan zlib, pada tahap ketiga, data tersebut dikonversi ke pengkodean base64.  Kami menduga bahwa sumber masalahnya bisa berupa perpustakaan pihak ketiga yang kami gunakan untuk menghasilkan string JSON - <a href="https://www.npmjs.com/package/bfj">bfj</a> .  Kami menulis skrip yang memeriksa kinerja berbagai pustaka untuk menghasilkan data string JSON menggunakan stream (kode yang sesuai dapat ditemukan di <a href="https://gist.github.com/evanlimanto/07670a6eee03149fa149a1c004595a2c">sini</a> ).  Ternyata paket JSON Besar Ramah yang kami gunakan sama sekali tidak ramah.  Lihat saja hasil dari beberapa pengukuran yang diperoleh selama percobaan: <br><br><pre> <code class="javascript hljs">benchBFJ*<span class="hljs-number"><span class="hljs-number">100</span></span>:    <span class="hljs-number"><span class="hljs-number">67652.616</span></span>ms benchJSONStream*<span class="hljs-number"><span class="hljs-number">100</span></span>: <span class="hljs-number"><span class="hljs-number">14094.825</span></span>ms</code> </pre> <br>  Hasil luar biasa.  Bahkan dalam tes sederhana, paket bfj ternyata 5 kali lebih lambat daripada paket lainnya, JSONStream.  Mengetahui hal ini, kami dengan cepat mengubah bfj menjadi <a href="https://www.npmjs.com/package/JSONStream">JSONStream</a> dan segera melihat peningkatan kinerja yang signifikan. <br><br><h3>  <font color="#3AC1EF">▍ Mengurangi waktu yang dibutuhkan untuk pengumpulan sampah</font> </h3><br>  Setelah kami memecahkan masalah dengan memori, kami mulai memperhatikan perbedaan waktu yang diperlukan untuk memproses tugas dengan jenis yang sama antara pekerja reguler dan paralel.  Perbandingan ini benar-benar sah, menurut hasilnya kami dapat menilai efektivitas sistem baru.  Jadi, jika rasio antara pekerja reguler dan paralel adalah sekitar 1, ini akan memberi kami keyakinan bahwa kami dapat mengarahkan lalu lintas ke pekerja ini dengan aman.  Tetapi selama sistem pertama diluncurkan, grafik yang sesuai di panel kontrol Grafana tampak seperti yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ed/110/a81/2ed110a812b69096ee0bc33f5733895e.png"></div><br>  <i><font color="#999999">Rasio waktu pelaksanaan tugas oleh pekerja konvensional dan paralel</font></i> <br><br>  Harap dicatat bahwa kadang-kadang indikatornya berada di wilayah 8: 1, dan ini terlepas dari kenyataan bahwa tingkat rata-rata paralelisasi tugas relatif rendah dan berada di wilayah 30. Kami menyadari bahwa tugas yang kami selesaikan mengenai interaksi dengan bank tidak membuat beban berat pada prosesor.  Kami juga tahu bahwa wadah "paralel" kami tidak dibatasi dengan cara apa pun.  Tidak tahu ke mana harus mencari penyebab masalahnya, kami pergi membaca materi tentang mengoptimalkan proyek Node.js.  Terlepas dari sejumlah kecil artikel semacam itu, kami menemukan materi <a href="https://blog.jayway.com/2015/04/13/600k-concurrent-websocket-connections-on-aws-using-node-js/">ini</a> , yang membahas pencapaian 600 ribu koneksi soket web kompetitif di Node.js. <br><br>  Secara khusus, perhatian kami tertuju pada penggunaan <code>--nouse-idle-notification</code> .  Bisakah proses Node.js kami menghabiskan begitu banyak waktu mengumpulkan sampah?  Ngomong-ngomong, paket gc-stats memberi kami kesempatan untuk melihat waktu rata-rata yang dihabiskan untuk pengumpulan sampah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/f49/cd5/fc8f49cd59c3dd896a332f85f49b7946.png"></div><br>  <i><font color="#999999">Analisis waktu yang dihabiskan untuk pengumpulan sampah</font></i> <br><br>  Ada perasaan bahwa proses kami menghabiskan sekitar 30% dari waktu mengumpulkan sampah menggunakan algoritma Pemulung.  Di sini kita tidak akan menjelaskan detail teknis mengenai berbagai jenis pengumpulan sampah di Node.js.  Jika Anda tertarik dengan topik ini - lihat materi <a href="https://strongloop.com/strongblog/node-js-performance-garbage-collection/">ini</a> .  Inti dari algoritma Scavenge adalah bahwa pengumpulan sampah sering mulai membersihkan memori yang ditempati oleh benda-benda kecil di tumpukan Node.js yang disebut "ruang baru". <br><br>  Jadi, ternyata di Node.js kami proses pengumpulan sampah terlalu sering dimulai.  Bisakah saya menonaktifkan pengumpulan sampah V8 dan menjalankannya sendiri?  Apakah ada cara untuk <a href="https://www.alibabacloud.com/blog/node-js-application-troubleshooting-manual---comprehensive-gc-problems-and-optimization_594965">mengurangi frekuensi</a> panggilan pengumpulan sampah?  Ternyata yang pertama di atas tidak dapat dilakukan, tetapi yang terakhir - itu mungkin!  Kita cukup meningkatkan ukuran area "ruang baru" dengan meningkatkan batas area "ruang semi" di Node.js menggunakan flag baris perintah <code>--max-semi-space-size=1024</code> .  Ini memungkinkan Anda untuk melakukan lebih banyak operasi alokasi memori untuk objek yang berumur pendek hingga V8 memulai pengumpulan sampah.  Akibatnya, frekuensi peluncuran operasi tersebut berkurang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/54b/243/07e54b243db9dc18bed7bc5bdd235d74.png"></div><br>  <i><font color="#999999">Hasil optimasi pengumpulan sampah</font></i> <br><br>  Kemenangan lain!  Peningkatan area "ruang baru" menyebabkan pengurangan yang signifikan dalam jumlah waktu yang dihabiskan untuk pengumpulan sampah menggunakan algoritma Scavenge - dari 30% menjadi 2%. <br><br><h3>  <font color="#3AC1EF">▍Optimasi penggunaan prosesor</font> </h3><br>  Setelah semua pekerjaan ini selesai, hasilnya cocok untuk kami.  Tugas dilakukan pada pekerja paralel, dengan paralelisasi kerja 20 kali, berfungsi hampir secepat yang dilakukan secara terpisah pada pekerja terpisah.  Tampaknya bagi kami bahwa kami telah mengatasi semua kemacetan, tetapi kami masih tidak tahu persis operasi mana yang memperlambat sistem dalam produksi.  Karena tidak ada lagi tempat dalam sistem yang jelas membutuhkan optimasi, kami memutuskan untuk mempelajari bagaimana pekerja menggunakan sumber daya prosesor. <br><br>  Berdasarkan data yang dikumpulkan pada salah satu pekerja paralel kami, jadwal berapi-api dibuat.  Kami memiliki visualisasi yang rapi, yang dapat digunakan pada mesin lokal.  Ya, inilah detail yang menarik: ukuran data ini adalah 60 MB.  Inilah yang kami lihat dengan mencari kata <code>logger</code> di grafik 0x yang berapi-api. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/358/973/efc/358973efca61adf8a654ab855029daea.jpg"></div><br>  <i><font color="#999999">Analisis Data dengan 0x Tools</font></i> <br><br>  Area biru-hijau yang disorot di kolom menunjukkan bahwa setidaknya 15% dari waktu prosesor dihabiskan untuk menghasilkan log pekerja.  Hasilnya, kami dapat mengurangi waktu ini hingga 75%.  Benar, kisah tentang bagaimana kami melakukan ini menarik ke artikel terpisah.  (Petunjuk: kami menggunakan ekspresi reguler dan melakukan banyak pekerjaan dengan properti). <br><br>  Setelah optimasi ini, kami dapat secara bersamaan memproses hingga 30 tugas dalam satu pekerja tanpa merusak kinerja sistem. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Beralih ke pekerja paralel telah mengurangi biaya tahunan untuk EC2 sekitar 300 ribu dolar dan sangat menyederhanakan arsitektur sistem.  Sekarang kami menggunakan dalam produksi sekitar 30 kali lebih sedikit kontainer dari sebelumnya.  Sistem kami lebih tahan terhadap keterlambatan dalam memproses permintaan keluar dan memuncak permintaan API yang berasal dari pengguna. <br><br>  Saat memparalelkan layanan integrasi kami dengan bank, kami belajar banyak hal baru: <br><br><ul><li>  Jangan pernah meremehkan pentingnya memiliki metrik sistem tingkat rendah.  Kemampuan untuk memantau data yang berkaitan dengan pengumpulan sampah dan penggunaan memori telah memberikan kami bantuan luar biasa dalam menyebarkan sistem dan menyelesaikannya. </li><li>  Grafik flaming adalah alat yang hebat.  Sekarang kita telah belajar bagaimana menggunakannya, kita dapat dengan mudah mengidentifikasi kemacetan baru dalam sistem dengan bantuan mereka. </li><li>  Memahami mekanisme runtime Node.js memungkinkan kami untuk menulis kode yang lebih baik.  Sebagai contoh, mengetahui bagaimana V8 mengalokasikan memori untuk objek, dan bagaimana pengumpulan sampah bekerja, kami melihat titik dalam menggunakan teknik reuse objek seluas mungkin.  Terkadang, untuk lebih memahami semua ini, Anda harus bekerja secara langsung dengan V8 atau bereksperimen dengan flag baris perintah Node.js. </li><li>        ,    .     <code>maxSocket</code> ,     Node.js, ,   , ,   AWS   Node.js . ,   ,    ,    . </li></ul><br>  <b>Pembaca yang budiman!</b>     Node.js-? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483688/">https://habr.com/ru/post/id483688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483676/index.html">Penilaian efektivitas dan biaya penerapan sistem analisis pemasaran end-to-end</a></li>
<li><a href="../id483678/index.html">Mengembangkan program Python yang sangat cepat</a></li>
<li><a href="../id483680/index.html">Kelemahan pemrograman umum untuk dihindari</a></li>
<li><a href="../id483684/index.html">PHP Digest No. 171 (1 - 13 Januari 2020)</a></li>
<li><a href="../id483686/index.html">32 tips untuk pengembang web yang ingin tumbuh di atas dirinya pada tahun 2020</a></li>
<li><a href="../id483698/index.html">Cara LoRaWAN Membantu Membangun Internet Modern of Things</a></li>
<li><a href="../id483700/index.html">Hasil Fisik Tahun Ini - 2019</a></li>
<li><a href="../id483704/index.html">Acara digital di Moskow dari 13 hingga 19 Januari</a></li>
<li><a href="../id483706/index.html">Gagasan aplikasi untuk menghasilkan pendapatan untuk startup pada tahun 2019 & lebih</a></li>
<li><a href="../id483712/index.html">HighLoad ++, Yuri Nasretdinov (VK): bagaimana VK memasukkan data ke dalam ClickHouse dari puluhan ribu server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>