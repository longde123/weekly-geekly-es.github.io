<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏿 🏀 ☣️ Apprenez OpenGL. Leçon 7.2 - Dessin de texte 🧛🏼 🈁 ♌️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À un moment donné de votre aventure graphique, vous voudrez sortir du texte via OpenGL. Contrairement à ce à quoi vous pourriez vous attendre, obtenir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprenez OpenGL. Leçon 7.2 - Dessin de texte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473990/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="image" align="left" width="300">  À un moment donné de votre aventure graphique, vous voudrez sortir du texte via OpenGL.  Contrairement à ce à quoi vous pourriez vous attendre, obtenir une simple ligne à l'écran est assez difficile avec une bibliothèque de bas niveau comme OpenGL.  Si vous n'avez pas besoin de plus de 128 caractères différents pour dessiner du texte, ce ne sera pas difficile.  Des difficultés surviennent lorsque les caractères ne correspondent pas à la hauteur, la largeur et le décalage.  Selon l'endroit où vous vivez, vous devrez peut-être plus de 128 caractères.  Mais que faire si vous voulez des caractères spéciaux, des caractères mathématiques ou musicaux?  Dès que vous comprendrez que dessiner du texte n'est pas la tâche la plus simple, vous vous rendrez compte qu'il ne devrait probablement pas appartenir à une API de bas niveau comme OpenGL. </p><br><p> Etant donné qu'OpenGL ne fournit aucun moyen pour rendre le texte, toutes les difficultés de ce cas sont sur nous.  Puisqu'il n'y a pas de "Symbole" primitif graphique, nous devrons l'inventer nous-mêmes.  Il existe déjà des exemples prêts à l'emploi: dessinez un symbole via <code>GL_LINES</code> , créez des modèles 3D de symboles ou dessinez des symboles sur des quadrangles plats dans un espace en trois dimensions. </p><br><p>  Le plus souvent, les développeurs sont <s>trop paresseux pour</s> <s>boire du café et</s> choisissent la dernière option.  Dessiner ces quadrangles texturés n'est pas aussi difficile que de choisir la bonne texture.  Dans ce didacticiel, nous allons apprendre quelques façons et écrire notre rendu de texte avancé mais flexible en utilisant FreeType. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Partie 1. Pour commencer</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création de fenêtres</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour fenêtre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour triangle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Textures</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Systèmes de coordonnées</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appareil photo</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 2. Éclairage de base</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bases d'éclairage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Matériaux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes de texture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources lumineuses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources d'éclairage multiples</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 3. Télécharger des modèles 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bibliothèque Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de polygone de maillage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de modèle 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 4. Fonctionnalités avancées d'OpenGL</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test de profondeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test au pochoir</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mélange de couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Couper les visages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tampon de trame</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes cubiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traitement avancé des données</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GLSL avancé</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shader géométrique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instanciation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lissage</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 5. Éclairage avancé</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Éclairage avancé.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèle Blinn Fong</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correction gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes fantômes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes ombrées omnidirectionnelles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartographie normale</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage de parallaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu différé</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Théorie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources de lumière analytiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Irradiation diffuse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exposition spéculaire</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 7. Pratique</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Débogage</a> </li><li>  <strong>Rendu de texte</strong> </li></ol></div></div></div></div><br><h1 id="klassika-rastrovye-shrifty">  Classique: polices raster </h1><br><p>  Il était une fois <s>à l'époque des dinosaures, le</s> rendu de texte comprenait la sélection d'une police (ou sa création) pour l'application et la copie des caractères souhaités sur une grande texture appelée police bitmap.  Cette texture contient tous les caractères nécessaires dans certaines parties.  Ces caractères sont appelés glyphes.  Chaque glyphe a une zone spécifique de coordonnées de texture qui lui est associée.  Chaque fois que vous dessinez un personnage, vous sélectionnez un glyphe spécifique et dessinez uniquement la partie souhaitée sur un quadrillage plat. </p><br><p><img src="https://habrastorage.org/webt/0q/dd/sm/0qddsmwzcxldp9s0kvohcz2qgea.png"></p><br><p>  Ici vous pouvez voir comment nous rendrions le texte "OpenGL".  Nous prenons la police raster et échantillonnons les glyphes nécessaires à partir de la texture, en choisissant soigneusement les coordonnées de la texture, que nous dessinerons sur plusieurs quadrangles.  En activant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mélange</a> et en maintenant l'arrière-plan transparent, nous obtenons une chaîne de caractères à l'écran.  Cette police bitmap a été générée à l'aide du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">générateur de polices bitmap Codehead</a> . </p><br><p>  Cette approche a ses avantages et ses inconvénients.  Cette approche a une implémentation simple, car les polices bitmap sont déjà tramées.  Cependant, ce n'est pas toujours pratique.  Si vous avez besoin d'une police différente, vous devez générer une nouvelle police bitmap.  De plus, l'augmentation de la taille des caractères affichera rapidement des bords pixellisés.  De plus, les polices bitmap sont souvent liées à un petit ensemble de caractères, donc les caractères Unicode ne seront probablement pas affichés. </p><br><p>  Cette technique était populaire il n'y a pas si longtemps (et conserve toujours sa popularité), car elle est très rapide et fonctionne sur n'importe quelle plate-forme.  Mais à ce jour, il existe d'autres approches pour rendre le texte.  L'un d'eux rend les polices TrueType à l'aide de FreeType. </p><br><h1 id="sovremennost-freetype">  Modernité: FreeType </h1><br><p>  FreeType est une bibliothèque qui télécharge des polices, les rend en bitmaps et prend en charge certaines opérations liées aux polices.  Cette bibliothèque populaire est utilisée sur Mac OS X, Java, Qt, PlayStation, Linux et Android.  La possibilité de charger des polices TrueType rend cette bibliothèque suffisamment attrayante. </p><br><p>  Une police TrueType est une collection de glyphes définis non pas par des pixels, mais par des formules mathématiques.  Comme pour les images vectorielles, une image de police tramée peut être générée en fonction de la taille de police préférée.  En utilisant les polices TrueType, vous pouvez facilement afficher des glyphes de différentes tailles sans perte de qualité. </p><br><p>  FreeType peut être téléchargé sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site officiel</a> .  Vous pouvez soit compiler FreeType vous-même, soit utiliser des versions précompilées, le cas échéant, sur le site.  N'oubliez pas de lier votre programme à <code>freetype.lib</code> et assurez-vous que le compilateur sait où chercher les fichiers d'en-tête. </p><br><p>  Ensuite, joignez les fichiers d'en-tête corrects: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ft2build.h&gt; #include FT_FREETYPE_H</span></span></span></span></code> </pre> <br><blockquote>  Étant donné que FreeType est conçu d'une manière légèrement étrange (au moment de la rédaction de l'original, faites-moi savoir si quelque chose a changé), vous ne pouvez placer ses fichiers d'en-tête qu'à la racine du dossier contenant les fichiers d'en-tête.  La connexion de FreeType d'une autre manière (par exemple, <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> ) peut provoquer un conflit de fichier d'en-tête. </blockquote><p>  Que fait FreeType?  Charge les polices TrueType et génère une image bitmap pour chaque glyphe et calcule certaines métriques de glyphe.  Nous pouvons obtenir des images bitmap pour générer des textures et positionner chaque glyphe en fonction des métriques reçues. </p><br><p>  Pour télécharger une police, nous devons initialiser FreeType et charger la police en tant que visage (comme FreeType appelle la police).  Dans cet exemple, nous chargeons la police TrueType <code>arial.ttf</code> , copiée à partir du dossier C: / Windows / Fonts. </p><br><pre> <code class="cpp hljs">FT_Library ft; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Init_FreeType(&amp;ft)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Could not init FreeType Library"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; FT_Face face; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_New_Face(ft, <span class="hljs-string"><span class="hljs-string">"fonts/arial.ttf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;face)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Failed to load font"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Chacune de ces fonctions FreeType renvoie une valeur différente de zéro en cas d'échec. </p><br><p>  Une fois la <s>police de la</s> face chargée, nous devons spécifier la taille de police souhaitée, que nous allons extraire: </p><br><pre> <code class="cpp hljs">FT_Set_Pixel_Sizes(face, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>);</code> </pre> <br><p>  Cette fonction définit la largeur et la hauteur du glyphe.  En définissant la largeur à 0 (zéro), nous permettons à FreeType de calculer la largeur en fonction de la hauteur définie. </p><br><p>  Face FreeType contient une collection de glyphes.  Nous pouvons <code>FT_Load_Char</code> un glyphe en appelant <code>FT_Load_Char</code> .  Ici, nous essayons de charger le glyphe <code>X</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Load_Char(face, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, FT_LOAD_RENDER)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYTPE: Failed to load Glyph"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  En définissant <code>FT_LOAD_RENDER</code> comme l'un des indicateurs de téléchargement, nous demandons à FreeType de créer une image bitmap en niveaux de gris 8 bits, que nous pouvons ensuite obtenir comme ceci: </p><br><pre> <code class="cpp hljs">face-&gt;glyph-&gt;bitmap;</code> </pre> <br><p>  Les glyphes chargés avec FreeType n'ont pas la même taille que dans le cas des polices bitmap.  Un bitmap généré avec FreeType est la taille minimale pour une taille de police donnée et ne suffit que pour contenir un caractère.  Par exemple, une image bitmap d'un glyphe <code>.</code>  beaucoup plus petit que le bitmap du glyphe <code>X</code>  Pour cette raison, FreeType télécharge également certaines mesures qui montrent quelle taille et où un seul caractère doit être localisé.  Ci-dessous, une image montrant les mesures que FreeType calcule pour chaque glyphe. </p><br><p><img src="https://habrastorage.org/webt/ux/2y/kh/ux2ykhrgznafueqwujrjdqgun9q.png"></p><br><p>  Chaque glyphe est situé sur la ligne de base (ligne horizontale avec une flèche).  Certains sont exactement sur la ligne de base ( <code>X</code> ), certains sont en dessous ( <code>g</code> , <code>p</code> ).  Ces mesures déterminent avec précision les décalages pour positionner avec précision les glyphes sur la ligne de base, ajuster la taille des glyphes et savoir combien de pixels vous devez laisser pour dessiner le glyphe suivant.  Voici une liste des mesures que nous utiliserons: </p><br><ul><li>  <strong>width</strong> : <strong>largeur du</strong> glyphe en pixels, accès par <code>face-&gt;glyph-&gt;bitmap.width</code> </li><li>  <strong>hauteur</strong> : <strong>hauteur du</strong> glyphe en pixels, accès par <code>face-&gt;glyph-&gt;bitmap.rows</code> </li><li>  <strong>portantX</strong> : décalage horizontal du point supérieur gauche du glyphe par rapport à l'origine, accès par <code>face-&gt;glyph-&gt;bitmap_left</code> </li><li>  <strong>portantY</strong> : décalage vertical du point supérieur gauche du glyphe par rapport à l'origine, accès par <code>face-&gt;glyph-&gt;bitmap_top</code> </li><li>  <strong>avance</strong> : décalage horizontal du début du glyphe suivant en 1/64 pixels par rapport à l'origine, accès par <code>face-&gt;glyph-&gt;advance.x</code> </li></ul><br><p>  Nous pouvons charger un glyphe d'un symbole, obtenir ses métriques et générer une texture chaque fois que nous voulons le dessiner à l'écran, mais créer des textures pour chaque symbole sur chaque cadre n'est pas une bonne méthode.  Mieux, nous enregistrerons les données générées quelque part et les demanderons lorsque nous en aurons besoin.  Nous définissons une structure pratique que nous allons stocker dans <code>std::map</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> {</span></span> GLuint TextureID; <span class="hljs-comment"><span class="hljs-comment">// ID   glm::ivec2 Size; //   glm::ivec2 Bearing; //      GLuint Advance; //       }; std::map&lt;GLchar, Character&gt; Characters;</span></span></code> </pre> <br><p>  Dans cet article, nous simplifierons notre vie et n'utiliserons que les 128 premiers caractères.  Pour chaque caractère, nous générerons une texture et enregistrerons les données nécessaires dans une structure de type <code>Character</code> , que nous ajouterons aux <code>Characters</code> type <code>std::map</code> .  Ainsi, toutes les données nécessaires pour dessiner un personnage sont enregistrées pour une utilisation future. </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Disable byte-alignment restriction for (GLubyte c = 0; c &lt; 128; c++) { // Load character glyph if (FT_Load_Char(face, c, FT_LOAD_RENDER)) { std::cout &lt;&lt; "ERROR::FREETYTPE: Failed to load Glyph" &lt;&lt; std::endl; continue; } // Generate texture GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, face-&gt;glyph-&gt;bitmap.buffer ); // Set texture options glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Now store character for later use Character character = { texture, glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows), glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top), face-&gt;glyph-&gt;advance.x }; Characters.insert(std::pair&lt;GLchar, Character&gt;(c, character)); // Characters[c] = character; }</span></span></code> </pre> <br><p>  À l'intérieur de la boucle, pour chacun des 128 premiers caractères, nous obtenons un glyphe, générons une texture, définissons ses paramètres et enregistrons les métriques.  Il est intéressant de noter que nous utilisons <code>GL_RED</code> comme arguments pour <code>internalFormat</code> et <code>format</code> textures.  Un bitmap généré par glyphe est une image en niveaux de gris de 8 bits, dont chaque pixel occupe 1 octet.  Pour cette raison, nous allons stocker le tampon bitmap comme valeur de couleur de texture.  Ceci est réalisé en créant une texture dans laquelle chaque octet correspond à la composante rouge de la couleur.  Si nous utilisons 1 octet pour représenter les couleurs de texture, n'oubliez pas les limitations d'OpenGL: </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  OpenGL nécessite que toutes les textures aient un décalage de 4 octets, c'est-à-dire  leur taille doit être un multiple de 4 octets (par exemple 8 octets, 4000 octets, 2048 octets) ou (et) ils doivent utiliser 4 octets par pixel (comme au format RGBA), mais comme nous utilisons 1 octet par pixel, ils peuvent avoir différents largeur.  En définissant le décalage d'alignement de décompression (y a-t-il une meilleure traduction?) À 1, nous éliminons les erreurs de décalage qui pourraient provoquer des erreurs de segmentation. </p><br><p>  De plus, lorsque nous avons fini de travailler avec la police elle-même, nous devons effacer les ressources FreeType: </p><br><pre> <code class="cpp hljs">FT_Done_Face(face); <span class="hljs-comment"><span class="hljs-comment">//     face FT_Done_FreeType(ft); //   FreeType</span></span></code> </pre> <br><h4 id="sheydery">  Shaders </h4><br><p>  Pour dessiner des glyphes, utilisez le vertex shader suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec4 vertex; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;vec2 pos, vec2 tex_coord&gt; out vec2 TexCoords; uniform mat4 projection; void main() { gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); TexCoords = vertex.zw; }</span></span></span></span></code> </pre> <br><p>  Nous combinons la position du symbole et les coordonnées de texture dans un <code>vec4</code> .  Le vertex shader calcule le produit des coordonnées avec la matrice de projection et transfère les coordonnées de texture au fragment shader: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec2 TexCoords; out vec4 color; uniform sampler2D text; uniform vec3 textColor; void main() { vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); color = vec4(textColor, 1.0) * sampled; }</span></span></code> </pre> <br><p>  Le fragment shader accepte 2 variables globales - une image monochrome du glyphe et la couleur du glyphe lui-même.  Tout d'abord, nous échantillonnons la valeur de couleur du glyphe.  Étant donné que les données de texture sont stockées dans le composant rouge de la texture, nous n'échantillons que le composant <code>r</code> comme valeur de transparence.  En modifiant la transparence de la couleur, la couleur résultante sera transparente à l'arrière-plan du glyphe et opaque aux vrais pixels du glyphe.  Nous multiplions également les couleurs RVB avec la variable textColor pour changer la couleur du texte. </p><br><p>  Mais pour que notre mécanisme fonctionne, vous devez activer le mixage: </p><br><pre> <code class="cpp hljs">glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre> <br><p>  En tant que matrice de projection, nous aurons une matrice de projection orthographique.  Pour dessiner du texte, en fait, une matrice en perspective n'est pas nécessaire et l'utilisation de la projection orthographique nous permet également de définir toutes les coordonnées des sommets en coordonnées d'écran si nous définissons la matrice comme ceci: </p><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>);</code> </pre> <br><p>  Nous définissons le bas de la matrice à <code>0.0f</code> , le haut à la hauteur de la fenêtre.  Par conséquent, la coordonnée <code>y</code> prend des valeurs du bas de l'écran ( <code>y = 0</code> ) vers le haut de l'écran ( <code>y = 600</code> ).  Cela signifie que le point <code>(0, 0)</code> indique et le coin inférieur gauche de l'écran. </p><br><p>  En conclusion, créez VBO et VAO pour dessiner les quadrangles.  Ici, nous réservons suffisamment de mémoire dans VBO pour que nous puissions ensuite mettre à jour les données pour dessiner des caractères. </p><br><pre> <code class="cpp hljs">GLuint VAO, VBO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat) * <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_DYNAMIC_DRAW); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Un quadrilatère plat nécessite 6 sommets de 4 nombres à virgule flottante, nous réservons donc <code>6 * 4 = 24</code> flottants de mémoire.  Puisque nous allons changer les données de sommet assez souvent, nous <code>GL_DYNAMIC_DRAW</code> mémoire en utilisant <code>GL_DYNAMIC_DRAW</code> . </p><br><h4 id="vyvod-stroki-teksta-na-ekran">  Afficher une ligne de texte à l'écran </h4><br><p>  Pour afficher une ligne de texte, nous extrayons la structure de <code>Character</code> correspondant au symbole et calculons les dimensions du quadrilatère à partir des métriques du symbole.  À partir des dimensions calculées du quadrilatère, nous créons à la volée un ensemble de 6 sommets et <code>glBufferSubData</code> jour les données des sommets à l'aide de <code>glBufferSubData</code> . </p><br><p>  Pour plus de commodité, <code>RenderText</code> fonction <code>RenderText</code> qui dessinera une chaîne de caractères: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader &amp;s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Activate corresponding render state s.Use(); glUniform3f(glGetUniformLocation(s.Program, "textColor"), color.x, color.y, color.z); glActiveTexture(GL_TEXTURE0); glBindVertexArray(VAO); // Iterate through all characters std::string::const_iterator c; for (c = text.begin(); c != text.end(); c++) { Character ch = Characters[*c]; GLfloat xpos = x + ch.Bearing.x * scale; GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale; GLfloat w = ch.Size.x * scale; GLfloat h = ch.Size.y * scale; // Update VBO for each character GLfloat vertices[6][4] = { { xpos, ypos + h, 0.0, 0.0 }, { xpos, ypos, 0.0, 1.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos, ypos + h, 0.0, 0.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos + w, ypos + h, 1.0, 0.0 } }; // Render glyph texture over quad glBindTexture(GL_TEXTURE_2D, ch.textureID); // Update content of VBO memory glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBindBuffer(GL_ARRAY_BUFFER, 0); // Render quad glDrawArrays(GL_TRIANGLES, 0, 6); // Now advance cursors for next glyph (note that advance is number of 1/64 pixels) x += (ch.Advance &gt;&gt; 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64) } glBindVertexArray(0); glBindTexture(GL_TEXTURE_2D, 0); }</span></span></code> </pre> <br><p>  Le contenu de la fonction est relativement clair: le calcul de l'origine, des tailles et des sommets du quadrilatère.  Notez que nous avons multiplié chaque métrique par <code>scale</code> .  Après cela, mettez à jour VBO et dessinez un quad. </p><br><p>  Cette ligne de code nécessite une certaine attention: </p><br><pre> <code class="cpp hljs">GLfloat ypos = y - (ch.Size.y - ch.Bearing.y);</code> </pre> <br><p>  Certains caractères, tels que <code>p</code> et <code>g</code> , sont nettement dessinés sous la ligne de base, ce qui signifie que le quad doit être sensiblement inférieur au paramètre <code>y</code> de la fonction <code>RenderText</code> .  Le décalage exact <code>y_offset</code> peut être exprimé à partir des métriques de glyphe: </p><br><p><img src="https://habrastorage.org/webt/2m/kp/g2/2mkpg2lb3jrfhl-zt9elefuopek.png"></p><br><p>  Pour calculer le décalage, nous avons besoin de <s>bras droits pour</s> déterminer la distance à laquelle le symbole est situé sous la ligne de base.  Cette distance est indiquée par la flèche rouge.  Évidemment, <code>y_offset = bearingY - height</code> et <code>ypos = y + y_offset</code> . </p><br><p>  Si tout est fait correctement, vous pouvez afficher le texte à l'écran comme ceci: </p><br><pre> <code class="cpp hljs">RenderText(shader, <span class="hljs-string"><span class="hljs-string">"This is sample text"</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); RenderText(shader, <span class="hljs-string"><span class="hljs-string">"(C) LearnOpenGL.com"</span></span>, <span class="hljs-number"><span class="hljs-number">540.0f</span></span>, <span class="hljs-number"><span class="hljs-number">570.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span>));</code> </pre> <br><p>  Le résultat devrait ressembler à ceci: </p><br><p><img src="https://habrastorage.org/webt/dq/xs/uf/dqxsufeshmfga1wyzr1dl8amjes.png"></p><br><p>  Un exemple de code est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (lien vers le site de l'auteur d'origine). </p><br><p>  Pour comprendre quels quadrangles sont dessinés, désactivez le mélange: </p><br><p><img src="https://habrastorage.org/webt/up/uc/fh/upucfh3hztm2du_zx7uc2wtiaby.png"></p><br><p>  À partir de cette figure, il est évident que la plupart des quadrangles sont au-dessus d'une ligne de base imaginaire, bien que certains caractères, tels que <code>(</code> et <code>p</code> , soient décalés vers le bas. </p><br><h1 id="chto-zhe-dalee">  Et ensuite? </h1><br><p>  Cet article a montré comment rendre les polices TrueType avec FreeType.  Cette approche est flexible, évolutive et efficace sur différents encodages de caractères.  Cependant, cette approche peut être trop lourde pour votre application, car une texture est créée pour chaque personnage.  Les polices bitmap productives sont préférées car nous avons une texture pour tous les glyphes.  La meilleure approche consiste à combiner les deux approches et à tirer le meilleur parti: générer à la volée une police raster à partir de glyphes téléchargés à l'aide de FreeType.  Cela permettra d'économiser le rendu de nombreux changements de texture et, selon le conditionnement de la texture, augmentera les performances. </p><br><p>  Mais FreeType a un autre inconvénient: les glyphes de taille fixe, ce qui signifie qu'à mesure que la taille du glyphe rendu augmente, des étapes peuvent apparaître à l'écran et une fois tourné, le glyphe peut sembler flou.  Valve a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20120815035559/">résolu</a> (lien vers l'archive Web) ce problème il y a plusieurs années en utilisant des champs de distance signés.  Ils s'en sont très bien sortis et l'ont montré sur des applications 3D. </p><br><p>  <strong>PS</strong> : Nous avons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télégramme conf</a> pour la coordination des transferts.  Si vous avez un sérieux désir d'aider à la traduction, alors vous êtes les bienvenus! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473990/">https://habr.com/ru/post/fr473990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473980/index.html">La technologie et le monde réel: 4 start-ups qui changent l'avenir du design d'intérieur</a></li>
<li><a href="../fr473982/index.html">NB-IoT: comment ça marche? Partie 3: SCEF - une fenêtre d'accès unique aux services de l'opérateur</a></li>
<li><a href="../fr473984/index.html">Data Science Digest (octobre 2019)</a></li>
<li><a href="../fr473986/index.html">«Mon rêve est de voir une personne à travers les arbres» - fondatrice de Lisa Alert sur les technologies de recherche modernes</a></li>
<li><a href="../fr473988/index.html">Optimisation de la distribution des serveurs sur les racks</a></li>
<li><a href="../fr473992/index.html">Aperçu des protocoles modernes dans les systèmes d'automatisation industrielle</a></li>
<li><a href="../fr473994/index.html">Chargement de script moderne</a></li>
<li><a href="../fr473998/index.html">Pays-Bas, ou aller-retour</a></li>
<li><a href="../fr474000/index.html">IQBX - concepteur électromécanique pour les cercles et les amateurs de bricolage [idée conceptuelle]</a></li>
<li><a href="../fr474004/index.html">De Norilsk à Riyad: un vrai cas pour les cartes mémoire microSD UHS-I à température industrielle de Kingston</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>