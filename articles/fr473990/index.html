<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèø üèÄ ‚ò£Ô∏è Apprenez OpenGL. Le√ßon 7.2 - Dessin de texte üßõüèº üàÅ ‚ôåÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√Ä un moment donn√© de votre aventure graphique, vous voudrez sortir du texte via OpenGL. Contrairement √† ce √† quoi vous pourriez vous attendre, obtenir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprenez OpenGL. Le√ßon 7.2 - Dessin de texte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473990/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="image" align="left" width="300">  √Ä un moment donn√© de votre aventure graphique, vous voudrez sortir du texte via OpenGL.  Contrairement √† ce √† quoi vous pourriez vous attendre, obtenir une simple ligne √† l'√©cran est assez difficile avec une biblioth√®que de bas niveau comme OpenGL.  Si vous n'avez pas besoin de plus de 128 caract√®res diff√©rents pour dessiner du texte, ce ne sera pas difficile.  Des difficult√©s surviennent lorsque les caract√®res ne correspondent pas √† la hauteur, la largeur et le d√©calage.  Selon l'endroit o√π vous vivez, vous devrez peut-√™tre plus de 128 caract√®res.  Mais que faire si vous voulez des caract√®res sp√©ciaux, des caract√®res math√©matiques ou musicaux?  D√®s que vous comprendrez que dessiner du texte n'est pas la t√¢che la plus simple, vous vous rendrez compte qu'il ne devrait probablement pas appartenir √† une API de bas niveau comme OpenGL. </p><br><p> Etant donn√© qu'OpenGL ne fournit aucun moyen pour rendre le texte, toutes les difficult√©s de ce cas sont sur nous.  Puisqu'il n'y a pas de "Symbole" primitif graphique, nous devrons l'inventer nous-m√™mes.  Il existe d√©j√† des exemples pr√™ts √† l'emploi: dessinez un symbole via <code>GL_LINES</code> , cr√©ez des mod√®les 3D de symboles ou dessinez des symboles sur des quadrangles plats dans un espace en trois dimensions. </p><br><p>  Le plus souvent, les d√©veloppeurs sont <s>trop paresseux pour</s> <s>boire du caf√© et</s> choisissent la derni√®re option.  Dessiner ces quadrangles textur√©s n'est pas aussi difficile que de choisir la bonne texture.  Dans ce didacticiel, nous allons apprendre quelques fa√ßons et √©crire notre rendu de texte avanc√© mais flexible en utilisant FreeType. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des mati√®res</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Partie 1. Pour commencer</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cr√©ation de fen√™tres</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour fen√™tre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour triangle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Textures</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Syst√®mes de coordonn√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appareil photo</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 2. √âclairage de base</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bases d'√©clairage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mat√©riaux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes de texture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources lumineuses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources d'√©clairage multiples</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 3. T√©l√©charger des mod√®les 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Biblioth√®que Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de polygone de maillage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de mod√®le 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 4. Fonctionnalit√©s avanc√©es d'OpenGL</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test de profondeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test au pochoir</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©lange de couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Couper les visages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tampon de trame</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes cubiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traitement avanc√© des donn√©es</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GLSL avanc√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shader g√©om√©trique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instanciation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lissage</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 5. √âclairage avanc√©</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âclairage avanc√©.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mod√®le Blinn Fong</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correction gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes fant√¥mes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes ombr√©es omnidirectionnelles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartographie normale</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage de parallaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu diff√©r√©</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Th√©orie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources de lumi√®re analytiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Irradiation diffuse</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exposition sp√©culaire</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Partie 7. Pratique</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©bogage</a> </li><li>  <strong>Rendu de texte</strong> </li></ol></div></div></div></div><br><h1 id="klassika-rastrovye-shrifty">  Classique: polices raster </h1><br><p>  Il √©tait une fois <s>√† l'√©poque des dinosaures, le</s> rendu de texte comprenait la s√©lection d'une police (ou sa cr√©ation) pour l'application et la copie des caract√®res souhait√©s sur une grande texture appel√©e police bitmap.  Cette texture contient tous les caract√®res n√©cessaires dans certaines parties.  Ces caract√®res sont appel√©s glyphes.  Chaque glyphe a une zone sp√©cifique de coordonn√©es de texture qui lui est associ√©e.  Chaque fois que vous dessinez un personnage, vous s√©lectionnez un glyphe sp√©cifique et dessinez uniquement la partie souhait√©e sur un quadrillage plat. </p><br><p><img src="https://habrastorage.org/webt/0q/dd/sm/0qddsmwzcxldp9s0kvohcz2qgea.png"></p><br><p>  Ici vous pouvez voir comment nous rendrions le texte "OpenGL".  Nous prenons la police raster et √©chantillonnons les glyphes n√©cessaires √† partir de la texture, en choisissant soigneusement les coordonn√©es de la texture, que nous dessinerons sur plusieurs quadrangles.  En activant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©lange</a> et en maintenant l'arri√®re-plan transparent, nous obtenons une cha√Æne de caract√®res √† l'√©cran.  Cette police bitmap a √©t√© g√©n√©r√©e √† l'aide du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©rateur de polices bitmap Codehead</a> . </p><br><p>  Cette approche a ses avantages et ses inconv√©nients.  Cette approche a une impl√©mentation simple, car les polices bitmap sont d√©j√† tram√©es.  Cependant, ce n'est pas toujours pratique.  Si vous avez besoin d'une police diff√©rente, vous devez g√©n√©rer une nouvelle police bitmap.  De plus, l'augmentation de la taille des caract√®res affichera rapidement des bords pixellis√©s.  De plus, les polices bitmap sont souvent li√©es √† un petit ensemble de caract√®res, donc les caract√®res Unicode ne seront probablement pas affich√©s. </p><br><p>  Cette technique √©tait populaire il n'y a pas si longtemps (et conserve toujours sa popularit√©), car elle est tr√®s rapide et fonctionne sur n'importe quelle plate-forme.  Mais √† ce jour, il existe d'autres approches pour rendre le texte.  L'un d'eux rend les polices TrueType √† l'aide de FreeType. </p><br><h1 id="sovremennost-freetype">  Modernit√©: FreeType </h1><br><p>  FreeType est une biblioth√®que qui t√©l√©charge des polices, les rend en bitmaps et prend en charge certaines op√©rations li√©es aux polices.  Cette biblioth√®que populaire est utilis√©e sur Mac OS X, Java, Qt, PlayStation, Linux et Android.  La possibilit√© de charger des polices TrueType rend cette biblioth√®que suffisamment attrayante. </p><br><p>  Une police TrueType est une collection de glyphes d√©finis non pas par des pixels, mais par des formules math√©matiques.  Comme pour les images vectorielles, une image de police tram√©e peut √™tre g√©n√©r√©e en fonction de la taille de police pr√©f√©r√©e.  En utilisant les polices TrueType, vous pouvez facilement afficher des glyphes de diff√©rentes tailles sans perte de qualit√©. </p><br><p>  FreeType peut √™tre t√©l√©charg√© sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site officiel</a> .  Vous pouvez soit compiler FreeType vous-m√™me, soit utiliser des versions pr√©compil√©es, le cas √©ch√©ant, sur le site.  N'oubliez pas de lier votre programme √† <code>freetype.lib</code> et assurez-vous que le compilateur sait o√π chercher les fichiers d'en-t√™te. </p><br><p>  Ensuite, joignez les fichiers d'en-t√™te corrects: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ft2build.h&gt; #include FT_FREETYPE_H</span></span></span></span></code> </pre> <br><blockquote>  √âtant donn√© que FreeType est con√ßu d'une mani√®re l√©g√®rement √©trange (au moment de la r√©daction de l'original, faites-moi savoir si quelque chose a chang√©), vous ne pouvez placer ses fichiers d'en-t√™te qu'√† la racine du dossier contenant les fichiers d'en-t√™te.  La connexion de FreeType d'une autre mani√®re (par exemple, <code>#include &lt;3rdParty/FreeType/ft2build.h&gt;</code> ) peut provoquer un conflit de fichier d'en-t√™te. </blockquote><p>  Que fait FreeType?  Charge les polices TrueType et g√©n√®re une image bitmap pour chaque glyphe et calcule certaines m√©triques de glyphe.  Nous pouvons obtenir des images bitmap pour g√©n√©rer des textures et positionner chaque glyphe en fonction des m√©triques re√ßues. </p><br><p>  Pour t√©l√©charger une police, nous devons initialiser FreeType et charger la police en tant que visage (comme FreeType appelle la police).  Dans cet exemple, nous chargeons la police TrueType <code>arial.ttf</code> , copi√©e √† partir du dossier C: / Windows / Fonts. </p><br><pre> <code class="cpp hljs">FT_Library ft; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Init_FreeType(&amp;ft)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Could not init FreeType Library"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; FT_Face face; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_New_Face(ft, <span class="hljs-string"><span class="hljs-string">"fonts/arial.ttf"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;face)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYPE: Failed to load font"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  Chacune de ces fonctions FreeType renvoie une valeur diff√©rente de z√©ro en cas d'√©chec. </p><br><p>  Une fois la <s>police de la</s> face charg√©e, nous devons sp√©cifier la taille de police souhait√©e, que nous allons extraire: </p><br><pre> <code class="cpp hljs">FT_Set_Pixel_Sizes(face, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>);</code> </pre> <br><p>  Cette fonction d√©finit la largeur et la hauteur du glyphe.  En d√©finissant la largeur √† 0 (z√©ro), nous permettons √† FreeType de calculer la largeur en fonction de la hauteur d√©finie. </p><br><p>  Face FreeType contient une collection de glyphes.  Nous pouvons <code>FT_Load_Char</code> un glyphe en appelant <code>FT_Load_Char</code> .  Ici, nous essayons de charger le glyphe <code>X</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FT_Load_Char(face, <span class="hljs-string"><span class="hljs-string">'X'</span></span>, FT_LOAD_RENDER)) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ERROR::FREETYTPE: Failed to load Glyph"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br><p>  En d√©finissant <code>FT_LOAD_RENDER</code> comme l'un des indicateurs de t√©l√©chargement, nous demandons √† FreeType de cr√©er une image bitmap en niveaux de gris 8 bits, que nous pouvons ensuite obtenir comme ceci: </p><br><pre> <code class="cpp hljs">face-&gt;glyph-&gt;bitmap;</code> </pre> <br><p>  Les glyphes charg√©s avec FreeType n'ont pas la m√™me taille que dans le cas des polices bitmap.  Un bitmap g√©n√©r√© avec FreeType est la taille minimale pour une taille de police donn√©e et ne suffit que pour contenir un caract√®re.  Par exemple, une image bitmap d'un glyphe <code>.</code>  beaucoup plus petit que le bitmap du glyphe <code>X</code>  Pour cette raison, FreeType t√©l√©charge √©galement certaines mesures qui montrent quelle taille et o√π un seul caract√®re doit √™tre localis√©.  Ci-dessous, une image montrant les mesures que FreeType calcule pour chaque glyphe. </p><br><p><img src="https://habrastorage.org/webt/ux/2y/kh/ux2ykhrgznafueqwujrjdqgun9q.png"></p><br><p>  Chaque glyphe est situ√© sur la ligne de base (ligne horizontale avec une fl√®che).  Certains sont exactement sur la ligne de base ( <code>X</code> ), certains sont en dessous ( <code>g</code> , <code>p</code> ).  Ces mesures d√©terminent avec pr√©cision les d√©calages pour positionner avec pr√©cision les glyphes sur la ligne de base, ajuster la taille des glyphes et savoir combien de pixels vous devez laisser pour dessiner le glyphe suivant.  Voici une liste des mesures que nous utiliserons: </p><br><ul><li>  <strong>width</strong> : <strong>largeur du</strong> glyphe en pixels, acc√®s par <code>face-&gt;glyph-&gt;bitmap.width</code> </li><li>  <strong>hauteur</strong> : <strong>hauteur du</strong> glyphe en pixels, acc√®s par <code>face-&gt;glyph-&gt;bitmap.rows</code> </li><li>  <strong>portantX</strong> : d√©calage horizontal du point sup√©rieur gauche du glyphe par rapport √† l'origine, acc√®s par <code>face-&gt;glyph-&gt;bitmap_left</code> </li><li>  <strong>portantY</strong> : d√©calage vertical du point sup√©rieur gauche du glyphe par rapport √† l'origine, acc√®s par <code>face-&gt;glyph-&gt;bitmap_top</code> </li><li>  <strong>avance</strong> : d√©calage horizontal du d√©but du glyphe suivant en 1/64 pixels par rapport √† l'origine, acc√®s par <code>face-&gt;glyph-&gt;advance.x</code> </li></ul><br><p>  Nous pouvons charger un glyphe d'un symbole, obtenir ses m√©triques et g√©n√©rer une texture chaque fois que nous voulons le dessiner √† l'√©cran, mais cr√©er des textures pour chaque symbole sur chaque cadre n'est pas une bonne m√©thode.  Mieux, nous enregistrerons les donn√©es g√©n√©r√©es quelque part et les demanderons lorsque nous en aurons besoin.  Nous d√©finissons une structure pratique que nous allons stocker dans <code>std::map</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class"> {</span></span> GLuint TextureID; <span class="hljs-comment"><span class="hljs-comment">// ID   glm::ivec2 Size; //   glm::ivec2 Bearing; //      GLuint Advance; //       }; std::map&lt;GLchar, Character&gt; Characters;</span></span></code> </pre> <br><p>  Dans cet article, nous simplifierons notre vie et n'utiliserons que les 128 premiers caract√®res.  Pour chaque caract√®re, nous g√©n√©rerons une texture et enregistrerons les donn√©es n√©cessaires dans une structure de type <code>Character</code> , que nous ajouterons aux <code>Characters</code> type <code>std::map</code> .  Ainsi, toutes les donn√©es n√©cessaires pour dessiner un personnage sont enregistr√©es pour une utilisation future. </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Disable byte-alignment restriction for (GLubyte c = 0; c &lt; 128; c++) { // Load character glyph if (FT_Load_Char(face, c, FT_LOAD_RENDER)) { std::cout &lt;&lt; "ERROR::FREETYTPE: Failed to load Glyph" &lt;&lt; std::endl; continue; } // Generate texture GLuint texture; glGenTextures(1, &amp;texture); glBindTexture(GL_TEXTURE_2D, texture); glTexImage2D( GL_TEXTURE_2D, 0, GL_RED, face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, face-&gt;glyph-&gt;bitmap.buffer ); // Set texture options glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // Now store character for later use Character character = { texture, glm::ivec2(face-&gt;glyph-&gt;bitmap.width, face-&gt;glyph-&gt;bitmap.rows), glm::ivec2(face-&gt;glyph-&gt;bitmap_left, face-&gt;glyph-&gt;bitmap_top), face-&gt;glyph-&gt;advance.x }; Characters.insert(std::pair&lt;GLchar, Character&gt;(c, character)); // Characters[c] = character; }</span></span></code> </pre> <br><p>  √Ä l'int√©rieur de la boucle, pour chacun des 128 premiers caract√®res, nous obtenons un glyphe, g√©n√©rons une texture, d√©finissons ses param√®tres et enregistrons les m√©triques.  Il est int√©ressant de noter que nous utilisons <code>GL_RED</code> comme arguments pour <code>internalFormat</code> et <code>format</code> textures.  Un bitmap g√©n√©r√© par glyphe est une image en niveaux de gris de 8 bits, dont chaque pixel occupe 1 octet.  Pour cette raison, nous allons stocker le tampon bitmap comme valeur de couleur de texture.  Ceci est r√©alis√© en cr√©ant une texture dans laquelle chaque octet correspond √† la composante rouge de la couleur.  Si nous utilisons 1 octet pour repr√©senter les couleurs de texture, n'oubliez pas les limitations d'OpenGL: </p><br><pre> <code class="cpp hljs">glPixelStorei(GL_UNPACK_ALIGNMENT, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  OpenGL n√©cessite que toutes les textures aient un d√©calage de 4 octets, c'est-√†-dire  leur taille doit √™tre un multiple de 4 octets (par exemple 8 octets, 4000 octets, 2048 octets) ou (et) ils doivent utiliser 4 octets par pixel (comme au format RGBA), mais comme nous utilisons 1 octet par pixel, ils peuvent avoir diff√©rents largeur.  En d√©finissant le d√©calage d'alignement de d√©compression (y a-t-il une meilleure traduction?) √Ä 1, nous √©liminons les erreurs de d√©calage qui pourraient provoquer des erreurs de segmentation. </p><br><p>  De plus, lorsque nous avons fini de travailler avec la police elle-m√™me, nous devons effacer les ressources FreeType: </p><br><pre> <code class="cpp hljs">FT_Done_Face(face); <span class="hljs-comment"><span class="hljs-comment">//     face FT_Done_FreeType(ft); //   FreeType</span></span></code> </pre> <br><h4 id="sheydery">  Shaders </h4><br><p>  Pour dessiner des glyphes, utilisez le vertex shader suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec4 vertex; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;vec2 pos, vec2 tex_coord&gt; out vec2 TexCoords; uniform mat4 projection; void main() { gl_Position = projection * vec4(vertex.xy, 0.0, 1.0); TexCoords = vertex.zw; }</span></span></span></span></code> </pre> <br><p>  Nous combinons la position du symbole et les coordonn√©es de texture dans un <code>vec4</code> .  Le vertex shader calcule le produit des coordonn√©es avec la matrice de projection et transf√®re les coordonn√©es de texture au fragment shader: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core in vec2 TexCoords; out vec4 color; uniform sampler2D text; uniform vec3 textColor; void main() { vec4 sampled = vec4(1.0, 1.0, 1.0, texture(text, TexCoords).r); color = vec4(textColor, 1.0) * sampled; }</span></span></code> </pre> <br><p>  Le fragment shader accepte 2 variables globales - une image monochrome du glyphe et la couleur du glyphe lui-m√™me.  Tout d'abord, nous √©chantillonnons la valeur de couleur du glyphe.  √âtant donn√© que les donn√©es de texture sont stock√©es dans le composant rouge de la texture, nous n'√©chantillons que le composant <code>r</code> comme valeur de transparence.  En modifiant la transparence de la couleur, la couleur r√©sultante sera transparente √† l'arri√®re-plan du glyphe et opaque aux vrais pixels du glyphe.  Nous multiplions √©galement les couleurs RVB avec la variable textColor pour changer la couleur du texte. </p><br><p>  Mais pour que notre m√©canisme fonctionne, vous devez activer le mixage: </p><br><pre> <code class="cpp hljs">glEnable(GL_BLEND); glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</code> </pre> <br><p>  En tant que matrice de projection, nous aurons une matrice de projection orthographique.  Pour dessiner du texte, en fait, une matrice en perspective n'est pas n√©cessaire et l'utilisation de la projection orthographique nous permet √©galement de d√©finir toutes les coordonn√©es des sommets en coordonn√©es d'√©cran si nous d√©finissons la matrice comme ceci: </p><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::ortho(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">800.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">600.0f</span></span>);</code> </pre> <br><p>  Nous d√©finissons le bas de la matrice √† <code>0.0f</code> , le haut √† la hauteur de la fen√™tre.  Par cons√©quent, la coordonn√©e <code>y</code> prend des valeurs du bas de l'√©cran ( <code>y = 0</code> ) vers le haut de l'√©cran ( <code>y = 600</code> ).  Cela signifie que le point <code>(0, 0)</code> indique et le coin inf√©rieur gauche de l'√©cran. </p><br><p>  En conclusion, cr√©ez VBO et VAO pour dessiner les quadrangles.  Ici, nous r√©servons suffisamment de m√©moire dans VBO pour que nous puissions ensuite mettre √† jour les donn√©es pour dessiner des caract√®res. </p><br><pre> <code class="cpp hljs">GLuint VAO, VBO; glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat) * <span class="hljs-number"><span class="hljs-number">6</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_DYNAMIC_DRAW); glEnableVertexAttribArray(<span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(GLfloat), <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindVertexArray(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Un quadrilat√®re plat n√©cessite 6 sommets de 4 nombres √† virgule flottante, nous r√©servons donc <code>6 * 4 = 24</code> flottants de m√©moire.  Puisque nous allons changer les donn√©es de sommet assez souvent, nous <code>GL_DYNAMIC_DRAW</code> m√©moire en utilisant <code>GL_DYNAMIC_DRAW</code> . </p><br><h4 id="vyvod-stroki-teksta-na-ekran">  Afficher une ligne de texte √† l'√©cran </h4><br><p>  Pour afficher une ligne de texte, nous extrayons la structure de <code>Character</code> correspondant au symbole et calculons les dimensions du quadrilat√®re √† partir des m√©triques du symbole.  √Ä partir des dimensions calcul√©es du quadrilat√®re, nous cr√©ons √† la vol√©e un ensemble de 6 sommets et <code>glBufferSubData</code> jour les donn√©es des sommets √† l'aide de <code>glBufferSubData</code> . </p><br><p>  Pour plus de commodit√©, <code>RenderText</code> fonction <code>RenderText</code> qui dessinera une cha√Æne de caract√®res: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shader &amp;s, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Activate corresponding render state s.Use(); glUniform3f(glGetUniformLocation(s.Program, "textColor"), color.x, color.y, color.z); glActiveTexture(GL_TEXTURE0); glBindVertexArray(VAO); // Iterate through all characters std::string::const_iterator c; for (c = text.begin(); c != text.end(); c++) { Character ch = Characters[*c]; GLfloat xpos = x + ch.Bearing.x * scale; GLfloat ypos = y - (ch.Size.y - ch.Bearing.y) * scale; GLfloat w = ch.Size.x * scale; GLfloat h = ch.Size.y * scale; // Update VBO for each character GLfloat vertices[6][4] = { { xpos, ypos + h, 0.0, 0.0 }, { xpos, ypos, 0.0, 1.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos, ypos + h, 0.0, 0.0 }, { xpos + w, ypos, 1.0, 1.0 }, { xpos + w, ypos + h, 1.0, 0.0 } }; // Render glyph texture over quad glBindTexture(GL_TEXTURE_2D, ch.textureID); // Update content of VBO memory glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBindBuffer(GL_ARRAY_BUFFER, 0); // Render quad glDrawArrays(GL_TRIANGLES, 0, 6); // Now advance cursors for next glyph (note that advance is number of 1/64 pixels) x += (ch.Advance &gt;&gt; 6) * scale; // Bitshift by 6 to get value in pixels (2^6 = 64) } glBindVertexArray(0); glBindTexture(GL_TEXTURE_2D, 0); }</span></span></code> </pre> <br><p>  Le contenu de la fonction est relativement clair: le calcul de l'origine, des tailles et des sommets du quadrilat√®re.  Notez que nous avons multipli√© chaque m√©trique par <code>scale</code> .  Apr√®s cela, mettez √† jour VBO et dessinez un quad. </p><br><p>  Cette ligne de code n√©cessite une certaine attention: </p><br><pre> <code class="cpp hljs">GLfloat ypos = y - (ch.Size.y - ch.Bearing.y);</code> </pre> <br><p>  Certains caract√®res, tels que <code>p</code> et <code>g</code> , sont nettement dessin√©s sous la ligne de base, ce qui signifie que le quad doit √™tre sensiblement inf√©rieur au param√®tre <code>y</code> de la fonction <code>RenderText</code> .  Le d√©calage exact <code>y_offset</code> peut √™tre exprim√© √† partir des m√©triques de glyphe: </p><br><p><img src="https://habrastorage.org/webt/2m/kp/g2/2mkpg2lb3jrfhl-zt9elefuopek.png"></p><br><p>  Pour calculer le d√©calage, nous avons besoin de <s>bras droits pour</s> d√©terminer la distance √† laquelle le symbole est situ√© sous la ligne de base.  Cette distance est indiqu√©e par la fl√®che rouge.  √âvidemment, <code>y_offset = bearingY - height</code> et <code>ypos = y + y_offset</code> . </p><br><p>  Si tout est fait correctement, vous pouvez afficher le texte √† l'√©cran comme ceci: </p><br><pre> <code class="cpp hljs">RenderText(shader, <span class="hljs-string"><span class="hljs-string">"This is sample text"</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">25.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); RenderText(shader, <span class="hljs-string"><span class="hljs-string">"(C) LearnOpenGL.com"</span></span>, <span class="hljs-number"><span class="hljs-number">540.0f</span></span>, <span class="hljs-number"><span class="hljs-number">570.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, glm::vec3(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.9f</span></span>));</code> </pre> <br><p>  Le r√©sultat devrait ressembler √† ceci: </p><br><p><img src="https://habrastorage.org/webt/dq/xs/uf/dqxsufeshmfga1wyzr1dl8amjes.png"></p><br><p>  Un exemple de code est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (lien vers le site de l'auteur d'origine). </p><br><p>  Pour comprendre quels quadrangles sont dessin√©s, d√©sactivez le m√©lange: </p><br><p><img src="https://habrastorage.org/webt/up/uc/fh/upucfh3hztm2du_zx7uc2wtiaby.png"></p><br><p>  √Ä partir de cette figure, il est √©vident que la plupart des quadrangles sont au-dessus d'une ligne de base imaginaire, bien que certains caract√®res, tels que <code>(</code> et <code>p</code> , soient d√©cal√©s vers le bas. </p><br><h1 id="chto-zhe-dalee">  Et ensuite? </h1><br><p>  Cet article a montr√© comment rendre les polices TrueType avec FreeType.  Cette approche est flexible, √©volutive et efficace sur diff√©rents encodages de caract√®res.  Cependant, cette approche peut √™tre trop lourde pour votre application, car une texture est cr√©√©e pour chaque personnage.  Les polices bitmap productives sont pr√©f√©r√©es car nous avons une texture pour tous les glyphes.  La meilleure approche consiste √† combiner les deux approches et √† tirer le meilleur parti: g√©n√©rer √† la vol√©e une police raster √† partir de glyphes t√©l√©charg√©s √† l'aide de FreeType.  Cela permettra d'√©conomiser le rendu de nombreux changements de texture et, selon le conditionnement de la texture, augmentera les performances. </p><br><p>  Mais FreeType a un autre inconv√©nient: les glyphes de taille fixe, ce qui signifie qu'√† mesure que la taille du glyphe rendu augmente, des √©tapes peuvent appara√Ætre √† l'√©cran et une fois tourn√©, le glyphe peut sembler flou.  Valve a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://web.archive.org/web/20120815035559/">r√©solu</a> (lien vers l'archive Web) ce probl√®me il y a plusieurs ann√©es en utilisant des champs de distance sign√©s.  Ils s'en sont tr√®s bien sortis et l'ont montr√© sur des applications 3D. </p><br><p>  <strong>PS</strong> : Nous avons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t√©l√©gramme conf</a> pour la coordination des transferts.  Si vous avez un s√©rieux d√©sir d'aider √† la traduction, alors vous √™tes les bienvenus! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr473990/">https://habr.com/ru/post/fr473990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr473980/index.html">La technologie et le monde r√©el: 4 start-ups qui changent l'avenir du design d'int√©rieur</a></li>
<li><a href="../fr473982/index.html">NB-IoT: comment √ßa marche? Partie 3: SCEF - une fen√™tre d'acc√®s unique aux services de l'op√©rateur</a></li>
<li><a href="../fr473984/index.html">Data Science Digest (octobre 2019)</a></li>
<li><a href="../fr473986/index.html">¬´Mon r√™ve est de voir une personne √† travers les arbres¬ª - fondatrice de Lisa Alert sur les technologies de recherche modernes</a></li>
<li><a href="../fr473988/index.html">Optimisation de la distribution des serveurs sur les racks</a></li>
<li><a href="../fr473992/index.html">Aper√ßu des protocoles modernes dans les syst√®mes d'automatisation industrielle</a></li>
<li><a href="../fr473994/index.html">Chargement de script moderne</a></li>
<li><a href="../fr473998/index.html">Pays-Bas, ou aller-retour</a></li>
<li><a href="../fr474000/index.html">IQBX - concepteur √©lectrom√©canique pour les cercles et les amateurs de bricolage [id√©e conceptuelle]</a></li>
<li><a href="../fr474004/index.html">De Norilsk √† Riyad: un vrai cas pour les cartes m√©moire microSD UHS-I √† temp√©rature industrielle de Kingston</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>