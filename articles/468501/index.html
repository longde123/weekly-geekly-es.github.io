<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçü§ù‚Äçüë®üèΩ üò¶ üë©üèΩ‚Äçüç≥ C√≥mo cre√© un filtro que no corrompe la imagen incluso despu√©s de un mill√≥n de ejecuciones üè¥ ü¶ì üèè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despu√©s de completar la creaci√≥n de la arquitectura web para nuestro nuevo c√≥mic web Meow the Infinite , decid√≠ que era hora de escribir algunos art√≠c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo cre√© un filtro que no corrompe la imagen incluso despu√©s de un mill√≥n de ejecuciones</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468501/">  Despu√©s de completar la creaci√≥n de la arquitectura web para nuestro nuevo c√≥mic web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Meow the Infinite</a> , decid√≠ que era hora de escribir algunos art√≠culos t√©cnicos muy atrasados.  Este art√≠culo se centrar√° en un filtro que desarroll√© hace varios a√±os.  Nunca se ha discutido en el campo de la compresi√≥n de video, aunque me parece que vale la pena hacerlo. <br><br>  En 2011, desarroll√© el "filtro de media capa".  Este es un tipo especial de filtro que toma una imagen entrante y muestra de manera convincente c√≥mo se ver√≠a la imagen cuando se desplaza <i>exactamente medio p√≠xel</i> . <br><br>  Probablemente se est√© preguntando por qu√© tal filtro puede ser necesario.  De hecho, son bastante comunes en los c√≥decs de video modernos.  Los c√≥decs de video usan filtros similares para tomar fragmentos de cuadros anteriores y usarlos en cuadros posteriores.  Los c√≥decs m√°s antiguos movieron los datos del cuadro solo un p√≠xel completo a la vez, pero los nuevos c√≥decs fueron m√°s all√° y permitieron un desplazamiento de medio o incluso un cuarto de p√≠xel para transmitir mejor peque√±os movimientos. <br><br>  Al analizar el comportamiento de los algoritmos de compensaci√≥n de movimiento en los filtros de halfpel tradicionales, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jeff Roberts</a> descubri√≥ que cuando se aplican repetidamente a cuadros secuenciales, se degradan r√°pidamente, obligando a otras partes del compresor de video a usar m√°s datos de los necesarios para corregir los artefactos.  Si deshabilita estas correcciones y observa los resultados "en bruto" del filtro de halfpel, esta es la imagen original: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br>  se convierte en esto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  solo un segundo despu√©s el video.  Como deber√≠a, se desplaza hacia un lado, porque cada cuadro desplaz√≥ la imagen medio p√≠xel.  Pero el resultado no parece una versi√≥n desplazada de la imagen original, est√° muy distorsionada. <br><a name="habracut"></a><br>  Durante el "video de un segundo", el filtro se aplica muchas veces, 60 si el video se reproduce a una frecuencia de 60 cuadros por segundo.  Pero idealmente, necesitamos filtros que sean resistentes a tales distorsiones.  Si los tuvi√©ramos, los videos de desplazamiento suave no habr√≠an sido codificados con tantas correcciones de artefactos, lo que los habr√≠a hecho menos, o mejor, o ambos. <br><br>  Si est√° familiarizado con el campo de la compresi√≥n de video, es posible que se pregunte por qu√© incluso necesitamos usar el filtro de halfpel m√°s de una vez.  Al final, si aplicamos el filtro de halfpel dos veces, entonces ya moveremos un p√≠xel completo, entonces, ¬øpor qu√© no usar los datos de <i>dos</i> cuadros hacia atr√°s y simplemente tomarlos? <br><br>  La respuesta no es tan simple.  En primer lugar, cuantos m√°s datos necesitemos para codificarlos, menos compresi√≥n obtendremos.  Por lo tanto, si comenzamos a codificar sin la necesidad de demasiados datos, como "de qu√© fotograma tomar datos", el video no se comprimir√° muy bien. <br><br>  Pero esto no es lo m√°s importante.  El principal problema es que si necesitamos tomar informaci√≥n de marcos anteriores, tendremos <i>que almacenarlos</i> .  Para preservar los dos cuadros anteriores, en lugar de uno, debe adivinar que tiene el doble de memoria.  Para las CPU modernas, este no es un problema especial, tienen mucha memoria y tal problema no les molesta.  Pero esto es un <i>problema</i> para usted si desea crear un formato de video r√°pido, port√°til y ampliamente utilizado que deber√≠a funcionar en dispositivos con una peque√±a cantidad de memoria (tel√©fonos m√≥viles, dispositivos electr√≥nicos integrados, etc.). <br><br>  Realmente no queremos almacenar varios cuadros para compensar el movimiento, simplemente para no usar un filtro de halfpel.  Por lo tanto, se me indic√≥ que averiguara qu√© est√° sucediendo exactamente aqu√≠ y que averig√ºe si puedo crear un filtro que no tenga tales problemas. <br><br>  Antes de eso, nunca hab√≠a trabajado con filtros y no ten√≠a idea de c√≥mo se desarrollan habitualmente.  Por extra√±o que parezca, result√≥ estar a mi favor, porque tuve que mirar este problema sin prejuicios. <br><br><h2>  Los fundamentos </h2><br>  R√°pidamente me di cuenta de que los filtros halfpel m√°s populares tienen una estructura similar: para cada p√≠xel en la imagen de salida, se toman de 2 a 8 p√≠xeles de la imagen de entrada, que se muestrean y mezclan con ciertos coeficientes.  Los diferentes filtros difieren solo en el n√∫mero de p√≠xeles de origen muestreados (a menudo en la jerga de los desarrolladores de filtros se les llama tap) y los factores de mezcla de p√≠xeles.  Estos coeficientes a menudo se denominan "n√∫cleo de filtro" y eso es todo lo que se necesita para describir completamente el filtro. <br><br>  Si est√° familiarizado con alg√∫n tipo de muestreo o remuestreo de im√°genes (por ejemplo, escalar im√°genes), entonces esto deber√≠a estar claro para usted.  Esencialmente, los filtros hacen lo mismo.  Dado que la compresi√≥n de video es un √°rea extensa en la que se llevan a cabo varios estudios, es obvio que hay muchas <i>otras</i> formas de compensar el movimiento adem√°s del simple filtrado.  Pero los c√≥decs comunes usualmente usan procedimientos de compensaci√≥n de movimiento con filtros de halfpel, que son esencialmente id√©nticos a los filtros de escala de imagen: simplemente toman los p√≠xeles originales, los multiplican por algunos pesos, los agregan y obtienen los p√≠xeles de salida. <br><br><h2>  La necesidad de "nitidez" </h2><br>  Entonces, necesitamos cambiar la imagen por medio p√≠xel.  Si usted es un programador de gr√°ficos, pero no est√° particularmente familiarizado con el filtrado, podr√≠a pensar: "Tambi√©n tengo un problema, solo use un filtro bilineal".  Este es un proceso est√°ndar para trabajar con gr√°ficos, cuando necesitamos calcular valores intermedios entre dos elementos de datos entrantes, como sucede aqu√≠. <br><br>  El siguiente n√∫cleo de filtro puede describir f√°cilmente un filtro bilineal para mover exactamente medio p√≠xel: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Simple bilinear filter BilinearKernel[] = {1.0/2.0, 1.0/2.0};</span></span></code> </pre> <br>  Esto funcionar√°, pero no sin problemas.  Si su objetivo es im√°genes de alta calidad, y en el caso de la compresi√≥n de video, el objetivo es solo eso, entonces un filtro bilineal no es la mejor soluci√≥n, ya que agrega m√°s desenfoque al resultado del necesario.  No es <i>tanto</i> , pero crea <i>m√°s</i> que otros filtros. <br><br>  Para mostrar esto claramente, aqu√≠ hay una imagen aproximada del ojo de la morsa de la imagen original despu√©s de una sola aplicaci√≥n de los filtros m√°s comunes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b0/97d/17e/1b097d17ed0bf71252e43527442a852b.png" width="670" height="140"></div><br>  A la izquierda est√° el original, a la derecha est√° el filtrado bilineal.  Entre ellos se encuentran los filtros halfpel m√°s utilizados de c√≥decs de video.  Si observa de cerca, puede ver que casi todas las im√°genes son similares, <i>excepto una</i> bilineal, que es un poco m√°s borrosa.  Aunque el desenfoque no es tanto, si su objetivo principal es la calidad de imagen, esto es suficiente para preferir un filtro diferente al filtro bilineal. <br><br>  Entonces, ¬øc√≥mo otros filtros "mantienen" la nitidez y evitan el desenfoque?  Recordemos c√≥mo se ve el n√∫cleo del desenfoque bilineal: <br><br><pre> <code class="cpp hljs">BilinearKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.0</span></span>};</code> </pre> <br>  Es muy simple  Para cambiar la imagen a medio p√≠xel, tomamos un p√≠xel y lo mezclamos al 50% con su vecino.  Eso es todo  Uno puede imaginar c√≥mo esto "difumina" la imagen, porque en aquellos lugares donde el p√≠xel blanco brillante est√° adyacente al negro oscuro, estos dos p√≠xeles se promedian durante el filtrado bilineal, creando un p√≠xel gris que "suaviza" el borde.  Esto sucede con cada p√≠xel, as√≠ que literalmente cada √°rea donde hay una clara diferencia en color o brillo.  suavizado <br><br>  Es por eso que en los c√≥decs de alta calidad, el filtrado bilineal no se usa para la compensaci√≥n de movimiento (aunque puede usarse en otros casos).  En cambio, se utilizan filtros que conservan la nitidez, por ejemplo, como: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Half-pel filters for the industry-standard h.264 and HEVC video codecs h264Kernel[] = {1.0/32.0, -5.0/32.0, 20.0/32.0, 20.0/32.0, -5.0/32.0, 1.0/32.0}; HEVCKernel[] = {-1.0/64.0, 4.0/64.0, -11.0/64.0, 40.0/64.0, 40/64.0, -11.0/64.0, 4.0/64.0, -1.0/64.0};</span></span></code> </pre> <br>  Como puede ver, donde el filtrado bilineal tuvo en cuenta solo dos p√≠xeles, estos filtros tienen en cuenta seis (h.264) o incluso ocho (HEVC) p√≠xeles.  Adem√°s, no solo calculan los valores promedio ponderados habituales de estos p√≠xeles, sino que usan pesos <i>negativos</i> para algunos p√≠xeles para <i>restar</i> estos p√≠xeles de otros valores. <br><br>  ¬øPor qu√© est√°n haciendo esto? <br><br>  En realidad, no es dif√≠cil entender esto: utilizando valores positivos y negativos, y tambi√©n considerando una "ventana" m√°s amplia, el filtro puede tener en cuenta la <i>diferencia</i> entre p√≠xeles adyacentes y simular la nitidez de los dos p√≠xeles m√°s cercanos en relaci√≥n con sus vecinos m√°s lejanos.  Esto le permite mantener la nitidez del resultado de la imagen en aquellos lugares donde los p√≠xeles difieren significativamente de sus vecinos, mientras que el promedio todav√≠a se usa para crear valores cre√≠bles de cambios de "medio p√≠xel", que necesariamente deben reflejar la combinaci√≥n de p√≠xeles de la imagen entrante. <br><br><h2>  Filtrado inestable </h2><br>  Entonces, ¬øse resuelve el problema?  S√≠, es posible, pero si solo necesita hacer un desplazamiento de medio p√≠xel.  Sin embargo, estos filtros de "afilado" (y uso este t√©rmino aqu√≠ intencionalmente) en realidad hacen algo peligroso, <i>esencialmente similar</i> a lo que hace el filtrado bilineal.  Simplemente saben c√≥mo esconderlo. <br><br>  Cuando el filtrado bilineal <i>reduce la</i> nitidez de la imagen, estos filtros est√°ndar la <i>aumentan</i> , como la operaci√≥n de nitidez en alg√∫n tipo de programa gr√°fico.  La cantidad de nitidez es muy peque√±a, por lo que si ejecutamos el filtro solo una vez, no lo notaremos.  Pero si el filtrado se realiza varias veces, esto puede volverse muy notable. <br><br>  Y, desafortunadamente, dado que este enfoque es de procedimiento y depende de la diferencia entre los p√≠xeles, <i>crea un ciclo de retroalimentaci√≥n</i> que continuar√° enfocando el mismo borde una y otra vez hasta que destruya la imagen.  Puede mostrar esto con ejemplos espec√≠ficos. <br><br>  Arriba, la imagen original, abajo, con filtrado bilineal, realizado en m√°s de 60 cuadros: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br>  Como es de esperar, el desenfoque simplemente contin√∫a reduciendo la nitidez de la imagen hasta que se vuelve bastante borrosa.  Ahora el original estar√° en la parte superior y el filtro de halfpel de c√≥dec h.264 que se ejecutar√° durante 60 fotogramas en la parte inferior: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br>  ¬øVes toda esta basura?  El filtro hizo lo mismo que el efecto de "desenfoque" del filtrado bilineal, pero <i>viceversa</i> : "aument√≥ la nitidez de la imagen" para que todas las partes donde los detalles se convirtieron en patrones de luz / oscuridad fuertemente distorsionados. <br><br>  ¬øEl c√≥dec HEVC que usa 8 p√≠xeles se comporta mejor?  Bueno, definitivamente funciona mejor que h.264: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  pero si aumentamos el tiempo de 60 cuadros (1 segundo) a 120 cuadros (2 segundos), todav√≠a veremos que hay comentarios y la imagen se destruye: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Por el bien de aquellos a quienes les gusta el procesamiento de se√±ales, agregar√© un filtro de ventana sinc (llamado filtro Lanczos) como referencia: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// NOTE(casey): Traditional 6-tap Lanczos filter LanczosKernel[] = {0.02446, -0.13587, 0.61141, 0.61141, -0.13587, 0.02446};</span></span></code> </pre> <br>  No explicar√© en este art√≠culo por qu√© alguien podr√≠a estar interesado en la "ventana sinc", pero basta con decir que este filtro es popular por razones te√≥ricas, as√≠ que mire c√≥mo se ve al procesar 60 cuadros (1 segundo): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br>  y al procesar 120 cuadros (2 segundos): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br>  Mejor que h.264, y casi lo mismo que HEVC. <br><br><h2>  Filtrado estable </h2><br>  ¬øC√≥mo podemos lograr mejores resultados que h.264, HEVC y sinc en ventana?  ¬øY cu√°nto mejor pueden ser? <br><br>  <i>Esperar√≠a</i> ver preguntas similares en la literatura sobre compresi√≥n de video y deber√≠an ser bien conocidas por los especialistas en compresi√≥n, pero de hecho (al menos para 2011) no encontr√© a nadie que al menos dijera que esto era un problema.  As√≠ que tuve que encontrar una soluci√≥n solo. <br><br>  Afortunadamente, el enunciado del problema es muy simple: cree un filtro que pueda aplicarse tantas veces como sea posible para que la imagen tenga el mismo aspecto que al principio. <br><br>  Llamo a esta definici√≥n "filtrado estable" porque, en mi opini√≥n, puede considerarse una propiedad de filtro.  Un filtro es "estable" si no cae en su ciclo de retroalimentaci√≥n, es decir, puede aplicarse repetidamente sin crear artefactos.  Un filtro es "inestable" si crea artefactos que se amplifican con el uso repetido y eventualmente destruyen la imagen. <br><br>  Repito, no entiendo por qu√© este tema no se considera en la literatura sobre c√≥decs de video o procesamiento de im√°genes.  Quiz√°s usa una terminolog√≠a diferente, pero no la he cumplido.  El concepto de "retroalimentaci√≥n" est√° bien establecido en el campo del trabajo con sonido.  pero no es un problema importante en el procesamiento de im√°genes.  ¬øQuiz√°s porque los filtros deber√≠an aplicarse solo una vez? <br><br>  Si fuera un especialista en este campo, lo m√°s probable es que tuviera una opini√≥n sobre este tema, y ‚Äã‚Äãtal vez incluso conocer√≠a esos rincones de la literatura especializada donde ya hay soluciones a este problema, que pocos conocen.  Pero, como dije al comienzo del art√≠culo, nunca antes hab√≠a podido crear filtros, as√≠ que busqu√© solo en art√≠culos conocidos (aunque vale la pena se√±alar que hay al menos una persona conocida en la literatura que tampoco ha escuchado algo as√≠) ) <br><br>  Entonces, en la ma√±ana me dijeron que necesit√°bamos este filtro, y todo el d√≠a intent√© crearlo.  Mi enfoque era simple: cre√© un programa que ejecutaba el filtro cientos de veces y al final produje una imagen para poder ver el resultado de largas ejecuciones.  Luego experiment√© con diferentes coeficientes de filtro y observ√© los resultados.  Fue literalmente un proceso direccional de prueba y error. <br><br>  Aproximadamente una hora despu√©s, recog√≠ los mejores coeficientes de filtro adecuados para esta tarea (pero ten√≠an un defecto, que discutiremos en la segunda parte del art√≠culo): <br><br><pre> <code class="cpp hljs">MyKernel[] = {<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">19.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">-4.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">32.0</span></span>};</code> </pre> <br>  Este n√∫cleo est√° a punto de afilarse y difuminarse.  Dado que la nitidez siempre conduce a la retroalimentaci√≥n que crea artefactos v√≠vidos y obvios, este n√∫cleo de filtro prefiere un poco de desenfoque para que la imagen se vea un poco m√°s "opaca". <br><br>  As√≠ es como se ve despu√©s de 60 cuadros.  Como referencia, mostr√© todos los filtros en este orden: la imagen original (sin filtrado), mi filtro, bilineal, Lanczos, h.264, HEVC: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/c7e/cd1/fc8c7ecd131c285b080ca8c6375c66b5.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/346/0d9/d18/3460d9d18c2e74e79980d1ead799d7c4.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a46/5ce/35c/a465ce35c2009cc7cfd8ebfc2959748c.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a3/3f7/605/2a33f7605ba0b5456d11881f24be8226.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/337/309/98e/33730998e411bb57ad5e38bb835cf7e1.png" width="1000" height="284"></div><br>  Como puede ver, mi filtro proporciona resultados ligeramente m√°s borrosos que los filtros de nitidez, pero no tiene artefactos de nitidez inaceptables despu√©s de 60 cuadros.  Sin embargo, es posible que prefiera desenfocar los artefactos para agudizar los artefactos, por lo que puede elegir entre el mejor filtro de nitidez (Lanczos) y el m√≠o.  Sin embargo, si aumentamos el n√∫mero a 120 cuadros, entonces mi filtro est√° fuera de competencia: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44a/a48/c5e/44aa48c5ef416f191097379547061625.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a13/3a5/f66/a133a5f66fa5ddd6d5a9073a23f02b2e.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b8/f55/da5/3b8f55da553059f6639982098c75f148.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/410/92a/849/41092a8499f2ea7beab529cdeca274bc.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/95c/672/b35/95c672b35482ac260a4ed0bbf10d7833.png" width="1000" height="284"></div><br>  Despu√©s de 300 cuadros, todos los filtros, excepto el m√≠o, se convierten en una broma de mal gusto: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d2/1ca/007/2d21ca007ccba46c3a9427dd767d6fb7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/816/ca3/619/816ca36196d48266af8218a585744068.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de4/45d/377/de445d3777d9d35e988585af3f83581f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c5/0e4/31f/5c50e431ff7a624e078fe95479cafbe2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d9/ac8/5b7/8d9ac85b768064dfaacd5bdb8019b8c5.png" width="1000" height="284"></div><br>  Despu√©s de 600 fotogramas, la broma se vuelve a√∫n m√°s cruel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f23/69e/d51/f2369ed51c63439be8c3281c706e10d7.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/544/b61/344544b6152756bcdce564d58ee61cc0.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/536/25d/943/53625d9435b36876edf087a753a63c61.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55d/32c/66a/55d32c66a716e40c2826bd5150e3e34f.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4f5/b92/c95/4f5b92c95825178ca0ce82320c37a2bc.png" width="1000" height="284"></div><br>  Ni siquiera tiene que decir qu√© sucede despu√©s de 900 fotogramas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb6/4a0/8c8/cb64a08c837e77581726d7d7200982f2.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09c/46f/617/09c46f617c7dfe04b5cb7e7c1010ba62.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1c/f58/7a4/b1cf587a4ceea34f13f97bece1f70a07.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/271/860/34d/27186034d68d111643b325559a3d5b13.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/ac6/d55/f9dac6d551ef448f6b8a042a43af17b6.png" width="1000" height="284"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/32e/742/9dd/32e7429dd6fa7f0d704f40d28e92e0dc.png" width="1000" height="284"></div><br><h2>  ¬øQu√© tan estable es? </h2><br>  En esta etapa, naturalmente se preguntar√°: ¬ømi filtro es <i>realmente</i> estable o es simplemente un desenfoque muy lento, mucho m√°s lento que el filtrado bilineal?  ¬øQuiz√°s despu√©s de miles de repeticiones, mi filtro borrar√° <i>gradualmente</i> la imagen? <br><br>  Sorprendentemente, la respuesta parece ser negativa.  Aunque se agrega un poco de desenfoque en el transcurso de aproximadamente cien de las primeras superposiciones, parece que el filtro <i>converge</i> en una representaci√≥n estable de la imagen, que <i>nunca se</i> degrada.  Aqu√≠ hay otra imagen ampliada de un ojo de morsa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4a/26d/19f/e4a26d19f9ba6142ab7c45aeaea765ec.png" width="768" height="128"></div><br>  De izquierda a derecha: la imagen original, mi filtro aplicado 60 veces, 120 veces, 300 veces, 600 y 900 veces.  Como puede ver, el desenfoque converge a un estado estable, que ya no se degrada incluso despu√©s de cientos de superposiciones de filtros.  Por el contrario, compare esto con la sincronizaci√≥n en ventana para el mismo n√∫mero de muestras (toque), y vea qu√© tan malo (¬°y r√°pido!) Los artefactos forman la retroalimentaci√≥n y crean un resultado in√∫til: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/122/2ff/2f2/1222ff2f2fe380cfab03df453f06ce2f.png" width="768" height="128"></div><br>  Mi filtro parece muy estable y, en comparaci√≥n con todos los filtros que he visto, crea los mejores resultados despu√©s de un uso repetido.  Parece que tiene una cierta propiedad "asint√≥tica", en la que los datos convergen r√°pidamente a una imagen suavizada (limitada), y luego esta imagen suavizada se guarda y no realiza una degradaci√≥n ilimitada para completar la basura. <br><br>  Incluso intent√© aplicar el filtro un <i>mill√≥n de</i> veces, y parece que despu√©s de los primeros cientos de superposiciones no se degrada m√°s.  Sin un mejor an√°lisis matem√°tico (y a√∫n no he encontrado una soluci√≥n matem√°tica que pueda probarlo exactamente, pero estoy seguro de que est√° en alg√∫n lugar), no puedo decir con certeza que en alg√∫n lugar despu√©s de miles de millones o billones de superposiciones que -no se romper√°.  Dentro de las pruebas razonables, no pude detectar una mayor degradaci√≥n. <br><br><h2>  ¬øEs el mejor filtro Halfpel estable para seis toques? </h2><br>  En esta etapa, ser√≠a l√≥gico hacer la pregunta: ¬øes esto realmente lo mejor que se puede encontrar?  La intuici√≥n nos dice que no, porque no ten√≠a absolutamente ning√∫n conocimiento sobre el desarrollo de filtros y casi no busqu√© en la literatura, recog√≠ este filtro en solo una hora.  Al menos se puede <i>suponer</i> que despu√©s de un estudio tan breve, no habr√≠a encontrado un filtro definitivo, el mejor, el mejor conquistador. <br><br>  ¬øEs cierto este supuesto?  Y si es cierto, <i>¬øcu√°l</i> ser√° el mejor filtro final?  Discutir√© esto con m√°s detalle en la segunda parte del art√≠culo. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468501/">https://habr.com/ru/post/468501/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468487/index.html">Qu√© puede suceder (vectores de ataque t√≠picos)</a></li>
<li><a href="../468489/index.html">Contrabando de solicitudes HTTP: nuevos enfoques</a></li>
<li><a href="../468491/index.html">La maldici√≥n k√°rmica de Habra</a></li>
<li><a href="../468493/index.html">La estructura de la vista a√©rea del proyecto Data Science</a></li>
<li><a href="../468497/index.html">Temporizador de cepillado temporizado de 3 minutos</a></li>
<li><a href="../468503/index.html">El correo no va m√°s all√° de 500 millas - Preguntas frecuentes</a></li>
<li><a href="../468509/index.html">Desarrollo de sistemas operativos tipo Unix: controladores de dispositivos de caracteres (8)</a></li>
<li><a href="../468511/index.html">Publicar un servidor a trav√©s de una puerta de enlace D-Link DFL</a></li>
<li><a href="../468515/index.html">Consejos √∫tiles para la integraci√≥n en nuevos proyectos.</a></li>
<li><a href="../468517/index.html">2. Descripci√≥n general del soporte t√©cnico y la garant√≠a de Extreme Networks Switch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>