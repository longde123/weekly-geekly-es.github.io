<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍💻 🔏 🧟 Maulwurfslöcher in JavaScript 🔰 🌳 🙉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich präsentiere Ihnen die Übersetzung des Artikels "Wurmlöcher in JavaScript" von Mathius Buus. 





 Computer sind interessante Maschine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maulwurfslöcher in JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428201/"><p>  Hallo Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wurmlöcher in JavaScript"</a> von Mathius Buus. </p><br><p><img src="https://habrastorage.org/webt/ak/t9/k_/akt9k_w0hs5lodk-p8ezfr4f6pk.jpeg"></p><br><p>  Computer sind interessante Maschinen.  Theoretisch scheinen sie uns ideale mechanische Mathematiker zu sein, die mit Zahlen arbeiten und Operationen der Addition, Multiplikation und Subtraktion gut ausführen. </p><br><p>  Eine solche Abstraktion ist jedoch ziemlich irreführend.  Es nimmt uns vom Verständnis ab, dass ein Computer verschiedene mathematische Operationen mit unterschiedlichen Geschwindigkeiten verarbeitet.  Wenn Sie in JavaScript (oder einer anderen Sprache) schreiben und sich um die Leistung der von Ihnen geschriebenen Algorithmen kümmern, ist es sehr wichtig zu verstehen, wie Computer unter der Haube funktionieren. </p><br><p> Wenn wir wissen, wozu der Computer in der Lage ist, können wir die kürzesten Wege oder Wurmlöcher verwenden, um unsere Programme viel schneller als erwartet zu machen. </p><a name="habracut"></a><br><h2 id="krotovaya-nora-v-operacii-polucheniya-ostatka-ot-deleniya">  Wurmloch bei der Beschaffung des Restes der Division </h2><br><p>  Was genau bedeutet das?  Schauen wir uns ein Beispiel an: Stellen Sie sich vor, wir möchten eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ringliste</a> implementieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Ringliste</a> ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste</a> mit fester Größe, in der Einfügungen, die größer als die Größe der Liste sind, an den Anfang der Liste und in einen Kreis verschoben werden.  Ringlisten sind für viele Dinge sehr praktisch - zum Beispiel für das Sammeln von Statistiken für bestimmte Zeitintervalle, das Puffern von Daten und mehr. Sehen Sie sich jedoch diese Implementierung an: </p><br><pre><code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-number"><span class="hljs-number">15000</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  % -   ,     //        //    ,     i    list[i % list.length] = item }</span></span></code> </pre> <br><p>  Wie schnell wird dieser Code ausgeführt?  Lassen Sie uns einen einfachen Geschwindigkeitstest durchführen </p><br><pre> <code class="hljs matlab">console.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1e9</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { set(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) } console.timeEnd()</code> </pre><br><p>  Auf meinem Computer dauerte es ~ 4 Sekunden für 1 Milliarde Beilagen.  Nicht schlecht. </p><br><p>  Wenden wir jedoch ein rechnerisches Wurmloch an und ändern die Größe des Arrays in eine magische Zahl: </p><br><pre> <code class="hljs powershell">//     <span class="hljs-number"><span class="hljs-number">15000</span></span>  <span class="hljs-number"><span class="hljs-number">16384</span></span> const list = new Array(<span class="hljs-number"><span class="hljs-number">16384</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span></span> { //  % -   ,     //        //    ,     i    list[<span class="hljs-type"><span class="hljs-type">i</span></span> % <span class="hljs-type"><span class="hljs-type">list.length</span></span>] = item }</code> </pre><br><p>  Versuchen wir erneut, den Leistungstest auszuführen.  Auf meinem Computer wurde der Test in ~ 1,5 Sekunden abgeschlossen.  Mehr als doppelte Erhöhung durch einfache Größenänderung.  Um zu verstehen, warum dies geschieht, müssen wir Folgendes verstehen: Unter der Haube arbeitet der Computer mit Zahlen mit Basis 2. Es ist wichtig zu wissen, ob wir den Rest der Division erhalten (Operation%).  Eine solche Berechnung ist viel einfacher, wenn die Zahl ein Vielfaches von 2 (2 ^ n) b 16384 ist, es ist 2 ^ 14. Tatsächlich betrachtet der Computer die Zahl in binärer Form und nimmt einfach die letzten n Bits. </p><br><p>  Zum Beispiel: Was passiert, wenn eine solche Operation ausgeführt wird? 353 500% 16 384?  353 500 in binärer Darstellung sieht aus wie 1010110010011011100. Seit 16384 == 2 ^ 14 - müssen wir die letzten 14 Bits nehmen - 10101 (10010011011100) oder 9 346. </p><br><p>  Wir können dieses Wissen in Bezug auf ein anderes Wurmloch verwenden.  Für einen Computer ist es sehr einfach und schnell, die letzten n Bits zu nehmen.  Tatsächlich ist es nur notwendig, binär und (Operation &amp;) mit der Zahl (2 ^ n) - 1 zu erzeugen </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-number"><span class="hljs-number">16384</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    &amp;( )  %    2 ^ n list[i &amp; (list.length - 1)] = i }</span></span></code> </pre> <br><p>  Wenn Sie den Leistungstest erneut auf meinem Computer ausführen, werden Sie feststellen, dass sich die Ausführungszeit auf ~ 1s verringert oder die Leistung im Vergleich zum ersten Lauf um das Vierfache erhöht wird.  Und das alles aufgrund des Verständnisses der Funktionsweise des Computers. </p><br><p>  Intelligente Compiler oder VMs können diese Art der Optimierung durchführen, indem sie den Vorgang, den Rest hinter die Kulissen zu bringen, in einen bitweisen Vorgang umwandeln und umgekehrt.  Tatsächlich macht die neueste V8-Javascript-VM (nicht in NodeJS implementiert) genau das. </p><br><h2 id="chislovye-krotovye-nory">  Numerisches Wurmloch </h2><br><p>  Ein weiterer nützlicher Maulwurfshügel ist das Verstehen, wie das Lesen und Schreiben von Zahlen funktioniert.  Erinnerst du dich, wie wir 32-Bit-Computer verwendet haben und wie wir 64-Bit bekommen haben?  Und bis zu 32 Bit hatten wir 16 Bit.  Was genau bedeutet das?  Normalerweise denken wir so - wie viel RAM wir auf dem Computer haben.  2 ^ 32 = 4294967296 oder 4 GB, was bedeutet, dass wir auf einem 32-Bit-Computer nur auf 4 GB Speicher zugreifen können.  Wenn wir ein JS-Programm schreiben, müssen wir normalerweise nicht darüber nachdenken, da wir normalerweise nicht so viel Speicher verwenden. </p><br><p>  Es ist jedoch sehr wichtig, den Unterschied zwischen 32-Bit- und 64-Bit-Computern zu verstehen.  Seit Prozessoren 64-Bit-Register auf 64-Bit-Computern empfangen haben, sind die Vorgänge doppelt so schnell wie auf 32-Bit-Computern, auf denen Sie nur 32-Bit-Register hatten. </p><br><p>  Wie können wir Informationen über dieses Wurmloch verwenden? <br>  Schreiben wir ein einfaches Programm, das ein Uint8Array in ein anderes kopiert.  Wenn Sie mit Unit8Arrays nicht vertraut sind, sind sie den Puffern in NodeJS oder einfach dem "sauberen" Speicher sehr ähnlich. </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input, output)</span></span></span></span> { //    <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length &lt;= <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length; i++) { //   <span class="hljs-number"><span class="hljs-number">8</span></span>-  (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>[i] } }</code> </pre> <br><p>  Lassen Sie uns die Geschwindigkeit erneut messen, indem Sie einen Leistungstest ausführen. </p><br><pre> <code class="hljs pgsql">//    <span class="hljs-number"><span class="hljs-number">1</span></span>MB Uint8Arrays     const input = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uint8Array(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) const output = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uint8Array(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) console.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1e4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output) } console.timeEnd()</code> </pre><br><p>  Auf meinem Computer wurde das Programm in ~ 7,5 Sekunden abgeschlossen.  Wie können wir ein Wurmloch verwenden, um zu beschleunigen?  Mit Uint8Array kopieren wir jeweils nur 8 Bit, aber mit einem 64-Bit-Computer können wir gleichzeitig 64 Bit Informationen kopieren.  Wir können dies in JavaScript tun, indem wir unser Uint8Array vor dem Kopieren in ein Float64Array konvertieren, was uns nichts kostet. </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input, output)</span></span></span></span> { //    <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length &lt;= <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length //       <span class="hljs-number"><span class="hljs-number">64</span></span>-  //        , //      <span class="hljs-number"><span class="hljs-number">64</span></span>-  //  BigInts   JavaScript,    BigInt64Array. const input64 = new Float64Array(<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.buffer, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.byteOffset, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length / <span class="hljs-number"><span class="hljs-number">8</span></span>) const output64 = new Float64Array(<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.buffer, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.byteOffset, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length / <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input64.length; i++) { //   <span class="hljs-number"><span class="hljs-number">64</span></span>-  output64[i] = input64[i] } }</code> </pre><br><p>  Wenn wir die Leistungstests erneut ausführen, erhalten wir eine Laufzeit von 1 Sekunde, was eine 8-fache Geschwindigkeitssteigerung bedeutet. </p><br><p>  Eine akzeptable Lösung für das Kopieren wäre die Verwendung der Methode array.set (otherArray) für Uint8Array, mit der wir in nativen Code kopieren können - was viel schneller ist als jedes andere Wurmloch.  Als Referenz ergibt dies ein Ergebnis von ~ 0,2 Sekunden Ausführung in unserem Test auf meinem Computer, was fünfmal schneller ist als die vorherige Lösung. </p><br><h2 id="galaktika-javascript-polna-krotovyh-nor">  Eine Galaxie aus JavaScript ist voller Wurmlöcher </h2><br><p>  Wenn Sie die oben genannten Wurmlöcher verwenden, können Sie Tonnen realer Algorithmen viel schneller erstellen.  Es gibt noch viel mehr solche Wurmlöcher.  Mein Favorit ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Math.clz32</a> , eine Methode, die die Anzahl der führenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullbits</a> in einer 32-Bit-Binärdarstellung einer Zahl zurückgibt.  Wir können diese Methode für viele interessante Algorithmen verwenden.  Ich habe es verwendet, um die Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitfeldern um das</a> Vierfache zu beschleunigen, was zu einer Verringerung des Speicherverbrauchs um das Vierfache führte und es mir ermöglichte, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zahlen</a> in einigen Situationen viel schneller zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sortieren</a> . </p><br><p>  Wenn Sie die Grundprinzipien des Computers verstehen, können Sie die schnellsten Programme schreiben, die wir benötigen.  Dieses Wissen ist auch dann wichtig, wenn Sie in einer Hochsprache wie JavaScript schreiben. </p><br><p>  <strong>PS:</strong> </p><br><p>  Besonderer Dank für die Hilfe bei der Übersetzung und Anpassung der Übersetzung an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Olga Pereverzeva</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428201/">https://habr.com/ru/post/de428201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428187/index.html">So schreiben Sie eine Erweiterung für die GNOME-Shell: Nicht stören</a></li>
<li><a href="../de428189/index.html">Wer ist ein Paladin?</a></li>
<li><a href="../de428191/index.html">Was sollen wir für einen Hackathon arrangieren oder wie haben wir einen internen Hackathon durchgeführt?</a></li>
<li><a href="../de428193/index.html">Über Touren gehen</a></li>
<li><a href="../de428197/index.html">Effektive persönliche Finanzierung. Stufe 1</a></li>
<li><a href="../de428203/index.html">Wir sehen uns die Diagramme an: Schätzungen und Prognosen für den Cloud-Computing-Markt, Daten für 2018</a></li>
<li><a href="../de428205/index.html">Lifehacks NaviHaka</a></li>
<li><a href="../de428209/index.html">Entwicklerkochbuch: Domain Driven Design Rezepte (Teil 2, Struktur und Interaktion)</a></li>
<li><a href="../de428211/index.html">Das Buch „Evolutionäre Architektur. Unterstützung für ständigen Wandel "</a></li>
<li><a href="../de428213/index.html">Interpretieren von Modellvorhersagen in SHAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>