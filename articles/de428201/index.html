<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüíª üîè üßü Maulwurfsl√∂cher in JavaScript üî∞ üå≥ üôâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! Ich pr√§sentiere Ihnen die √úbersetzung des Artikels "Wurml√∂cher in JavaScript" von Mathius Buus. 





 Computer sind interessante Maschine...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Maulwurfsl√∂cher in JavaScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428201/"><p>  Hallo Habr!  Ich pr√§sentiere Ihnen die √úbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wurml√∂cher in JavaScript"</a> von Mathius Buus. </p><br><p><img src="https://habrastorage.org/webt/ak/t9/k_/akt9k_w0hs5lodk-p8ezfr4f6pk.jpeg"></p><br><p>  Computer sind interessante Maschinen.  Theoretisch scheinen sie uns ideale mechanische Mathematiker zu sein, die mit Zahlen arbeiten und Operationen der Addition, Multiplikation und Subtraktion gut ausf√ºhren. </p><br><p>  Eine solche Abstraktion ist jedoch ziemlich irref√ºhrend.  Es nimmt uns vom Verst√§ndnis ab, dass ein Computer verschiedene mathematische Operationen mit unterschiedlichen Geschwindigkeiten verarbeitet.  Wenn Sie in JavaScript (oder einer anderen Sprache) schreiben und sich um die Leistung der von Ihnen geschriebenen Algorithmen k√ºmmern, ist es sehr wichtig zu verstehen, wie Computer unter der Haube funktionieren. </p><br><p> Wenn wir wissen, wozu der Computer in der Lage ist, k√∂nnen wir die k√ºrzesten Wege oder Wurml√∂cher verwenden, um unsere Programme viel schneller als erwartet zu machen. </p><a name="habracut"></a><br><h2 id="krotovaya-nora-v-operacii-polucheniya-ostatka-ot-deleniya">  Wurmloch bei der Beschaffung des Restes der Division </h2><br><p>  Was genau bedeutet das?  Schauen wir uns ein Beispiel an: Stellen Sie sich vor, wir m√∂chten eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ringliste</a> implementieren.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine Ringliste</a> ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Liste</a> mit fester Gr√∂√üe, in der Einf√ºgungen, die gr√∂√üer als die Gr√∂√üe der Liste sind, an den Anfang der Liste und in einen Kreis verschoben werden.  Ringlisten sind f√ºr viele Dinge sehr praktisch - zum Beispiel f√ºr das Sammeln von Statistiken f√ºr bestimmte Zeitintervalle, das Puffern von Daten und mehr. Sehen Sie sich jedoch diese Implementierung an: </p><br><pre><code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-number"><span class="hljs-number">15000</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  % -   ,     //        //    ,     i    list[i % list.length] = item }</span></span></code> </pre> <br><p>  Wie schnell wird dieser Code ausgef√ºhrt?  Lassen Sie uns einen einfachen Geschwindigkeitstest durchf√ºhren </p><br><pre> <code class="hljs matlab">console.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1e9</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { set(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) } console.timeEnd()</code> </pre><br><p>  Auf meinem Computer dauerte es ~ 4 Sekunden f√ºr 1 Milliarde Beilagen.  Nicht schlecht. </p><br><p>  Wenden wir jedoch ein rechnerisches Wurmloch an und √§ndern die Gr√∂√üe des Arrays in eine magische Zahl: </p><br><pre> <code class="hljs powershell">//     <span class="hljs-number"><span class="hljs-number">15000</span></span>  <span class="hljs-number"><span class="hljs-number">16384</span></span> const list = new Array(<span class="hljs-number"><span class="hljs-number">16384</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span></span> { //  % -   ,     //        //    ,     i    list[<span class="hljs-type"><span class="hljs-type">i</span></span> % <span class="hljs-type"><span class="hljs-type">list.length</span></span>] = item }</code> </pre><br><p>  Versuchen wir erneut, den Leistungstest auszuf√ºhren.  Auf meinem Computer wurde der Test in ~ 1,5 Sekunden abgeschlossen.  Mehr als doppelte Erh√∂hung durch einfache Gr√∂√üen√§nderung.  Um zu verstehen, warum dies geschieht, m√ºssen wir Folgendes verstehen: Unter der Haube arbeitet der Computer mit Zahlen mit Basis 2. Es ist wichtig zu wissen, ob wir den Rest der Division erhalten (Operation%).  Eine solche Berechnung ist viel einfacher, wenn die Zahl ein Vielfaches von 2 (2 ^ n) b 16384 ist, es ist 2 ^ 14. Tats√§chlich betrachtet der Computer die Zahl in bin√§rer Form und nimmt einfach die letzten n Bits. </p><br><p>  Zum Beispiel: Was passiert, wenn eine solche Operation ausgef√ºhrt wird? 353 500% 16 384?  353 500 in bin√§rer Darstellung sieht aus wie 1010110010011011100. Seit 16384 == 2 ^ 14 - m√ºssen wir die letzten 14 Bits nehmen - 10101 (10010011011100) oder 9 346. </p><br><p>  Wir k√∂nnen dieses Wissen in Bezug auf ein anderes Wurmloch verwenden.  F√ºr einen Computer ist es sehr einfach und schnell, die letzten n Bits zu nehmen.  Tats√§chlich ist es nur notwendig, bin√§r und (Operation &amp;) mit der Zahl (2 ^ n) - 1 zu erzeugen </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>(<span class="hljs-number"><span class="hljs-number">16384</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    &amp;( )  %    2 ^ n list[i &amp; (list.length - 1)] = i }</span></span></code> </pre> <br><p>  Wenn Sie den Leistungstest erneut auf meinem Computer ausf√ºhren, werden Sie feststellen, dass sich die Ausf√ºhrungszeit auf ~ 1s verringert oder die Leistung im Vergleich zum ersten Lauf um das Vierfache erh√∂ht wird.  Und das alles aufgrund des Verst√§ndnisses der Funktionsweise des Computers. </p><br><p>  Intelligente Compiler oder VMs k√∂nnen diese Art der Optimierung durchf√ºhren, indem sie den Vorgang, den Rest hinter die Kulissen zu bringen, in einen bitweisen Vorgang umwandeln und umgekehrt.  Tats√§chlich macht die neueste V8-Javascript-VM (nicht in NodeJS implementiert) genau das. </p><br><h2 id="chislovye-krotovye-nory">  Numerisches Wurmloch </h2><br><p>  Ein weiterer n√ºtzlicher Maulwurfsh√ºgel ist das Verstehen, wie das Lesen und Schreiben von Zahlen funktioniert.  Erinnerst du dich, wie wir 32-Bit-Computer verwendet haben und wie wir 64-Bit bekommen haben?  Und bis zu 32 Bit hatten wir 16 Bit.  Was genau bedeutet das?  Normalerweise denken wir so - wie viel RAM wir auf dem Computer haben.  2 ^ 32 = 4294967296 oder 4 GB, was bedeutet, dass wir auf einem 32-Bit-Computer nur auf 4 GB Speicher zugreifen k√∂nnen.  Wenn wir ein JS-Programm schreiben, m√ºssen wir normalerweise nicht dar√ºber nachdenken, da wir normalerweise nicht so viel Speicher verwenden. </p><br><p>  Es ist jedoch sehr wichtig, den Unterschied zwischen 32-Bit- und 64-Bit-Computern zu verstehen.  Seit Prozessoren 64-Bit-Register auf 64-Bit-Computern empfangen haben, sind die Vorg√§nge doppelt so schnell wie auf 32-Bit-Computern, auf denen Sie nur 32-Bit-Register hatten. </p><br><p>  Wie k√∂nnen wir Informationen √ºber dieses Wurmloch verwenden? <br>  Schreiben wir ein einfaches Programm, das ein Uint8Array in ein anderes kopiert.  Wenn Sie mit Unit8Arrays nicht vertraut sind, sind sie den Puffern in NodeJS oder einfach dem "sauberen" Speicher sehr √§hnlich. </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input, output)</span></span></span></span> { //    <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length &lt;= <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length; i++) { //   <span class="hljs-number"><span class="hljs-number">8</span></span>-  (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>[i] } }</code> </pre> <br><p>  Lassen Sie uns die Geschwindigkeit erneut messen, indem Sie einen Leistungstest ausf√ºhren. </p><br><pre> <code class="hljs pgsql">//    <span class="hljs-number"><span class="hljs-number">1</span></span>MB Uint8Arrays     const input = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uint8Array(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) const output = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Uint8Array(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>) console.time() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1e4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>, output) } console.timeEnd()</code> </pre><br><p>  Auf meinem Computer wurde das Programm in ~ 7,5 Sekunden abgeschlossen.  Wie k√∂nnen wir ein Wurmloch verwenden, um zu beschleunigen?  Mit Uint8Array kopieren wir jeweils nur 8 Bit, aber mit einem 64-Bit-Computer k√∂nnen wir gleichzeitig 64 Bit Informationen kopieren.  Wir k√∂nnen dies in JavaScript tun, indem wir unser Uint8Array vor dem Kopieren in ein Float64Array konvertieren, was uns nichts kostet. </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input, output)</span></span></span></span> { //    <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length &lt;= <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length //       <span class="hljs-number"><span class="hljs-number">64</span></span>-  //        , //      <span class="hljs-number"><span class="hljs-number">64</span></span>-  //  BigInts   JavaScript,    BigInt64Array. const input64 = new Float64Array(<span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.buffer, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.byteOffset, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.length / <span class="hljs-number"><span class="hljs-number">8</span></span>) const output64 = new Float64Array(<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.buffer, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.byteOffset, <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.length / <span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input64.length; i++) { //   <span class="hljs-number"><span class="hljs-number">64</span></span>-  output64[i] = input64[i] } }</code> </pre><br><p>  Wenn wir die Leistungstests erneut ausf√ºhren, erhalten wir eine Laufzeit von 1 Sekunde, was eine 8-fache Geschwindigkeitssteigerung bedeutet. </p><br><p>  Eine akzeptable L√∂sung f√ºr das Kopieren w√§re die Verwendung der Methode array.set (otherArray) f√ºr Uint8Array, mit der wir in nativen Code kopieren k√∂nnen - was viel schneller ist als jedes andere Wurmloch.  Als Referenz ergibt dies ein Ergebnis von ~ 0,2 Sekunden Ausf√ºhrung in unserem Test auf meinem Computer, was f√ºnfmal schneller ist als die vorherige L√∂sung. </p><br><h2 id="galaktika-javascript-polna-krotovyh-nor">  Eine Galaxie aus JavaScript ist voller Wurml√∂cher </h2><br><p>  Wenn Sie die oben genannten Wurml√∂cher verwenden, k√∂nnen Sie Tonnen realer Algorithmen viel schneller erstellen.  Es gibt noch viel mehr solche Wurml√∂cher.  Mein Favorit ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Math.clz32</a> , eine Methode, die die Anzahl der f√ºhrenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nullbits</a> in einer 32-Bit-Bin√§rdarstellung einer Zahl zur√ºckgibt.  Wir k√∂nnen diese Methode f√ºr viele interessante Algorithmen verwenden.  Ich habe es verwendet, um die Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bitfeldern um das</a> Vierfache zu beschleunigen, was zu einer Verringerung des Speicherverbrauchs um das Vierfache f√ºhrte und es mir erm√∂glichte, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zahlen</a> in einigen Situationen viel schneller zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sortieren</a> . </p><br><p>  Wenn Sie die Grundprinzipien des Computers verstehen, k√∂nnen Sie die schnellsten Programme schreiben, die wir ben√∂tigen.  Dieses Wissen ist auch dann wichtig, wenn Sie in einer Hochsprache wie JavaScript schreiben. </p><br><p>  <strong>PS:</strong> </p><br><p>  Besonderer Dank f√ºr die Hilfe bei der √úbersetzung und Anpassung der √úbersetzung an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Olga Pereverzeva</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428201/">https://habr.com/ru/post/de428201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428187/index.html">So schreiben Sie eine Erweiterung f√ºr die GNOME-Shell: Nicht st√∂ren</a></li>
<li><a href="../de428189/index.html">Wer ist ein Paladin?</a></li>
<li><a href="../de428191/index.html">Was sollen wir f√ºr einen Hackathon arrangieren oder wie haben wir einen internen Hackathon durchgef√ºhrt?</a></li>
<li><a href="../de428193/index.html">√úber Touren gehen</a></li>
<li><a href="../de428197/index.html">Effektive pers√∂nliche Finanzierung. Stufe 1</a></li>
<li><a href="../de428203/index.html">Wir sehen uns die Diagramme an: Sch√§tzungen und Prognosen f√ºr den Cloud-Computing-Markt, Daten f√ºr 2018</a></li>
<li><a href="../de428205/index.html">Lifehacks NaviHaka</a></li>
<li><a href="../de428209/index.html">Entwicklerkochbuch: Domain Driven Design Rezepte (Teil 2, Struktur und Interaktion)</a></li>
<li><a href="../de428211/index.html">Das Buch ‚ÄûEvolution√§re Architektur. Unterst√ºtzung f√ºr st√§ndigen Wandel "</a></li>
<li><a href="../de428213/index.html">Interpretieren von Modellvorhersagen in SHAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>