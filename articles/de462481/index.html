<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóÉÔ∏è ‚óªÔ∏è üòÇ Geben Sie System-FAQs ein üß° üíû üìå</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Artikels, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass dieser Beitrag und seine Kommentare als Inspirationsquelle f√ºr sein S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geben Sie System-FAQs ein</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/462481/">  Der Autor des Artikels, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> Beitrag und seine Kommentare als Inspirationsquelle f√ºr sein Schreiben gedient haben.  Ihm zufolge haben IT-Spezialisten falsche Vorstellungen √ºber Typen, verwenden falsche Terminologie und kommen bei der Er√∂rterung typbezogener Probleme zu falschen Schlussfolgerungen.  Er stellt fest, dass er kein Verteidiger des statischen Typsystems ist.  Das einzige, was ihn st√∂rt, ist die korrekte Verwendung von Begriffen.  Dies erm√∂glicht konstruktive Diskussionen.  Der Autor sagt, dass er dieses Material spontan geschrieben hat, hofft aber, dass es keine Fehler enth√§lt.  Wenn er etwas verwirrt hat, bittet er <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihn dar√ºber zu</a> informieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5h/v0/_9/5hv0_9iyqwfr7itow5ihgjdpdio.jpeg"></a> <br><br>  Lassen Sie uns ein f√ºr alle Mal verstehen, was bei Typsystemen Verwirrung stiftet. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Dynamische Eingabe und fehlende Eingabe</font> </h2><br>  Einige Leute denken, dass ein dynamisches Typsystem dasselbe ist wie ein untypisiertes Typsystem.  Das Fehlen einer Typisierung bedeutet, dass es in einem bestimmten Typensystem keinen Sinn macht, zwischen Typen zu unterscheiden.  Es macht keinen Sinn, Typen zu unterscheiden, selbst wenn nur ein Typ im Typensystem vorhanden ist.  Zum Beispiel: <br><br><ul><li>  In Assembler ist der einzige Typ eine Bitfolge. </li><li>  In der Lambda-Rechnung ist der einzige Typ die Funktion. </li></ul><br>  Jemand k√∂nnte dies bei dieser Gelegenheit sagen: "Aber welchen Unterschied macht es - dynamisches Tippen oder mangelndes Tippen - auch eine Frage f√ºr mich."  Dies ist jedoch in der Tat ein gro√ües und wichtiges Thema.  Tatsache ist, dass, wenn Sie die dynamische Typisierung mit der fehlenden Typisierung gleichsetzen, dies die automatische √úbernahme der Tatsache bedeutet, dass ein dynamisches Typsystem das Gegenteil eines statischen Typsystems ist.  Infolgedessen werden zwei entgegengesetzte Lager von Programmierern gebildet - das Lager der dynamischen Typisierung und das Lager der statischen Typisierung (und dies ist, wie wir im entsprechenden Abschnitt sehen werden, falsch). <br><br>  <i><font color="#999999">Sprachen, die den Wertebereich von Variablen nicht einschr√§nken, werden als untypisierte Sprachen bezeichnet: Sie haben keine Typen, oder, was dasselbe ist, sie haben nur einen universellen Typ, der alle Werte enth√§lt.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typ Systeme, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">Programmiersprachen haben eine interessante Funktion, mit der Sie ihre Welt grob in zwei Gruppen unterteilen k√∂nnen:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  Untypisierte Sprachen - Programme werden einfach ausgef√ºhrt.  Dies geschieht schnell, ohne zu versuchen, die ‚ÄûEinheitlichkeit der Formulare‚Äú zu √ºberpr√ºfen. </li><li>  Typisierte Sprachen - es wird versucht, die ‚ÄûEinheitlichkeit der Form‚Äú zu √ºberpr√ºfen - entweder w√§hrend der Kompilierung oder w√§hrend der Programmausf√ºhrung. </li></ul><br>  <sub>"Typensysteme f√ºr Programmiersprachen", Benjamin Pearce</sub> <br><br><h2>  <font color="#3AC1EF">Dynamische und statische Eingabe</font> </h2><br>  Ein dynamisches Typsystem ist ein System, in dem Typen dynamisch √ºberpr√ºft werden (w√§hrend der Programmausf√ºhrung).  Ein statisches Typsystem ist ein System, in dem Typen statisch √ºberpr√ºft werden (w√§hrend der Kompilierung oder Code√ºbersetzung). <br><br>  Ist eines dieser Systeme das Gegenteil des anderen?  Nein, das ist es nicht.  Beide Systemtypen k√∂nnen in derselben Sprache verwendet werden.  Tats√§chlich verf√ºgen die meisten statischen Typsysteme auch √ºber dynamische Typpr√ºfungen.  Betrachten Sie als Beispiel die Validierung von Eingabe-Ausgabe-Operationen (Eingabe-Ausgabe, E / A).  Stellen Sie sich vor, Sie m√ºssen Daten lesen, die von einem Benutzer bereitgestellt wurden, der eine Nummer eingeben muss.  Sie werden w√§hrend der Programmausf√ºhrung pr√ºfen, ob die Nummer das Ergebnis des Parsens der entsprechenden Zeile ist (als Ergebnis des Parsens kann eine Ausnahme ausgel√∂st werden oder etwas wie <code>NaN</code> wird zur√ºckgegeben).  Wenn Sie die vom Benutzer eingegebenen Daten √ºberpr√ºfen und herausfinden, ob sie als Zahl betrachtet werden k√∂nnen, f√ºhren Sie eine dynamische Typpr√ºfung durch. <br><br>  Infolgedessen k√∂nnen wir feststellen, dass keine Konfrontation zwischen statischen und dynamischen Typen besteht.  Sie k√∂nnen diese und andere in derselben Sprache verwenden. <br><br>  Dar√ºber hinaus sollte beachtet werden, dass die statische Typpr√ºfung ein komplexer Prozess ist.  Manchmal ist es sehr schwierig, einige Teile eines Programms statisch zu √ºberpr√ºfen.  Anstatt statische Typpr√ºfungen anzuwenden, k√∂nnen Sie daher auf dynamische Pr√ºfungen zur√ºckgreifen. <br><br>  Es wird empfohlen, ein statisches Typsystem als Typen zu betrachten, die statisch √ºberpr√ºft werden.  Ein dynamisches Typsystem √§hnelt Typen, die dynamisch √ºberpr√ºft werden. <br><br><h2>  <font color="#3AC1EF">Bedeutet die Verwendung statischer Typen, dass Typen zur Kompilierungszeit bekannt sind?</font> </h2><br>  Die im Titel dieses Abschnitts gestellte Frage kann verneint werden.  Wenn Sie den Quellcode eines Parsers (einschlie√ülich des JavaScript-Parsers) √∂ffnen, k√∂nnen Sie feststellen, dass der Parser die Wertetypen w√§hrend des Parsens kennt (dies ist Teil des Kompilierungsprozesses). <br><br><pre> <code class="plaintext hljs">let x = "test";</code> </pre> <br>  Es stellt sich heraus, dass der Parser wei√ü, dass <code>"test"</code> eine Zeichenfolge ist.  Macht dies JavaScript zu einer statisch typisierten Sprache?  Nein, das tut es nicht. <br><br><h2>  <font color="#3AC1EF">Allm√§hliches Tippen</font> </h2><br>  Ein schrittweises Typsystem ist ein statisches Typsystem, mit dem Sie Typpr√ºfungen f√ºr einige Teile eines Programms √ºberspringen k√∂nnen.  In TypeScript wird dies beispielsweise mit <code>any</code> oder <code>@ts-ignore</code> implementiert. <br><br>  Dies macht zum einen das Typensystem weniger sicher.  Auf der anderen Seite k√∂nnen Sie mit einem Typensystem mit schrittweiser Eingabe Sprachen mit dynamischer Eingabe schrittweise Typbeschreibungen hinzuf√ºgen. <br><br><h2>  <font color="#3AC1EF">Zuverl√§ssige und unzuverl√§ssige Systeme</font> </h2><br>  Wenn Sie ein zuverl√§ssiges Typsystem (Soundtypsystem) verwenden, wird das Programm w√§hrend der Typpr√ºfung nicht "genehmigt", wenn Fehler in Bezug auf Typen in diesem Programm vorliegen.  Die Verwendung eines unsoliden Typsystems f√ºhrt zu der M√∂glichkeit von Typfehlern im Programm.  Es stimmt, Sie sollten nicht in Panik geraten, nachdem Sie davon erfahren haben.  In der Praxis hat dies m√∂glicherweise keine Auswirkungen auf Sie.  Zuverl√§ssigkeit oder Solidit√§t ist eine mathematische Eigenschaft eines Typpr√ºfungsalgorithmus, der bewiesen werden muss.  Viele vorhandene Compiler (intern Typpr√ºfungssysteme) sind unzuverl√§ssig. <br><br>  Wenn Sie mit zuverl√§ssigen Typsystemen arbeiten m√∂chten, werfen Sie einen Blick auf die Programmiersprachen der ML-Familie, die das Hindley-Milner-Typsystem verwenden. <br><br>  Dar√ºber hinaus muss verstanden werden, dass ein zuverl√§ssiges Typsystem das falsche Programm nicht √ºberspringt (es liefert keine falsch positiven Testergebnisse, wenn die falschen Programme als korrekt angesehen werden), aber m√∂glicherweise nicht das richtige Programm verfehlt (es kann falsch negative Testergebnisse liefern). <br><br>  Ein Typsystem, das niemals das richtige Programm ablehnt, wird als vollst√§ndig bezeichnet. <br><br>  Kommt es vor, dass ein Typsystem sowohl zuverl√§ssig als auch vollst√§ndig ist?  Soweit ich wei√ü, existieren solche Typsysteme nicht.  Ich bin mir bis zum Ende nicht sicher, aber es scheint mir, dass die Existenz solcher Typsysteme, wenn sie auf G√∂dels Unvollst√§ndigkeitssatz beruhen, grunds√§tzlich unm√∂glich ist (ich kann mich jedoch irren). <br><br><h2>  <font color="#3AC1EF">Schwache und starke Eingabe</font> </h2><br>  Ich finde es unangemessen, die Begriffe "schwaches Tippen" und "starkes Tippen" zu verwenden.  Diese Begriffe sind nicht eindeutig, ihre Verwendung kann mehr Verwirrung als Klarheit bringen.  Lassen Sie mich ein paar Zitate geben. <br><br>  <i><font color="#999999">Diese Sprachen k√∂nnen im √ºbertragenen Sinne Sprachen mit schwacher Typpr√ºfung genannt werden (oder schwach typisierte Sprachen, wie sie normalerweise in verschiedenen Ver√∂ffentlichungen genannt werden).</font></i>  <i><font color="#999999">Die Verwendung einer schwachen Typpr√ºfung in der Sprache bedeutet, dass einige unsichere Vorg√§nge statisch erkannt werden und andere nicht.</font></i>  <i><font color="#999999">Die "Schw√§che" der Typpr√ºfungen in Sprachen dieser Klasse ist sehr unterschiedlich.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Typ Systeme, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">Die wahrscheinlich h√§ufigste Methode zur Klassifizierung von Typsystemen besteht darin, sie in Systeme mit ‚Äûschwacher‚Äú und ‚Äûstarker‚Äú Typisierung zu unterteilen.</font></i>  <i><font color="#999999">Dies kann nur bedauert werden, da diese W√∂rter an sich praktisch keine Bedeutung haben.</font></i>  <i><font color="#999999">In begrenztem Umfang ist es m√∂glich, zwei Sprachen mit sehr √§hnlichen Typsystemen zu vergleichen und eine davon mit einem st√§rkeren Typsystem als das zweite auszuw√§hlen.</font></i>  <i><font color="#999999">In anderen F√§llen sind die Begriffe ‚Äûstarkes Tippen‚Äú und ‚Äûschwaches Tippen‚Äú v√∂llig bedeutungslos.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999"><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûWissenswertes vor der Diskussion von Typensystemen‚Äú, Steve Klabnik</a></sub></font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">Die Begriffe ‚Äûstarkes Tippen‚Äú und ‚Äûschwaches Tippen‚Äú sind √§u√üerst vieldeutig.</font></i>  <i><font color="#999999">Hier sind einige Beispiele f√ºr ihre Verwendung:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  <i><font color="#999999">Manchmal wird unter ‚Äûstarker Typisierung‚Äú ‚Äûstatische Typisierung‚Äú verstanden.</font></i>  <i><font color="#999999">Es ist nicht schwierig, eine solche "Substitution" vorzunehmen, aber es ist besser, wenn man von statischer Typisierung spricht, sie einfach "statisch" zu nennen.</font></i>  <i><font color="#999999">Tatsache ist, dass die meisten Programmierer diesen Begriff klar verstehen.</font></i> </li><li>  <i><font color="#999999">Wenn sie "starke Typisierung" sagen, meinen sie manchmal "das Fehlen einer impliziten Typkonvertierung".</font></i>  <i><font color="#999999">In JavaScript k√∂nnen Sie beispielsweise Ausdr√ºcke wie <code>"a" - 1</code> .</font></i>  <i><font color="#999999">Dies kann als Modell f√ºr "schwache Typisierung" bezeichnet werden.</font></i>  <i><font color="#999999">Fast alle Sprachen bieten dem Programmierer jedoch einige M√∂glichkeiten zur impliziten Typkonvertierung, beispielsweise die automatische Konvertierung von Ganzzahlen in Gleitkommazahlen in Ausdr√ºcken wie <code>1 - 1.1</code> .</font></i>  <i><font color="#999999">In der Praxis unterscheiden die meisten Fachleute, die den Begriff "starkes Tippen" auf diese Weise verwenden, zwischen "akzeptablen" und "nicht akzeptablen" Typkonvertierungen.</font></i>  <i><font color="#999999">Es gibt jedoch keine allgemein akzeptierte Grenze zwischen solchen Typkonvertierungen.</font></i>  <i><font color="#999999">Die "Akzeptanz" und "Inakzeptanz" von Transformationen ist eine subjektive Bewertung, abh√§ngig von der Meinung einer bestimmten Person.</font></i> </li><li>  <i><font color="#999999">Manchmal werden Sprachen mit "starker Typisierung" als Sprachen bezeichnet, in denen es unm√∂glich ist, die Regeln des in ihnen vorhandenen Typensystems zu umgehen.</font></i> </li><li>  <i><font color="#999999">Manchmal bedeutet ‚Äûstarkes Tippen‚Äú, √ºber ein Typensystem zu verf√ºgen, mit dem Sie sicher mit dem Speicher arbeiten k√∂nnen.</font></i>  <i><font color="#999999">Die C-Sprache ist ein bemerkenswertes Beispiel f√ºr eine Sprache, die mit dem Speicher unsicher ist.</font></i>  <i><font color="#999999">Wenn <code>xs</code> beispielsweise ein Array mit vier Zahlen ist, genehmigt C einen Code, der problemlos Konstrukte wie <code>xs[5]</code> oder <code>xs[1000]</code> verwendet.</font></i>  <i><font color="#999999">Mit ihnen k√∂nnen Sie auf den Speicher zugreifen, der sich nach den Adressen befindet, die zum Speichern des Inhalts des <code>xs</code> Arrays zugewiesen wurden.</font></i> </li></ul><br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Typen, Gary Bernard</a></sub> <br><br><h2>  <font color="#3AC1EF">Ben√∂tigen statisch typisierte Sprachen Typdeklarationen?</font> </h2><br>  Statisch typisierte Sprachen ben√∂tigen nicht immer Typdeklarationen.  Manchmal kann ein Typsystem Typen ableiten (indem Annahmen getroffen werden, die auf der Codestruktur basieren).  Hier ist ein Beispiel (TypeScript): <br><br><pre> <code class="plaintext hljs">const x = "test";</code> </pre> <br>  Das Typsystem wei√ü, dass <code>"test"</code> eine Zeichenfolge ist (dieses Wissen basiert auf den Regeln der Code-Analyse).  Das Typsystem wei√ü auch, dass <code>x</code> eine Konstante ist, dh der Wert von <code>x</code> kann nicht neu zugewiesen werden.  Infolgedessen kann geschlossen werden, dass <code>x</code> vom Typ String ist. <br>  Hier ist ein weiteres Beispiel (Flow): <br><br><pre> <code class="plaintext hljs">const add = (x, y) =&gt; x / y //            ^        [1]   . add(1, "2")</code> </pre> <br>  Das Typpr√ºfungssystem erkennt, dass wir die Funktion <code>add</code> aufrufen und ihr eine Zahl und eine Zeichenfolge √ºbergeben.  Dies analysiert die Funktionsdeklaration.  Das Typpr√ºfsystem wei√ü, dass zur Durchf√ºhrung der Teilungsoperation die Nummern rechts und links vom entsprechenden Operator stehen m√ºssen.  Einer der an der Divisionsoperation beteiligten Operanden ist keine Zahl.  Dadurch werden wir √ºber den Fehler informiert. <br><br>  Hier gibt es keine Typdeklarationen, dies verhindert jedoch nicht eine statische Typpr√ºfung durch das obige Programm.  Wenn Sie in der realen Welt auf √§hnliche Situationen sto√üen, m√ºssen Sie fr√ºher oder sp√§ter einige Typen deklarieren.  Das Typensystem kann nicht absolut alle Typen ableiten.  Sie m√ºssen jedoch verstehen, dass eine Sprache nicht als "statisch" bezeichnet werden kann, nicht weil sie Typdeklarationen verwendet, sondern weil Typen vor dem Start des Programms √ºberpr√ºft werden. <br><br><h2>  <font color="#3AC1EF">Ist TypeScript eine unsichere Sprache, weil darin geschriebener Code in JavaScript-Code kompiliert wird?</font> </h2><br>  TypeScript ist eine unsolide Sprache.  Daher kann der darauf geschriebene Code zu unsicheren Anwendungen werden.  Dies hat jedoch nichts mit dem zu tun, was es kompiliert. <br><br>  Die meisten Desktop-Compiler konvertieren Programme in eine Assemblersprache.  Und Assembler ist eine Sprache, die noch weniger sicher ist als JS. <br><br>  Wenn Sie hier auf die Idee zur√ºckkommen, dass TS aufgrund der Kompilierung in JS unsicher ist, k√∂nnten Sie den folgenden Gedanken bekommen: ‚ÄûKompilierter Code wird im Browser ausgef√ºhrt, JS ist eine unsichere Sprache und kann die Stelle, an der die Zeile erwartet wird, durch <code>null</code> ersetzen ".  Denken ist sinnvoll.  Dies ist jedoch wiederum kein Grund, TS als unsichere Sprache zu bezeichnen.  Damit TS die Sicherheit innerhalb der Anwendung gew√§hrleisten kann, m√ºssen Sie die "Abwehrmechanismen" an den Stellen platzieren, an denen der TS-Code mit der Au√üenwelt interagiert.  Das hei√üt, Sie m√ºssen beispielsweise die Richtigkeit der Daten √ºberpr√ºfen, die √ºber die Eingabe-Ausgabe-Mechanismen in das Programm eingegeben werden.  Angenommen, dies kann das √úberpr√ºfen der Eingabe durch den Benutzer, das √úberpr√ºfen der Serverantworten, das √úberpr√ºfen der aus dem Browserspeicher gelesenen Daten usw. sein. <br><br>  Zum Beispiel spielen " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">H√§fen</a> " die Rolle solcher "Abwehrmechanismen" in Elm.  In TS k√∂nnen Sie daf√ºr so etwas wie io-ts verwenden. <br><br>  Der entsprechende ‚ÄûSchutzmechanismus‚Äú schafft eine Br√ºcke zwischen statischen und dynamischen Systemen. <br><br>  Hier ist ein vereinfachtes Beispiel: <br><br><pre> <code class="plaintext hljs">const makeSureIsNumber = (x: any) =&gt; {  const result = parseFloat(x);  if (isNaN(result)) {    throw Error("Not a number");  }  return result; } const read = (input: any) =&gt; {  try {    const n = makeSureIsNumber(input);    //     n, ,      //              // makeSureIsNumber "" , n    } catch (e) { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Stimmt es, dass Typen nur f√ºr Compiler ben√∂tigt werden?</font> </h2><br>  <i><font color="#999999">Typen sind nur der Hack, der ben√∂tigt wird, um dem Compiler Hinweise zu geben.</font></i> <br>  <sub>Waut Mertens</sub> <br><br>  Werden Typen nur von Compilern ben√∂tigt?  Dies ist eine philosophische Frage.  Typen werden f√ºr Menschen ben√∂tigt, nicht f√ºr Autos.  Compiler ben√∂tigen Typen, da es sich um Programme handelt, die von Personen geschrieben wurden. <br><br>  Das Ph√§nomen der Typen existiert aufgrund von Menschen.  Typen existieren erst, wenn eine Person etwas in Form eines ‚ÄûDatentyps‚Äú wahrnimmt.  Der menschliche Geist teilt verschiedene Entit√§ten in verschiedene Kategorien ein.  Typen sind ohne Beobachter nicht sinnvoll. <br><br>  Lassen Sie uns ein Gedankenexperiment arrangieren.  Denken Sie an das Spiel Life.  Sie haben ein zweidimensionales Gitter, das aus quadratischen Zellen besteht.  Jede der Zellen kann sich in zwei m√∂glichen Zust√§nden befinden.  Es kann "lebendig" oder "tot" sein.  Jede Zelle kann mit ihren acht Nachbarn interagieren.  Dies sind Zellen, die vertikal, horizontal oder diagonal an sie angrenzen.  Beim Ermitteln des n√§chsten Status des Systems gelten die folgenden Regeln: <br><br><ul><li>  Eine "lebende" Zelle mit weniger als zwei "lebenden" Nachbarn "stirbt" wie bei einer geringen Bev√∂lkerungsdichte. </li><li>  Eine "lebende" Zelle mit zwei oder drei "lebenden" Nachbarn √ºberlebt und f√§llt in die n√§chste Generation. </li><li>  Eine "lebende" Zelle mit mehr als drei "lebenden" Nachbarn "stirbt" wie bei √úberbev√∂lkerung. </li><li>  Die "tote" Zelle, die genau drei "lebende" Nachbarn hat, wird "lebendig", wie bei der Reproduktion der Bev√∂lkerung. </li></ul><br>  √Ñu√üerlich sieht es aus wie ein Feld, das in quadratische Zellen unterteilt ist, die st√§ndig ‚Äûeingeschaltet‚Äú und ‚Äûausgeschaltet‚Äú werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier k√∂nnen</a> Sie sich das ansehen. <br><br>  Wenn Sie das Leben einige Zeit beobachten, k√∂nnen stabile Strukturen wie ‚ÄûSegelflugzeug‚Äú auf dem Feld erscheinen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/710/310/04f710310ef2d132545b15df0e19e601.gif"></div><br>  <i><font color="#999999">Segelflugzeug</font></i> <br><br>  Sehen Sie ihn?  Ein Segelflugzeug bewegt sich √ºber den Bildschirm.  Richtig?  Lassen Sie uns jetzt etwas langsamer fahren.  Existiert dieser Schirm wirklich?  Dies sind nur einzelne Quadrate, die erscheinen und verschwinden.  Aber unser Gehirn kann diese Struktur als etwas objektiv Vorhandenes wahrnehmen. <br><br>  Au√üerdem k√∂nnen wir sagen, dass das ‚ÄûSegelflugzeug‚Äú existiert, weil die Quadrate nicht unabh√§ngig sind (sie h√§ngen von den Nachbarn ab), und selbst wenn das ‚ÄûSegelflugzeug‚Äú selbst nicht existiert, gibt es ein ‚ÄûSegelflugzeug‚Äú in der Form platonische Ideen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Betrachten Sie jedes Programm, das in einer typisierten Programmiersprache geschrieben ist.  Wir k√∂nnen die Typen beobachten.  Richtig?  Das Programm wird jedoch in Maschinencodes kompiliert.  In diesen Codes wird dasselbe ausgedr√ºckt wie im urspr√ºnglichen Programm (obwohl es f√ºr eine Person schwierig ist, maschinelle Darstellungen von Programmen zu lesen).  Aus Computersicht gibt es keine Typen.  Er sieht nur die Folge von Bits - Mengen von Nullen und Einsen ("tote" und "lebende" Zellen).  Es gibt Typen f√ºr Menschen, nicht f√ºr Autos. <br><br>  <b>Liebe Leser!</b>  Welches Typsystem k√∂nnten Sie als ideal f√ºr die Webentwicklung betrachten? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462481/">https://habr.com/ru/post/de462481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462471/index.html">L√∂sen eines Jobs mit pwnable.kr 16 - uaf. Verwendung nach freier Sicherheitsl√ºcke</a></li>
<li><a href="../de462473/index.html">Wir entwickeln eine Umgebung f√ºr die Arbeit mit Microservices. Teil 1 Installation von Kubernetes HA auf Bare Metal (Debian)</a></li>
<li><a href="../de462475/index.html">Alexey Savvateev: Wie man Korruption mit Hilfe der Mathematik bek√§mpft (Nobelpreis f√ºr Wirtschaftswissenschaften f√ºr 2016)</a></li>
<li><a href="../de462477/index.html">Wissenschaftler behaupten, AI sei der Autor eines neuen Patents und versuchen, das Patentrecht zu √§ndern</a></li>
<li><a href="../de462479/index.html">Eskalation der lokalen Berechtigungen des Steam Windows-Clients 0 Tag</a></li>
<li><a href="../de462483/index.html">Funktionale Programmierung: Ein verr√ºcktes Spielzeug, das die Arbeitsproduktivit√§t beeintr√§chtigt. Teil 1</a></li>
<li><a href="../de462485/index.html">Funktionale Programmierung: Ein verr√ºcktes Spielzeug, das die Arbeitsproduktivit√§t beeintr√§chtigt. Teil 2</a></li>
<li><a href="../de462487/index.html">Cython: √úber 30-fache Python-Code-Beschleunigung</a></li>
<li><a href="../de462489/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 374 (29. Juli - 4. August 2019)</a></li>
<li><a href="../de462493/index.html">Multimodell-DBMS - die Basis moderner Informationssysteme?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>