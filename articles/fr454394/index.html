<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéΩ üßñüèª üßìüèΩ Lecteur MIDI minimaliste en quatre parties üéÆ üë©üèº‚Äç‚úàÔ∏è üéÖüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le lecteur propos√© ne n√©cessite pas de carte m√©moire; il stocke un fichier MIDI jusqu'√† 6000 octets directement dans le microcontr√¥leur ATtiny85 (cont...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lecteur MIDI minimaliste en quatre parties</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454394/"><img src="https://habrastorage.org/webt/wy/qv/ce/wyqvcexiheyxhiuc2lspo3iz7jm.jpeg"><br><br>  Le lecteur propos√© ne n√©cessite pas de carte m√©moire; il stocke un fichier MIDI jusqu'√† 6000 octets directement dans le microcontr√¥leur ATtiny85 (contrairement √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette</a> conception classique, qui lit des fichiers WAV, il n√©cessite naturellement une carte m√©moire).  La lecture √† quatre voies avec att√©nuation utilisant PWM est impl√©ment√©e dans le logiciel.  Un exemple de sondage est <a href="">ici</a> . <a name="habracut"></a><br><br>  L'appareil est fabriqu√© selon le sch√©ma: <br><br><img src="https://habrastorage.org/webt/qs/h8/uz/qsh8uzrueecz-x4c-pxv5webr7o.gif"><br><br>  Le condensateur √©lectrolytique entre le microcontr√¥leur et la t√™te dynamique ne manquera pas la composante constante si une unit√© logique appara√Æt √† la sortie du PB4 √† la suite d'une panne logicielle.  L'inductance de la t√™te ne d√©passe pas la fr√©quence PWM.  Si vous d√©cidez de connecter l'appareil √† l'amplificateur, afin d'√©viter de surcharger ce dernier avec un signal PWM, vous devez ajouter un filtre passe-bas, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Le fichier MIDI doit √™tre plac√© dans la source du firmware sous la forme d'un tableau de la forme: <br><br><pre><code class="plaintext hljs">const uint8_t Tune[] PROGMEM = { 0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, 0x03, 0xc0, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x0a, 0x7e, 0x00, 0xff, ... 0x50, 0xb0, 0x5b, 0x00, 0x00, 0xff, 0x2f, 0x00 };</code> </pre> <br>  Il existe une solution pr√™te √† l'emploi pour convertir un fichier dans ce format sur des syst√®mes d'exploitation de type UNIX - l'utilitaire xxd.  Nous prenons le fichier MIDI et passons par cet utilitaire comme ceci: <br><br><pre> <code class="plaintext hljs">xxd -i musicbox.mid</code> </pre> <br>  La console affichera quelque chose comme: <br><br><pre> <code class="plaintext hljs">unsigned char musicbox_mid[] = { 0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, 0x03, 0xc0, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x0a, 0x7e, 0x00, 0xff, ... 0x50, 0xb0, 0x5b, 0x00, 0x00, 0xff, 0x2f, 0x00 }; unsigned int musicbox_mid_len = 2708;</code> </pre> <br>  2708 est la longueur en octets.  Il s'est av√©r√© moins de 6000 - ce qui signifie qu'il convient.  La s√©quence de nombres hexad√©cimaux √† travers le presse-papiers est transf√©r√©e vers l'esquisse (rappelez-vous juste: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la console - pas Ctrl + C</a> ) au lieu du tableau par d√©faut.  Ou ne faites pas tout cela si nous voulons le quitter. <br><br>  Le compteur de minuterie 1 fonctionnera √† une fr√©quence de 64 MHz √† partir de la PLL: <br><br><pre> <code class="plaintext hljs"> PLLCSR = 1&lt;&lt;PCKE | 1&lt;&lt;PLLE;</code> </pre> <br>  Nous transf√©rons cette minuterie en mode PWM pour fonctionner comme un DAC; le rapport cyclique d√©pendra de la valeur de OCR1B: <br><br><pre> <code class="plaintext hljs"> TIMSK = 0; // Timer interrupts OFF TCCR1 = 1&lt;&lt;CS10; // 1:1 prescale GTCCR = 1&lt;&lt;PWM1B | 2&lt;&lt;COM1B0; // PWM B, clear on match OCR1B = 128; DDRB = 1&lt;&lt;DDB4; // Enable PWM output on pin 4</code> </pre> <br>  La fr√©quence des impulsions rectangulaires d√©pend de la valeur de OCR1C, nous la laissons √©gale √† 255 (par d√©faut), puis la fr√©quence de 64 MHz sera divis√©e par 256, et nous obtenons 250 kHz. <br><br>  Le compteur de minuterie 0 g√©n√©rera des interruptions: <br><br><pre> <code class="plaintext hljs"> TCCR0A = 3&lt;&lt;WGM00; // Fast PWM TCCR0B = 1&lt;&lt;WGM02 | 2&lt;&lt;CS00; // 1/8 prescale OCR0A = 19; // Divide by 20 TIMSK = 1&lt;&lt;OCIE0A; // Enable compare match, disable overflow</code> </pre> <br>  Une fr√©quence d'horloge de 16 MHz est divis√©e par un diviseur par 8, puis par une valeur OCR0A de 19 + 1, et 100 kHz sont obtenus.  Le lecteur est √† quatre voix, 25 kHz est obtenu pour chaque voix.  Lors d'une interruption, un sous-programme de traitement ISR est appel√© (TIMER0_COMPA_vect), qui calcule et √©met des sons. <br><br>  Le temporisateur du chien de garde est configur√© pour g√©n√©rer une interruption toutes les 16 ms, ce qui est n√©cessaire pour recevoir les fr√©quences des notes: <br><br><pre> <code class="plaintext hljs">WDTCR = 1&lt;&lt;WDIE | 0&lt;&lt;WDP0; // Interrupt every 16ms</code> </pre> <br>  Pour obtenir des oscillations d'une forme donn√©e, une synth√®se num√©rique directe est utilis√©e.  Il n'y a pas de multiplication mat√©rielle dans ATtiny85, nous prenons donc des impulsions rectangulaires et multiplions l'amplitude de l'enveloppe par 1 ou -1.  L'amplitude diminue lin√©airement, et pour la calculer √† un instant donn√©, il suffit de diminuer lin√©airement la lecture du compteur. <br><br>  Trois variables sont fournies pour chaque canal: Fr√©q [] - fr√©quence, Acc [] - batterie de phase, Amp [], valeur d'amplitude d'enveloppe.  Les valeurs de Freq [] et Acc [] sont additionn√©es.  Le bit de poids fort Acc [] est utilis√© pour obtenir des impulsions rectangulaires.  Plus Freq [] est √©lev√©, plus la fr√©quence est √©lev√©e.  La forme d'onde finie est multipli√©e par l'enveloppe Amp [].  Les quatre canaux sont multiplex√©s et envoy√©s √† la sortie analogique. <br><br>  Une partie importante du programme est la proc√©dure de traitement de l'interruption √† partir du compteur de temporisation 0, qui d√©livre les oscillations √† la sortie analogique.  Cette proc√©dure est appel√©e √† une fr√©quence d'environ 95 kHz.  Pour le canal actuel c, il met √† jour les valeurs de Acc [c] et Amp [c], et calcule √©galement la valeur de la note actuelle.  Le r√©sultat est envoy√© au registre de comparaison OCR1B du compteur de temps OCR1B pour obtenir un signal analogique √† la broche 4: <br><br><pre> <code class="plaintext hljs">ISR(TIMER0_COMPA_vect) { static uint8_t c; signed char Temp, Mask, Env, Note; Acc[c] = Acc[c] + Freq[c]; Amp[c] = Amp[c] - (Amp[c] != 0); Temp = Acc[c] &gt;&gt; 8; Temp = Temp &amp; Temp&lt;&lt;1; Mask = Temp &gt;&gt; 7; Env = Amp[c] &gt;&gt; Volume; Note = (Env ^ Mask) + (Mask &amp; 1); OCR1B = Note + 128; c = (c + 1) &amp; 3; }</code> </pre> <br>  String <br><br><pre> <code class="plaintext hljs">Acc[c] = Acc[c] + Freq[c];</code> </pre> <br>  ajoute la fr√©quence freq [c] √† la batterie Acc [c].  Plus Freq [c] est √©lev√©, plus la valeur Acc [c] changera rapidement.  Puis ligne <br><br><pre> <code class="plaintext hljs">Amp[c] = Amp[c] - (Amp[c] != 0);</code> </pre> <br>  diminue la valeur d'amplitude pour un canal donn√©.  Le fragment (Amp [c]! = 0) est n√©cessaire pour qu'apr√®s que l'amplitude ait atteint z√©ro, elle ne diminue plus.  Now line <br><br><pre> <code class="plaintext hljs">Temp = Acc[c] &gt;&gt; 8;</code> </pre> <br>  transf√®re les 9 bits de Acc [c] √©lev√©s √† Temp.  Et la ligne <br><br><pre> <code class="plaintext hljs">Temp = Temp &amp; Temp&lt;&lt;1;</code> </pre> <br>  laisse le bit de poids fort de cette variable √©gal √† un si deux bits de poids fort sont √©gaux √† un et met le bit de poids fort √† z√©ro s'il ne l'est pas.  Le r√©sultat est des impulsions rectangulaires avec un rapport marche / arr√™t de 25/75.  Dans l'une des constructions pr√©c√©dentes, l'auteur a appliqu√© un m√©andre, tandis qu'avec la nouvelle m√©thode, les harmoniques sont un peu plus obtenues.  String <br><br><pre> <code class="plaintext hljs">Mask = Temp &gt;&gt; 7;</code> </pre> <br>  transf√®re les valeurs des bits les plus significatifs aux bits restants de l'octet, par exemple, si le bit le plus significatif √©tait 0, alors 0x00 sera obtenu, et si 1 - alors 0xFF.  String <br><br><pre> <code class="plaintext hljs">Env = Amp[c] &gt;&gt; Volume;</code> </pre> <br>  transf√®re le bit Amp [c] sp√©cifi√© par la valeur Volume √† Env, par d√©faut le bit principal, puisque Volume = 8. String <br><br><pre> <code class="plaintext hljs">Note = (Env ^ Mask) + (Mask &amp; 1);</code> </pre> <br>  Tout cela unit.  Si Mask = 0x00, la valeur Env est attribu√©e √† Note.  Si Mask = 0xFF, alors Note re√ßoit une valeur suppl√©mentaire √† Env + 1, c'est-√†-dire Env avec un signe moins.  Remarque contient maintenant la forme d'onde actuelle, passant de valeurs positives √† des valeurs n√©gatives de l'amplitude actuelle.  String <br><br><pre> <code class="plaintext hljs">OCR1B = Note + 128;</code> </pre> <br>  ajoute 128 √† Note et √©crit le r√©sultat dans OCR1B.  String <br><br><pre> <code class="plaintext hljs">c = (c + 1) &amp; 3;</code> </pre> <br>  produit quatre canaux en fonction des interruptions correspondantes, multiplexant les voix √† la sortie. <br><br>  Douze fr√©quences de notes sont donn√©es dans le tableau: <br><br><pre> <code class="plaintext hljs">unsigned int Scale[] = { 10973, 11626, 12317, 13050, 13826, 14648, 15519, 16442, 17419, 18455, 19552, 20715};</code> </pre> <br>  Les fr√©quences de note des autres octaves sont obtenues en divisant par 2 <sup>n</sup> .  Par exemple, nous divisons 10973 par 2 <sup>4</sup> et nous obtenons 686. Le bit sup√©rieur Acc [c] commutera avec une fr√©quence de 25000 / (65536/685) = 261,7 Hz. <br><br>  Deux variables influencent le son: Volume - volume, de 7 √† 9 et Decay - att√©nuation, de 12 √† 14. Plus la valeur de Decay est √©lev√©e, plus l'att√©nuation est lente. <br><br>  L'interpr√®te MIDI le plus simple ne fait attention qu'aux valeurs de la note, du tempo et du coefficient de division, et ignore les autres donn√©es.  La routine readIgnore () ignore le nombre sp√©cifi√© d'octets dans le tableau re√ßu du fichier: <br><br><pre> <code class="plaintext hljs">void readIgnore (int n) { Ptr = Ptr + n; }</code> </pre> <br>  La routine readNumber () lit un nombre √† partir d'un nombre donn√© d'octets avec une pr√©cision de 4: <br><br><pre> <code class="plaintext hljs">unsigned long readNumber (int n) { long result = 0; for (int i=0; i&lt;n; i++) result = (result&lt;&lt;8) + pgm_read_byte(&amp;Tune[Ptr++]); return result; }</code> </pre> <br>  La routine readVariable () lit un nombre avec une pr√©cision variable MIDI.  Le nombre d'octets dans ce cas peut √™tre de un √† quatre: <br><br><pre> <code class="plaintext hljs">unsigned long readVariable () { long result = 0; uint8_t b; do { b = pgm_read_byte(&amp;Tune[Ptr++]); result = (result&lt;&lt;7) + (b &amp; 0x7F); } while (b &amp; 0x80); return result; }</code> </pre> <br>  Sept bits sont extraits de chaque octet, et le huiti√®me est √©gal √† un si vous avez besoin de lire un autre octet plus loin, ou z√©ro sinon. <br><br>  L'interpr√©teur appelle la routine noteOn () pour jouer la note dans le canal disponible suivant: <br><br><pre> <code class="plaintext hljs">void noteOn (uint8_t number) { uint8_t octave = number/12; uint8_t note = number%12; unsigned int freq = Scale[note]; uint8_t shift = 9-octave; Freq[Chan] = freq&gt;&gt;shift; Amp[Chan] = 1&lt;&lt;Decay; Chan = (Chan + 1) &amp; 3; }</code> </pre> <br>  La variable Ptr indique l'octet suivant √† lire: <br><br><pre> <code class="plaintext hljs">void playMidiData () { Ptr = 0; // Begin at start of file</code> </pre> <br>  Le premier bloc du fichier MIDI est un en-t√™te qui indique le nombre de pistes, le tempo et le rapport de division: <br><br><pre> <code class="plaintext hljs">// Read header chunk unsigned long type = readNumber(4); if (type != MThd) error(1); unsigned long len = readNumber(4); unsigned int format = readNumber(2); unsigned int tracks = readNumber(2); unsigned int division = readNumber(2); // Ticks per beat TempoDivisor = (long)division*16000/Tempo;</code> </pre> <br>  Le coefficient de division est g√©n√©ralement √©gal √† 960. Nous lisons maintenant le nombre donn√© de blocs: <br><br><pre> <code class="plaintext hljs"> // Read track chunks for (int t=0; t&lt;tracks; t++) { type = readNumber(4); if (type != MTrk) error(2); len = readNumber(4); EndBlock = Ptr + len;</code> </pre> <br>  Lisez les √©v√©nements s√©quentiels jusqu'√† la fin du bloc: <br><br><pre> <code class="plaintext hljs"> // Parse track while (Ptr &lt; EndBlock) { unsigned long delta = readVariable(); uint8_t event = readNumber(1); uint8_t eventType = event &amp; 0xF0; if (delta &gt; 0) Delay(delta/TempoDivisor);</code> </pre> <br>  Dans chaque √©v√©nement, le delta est sp√©cifi√© - le retard en unit√©s de temps d√©termin√© par le coefficient de division, qui doit se produire avant cet √©v√©nement.  Pour les √©v√©nements qui devraient se produire ici, delta est nul. <br><br>  Les m√©ta-√©v√©nements sont des √©v√©nements de type 0xFF: <br><br><pre> <code class="plaintext hljs"> // Meta event if (event == 0xFF) { uint8_t mtype = readNumber(1); uint8_t mlen = readNumber(1); // Tempo if (mtype == 0x51) { Tempo = readNumber(mlen); TempoDivisor = (long)division*16000/Tempo; // Ignore other meta events } else readIgnore(mlen);</code> </pre> <br>  Le seul type de m√©ta-√©v√©nement qui nous int√©resse est Tempo, la valeur du tempo en microsecondes.  Par d√©faut, c'est 500 000, soit une demi-seconde, ce qui correspond √† 120 battements par minute. <br><br>  Les √©v√©nements restants sont des √©v√©nements MIDI d√©finis par le premier chiffre hexad√©cimal de leur type.  Nous ne sommes int√©ress√©s que par 0x90 - Note On, jouant des notes sur le canal disponible suivant: <br><br><pre> <code class="plaintext hljs"> // Note off - ignored } else if (eventType == 0x80) { uint8_t number = readNumber(1); uint8_t velocity = readNumber(1); // Note on } else if (eventType == 0x90) { uint8_t number = readNumber(1); uint8_t velocity = readNumber(1); noteOn(number); // Polyphonic key pressure } else if (eventType == 0xA0) readIgnore(2); // Controller change else if (eventType == 0xB0) readIgnore(2); // Program change else if (eventType == 0xC0) readIgnore(1); // Channel key pressure else if (eventType == 0xD0) readIgnore(1); // Pitch bend else if (eventType == 0xD0) readIgnore(2); else error(3); } } }</code> </pre> <br>  Nous ignorons la valeur de v√©locit√©, mais si vous le souhaitez, vous pouvez d√©finir l'amplitude initiale de la note dessus.  Nous sautons le reste des √©v√©nements, leur dur√©e peut √™tre diff√©rente.  Si une erreur se produit dans le fichier MIDI, la LED s'allume. <br><br>  Le microcontr√¥leur fonctionne √† une fr√©quence de 16 MHz, de sorte que le quartz n'est pas n√©cessaire, vous devez configurer correctement la PLL int√©gr√©e.  Pour que le microcontr√¥leur devienne compatible Arduino, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette exp√©rience de</a> Spence Konde est appliqu√©e.  Dans le menu Board, s√©lectionnez le sous-menu ATtinyCore, et l√† - ATtiny25 / 45/85.  Dans les menus suivants, s√©lectionnez: Timer 1 Clock: CPU, BOD Disabled, ATtiny85, 16 MHz (PLL).  S√©lectionnez ensuite Graver Bootloader, puis remplissez le programme.  Le programmateur est utilis√© comme le Tiny AVR Programmer Board de SpinyFun. <br><br>  Le firmware pour CC-BY 4.0, qui a d√©j√† une fugue de Bach en r√© mineur, est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , le fichier MIDI d'origine est pris <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr454394/">https://habr.com/ru/post/fr454394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr454378/index.html">Astronautes russes sur la lune d'ici 2030: pr√©sentation de Rogozin</a></li>
<li><a href="../fr454382/index.html">Ivan Uglyansky et Vladimir Sitnikov sur jug.msk.ru</a></li>
<li><a href="../fr454384/index.html">Correction de la vue au laser - la m√©thode Smile est-elle vraiment efficace?</a></li>
<li><a href="../fr454386/index.html">MessageBox pour AvaloniaUI</a></li>
<li><a href="../fr454388/index.html">ARA: algorithme pour trouver le nombre maximum de points sur une ligne droite</a></li>
<li><a href="../fr454396/index.html">Installer sdl2 sur les principales distributions</a></li>
<li><a href="../fr454398/index.html">Des critiques aux algorithmes: comment la d√©mocratie et la technocratie sont venues dans l'industrie musicale</a></li>
<li><a href="../fr454400/index.html">Rapports quotidiens sur l'√©tat des machines virtuelles avec R et PowerShell</a></li>
<li><a href="../fr454402/index.html">Architecture de la machine d'√©tat Unity pour l'organisation des comportements d'unit√©</a></li>
<li><a href="../fr454404/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 6. Remplissez les blancs (DHCP, TCP, ¬´handshake¬ª, num√©ros de port communs)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>