<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏿 👁‍🗨 🖕🏿 ActivityLifecycleCallbacks - نقطة عمياء في واجهة برمجة التطبيقات العامة 🤸 💸 👻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="منذ الطفولة ، أحب قراءة التعليمات. لقد نشأت ، لكن ما زال يذهلني كيف يهتم البالغون بالتعليمات: يعتقد الكثير منهم أن الجميع يعرفون ، وفي الوقت نفسه يستخ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ActivityLifecycleCallbacks - نقطة عمياء في واجهة برمجة التطبيقات العامة</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/482476/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/h5/7s/op/h57sopubtnsjbnkfclj9sapsho4.png"><br><br>  منذ الطفولة ، أحب قراءة التعليمات.  لقد نشأت ، لكن ما زال يذهلني كيف يهتم البالغون بالتعليمات: يعتقد الكثير منهم أن الجميع يعرفون ، وفي الوقت نفسه يستخدمون وظيفة أو وظيفتين ، بينما يوجد الكثير منهم!  كم كنت تستخدم للحفاظ على درجة الحرارة في الميكروويف؟  وهي في كل شخص تقريبًا. <br><br>  بمجرد أن قررت قراءة الوثائق لفئات مختلفة من إطار أندرويد.  ركضت خلال الفئات الرئيسية: عرض ، نشاط ، جزء ، تطبيق ، وكنت مهتمًا جدًا بطريقة <a href="https://developer.android.com/reference/android/app/Application.html">Application.registerActivityLifecycleCallbacks ()</a> وواجهة <a href="https://developer.android.com/reference/android/app/Application.ActivityLifecycleCallbacks.html">ActivityLifecycleCallbacks</a> .  من أمثلة استخدامه على الإنترنت ، لم يكن هناك شيء أفضل من تسجيل دورة حياة النشاط.  ثم بدأت تجربتي بنفسي ، والآن نحن في Yandex.Money نستخدمها بنشاط لحل مجموعة كاملة من المهام المتعلقة بتأثير كائنات النشاط من الخارج. <br><a name="habracut"></a><br><h1 style=";text-align:right;direction:rtl">  ما هي ActivityLifecycleCallbacks؟ </h1><br>  انظر إلى هذه الواجهة ، إليك ما بدا عليه عندما ظهر في API 14: <br><br><pre style=";text-align:right;direction:rtl"><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityLifecycleCallbacks</span></span></span><span class="hljs-class"> </span></span>{    void onActivityCreated(Activity activity, Bundle savedInstanceState);    void onActivityStarted(Activity activity);    void onActivityResumed(Activity activity);    void onActivityPaused(Activity activity);    void onActivityStopped(Activity activity);    void onActivitySaveInstanceState(Activity activity, Bundle outState);    void onActivityDestroyed(Activity activity); }</code> </pre> <br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">بدءًا من API 29 ، تمت إضافة عدة طرق جديدة إليه</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActivityLifecycleCallbacks</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState) { }   void onActivityCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostCreated( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> Bundle savedInstanceState) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostStarted(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostResumed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPrePaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityPaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostPaused(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostStopped(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreSaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState) { }   void onActivitySaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostSaveInstanceState( <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity, <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Bundle outState) { }   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPreDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { }   void onActivityDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity);   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> void onActivityPostDestroyed(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> Activity activity) { } }</code> </pre> <br></div></div><br>  ربما يتم إعطاء هذه الواجهة القليل من الاهتمام لأنها ظهرت فقط في Android 4.0 ICS.  ولكن دون جدوى ، لأنه يتيح لك القيام بشيء مثير للاهتمام للغاية: التأثير على جميع كائنات النشاط من الخارج.  ولكن المزيد عن ذلك لاحقًا ، وألقِ نظرة فاحصة على الأساليب. <br><br>  تعرض كل طريقة طريقة مماثلة لدورة حياة النشاط ويتم استدعاؤها في الوقت الذي يتم فيه تشغيل الطريقة على أي نشاط في التطبيق.  وهذا هو ، إذا بدأ التطبيق مع MainActivity ، ثم الأول سوف نتلقى مكالمة إلى ActivityLifecycleCallback.onActivityCreated (MainActivity ، خالية). <br><br>  عظيم ، ولكن كيف يعمل؟  لا يوجد سحر هنا: النشاط نفسه يبلغ عن الحالة فيه.  فيما يلي جزء من التعليمات البرمجية من Activity.onCreate (): <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"> mFragments.restoreAllState(p, mLastNonConfigurationInstances != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>           ? mLastNonConfigurationInstances.fragments : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } mFragments.dispatchCreate(); getApplication().dispatchActivityCreated(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mVoiceInteractor != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {</code> </pre><br>  يبدو كما لو أننا أنفسنا فعلنا BaseActivity.  قام بذلك الزملاء من Android فقط ، كما ألزم الجميع باستخدامه.  وهذا جيد جدا! <br><br>  في API 29 ، تعمل هذه الطرق بالطريقة نفسها تقريبًا ، ولكن يتم استدعاء نسخ Pre و Post الخاصة بهم بصدق قبل وبعد أساليب محددة.  من المحتمل أن يتم التحكم به الآن بواسطة ActivityManager ، لكن هذا مجرد تخميني ، لأنني لم أذهب إلى المصدر بما فيه الكفاية لمعرفة ذلك. <br><br><h2 style=";text-align:right;direction:rtl">  كيفية جعل ActivityLifecycleCallbacks تعمل؟ </h2><br>  مثل كل عمليات الاسترجاعات ، يجب عليك أولاً تسجيلها.  نقوم بتسجيل جميع ActivityLifecycleCallbacks في Application.onCreate () ، حتى نحصل على معلومات حول كل النشاط والقدرة على إدارتها. <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() {   <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() registerActivityLifecycleCallbacks(MyCallbacks()) } }</code> </pre> <br>  استطراد صغير: بدءًا من API 29 ، يمكن أيضًا تسجيل ActivityLifecycleCallbacks من داخل النشاط.  سيكون هذا <a href="https://developer.android.com/reference/android/app/Activity.html">رد</a> اتصال <a href="https://developer.android.com/reference/android/app/Activity.html">محلي</a> يعمل فقط لهذا النشاط. <br><br>  هذا كل شيء.  ولكن يمكنك العثور على هذا ببساطة عن طريق إدخال اسم ActivityLifecycleCallbacks في مربع البحث.  سيكون هناك العديد من الأمثلة لتسجيل دورة حياة النشاط ، ولكن هل هذا مثير للاهتمام؟  يحتوي النشاط على العديد من الطرق العامة (حوالي 400) ، ويمكن استخدام كل هذا للقيام بالعديد من الأشياء المثيرة للاهتمام والمفيدة. <br><br><h2 style=";text-align:right;direction:rtl">  ما الذي يمكن القيام به مع هذا؟ </h2><br>  ماذا تريد؟  هل تريد تغيير السمة ديناميكيًا في كل نشاط في التطبيق؟  من فضلك: طريقة setTheme () عامة ، مما يعني أنه يمكنك الاتصال بها من ActivityLifecycleCallback: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThemeCallback</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@StyleRes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTheme: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { activity.setTheme(myTheme) } }</code> </pre> <br>  <b>كرر هذه الخدعة فقط في المنزل</b> <br>  يمكن لبعض الأنشطة من المكتبات المتصلة استخدام سماتها المخصصة.  لذلك ، تحقق من الحزمة أو أي علامة أخرى يمكن من خلالها تحديد أن موضوع هذا النشاط يمكن تغييره بأمان.  على سبيل المثال ، نتحقق من الحزمة مثل هذه (في Kotlinovsky =)): <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThemeCallback</span></span></span></span>( <span class="hljs-meta"><span class="hljs-meta">@StyleRes</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myTheme: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myPackage = <span class="hljs-string"><span class="hljs-string">"my.cool.application"</span></span> activity .takeIf { it.javaClass.name.startsWith(myPackage) } ?.setTheme(myTheme) } }</code> </pre> <br>  هل المثال لا يعمل؟  ربما نسيت تسجيل ThemeCallback في التطبيق أو التطبيق في AndroidManifest. <br><br>  تريد مثالا آخر للاهتمام؟  يمكنك إظهار مربعات الحوار على أي نشاط في التطبيق. <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DialogCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dialogFragment: DialogFragment ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag = dialogFragment.javaClass.name (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? AppCompatActivity) ?.supportFragmentManager ?.also { fragmentManager -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragmentManager.findFragmentByTag(tag) == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { dialogFragment.show(fragmentManager, tag) } } } } }</code> </pre> <br>  <b>كرر هذه الخدعة فقط في المنزل</b> <br>  بالطبع ، يجب ألا تظهر حوارًا على كل شاشة - فلن يحبنا مستخدمونا لهذا الغرض.  لكن في بعض الأحيان قد يكون من المفيد إظهار شيء مثل هذا على بعض الشاشات المحددة. <br><br>  وإليك مثال آخر: ما إذا كنا بحاجة إلى بدء نشاط ما ، كل شيء بسيط هنا: Activity.startActivity () - وقادته.  ولكن ماذا لو كنا بحاجة إلى انتظار النتيجة بعد استدعاء Activity.startActivityForResult ()؟  لدي وصفة واحدة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartingActivityCallback</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application.ActivityLifecycleCallbacks { override fun onActivityCreated</span></span></span></span>( activity: Activity, savedInstanceState: Bundle? ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? AppCompatActivity) ?.supportFragmentManager ?.also { fragmentManager -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startingFragment = findOrCreateFragment(fragmentManager) startingFragment.listener = { resultCode, <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> -&gt; <span class="hljs-comment"><span class="hljs-comment">// handle response here } // start Activity inside StartingFragment } } } private fun findOrCreateFragment( fragmentManager: FragmentManager ): StartingFragment { val tag = StartingFragment::class.java.name return fragmentManager .findFragmentByTag(tag) as StartingFragment? ?: StartingFragment().apply { fragmentManager .beginTransaction() .add(this, tag) .commit() } } }</span></span></code> </pre> <br>  في المثال ، نقوم فقط بإسقاط Fragment ، الذي يبدأ النشاط ويحصل على النتيجة ، ثم يفوض معالجته إلينا.  كن حذرًا: هنا نتحقق من أن نشاطنا هو AppCompatActivity ، مما قد يؤدي إلى حلقة لا نهائية.  استخدام شروط أخرى. <br><br>  دعونا تعقيد الأمثلة.  حتى تلك اللحظة ، استخدمنا فقط تلك الأساليب الموجودة بالفعل في النشاط.  ماذا عن إضافة الخاصة بك؟  لنفترض أننا نريد إرسال تحليلات حول فتح الشاشة.  في الوقت نفسه ، فإن شاشاتنا لها أسماء خاصة بها.  كيفية حل هذه المشكلة؟  بسيط جدا  قم بإنشاء واجهة شاشة يمكنها إعطاء اسم الشاشة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Screen</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String }</code> </pre> <br>  الآن ننفذه في النشاط المطلوب: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), Screen { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String = <span class="hljs-string"><span class="hljs-string">"First screen"</span></span> }</code> </pre> <br>  بعد ذلك ، قمنا بإعداد ActivityLifecycleCallbacks خاص لمثل هذا النشاط: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyticsActivityCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sendAnalytics: (String) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Screen)?.screenName?.let(sendAnalytics) } } }</code> </pre> <br>  ترى؟  نحن فقط نتحقق من الواجهة ونرسل التحليلات إذا تم تنفيذها. <br><br>  كرر لإصلاح.  ماذا تفعل إذا كنت بحاجة لرمي بعض المعلمات؟  تمديد الواجهة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScreenWithParameters</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Screen { val parameters: Map</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String, String</span></span></span><span class="hljs-class">&gt; }</span></span></code> </pre> <br>  ننفذ: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), ScreenWithParameters { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> screenName: String = <span class="hljs-string"><span class="hljs-string">"First screen"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parameters: Map&lt;String, String&gt; = mapOf(<span class="hljs-string"><span class="hljs-string">"key"</span></span> to <span class="hljs-string"><span class="hljs-string">"value"</span></span>) }</code> </pre> <br>  نحن نشحن: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyticsActivityCallback</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sendAnalytics: (String, Map&lt;String, String&gt;?) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) : Application.ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (savedInstanceState == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? Screen)?.screenName?.let { name -&gt; sendAnalytics( name, (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? ScreenWithParameters)?.parameters ) } } } }</code> </pre> <br>  لكنها لا تزال سهلة.  كل هذا كان فقط لإحضارك إلى موضوع مثير للاهتمام: حقن التبعية الأصلية.  نعم ، لدينا خنجر ، كوين ، Guice ، Kodein وأكثر من ذلك.  ولكن في المشاريع الصغيرة ، فهي زائدة عن الحاجة.  ولكن لدي حل ... تخمين أي واحد؟ <br><br>  دعنا نقول أن لدينا بعض الأدوات مثل هذا: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> extraInfo = <span class="hljs-string"><span class="hljs-string">"i am dependency"</span></span> }</code> </pre> <br>  أغلقه مع الواجهة ، مثل المبرمجين البالغين: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolTool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> extraInfo: String } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolImpl</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CoolTool { override val extraInfo = "i am dependency" }</span></span></span></span></code> </pre> <br>  والآن بسحر شارع صغير من ActivityLifecycleCallbacks: سنقوم بإنشاء واجهة لتطبيق هذه التبعية وتنفيذها في الأنشطة الضرورية ، وباستخدام ActivityLifecycleCallbacks سنجده وننفذ تطبيق CoolToolImpl. <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequireCoolTool</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coolTool: CoolTool } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CoolToolActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>(), RequireCoolTool { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coolTool: CoolTool } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectingLifecycleCallbacks</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ActivityLifecycleCallbacks { override fun onActivityCreated</span></span></span></span>( activity: Activity, savedInstanceState: Bundle? ) { (activity <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? RequireCoolTool)?.coolTool = CoolToolImpl() } }</code> </pre> <br>  تذكر تسجيل InjectingLifecycleCallbacks في التطبيق الخاص بك ، قم بتشغيله ويعمل. <br><br>  ولا تنسى اختبار: <br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith(AndroidJUnit4::class)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DIActivityTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> `should access extraInfo </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">when</span></span></span><span class="hljs-function"> created`</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// prepare val mockTool: CoolTool = mock() val application = getApplicationContext&lt;android.app.Application&gt;() application.registerActivityLifecycleCallbacks( object : Application.ActivityLifecycleCallbacks { override fun onActivityCreated( activity: Activity, savedInstanceState: Bundle? ) { (activity as? RequireCoolTool)?.coolTool = mockTool } }) // invoke launch&lt;DIActivity&gt;(Intent(application, DIActivity::class.java)) // assert verify(mockTool).extraInfo } }</span></span></code> </pre> <br>  ولكن في المشروعات الكبيرة ، لن يتطور هذا النهج بشكل جيد ، لذلك لن أسلب أي أطر عمل DI من أي شخص.  حيث من الأفضل الجمع بين الجهود وتحقيق التآزر.  سأريكم مثال Dagger2.  إذا كان لديك بعض النشاط الأساسي في المشروع يقوم بشيء مثل AndroidInjection.inject (هذا) ، فعندئذ حان الوقت لرميها بعيدًا.  بدلاً من ذلك ، قم بما يلي: <br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  وفقًا للتعليمات ، ننفذ تطبيق DispatchingAndroidInjector ؛ </li><li style=";text-align:right;direction:rtl">  إنشاء ActivityLifecycleCallbacks يستدعي DispatchingAndroidInjector.maybeInject () على كل نشاط ؛ </li><li style=";text-align:right;direction:rtl">  تسجيل ActivityLifecycleCallbacks في التطبيق. </li></ol><br><br><pre style=";text-align:right;direction:rtl"> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyApplication</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Any&gt; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate() DaggerYourApplicationComponent.create().inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); registerActivityLifecycleCallbacks( InjectingLifecycleCallbacks( dispatchingAndroidInjector ) ) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InjectingLifecycleCallbacks</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatchingAndroidInjector: DispatchingAndroidInjector&lt;Any&gt; ) : ActivityLifecycleCallbacks { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( activity: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">, savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">? )</span></span></span></span> {       dispatchingAndroidInjector.maybeInject(activity) } }</code> </pre> <br>  ويمكن تحقيق نفس التأثير مع أطر عمل DI الأخرى.  حاول أن تكتب في التعليقات ما حدث. <br><br><h2 style=";text-align:right;direction:rtl">  لتلخيص </h2><br>  ActivityLifecycleCallbacks هي أداة قوية وقليلة.  جرب أحد <a href="https://github.com/yandex-money/android-activitylifecyclecallbacks-example">هذه الأمثلة</a> ، واسمح لهم بمساعدتك في مشاريعك بالطريقة نفسها التي يساعد بها Yandex.Money على تحسين تطبيقاتنا. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar482476/">https://habr.com/ru/post/ar482476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar482462/index.html">تعلم Metaflow في 10 دقائق</a></li>
<li><a href="../ar482464/index.html">ما هي * args و ** kwargs في بيثون؟</a></li>
<li><a href="../ar482466/index.html">5 أشياء يمكنك القيام بها للتحضير لـ Vue 3.0</a></li>
<li><a href="../ar482468/index.html">5 امتدادات وسمات لـ VS Code يمكنها تغيير حياة مطور الواجهة الأمامية</a></li>
<li><a href="../ar482472/index.html">ما هو جافا سكريبت مصنوعة من؟</a></li>
<li><a href="../ar482478/index.html">إيتابتور: مكتبة لإعادة رسم خريطة شفافة عميقة</a></li>
<li><a href="../ar482482/index.html">لعب الأدوار</a></li>
<li><a href="../ar482484/index.html">كيفية زيادة كفاءة التنمية باستخدام نظرية القيود</a></li>
<li><a href="../ar482486/index.html">ما هي ميسرا وكيف تطبخها</a></li>
<li><a href="../ar482490/index.html">ما هو MISRA وكيفية طبخه</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>