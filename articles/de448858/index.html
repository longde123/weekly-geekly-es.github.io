<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍✈️ 🍉 👩🏻‍🤝‍👨🏾 Verwenden Sie hierfür keine Ngrx / Effekte mehr 🤞🏽 💴 🅾️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Manchmal verursacht die einfachste Implementierung von Funktionen letztendlich mehr Probleme als gute und erhöht nur die Komplexität an anderer Stelle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden Sie hierfür keine Ngrx / Effekte mehr</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448858/"><img src="https://habrastorage.org/webt/73/82/fl/7382flctc9zmk_xd-mox_6ahrru.jpeg" alt="Büste mit Effekten"><br><br>  Manchmal verursacht die einfachste Implementierung von Funktionen letztendlich mehr Probleme als gute und erhöht nur die Komplexität an anderer Stelle.  Das Endergebnis ist eine gezackte Architektur, die niemand berühren möchte. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Anmerkungen des Übersetzers</b> <div class="spoiler_text"><p>  Der Artikel wurde 2017 geschrieben, ist aber bis heute relevant.  Es richtet sich an Personen, die Erfahrung mit RxJS und Ngrx haben oder Redux in Angular ausprobieren möchten. </p><br>  Die Codefragmente wurden basierend auf der aktuellen RxJS-Syntax aktualisiert und leicht modifiziert, um die Lesbarkeit und das Verständnis zu verbessern. <br></div></div><br><p> Ngrx / store ist eine Angular-Bibliothek, mit deren Hilfe die Komplexität einzelner Funktionen berücksichtigt werden kann.  Ein Grund dafür ist, dass ngrx / store eine funktionale Programmierung umfasst, die die Möglichkeiten innerhalb einer Funktion einschränkt, um außerhalb eine vernünftigere Funktion zu erzielen.  In ngrx / store sind Dinge wie Reduzierer (im Folgenden als Reduzierer bezeichnet), Selektoren (im Folgenden als Selektoren bezeichnet) und RxJS-Operatoren reine Funktionen. </p><br><p>  Reine Funktionen sind einfacher zu testen, zu debuggen, zu analysieren, zu parallelisieren und zu kombinieren.  Eine Funktion ist sauber, wenn: </p><br><ul><li>  Mit derselben Eingabe wird immer dieselbe Ausgabe zurückgegeben. </li><li>  Keine Nebenwirkungen. </li></ul><br><p>  Nebenwirkungen können nicht vermieden werden, sind jedoch in ngrx / store isoliert, sodass der Rest der Anwendung aus reinen Funktionen bestehen kann. </p><br><h3>  Nebenwirkungen </h3><br><p>  Wenn der Benutzer das Formular sendet, müssen wir Änderungen auf dem Server vornehmen.  Das Ändern des Servers und das Antworten auf den Client ist ein Nebeneffekt.  Dies kann in der Komponente behandelt werden: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data) <span class="hljs-comment"><span class="hljs-comment">// POST    .pipe(map(res =&gt; this.store.dispatch({ type: 'DATA_SAVED' }))) .subscribe();</span></span></code> </pre> <br><p>  Es wäre schön, wenn wir die Aktion (im Folgenden die Aktion) nur innerhalb der Komponente auslösen könnten, wenn der Benutzer das Formular einreicht und die Nebenwirkung an anderer Stelle behandelt. </p><br><p>  Ngrx / Effects ist eine Middleware zur Behandlung von Nebenwirkungen in Ngrx / Store.  Es wartet auf übermittelte Aktionen im beobachtbaren Thread, führt Nebenwirkungen aus und gibt neue Aktionen sofort oder asynchron zurück.  Die zurückgegebenen Aktionen werden an den Reduzierer übergeben. </p><br><p>  Die Fähigkeit, Nebenwirkungen auf RxJS-Weise zu behandeln, macht den Code sauberer.  Nachdem Sie die erste Aktion <code>SAVE_DATA</code> von der Komponente <code>SAVE_DATA</code> , erstellen Sie eine <code>SAVE_DATA</code> , um den Rest zu erledigen: </p><br><pre> <code class="javascript hljs">@Effect() saveData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>), pluck(<span class="hljs-string"><span class="hljs-string">'payload'</span></span>), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data)), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DATA_SAVED'</span></span> })), );</code> </pre><br><p>  Dies vereinfacht den Betrieb der Komponente nur vor dem Senden von Aktionen und dem Abonnieren von Observable. </p><br><h2>  Leicht zu missbrauchen Ngrx / Effekte </h2><br><p>  Ngrx / Effekte ist eine sehr leistungsfähige Lösung, daher ist es leicht zu missbrauchen.  Hier sind einige gängige Anti-Patterns für ngrx / store, die durch Ngrx / -Effekte vereinfacht werden: </p><br><h3>  1. Doppelter Status </h3><br><p>  Angenommen, Sie arbeiten an einer Multimedia-Anwendung und haben im Statusbaum die folgenden Eigenschaften: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">mediaPlaying</span></span>: boolean; audioPlaying: boolean; videoPlaying: boolean; }</code> </pre><br><p>  Da Audio eine Art von Medium ist, sollte <code>audioPlaying</code> auch dann wahr sein, wenn <code>audioPlaying</code> wahr ist.  Hier ist also die Frage: "Wie stelle ich sicher, dass mediaPlaying aktualisiert wird, wenn audioPlaying aktualisiert wird?" </p><br><p>  <b>Ungültige Antwort</b> : Ngrx / Effekte verwenden! </p><br><pre> <code class="javascript hljs">@Effect() playMediaWithAudio$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'PLAY_AUDIO'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'PLAY_MEDIA'</span></span> })), );</code> </pre><br><p>  <b>Die richtige Antwort lautet</b> : Wenn der Status von <code>mediaPlaying</code> vollständig von einem anderen Teil des <code>mediaPlaying</code> vorhergesagt wird, ist dies kein echter Status.  Dies ist ein abgeleiteter Zustand.  Es gehört dem Selektor, nicht dem Laden. </p><br><pre> <code class="javascript hljs">audioPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'audioPlaying'</span></span>); videoPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'videoPlaying'</span></span>); mediaPlaying$ = combineLatest(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.audioPlaying$, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.videoPlaying$).pipe( map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[audioPlaying, videoPlaying]</span></span></span><span class="hljs-function">) =&gt;</span></span> audioPlaying || videoPlaying), );</code> </pre><br><p>  Jetzt kann unser Zustand sauber und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normal</a> bleiben, und wir verwenden Ngrx / Effekte nicht für etwas, das keine Nebenwirkung ist. </p><br><h3>  2. Verkettungsaktionen mit Reduzierstück </h3><br><p>  Stellen Sie sich vor, Sie haben diese Eigenschaften in Ihrem Statusbaum: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">items</span></span>: { [index: number]: Item }; favoriteItems: number[]; }</code> </pre><br><p>  Dann löscht der Benutzer das Element.  Wenn die <code>DELETE_ITEM_SUCCESS</code> zurückgegeben wird, wird die Aktion <code>DELETE_ITEM_SUCCESS</code> gesendet, um den Status unserer Anwendung zu aktualisieren.  Im Artikelreduzierer wird ein einzelner <code>Item</code> aus dem <code>Item</code> entfernt.  Wenn sich dieser Elementbezeichner jedoch im Array " <code>favoriteItems</code> , fehlt das Element, auf das er verweist.  Die Frage ist also, wie ich sicherstellen kann, dass der Bezeichner beim Senden der Aktion <code>DELETE_ITEM_SUCCESS</code> aus <code>favoriteItems</code> entfernt wird. </p><br><p>  <b>Ungültige Antwort</b> : Ngrx / Effekte verwenden! </p><br><pre> <code class="javascript hljs">@Effect() removeFavoriteItemId$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM_ID'</span></span> })), );</code> </pre><br><p>  Jetzt werden zwei Aktionen nacheinander gesendet, und zwei Reduzierer geben nacheinander neue Zustände zurück. </p><br><p>  <b>Richtige Antwort</b> : <code>DELETE_ITEM_SUCCESS</code> kann sowohl vom <code>DELETE_ITEM_SUCCESS</code> als auch vom <code>favoriteItems</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">favoriteItemsReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = initialState, action: Action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemId = action.payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> id !== itemId); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre><br><p>  Ziel der Aktion ist es, zu trennen, was passiert ist und wie sich der Staat ändern soll.  Was passiert ist, war <code>DELETE_ITEM_SUCCESS</code> .  Die Aufgabe von Reduzierern besteht darin, eine entsprechende Zustandsänderung zu bewirken. </p><br><p>  Das Entfernen eines Bezeichners aus <code>favoriteItems</code> kein Nebeneffekt beim Löschen eines <code>Item</code> .  Der gesamte Prozess ist vollständig synchronisiert und kann von Reduzierern verarbeitet werden.  Ngrx / Effekte werden nicht benötigt. </p><br><h3>  3. Fordern Sie Daten für die Komponente an </h3><br><p>  Ihre Komponente benötigt Daten aus dem Speicher, aber zuerst müssen Sie sie vom Server abrufen.  Die Frage ist, wie können wir die Daten in den Speicher stellen, damit die Komponente sie empfangen kann? </p><br><p>  <b>Schmerzhafter Weg</b> : Ngrx / Effekte verwenden! </p><br><p>  In der Komponente initiieren wir die Anforderung, indem wir eine Aktion senden: </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> }); }</code> </pre><br><p>  In der <code>GET_USERS</code> hören wir <code>GET_USERS</code> : </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), );</code> </pre><br><p>  Angenommen, der Benutzer entscheidet, dass das Laden einer bestimmten Route zu lange dauert, sodass er von einer zur anderen wechselt.  Um effizient zu sein und keine unnötigen Daten zu laden, möchten wir diese Anfrage abbrechen.  Wenn die Komponente zerstört wird, werden wir die Anforderung durch Senden der folgenden Aktion abbestellen: </p><br><pre> <code class="javascript hljs">ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> }); }</code> </pre><br><p>  Jetzt hören wir in der Effektklasse beide Aktionen: </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>, <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> action), switchMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> action.type === <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>() : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers().pipe(map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users }))), ), );</code> </pre><br><p>  Gut.  Jetzt fügt ein anderer Entwickler eine Komponente hinzu, für die dieselbe HTTP-Anforderung erforderlich ist (wir werden keine Annahmen über andere Komponenten treffen).  Die Komponente sendet dieselben Aktionen an denselben Orten.  Wenn beide Komponenten gleichzeitig aktiv sind, initiiert die erste Komponente eine HTTP-Anforderung, um sie zu initialisieren.  Wenn die zweite Komponente initialisiert wird, geschieht nichts <code>needUsers</code> , da <code>needUsers</code> <code>false</code> .  Großartig! </p><br><p>  Wenn die erste Komponente zerstört wird, sendet sie <code>CANCEL_GET_USERS</code> .  Die zweite Komponente benötigt diese Daten jedoch weiterhin.  Wie können wir verhindern, dass eine Anfrage storniert wird?  Vielleicht starten wir den Zähler aller Abonnenten?  Ich werde dies nicht umsetzen, aber ich nehme an, Sie haben den Punkt verstanden.  Wir beginnen zu vermuten, dass es einen besseren Weg gibt, diese Datenabhängigkeiten zu verwalten. </p><br><p>  Angenommen, eine andere Komponente wird angezeigt. Dies hängt von Daten ab, die erst abgerufen werden können, wenn <code>users</code> im Geschäft angezeigt werden.  Dies kann eine Verbindung zu einem Web-Socket für den Chat, zusätzliche Informationen zu einigen Benutzern oder etwas anderes sein.  Wir wissen nicht, ob diese Komponente vor oder nach dem Abonnieren von zwei anderen Komponenten für <code>users</code> initialisiert wird. </p><br><p>  Die beste Hilfe, die ich für dieses spezielle Szenario gefunden habe, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser großartige Beitrag</a> .  In seinem Beispiel erfordert <code>callApiY</code> , dass <code>callApiX</code> bereits abgeschlossen ist.  Ich habe die Kommentare entfernt, damit sie weniger einschüchternd wirken. Sie können jedoch auch den Originalbeitrag lesen, um mehr zu erfahren: </p><br><pre> <code class="javascript hljs">@Effect() actionX$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>), map(toPayload), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiX(payload).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err })), ), ), ); @Effect() actionY$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_Y'</span></span>), map(toPayload), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> state.someBoolean)), switchMap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[payload, someBoolean]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callHttpY = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiY(v).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err, }), ), ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someBoolean) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>, payload }).merge( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>), first(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.type === <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">'Because ACTION_X failed.'</span></span>, }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); }), ), ); }), );</code> </pre><br><p>  Fügen Sie nun die Anforderung hinzu, dass HTTP-Anforderungen abgebrochen werden müssen, wenn Komponenten sie nicht mehr benötigen. Dies wird noch komplexer. </p><br><h3><pre>  .  .  . </pre></h3><br><p>  Warum gibt es so viele Probleme mit dem Datenabhängigkeitsmanagement, wenn RxJS es wirklich einfach machen sollte? </p><br><p>  Obwohl die vom Server kommenden Daten technisch gesehen ein Nebeneffekt sind, scheint es mir nicht, dass Ngrx / Effekte der beste Weg ist, damit umzugehen. </p><br><p>  Komponenten sind Benutzereingabe- / Ausgabeschnittstellen.  Sie zeigen Daten und senden von ihm ausgeführte Aktionen.  Wenn eine Komponente geladen wird, sendet sie keine von diesem Benutzer ausgeführten Aktionen.  Er möchte die Daten anzeigen.  Dies ist eher ein Abonnement als ein Nebeneffekt. </p><br><p>  Sehr oft sehen Sie Anwendungen, die Aktionen verwenden, um eine Datenanforderung zu initiieren.  Diese Anwendungen implementieren eine spezielle Schnittstelle zur Beobachtung durch Nebenwirkungen.  Und wie wir gesehen haben, kann diese Schnittstelle sehr unpraktisch und umständlich werden.  Das Abonnieren, Abbestellen und Verbinden von Observable selbst ist viel einfacher. </p><br><h3><pre>  .  .  . </pre></h3><br><p>  <b>Weniger schmerzhaft</b> : Die Komponente registriert ihr Interesse an den Daten, indem sie diese über Observable abonniert. </p><br><p>  Wir werden Observable erstellen, die die notwendigen HTTP-Anfragen enthalten.  Wir werden sehen, wie viel einfacher es ist, mehrere Abonnements und Abfrageketten, die voneinander abhängig sind, mit reinem RxJS zu verwalten, anstatt dies durch Effekte zu tun. </p><br><p>  Erstellen Sie diese im Service beobachtbaren: </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), finalize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), );</code> </pre><br><p>  Das Abonnement für <code>users$</code> wird sowohl an <code>requireUsers$</code> als auch an <code>this.store.pipe(select(selectUsers))</code> , die Daten werden jedoch nur von <code>this.store.pipe(select(selectUsers))</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>muteFirst</code></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>muteFirst</code></a> Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>muteFirst</code></a> und festes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>muteFirst</code></a> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihrem Test</a> .) </p><br><p>  In Komponente: </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.users$; }</code> </pre><br><p>  Da diese Datenabhängigkeit jetzt einfach zu beobachten ist, können wir die Vorlage mithilfe der <code>async</code> Pipe abonnieren und abbestellen, und wir müssen keine Aktionen mehr senden.  Wenn die Anwendung die Route der letzten für Daten signierten Komponente verlässt, wird die HTTP-Anforderung abgebrochen oder der Web-Socket geschlossen. </p><br><p>  Die Datenabhängigkeitskette kann folgendermaßen verarbeitet werden: </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), ); requireUsersExtraData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$.pipe( withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectNeedUsersExtraData))), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[users, needData]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(users.length) &amp;&amp; needData), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS_EXTRA_DATA'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS_EXTRA_DATA'</span></span>, users, }), ), share(), ); public usersExtraData$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsersExtraData$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsersExtraData)), );</code> </pre><br><p>  Hier ist ein paralleler Vergleich der obigen Methode mit dieser Methode: </p><br><img src="https://habrastorage.org/webt/xd/cb/ho/xdcbhozsjus5vu64eqp9x8nsnuy.png" alt="paralleler Vergleich"><br><br><p>  Die Verwendung von rein beobachtbar erfordert weniger Codezeilen und wird automatisch von Datenabhängigkeiten in der gesamten Kette abgemeldet.  (Ich habe die ursprünglich enthaltenen <code>finalize</code> Anweisungen übersprungen, um den Vergleich verständlicher zu machen, aber auch ohne sie werden Abfragen entsprechend abgebrochen.) </p><br><img src="https://habrastorage.org/webt/mj/2m/pc/mj2mpclzeric84dwrap4c5fpkqm.jpeg" alt="Effekte wie Kirsche in einem Cocktail"><br><br><h2>  Fazit </h2><br><p>  Ngrx / Effekte ist ein großartiges Werkzeug!  Berücksichtigen Sie jedoch diese Fragen, bevor Sie sie verwenden: </p><br><ul><li>  Ist das wirklich ein Nebeneffekt? </li><li>  Ist Ngrx / Effects der beste Weg, dies zu tun? </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448858/">https://habr.com/ru/post/de448858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448840/index.html">Digitale Veranstaltungen in Moskau vom 22. bis 28. April</a></li>
<li><a href="../de448842/index.html">Honeywell HAQ Luftqualitätsmonitor</a></li>
<li><a href="../de448846/index.html">Was bei der Implementierung von Agile in einem großen Unternehmen nicht zu vergessen ist</a></li>
<li><a href="../de448854/index.html">Crew Dragon explodierte</a></li>
<li><a href="../de448856/index.html">Torfon - eine mobile Anwendung für anonyme Telefonie</a></li>
<li><a href="../de448860/index.html">Versionshinweise zu Android Studio 3.4 (April 2019)</a></li>
<li><a href="../de448866/index.html">Einzelheiten zum Übergang von gepaarten (relativen) Wechselkursen zu absoluten. Fehlerbehandlung</a></li>
<li><a href="../de448868/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 295 (vom 15. bis 21. April)</a></li>
<li><a href="../de448870/index.html">Optlib Implementierung eines genetischen Optimierungsalgorithmus in Rust</a></li>
<li><a href="../de448872/index.html">Intercom-Buchübersetzung zum Produktmanagement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>