<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äç‚úàÔ∏è üçâ üë©üèª‚Äçü§ù‚Äçüë®üèæ Verwenden Sie hierf√ºr keine Ngrx / Effekte mehr ü§ûüèΩ üí¥ üÖæÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Manchmal verursacht die einfachste Implementierung von Funktionen letztendlich mehr Probleme als gute und erh√∂ht nur die Komplexit√§t an anderer Stelle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden Sie hierf√ºr keine Ngrx / Effekte mehr</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448858/"><img src="https://habrastorage.org/webt/73/82/fl/7382flctc9zmk_xd-mox_6ahrru.jpeg" alt="B√ºste mit Effekten"><br><br>  Manchmal verursacht die einfachste Implementierung von Funktionen letztendlich mehr Probleme als gute und erh√∂ht nur die Komplexit√§t an anderer Stelle.  Das Endergebnis ist eine gezackte Architektur, die niemand ber√ºhren m√∂chte. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Anmerkungen des √úbersetzers</b> <div class="spoiler_text"><p>  Der Artikel wurde 2017 geschrieben, ist aber bis heute relevant.  Es richtet sich an Personen, die Erfahrung mit RxJS und Ngrx haben oder Redux in Angular ausprobieren m√∂chten. </p><br>  Die Codefragmente wurden basierend auf der aktuellen RxJS-Syntax aktualisiert und leicht modifiziert, um die Lesbarkeit und das Verst√§ndnis zu verbessern. <br></div></div><br><p> Ngrx / store ist eine Angular-Bibliothek, mit deren Hilfe die Komplexit√§t einzelner Funktionen ber√ºcksichtigt werden kann.  Ein Grund daf√ºr ist, dass ngrx / store eine funktionale Programmierung umfasst, die die M√∂glichkeiten innerhalb einer Funktion einschr√§nkt, um au√üerhalb eine vern√ºnftigere Funktion zu erzielen.  In ngrx / store sind Dinge wie Reduzierer (im Folgenden als Reduzierer bezeichnet), Selektoren (im Folgenden als Selektoren bezeichnet) und RxJS-Operatoren reine Funktionen. </p><br><p>  Reine Funktionen sind einfacher zu testen, zu debuggen, zu analysieren, zu parallelisieren und zu kombinieren.  Eine Funktion ist sauber, wenn: </p><br><ul><li>  Mit derselben Eingabe wird immer dieselbe Ausgabe zur√ºckgegeben. </li><li>  Keine Nebenwirkungen. </li></ul><br><p>  Nebenwirkungen k√∂nnen nicht vermieden werden, sind jedoch in ngrx / store isoliert, sodass der Rest der Anwendung aus reinen Funktionen bestehen kann. </p><br><h3>  Nebenwirkungen </h3><br><p>  Wenn der Benutzer das Formular sendet, m√ºssen wir √Ñnderungen auf dem Server vornehmen.  Das √Ñndern des Servers und das Antworten auf den Client ist ein Nebeneffekt.  Dies kann in der Komponente behandelt werden: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data) <span class="hljs-comment"><span class="hljs-comment">// POST    .pipe(map(res =&gt; this.store.dispatch({ type: 'DATA_SAVED' }))) .subscribe();</span></span></code> </pre> <br><p>  Es w√§re sch√∂n, wenn wir die Aktion (im Folgenden die Aktion) nur innerhalb der Komponente ausl√∂sen k√∂nnten, wenn der Benutzer das Formular einreicht und die Nebenwirkung an anderer Stelle behandelt. </p><br><p>  Ngrx / Effects ist eine Middleware zur Behandlung von Nebenwirkungen in Ngrx / Store.  Es wartet auf √ºbermittelte Aktionen im beobachtbaren Thread, f√ºhrt Nebenwirkungen aus und gibt neue Aktionen sofort oder asynchron zur√ºck.  Die zur√ºckgegebenen Aktionen werden an den Reduzierer √ºbergeben. </p><br><p>  Die F√§higkeit, Nebenwirkungen auf RxJS-Weise zu behandeln, macht den Code sauberer.  Nachdem Sie die erste Aktion <code>SAVE_DATA</code> von der Komponente <code>SAVE_DATA</code> , erstellen Sie eine <code>SAVE_DATA</code> , um den Rest zu erledigen: </p><br><pre> <code class="javascript hljs">@Effect() saveData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'SAVE_DATA'</span></span>), pluck(<span class="hljs-string"><span class="hljs-string">'payload'</span></span>), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.saveData(data)), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'DATA_SAVED'</span></span> })), );</code> </pre><br><p>  Dies vereinfacht den Betrieb der Komponente nur vor dem Senden von Aktionen und dem Abonnieren von Observable. </p><br><h2>  Leicht zu missbrauchen Ngrx / Effekte </h2><br><p>  Ngrx / Effekte ist eine sehr leistungsf√§hige L√∂sung, daher ist es leicht zu missbrauchen.  Hier sind einige g√§ngige Anti-Patterns f√ºr ngrx / store, die durch Ngrx / -Effekte vereinfacht werden: </p><br><h3>  1. Doppelter Status </h3><br><p>  Angenommen, Sie arbeiten an einer Multimedia-Anwendung und haben im Statusbaum die folgenden Eigenschaften: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">mediaPlaying</span></span>: boolean; audioPlaying: boolean; videoPlaying: boolean; }</code> </pre><br><p>  Da Audio eine Art von Medium ist, sollte <code>audioPlaying</code> auch dann wahr sein, wenn <code>audioPlaying</code> wahr ist.  Hier ist also die Frage: "Wie stelle ich sicher, dass mediaPlaying aktualisiert wird, wenn audioPlaying aktualisiert wird?" </p><br><p>  <b>Ung√ºltige Antwort</b> : Ngrx / Effekte verwenden! </p><br><pre> <code class="javascript hljs">@Effect() playMediaWithAudio$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'PLAY_AUDIO'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'PLAY_MEDIA'</span></span> })), );</code> </pre><br><p>  <b>Die richtige Antwort lautet</b> : Wenn der Status von <code>mediaPlaying</code> vollst√§ndig von einem anderen Teil des <code>mediaPlaying</code> vorhergesagt wird, ist dies kein echter Status.  Dies ist ein abgeleiteter Zustand.  Es geh√∂rt dem Selektor, nicht dem Laden. </p><br><pre> <code class="javascript hljs">audioPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'audioPlaying'</span></span>); videoPlaying$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-string"><span class="hljs-string">'videoPlaying'</span></span>); mediaPlaying$ = combineLatest(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.audioPlaying$, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.videoPlaying$).pipe( map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[audioPlaying, videoPlaying]</span></span></span><span class="hljs-function">) =&gt;</span></span> audioPlaying || videoPlaying), );</code> </pre><br><p>  Jetzt kann unser Zustand sauber und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">normal</a> bleiben, und wir verwenden Ngrx / Effekte nicht f√ºr etwas, das keine Nebenwirkung ist. </p><br><h3>  2. Verkettungsaktionen mit Reduzierst√ºck </h3><br><p>  Stellen Sie sich vor, Sie haben diese Eigenschaften in Ihrem Statusbaum: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface State { <span class="hljs-attr"><span class="hljs-attr">items</span></span>: { [index: number]: Item }; favoriteItems: number[]; }</code> </pre><br><p>  Dann l√∂scht der Benutzer das Element.  Wenn die <code>DELETE_ITEM_SUCCESS</code> zur√ºckgegeben wird, wird die Aktion <code>DELETE_ITEM_SUCCESS</code> gesendet, um den Status unserer Anwendung zu aktualisieren.  Im Artikelreduzierer wird ein einzelner <code>Item</code> aus dem <code>Item</code> entfernt.  Wenn sich dieser Elementbezeichner jedoch im Array " <code>favoriteItems</code> , fehlt das Element, auf das er verweist.  Die Frage ist also, wie ich sicherstellen kann, dass der Bezeichner beim Senden der Aktion <code>DELETE_ITEM_SUCCESS</code> aus <code>favoriteItems</code> entfernt wird. </p><br><p>  <b>Ung√ºltige Antwort</b> : Ngrx / Effekte verwenden! </p><br><pre> <code class="javascript hljs">@Effect() removeFavoriteItemId$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM_ID'</span></span> })), );</code> </pre><br><p>  Jetzt werden zwei Aktionen nacheinander gesendet, und zwei Reduzierer geben nacheinander neue Zust√§nde zur√ºck. </p><br><p>  <b>Richtige Antwort</b> : <code>DELETE_ITEM_SUCCESS</code> kann sowohl vom <code>DELETE_ITEM_SUCCESS</code> als auch vom <code>favoriteItems</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">favoriteItemsReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = initialState, action: Action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'REMOVE_FAVORITE_ITEM'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'DELETE_ITEM_SUCCESS'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itemId = action.payload; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id</span></span></span><span class="hljs-function"> =&gt;</span></span> id !== itemId); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre><br><p>  Ziel der Aktion ist es, zu trennen, was passiert ist und wie sich der Staat √§ndern soll.  Was passiert ist, war <code>DELETE_ITEM_SUCCESS</code> .  Die Aufgabe von Reduzierern besteht darin, eine entsprechende Zustands√§nderung zu bewirken. </p><br><p>  Das Entfernen eines Bezeichners aus <code>favoriteItems</code> kein Nebeneffekt beim L√∂schen eines <code>Item</code> .  Der gesamte Prozess ist vollst√§ndig synchronisiert und kann von Reduzierern verarbeitet werden.  Ngrx / Effekte werden nicht ben√∂tigt. </p><br><h3>  3. Fordern Sie Daten f√ºr die Komponente an </h3><br><p>  Ihre Komponente ben√∂tigt Daten aus dem Speicher, aber zuerst m√ºssen Sie sie vom Server abrufen.  Die Frage ist, wie k√∂nnen wir die Daten in den Speicher stellen, damit die Komponente sie empfangen kann? </p><br><p>  <b>Schmerzhafter Weg</b> : Ngrx / Effekte verwenden! </p><br><p>  In der Komponente initiieren wir die Anforderung, indem wir eine Aktion senden: </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> }); }</code> </pre><br><p>  In der <code>GET_USERS</code> h√∂ren wir <code>GET_USERS</code> : </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), );</code> </pre><br><p>  Angenommen, der Benutzer entscheidet, dass das Laden einer bestimmten Route zu lange dauert, sodass er von einer zur anderen wechselt.  Um effizient zu sein und keine unn√∂tigen Daten zu laden, m√∂chten wir diese Anfrage abbrechen.  Wenn die Komponente zerst√∂rt wird, werden wir die Anforderung durch Senden der folgenden Aktion abbestellen: </p><br><pre> <code class="javascript hljs">ngOnDestroy() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> }); }</code> </pre><br><p>  Jetzt h√∂ren wir in der Effektklasse beide Aktionen: </p><br><pre> <code class="javascript hljs">@Effect getUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span>, <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span>), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userSelectors.needUsers$), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> needUsers), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[action, needUsers]</span></span></span><span class="hljs-function">) =&gt;</span></span> action), switchMap( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> action.type === <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>() : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers().pipe(map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users }))), ), );</code> </pre><br><p>  Gut.  Jetzt f√ºgt ein anderer Entwickler eine Komponente hinzu, f√ºr die dieselbe HTTP-Anforderung erforderlich ist (wir werden keine Annahmen √ºber andere Komponenten treffen).  Die Komponente sendet dieselben Aktionen an denselben Orten.  Wenn beide Komponenten gleichzeitig aktiv sind, initiiert die erste Komponente eine HTTP-Anforderung, um sie zu initialisieren.  Wenn die zweite Komponente initialisiert wird, geschieht nichts <code>needUsers</code> , da <code>needUsers</code> <code>false</code> .  Gro√üartig! </p><br><p>  Wenn die erste Komponente zerst√∂rt wird, sendet sie <code>CANCEL_GET_USERS</code> .  Die zweite Komponente ben√∂tigt diese Daten jedoch weiterhin.  Wie k√∂nnen wir verhindern, dass eine Anfrage storniert wird?  Vielleicht starten wir den Z√§hler aller Abonnenten?  Ich werde dies nicht umsetzen, aber ich nehme an, Sie haben den Punkt verstanden.  Wir beginnen zu vermuten, dass es einen besseren Weg gibt, diese Datenabh√§ngigkeiten zu verwalten. </p><br><p>  Angenommen, eine andere Komponente wird angezeigt. Dies h√§ngt von Daten ab, die erst abgerufen werden k√∂nnen, wenn <code>users</code> im Gesch√§ft angezeigt werden.  Dies kann eine Verbindung zu einem Web-Socket f√ºr den Chat, zus√§tzliche Informationen zu einigen Benutzern oder etwas anderes sein.  Wir wissen nicht, ob diese Komponente vor oder nach dem Abonnieren von zwei anderen Komponenten f√ºr <code>users</code> initialisiert wird. </p><br><p>  Die beste Hilfe, die ich f√ºr dieses spezielle Szenario gefunden habe, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser gro√üartige Beitrag</a> .  In seinem Beispiel erfordert <code>callApiY</code> , dass <code>callApiX</code> bereits abgeschlossen ist.  Ich habe die Kommentare entfernt, damit sie weniger einsch√ºchternd wirken. Sie k√∂nnen jedoch auch den Originalbeitrag lesen, um mehr zu erfahren: </p><br><pre> <code class="javascript hljs">@Effect() actionX$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>), map(toPayload), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">payload</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiX(payload).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err })), ), ), ); @Effect() actionY$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_Y'</span></span>), map(toPayload), withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.select(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function"> =&gt;</span></span> state.someBoolean)), switchMap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[payload, someBoolean]</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callHttpY = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">v</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.api.callApiY(v).pipe( map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_SUCCESS'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: data, })), catchError(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: err, }), ), ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (someBoolean) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_X'</span></span>, payload }).merge( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.actions$.pipe( ofType(<span class="hljs-string"><span class="hljs-string">'ACTION_X_SUCCESS'</span></span>, <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>), first(), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.type === <span class="hljs-string"><span class="hljs-string">'ACTION_X_FAIL'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span>({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'ACTION_Y_FAIL'</span></span>, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">'Because ACTION_X failed.'</span></span>, }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callHttpY(payload); }), ), ); }), );</code> </pre><br><p>  F√ºgen Sie nun die Anforderung hinzu, dass HTTP-Anforderungen abgebrochen werden m√ºssen, wenn Komponenten sie nicht mehr ben√∂tigen. Dies wird noch komplexer. </p><br><h3><pre>  .  .  . </pre></h3><br><p>  Warum gibt es so viele Probleme mit dem Datenabh√§ngigkeitsmanagement, wenn RxJS es wirklich einfach machen sollte? </p><br><p>  Obwohl die vom Server kommenden Daten technisch gesehen ein Nebeneffekt sind, scheint es mir nicht, dass Ngrx / Effekte der beste Weg ist, damit umzugehen. </p><br><p>  Komponenten sind Benutzereingabe- / Ausgabeschnittstellen.  Sie zeigen Daten und senden von ihm ausgef√ºhrte Aktionen.  Wenn eine Komponente geladen wird, sendet sie keine von diesem Benutzer ausgef√ºhrten Aktionen.  Er m√∂chte die Daten anzeigen.  Dies ist eher ein Abonnement als ein Nebeneffekt. </p><br><p>  Sehr oft sehen Sie Anwendungen, die Aktionen verwenden, um eine Datenanforderung zu initiieren.  Diese Anwendungen implementieren eine spezielle Schnittstelle zur Beobachtung durch Nebenwirkungen.  Und wie wir gesehen haben, kann diese Schnittstelle sehr unpraktisch und umst√§ndlich werden.  Das Abonnieren, Abbestellen und Verbinden von Observable selbst ist viel einfacher. </p><br><h3><pre>  .  .  . </pre></h3><br><p>  <b>Weniger schmerzhaft</b> : Die Komponente registriert ihr Interesse an den Daten, indem sie diese √ºber Observable abonniert. </p><br><p>  Wir werden Observable erstellen, die die notwendigen HTTP-Anfragen enthalten.  Wir werden sehen, wie viel einfacher es ist, mehrere Abonnements und Abfrageketten, die voneinander abh√§ngig sind, mit reinem RxJS zu verwalten, anstatt dies durch Effekte zu tun. </p><br><p>  Erstellen Sie diese im Service beobachtbaren: </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), finalize(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'CANCEL_GET_USERS'</span></span> })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), );</code> </pre><br><p>  Das Abonnement f√ºr <code>users$</code> wird sowohl an <code>requireUsers$</code> als auch an <code>this.store.pipe(select(selectUsers))</code> , die Daten werden jedoch nur von <code>this.store.pipe(select(selectUsers))</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>muteFirst</code></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>muteFirst</code></a> Implementierung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>muteFirst</code></a> und festes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>muteFirst</code></a> mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ihrem Test</a> .) </p><br><p>  In Komponente: </p><br><pre> <code class="javascript hljs">ngOnInit() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.userService.users$; }</code> </pre><br><p>  Da diese Datenabh√§ngigkeit jetzt einfach zu beobachten ist, k√∂nnen wir die Vorlage mithilfe der <code>async</code> Pipe abonnieren und abbestellen, und wir m√ºssen keine Aktionen mehr senden.  Wenn die Anwendung die Route der letzten f√ºr Daten signierten Komponente verl√§sst, wird die HTTP-Anforderung abgebrochen oder der Web-Socket geschlossen. </p><br><p>  Die Datenabh√§ngigkeitskette kann folgenderma√üen verarbeitet werden: </p><br><pre> <code class="javascript hljs">requireUsers$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe( select(selectNeedUser), filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">needUsers</span></span></span><span class="hljs-function"> =&gt;</span></span> needUsers), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS'</span></span>, users })), share(), ); users$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsers$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsers)), ); requireUsersExtraData$ = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.users$.pipe( withLatestFrom(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectNeedUsersExtraData))), filter(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[users, needData]</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>(users.length) &amp;&amp; needData), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'GET_USERS_EXTRA_DATA'</span></span> })), switchMap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getUsers()), tap(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">users</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'RECEIVE_USERS_EXTRA_DATA'</span></span>, users, }), ), share(), ); public usersExtraData$ = muteFirst( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.requireUsersExtraData$.pipe(startWith(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.store.pipe(select(selectUsersExtraData)), );</code> </pre><br><p>  Hier ist ein paralleler Vergleich der obigen Methode mit dieser Methode: </p><br><img src="https://habrastorage.org/webt/xd/cb/ho/xdcbhozsjus5vu64eqp9x8nsnuy.png" alt="paralleler Vergleich"><br><br><p>  Die Verwendung von rein beobachtbar erfordert weniger Codezeilen und wird automatisch von Datenabh√§ngigkeiten in der gesamten Kette abgemeldet.  (Ich habe die urspr√ºnglich enthaltenen <code>finalize</code> Anweisungen √ºbersprungen, um den Vergleich verst√§ndlicher zu machen, aber auch ohne sie werden Abfragen entsprechend abgebrochen.) </p><br><img src="https://habrastorage.org/webt/mj/2m/pc/mj2mpclzeric84dwrap4c5fpkqm.jpeg" alt="Effekte wie Kirsche in einem Cocktail"><br><br><h2>  Fazit </h2><br><p>  Ngrx / Effekte ist ein gro√üartiges Werkzeug!  Ber√ºcksichtigen Sie jedoch diese Fragen, bevor Sie sie verwenden: </p><br><ul><li>  Ist das wirklich ein Nebeneffekt? </li><li>  Ist Ngrx / Effects der beste Weg, dies zu tun? </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448858/">https://habr.com/ru/post/de448858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448840/index.html">Digitale Veranstaltungen in Moskau vom 22. bis 28. April</a></li>
<li><a href="../de448842/index.html">Honeywell HAQ Luftqualit√§tsmonitor</a></li>
<li><a href="../de448846/index.html">Was bei der Implementierung von Agile in einem gro√üen Unternehmen nicht zu vergessen ist</a></li>
<li><a href="../de448854/index.html">Crew Dragon explodierte</a></li>
<li><a href="../de448856/index.html">Torfon - eine mobile Anwendung f√ºr anonyme Telefonie</a></li>
<li><a href="../de448860/index.html">Versionshinweise zu Android Studio 3.4 (April 2019)</a></li>
<li><a href="../de448866/index.html">Einzelheiten zum √úbergang von gepaarten (relativen) Wechselkursen zu absoluten. Fehlerbehandlung</a></li>
<li><a href="../de448868/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 295 (vom 15. bis 21. April)</a></li>
<li><a href="../de448870/index.html">Optlib Implementierung eines genetischen Optimierungsalgorithmus in Rust</a></li>
<li><a href="../de448872/index.html">Intercom-Buch√ºbersetzung zum Produktmanagement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>