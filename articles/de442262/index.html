<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëü üò∞ üåΩ Geheimnis der Firmware üíÖüèæ ‚åõÔ∏è üç¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Autoren: Ph.D. Chernov A.V. ( monsieur_cher ) und Ph.D. Troshina K.N. 

 Wie k√∂nnen Sie unter Verwendung der allgemeinsten Annahmen, die auf dem Wisse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Geheimnis der Firmware</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/442262/">  <b>Autoren: Ph.D.</b>  <b>Chernov A.V.</b>  <b>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">monsieur_cher</a> ) und Ph.D.</b>  <b>Troshina K.N.</b> <br><br>  <b>Wie k√∂nnen Sie unter Verwendung der allgemeinsten Annahmen, die auf dem Wissen √ºber moderne Prozessorarchitekturen basieren, die Programmstruktur aus einem Bin√§rbild einer unbekannten Architektur wiederherstellen und dann Algorithmen und vieles mehr wiederherstellen?</b> <br><br>  In diesem Artikel werden wir √ºber eine interessante Aufgabe sprechen, die uns vor einigen Jahren gestellt wurde.  Der Kunde bat darum, sich mit der bin√§ren Firmware des Ger√§ts zu befassen, das einen bestimmten physischen Prozess verwaltet.  Er brauchte einen Steueralgorithmus in Form eines kompilierten C-Programms sowie Formeln mit einer Erkl√§rung, wie sie funktionieren und warum.  Nach Angaben des Kunden war dies erforderlich, um die Kompatibilit√§t mit den "alten" Ger√§ten im neuen System sicherzustellen.  Die Art und Weise, wie wir letztendlich mit Physik umgegangen sind, wird im Rahmen dieser Artikelserie weggelassen, aber wir werden den Prozess der Wiederherstellung des Algorithmus im Detail betrachten. <br><br>  Die fast allgegenw√§rtige Verwendung programmierbarer Mikrocontroller in Massenger√§ten (IOT oder SmartHome Internet of Things) erfordert die Ber√ºcksichtigung der bin√§ren Analyse von eingebettetem Code oder mit anderen Worten der bin√§ren Analyse von Ger√§tefirmware. <br><br>  Eine bin√§re Analyse der Ger√§tefirmware kann folgende Ziele haben: <br><br><ul><li>  Analyse des Codes auf Schwachstellen, die den unbefugten Zugriff auf das Ger√§t oder die von diesem Ger√§t √ºbertragenen oder verarbeiteten Daten erm√∂glichen. </li><li>  Codeanalyse f√ºr undokumentierte Funktionen, die beispielsweise zu Informationslecks f√ºhrt. </li><li>  Codeanalyse zur Wiederherstellung von Protokollen und Schnittstellen f√ºr die Interaktion mit Ger√§ten, um die Kompatibilit√§t dieses Ger√§ts mit anderen Ger√§ten sicherzustellen. </li></ul><br>  Die oben gestellte Aufgabe zur Analyse des Bin√§rcodes kann als Sonderfall der Aufgabe zur Analyse des Bin√§rcodes betrachtet werden, um die Ger√§tekompatibilit√§t sicherzustellen. <br><a name="habracut"></a><br><h4>  Analyse des bin√§ren Dateiformats </h4><br>  Wenn in der Welt der ‚Äûechten‚Äú Betriebssysteme ausf√ºhrbare Dateiformate standardisiert sind, kann in der Welt der eingebetteten Programme jeder Anbieter seine propriet√§re L√∂sung verwenden.  Daher muss die Analyse der bin√§ren Firmware-Datei mit der Analyse des bin√§ren Dateiformats beginnen. <br><br>  Zu Beginn der Arbeit war die Situation f√ºr uns wie folgt: Wir haben eine bestimmte Datei mit der Firmware ohne Begleitdokumentation erhalten.  Es gab keine Informationen √ºber das Format der Firmware-Datei oder √ºber die Architektur des Mikrocontrollers. <br><br>  Die Firmware-Datei stellte sich als Textdatei heraus.  Es enthielt Zeilen der folgenden Form: <br><br><pre><code class="tex hljs">:04013000260F970CF8 :10020000004D000B043F000B34AD010C002FFE4D30 :02023000FD0BC1 :1004000018001A0000001E0008005E000200190052</code> </pre> <br>  Nachdem wir uns diese Zeilen genau angesehen hatten, stellten wir fest, dass dies ein vollst√§ndig standardm√§√üiges Intel HEX-Format f√ºr Mikrocontroller ist.  Die Datei besteht aus Datens√§tzen, von denen jeder Typ, Speicherort, Daten und Pr√ºfsumme angibt.  Die Verwendung des Intel Hex-Formats bedeutet f√ºr sich genommen, dass die Datei h√∂chstwahrscheinlich nicht verschl√ºsselt ist und ein Image eines Programms ist, das sich im Speicher befindet. <br><br>  Obwohl das Intel Hex-Format eine Adressierung von bis zu 32-Bit-Speicher unterst√ºtzt, enthielt unsere Datei nur 16-Bit-Speicheradressen.  Daher ist es einfach, eine Bin√§rdatei eines Speicherbilds aus einer Textdatei zu erstellen, in der Datens√§tze aus der urspr√ºnglichen Testdatei bereits an den angegebenen Adressen abgelegt werden.  Es ist bequemer, eine solche Bin√§rdatei mit den Dienstprogrammen zur Analyse von Bin√§rdateien zu √ºberpr√ºfen, und es ist einfacher, eigene Dienstprogramme daf√ºr zu schreiben als f√ºr Intel HEX.  Die bin√§re Bildspeicherdatei best√§tigte, dass die Datei nicht verschl√ºsselt war, da verschiedene aussagekr√§ftige Zeilen an verschiedenen Stellen im Code verstreut gefunden wurden. <br>  Dies beantwortete jedoch nicht die Frage, f√ºr welche Architektur diese Datei ist. <br><br><img src="https://habrastorage.org/webt/25/6a/cq/256acqp6bgydpoj5ju-vwvc97gq.jpeg"><br><br>  Wir haben eine Datei mit dem Speicherabbild eines 16-Bit- oder 8-Bit-Mikrocontrollers.  Und was f√ºr ein Mikrocontroller ist, ist nicht klar.  Wir haben IDA Pro genommen und versucht, die Datei mit allen m√∂glichen Varianten der unterst√ºtzten Prozessoren zu zerlegen.  Und nichts.  Keiner der unterst√ºtzten IDA Pro-Prozessoren wurde angezeigt: Die Auflistung wurde entweder nicht generiert oder enthielt offensichtlichen Unsinn.  Es war vielleicht ein Programm f√ºr einen der unterst√ºtzten IDA Pro-Prozessoren, aber wir haben etwas falsch gemacht.  Zum Beispiel brauchten Sie nur eine zus√§tzliche Verarbeitung der Bilddatei.  In jedem Fall war es hier m√∂glich, die Arbeit auszusetzen und zus√§tzliche Informationen √ºber die Bin√§rdatei anzufordern. <br><br><h4>  Alle Prozessoren sind ungef√§hr gleich. </h4><br>  Aber es wurde f√ºr uns interessant und was wir aus dem Bin√§rprogramm verstehen k√∂nnen, auch wenn der Prozessor, f√ºr den es kompiliert wurde, unbekannt ist.  Die Antwort lautet ‚Äûnichts‚Äú - uninteressant, auch wenn wir ein wenig verstehen k√∂nnen, es ist besser als nichts.  Nat√ºrlich k√∂nnen Textzeichenfolgen Informationen √ºber das Programm liefern, aber wir wollen mehr - etwas aus der Struktur des Programms verstehen. <br>  Verschiedene Prozessorarchitekturen - eine gro√üe Anzahl.  Die Entwicklung des Computing hat selbst die ungew√∂hnlichsten Architekturen wie tern√§re Computer hervorgebracht.  Die derzeit existierenden Mikroprozessoren und Mikrocontroller, zumindest die Massenprozessoren, sind einander jedoch bemerkenswert √§hnlich. <br><br>  Nachfolgend listen wir die Grundprinzipien auf, die modernen Mikroprozessoren gemeinsam sind. <br><br>  Konsistente Ausf√ºhrung von Anweisungen.  Der Prozessor f√ºhrt Anweisungen nacheinander im Speicher aus.  Es gibt spezielle Anweisungen f√ºr das bedingte und bedingungslose Springen und Aufrufen und Zur√ºckkehren von der Unterroutine, mit denen Sie die sequentielle Auswahl von Anweisungen aus dem Speicher unterbrechen und mit der Ausf√ºhrung einer anderen Anweisung fortfahren k√∂nnen.  Der Rest der Anweisungen setzt jedoch eine sequentielle Ausf√ºhrung voraus und enth√§lt daher nicht die Adresse der n√§chsten Anweisung. <br><br>  <i>Bin√§re Codierung.</i>  Zus√§tzlich zu der Tatsache, dass der Prozessor Daten in bin√§rer Form verarbeitet, werden die Prozessorbefehle, aus denen das ausf√ºhrbare Programm besteht, im Bin√§rformat codiert, dh die Felder, in denen die Befehlsparameter gespeichert sind, beispielsweise Offsets oder Registernummern, belegen eine ganzzahlige Anzahl von Bits.  Man kann sich theoretisch vorstellen, dass Daten und Programme trotz der bin√§ren Codierung im Prozessor in einem anderen Zahlensystem verarbeitet werden, aber wir sind uns einer solchen Exotik nicht bewusst. <br><br>  Die folgenden Prinzipien sind im Allgemeinen keine grundlegenden Architekturprinzipien, werden jedoch praktisch universell implementiert, insbesondere f√ºr Maschinencode, der nicht manuell in Assemblersprache geschrieben, sondern von einem Hochsprachen-Compiler generiert wird. <br><br>  <i>Prozedurale Programmierung.</i>  Das Programm ist in Struktureinheiten unterteilt, die unterschiedlich aufgerufen werden k√∂nnen: Prozeduren, Funktionen, Unterprogramme usw. Unterprogramme k√∂nnen andere Unterprogramme aufrufen, Parameter an diese √ºbergeben und das Ergebnis der Ausf√ºhrung zur√ºckerhalten.  Es ist wichtig, dass das Unterprogramm einen Einstiegspunkt hat, dh alle Unterprogramme, die den angegebenen aufrufen, gehen an dieselbe Einstiegspunktadresse. <br><br>  Normalerweise haben Routinen einen Austrittspunkt, der die Kontrolle an den Aufrufpunkt zur√ºckgibt. Dies ist jedoch weniger wichtig, als dass f√ºr jede Routine ein Einstiegspunkt erforderlich ist.  Ein solcher Code wird normalerweise durch Kompilieren eines Programms erhalten.  Der Verbindungszeitoptimierer kann diese Struktur teilweise zerst√∂ren, um die Gr√∂√üe des Programms zu verringern, und die Gr√∂√üe des Programms ist f√ºr eingebettete Systeme von entscheidender Bedeutung.  Dar√ºber hinaus kann diese Struktur durch den Code-Verschleierer zerst√∂rt werden. <br><br>  Das Verschachteln von Unterprogrammaufrufen kann mithilfe des Stapels organisiert werden, der weiterhin zum √úbergeben von Argumenten an das Unterprogramm und zum Speichern lokaler Variablen verwendet werden kann. Auf dem aktuellen Stand der Architekturentwicklung sind diese Informationen jedoch verfr√ºht. <br><br>  Wie k√∂nnen diese Prinzipien auf die anf√§ngliche Analyse von Bin√§rcode angewendet werden? <br><br>  Wir gehen grunds√§tzlich davon aus, dass es im Prozessorbefehlssystem einen RET-Befehl (R√ºckkehr von einem Unterprogramm) gibt.  Diese Anweisung hat eine Art feste bin√§re Darstellung, nach der wir suchen werden.  Wenn RET nicht der einzige ist, wie in x86, wo RET ein Argument hat - die Gr√∂√üe des Unterprogrammparameterbereichs, oder wenn RET ein Nebeneffekt einer komplizierteren Operation ist, wie in ARMv7, wo der PC-Wert gleichzeitig mit den Werten anderer Register vom Stapel abgerufen werden kann (ldmfd sp! , {fp, pc}), dann wird unsere heuristische Suche h√∂chstwahrscheinlich keine Ergebnisse liefern. <br><br>  Wir m√ºssen auch sofort vern√ºnftige Annahmen √ºber das Prinzip der Codierung von Anweisungen des untersuchten Prozessors treffen.  Bestehende Prozessoren verwenden verschiedene Prinzipien zum Codieren von Anweisungen: <br><br><ul><li>  Ein Strom von Bytes, aus denen Befehle generiert werden, und verschiedene Befehle werden mit einer unterschiedlichen Anzahl von Bytes codiert.  In dieser Kategorie ist der bekannteste Vertreter die x86-Familie, von den ersten 8080-Prozessoren bis zu den modernsten 64-Bit-Prozessoren.  Ein x86_64-Prozessorbefehl kann in einer Folge von 1 bis 16 Bytes codiert werden.  Die gleiche Familie von Prozessoren mit variablen Befehlsl√§ngen umfasst 8051, das in Mikrocontrollern verwendet wird. </li><li>  Ein Stream von 16-Bit-Werten.  Dar√ºber hinaus hat jeder Befehl eine feste Gr√∂√üe - 16 Bit. </li><li>  Ein Stream mit 16-Bit-Werten, w√§hrend die Anweisungen unterschiedlich gro√ü sind.  Einer der Vertreter dieser Familie ist die PDP-11-Architektur, bei der der Befehl selbst die ersten 16 Bits belegt und auf die entweder direkte Werte oder Speicheradressen f√ºr die direkte Adressierung folgen k√∂nnen.  Dies beinhaltet die THUMB-Codierung in der ARM-Architektur. </li><li>  Jeder Befehl ist ein Strom von 32-Bit-Werten und hat eine feste Gr√∂√üe von 32 Bit.  Dies sind die meisten 32- und 64-Bit-RISC-Prozessoren: ARMv7, ARMv8, MIPS. </li></ul><br>  Wenn Sie zwischen einem Byte-Stream variabler L√§nge und einem 16-Bit-Wortstrom w√§hlen, k√∂nnen Sie das Speicherbild ‚Äûmit dem Auge‚Äú anzeigen.  Unabh√§ngig davon, wie Prozessorbefehle codiert sind, werden sie in einem Programm mit ausreichender L√§nge zwangsl√§ufig wiederholt.  Zum Beispiel auf x86-Anweisung <br><br><pre> <code class="tex hljs">add <span class="hljs-comment"><span class="hljs-comment">%ebx,%eax</span></span></code> </pre> <br>  Das addiert die Werte der eax- und ebx-Register und setzt das Ergebnis in eax. Es wird in zwei Bytes codiert: <br><br><pre> <code class="tex hljs">01 d8.</code> </pre> <br>  Auf ARMv7-Anweisung <br><br><pre> <code class="tex hljs">add r0, r0, r1</code> </pre> <br>  Das Addieren der Werte der Register r0 und r1 und das Setzen des Ergebnisses in r0 wird durch den 32-Bit-Wert e0800001 codiert. <br><br>  In einem ausreichend gro√üen Programm werden solche Anweisungen mehr als einmal wiederholt.  Wenn eine f√ºr uns interessante Folge von Bytes (z. B. 01 d8) an einer beliebigen nicht ausgerichteten Adresse auftritt, k√∂nnen wir davon ausgehen, dass die Prozessorbefehle von einem Strom von Bytes variabler Gr√∂√üe codiert werden.  Wenn der Wert beispielsweise e0800001 nur bei Adressen gefunden wird, die ein Vielfaches von 4 sind, k√∂nnen wir eine feste Gr√∂√üe von Prozessoranweisungen annehmen.  Nat√ºrlich gibt es hier einen Fehler, dass wir Datenbytes f√ºr eine Anweisung genommen haben, oder es ist zuf√§llig passiert, dass sich herausstellte, dass eine Anweisung immer ausgerichtet war.  Die Auswirkungen eines solchen ‚ÄûRauschens‚Äú auf ein Programm mit ausreichender Gr√∂√üe sind jedoch gering. <br><br>  Bei Betrachtung der analysierten Firmware aus diesem Blickwinkel wurde deutlich, dass die Anweisungen f√ºr den betreffenden Prozessor h√∂chstwahrscheinlich mit 16-Bit-Werten codiert sind. <br><br>  Ausgehend von der Annahme, dass die Codierung des RET-Befehls ein fester 16-Bit-Wert ist, versuchen wir, ihn zu finden.  Wir finden im Programmbild die h√§ufigsten 16-Bit-Werte.  In unserem Fall ist Folgendes passiert: <br><br><pre> <code class="tex hljs"> (hex)   0b01 854 5.1<span class="hljs-comment"><span class="hljs-comment">% 0800 473 2.8% 8c0d 432 2.6% 2b00 401 2.4% 4e1c 365 2.2% 0801 277 1.6%</span></span></code> </pre><br>  Wir werden nach dem RET-Befehl unter diesen 16-Bit-Werten suchen, die im Code am h√§ufigsten vorkommen.  Sofort werden wir nach dem CALL-Befehl suchen - gepaart mit dem RET-Befehl.  Der CALL-Befehl hat mindestens einen Parameter - die Sprungadresse, daher sind feste Werte unverzichtbar. <br><br>  Wir gehen davon aus, dass in vielen F√§llen unmittelbar nach dem Ende eines Unterprogramms, dh nach dem RET-Befehl, ein anderes Unterprogramm beginnt und dieses Unterprogramm vom CALL-Befehl von einem anderen Punkt im Programm aus aufgerufen wird.  Eine gro√üe Anzahl von Spr√ºngen zur Adresse unmittelbar nach RET ist eines der Kennzeichen des CALL-Befehls.  Nat√ºrlich ist diese Regel nicht universell, da auf einigen Plattformen, insbesondere ARMv7, unmittelbar nach Abschluss der Unterroutine normalerweise ein konstanter Pool vorhanden ist.  In diesem Fall k√∂nnen wir einen vern√ºnftigen Adressbereich unmittelbar nach RET als √úbergangspunkte des RET-Befehls betrachten. <br><br>  Im Fall des CALL-Befehls kann es eine ganze Reihe von Optionen geben, um ihn in das Unterprogramm zu codieren.  Erstens kann der Prozessor eine andere Bytereihenfolge im Wort verwenden: Little-Endian, wie bei den meisten modernen Prozessoren, wenn eine Multibyte-Ganzzahl in den Speicher geschrieben wird, beginnend mit dem niedrigen Byte, und Big-Endian, wenn eine Multibyte-Ganzzahl in den Speicher geschrieben wird, beginnend vom hohen Byte.  Fast alle modernen Prozessoren arbeiten im Little-Endian-Modus, aber Sie sollten andere m√∂gliche Bytereihenfolgen nicht in einem Wort verwerfen. <br>  Zweitens kann der CALL-Befehl entweder die absolute Adressierung des Sprungpunkts oder die Adressierung relativ zur aktuellen Adresse verwenden.  Bei der absoluten Adressierung enth√§lt der codierte Befehl die Adresse, an die Sie in einigen Bits des codierten Befehls gehen m√∂chten.  Um sicherzustellen, dass die Unterroutine von einem beliebigen Punkt im 16-Bit-Adressraum zu einem anderen Punkt an der absoluten Adresse des 16-Bit-Wortes aufgerufen wird, reicht der codierte Befehl nicht aus, da zus√§tzlich zur √úbergangsadresse die Bits des Operationscodes an einer anderen Stelle gespeichert werden m√ºssen.  Daher ist es sinnvoll, zwei 16-Bit-W√∂rter hintereinander zu betrachten und verschiedene Optionen zum Aufteilen der √úbergangsadresse zwischen diesen W√∂rtern auszuprobieren. <br><br>  Eine Alternative zur absoluten Codierung einer Routineadresse ist die relative Codierung.  In der codierten Anweisung zeichnen wir die Differenz zwischen der Adresse des Unterprogramms und dem aktuellen Punkt auf.  Relative Codierung ist normalerweise der absoluten vorzuziehen, da zum einen ein Programm mit relativen √úberg√§ngen positionsunabh√§ngig ist, dh von jeder Adresse aus im Speicher gespeichert werden kann, ohne dass sich der Bin√§rcode √§ndert.  Zweitens k√∂nnen zum Codieren des Offsets weniger Bits reserviert werden als die Dimension des Adressraums, basierend auf der Tatsache, dass die aufgerufene Routine in vielen F√§llen nicht so weit von der aufrufenden entfernt ist.  Wenn der Offset f√ºr den Anruf jedoch au√üerhalb des Bereichs der darstellbaren Werte liegt, m√ºssen Sie spezielle Anweisungen einf√ºgen - "Spr√ºnge". <br><br>  Die relative Codierung einer Unterprogrammadresse kann mit einigen Variationen durchgef√ºhrt werden: Erstens kann die Adresse des aktuellen Punkts des Programms entweder als Adresse des aktuellen Befehls oder als Adresse des n√§chsten Befehls wie in x86-Prozessoren oder als Adresse eines anderen Befehls in der N√§he des aktuellen Punkts verwendet werden.  In ARM-Prozessoren ist der Referenzpunkt beispielsweise die Adresse des aktuellen Befehls +8 (dh nicht die Adresse des Befehls nach dem CALL, sondern die Adresse des Befehls nach dem n√§chsten).  Da in unserem Fall das Programm als Strom von 16-Bit-W√∂rtern geschrieben ist, ist es au√üerdem logisch zu erwarten, dass der Offset in W√∂rtern ausgedr√ºckt wird.  Das hei√üt, um die Adresse der aufgerufenen Routine zu erhalten, muss der Offset mit 2 multipliziert werden. <br><br>  Unter Ber√ºcksichtigung all dieser Punkte erhalten wir den folgenden Aufz√§hlungsraum f√ºr die Suche nach einem CALL / RET-Paar im Bin√§rcode. <br><br>  Zun√§chst nehmen wir 16-Bit-W√∂rter aus der Liste der h√§ufigsten Werte im Code als Kandidaten f√ºr den RET-Befehl.  Als n√§chstes durchsuchen wir die CALL-Anweisung: <br><br><ul><li>  Big-Endian- und Little-Endian-Wortbyte-Reihenfolge </li><li>  Absolute und relative Codierung der Routineadresse in der Anweisung. </li></ul><br>  F√ºr die absolute Codierung betrachten wir zwei 16-Bit-Werte in einer Reihe, dh wir sortieren verschiedene Optionen zum Platzieren eines Bitfelds, in dem eine absolute Adresse in einem 32-Bit-Wort gespeichert ist, und f√ºr die relative Codierung betrachten wir sowohl 16-Bit-Werte als auch zwei 16-Bit-W√∂rter in einer Reihe .  Als n√§chstes sortieren wir die verschiedenen Optionen zum Platzieren eines Bitfelds, in dem Offsets gespeichert sind.  Wir pr√ºfen, ob der Offset in Bytes oder in 16-Bit-W√∂rtern ausgedr√ºckt wird, dh ob der Offset mit 2 multipliziert werden muss. Wir pr√ºfen verschiedene Optionen f√ºr den Referenzpunkt: die Adresse des aktuellen Befehls, die Adresse des n√§chsten Befehls. <br><br>  F√ºr jede der oben beschriebenen Optionen im Suchraum berechnen wir Statistiken: <br><br><ul><li>  Wie viele angenommene Adressen am Anfang der Unterprogramme sind offensichtlich nicht korrekt, dh sie befinden sich dort, wo nichts vorhanden ist oder wo sich die Daten (explizite Zeichenfolgen oder explizite Wertetabellen) befinden.  Selbst f√ºr den Wert, der der korrekten Codierung des CALL-Befehls entspricht, ist es durchaus m√∂glich, dass eine kleine Anzahl falscher Adressen am Anfang des Unterprogramms m√∂glich ist, wenn der Wert, der dem CALL-Befehl entspricht, versehentlich in den Daten vorkommt. </li><li>  Wie viele mutma√üliche Routine-Startadressen befinden sich unmittelbar nach dem mutma√ülichen RET-Befehl. </li><li>  Wie viele hypothetische Startadressen von Routinen werden mehr als einmal verwendet. </li></ul><br>  Wenn unsere Annahmen √ºber ein Paar von CALL / RET-Anweisungen korrekt sind, sollte sie sich im beschriebenen Aufz√§hlungsraum befinden.  Es kann aber auch zu Fehlalarmen kommen.  Nun, wir starten die Suche. <br><br>  Und wir finden nur eine m√∂gliche Option! <br><br><pre> <code class="tex hljs">Trying 8c0d as RET After-ret-addr-set-size: 430 Matching call opcodes for 1, ff00ff00, 1: 000b003d: total: 1275, hits: 843 (66<span class="hljs-comment"><span class="hljs-comment">%), misses: 432 (33%), coverage: 76%</span></span></code> </pre> <br>  Das 16-Bit-Wort 8c0d ist also als Kandidat f√ºr den RET-Befehl geeignet.  Insgesamt enth√§lt die Firmware unmittelbar nach dieser Anweisung 430 Positionen von Programmadressen.  Wir haben 32-Bit-Werte (zwei 16-Bit-W√∂rter hintereinander) mit einem Adressmaskenwert von ff 00 ff 00 betrachtet und eine Anweisung mit dem Code 00 0b 00 3d gefunden.  Es gibt 1275 solcher Anweisungen, von denen 843 (d. H. 66%) die Kontrolle auf den Punkt unmittelbar nach dem Kandidaten f√ºr RET √ºbertragen.  Somit wurden zwei Anweisungen identifiziert: <br><br><ul><li>  RET: 8c0d (16-Bit-Little-Endian) </li><li>  CALL HHLL: 0bHH 3dLL (2 16-Bit-Little-Endian) </li></ul><br>  Der CALL-Befehl verwendet eine absolute Adressierung, und beim Schreiben der Sprungadresse wird zuerst das High-Byte und dann das Low-Byte geschrieben.  Es ist m√∂glich, dass dies in der Realit√§t zwei Prozessorbefehle sind, von denen jeder die H√§lfte der √úbergangsadresse l√§dt, aber aus Sicht der Programmanalyse ist dies nicht wichtig.  Wenn wir die Anweisungen CALL und RET kennen, k√∂nnen wir Bereiche mit Code- und Programmdaten genauer markieren, die f√ºr die weitere Analyse wichtig sind. <br><br>  Fortsetzung folgt‚Ä¶ <br><br>  Weiter werden wir erz√§hlen, wie bedingte und bedingungslose √úberg√§nge und einige arithmetische und logische Operationen wiederhergestellt wurden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442262/">https://habr.com/ru/post/de442262/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442250/index.html">Reagieren und Vue: St√§rken</a></li>
<li><a href="../de442252/index.html">Python-Code-Lebenszyklus - CPython-Laufzeitmodell</a></li>
<li><a href="../de442256/index.html">Digitale Verteidigung vor der Plastikwelt der heimischen Internetregulierungsbeh√∂rden</a></li>
<li><a href="../de442258/index.html">Web Scraping f√ºr Webentwickler: eine kurze Zusammenfassung</a></li>
<li><a href="../de442260/index.html">10 Git-Befehle, die ein Entwickler kennen sollte</a></li>
<li><a href="../de442264/index.html">Beseitigung von M√∂glichkeiten zur Entf√ºhrung von Verkehr</a></li>
<li><a href="../de442266/index.html">Delta Chat - dezentraler Messenger √ºber E-Mail</a></li>
<li><a href="../de442268/index.html">AsyncIO Micropython: Synchronisationsmethoden in der asynchronen Programmierung</a></li>
<li><a href="../de442270/index.html">5 Fehler, die beim Erstellen von 3D-Modellen f√ºr den 3D-Druck vermieden werden sollten</a></li>
<li><a href="../de442272/index.html">Go + = Paketversionierung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>