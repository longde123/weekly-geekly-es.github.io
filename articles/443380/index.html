<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê® üôá üìí UDB Que es esto Parte 6. M√≥dulo de estado y control üïö ‚ùï üë©‚Äçüë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En art√≠culos anteriores, traducciones de la documentaci√≥n de Cypress, el aut√≥mata operativo Datapath fue considerado de manera muy sustancial. Poco a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>UDB Que es esto Parte 6. M√≥dulo de estado y control</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443380/"><img src="https://habrastorage.org/webt/mf/zu/nx/mfzunxkuzhcahgj4dodvrfn2i18.jpeg"><br><br>  En art√≠culos anteriores, traducciones de la documentaci√≥n de Cypress, el aut√≥mata operativo Datapath fue considerado de manera muy sustancial.  Poco a poco pasamos al estudio de otros m√≥dulos UDB, en particular, el m√≥dulo de gesti√≥n y estado. <a name="habracut"></a><br><br>  El contenido general del ciclo ‚ÄúUDB.  ¬øQu√© es esto? <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1. Introducci√≥n.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Pld.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Ruta de datos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 3. Datapath FIFO.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 4. Datapath ALU.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 5. Ruta de datos.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Peque√±as cosas √∫tiles.</a> <br>  Parte 6. M√≥dulo de gesti√≥n y estado.  (Art√≠culo actual) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 7. M√≥dulo de control de temporizaci√≥n y reinicio</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 8. Abordar UDB</a> <br><br><h2>  21.3.3.  M√≥dulo de gesti√≥n y estado </h2><br>  En la Figura 21-28 se muestra una vista de alto nivel del m√≥dulo de control y el estado.  Los bits de estado del registro de control se transfieren a recursos de rastreo, lo que le da al programa la capacidad de controlar el comportamiento de UDB.  El registro de estado recibe datos de las l√≠neas de rastreo, por lo que el programa puede monitorear las operaciones realizadas por UDB. <br><br><img src="https://habrastorage.org/webt/4n/0g/wf/4n0gwf_b13miix_dof5ojhxwltk.png"><br>  <i>Figura 21-28.</i>  <i>Registros de gesti√≥n y estado.</i> <br><br>  La estructura del m√≥dulo de control y el estado se muestran con m√°s detalle en la Figura 21-29.  El objetivo principal de esta unidad es coordinar la interacci√≥n del programa central del procesador con el trabajo de los elementos UDB internos.  Sin embargo, debido a la fuerte conexi√≥n con la matriz de rastreo, este bloque se puede configurar para realizar otras funciones. <br><br><img src="https://habrastorage.org/webt/rh/ak/9e/rhak9e-mn02qvbn0-di2e_81r_i.png"><br>  <i>Figura 21-29.</i>  <i>M√≥dulo de control y estado.</i> <br><br>  Modos de funcionamiento: <br><br><ul><li>  <b>Entrada de estado</b>  El estado de las l√≠neas enrolladas desde el exterior se puede ingresar y capturar como estado, despu√©s de lo cual se lee la CPU o el DMA. </li><li>  <b>Salida de control</b>  La CPU o DMA puede escribir datos en el registro de control.  Estos datos determinar√°n el estado de las l√≠neas que van a los recursos de rastreo. </li><li>  <b>Entrada paralela</b> - a la entrada paralela Datapath. </li><li>  <b>Salida paralela</b> : desde la salida paralela de Datapath. </li><li>  <b>Modo contador</b>  En este modo, el registro de control funciona como un contador decreciente de 7 bits con un per√≠odo programable y reinicio autom√°tico.  Las entradas del canal de rastreo se pueden configurar para controlar tanto el encendido como el reinicio del contador.  Cuando se activa este modo, la funcionalidad del registro de control no est√° disponible. </li><li>  <b>Modo sincr√≥nico / Modo de sincronizaci√≥n</b> .  En este modo, el registro de estado act√∫a como un sincronizador dual de 4 bits.  Cuando se activa este modo, la funcionalidad del registro de estado no est√° disponible. </li></ul><br><h2>  21.3.3.1 Estado y modo de control </h2><br>  Cuando funciona en modo de control y estado, este m√≥dulo act√∫a como un registro de estado, registro de anulaci√≥n de m√°scara y registro de control en la configuraci√≥n que se muestra en la Figura 21-30. <br><br><img src="https://habrastorage.org/webt/t3/2j/hk/t32jhkcoc-imxe6vuwpuv91b_rs.png"><br>  <i>Figura 21-30.</i>  <i>Gesti√≥n laboral y estado.</i> <br><br><h4>  Operaci√≥n de registro de estado </h4><br>  Cada UDB tiene un registro de estado de 8 bits.  La entrada a este registro proviene de cualquier se√±al de una estructura de rastreo digital.  El registro de estado es destructible: pierde su estado durante el sue√±o y despu√©s de despertarse tiene un valor de 0x00.  Cada bit puede programarse independientemente para operar en uno de los dos modos. <br><br>  Cuadro 21-19.  Registro de estado. <br><br><div class="scrollable-table"><table><tbody><tr><th>  <b>STAT MD</b> </th><th>  <b>Descripci√≥n</b> </th></tr><tr><td>  0 0 </td><td>  Lectura normal  Devuelve el valor actual de la se√±al de entrada. </td></tr><tr><td>  1 </td><td>  Pegado, despejado al leer.  Pestillos de alto nivel de entrada <br>  en una se√±al de reloj.  Borrado despu√©s de leer el registro. </td></tr></tbody></table></div><br>  Una caracter√≠stica importante de la operaci√≥n de borrado del registro de estado es que solo se borran los bits armados.  Esto permite que los bits restantes contin√∫en capturando el estado para mantener la continuidad del proceso. <br><br><h4>  Estado de lectura normal </h4><br>  Por defecto, la CPU lee de forma transparente el estado del circuito correspondiente.  Este modo se puede usar para leer datos retenidos dentro de UDB. <br><br><h4>  Estado de pegado con claro despu√©s de leer </h4><br>  En este modo, las entradas del registro de estado se muestrean en cada control y ciclo de reloj de estado.  Si la se√±al en un reloj dado es alta, se captura en el bit de estado y permanece alta, independientemente de los estados de entrada posteriores.  Cuando la CPU o DMA lee el registro de estado, el bit se borra.  Borrar el registro de estado es independiente del modo y ocurre incluso cuando el reloj UDB est√° desactivado;  se basa en la sincronizaci√≥n del bus y ocurre como parte de una operaci√≥n de lectura. <br><br><h4>  Estado de bloqueo mientras lee </h4><br>  La figura 21-31 muestra la estructura de la l√≥gica de lectura de estado.  El registro de estado fijo es seguido por un pestillo que bloquea los datos del registro de estado y lo mantiene estable durante el ciclo de lectura, independientemente del n√∫mero de tics de espera en la operaci√≥n de lectura actual. <br><br><img src="https://habrastorage.org/webt/vc/0w/3c/vc0w3cd0tr9yc51xphqneftldra.png"><br>  <i>Figura 21-31.</i>  <i>La l√≥gica del estado de lectura.</i> <br><br><h4>  Generaci√≥n de interrupci√≥n </h4><br>  En la mayor√≠a de las funciones, la generaci√≥n de interrupciones est√° vinculada a los par√°metros de bit de estado.  Como se muestra en la Figura 21-31, esta caracter√≠stica est√° integrada en la l√≥gica del registro de estado en forma de una operaci√≥n de enmascaramiento y aplica la operaci√≥n <b>OR</b> al estado.  Solo los 7 bits inferiores de la entrada de estado pueden usarse con los generadores de interrupciones incorporados.  El bit m√°s significativo (el bit m√°s significativo, MSB) generalmente se usa como salida de interrupci√≥n y puede enviarse al controlador de interrupci√≥n utilizando canales de rastreo digital.  En esta configuraci√≥n, el estado del bit de solicitud de interrupci√≥n se lee desde el bit de registro de estado alto. <br><br><h2>  21.3.3.2 Operaci√≥n de registro de control </h2><br>  Cada UDB tiene un registro de control de 8 bits disponible.  Funciona como un registro est√°ndar de lectura / escritura en el bus del sistema, donde la salida de estos bits de registro es controlada por las l√≠neas de la estructura de rastreo digital. <br><br>  El registro de control es destructible: pierde su estado durante el sue√±o y despu√©s de despertarse tiene un valor de 0x00. <br><br><h4>  Modos de registro de gesti√≥n </h4><br>  Cada bit se puede configurar en uno de los tres modos.  La configuraci√≥n se especifica combinando los bits de dos registros de 8 bits CTL_MD1 [7: 0] y CTL_MD0 [7: 0].  Por ejemplo, {CTL_MD1 [0], CTL_MD0 [0]} controla el modo de bit cero del registro de control (consulte la tabla 21-20). <br><br>  Tabla 21-20.  Modo de registro de control de bit cero <br><div class="scrollable-table"><table><tbody><tr><th>  <b>CTL MD</b> </th><th>  <b>Descripci√≥n</b> </th></tr><tr><td>  00 </td><td>  Modo directo </td></tr><tr><td>  01 </td><td>  Modo de sincronizaci√≥n </td></tr><tr><td>  10 </td><td>  (reservado) </td></tr><tr><td>  11 </td><td>  Modo de pulso </td></tr></tbody></table></div><br><h4>  Modo de registro de control directo </h4><br>  Por defecto, el modo es directo.  Como se muestra en la Figura 21-32, cuando la CPU o DMA se escribe en el registro de control, la salida del registro de control se env√≠a directamente a la l√≠nea de rastreo en el mismo ciclo. <br><br><img src="https://habrastorage.org/webt/ft/cl/q-/ftclq-bcwhq3r_kozkj3vrwuli0.png"><br>  <i>Figura 21-32.</i>  <i>Modo de registro de control directo.</i> <br><br><h4>  Modo de registro de control s√≠ncrono </h4><br>  En modo s√≠ncrono, como se muestra en la Figura 21-33, la salida del registro de control no est√° sincronizada con el reloj igual al reloj actual del control y estado (Estado y Control, SC).  Esto le permite controlar los diagramas de temporizaci√≥n de la salida a la frecuencia SC seleccionada y no a la frecuencia del reloj del bus. <br><br><img src="https://habrastorage.org/webt/jd/a6/7s/jda67s-pgp1kw-03dnttxc-zdcq.png"><br>  <i>Figura 21-33.</i>  <i>Modo de registro de control s√≠ncrono.</i> <br><br><h4>  Registro de control de modo de pulso </h4><br>  El modo de pulso es similar al modo s√≠ncrono, ya que en √©l el bit de control se vuelve a muestrear a la frecuencia SC;  el pulso comienza en el primer ciclo de reloj SC y sigue el ciclo de escritura del bus.  La salida del bit de control se establece durante un ciclo de reloj SC completo.  Al final de este ciclo de reloj, el bit de control se restablece autom√°ticamente. <br><br>  Con este modo de operaci√≥n, el programa puede escribir 1 en el bit de registro de control para generar un pulso.  Despu√©s de que el bit tenga asignado el valor 1, el programa lo leer√° como 1 hasta el final del pulso, despu√©s de lo cual se leer√° como 0. Despu√©s de eso, el programa puede escribir otro 1 para iniciar un nuevo pulso.  Por lo tanto, no ser√° posible dar un pulso con m√°s frecuencia que en cada segundo paso de la se√±al SC. <br><br><h4>  Restablecer registro de gesti√≥n </h4><br>  El registro de control tiene dos modos de reinicio controlados por el bit de configuraci√≥n EXT RES, como se muestra en la Figura 21-34.  Cuando EXT RES es 0 (predeterminado), en modo s√≠ncrono o de pulso, la entrada de restablecimiento rastreada restablece la salida sincronizada, pero no el bit de control en s√≠.  Cuando EXT RES es 1, la entrada de restablecimiento rastreable restablece tanto el bit de control como la salida sincronizada. <br><br><img src="https://habrastorage.org/webt/lo/ho/dl/lohodlp2-dbsqoqzpwurp8hx2di.png"><br>  <i>Figura 21-34.</i>  <i>Restablecer registro de gesti√≥n.</i> <br><br><h2>  21.3.3.3 Modo de entrada / salida paralela </h2><br>  En este modo, el control y el seguimiento del estado se conecta a las se√±ales de Datapath en paralelo y en paralelo.  Para activar este modo, debe activar los bits de configuraci√≥n de SC OUT para seleccionar la salida paralela de Datapath.  La comunicaci√≥n con entrada paralela siempre est√° disponible, sin embargo, estas conexiones de rastreo se comparten con las entradas de registro de estado, las entradas de control de contador y las salidas de interrupci√≥n. <br><br><img src="https://habrastorage.org/webt/9c/se/c2/9csec2u290m0hm1qaecqxpyybhe.png"><br>  <i>Figura 21-35.</i>  <i>Modo paralelo de E / S.</i> <br><br><h2>  21.3.3.4 Modo contador </h2><br>  Como se muestra en la Figura 21-36, cuando la unidad funciona en modo contador, un contador decreciente de 7 bits est√° disponible para su uso dentro de las operaciones dentro de la UDB y para las necesidades del programa.  Las caracter√≠sticas del medidor incluyen: <br><br><ul><li>  Registro de per√≠odo de 7 bits (lectura / escritura). </li><li>  Registro de cuenta de 7 bits (lectura / escritura).  El acceso solo es posible cuando el contador est√° detenido. </li><li>  Recarga autom√°ticamente el per√≠odo en el registro de la cuenta cuando llega a cero. </li><li>  El bit de control accesible por software en el registro de control auxiliar CNT START, utilizado para iniciar y detener el contador.  (Se superpone a la se√±al de hardware ENABLE y debe instalarse para que funcione la se√±al de hardware ENABLE opcional). </li><li>  Bits seleccionables de los canales de rastreo del control de contador din√°mico opcional para las funciones de inicio y carga: <br>  - EN, se√±al trazada para iniciar o detener el conteo. <br>  - LD, una se√±al de carga rastreable que provoca una recarga de per√≠odo.  Cuando esta se√±al est√° activada, se superpone a la se√±al final pendiente.  Es sensible al nivel, y mientras la se√±al est√° activada, el per√≠odo contin√∫a carg√°ndose. </li><li>  Se puede enviar un contador de 7 bits para rastrear recursos como sc_out [6: 0]. </li><li>  La se√±al de terminaci√≥n puede ingresar recursos de rastreo como sc_out [7]. </li><li>  En el modo "predeterminado", el modo de ajuste se utiliza para la se√±al de conteo.  En modo alternativo, cambia al modo combinado. </li><li>  En el modo predeterminado, la se√±al opcional de hardware EN, si se usa, debe configurarse para habilitar la se√±al de hardware LD.  En modo alternativo, las se√±ales de hardware LD y EN son independientes. </li></ul><br><img src="https://habrastorage.org/webt/no/ov/up/noovupgcemdnnl1v6ak4tyl1rnq.png"><br>  <i>Figura 21-36.</i>  <i>Modo contador</i> <br><blockquote>  <i><b>Nota del traductor:</b></i> <br>  Alrededor de este lugar, me di cuenta de que no entiendo nada del documento.  En ninguna parte se describe este modo "predeterminado" y "alternativo".  Despu√©s de una larga b√∫squeda, logr√© encontrar algunos, pero un ejemplo. <br>  Archivo: C: \ Archivos de programa (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ psoc \ content \ CyComponentLibrary \ CyComponentLibrary.cylib \ bScanComp_v1_10 \ bScanComp_v1_10.v <br>  C√≥digo explicativo: <br><br><img src="https://habrastorage.org/webt/ba/rf/13/barf13t7suartgjw8b0frvtsccs.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mismo texto:</b> <div class="spoiler_text"><pre><code class="plaintext hljs">cy_psoc3_count7 #(.cy_period(Period),.cy_route_ld(0),.cy_route_en(1), .cy_alt_mode(1)) ChannelCounter( /* input */ .clock(clk_int), /* input */ .reset(1'b0), /* input */ .load(1'b0), /* input */ .enable(enable_int), /* output [06:00] */ .count(count), /* output */ .tc(tc_o) );</code> </pre> <br></div></div><br>  La declaraci√≥n misma del componente cy_psoc3_count7 que encontr√© solo para el lenguaje VHDL, parece que para Verilog est√° integrada en las herramientas de desarrollo.  Ahora sabe aproximadamente d√≥nde buscar los bits de ajuste en discusi√≥n. <br><br>  Aqu√≠ consideramos los bits misteriosos, que se llaman SC OUT CTL o SC_OUT_CTL, pero sus valores no est√°n documentados.  No los encontr√© en ninguna parte.  Del texto se desprende que cambian el componente STATUS_CONTROL entre modos.  Pero en el archivo VHDL mencionado anteriormente C: \ Archivos de programa (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ lcpsoc3 \ cpsoc3.vhd <br><br><div class="spoiler">  <b class="spoiler_title">vemos por separado el contador ya conocido por nosotros</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">component cy_psoc3_count7 generic(cy_period : std_logic_vector (6 downto 0) := "1111111"; cy_init_value : std_logic_vector (6 downto 0) := "0000000"; cy_route_ld : boolean := false; cy_route_en : boolean := false; cy_alt_mode : boolean := false); port (clock : in std_logic; reset : in std_logic; load : in std_logic; enable : in std_logic; count : out std_logic_vector (6 downto 0); tc : out std_logic); end component;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">por separado - estado y gesti√≥n</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> attribute atomic_rtl of cy_psoc3_status : component is rtl_generic; attribute cpu_access of cy_psoc3_status : component is true; component cy_psoc3_statusi generic(cy_force_order : boolean := false; cy_md_select : std_logic_vector (6 downto 0) := "0000000"; cy_int_mask : std_logic_vector (6 downto 0) := "0000000"); port (reset : in std_logic := '0'; clock : in std_logic := '0'; status : in std_logic_vector (6 downto 0); interrupt : out std_logic); end component; attribute atomic_rtl of cy_psoc3_statusi : component is rtl_generic; attribute cpu_access of cy_psoc3_statusi : component is true; component cy_psoc3_control generic(cy_init_value : std_logic_vector (7 downto 0) := "00000000"; cy_force_order : boolean := false; cy_ctrl_mode_1 : std_logic_vector (7 downto 0) := "00000000"; cy_ctrl_mode_0 : std_logic_vector (7 downto 0) := "00000000"; cy_ext_reset : boolean := false); port (reset : in std_logic := '0'; clock : in std_logic := '0'; control : out std_logic_vector (7 downto 0)); end component;</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">por separado - sincronizador</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">component cy_psoc3_sync port (clock : in std_logic := '0'; sc_in : in std_logic; sc_out : out std_logic); end component;</code> </pre><br></div></div><br>  Repito que Verilog no tiene una versi√≥n de estas declaraciones en absoluto (solo hay modelos de comportamiento en el directorio C: \ Archivos de programa (x86) \ Cypress \ PSoC Creator \ 4.2 \ PSoC Creator \ warp \ lib \ sim, por lo que creo que la configuraci√≥n de bits los programadores simples no tienen acceso a los modos. Al leer esta secci√≥n, debe tener en cuenta este hecho. Algo se proporciona √∫nicamente como referencia, no est√° sujeto a nosotros los programadores. </blockquote>  Para habilitar el modo de contador, la salida del contador debe seleccionarse en bits SC_OUT_CTI [1: 0].  En este modo, el funcionamiento normal del registro de control no est√° disponible.  Al mismo tiempo, el registro de estado puede usarse para operaciones de lectura, pero no debe usarlo para generar una interrupci√≥n, ya que el registro de mapeo de m√°scara tambi√©n se usa como un registro de per√≠odo de contador.  El registro de per√≠odo no se destruye y conserva su estado despu√©s de despertarse.  Para un per√≠odo de N medidas, el valor N-1 debe cargarse en el registro de per√≠odo.  El valor N = 1 (el per√≠odo es cero) ya que el valor del divisor de frecuencia no es compatible y conducir√° a una unidad constante en la salida del TC (recuento de terminales, TC).  La disponibilidad del modo SYNC depende de si se usa o no el control din√°mico (LD / EN).  Si no se usa, no afecta el modo SYNC.  Si se usa, el modo SYNC no est√° disponible. <br><br><h2>  21.3.3.5 Modo de sincronizaci√≥n </h2><br>  Como se muestra en la Figura 21-37, el registro de estado puede funcionar como un reloj dual de 4 bits sincronizado con el valor SC_CLK actual si se establece el bit SYNC MD.  Este modo se puede usar para implementar la sincronizaci√≥n local de se√±ales as√≠ncronas (por ejemplo, entradas GPIO).  En este caso, las se√±ales sincronizadas se seleccionan de SC_IN [3: 0], las salidas se enrutan a los contactos SC_IO_OUT [3: 0] y SYNC MD cambia autom√°ticamente los contactos SC_IO al modo de salida.  En este modo, el funcionamiento normal del registro de estado no est√° disponible, y el modo de bit de estado fijo se desactiva por la fuerza, independientemente de la configuraci√≥n del control de modo.  Este modo no afecta el registro de control.  El contador a√∫n se puede usar, pero con limitaciones.  En este modo de operaci√≥n, no se pueden usar entradas din√°micas (LD / EN). <br><br><img src="https://habrastorage.org/webt/ol/cw/6z/olcw6ztxrs5xqzb-9l0i6uyyqa8.png"><br>  <i>Figura 21-37.</i>  <i>Modo sincr√≥nico</i> <br><br><h2>  21.3.3.6 Reloj de estado y control </h2><br>  Los registros de control y estado requieren una selecci√≥n de reloj en cualquiera de los siguientes modos de funcionamiento: <br><br><ul><li>  registro de estado con cualquier bit en modo fijo con borrado despu√©s de leer, </li><li>  registro de control en modo contador, </li><li>  modo s√≠ncrono </li></ul><br>  El tiempo se asigna en el reloj y el m√≥dulo de reinicio.  Ver 21.3.4.  Reloj y m√≥dulo de control de reinicio. <br><br><h2>  21.3.3.7 Registro de control auxiliar </h2><br>  El registro de control auxiliar para lectura y escritura es un registro especial que controla el equipo UDB de hardware.  Este registro permite que la CPU o el DMA controlen din√°micamente las interrupciones, los FIFO y la operaci√≥n del contador.  Los bits de los registros y su descripci√≥n se dan a continuaci√≥n: <br><br><div class="scrollable-table"><table><tbody><tr><th colspan="8">  <b>Registro de control auxiliar</b> </th></tr><tr><td>  <b>7 7</b> </td><td>  <b>6 6</b> </td><td>  <b>5 5</b> </td><td>  <b>4 4</b> </td><td>  <b>3</b> </td><td>  <b>2</b> </td><td>  <b>1</b> </td><td>  <b>0 0</b> </td></tr><tr><td></td><td></td><td>  CNT <br>  START </td><td>  INT EN </td><td>  FIFO1 <br>  LVL </td><td>  FIFO0 <br>  LVL </td><td>  FIFO1 <br>  CLR </td><td>  FIFO0 <br>  CLR </td></tr></tbody></table></div><br><h4>  Borrar FIFO0 y FIFO1 (Borrar FIFO0, Borrar FIFO1) </h4><br>  Los bits FIFO0 CLR y FIFO1 CLR se utilizan para restablecer el estado de los FIFO correspondientes.  Cuando se escribe 1 en estos bits, se restablece el estado de la FIFO correspondiente.  Para continuar con la operaci√≥n FIFO, es necesario escribir 0. Estos bits permanecen amartillados Los FIFO funcionan como memorias intermedias simples de un solo byte sin estado. <br><br><h4>  Nivel FIFO0 y FIFO1 (Nivel FIFO0, Nivel FIFO1) </h4><br>  Los bits FIFO0 LVL y FIFO1 LVL establecen el nivel en el que un FIFO de 4 bytes eleva el estado del bus (cuando el bus lee o escribe en FIFO).  El valor del estado del bus FIFO depende de la direcci√≥n configurada, como se muestra en la tabla a continuaci√≥n. <br><br>  Cuadro 21-21.  Bits de control de nivel FIFO. <br><div class="scrollable-table"><table><tbody><tr><th>  <b>FIFOx</b> <b><br></b>  <b>LVL</b> </th><th>  <b>Modo de entrada</b> <b><br></b>  <b>(El autob√∫s escribe a FIFO)</b> </th><th>  <b>Modo de salida</b> <b><br></b>  <b>(El autob√∫s lee de FIFO)</b> </th></tr><tr><td>  0 0 </td><td>  <b>No lleno</b> <br>  Puede escribir al menos 1 byte. <br></td><td>  <b>No vacio</b> <br>  Al menos 1 byte est√° disponible para leer. </td></tr><tr><td>  1 </td><td>  <b>Devastado por al menos la mitad.</b> <br>  Puede escribir al menos 2 bytes. </td><td>  <b>Al menos medio lleno.</b> <br>  Al menos 2 bytes est√°n disponibles para leer. </td></tr></tbody></table></div><br><h4>  Habilitar interrupci√≥n </h4><br>  Cuando se activa la l√≥gica de generaci√≥n del registro de estado, el bit INT EN permite que pase la se√±al de interrupci√≥n generada. <br><br><h4>  ¬øIniciar contador / cuenta?  (Cuenta de inicio) </h4><br>  El bit CNT START se puede usar para iniciar y detener el contador (solo disponible si los bits SC_OUT_CTL [1: 0] est√°n configurados para el modo de salida del contador). <br><br><h2>  21.3.3.8 Resumen de registros de gesti√≥n y estado </h2><br>  La siguiente tabla resume las funciones de los registros de control y estado.  Tenga en cuenta que los registros de m√°scara y control se combinan con contadores y registros de per√≠odo, y el valor de estos registros no depende del modo de funcionamiento. <br><br>  Cuadro 21-22.  Un breve resumen del funcionamiento de los registros de gesti√≥n y estado. <br><div class="scrollable-table"><table><tbody><tr><th>  El modo </th><th>  Gerencia / Contador <br>  (Control / conteo) </th><th>  Estado / Sincronizaci√≥n <br>  (Estado / SINCRONIZACI√ìN) </th><th>  Superposici√≥n de m√°scara / per√≠odo <br>  (M√°scara / per√≠odo) </th></tr><tr><td>  Control </td><td>  Control fuera </td><td rowspan="2">  Status In o SYNC </td><td>  M√°scara de estado de superposici√≥n </td></tr><tr><td>  Contador </td><td>  Contrarrestar </td><td>  Periodo de contador <sup>a</sup> (Periodo de conteo) </td></tr><tr><td>  Estado </td><td rowspan="2">  Controlar o contar </td><td>  Estado en </td><td>  M√°scara de estado de superposici√≥n </td></tr><tr><td>  Sincronizaci√≥n (SYNC) </td><td>  Sincronizaci√≥n (SYNC) </td><td>  No disponible <sup>b</sup> (NA) </td></tr></tbody></table></div><br>  a.  - tenga en cuenta que en el modo contador, el registro de superposici√≥n de m√°scara funciona como un registro de per√≠odo y no puede funcionar como un registro de m√°scara sobre.  En consecuencia, la salida de interrupci√≥n no est√° disponible cuando se activa el modo contador. <br><br>  b.  - tenga en cuenta que en el modo de sincronizaci√≥n el registro de estado no est√° disponible y, por lo tanto, es imposible utilizar el registro de superposici√≥n de m√°scara.  Sin embargo, se puede usar como un registro de per√≠odo para el modo contador. <br><br>  Continuar√° ... </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443380/">https://habr.com/ru/post/443380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443364/index.html">C√≥mo una empresa de medios puede lanzar 12 startups exitosas al a√±o</a></li>
<li><a href="../443370/index.html">Conectando Google reCAPTCHA a Vue y validando la respuesta en el servidor</a></li>
<li><a href="../443372/index.html">Backend en CodeFest. Tripas ordenadas?</a></li>
<li><a href="../443376/index.html">Logramos encontrar docenas de almacenamientos corporativos de Box.com que revelan datos de Apple, Herbalife, etc.</a></li>
<li><a href="../443378/index.html">Estamos escribiendo un cliente http de alto rendimiento usando fasthttp como ejemplo. Alexander Valyalkin (VertaMedia)</a></li>
<li><a href="../443382/index.html">Fintech Digest: Mir Pay para Android, levantando la prohibici√≥n de retirar efectivo de billeteras an√≥nimas, las startups de AI no son exactamente AI</a></li>
<li><a href="../443384/index.html">Slurm y MegaSlerm en Mosc√∫ a finales de mayo</a></li>
<li><a href="../443386/index.html">C√≥mo obtener el registro de seguridad con un usuario no administrativo</a></li>
<li><a href="../443388/index.html">Control de iluminaci√≥n multinivel basado en KTS NPL</a></li>
<li><a href="../443390/index.html">Caracter√≠sticas del ingl√©s australiano</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>