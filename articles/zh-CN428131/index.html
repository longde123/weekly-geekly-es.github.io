<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏾 👩🏿‍⚖️ 👩🏾‍🤝‍👨🏻 关于RTOS的全部真相。 第十七条 事件标志组：简介和基本服务 🧒🏿 🕴🏼 🧜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在前面的一篇文章（第5章）中已经提到了事件标志组。 在Nucleus SE中，它们类似于信号，但更灵活。 它们提供了一种低成本且灵活的方式来在任务之间传输简单消息。 


 该系列中的先前文章： 
 第十六条 讯号 
 第十五条 内存分区：服务和数据结构 
 第十四条 内存部分：简介和基本服务 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>关于RTOS的全部真相。 第十七条 事件标志组：简介和基本服务</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428131/"><img src="https://habrastorage.org/webt/y6/hx/yw/y6hxyww0r_cp5m_lr0uspctzgqk.jpeg"><br><br> 在前面的一篇文章（第5章）中已经提到了事件标志组。 在Nucleus SE中，它们类似于信号，但更灵活。 它们提供了一种低成本且灵活的方式来在任务之间传输简单消息。 <br><a name="habracut"></a><br><br> 该系列中的先前文章： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十六条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">讯号</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十五条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存分区：服务和数据结构</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十四条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">内存部分：简介和基本服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十三条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务数据结构和不受支持的API调用</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第十二条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务处理服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第11条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务：API的配置和介绍</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第10条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计划程序：高级功能和上下文保留</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">调度程序：实施</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：内部设计和部署</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nucleus SE：简介</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">其他RTOS服务</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务交互和同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务，上下文切换和中断</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">任务与计划</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2条。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：结构和实时模式</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RTOS：简介。</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br><br><h2> 使用事件标志 </h2><br> 在Nucleus SE中，事件标记是在构建阶段定义的。 应用程序中事件标志组的最大数量为16。如果未定义事件标志组，则与事件标志组的数据结构和服务调用相关的代码将不包含在应用程序中。 <br><br> 事件标志组-一组八个位的标志，对其进行访问进行调节，以便多个任务可以安全地使用一个标志。 一个任务可以设置或清除事件标志的任意组合。 另一个任务是随时读取一组标志，它也可以等待特定的标志序列（通过轮询或暂停）。 <br><br><h2> 配置事件标志组 </h2><br><h3> 事件标志组数 </h3><br> 与大多数Nucleus SE对象一样，事件标志组的配置由<b>nuse_config.h中</b>的<b>#define</b>指令指定。 主要参数是<b>NUSE_EVENT_GROUP_NUMBER</b> ，它确定将在应用程序中定义多少组事件标志。 默认情况下，此参数设置为0（即，不使用事件标志组），并且可以具有最大为16的任何值。不正确的值将导致编译错误，该错误将通过检入<b>nuse_config_check.h</b>来生成（由<b>nuse_config.c</b>启用）。 ，这意味着它将使用此模块进行编译），因此，# <b>error</b>指令将起作用。 选择一个非零值将用作事件标志组的主要激活器。 定义数据结构时使用此参数，其大小取决于其值（以下文章中有更多关于此的内容）。 此外，非零值会激活API设置。 <br><br><h3> 激活API调用 </h3><br>  Nucleus SE中的每个API函数（实用程序调用） <b>都由nuse_config.h中</b>的<b>#define</b>指令激活。 对于事件标志组，这些标志包括： <br> <code>NUSE_EVENT_GROUP_SET <br> NUSE_EVENT_GROUP_RETRIEVE <br> NUSE_EVENT_GROUP_INFORMATION <br> NUSE_EVENT_GROUP_COUNT <br></code> <br> 默认情况下，它们设置为<b>FALSE</b> ，从而禁用每个服务调用并阻止包含实现它们的代码。 要配置事件标志组，您需要选择必要的API调用并将相应的伪指令设置为<b>TRUE</b> 。 <br><br> 以下是默认nuse_config.h文件的摘录。 <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_NUMBER 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Number of event groups in the system - 0-16 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_SET FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_RETRIEVE FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_INFORMATION FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_COUNT FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span></span></code> </pre><br> 如果应用程序中没有事件标志组，则激活的API函数将导致编译错误（始终启用的<b>NUSE_Event_Group_Count（）</b>除外）。 如果您的代码使用尚未激活的API调用，则会发生布局错误，因为实现代码未包含在应用程序中。 <br><br><h2> 事件调用实用程序调用 </h2><br>  Nucleus RTOS支持七个实用程序调用，这些调用提供以下功能： <br><br><ul><li> 设置事件标志。  Nucleus SE在<b>NUSE_Event_Group_Set（）</b>函数中实现。 </li><li> 读取事件标志。 在Nucleus SE中，在<b>NUSE_Event_Group_Retrieve（）中实现</b> 。 </li><li> 提供有关特定事件标志组的信息。 在Nucleus SE中，在<b>NUSE_Event_Group_Information（）中实现</b> 。 </li><li> 返回应用程序中当前配置的事件标志组的数量。 在Nucleus SE中，在<b>NUSE_Event_Group_Count（）中实现</b> 。 </li><li> 向应用程序添加新的事件标志组。 未实施Nucleus SE。 </li><li> 从应用程序中删除一组事件标志。 未实施Nucleus SE。 </li><li> 返回指向应用程序中所有事件标志组的指针。 未实施Nucleus SE。 </li></ul><br> 这些开销调用中的每一个的实现将在下面详细讨论。 <br><br> 值得注意的是，Nucleus RTOS或Nucleus SE中都没有复位功能。 这是有意完成的。 复位功能暗示了标志的特殊状态的普遍性。 对于事件标志组，唯一的“特殊”状态是重置所有标志，这可以使用<b>NUSE_Event_Group_Set（）完成</b> 。 <br><br><h2> 服务呼叫以设置和读取事件标志组 </h2><br> 可以对一组事件标志执行的基本操作是设置一个或多个标志的值，以及读取当前标志值。  Nucleus RTOS和Nucleus SE为这些操作提供了四个基本的API调用。 <br><br> 由于事件标志是位，因此最好将它们可视化为二进制数。 由于历史上标准C不支持二进制常数的表示（仅八进制和十六进制），因此Nucleus SE具有有用的头文件<b>nuse_binary.h</b> ，其中包含针对所有256个8位值的<b>#define</b>字符，例如<b>b01010101</b> 。 <br><br><h3> 设置事件标志 </h3><br>  Nucleus RTOS API实用程序的标记调用非常灵活，它允许您使用<b>AND</b>和<b>OR</b>运算来设置和清除标记值。  Nucleus SE提供了类似的功能，但任务暂停是可选的。 <br><br>  <b><i>调用以在Nucleus RTOS中设置标志</i></b> <br> 服务电话原型： <br><br>  <b>状态NU_Set_Events（NU_EVENT_GROUP *组，UNSIGNED event_flags，OPTION操作）;</b> <br><br> 参数： <br><br>  group-指向一组事件标志的用户提供的控制块的指针； <br>  <b>event_flags-</b>标志组的位掩码的值； <br>  <b>operation-</b>要执行的<b>操作</b> ， <b>NU_OR</b> （用于设置标志）或<b>NU_AND</b> （用于清除标志）。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_INVALID_GROUP-</b>指向一组事件标志的无效指针； <br>  <b>NU_INVALID_OPERATION-</b>指定的操作不同于<b>NU_OR</b>和<b>NU_AND</b> 。 <br><br>  <b><i>调用以在Nucleus SE中设置标志</i></b> <br> 该API调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br><br>  <b>STATUS NUSE_Event_Group_Set（NUSE_EVENT_GROUP组，U8 event_flags，OPTION操作）；</b> <br><br> 参数： <br><br>  group-设置/清除标志的事件组的索引（ID）； <br>  <b>event_flags-</b>一组标志的最大比特值； <br>  <b>operation-</b>要执行的<b>操作</b> ， <b>NUSE_OR</b> （用于设置标志）或<b>NUSE_AND</b> （用于清除标志）。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_INVALID_GROUP-</b>一组事件标志的无效索引； <br>  <b>NUSE_INVALID_OPERATION-</b>指定的操作不同于<b>NUSE_OR</b>和<b>NUSE_AND</b> 。 <br><br>  <b><i>在Nucleus SE中实现事件标志的安装</i></b> <br>  <b>NUSE_Event_Group_Set（）</b> API函数的初始代码是通用的（检查参数后），无论是否激活了对阻塞调用（任务挂起）的API支持。 逻辑很简单： <br><br><pre> <code class="hljs powershell">NUSE_CS_Enter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { NUSE_Event_Group_Data[<span class="hljs-type"><span class="hljs-type">group</span></span>] |= event_flags; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> /* NUSE_AND */ { NUSE_Event_Group_Data[<span class="hljs-type"><span class="hljs-type">group</span></span>] &amp;= event_flags; }</code> </pre> <br> 将<b>event_flags位掩码</b> （使用<b>AND</b>或<b>OR</b>操作）叠加在所选事件标志组的值上。 <br><br> 剩余的代码仅在激活任务锁定时启用： <br><br><pre> <code class="hljs mel">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_BLOCKING_ENABLE <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { U8 index; <span class="hljs-comment"><span class="hljs-comment">/* check whether any tasks are blocked */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* on this event group */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index=<span class="hljs-number"><span class="hljs-number">0</span></span>; index&lt;NUSE_TASK_NUMBER; index++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((LONIB(NUSE_Task_Status[index]) == NUSE_EVENT_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Task_Status[index] = NUSE_READY; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]--; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif #endif NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS;</code> </pre> <br> 如果从该组标志中暂停了任何任务（用于读取），它们将继续执行。 当他们有机会继续执行时（取决于调度程序），他们可以确定是否满足恢复条件（请参阅读取事件标志）。 <br><br><h3> 读取事件标志 </h3><br>  Nucleus RTOS API实用程序读取的调用非常灵活，如果无法立即完成操作（例如，如果您尝试读取不代表当前状态的特定事件标志序列），则可以无限期地暂停任务或以特定的超时暂停任务。  Nucleus SE提供了相同的功能，仅任务暂停是可选的，并且未实现超时。 <br><br>  <b><i>在Nucleus RTOS中挑战标志</i></b> <br> 服务电话原型： <br><br>  <b>状态NU_Retrieve_Events（NU_EVENT_GROUP *组，未签名的请求事件，选项操作，未签名*检索的事件，未签名挂起）；</b> <br><br> 参数： <br><br>  group-指向一组事件标志的用户提供的控制块的指针； <br>  <b>request_events-</b>定义要读取的标志的位掩码； <br>  <b>操作</b> -有四个<b>操作</b>可用： <b>NU_AND</b> ， <b>NU_AND_CONSUME</b> ， <b>NU_OR</b>和<b>NU_OR_CONSUME</b> 。  <b>NU_AND</b>和<b>NU_AND_CONSUME</b>操作指示所有请求的标志都是必需的。  <b>NU_OR</b>和<b>NU_OR_CONSUME</b>操作指示一个或多个请求的标志已足够。 成功请求后， <b>CONSUME</b>参数将自动清除现有标志。 <br>  <b>resolved_events-</b>读取事件标志的值的存储指针； <br>  <b>暂停</b> -暂停任务的规范； 可以采用<b>NU_NO_SUSPEND</b>或<b>NU_SUSPEND</b>值，或者以系统计时器的滴答度为单位的超时值（从1到4,294,967,293）。 <br><br> 返回值： <br><br>  <b>NU_SUCCESS-</b>调用成功完成； <br>  <b>NU_NOT_PRESENT-</b>指定的操作没有返回事件（在NU_OR情况下不是单个事件，在NU_AND情况下不是所有事件）； <br>  <b>NU_INVALID_GROUP-</b>指向一组事件标志的无效指针； <br>  <b>NU_INVALID_OPERATION-</b>指定的操作不正确； <br>  <b>NU_INVALID_POINTER-</b>指向事件标志存储的空指针（NULL）； <br>  <b>NU_INVALID_SUSPEND-</b>尝试从与任务无关的线程中暂停； <br>  <b>NU_TIMEOUT-</b>即使在指定的超时后也未设置所需的事件标志组合； <br>  <b>NU_GROUP_DELETED-</b>任务挂起时删除了事件标志组。 <br><br>  <b><i>在Nucleus SE中进行标志挑战</i></b> <br> 该API调用支持Nucleus RTOS API的核心功能。 <br><br> 服务电话原型： <br><br>  <b>状态NUSE_Event_Group_Retrieve（NUSE_EVENT_GROUP组，U8请求的事件，OPTION操作，U8 *检索的事件，U8挂起）；</b> <br><br> 参数： <br><br>  <b>group-</b>读取的事件标志组的索引（ID）； <br>  <b>request_events-</b>定义要读取的标志的位掩码； <br>  <b>操作</b> -指示所需标志数量的规范： <b>NUSE OR</b> （某些标志）或<b>NUSE AND</b> （所有标志）； <br>  <b>resolved_events-指向</b>读取事件标志的实际值的存储的指针（使用<b>NUSE_AND</b>操作<b>，</b>这与在<b>request_events</b>参数中传递的相同）； <br>  <b>暂停</b> -暂停任务的规范；它可以采用值<b>NUSE_NO_SUSPEND</b>或<b>NUSE_SUSPEND</b> 。 <br><br> 返回值： <br><br>  <b>NUSE_SUCCESS-</b>呼叫已成功完成； <br>  <b>NUSE_NOT_PRESENT-</b>指定的操作没有返回事件（对于<b>NUSE_OR</b> ，不是单个事件，对于<b>NUSE_AND是</b>不是所有事件）； <br>  <b>NUSE_INVALID_GROUP-</b>一组事件标志的无效索引； <br>  <b>NUSE_INVALID_OPERATION-</b>指定的操作不同于<b>NUSE_OR</b>或<b>NUSE_AND</b> ； <br>  <b>NUSE_INVALID_POINTER-</b>指向读取事件标志存储的空指针（ <b>NULL</b> ）； <br>  <b>NUSE_INVALID_SUSPEND-</b>尝试从非任务流暂停或禁用了对阻止API调用的支持。 <br><br>  <b><i>在Nucleus SE中实现事件标志读取</i></b> <br> 在条件编译期间，根据是否激活了对阻止（挂起）任务的API调用的支持，选择了API函数代码<b>NUSE_Event_Group_Retrieve（）的版本</b> （检查参数之后）。 让我们分别考虑这两个选项。 <br><br> 如果禁用了锁定，则此API调用的完整代码如下所示： <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">temp_events</span></span> = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (operation == NUSE_OR) { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } } <span class="hljs-attribute"><span class="hljs-attribute">else</span></span> /* operation == NUSE_AND */ { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events == requested_events) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } }</code> </pre><br> 从指定的事件标志组中选择所需的事件标志。 将该值与所需事件进行比较，同时考虑到<b>AND / OR</b>操作以及返回的结果和所请求标志的立即值。 <br><br> 如果激活了任务锁定，则代码将变得更加复杂： <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { temp_events = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">/* operation == NUSE_AND */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events == requested_events) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value == NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND) <span class="hljs-comment"><span class="hljs-comment">/* block task */</span></span> { NUSE_Event_Group_Blocking_Count[group]++; NUSE_Suspend_Task(NUSE_Task_Active, (group &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | NUSE_EVENT_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value != NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND);</code> </pre><br> 该代码放置在<b>do ... while循环中</b> ，该<b>循环</b>在<b>suspend</b>参数为<b>NUSE_SUSPEND时起作用</b> 。 <br><br> 读取请求的事件标志就像调用它们时一样，不会阻塞。 如果读取不成功，并且<b>suspend</b>参数为<b>NUSE_NO_SUSPEND</b> ，则API调用将设置为<b>NUSE_NOT_PRESENT</b> 。 如果<b>suspend</b>参数设置为<b>NUSE_SUSPEND</b> ，任务将暂停。 返回时（任务恢复时），如果返回值为<b>NUSE_SUCCESS</b> ，表明由于已设置或清除了该组中的事件标志而恢复了任务，则循环从头开始，并读取并检查这些标志。 由于没有用于重置事件标志组的API函数，因此这是恢复任务的唯一原因，但是系统上<b>保留</b>了<b>NUSE_Task_Blocking_Return []</b>检查过程，以使锁定控制与其他类型的对象兼容。 <br><br> 下面的文章将描述与事件标志组关联的其他API调用，以及它们的数据结构。 <br><br>  <b>关于作者：</b> Colin Walls在电子行业工作了30多年，大部分时间用于固件。 他现在是Mentor Embedded（Mentor Graphics的一个部门）的固件工程师。  Colin Walls经常在会议和研讨会上发表演讲，他撰写了许多技术文章并撰写了两本有关固件的书。 居住在英国。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Colin的</a>专业<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">博客</a> ，电子邮件：colin_walls@mentor.com。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN428131/">https://habr.com/ru/post/zh-CN428131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN428121/index.html">斯坦·德拉普金（Stan Drapkin）。 .NET中的高级密码陷阱</a></li>
<li><a href="../zh-CN428123/index.html">安全周41：好消息</a></li>
<li><a href="../zh-CN428125/index.html">谁是产品分析人员，为什么团队需要它们？</a></li>
<li><a href="../zh-CN428127/index.html">Nginx缓存：一切都是新的-被遗忘的很旧</a></li>
<li><a href="../zh-CN428129/index.html">简单的模糊逻辑将燃气轮机的“从过去”粘合在一起</a></li>
<li><a href="../zh-CN428133/index.html">羽ura 高性能GraphQL到SQL Server的体系结构</a></li>
<li><a href="../zh-CN428135/index.html">如何在内置代码编辑器中配置或禁用linting</a></li>
<li><a href="../zh-CN428137/index.html">奥运会，创意大赛，有关IT项目管理和电影放映的讲座：ITMO大学即将举行的10个活动</a></li>
<li><a href="../zh-CN428141/index.html">前端的后端，或Yandex.Market如何创建没有拐杖的API</a></li>
<li><a href="../zh-CN428143/index.html">ReactJS RBAC实现方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>