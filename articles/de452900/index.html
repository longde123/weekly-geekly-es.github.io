<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé† üòÑ üç£ Indizes in PostgreSQL - 9 (BRIN) üï§ ü§Ω üë®üèΩ‚Äç‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den vorherigen Artikeln haben wir die PostgreSQL- Indexierungs-Engine , die Schnittstelle der Zugriffsmethoden und die folgenden Methoden erl√§utert...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indizes in PostgreSQL - 9 (BRIN)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/452900/">  In den vorherigen Artikeln haben wir die PostgreSQL- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Indexierungs-Engine</a> , die Schnittstelle der Zugriffsmethoden und die folgenden Methoden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">erl√§utert</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hash-Indizes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">B-B√§ume</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GIN</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RUM</a> .  Das Thema dieses Artikels sind BRIN-Indizes. <br><br><h1>  Brin </h1><br><h2>  Allgemeines Konzept </h2><br>  Im Gegensatz zu Indizes, mit denen wir bereits Daten gesammelt haben, besteht die Idee von BRIN darin, das Durchsuchen definitiv ungeeigneter Zeilen zu vermeiden, anstatt schnell die passenden zu finden.  Dies ist immer ein ungenauer Index: Er enth√§lt √ºberhaupt keine TIDs von Tabellenzeilen. <br><br>  Vereinfacht gesagt funktioniert BRIN gut f√ºr Spalten, in denen Werte mit ihrer physischen Position in der Tabelle korrelieren.  Mit anderen Worten, wenn eine Abfrage ohne ORDER BY-Klausel die Spaltenwerte virtuell in aufsteigender oder absteigender Reihenfolge zur√ºckgibt (und es keine Indizes f√ºr diese Spalte gibt). <br><br>  Diese Zugriffsmethode wurde im Rahmen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Axle</a> , dem europ√§ischen Projekt f√ºr extrem gro√üe Analysedatenbanken, mit Blick auf Tabellen mit einer Gr√∂√üe von mehreren Terabyte oder Dutzenden von Terabyte erstellt.  Ein wichtiges Merkmal von BRIN, mit dem wir Indizes f√ºr solche Tabellen erstellen k√∂nnen, ist die geringe Gr√∂√üe und die minimalen Wartungskosten. <br><br>  Dies funktioniert wie folgt.  Die Tabelle ist in <em>Bereiche unterteilt</em> , die mehrere Seiten gro√ü sind (oder mehrere Bl√∂cke, die gleich sind) - daher der Name: Block Range Index, BRIN.  Der Index speichert <em>zusammenfassende Informationen</em> zu den Daten in jedem Bereich.  In der Regel sind dies die minimalen und maximalen Werte, aber es ist zuf√§llig anders, wie weiter unten gezeigt.  Angenommen, es wird eine Abfrage ausgef√ºhrt, die die Bedingung f√ºr eine Spalte enth√§lt.  Wenn die gesuchten Werte nicht in das Intervall gelangen, kann der gesamte Bereich √ºbersprungen werden.  Wenn dies jedoch der Fall ist, m√ºssen alle Zeilen in allen Bl√∂cken durchgesehen werden, um die passenden unter ihnen auszuw√§hlen. <br><br>  Es ist kein Fehler, BRIN nicht als Index, sondern als Beschleuniger des sequentiellen Scans zu behandeln.  Wir k√∂nnen BRIN als Alternative zur Partitionierung betrachten, wenn wir jeden Bereich als "virtuelle" Partition betrachten. <br><br>  Lassen Sie uns nun die Struktur des Index genauer diskutieren. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  Die erste Seite (genauer gesagt Null) enth√§lt die Metadaten. <br><br>  Seiten mit den zusammenfassenden Informationen befinden sich in einem bestimmten Versatz zu den Metadaten.  Jede Indexzeile auf diesen Seiten enth√§lt zusammenfassende Informationen zu einem Bereich. <br><br>  Zwischen der Metaseite und den Zusammenfassungsdaten befinden sich Seiten mit der Umkehrbereichskarte (abgek√ºrzt als "revmap").  Tats√§chlich ist dies ein Array von Zeigern (TIDs) auf die entsprechenden Indexzeilen. <br><br><img src="https://habrastorage.org/webt/nr/pm/s9/nrpms932o5clzubwymywxtud6q4.png"><br><br>  F√ºr einige Bereiche kann der Zeiger in "revmap" zu keiner Indexzeile f√ºhren (eine ist in der Abbildung grau markiert).  In einem solchen Fall wird davon ausgegangen, dass der Bereich noch keine zusammenfassenden Informationen enth√§lt. <br><br><h2>  Index scannen </h2><br>  Wie wird der Index verwendet, wenn er keine Verweise auf Tabellenzeilen enth√§lt?  Diese Zugriffsmethode kann sicherlich keine Zeilen TID f√ºr TID zur√ºckgeben, aber sie kann eine Bitmap erstellen.  Es gibt zwei Arten von Bitmap-Seiten: genau auf die Zeile und ungenau auf die Seite.  Es ist eine ungenaue Bitmap, die verwendet wird. <br><br>  Der Algorithmus ist einfach.  Die Karte der Bereiche wird nacheinander gescannt (dh die Bereiche werden in der Reihenfolge ihrer Position in der Tabelle durchlaufen).  Die Zeiger werden verwendet, um Indexzeilen mit zusammenfassenden Informationen zu jedem Bereich zu bestimmen.  Wenn ein Bereich nicht den gesuchten Wert enth√§lt, wird er √ºbersprungen. Wenn er den Wert enthalten kann (oder zusammenfassende Informationen nicht verf√ºgbar sind), werden alle Seiten des Bereichs zur Bitmap hinzugef√ºgt.  Die resultierende Bitmap wird dann wie gewohnt verwendet. <br><br><h2>  Index aktualisieren </h2><br>  Interessanter ist, wie der Index aktualisiert wird, wenn die Tabelle ge√§ndert wird. <br><br>  Wenn Sie einer Tabellenseite eine neue Version einer Zeile <strong>hinzuf√ºgen</strong> , bestimmen wir, in welchem ‚Äã‚ÄãBereich sie enthalten ist, und verwenden die Karte der Bereiche, um die Indexzeile mit den Zusammenfassungsinformationen zu finden.  All dies sind einfache arithmetische Operationen.  Die Gr√∂√üe eines Bereichs sei beispielsweise vier, und auf Seite 13 wird eine Zeilenversion mit dem Wert 42 angezeigt.  Die Nummer des Bereichs (beginnend mit Null) ist 13/4 = 3, daher nehmen wir in "revmap" den Zeiger mit dem Offset von 3 (seine Bestellnummer ist vier). <br><br>  Der minimale Wert f√ºr diesen Bereich ist 31 und der maximale Wert ist 40. Da der neue Wert von 42 au√üerhalb des Intervalls liegt, aktualisieren wir den maximalen Wert (siehe Abbildung).  Befindet sich der neue Wert jedoch noch innerhalb der gespeicherten Grenzen, muss der Index nicht aktualisiert werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba7/6ce/e4c/ba76cee4c3d40e9f428954d0478ecee0.png"><br><br>  All dies bezieht sich auf die Situation, in der die neue Version der Seite in einem Bereich erscheint, f√ºr den die zusammenfassenden Informationen verf√ºgbar sind.  Wenn der Index erstellt wird, werden die Zusammenfassungsinformationen f√ºr alle verf√ºgbaren Bereiche berechnet. W√§hrend die Tabelle jedoch weiter erweitert wird, k√∂nnen neue Seiten auftreten, die au√üerhalb der Grenzen liegen.  Hier stehen zwei Optionen zur Verf√ºgung: <br><br><ol><li>  Normalerweise wird der Index nicht sofort aktualisiert.  Dies ist keine gro√üe Sache: Wie bereits erw√§hnt, wird beim Scannen des Index der gesamte Bereich durchgesehen.  Die eigentliche Aktualisierung erfolgt w√§hrend des "Vakuums" oder manuell durch Aufrufen der Funktion "brin_summarize_new_values". </li><li> Wenn wir den Index mit dem Parameter "autosummarize" erstellen, wird die Aktualisierung sofort durchgef√ºhrt.  Wenn Seiten des Bereichs jedoch mit neuen Werten gef√ºllt werden, k√∂nnen Aktualisierungen zu h√§ufig erfolgen. Daher ist dieser Parameter standardm√§√üig deaktiviert. </li></ol><br>  Wenn neue Bereiche auftreten, kann sich die Gr√∂√üe der "Revmap" erh√∂hen.  Immer wenn die Karte zwischen der Metaseite und den Zusammenfassungsdaten um eine andere Seite erweitert werden muss, werden vorhandene Zeilenversionen auf einige andere Seiten verschoben.  Die Karte der Bereiche befindet sich also immer zwischen der Metaseite und den Zusammenfassungsdaten. <br><br>  Wenn eine Zeile <strong>gel√∂scht wird</strong> , ... passiert nichts.  Wir k√∂nnen feststellen, dass manchmal der minimale oder maximale Wert gel√∂scht wird. In diesem Fall k√∂nnte das Intervall reduziert werden.  Um dies zu erkennen, m√ºssten wir jedoch alle Werte im Bereich lesen, und dies ist kostspielig. <br><br>  Die Richtigkeit des Index wird nicht beeintr√§chtigt. Bei der Suche m√ºssen jedoch m√∂glicherweise mehr Bereiche durchsucht werden, als tats√§chlich ben√∂tigt werden.  Im Allgemeinen k√∂nnen zusammenfassende Informationen f√ºr eine solche Zone manuell neu berechnet werden (durch Aufrufen der Funktionen "brin_desummarize_range" und "brin_summarize_new_values"). Wie k√∂nnen wir jedoch einen solchen Bedarf erkennen?  Zu diesem Zweck steht jedoch kein herk√∂mmliches Verfahren zur Verf√ºgung. <br><br>  Schlie√ülich ist das <strong>Aktualisieren einer Zeile</strong> nur das L√∂schen der veralteten Version und das Hinzuf√ºgen einer neuen. <br><br><h2>  Beispiel </h2><br>  Versuchen wir, ein eigenes Mini-Data-Warehouse f√ºr die Daten aus Tabellen der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo-Datenbank zu</a> erstellen.  Nehmen wir an, dass f√ºr die BI-Berichterstattung eine denormalisierte Tabelle erforderlich ist, um die Fl√ºge, die von einem Flughafen abgeflogen oder auf dem Flughafen gelandet sind, mit der Genauigkeit eines Sitzplatzes in der Kabine wiederzugeben.  Die Daten f√ºr jeden Flughafen werden einmal t√§glich zur Tabelle hinzugef√ºgt, wenn es Mitternacht in der entsprechenden Zeitzone ist.  Die Daten werden weder aktualisiert noch gel√∂scht. <br><br>  Die Tabelle sieht wie folgt aus: <br><br><pre><code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> flights_bi( airport_code <span class="hljs-type"><span class="hljs-type">char</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>), airport_coord <span class="hljs-type"><span class="hljs-type">point</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- geo coordinates of airport airport_utc_offset interval, -- time zone flight_no char(6), -- flight number flight_type text. -- flight type: departure / arrival scheduled_time timestamptz, -- scheduled departure/arrival time of flight actual_time timestamptz, -- actual time of flight aircraft_code char(3), seat_no varchar(4), -- seat number fare_conditions varchar(10), -- travel class passenger_id varchar(20), passenger_name text );</span></span></code> </pre> <br>  Wir k√∂nnen den Vorgang des Ladens der Daten mithilfe verschachtelter Schleifen simulieren: eine externe - nach Tagen (wir betrachten <a href="">eine gro√üe Datenbank</a> , also 365 Tage) und eine interne Schleife - nach Zeitzonen (von UTC + 02 bis UTC + 12) .  Die Abfrage ist ziemlich lang und nicht von besonderem Interesse, daher werde ich sie unter dem Spoiler verstecken. <br><br><div class="spoiler">  <b class="spoiler_title">Simulation des Ladens der Daten in den Speicher</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-symbol"><span class="pgsql"><span class="hljs-symbol">&lt;&lt;local&gt;&gt;</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">DECLARE</span></span></span><span class="pgsql"> curdate </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">date</span></span></span><span class="pgsql"> := (</span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> min(scheduled_departure) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> flights); utc_offset </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHILE</span></span></span><span class="pgsql"> (curdate &lt;= bookings.now()::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">date</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> utc_offset := </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'12 hours'</span></span></span><span class="pgsql">; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHILE</span></span></span><span class="pgsql"> (utc_offset &gt;= </span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">interval</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'2 hours'</span></span></span><span class="pgsql">) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">LOOP</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INSERT</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">INTO</span></span></span><span class="pgsql"> flights_bi </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WITH</span></span></span><span class="pgsql"> flight ( airport_code, airport_coord, flight_id, flight_no, scheduled_time, actual_time, aircraft_code, flight_type ) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ( </span><span class="hljs-comment"><span class="pgsql"><span class="hljs-comment">--  SELECT a.airport_code, a.coordinates, f.flight_id, f.flight_no, f.scheduled_departure, f.actual_departure, f.aircraft_code, 'departure' FROM airports a, flights f, pg_timezone_names tzn WHERE a.airport_code = f.departure_airport AND f.actual_departure IS NOT NULL AND tzn.name = a.timezone AND tzn.utc_offset = local.utc_offset AND timezone(a.timezone, f.actual_departure)::date = curdate UNION ALL --  SELECT a.airport_code, a.coordinates, f.flight_id, f.flight_no, f.scheduled_arrival, f.actual_arrival, f.aircraft_code, 'arrival' FROM airports a, flights f, pg_timezone_names tzn WHERE a.airport_code = f.arrival_airport AND f.actual_arrival IS NOT NULL AND tzn.name = a.timezone AND tzn.utc_offset = local.utc_offset AND timezone(a.timezone, f.actual_arrival)::date = curdate ) SELECT f.airport_code, f.airport_coord, local.utc_offset, f.flight_no, f.flight_type, f.scheduled_time, f.actual_time, f.aircraft_code, s.seat_no, s.fare_conditions, t.passenger_id, t.passenger_name FROM flight f JOIN seats s ON s.aircraft_code = f.aircraft_code LEFT JOIN boarding_passes bp ON bp.flight_id = f.flight_id AND bp.seat_no = s.seat_no LEFT JOIN ticket_flights tf ON tf.ticket_no = bp.ticket_no AND tf.flight_id = bp.flight_id LEFT JOIN tickets t ON t.ticket_no = tf.ticket_no; RAISE NOTICE '%, %', curdate, utc_offset; utc_offset := utc_offset - interval '1 hour'; END LOOP; curdate := curdate + 1; END LOOP; END; $$</span></span></span></span>;</code> </pre><br></div></div><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi;</code> </pre><pre> <code class="plaintext hljs"> count ---------- 30517076 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 4127 MB (1 row)</code> </pre><br>  Wir bekommen 30 Millionen Zeilen und 4 GB.  Nicht so gro√ü, aber gut genug f√ºr einen Laptop: Der sequentielle Scan dauerte ungef√§hr 10 Sekunden. <br><br><h3>  Auf welchen Spalten sollen wir den Index erstellen? </h3><br>  Da BRIN-Indizes eine geringe Gr√∂√üe und moderate Gemeinkosten haben und Aktualisierungen nur selten auftreten, bietet sich die seltene Gelegenheit, viele Indizes ‚Äûnur f√ºr den Fall‚Äú zu erstellen, beispielsweise in allen Bereichen, in denen Analystenbenutzer ihre Ad-hoc-Abfragen erstellen k√∂nnen .  Wird nicht n√ºtzlich sein - egal, aber selbst ein Index, der nicht sehr effizient ist, funktioniert mit Sicherheit besser als sequentieller Scan.  Nat√ºrlich gibt es Felder, in denen es absolut nutzlos ist, einen Index zu erstellen.  reiner gesunder Menschenverstand wird sie dazu veranlassen. <br><br>  Es sollte jedoch seltsam sein, sich auf diesen Rat zu beschr√§nken. Versuchen wir daher, ein genaueres Kriterium anzugeben. <br><br>  Wir haben bereits erw√§hnt, dass die Daten in gewisser Weise mit ihrem physischen Standort korrelieren m√ºssen.  Hier ist es sinnvoll, sich daran zu erinnern, dass PostgreSQL Tabellenspaltenstatistiken sammelt, die den Korrelationswert enthalten.  Der Planer verwendet diesen Wert, um zwischen einem regul√§ren Index-Scan und einem Bitmap-Scan zu w√§hlen, und wir k√∂nnen ihn verwenden, um die Anwendbarkeit des BRIN-Index abzusch√§tzen. <br><br>  Im obigen Beispiel sind die Daten offensichtlich nach Tagen geordnet (nach "geplanter_Zeit" sowie nach "tats√§chlicher_Zeit" - es gibt keinen gro√üen Unterschied).  Dies liegt daran, dass Zeilen, die der Tabelle hinzugef√ºgt werden (ohne L√∂schungen und Aktualisierungen), nacheinander in der Datei angeordnet werden.  Bei der Simulation des Datenladens haben wir nicht einmal die ORDER BY-Klausel verwendet, daher k√∂nnen Daten innerhalb eines Tages im Allgemeinen auf beliebige Weise verwechselt werden, aber die Reihenfolge muss vorhanden sein.  Lassen Sie uns dies √ºberpr√ºfen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> flights_bi; demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename=<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> correlation <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nulls last</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation --------------------+------------- scheduled_time | 0.999994 actual_time | 0.999994 fare_conditions | 0.796719 flight_type | 0.495937 airport_utc_offset | 0.438443 aircraft_code | 0.172262 airport_code | 0.0543143 flight_no | 0.0121366 seat_no | 0.00568042 passenger_name | 0.0046387 passenger_id | -0.00281272 airport_coord | (12 rows)</code> </pre><br>  Der Wert, der nicht zu nahe bei Null liegt (idealerweise in der N√§he von Plus-Minus Eins, wie in diesem Fall), sagt uns, dass der BRIN-Index angemessen ist. <br><br>  Die Reiseklasse "Tarifbedingung" (die Spalte enth√§lt drei eindeutige Werte) und der Flugtyp "Flugtyp" (zwei eindeutige Werte) schienen unerwartet an zweiter und dritter Stelle zu stehen.  Dies ist eine Illusion: Formal ist die Korrelation hoch, w√§hrend tats√§chlich auf mehreren aufeinanderfolgenden Seiten alle m√∂glichen Werte mit Sicherheit angetroffen werden, was bedeutet, dass BRIN nichts Gutes bringt. <br><br>  Als n√§chstes folgt die Zeitzone "Airport_utc_offset": Im betrachteten Beispiel werden Flugh√§fen innerhalb eines Tageszyklus nach Zeitzonen "nach Konstruktion" geordnet. <br><br>  Es sind diese beiden Felder, Zeit und Zeitzone, mit denen wir weiter experimentieren werden. <br><br><h3>  M√∂gliche Schw√§chung der Korrelation </h3><br>  Die Korrelation, die "durch Konstruktion" entsteht, kann leicht geschw√§cht werden, wenn die Daten ge√§ndert werden.  Dabei geht es nicht um eine √Ñnderung eines bestimmten Werts, sondern um die Struktur der Multiversions-Parallelit√§tskontrolle: Die veraltete Zeilenversion wird auf einer Seite gel√∂scht, aber eine neue Version kann eingef√ºgt werden, wo immer freier Speicherplatz verf√ºgbar ist.  Aus diesem Grund werden bei Aktualisierungen ganze Zeilen verwechselt. <br><br>  Wir k√∂nnen diesen Effekt teilweise steuern, indem wir den Wert des Speicherparameters "fillfactor" reduzieren und auf diese Weise freien Speicherplatz auf einer Seite f√ºr zuk√ºnftige Aktualisierungen lassen.  Aber wollen wir die Gr√∂√üe eines bereits riesigen Tisches erh√∂hen?  Au√üerdem wird das Problem der L√∂schungen dadurch nicht behoben: Sie setzen auch "Traps" f√ºr neue Zeilen, indem sie den Speicherplatz irgendwo auf vorhandenen Seiten freigeben.  Aus diesem Grund werden Zeilen, die sonst am Ende der Datei ankommen w√ºrden, an einer beliebigen Stelle eingef√ºgt. <br><br>  Das ist √ºbrigens eine merkw√ºrdige Tatsache.  Da der BRIN-Index keine Verweise auf Tabellenzeilen enth√§lt, sollte seine Verf√ºgbarkeit HOT-Aktualisierungen √ºberhaupt nicht behindern, dies ist jedoch der Fall. <br><br>  Daher ist BRIN haupts√§chlich f√ºr Tabellen mit gro√üen und sogar gro√üen Gr√∂√üen konzipiert, die entweder √ºberhaupt nicht oder nur geringf√ºgig aktualisiert werden.  Es wird jedoch perfekt mit dem Hinzuf√ºgen neuer Zeilen (am Ende der Tabelle) fertig.  Dies ist nicht √ºberraschend, da diese Zugriffsmethode im Hinblick auf Data Warehouses und analytische Berichte erstellt wurde. <br><br><h3>  Welche Gr√∂√üe eines Bereichs m√ºssen wir ausw√§hlen? </h3><br>  Wenn wir uns mit einer Terabyte-Tabelle befassen, besteht unser Hauptanliegen bei der Auswahl der Gr√∂√üe eines Bereichs wahrscheinlich darin, den BRIN-Index nicht zu gro√ü zu machen.  In unserer Situation k√∂nnen wir es uns jedoch leisten, Daten genauer zu analysieren. <br><br>  Dazu k√∂nnen wir eindeutige Werte einer Spalte ausw√§hlen und sehen, auf wie vielen Seiten sie auftreten.  Die Lokalisierung der Werte erh√∂ht die Erfolgschancen bei der Anwendung des BRIN-Index.  Dar√ºber hinaus gibt die gefundene Anzahl von Seiten die Gr√∂√üe eines Bereichs an.  Wenn der Wert jedoch √ºber alle Seiten "verteilt" ist, ist BRIN nutzlos. <br><br>  Nat√ºrlich sollten wir diese Technik verwenden, um die interne Struktur der Daten im Auge zu behalten.  Zum Beispiel macht es keinen Sinn, jedes Datum (genauer gesagt einen Zeitstempel, einschlie√ülich der Uhrzeit) als eindeutigen Wert zu betrachten - wir m√ºssen ihn auf Tage runden. <br><br>  Technisch kann diese Analyse durchgef√ºhrt werden, indem der Wert der ausgeblendeten Spalte "ctid" betrachtet wird, die den Zeiger auf eine Zeilenversion (TID) liefert: die Nummer der Seite und die Nummer der Zeile innerhalb der Seite.  Leider gibt es keine konventionelle Technik, um TID in seine zwei Komponenten zu zerlegen. Daher m√ºssen wir Typen durch die Textdarstellung gie√üen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> min(numblk), round(avg(numblk)) avg, max(numblk) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> count(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> (ctid::<span class="hljs-type"><span class="hljs-type">text</span></span>::<span class="hljs-type"><span class="hljs-type">point</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) numblk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> scheduled_time::<span class="hljs-type"><span class="hljs-type">date</span></span> ) t;</code> </pre><pre> <code class="plaintext hljs"> min | avg | max ------+------+------ 1192 | 1500 | 1796 (1 row)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname = <span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 528172 (1 row)</code> </pre><br>  Wir k√∂nnen sehen, dass jeder Tag ziemlich gleichm√§√üig auf die Seiten verteilt ist und die Tage leicht miteinander verwechselt sind (1500 &amp; mal 365 = 547500, was nur wenig gr√∂√üer ist als die Anzahl der Seiten in der Tabelle 528172).  Dies ist eigentlich "durch Konstruktion" sowieso klar. <br><br>  Wertvolle Informationen sind hier eine bestimmte Anzahl von Seiten.  Bei einer herk√∂mmlichen Bereichsgr√∂√üe von 128 Seiten werden pro Tag 9 bis 14 Bereiche ausgef√ºllt.  Dies scheint realistisch: Bei einer Abfrage f√ºr einen bestimmten Tag k√∂nnen wir einen Fehler von etwa 10% erwarten. <br><br>  Versuchen wir mal: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin(scheduled_time);</code> </pre><br>  Die Gr√∂√üe des Index betr√§gt nur 184 KB: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 184 kB (1 row)</code> </pre><br>  In diesem Fall ist es kaum sinnvoll, die Gr√∂√üe eines Bereichs auf Kosten des Genauigkeitsverlusts zu erh√∂hen.  Bei Bedarf k√∂nnen wir jedoch die Gr√∂√üe reduzieren, und die Genauigkeit nimmt im Gegenteil zu (zusammen mit der Gr√∂√üe des Index). <br><br>  Schauen wir uns nun die Zeitzonen an.  Auch hier k√∂nnen wir keinen Brute-Force-Ansatz verwenden.  Alle Werte sollten stattdessen durch die Anzahl der Tageszyklen geteilt werden, da die Verteilung innerhalb jedes Tages wiederholt wird.  Da es nur wenige Zeitzonen gibt, k√∂nnen wir au√üerdem die gesamte Verteilung betrachten: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> airport_utc_offset, count(<span class="hljs-keyword"><span class="hljs-keyword">distinct</span></span> (ctid::<span class="hljs-type"><span class="hljs-type">text</span></span>::<span class="hljs-type"><span class="hljs-type">point</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>])/<span class="hljs-number"><span class="hljs-number">365</span></span> numblk <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> airport_utc_offset <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> airport_utc_offset | numblk --------------------+-------- 12:00:00 | 6 06:00:00 | 8 02:00:00 | 10 11:00:00 | 13 08:00:00 | 28 09:00:00 | 29 10:00:00 | 40 04:00:00 | 47 07:00:00 | 110 05:00:00 | 231 03:00:00 | 932 (11 rows)</code> </pre><br>  Im Durchschnitt f√ºllen die Daten f√ºr jede Zeitzone 133 Seiten pro Tag, aber die Verteilung ist sehr ungleichm√§√üig: Petropawlowsk-Kamtschatskiy und Anadyr haben nur sechs Seiten, w√§hrend Moskau und seine Umgebung Hunderte davon ben√∂tigen.  Die Standardgr√∂√üe eines Bereichs ist hier nicht gut.  Stellen wir es zum Beispiel auf vier Seiten ein. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin(airport_utc_offset) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (pages_per_range=<span class="hljs-number"><span class="hljs-number">4</span></span>); demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_airport_utc_offset_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 6528 kB (1 row)</code> </pre><br><h2>  Ausf√ºhrungsplan </h2><br>  Schauen wir uns an, wie unsere Indizes funktionieren.  W√§hlen wir einen Tag aus, beispielsweise vor einer Woche (in der Demo-Datenbank wird "heute" durch die Funktion "booking.now" bestimmt): <br><br><pre> <code class="pgsql hljs">demo=# \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d <span class="hljs-string"><span class="hljs-string">'bookings.now()::date - interval \'</span></span><span class="hljs-number"><span class="hljs-number">7</span></span> days\<span class="hljs-string"><span class="hljs-string">''</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=10.282..94.328 rows=83954 loops=1) Recheck Cond: ... Rows Removed by Index Recheck: 12045 Heap Blocks: lossy=1664 -&gt; Bitmap Index Scan on flights_bi_scheduled_time_idx (actual time=3.013..3.013 rows=16640 loops=1) Index Cond: ... Planning time: 0.375 ms Execution time: 97.805 ms</code> </pre><br>  Wie wir sehen k√∂nnen, hat der Planer den erstellten Index verwendet.  Wie genau ist es?  Das Verh√§ltnis der Anzahl der Zeilen, die die Abfragebedingungen erf√ºllen ("Zeilen" des Bitmap-Heap-Scan-Knotens), zur Gesamtzahl der Zeilen, die mit dem Index zur√ºckgegeben wurden (der gleiche Wert plus durch Index√ºberpr√ºfung entfernte Zeilen), gibt Auskunft dar√ºber.  In diesem Fall 83954 / (83954 + 12045), was erwartungsgem√§√ü ungef√§hr 90% entspricht (dieser Wert √§ndert sich von einem Tag zum anderen). <br><br>  Woher stammt die 16640-Nummer in "tats√§chlichen Zeilen" des Bitmap-Index-Scan-Knotens?  Die Sache ist, dass dieser Knoten des Plans eine ungenaue (Seite f√ºr Seite) Bitmap erstellt und nicht wei√ü, wie viele Zeilen die Bitmap ber√ºhren wird, w√§hrend etwas angezeigt werden muss.  In der Verzweiflung wird daher angenommen, dass eine Seite 10 Zeilen enth√§lt.  Die Bitmap enth√§lt insgesamt 1664 Seiten (dieser Wert wird in "Heap Blocks: lossy = 1664" angezeigt).  Wir bekommen also nur 16640. Insgesamt ist dies eine sinnlose Zahl, auf die wir nicht achten sollten. <br><br>  Wie w√§re es mit Flugh√§fen?  Nehmen wir zum Beispiel die Zeitzone von Wladiwostok, die 28 Seiten pro Tag umfasst: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> airport_utc_offset = <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'8 hours'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=75.151..192.210 rows=587353 loops=1) Recheck Cond: (airport_utc_offset = '08:00:00'::interval) Rows Removed by Index Recheck: 191318 Heap Blocks: lossy=13380 -&gt; Bitmap Index Scan on flights_bi_airport_utc_offset_idx (actual time=74.999..74.999 rows=133800 loops=1) Index Cond: (airport_utc_offset = '08:00:00'::interval) Planning time: 0.168 ms Execution time: 212.278 ms</code> </pre><br>  Der Planer verwendet erneut den erstellten BRIN-Index.  Die Genauigkeit ist schlechter (in diesem Fall etwa 75%), dies wird jedoch erwartet, da die Korrelation geringer ist. <br><br>  Auf BRMap-Ebene k√∂nnen sicherlich mehrere BRIN-Indizes (genau wie alle anderen) verkn√ºpft werden.  Das Folgende sind beispielsweise die Daten in der ausgew√§hlten Zeitzone f√ºr einen Monat (Hinweis "BitmapAnd" -Knoten): <br><br><pre> <code class="pgsql hljs">demo=# \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> d <span class="hljs-string"><span class="hljs-string">'bookings.now()::date - interval \'</span></span><span class="hljs-number"><span class="hljs-number">60</span></span> days\<span class="hljs-string"><span class="hljs-string">''</span></span> demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'30 days'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> airport_utc_offset = <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'8 hours'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=62.046..113.849 rows=48154 loops=1) Recheck Cond: ... Rows Removed by Index Recheck: 18856 Heap Blocks: lossy=1152 -&gt; BitmapAnd (actual time=61.777..61.777 rows=0 loops=1) -&gt; Bitmap Index Scan on flights_bi_scheduled_time_idx (actual time=5.490..5.490 rows=435200 loops=1) Index Cond: ... -&gt; Bitmap Index Scan on flights_bi_airport_utc_offset_idx (actual time=55.068..55.068 rows=133800 loops=1) Index Cond: ... Planning time: 0.408 ms Execution time: 115.475 ms</code> </pre><br><h3>  Vergleich mit B-Baum </h3><br>  Was ist, wenn wir einen regul√§ren B-Tree-Index f√ºr dasselbe Feld wie BRIN erstellen? <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> flights_bi_scheduled_time_btree <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi(scheduled_time); demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_btree'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 654 MB (1 row)</code> </pre><br>  Es schien <em>mehrere tausend Mal gr√∂√üer zu sein</em> als unser BRIN!  Die Abfrage wird jedoch etwas schneller ausgef√ºhrt: Der Planer verwendete Statistiken, um herauszufinden, dass die Daten physisch geordnet sind und keine Bitmap erstellt werden muss und dass die Indexbedingung haupts√§chlich nicht erneut √ºberpr√ºft werden muss: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduled_time &gt;= :d <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> scheduled_time &lt; :d + <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------- Index Scan using flights_bi_scheduled_time_btree on flights_bi (actual time=0.099..79.416 rows=83954 loops=1) Index Cond: ... Planning time: 0.500 ms Execution time: 85.044 ms</code> </pre><br>  Das ist das Wunderbare an BRIN: Wir opfern die Effizienz, gewinnen aber sehr viel Platz. <br><br><h2>  Operatorklassen </h2><br><h3>  minmax </h3><br>  Bei Datentypen, deren Werte miteinander verglichen werden k√∂nnen, bestehen die zusammenfassenden Informationen aus <em>den Minimal- und Maximalwerten</em> .  Die Namen der entsprechenden Operatorklassen enthalten "minmax", z. B. "date_minmax_ops".  Tats√§chlich sind dies Datentypen, die wir bisher in Betracht gezogen haben, und die meisten Typen sind von dieser Art. <br><br><h3>  inklusive </h3><br>  Vergleichsoperatoren sind nicht f√ºr alle Datentypen definiert.  Beispielsweise sind sie nicht f√ºr Punkte ("Punkt" -Typ) definiert, die die geografischen Koordinaten von Flugh√§fen darstellen.  Aus diesem Grund zeigen die Statistiken √ºbrigens nicht die Korrelation f√ºr diese Spalte. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename=<span class="hljs-string"><span class="hljs-string">'flights_bi'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> attname = <span class="hljs-string"><span class="hljs-string">'airport_coord'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------------+------------- airport_coord | (1 row)</code> </pre><br>  Viele solcher Typen erm√∂glichen es uns jedoch, ein Konzept eines "Begrenzungsbereichs" einzuf√ºhren, beispielsweise ein Begrenzungsrechteck f√ºr geometrische Formen.  Wir haben ausf√ºhrlich besprochen, wie der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GiST-</a> Index diese Funktion verwendet.  In √§hnlicher Weise erm√∂glicht BRIN auch das Sammeln von Zusammenfassungsinformationen zu Spalten mit Datentypen wie diesen: <em>Der Begrenzungsbereich f√ºr alle Werte innerhalb eines Bereichs</em> ist nur der Zusammenfassungswert. <br><br>  Im Gegensatz zu GiST muss der Zusammenfassungswert f√ºr BRIN vom gleichen Typ sein wie die zu indizierenden Werte.  Daher k√∂nnen wir den Index f√ºr Punkte nicht erstellen, obwohl klar ist, dass die Koordinaten in BRIN funktionieren k√∂nnten: Der L√§ngengrad ist eng mit der Zeitzone verbunden.  Gl√ºcklicherweise behindert nichts die Erstellung des Index f√ºr einen Ausdruck, nachdem Punkte in entartete Rechtecke umgewandelt wurden.  Gleichzeitig setzen wir die Gr√∂√üe eines Bereichs auf eine Seite, um den Grenzfall anzuzeigen: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> brin (box(airport_coord)) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (pages_per_range=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Die Gr√∂√üe des Index betr√§gt selbst in solch extremen Situationen nur 30 MB: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string"><span class="hljs-string">'flights_bi_box_idx'</span></span>));</code> </pre><pre> <code class="plaintext hljs"> pg_size_pretty ---------------- 30 MB (1 row)</code> </pre><br>  Jetzt k√∂nnen wir Anfragen stellen, die die Flugh√§fen durch Koordinaten einschr√§nken.  Zum Beispiel: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> airport_code, airport_name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> airports <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(coordinates) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> airport_code | airport_name --------------+----------------- KHV | Khabarovsk-Novyi VVO | Vladivostok (2 rows)</code> </pre><br>  Der Planer wird sich jedoch weigern, unseren Index zu verwenden. <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> flights_bi; demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------- Seq Scan on flights_bi (cost=0.00..985928.14 rows=30517 width=111) Filter: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box)</code> </pre><br>  Warum?  Deaktivieren wir den sequentiellen Scan und sehen, was passiert: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (cost=14079.67..1000007.81 rows=30517 width=111) Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) -&gt; Bitmap Index Scan on flights_bi_box_idx (cost=0.00..14072.04 rows=30517076 width=0) Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box)</code> </pre><br>  Es scheint, dass der Index <em>verwendet werden</em> kann, aber der Planer geht davon aus, dass die Bitmap auf der gesamten Tabelle erstellt werden muss (siehe "Zeilen" des Bitmap-Index-Scan-Knotens), und es ist kein Wunder, dass der Planer den sequentiellen Scan-In ausw√§hlt dieser Fall.  Das Problem hierbei ist, dass PostgreSQL f√ºr geometrische Typen keine Statistiken sammelt und der Planer blind vorgehen muss: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'flights_bi_box_idx'</span></span> \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------+------------------- schemaname | bookings tablename | flights_bi_box_idx attname | box inherited | f null_frac | 0 avg_width | 32 n_distinct | 0 most_common_vals | most_common_freqs | histogram_bounds | correlation | most_common_elems | most_common_elem_freqs | elem_count_histogram |</code> </pre><br>  Leider.  Es gibt jedoch keine Beschwerden √ºber den Index - er funktioniert und funktioniert einwandfrei: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flights_bi <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> box(airport_coord) &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'120,40,140,50'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Bitmap Heap Scan on flights_bi (actual time=158.142..315.445 rows=781790 loops=1) Recheck Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) Rows Removed by Index Recheck: 70726 Heap Blocks: lossy=14772 -&gt; Bitmap Index Scan on flights_bi_box_idx (actual time=158.083..158.083 rows=147720 loops=1) Index Cond: (box(airport_coord) &lt;@ '(140,50),(120,40)'::box) Planning time: 0.137 ms Execution time: 340.593 ms</code> </pre><br>  Die Schlussfolgerung muss folgenderma√üen lauten: PostGIS wird ben√∂tigt, wenn f√ºr die Geometrie etwas nicht Triviales erforderlich ist.  Es kann sowieso Statistiken sammeln. <br><br><h2>  Interna </h2><br>  Die konventionelle Erweiterung "pageinspect" erm√∂glicht es uns, in den BRIN-Index zu schauen. <br><br>  Zun√§chst werden wir anhand der Metainformation √ºber die Gr√∂√üe eines Bereichs und die Anzahl der f√ºr "revmap" zugewiesenen Seiten informiert: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_metapage_info(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> magic | version | pagesperrange | lastrevmappage ------------+---------+---------------+---------------- 0xA8109CFA | 1 | 128 | 3 (1 row)</code> </pre><br>  Die Seiten 1-3 sind hier f√ºr "revmap" reserviert, w√§hrend der Rest zusammenfassende Daten enth√§lt.  Aus "revmap" k√∂nnen wir Verweise auf Zusammenfassungsdaten f√ºr jeden Bereich erhalten.  Angenommen, die Informationen zum ersten Bereich, der die ersten 128 Seiten umfasst, befinden sich hier: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_revmap_data(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pages --------- (6,197) (1 row)</code> </pre><br>  Und das sind die zusammenfassenden Daten selbst: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> allnulls, hasnulls, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_page_items( get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> itemoffset = <span class="hljs-number"><span class="hljs-number">197</span></span>;</code> </pre><pre> <code class="plaintext hljs"> allnulls | hasnulls | value ----------+----------+---------------------------------------------------- f | f | {2016-08-15 02:45:00+03 .. 2016-08-15 17:15:00+03} (1 row)</code> </pre><br>  N√§chster Bereich: <br><br><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_revmap_data(get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pages --------- (6,198) (1 row)</code> </pre><pre> <code class="pgsql hljs">demo=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> allnulls, hasnulls, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> brin_page_items( get_raw_page(<span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'flights_bi_scheduled_time_idx'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> itemoffset = <span class="hljs-number"><span class="hljs-number">198</span></span>;</code> </pre><pre> <code class="plaintext hljs"> allnulls | hasnulls | value ----------+----------+---------------------------------------------------- f | f | {2016-08-15 06:00:00+03 .. 2016-08-15 18:55:00+03} (1 row)</code> </pre><br>  Und so weiter. <br><br>  Bei "Einschluss" -Klassen wird im Feld "Wert" so etwas wie angezeigt <br><br><pre> <code class="plaintext hljs"> {(94.4005966186523,69.3110961914062),(77.6600036621,51.6693992614746) .. f .. f}</code> </pre><br>  Der erste Wert ist das Einbettungsrechteck, und "f" -Buchstaben am Ende bezeichnen fehlende leere Elemente (das erste) und fehlende nicht zusammenf√ºhrbare Werte (das zweite).  Tats√§chlich sind die einzigen nicht zusammenlegbaren Werte die Adressen "IPv4" und "IPv6" (Datentyp "inet"). <br><br><h2>  Eigenschaften </h2><br>  Erinnert Sie an die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bereits gestellten</a> Fragen. <br><br>  Im Folgenden sind die Eigenschaften der Zugriffsmethode aufgef√ºhrt: <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- brin | can_order | f brin | can_unique | f brin | can_multi_col | t brin | can_exclude | f</code> </pre><br>  Indizes k√∂nnen f√ºr mehrere Spalten erstellt werden.  In diesem Fall werden f√ºr jede Spalte eigene Zusammenfassungsstatistiken erfasst, die jedoch f√ºr jeden Bereich zusammen gespeichert werden.  Dieser Index ist nat√ºrlich sinnvoll, wenn ein und dieselbe Gr√∂√üe eines Bereichs f√ºr alle Spalten geeignet ist. <br><br>  Die folgenden Indexschicht-Eigenschaften sind verf√ºgbar: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | f index_scan | f bitmap_scan | t backward_scan | f</code> </pre><br>  Offensichtlich wird nur der Bitmap-Scan unterst√ºtzt. <br><br>  Das Fehlen von Clustering kann jedoch verwirrend erscheinen.  Da der BRIN-Index empfindlich auf die physische Reihenfolge der Zeilen reagiert, w√§re es logisch, Daten gem√§√ü dem Index gruppieren zu k√∂nnen.  Das ist aber nicht so.  Wir k√∂nnen nur einen ‚Äûregul√§ren‚Äú Index (B-Tree oder GiST, je nach Datentyp) erstellen und entsprechend gruppieren.  M√∂chten Sie √ºbrigens eine vermeintlich gro√üe Tabelle unter Ber√ºcksichtigung der exklusiven Sperren, der Ausf√ºhrungszeit und des Speicherplatzverbrauchs beim Wiederherstellen gruppieren? <br><br>  Im Folgenden sind die Eigenschaften der Spaltenschicht aufgef√ºhrt: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f distance_orderable | f returnable | f search_array | f search_nulls | t</code> </pre><br>  Die einzige verf√ºgbare Eigenschaft ist die M√∂glichkeit, NULL-Werte zu bearbeiten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lesen Sie weiter</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452900/">https://habr.com/ru/post/de452900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452886/index.html">Wiki-Projekte und Noosphere-Name auf HACKNOWLEGE</a></li>
<li><a href="../de452888/index.html">In der N√§he von M√ºnchen begann der Test des f√ºnfsitzigen Tiltrotors Lilium Jet in Originalgr√∂√üe</a></li>
<li><a href="../de452890/index.html">23. Mai, 18.30 Uhr - Live-√úbertragung von QIWI Kitchen</a></li>
<li><a href="../de452892/index.html">Wie kann ein Nicht-Programmierer in die USA ziehen: Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de452894/index.html">Face Anti-Spoofing oder technologisch einen Betr√ºger von tausend Gesichtern erkennen</a></li>
<li><a href="../de452902/index.html">Nach 4 Jahren Ausbildung zum Programmierer verstehe ich, dass ich weit von einem Programmierer entfernt bin</a></li>
<li><a href="../de452904/index.html">Wie Maschinen kommunizieren - MQTT-Protokoll</a></li>
<li><a href="../de452906/index.html">JavaScript-Engines: Wie funktionieren sie? Vom Call-Stack bis zu den Versprechungen (fast) alles, was Sie wissen m√ºssen</a></li>
<li><a href="../de452908/index.html">Selenium WebDriver - Echtzeit-Testmetrik mit Grafana und InfluxDB</a></li>
<li><a href="../de452910/index.html">Hallo Habr! Hallo Tercon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>