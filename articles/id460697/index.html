<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóùÔ∏è üéµ ü§æüèø Font sekecil mungkin üóÑÔ∏è ü§Ø üèπ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tugas: menggunakan sumber daya sekecil mungkin, render teks yang bermakna. 


- Seberapa kecil font yang bisa dibaca? 
- Berapa banyak memori yang dib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Font sekecil mungkin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460697/"><p>  Tugas: menggunakan sumber daya sekecil mungkin, render teks yang bermakna. </p><br><ul><li>  Seberapa kecil font yang bisa dibaca? </li><li> Berapa banyak memori yang dibutuhkan untuk menyimpannya? </li><li>  Berapa banyak kode yang diperlukan untuk menggunakannya? </li></ul><br><p>  Mari kita lihat apa yang kita dapatkan.  Spoiler </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><a name="habracut"></a><br><h2 id="vvedenie-v-bitmepy">  Pengantar Bitmap </h2><br><p> Komputer menghadirkan bitmap sebagai bitmap.  Ini bukan tentang format <code>.bmp</code> , tetapi tentang cara untuk menyimpan piksel dalam memori.  Untuk memahami apa yang terjadi, kita perlu belajar sesuatu tentang cara ini. </p><br><h3 id="sloi">  Layers </h3><br><p>  Suatu gambar biasanya berisi beberapa <em>lapisan</em> di atas satu sama lain.  Paling sering mereka sesuai dengan koordinat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ruang warna RGB</a> .  Satu lapisan untuk <em>merah</em> , satu untuk <em>hijau</em> dan satu untuk <em>biru</em> .  Jika format gambar mendukung transparansi, maka lapisan keempat dibuat untuk itu, biasanya disebut <em>alpha</em> .  Secara kasar, gambar berwarna adalah tiga (atau empat, jika ada saluran alfa) hitam dan putih, terletak satu di atas yang lain. </p><br><ul><li>  RGB bukan satu-satunya ruang warna;  Format JPEG, misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YUV</a> .  Tetapi dalam artikel ini kita tidak perlu sisa ruang warna, jadi kita tidak mempertimbangkannya. </li></ul><br><p>  Seperangkat lapisan dapat direpresentasikan dalam memori dengan dua cara.  Entah mereka disimpan secara terpisah, atau nilai-nilai dari lapisan yang berbeda disisipkan.  Dalam kasus terakhir, layer disebut <em>saluran</em> , dan itulah cara sebagian besar format modern bekerja. </p><br><p>  Misalkan kita memiliki gambar 4x4 yang mengandung tiga lapisan: <em>R</em> untuk merah, <em>G</em> untuk hijau dan <em>B</em> untuk komponen biru dari masing-masing piksel.  Itu bisa direpresentasikan seperti ini: </p><br><pre> <code class="plaintext hljs"> RRRR RRRR RRRR RRRR GGGG GGGG GGGG GGGG BBBB BBBB BBBB BBBB</code> </pre> <br><p>  Ketiga lapisan disimpan secara terpisah.  Format bolak-balik terlihat berbeda: </p><br><pre> <code class="plaintext hljs"> RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><ul><li>  setiap tiga karakter sesuai dengan <strong>tepat</strong> satu piksel </li><li>  nilai dalam triple berada dalam urutan <em>RGB</em> .  Kadang-kadang urutan yang berbeda dapat digunakan (misalnya, <em>BGR</em> ), tetapi yang ini adalah yang paling umum. </li></ul><br><p>  Untuk kesederhanaan, saya mengatur piksel dalam bentuk matriks dua dimensi, karena lebih jelas di mana triple ini atau itu ada dalam gambar.  Namun pada kenyataannya, memori komputer bukan dua dimensi, tetapi satu dimensi, sehingga gambar 4x4 akan disimpan seperti ini: </p><br><pre> <code class="plaintext hljs">RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB RGB</code> </pre> <br><h3 id="bpp">  bpp </h3><br><p>  Singkatan <em>bpp</em> mengacu pada jumlah bit atau byte per piksel (bit / byte per piksel).  Anda mungkin melihat <code>24bpp</code> atau <code>3bpp</code> .  Kedua karakteristik ini memiliki arti yang sama - <strong>24 <em>bit</em> per piksel</strong> atau <strong>3 <em>byte</em> per piksel</strong> .  Karena selalu ada 8 bit dalam satu byte, Anda dapat menebak dengan nilai unit mana yang dimaksud. </p><br><h3 id="predstavlenie-v-pamyati">  Representasi memori </h3><br><p>  <code>24bpp</code> , alias <code>3bpp</code> - format yang paling umum untuk menyimpan bunga.  Ini adalah bagaimana <strong>satu piksel</strong> dalam urutan <em>RGB</em> terlihat pada tingkat bit individual. </p><br><pre> <code class="plaintext hljs"> 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  RRRRRRRRGGGGGGGGBBBBB BBB</code> </pre> <br><ul><li>  Satu byte untuk <em>R</em> , satu untuk <em>G</em> dan satu untuk <em>B</em> , totalnya tiga byte. </li><li>  Masing-masing berisi nilai dari 0 hingga 255. </li></ul><br><p>  Jadi jika piksel yang diberikan memiliki warna berikut: </p><br><ul><li> <code>R 255</code> </li> <li> <code>G 80</code> </li> <li> <code>B 100</code> </li> </ul><br><p>  Kemudian <code>255</code> disimpan di byte pertama, <code>80</code> di byte kedua, dan <code>100</code> di byte ketiga. </p><br><p>  Paling sering, nilai-nilai ini direpresentasikan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">heksadesimal</a> .  Katakan <code>#ff5064</code> .  Ini jauh lebih nyaman dan kompak: <code>R = 0xff</code> (mis. <code>R=255</code> dalam desimal), <code>G = 0x50</code> (= <code>G=80</code> ), <code>B=0x64</code> (= <code>B=100</code> ). </p><br><ul><li>  Representasi heksadesimal memiliki satu properti yang bermanfaat.  Karena setiap byte warna diwakili oleh dua karakter, masing-masing karakter mengkodekan <strong>tepat</strong> setengah byte, atau empat bit.  4 bit, omong-omong, disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nibble</a> . </li></ul><br><h3 id="shirina-stroki">  Lebar garis </h3><br><p>  Ketika piksel berjalan satu demi satu dan masing-masing berisi lebih dari satu saluran, datanya mudah bingung.  Tidak diketahui kapan satu baris berakhir dan selanjutnya dimulai, oleh karena itu, untuk menafsirkan file dengan bitmap, Anda perlu mengetahui ukuran gambar dan <em>bpp</em> .  Dalam kasus kami, gambar memiliki lebar <code>w = 4</code> piksel dan masing-masing piksel ini mengandung 3 byte, sehingga string dikodekan dengan 12 (dalam kasus umum <code>w*bpp</code> ) byte. </p><br><ul><li>  Sebuah string tidak selalu dikodekan dengan byte <code>w*bpp</code> ;  Seringkali, piksel "tersembunyi" ditambahkan ke dalamnya untuk membawa lebar gambar ke beberapa ukuran.  Misalnya, penskalaan gambar lebih cepat dan lebih nyaman ketika ukurannya dalam piksel sama dengan kekuatan dua.  Oleh karena itu, file tersebut mungkin berisi (dapat diakses oleh pengguna) gambar 120x120 piksel, tetapi disimpan sebagai gambar 128x128.  Saat gambar ditampilkan di layar, piksel ini diabaikan.  Namun, kita tidak perlu tahu tentang mereka. </li></ul><br><p>  Koordinat piksel apa pun <code>(x, y)</code> dalam representasi satu dimensi adalah <code>(y * w + x) * bpp</code> .  Ini, secara umum, jelas: <code>y</code> adalah nomor baris, setiap baris berisi <code>w</code> piksel, jadi <code>y * w</code> adalah awal dari baris yang diinginkan, dan <code>+x</code> membawa kita ke <code>x</code> diinginkan di dalamnya.  Dan karena koordinat tidak dalam byte, tetapi dalam piksel, semua ini dikalikan dengan ukuran piksel <code>bpp</code> , dalam hal ini dalam byte.  Karena piksel memiliki ukuran bukan nol, Anda perlu membaca byte <code>bpp</code> tepat, mulai dari koordinat yang diterima, dan kami akan memiliki representasi lengkap dari piksel yang diinginkan. </p><br><h2 id="atlas-shrifta">  Atlas font </h2><br><p>  Sebenarnya monitor yang ada tidak menampilkan piksel secara keseluruhan, tetapi tiga subpiksel - merah, biru dan hijau.  Jika Anda melihat monitor dalam pembesaran, Anda akan melihat sesuatu seperti ini: </p><br><p><img src="https://habrastorage.org/webt/w8/nb/c9/w8nbc98aixpbrxgvffsccmxelyk.png"></p><br><ul><li>  Gambar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> </li></ul><br><p>  Kami tertarik pada LCD, karena kemungkinan besar dari monitor itulah Anda membaca teks ini.  Tentu saja, ada jebakan: </p><br><ul><li>  Tidak semua matriks menggunakan urutan subpiksel ini, terkadang BGR. </li><li>  Jika Anda memutar monitor (misalnya, lihat telepon dalam orientasi mendatar), polanya juga akan berputar dan font akan berhenti bekerja. </li><li>  Orientasi matriks yang berbeda dan pengaturan subpiksel akan membutuhkan pengerjaan ulang font itu sendiri. </li><li>  Secara khusus, ini tidak berfungsi pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">layar AMOLED</a> yang menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tata letak PenTile</a> .  Tampilan seperti itu paling sering digunakan di perangkat seluler. </li></ul><br><p>  Menggunakan peretasan subpixel untuk meningkatkan resolusi disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">rendering subpixel</a> .  Anda dapat membaca tentang penggunaannya dalam tipografi, misalnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Untungnya bagi kami, Matt Sarnov sudah menemukan menggunakan rendering subpixel untuk membuat font <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">millitext</a> kecil.  Secara manual, ia menciptakan gambar kecil ini: </p><br><p><img src="https://habrastorage.org/webt/p7/jk/xe/p7jkxececbln6pxlatfoa9kyymq.png"></p><br><p>  Yang, jika Anda melihat monitor dengan sangat hati-hati, terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/8n/wz/fq/8nwzfqilnvn_jronmwqbfnodllg.png"></p><br><p>  Dan ini dia, secara pemrograman meningkat 12 kali: </p><br><p><img src="https://habrastorage.org/webt/fa/9p/us/fa9puspiilp5ip-50cuyxfyrdva.png"></p><br><p>  Berdasarkan karyanya, saya membuat atlas font di mana setiap karakter sesuai dengan kolom <code>1x5</code> piksel.  Urutan karakter adalah sebagai berikut: </p><br><pre> <code class="plaintext hljs">0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> </pre> <br><p><img src="https://habrastorage.org/webt/qe/ip/_v/qeip_vlwmjwfnnbbuz9cq6rhfn4.png"></p><br><p>  Atlas yang sama meningkat 12 kali: </p><br><p><img src="https://habrastorage.org/webt/m3/ds/eg/m3dseggtbsmpgnmvlekvlz2aqow.png"></p><br><p>  Dengan 36 karakter yang digunakan, tepatnya <code>365</code> piksel <code>365</code> .  Jika kita mengasumsikan bahwa setiap piksel menempati 3 byte, maka kita membutuhkan <code>36*5*3 = 540</code> byte untuk menyimpan seluruh gambar (kira-kira <em>.: Dalam aslinya, serangkaian suntingan yang membingungkan tentang saluran alfa, menghapus metadata, dll.). n. Dalam terjemahan, saya menghapusnya dan hanya menggunakan versi final file</em> ).  File PNG yang melewati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pngcrush</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optipng</a> membutuhkan waktu lebih sedikit: </p><br><pre> <code class="plaintext hljs"># wc -c &lt; font-crushed.png 390</code> </pre> <br><p>  Tetapi Anda dapat mencapai ukuran yang lebih kecil jika Anda menggunakan pendekatan yang sedikit berbeda </p><br><h1 id="szhatie">  Kompresi </h1><br><p>  Pembaca yang penuh perhatian dapat memperhatikan bahwa atlas hanya menggunakan 7 warna: </p><br><ol><li> <code>#ffffff</code> </li> <li> <code>#ff0000</code> </li> <li> <code>#00ff00</code> </li> <li> <code>#0000ff</code> </li> <li> <code>#00ffff</code> </li> <li> <code>#ff00ff</code> </li> <li> <code>#ffff00</code> </li> </ol><br><h2 id="palitra">  Palet </h2><br><p>  Dalam situasi seperti itu, seringkali lebih mudah untuk membuat palet.  Kemudian untuk setiap piksel Anda dapat menyimpan bukan tiga byte warna, tetapi hanya nomor warna dalam palet.  Dalam kasus kami, 3 bit ( <code>7 &lt; 2^3</code> ) akan cukup untuk dipilih dari 7 warna.  Jika kita menetapkan nilai tiga bit untuk setiap piksel, maka seluruh atlas akan muat dalam <em>68 byte</em> . </p><br><ul><li>  Pembaca, berpengalaman dalam kompresi data, dapat menjawab bahwa secara umum ada hal seperti "bit fraksional" dan dalam kasus kami <strong>2,875 bit per piksel sudah</strong> cukup.  Kepadatan ini dapat dicapai dengan menggunakan ilmu hitam, yang dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode aritmatika</a> .  Kami tidak akan melakukan ini, karena pengkodean aritmatika adalah hal yang rumit, dan 68 byte sudah sedikit. </li></ul><br><h2 id="vyravnivanie">  Perataan </h2><br><p>  Pengkodean tiga bit memiliki satu kelemahan serius.  Pixel tidak dapat didistribusikan secara merata melintasi 8-bit byte, yang penting karena byte adalah area memori terkecil yang dapat dialamatkan.  Katakanlah kita ingin menyimpan tiga piksel: </p><br><pre> <code class="plaintext hljs">ABC</code> </pre> <br><p>  Jika masing-masing membutuhkan 3 bit, maka akan dibutuhkan 2 byte untuk menyimpannya ( <code>-</code> menunjukkan bit yang tidak digunakan): </p><br><pre> <code class="plaintext hljs">bit 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pixel AAABBBCCC - - - - - - -</code> </pre> <br><p>  Yang penting, pixel <strong>C</strong> tidak hanya meninggalkan banyak ruang kosong;  itu <em>terbelah</em> antara dua byte.  Ketika kami mulai menambahkan piksel berikut, piksel dapat diposisikan secara sewenang-wenang relatif terhadap batas byte.  Solusi paling sederhana adalah dengan menggunakan nibble per pixel, karena 8 dibagi dengan sempurna oleh 4 dan memungkinkan Anda untuk menempatkan tepat dua pixel di setiap byte.  Tetapi ini akan meningkatkan ukuran atlas sebesar sepertiga, dari <strong>68 byte</strong> menjadi <strong>90 byte</strong> . </p><br><ul><li>  Bahkan, file dapat dibuat lebih kecil lagi menggunakan palindrome coding, interval coding, dan teknik kompresi lainnya.  Seperti pengkodean aritmatika, kami menunda teknik ini hingga artikel selanjutnya. </li></ul><br><h2 id="bitovyy-bufer">  Buffer bit </h2><br><p>  Untungnya, pada dasarnya tidak ada yang mustahil dalam bekerja dengan nilai 3-bit.  Anda hanya perlu memantau posisi di dalam byte yang sedang kita tulis atau baca saat ini.  Kelas sederhana berikut mengubah aliran data 3-bit menjadi array byte. </p><br><ul><li>  Untuk alasan keterbacaan, kode ini ditulis dalam JS, tetapi metode yang sama digeneralisasikan ke bahasa lain. </li><li>  Pesanan bekas dari byte rendah ke tinggi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Little Endian</a> ) </li></ul><br><pre> <code class="plaintext hljs">class BitBuffer { constructor(bytes) { this.data = new Uint8Array(bytes); this.offset = 0; } write(value) { for (let i = 0; i &lt; 3; ) { // bits remaining const remaining = 3 - i; // bit offset in the byte ie remainder of dividing by 8 const bit_offset = this.offset &amp; 7; // byte offset for a given bit offset, ie divide by 8 const byte_offset = this.offset &gt;&gt; 3; // max number of bits we can write to the current byte const wrote = Math.min(remaining, 8 - bit_offset); // mask with the correct bit-width const mask = ~(0xff &lt;&lt; wrote); // shift the bits we want to the start of the byte and mask off the rest const write_bits = value &amp; mask; // destination mask to zero all the bits we're changing first const dest_mask = ~(mask &lt;&lt; bit_offset); value &gt;&gt;= wrote; // write it this.data[byte_offset] = (this.data[byte_offset] &amp; dest_mask) | (write_bits &lt;&lt; bit_offset); // advance this.offset += wrote; i += wrote; } } to_string() { return Array.from(this.data, (byte) =&gt; ('0' + (byte &amp; 0xff).toString(16)).slice(-2)).join(''); } };</code> </pre> <br><p>  Mari mengunduh dan menyandikan file atlas: </p><br><pre> <code class="plaintext hljs">const PNG = require('png-js'); const fs = require('fs'); // this is our palette of colors const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // given a color represented as [R, G, B], find the index in palette where that color is function find_palette_index(color) { const [sR, sG, sB] = color; for (let i = 0; i &lt; Palette.length; i++) { const [aR, aG, aB] = Palette[i]; if (sR === aR &amp;&amp; sG === aG &amp;&amp; sB === aB) { return i; } } return -1; } // build the bit buffer representation function build(cb) { const data = fs.readFileSync('subpixels.png'); const image = new PNG(data); image.decode(function(pixels) { // we need 3 bits per pixel, so w*h*3 gives us the # of bits for our buffer // however BitBuffer can only allocate bytes, dividing this by 8 (bits for a byte) // gives us the # of bytes, but that division can result in 67.5 ... Math.ceil // just rounds up to 68. this will give the right amount of storage for any // size atlas. let result = new BitBuffer(Math.ceil((image.width * image.height * 3) / 8)); for (let y = 0; y &lt; image.height; y++) { for (let x = 0; x &lt; image.width; x++) { // 1D index as described above const index = (y * image.width + x) * 4; // extract the RGB pixel value, ignore A (alpha) const color = Array.from(pixels.slice(index, index + 3)); // write out 3-bit palette index to the bit buffer result.write(find_palette_index(color)); } } cb(result); }); } build((result) =&gt; console.log(result.to_string()));</code> </pre> <br><p>  Seperti yang diharapkan, atlas cocok dengan <strong>68 byte</strong> , yang 6 kali lebih kecil dari file PNG. </p><br><p>  ( <em>catatan per .: penulis agak tidak jujur: ia tidak menyimpan palet dan ukuran gambar, yang, menurut perkiraan saya, akan membutuhkan 23 byte dengan ukuran palet tetap dan meningkatkan ukuran gambar menjadi 91 byte</em> ) </p><br><p>  Sekarang mari kita konversi gambar ke string sehingga Anda dapat menempelkannya ke kode sumber.  Intinya, metode <code>to_string</code> ini: ia merepresentasikan konten setiap byte sebagai angka heksadesimal. </p><br><pre> <code class="plaintext hljs">305000000c0328d6d4b24cb46d516d4ddab669926a0ddab651db76150060009c0285 e6a0752db59054655bd7b569d26a4ddba053892a003060400d232850b40a6b61ad00</code> </pre> <br><p>  Tetapi string yang dihasilkan masih cukup panjang, karena kami membatasi diri pada alfabet 16 karakter.  Anda dapat menggantinya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">base64</a> , yang karakternya empat kali lebih banyak. </p><br><pre> <code class="plaintext hljs">to_string() { return Buffer.from(this.data).toString('base64'); }</code> </pre> <br><p>  Di base64, atlasnya terlihat seperti ini: </p><br><pre> <code class="plaintext hljs">MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=</code> </pre> <br><p>  Baris ini dapat dikodekan ke modul JS dan digunakan untuk meraster teks. </p><br><h1 id="rasterizaciya">  Rasterisasi </h1><br><p>  Untuk menghemat memori, hanya satu huruf yang akan diterjemahkan secara bersamaan. </p><br><pre> <code class="plaintext hljs">const Alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const Atlas = Uint8Array.from(Buffer.from('MFAAAAwDKNbUsky0bVFtTdq2aZJqDdq2Udt2FQBgAJwCheagdS21kFRlW9e1adJqTdugU4kqADBgQA0jKFC0CmthrQA=', 'base64')); const Palette = [ [0xff, 0xff, 0xff], [0xff, 0x00, 0x00], [0x00, 0xff, 0x00], [0x00, 0x00, 0xff], [0x00, 0xff, 0xff], [0xff, 0x00, 0xff], [0xff, 0xff, 0x00] ]; // at the given bit offset |offset| read a 3-bit value from the Atlas read = (offset) =&gt; { let value = 0; for (let i = 0; i &lt; 3; ) { const bit_offset = offset &amp; 7; const read = Math.min(3 - i, 8 - bit_offset); const read_bits = (Atlas[offset &gt;&gt; 3] &gt;&gt; bit_offset) &amp; (~(0xff &lt;&lt; read)); value |= read_bits &lt;&lt; i; offset += read; i += read; } return value; }; // for a given glyph |g| unpack the palette indices for the 5 vertical pixels unpack = (g) =&gt; { return (new Uint8Array(5)).map((_, i) =&gt; read(Alphabet.length*3*i + Alphabet.indexOf(g)*3)); }; // for given glyph |g| decode the 1x5 vertical RGB strip decode = (g) =&gt; { const rgb = new Uint8Array(5*3); unpack(g).forEach((value, index) =&gt; rgb.set(Palette[value], index*3)); return rgb; }</code> </pre> <br><p>  Fungsi <code>decode</code> mengambil karakter sebagai input dan mengembalikan kolom yang sesuai di gambar sumber.  Yang mengesankan di sini adalah bahwa hanya dibutuhkan <strong>5 byte</strong> memori untuk mendekodekan satu karakter, ditambah <strong>~ 1.875</strong> byte untuk membaca bagian array yang diinginkan, mis.  rata-rata <strong>6,875</strong> per surat.  Jika Anda menambahkan <strong>68 byte</strong> untuk menyimpan array dan <strong>36 byte</strong> untuk menyimpan alfabet, ternyata <em>secara teoritis</em> Anda dapat merender teks dengan 128 byte RAM. </p><br><ul><li>  Ini dimungkinkan jika Anda menulis ulang kode dalam C atau assembler.  Terhadap latar belakang overhead JS, ini adalah penghematan pada pertandingan. </li></ul><br><p>  Tinggal mengumpulkan kolom-kolom ini menjadi satu kesatuan dan mengembalikan gambar dengan teks. </p><br><pre> <code class="plaintext hljs">print = (t) =&gt; { const c = t.toUpperCase().replace(/[^\w\d ]/g, ''); const w = c.length * 2 - 1, h = 5, bpp = 3; // * 2 for whitespace const b = new Uint8Array(w * h * bpp); [...c].forEach((g, i) =&gt; { if (g !== ' ') for (let y = 0; y &lt; h; y++) { // copy each 1x1 pixel row to the the bitmap b.set(decode(g).slice(y * bpp, y * bpp + bpp), (y * w + i * 2) * bpp); } }); return {w: w, h: h, data: b}; };</code> </pre> <br><p>  Ini akan menjadi font sekecil mungkin. </p><br><pre> <code class="plaintext hljs">const fs = require('fs'); const result = print("Breaking the physical limits of fonts"); fs.writeFileSync(`${result.w}x${result.h}.bin`, result.data);</code> </pre> <br><p>  Tambahkan sedikit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">imagemagick</a> untuk mendapatkan gambar dalam format yang dapat dibaca: </p><br><pre> <code class="plaintext hljs"># convert -size 73x5 -depth 8 rgb:73x5.bin done.png</code> </pre> <br><p>  Dan inilah hasil akhirnya: </p><br><p><img src="https://habrastorage.org/webt/jv/lf/gs/jvlfgsoyr4xbnxsbzuzax3shp4s.png"></p><br><p>  Ini juga meningkat 12 kali: </p><br><p><img src="https://habrastorage.org/webt/6k/jr/6m/6kjr6md92hgpbm7gvs8ia3o1cti.png"></p><br><p>  Tembakan dari makro monitor yang tidak dikalibrasi: </p><br><p><img src="https://habrastorage.org/webt/pd/qp/li/pdqplibvzty8wtoxosah5d3phxe.png"></p><br><p>  Dan akhirnya, lebih baik di monitor: </p><br><p><img src="https://habrastorage.org/webt/ge/oz/rh/geozrhsclx2squmratxt8flet1a.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460697/">https://habr.com/ru/post/id460697/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460675/index.html">Ekstraksi Data Pembelajaran Mesin</a></li>
<li><a href="../id460683/index.html">Proyektor Acara Laravel dan Konsep Pembuatan Acara</a></li>
<li><a href="../id460685/index.html">Kami mendistribusikan file dari Google Drive menggunakan nginx</a></li>
<li><a href="../id460687/index.html">Bagaimana kaleng terlihat dari dalam</a></li>
<li><a href="../id460695/index.html">Apa itu DAA, dan bagaimana sistem ini membantu drone?</a></li>
<li><a href="../id460699/index.html">Habr Weekly # 10 / Layanan super dan paspor elektronik, ponsel cerdas dan Rusia, "gadget mata-mata", kehidupan tanpa satelit</a></li>
<li><a href="../id460701/index.html">Kursus "Mulai dalam Ilmu Data": langkah pertama dalam bekerja dengan data</a></li>
<li><a href="../id460703/index.html">Blue Ocean of Opportunity: Dari Nol hingga 400 Ribu Wawancara Video</a></li>
<li><a href="../id460707/index.html">Apakah sudah waktunya bagi pengembang game untuk berhenti mendengarkan penggemar mereka?</a></li>
<li><a href="../id460709/index.html">Refleksi tentang Agile</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>