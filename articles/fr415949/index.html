<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏻 🤚🏼 👨🏼‍🏫 Extraction élevée: la dernière option pour protéger la blockchain PoW d'une «attaque de 51%» 🌆 🤦🏿 🙏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les développeurs de la fourchette Litecoin Cash ont présenté une préimpression du document technique « The Hive: Agent-based Mining in Litecoin Cash »...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Extraction élevée: la dernière option pour protéger la blockchain PoW d'une «attaque de 51%»</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415949/"><img src="https://habrastorage.org/webt/d1/oo/5w/d1oo5wr_cgcroc3091uoyu1trbw.png" alt="image"><br><br>  Les développeurs de la fourchette Litecoin Cash ont présenté une préimpression du document technique « <i>The Hive: Agent-based Mining in Litecoin Cash</i> », dans lequel ils ont décrit leur proposition de protéger la blockchain de crypto-monnaie basée sur l'algorithme de preuve de travail contre une «attaque de 51%».  Leur solution combine l'exploitation minière en utilisant des dispositifs ASIC vieillissants (SHA-256) et l'exploitation minière virtuelle démocratique en utilisant des «abeilles actives» (HiveMine).  Dans le cas d'une mise en œuvre correcte de la blockchain, LCC résoudra l'un des plus gros problèmes des projets de blockchain modernes (de Bitcoin à Ethereum): la menace d'une attaque lorsque plus de la moitié de la puissance totale du réseau est concentrée entre les mains de l'attaquant. <br><a name="habracut"></a><br><h3>  51% Problème d'attaque </h3><br>  Ceux qui surveillent le marché des crypto-monnaies ne pouvaient manquer de noter la récente flambée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'attaques</a> à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">51%</a> sur des projets PoW relativement petits (preuve de travail - "preuve de travail effectuée"), lorsque les attaquants ont réécrit les transactions et transféré les fonds le plus rapidement possible via les échanges.  «Relatif» dans ce cas signifie qu'une petite fraction d'appareils prenant en charge la sécurité cryptographique d'une grande blockchain (Bitcoin ou Ethereum, par exemple) suffira à briser le consensus d'une petite blockchain travaillant sur le même algorithme de hachage (Bitcoin Cash ou Bitcoin Gold, respectivement) . <br><br>  Dans le cas des crypto-monnaies qui prennent l'algorithme SHA-256 (LCC ou BCH) comme base de cryptage, le risque est aggravé par le fait que la crypto-monnaie la plus grande et la plus sécurisée au monde fonctionne sur le même algorithme - Bitcoin (BTC). <br><br>  Dans cet article, nous nous concentrerons sur le modèle mathématique de protection contre les attaques à 51% et soulignerons superficiellement les principaux termes et concepts associés utilisés dans la cryptographie des blockchains. <br><br><h3>  Introduction à l'exploitation minière élevée </h3><br>  Dans le schéma de sécurité classique de la blockchain PoW, les mineurs se font concurrence en calculant un grand nombre de hachages de blocs potentiels pour en trouver un qui répond aux conditions de complexité spécifiées par le consensus du réseau.  Si la complexité est nulle et que tout hachage est accepté par le réseau comme valide, la preuve de travail ne fonctionnera pas et n'importe quel nœud du réseau peut facilement extraire des blocs. <br><br>  À première vue, ce n'est pas mal: l'exploitation minière deviendra démocratique et peu coûteuse en énergie.  Mais dans la pratique, tout le monde va extraire des blocs bon marché et les pousser dans le réseau, ce qui signifie qu'il y aura de nombreux candidats pour la suite de la chaîne de blocs.  Comme les mineurs ne comprendront plus sur quel bloc construire la suite de la blockchain, de nombreuses chaînes orphelines apparaîtront.  Il y aura du chaos, qui a été observé par PoW-coins avec un algorithme inadéquat pour ajuster la complexité de l'exploitation minière. <br><br>  Si la complexité est nulle et que la production du bloc n'entraînera aucun coût, personne ne pourra déterminer quelles chaînes candidates valent le plus, ce qui signifie qu'il n'y aura pas de priorité.  Les mineurs pourront également travailler sur différentes chaînes sans rien perdre. <br><br>  Cette expérience de réflexion démontre simplement que l'objectif principal de l'algorithme de preuve de travail, de preuve d'enjeu ou généralement de preuve de quoi que ce soit est de fournir au réseau un moyen déterministe de déterminer le droit à l'extraction, à la frappe ou à la forge d'un bloc, avec lequel les autres participants seront d'accord .  De plus, une autre condition importante pour tous les demandeurs de blocs est de ne pas travailler sur plusieurs chaînes simultanément en toute impunité.  Dans le système de preuve de mise, une telle approche est sanctionnée par la privation partielle ou totale d'une mise. <br><br>  <b>L'exploitation minière élevée</b> est une forme alternative de lutte contre les blocs lorsque le droit de produire un bloc est garanti par un agent travaillant pour le compte de l'utilisateur.  Ces agents - les «abeilles qui travaillent» - sont sur la blockchain elle-même.  Ils sont complètement décentralisés et sont créés lorsqu'un utilisateur effectue une transaction spéciale pour créer un agent. <br><br>  Après la création, les abeilles actives commencent à agir comme des dispositifs virtuels pour l'exploitation minière (rig) et leurs propriétaires deviennent des "apiculteurs".  Lorsque les abeilles ouvrières réussissent à obtenir le bloc, la rémunération du bloc (y compris les commissions incluses dans le bloc) est versée à l'apiculteur.  Les abeilles qui travaillent nécessitent très peu d'énergie et n'ont pas besoin d'équipement spécialisé pour la production de blocs.  De plus, leur durée de vie est limitée et la création d'une abeille est une action spéculative à un certain prix;  cela empêche les tentatives de travailler sur plusieurs chaînes en même temps.  Le succès d'une abeille individuelle dépend uniquement de la population d'abeilles vivant dans l'ensemble du réseau.  Certaines abeilles ne trouveront jamais de bloc, tandis que d'autres auront une chance disproportionnée (similaire à l'exploitation en solo). <br><br><img src="https://habrastorage.org/webt/9r/aw/je/9rawje4irkcraqt-hpczoggsuqq.png" alt="image"><br><br>  <i>Fig.</i>  <i>1: une abeille active est ajoutée à la blockchain via une transaction de création d'abeilles (BCT) et des blocs de mines au cours de sa durée de vie</i> <br><br><h3>  Création d'agents (abeilles ouvrières) </h3><br>  Pour créer une abeille qui travaille, l'utilisateur envoie la transaction à une adresse spéciale "morte", par exemple: <code>CReateLitecoinCashWorkerBeeXYs19YQ</code> .  Notez que tout le monde utilise la même adresse pour créer l'abeille.  Cette adresse est analysée comme existante et correcte, mais personne n'a de clé privée;  L'utilitaire vanitygen détermine que la recherche d'une clé privée à l'aide de cœurs 24 * 2 GHz prendra environ 1,7 * 10 ^ 31 ans (avec 50% de chances de succès). <br><br>  Une transaction créant une abeille doit avoir au moins deux sorties.  Le premier définit une redevance fixe pour la création d'une abeille, qui est envoyée à une adresse inaccessible.  Bien que le prix de la création d'une abeille soit déterminé de manière dynamique, il est supposé qu'il s'agira d'un pourcentage de la récompense en bloc.  Ce calcul inclut le coût minimum, de sorte qu'au moment où toutes les pièces sont extraites, il est logique d'utiliser une extraction élevée pour recevoir des frais de transaction. <br><br>  La deuxième conclusion a un coût nul, mais spécifie l'adresse de base, qui recevra une récompense pour le bloc trouvé par l'abeille à l'avenir.  Vous pouvez l'appeler "la future adresse de l'apiculteur".  S'il le souhaite, l'utilisateur lui-même peut le clarifier;  par défaut, une nouvelle adresse sera générée à chaque fois dans son portefeuille. <br><br>  Un exemple: <br><br><pre> <code class="hljs powershell"><span class="hljs-string"><span class="hljs-string">"vout"</span></span>: [ { // <span class="hljs-type"><span class="hljs-type">Bee</span></span> <span class="hljs-type"><span class="hljs-type">creation</span></span> <span class="hljs-type"><span class="hljs-type">fee</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"CReateLitecoinCashWorkerBeeXYs19YQ"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">1.0000000</span></span> }, { // <span class="hljs-type"><span class="hljs-type">Address</span></span> <span class="hljs-type"><span class="hljs-type">to</span></span> <span class="hljs-type"><span class="hljs-type">receive</span></span> <span class="hljs-type"><span class="hljs-type">block</span></span> <span class="hljs-type"><span class="hljs-type">rewards</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">any</span></span> <span class="hljs-type"><span class="hljs-type">blocks</span></span> <span class="hljs-type"><span class="hljs-type">this</span></span> <span class="hljs-type"><span class="hljs-type">bee</span></span> <span class="hljs-type"><span class="hljs-type">mines</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0000000</span></span> }, { // <span class="hljs-type"><span class="hljs-type">Change</span></span> <span class="hljs-type"><span class="hljs-type">address</span></span> <span class="hljs-type"><span class="hljs-type">for</span></span> <span class="hljs-type"><span class="hljs-type">change</span></span> <span class="hljs-type"><span class="hljs-type">from</span></span> <span class="hljs-type"><span class="hljs-type">creation</span></span> <span class="hljs-type"><span class="hljs-type">fee</span></span> <span class="hljs-string"><span class="hljs-string">"addr"</span></span>: <span class="hljs-string"><span class="hljs-string">"Cd6CRuWCu6p4NLR6XG7BKyC8hzvEoYuKbn"</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">123.5274346</span></span> } ]</code> </pre> <br>  Les abeilles arrivent à maturité et deviennent capables de produire des blocs après l'apparition de 576 blocs sur la chaîne de blocs à partir du moment où les abeilles ont été créées.  Il s'agit du nombre attendu de nouveaux blocs ajoutés à la blockchain Litecoin Cash en 24 heures.  Une fois les abeilles matures, il y a 4032 blocs (environ 1 semaine) et recherchez les blocs, puis ils meurent. <br><br>  L'abeille est créée dans un portefeuille QT.  Quelque chose comme ça ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/qx/pj/wt/qxpjwt6tv6k5il6empln0azugxe.png" alt="image"><br><br>  <i>Fig.</i>  <i>2: Disposition du portefeuille LCC avec des abeilles qui travaillent</i> <br><br><h3>  Les abeilles au travail: recherche de blocs </h3><br>  Par exemple, supposons que la hauteur de la chaîne de blocs = 1000, et le réseau devrait déterminer quelle abeille est affectée pour trouver le bloc 1001. L'apiculteur d'Alice a maintenant 4 abeilles (créées entre 576 et 4608 blocs). <br><br>  Lorsque le bloc 1000 apparaît, le portefeuille d'Alice calcule deux valeurs. <br><br>  Le premier est une valeur déterministe imprévisible mais facilement vérifiable.  Cela est facile à faire en ajoutant des hachages de blocs à différentes profondeurs (codées en dur) entre, disons, 0 et 500000 blocs, en veillant à ce que notre valeur aléatoire soit bien enracinée dans la blockchain: <br><br><pre> <code class="hljs powershell">string deterministicRandString = blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">13</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">173</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">1363</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">27363</span></span>].hash + blocks[<span class="hljs-type"><span class="hljs-type">blockHeight</span></span>-<span class="hljs-number"><span class="hljs-number">496393</span></span>].hash;</code> </pre> <br>  Ensuite, son portefeuille calcule le hachage cible de l'abeille, <code>beeTargetHash</code> .  Cette valeur est déterminée par la moyenne mobile exponentielle avec une plage dynamique très élevée, qui définit <code>beeTargetHash</code> sorte que pour une population d'abeilles donnée, la fréquence des blocs obtenus pendant le processus d'extraction soit déterminée.  Sur le plan positif, plus le nombre de blocs PoW a été extrait depuis le dernier bloc de mine élevé, plus <code>beeTargetHash</code> plus élevé (plus simple).  L'algorithme est défini comme suit;  les valeurs de <code>maxTarget</code> , <code>emaWindowsSize</code> et <code>emaDesiredSpacing</code> seront déterminées pendant la simulation. <br><br><pre> <code class="hljs pgsql">beeHashTarget = previousBeeHashTarget (<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> highest (easiest) target maxTarget) numPowBlocks = number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pow blocks since the previous hive mined block; emaInterval = emaWindowSize / emaDesiredSpacing; beeHashTarget *= (<span class="hljs-type"><span class="hljs-type">interval</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) * emaDesiredSpacing + numPowBlocks + numPowBlocks; beeHashTarget /= (<span class="hljs-type"><span class="hljs-type">interval</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) * emaDesiredSpacing;</code> </pre> <br>  <code>beeHashTarget</code> et <code>beeHashTarget</code> peuvent être calculés par n'importe quel nœud du réseau. <br><br>  Le portefeuille d'Alice passe maintenant chacune de ses abeilles vivantes à travers une chaîne aléatoire déterministe, combinant les transactions BCT des abeilles et les hachant pour obtenir un nouveau hachage - le hache d'abeille d'une abeille individuelle.  Par conséquent, chaque abeille génère un hachage par bloc.  Ce hachage est similaire au meilleur hachage généré par une plate-forme d'extraction PoW au cours de la même période. <br><br><pre> <code class="hljs lisp">hash beeHash = sha256(<span class="hljs-name"><span class="hljs-name">deterministicRandString</span></span> + bee.creationTransaction.ID)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Étant donné que le portefeuille d'Alice suit les abeilles, dont chacune calcule le <code>beeHash</code> , il conserve un enregistrement des meilleurs (plus bas) hachages découverts.  Si, en conséquence, le meilleur hachage découvert par le portefeuille d'Alice remplit la condition <code>beeHash &lt; beeTargetHash</code> , Alice obtient le droit d'ajouter un bloc. <br><br>  Supposons qu'Alice ait une abeille vivante, dont le hachage est inférieur à la cible, et l'identifiant de transaction BCT d'une abeille réussie est le suivant: <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0f</span></span>6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841.</code> </pre> <br>  Sachant que le portefeuille d'Alice a le droit de signer un bloc, le réseau produit un bloc avec une transaction spéciale avec deux sorties: <br><br><pre> <code class="hljs powershell"><span class="hljs-string"><span class="hljs-string">"vout"</span></span>: [ { // <span class="hljs-type"><span class="hljs-type">Zero</span></span>-<span class="hljs-type"><span class="hljs-type">value</span></span> <span class="hljs-type"><span class="hljs-type">output</span></span> <span class="hljs-type"><span class="hljs-type">identifies</span></span> <span class="hljs-type"><span class="hljs-type">the</span></span> <span class="hljs-type"><span class="hljs-type">bee</span></span> <span class="hljs-type"><span class="hljs-type">and</span></span> <span class="hljs-type"><span class="hljs-type">proves</span></span> <span class="hljs-type"><span class="hljs-type">it</span></span><span class="hljs-string"><span class="hljs-string">'s really minting for Alice "value": 0, "n": 0, "scriptPubKey": { "asm": "OP_RETURN OP_BEE 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 IH3Emz49KJeRbw0q4R48pD6GWPQtvHCxLeQOxxH+yv14Tn5KzUFIXBe9Td8EHudejzebMYt/XpusENzNkGM/a4I=" } }, { // Block reward (subsidy + fees) - must pay to bee'</span></span><span class="hljs-type"><span class="hljs-type">s</span></span> <span class="hljs-type"><span class="hljs-type">correct</span></span> <span class="hljs-type"><span class="hljs-type">coinbase</span></span> <span class="hljs-type"><span class="hljs-type">address</span></span> <span class="hljs-string"><span class="hljs-string">"value"</span></span>: <span class="hljs-number"><span class="hljs-number">250.0001125</span></span>, <span class="hljs-string"><span class="hljs-string">"n"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"scriptPubKey"</span></span>: { <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR"</span></span> ] } }</code> </pre> <br>  <code>vout[0]</code> est une sortie à valeur nulle qui ne peut pas être dépensée.  Il est utilisé à la fois pour identifier l'abeille qui a obtenu le bloc et pour prouver qu'elle l'a obtenu pour Alice. <br><br>  <code>vout[1]</code> est la sortie qui verse à Alice une récompense en bloc. <br><br><h3>  Confirmation de blocage </h3><br>  Le portefeuille de Bob, recevant le bloc d'Alice, doit maintenant s'assurer qu'il satisfait au consensus.  Tout d'abord, il s'assure que la transaction comprend deux entrées, dont la première est zéro, et que le script commence par <code>OP_RETURN OP_BEE</code> .  Il récupère ensuite l'identifiant de transaction d'abeille d'Alice: <br><br><pre> <code class="hljs go"><span class="hljs-number"><span class="hljs-number">0f</span></span>6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841.</code> </pre> <br><blockquote>  Digression: Puisque la transaction de création d'une abeille est transférée à une adresse inaccessible, la sortie des transactions non dépensées (UTXO) y reste.  Par conséquent, le portefeuille de Bob n'a pas besoin d'activer l'option de ligne de commande <code>txindex</code> (qui indexe complètement toutes les transactions en raison d'une vérification retardée et d'une utilisation accrue du disque) pour vérifier facilement les sorties BCT d'Alice.  En raison de l'utilisation d'UTXO, le portefeuille QT n'a pas besoin de bases de données ou de modifications pour prendre en charge l'extraction élevée.  L'onglet abeilles s'intègre également dynamiquement. </blockquote><br><br>  En validant le bloc de mine élevé, le portefeuille de Bob implémente l'équivalent de RPC (appel de procédure à distance): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gettxout</span></span> 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Cela lui donne la première sortie BTC, <code>vout [0]</code> , et garantit que 1) la profondeur de la transaction se situe dans la plage de la durée de vie de l'abeille;  2) une commission a été payée pour la création d'une abeille;  3) il a été envoyé à la bonne adresse sans issue. <br><br>  Si la vérification réussit, le portefeuille de Bob produira: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">gettxout</span></span> 0f6953f0a0816483c71ae3df45650a997e678588a315d72e9ae06e6a3f1c1841 <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  On obtient ainsi la deuxième sortie de BCT, <code>vout [1]</code> , confirmant que 1) la valeur est nulle;  2) l'adresse est la même que l'adresse de réception du transfert de pièces dans le bloc (dans l'exemple <code>CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR</code> ). <br><br>  La vérification suivante vérifie la signature du message de la dernière partie de <code>vout [0]</code> .  Le message doit contenir le numéro de bloc actuel, signé par l'adresse de réception du transfert de pièces, donc le portefeuille de Bob produit: <br><br><pre> <code class="hljs objectivec">verifymessage <span class="hljs-built_in"><span class="hljs-built_in">CTrdm8YDfjmFJwFnKbvNZ9NYznhMqrNgFR</span></span> <span class="hljs-string"><span class="hljs-string">"IH3Emz49KJeRbw0q4R48pD6GWPQtvHCxLeQOxxH+yv14Tn5KzUFIXBe9Td8EHudejzebMYt/XpusENzNkGM/a 4I="</span></span> <span class="hljs-string"><span class="hljs-string">"1001"</span></span></code> </pre> <br>  Enfin, Bob calcule <code>deterministicRandString</code> et <code>beeHashTarget</code> pour le bloc actuel, puis calcule le <code>beeHash</code> d'Alice et le <code>beeHash</code> à <code>beeHashTarget</code> .  Si tous les contrôles sont réussis, le bloc est considéré comme valide et vérifié.  Le processus de validation des blocs est rapide et ne nécessite pas de vérification coûteuse des blocs historiques. <br><br><h3>  Jumelage Hi-Mining et PoW Mining </h3><br>  Il est supposé que l'extraction élevée n'est pas la seule méthode pour assurer la sécurité du réseau.  Les développeurs de Litecoin Cash veulent non seulement sauver la communauté minière, mais aussi ne pas interférer avec elle de quelque manière que ce soit.  L'exploitation minière élevée doit être associée à l'exploitation minière PoW sur une chaîne de blocs. <br><br>  Actuellement, le fonctionnement du circuit est calculé comme suit: <br><br><img src="https://habrastorage.org/webt/vg/pz/np/vgpznpd0y6ijk9bv6ota03ybhn4.png" alt="image"><br><br>  C'est-à-dire que le fonctionnement du circuit s'accumule en fonction de la complexité dans chaque bloc du circuit.  Les développeurs proposent de modifier cette définition comme suit: <br><br><img src="https://habrastorage.org/webt/af/fo/e4/affoe4zxpceo_ow-jtscjvpb2lm.png" alt="image"><br><br>  Ainsi, chaque bloc de ruche-mine sera récompensé en fonction de la quantité de travail conclue dans le bloc PoW précédent, et la constante <code>k</code> est déterminée expérimentalement. <br><br><h3>  Conclusion: l'exploitation minière élevée comme défense contre l'attaque 51% </h3><br>  Selon Jane 'Tanner' Craig, développeur en chef de Litecoin Cash, l'idée de HiveMine n'est pas seulement de fournir une protection fiable contre les attaques à 51%, mais aussi de démocratiser et de décentraliser l'exploitation minière.  Contrairement aux chaînes de blocs PoS, lorsque «les riches s'enrichissent», accumulant leur part, HiveMine a encore besoin du coût de création d'une abeille qui peut ne pas être rentable.  L'exploitation minière basée sur les agents satisfait les trois tâches principales de l'équipe: compliquer considérablement l'attaque de 51%, démocratiser l'exploitation minière et la liberté des mineurs à l'aide de l'algorithme SHA-256, qui garantit une haute sécurité du même réseau Bitcoin.  Pour une attaque réussie, un attaquant devra prendre plus de 51% de la puissance du réseau, ainsi que 51% de la population d'abeilles du réseau, et étant donné le processus de création d'abeilles, cela deviendra immédiatement évident. <br><br>  Selon Craig, après avoir testé et implémenté le modèle HiveMine dans le réseau Litecoin Cash, qui n'est pas fourni avec le même taux de hachage SHA-256 que le même Bitcoin Cash, il sera néanmoins plus rapide et plus fiable que les réseaux Bitcoin Cash ou Bitcoin. . <br><br>  Références: <br>  1. « <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Hive: Agent-based Mining in Litecoin Cash</a></i> », Iain CRAIG, Sebastian CLARKE, Michał WYSZYŃSKI et Federico DE GONZÁLEZ-SOLER.  (2018) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415949/">https://habr.com/ru/post/fr415949/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415937/index.html">La fusée privée japonaise MOMO-2 a explosé sur la rampe de lancement</a></li>
<li><a href="../fr415939/index.html">Traitement graphique distribué avec Spark GraphX</a></li>
<li><a href="../fr415943/index.html">"Développement du jeu et théorie du divertissement": points clés du livre de Raff Coster</a></li>
<li><a href="../fr415945/index.html">Nouvel automate chinois avec Aliexpress: Wecon LX3VP / LX3VE</a></li>
<li><a href="../fr415947/index.html">Système de compensation d'erreur d'installation de fibre optique lors de son traitement par rayonnement laser lors de la rotation</a></li>
<li><a href="../fr415951/index.html">Mitap Sberbank et IBM sur HyperLedger Fabric</a></li>
<li><a href="../fr415953/index.html">Comment une entreprise sanglante remporte l'open source: la bataille pour BPMS</a></li>
<li><a href="../fr415957/index.html">Nous avons besoin de plus de sacs à dos: le Bobby XL de XD Design</a></li>
<li><a href="../fr415959/index.html">Comme nous avons écrit le code réseau du tireur PvP mobile: synchronisation du joueur sur le client</a></li>
<li><a href="../fr415961/index.html">Stockage distribué russe. Comment ça marche</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>