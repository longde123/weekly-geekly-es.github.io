<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õÑÔ∏è üë∞üèº ü§¥üèΩ Nous utilisons la mosa√Øque, la pixellisation et les masques g√©om√©triques de Voronoi dans les shaders pour d√©corer le site üßôüèª üë©üèº‚Äçüî¨ üö¥üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article est une suite logique de l' introduction des shaders de programmation pour les concepteurs de mise en page . Dans ce document, nous avons ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous utilisons la mosa√Øque, la pixellisation et les masques g√©om√©triques de Voronoi dans les shaders pour d√©corer le site</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421821/"><img src="https://habrastorage.org/webt/tw/dv/y5/twdvy5bonlmr47omgfhgmi9rjqu.jpeg" alt="image"><br><br><p> Cet article est une suite logique de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">introduction des shaders de programmation pour les concepteurs de mise en page</a> .  Dans ce document, nous avons cr√©√© un mod√®le pour cr√©er divers effets bidimensionnels avec des photos √† l'aide de shaders et regard√© quelques exemples.  Dans cet article, nous ajouterons quelques textures suppl√©mentaires, appliquerons le fractionnement de Voronoi en pratique pour cr√©er des mosa√Øques √† partir de celles-ci, parlerons de la cr√©ation de divers masques dans les shaders, de la pixellisation et aborderons √©galement certains probl√®mes de l'ancienne syntaxe GLSL qui existe toujours dans nos navigateurs. </p><br><p>  Tout comme la derni√®re fois, il y aura un minimum de th√©orie et un maximum de pratique et de raisonnement dans un langage banal de tous les jours.  Les d√©butants trouveront ici une s√©quence d'actions avec des conseils et des notes utiles, et les vendeurs exp√©riment√©s peuvent trouver quelques id√©es d'inspiration. </p><a name="habracut"></a><br><p>  <em>Une enqu√™te dans un article pr√©c√©dent a montr√© que le sujet des effets WebGL pour les sites peut int√©resser non seulement les typographes, mais aussi nos coll√®gues d'autres sp√©cialisations.</em>  <em>Afin de ne pas les d√©router avec les derni√®res fonctionnalit√©s ES, nous nous limitons d√©lib√©r√©ment √† des constructions de syntaxe plus traditionnelles que tout le monde comprend.</em>  <em>Et encore une fois, j'attire l'attention des lecteurs sur le fait que les √©diteurs int√©gr√©s de CodePen affectent les performances de ce qui est fait en eux.</em> </p><br><p>  Mais commen√ßons ... </p><br><h2 id="shablon-dlya-raboty-s-sheyderami">  Mod√®le pour travailler avec des shaders </h2><br><p>  Pour ceux qui n'ont pas lu l'article pr√©c√©dent, nous avons cr√©√© ce mod√®le pour travailler avec des shaders: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/ZMBMPJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Un plan y est cr√©√© (dans notre cas, un carr√©) sur lequel la texture de l'image est "dessin√©e".  Pas de d√©pendances inutiles et un vertex shader tr√®s simple.  Ensuite, nous avons d√©velopp√© ce mod√®le, mais maintenant nous allons commencer √† partir du moment o√π il n'y a pas encore de logique dans le shader de fragment. </p><br><h2 id="mozaika">  Mosa√Øque </h2><br><p>  La mosa√Øque est un plan divis√© en petites zones, o√π chacune des zones est remplie d'une certaine couleur ou, comme dans notre cas, d'une texture.  Comment pouvons-nous m√™me casser notre avion en morceaux?  √âvidemment, vous pouvez le diviser en rectangles.  Mais c'est d√©j√† si facile √† faire avec l'aide de SVG, de faire glisser WebGL vers cette t√¢che et de tout mettre √† l'improviste sur absolument rien. </p><br><p>  Pour que la mosa√Øque soit int√©ressante, elle doit avoir diff√©rents fragments, √† la fois en forme et en taille.  Il existe une approche tr√®s simple, mais en m√™me temps tr√®s divertissante pour construire une telle partition.  Il est connu comme la mosa√Øque de Vorono√Ø ou la partition de Dirichlet, et sur Wikip√©dia, il est √©crit que Descartes a utilis√© quelque chose de similaire au XVIIe si√®cle lointain.  L'id√©e est quelque chose comme √ßa: </p><br><ul><li>  Prenez un ensemble de points dans l'avion. </li><li>  Pour chaque point de l'avion, recherchez le point le plus proche de cet ensemble. </li><li>  C'est tout.  Le plan est divis√© en zones polygonales, chacune √©tant d√©termin√©e par l'un des points de l'ensemble. </li></ul><br><p>  Il est probablement pr√©f√©rable de montrer ce processus avec un exemple pratique.  Il existe diff√©rents algorithmes pour g√©n√©rer cette partition, mais nous agirons sur le front, car calculer quelque chose pour chaque point sur le plan est juste la t√¢che du shader.  Nous devons d'abord cr√©er un ensemble de points al√©atoires.  Afin de ne pas charger le code des exemples, nous allons leur faire une variable globale. </p><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS.push([<span class="hljs-type"><span class="hljs-type">Math.random</span></span>(), <span class="hljs-type"><span class="hljs-type">Math.random</span></span>()]); } }</code> </pre> <br><p>  Maintenant, nous devons les transmettre aux shaders.  Les donn√©es sont globales, nous allons donc utiliser le modificateur <code>uniform</code> .  Mais il y a un point subtil: nous ne pouvons pas simplement passer un tableau.  Il semblerait que le XXIe si√®cle soit dans la cour, mais n√©anmoins rien n'en sortira.  Par cons√©quent, vous devez transf√©rer un tableau de points un par un. </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_points['</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-string"><span class="hljs-string">']'</span></span>), POINTS[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); }</code> </pre> <br><p>  Aujourd'hui, nous rencontrerons souvent des probl√®mes similaires d'incoh√©rence entre ce qui est attendu et ce qui se trouve dans les vrais navigateurs.  Habituellement, les le√ßons WebGL utilisent THREE.js et cette biblioth√®que cache une partie de la salet√© en elle-m√™me, comme jQuery l'a fait dans ses t√¢ches, mais si vous la supprimez, cela fait vraiment mal √† votre cerveau. </p><br><p>  Dans le shader de fragment, nous avons une variable de tableau pour les points.  Nous ne pouvons cr√©er que des tableaux d'une longueur fixe.  Commen√ßons par 10 points: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_POINTS 10 uniform vec2 u_points[NUMBER_OF_POINTS];</span></span></code> </pre> <br><p>  Assurez-vous que tout cela fonctionne en dessinant des cercles √† la place des points.  Un tel dessin de diverses primitives g√©om√©triques est souvent utilis√© pendant le d√©bogage - elles sont clairement visibles et vous pouvez imm√©diatement comprendre ce qui se trouve et o√π il se d√©place. </p><br><blockquote>  Utilisez le "dessin" de cercles, de lignes et d'autres points de rep√®re pour les objets invisibles sur lesquels les animations sont construites.  Cela donnera des indices √©vidents sur la fa√ßon dont ils fonctionnent, surtout si les algorithmes sont complexes √† comprendre rapidement sans pr√©paration pr√©alable.  Ensuite, tout cela peut √™tre comment√© et laiss√© √† des coll√®gues - ils diront merci. </blockquote><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0.02</span></span>) { gl_FragColor = WHITE; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/pONOme" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bon.  Ajoutons √©galement du mouvement aux points.  Laissez-les se d√©placer en cercle pour commencer, puis nous reviendrons sur cette question plus tard.  Les coefficients sont √©galement mis sur l'≈ìil, juste pour ralentir l√©g√®rement leur mouvement et r√©duire l'amplitude des oscillations. </p><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movePoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timeStamp) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += Math.sin(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += Math.cos(i * timeStamp / <span class="hljs-number"><span class="hljs-number">5000.0</span></span>) / <span class="hljs-number"><span class="hljs-number">500.0</span></span>; } } }</code> </pre> <br><p>  Retournez au shader.  Pour de futures exp√©riences, nous trouverons un nombre utile de zones dans lesquelles tout sera divis√©.  Nous trouvons donc le point le plus proche du pixel actuel de l'ensemble et enregistrons le num√©ro de ce point - c'est le num√©ro de la zone. </p><br><pre> <code class="hljs matlab">float min_distance = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; int area_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { float current_distance = distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current_distance &lt; min_distance) { min_distance = current_distance; area_index = <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; } }</code> </pre> <br><p>  Pour tester les performances, nous peignons √† nouveau tout dans des couleurs vives: </p><br><pre> <code class="hljs pgsql">gl_FragColor = texture2D(u_texture, texture_coord); gl_FragColor.g = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index))); gl_FragColor.b = abs(sin(<span class="hljs-type"><span class="hljs-type">float</span></span>(area_index)));</code> </pre> <br><blockquote>  La combinaison de module (abs) et de fonctions limit√©es (en particulier sin et cos) est souvent utilis√©e lorsque l'on travaille avec des effets similaires.  D'une part, cela ajoute un peu de hasard, et d'autre part, cela donne imm√©diatement un r√©sultat normalis√© de 0 √† 1, ce qui est tr√®s pratique - nous avons de tr√®s nombreuses valeurs qui se situent pr√©cis√©ment dans ces limites. </blockquote><p>  Nous trouverons √©galement des points plus ou moins √©quidistants de plusieurs points de l'ensemble, et les colorierons.  Cette action ne porte pas de charge utile sp√©ciale, mais regarder le r√©sultat est toujours int√©ressant. </p><br><pre> <code class="hljs matlab">int number_of_near_points = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; NUMBER_OF_POINTS; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance(texture_coord, u_points[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]) &lt; min_distance + EPSILON) { number_of_near_points++; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number_of_near_points &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor.rgb = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Vous devriez obtenir quelque chose comme ceci: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/xaRavJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Ceci est encore un projet, nous allons encore le finaliser.  Mais maintenant, le concept g√©n√©ral d'une telle s√©paration de l'avion est clair. </p><br><h2 id="mozaika-iz-fotografiy">  Mosa√Øque √† partir de photos </h2><br><p>  Il est clair que dans sa forme pure, il n'y a pas beaucoup d'avantages d'une telle partition.  Pour √©largir vos horizons et juste pour le plaisir, vous pouvez jouer avec lui, mais sur un vrai site, il vaudrait la peine d'ajouter quelques photos de plus et d'en faire une mosa√Øque.  Refaisons un peu la fonction de cr√©ation de textures, pour qu'il y en ait plus d'une. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTextures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(let i = 0; i &lt; URLS.textures.length; i++)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(index)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">crossOrigin</span></span></span><span class="hljs-function"> = '</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anonymous</span></span></span><span class="hljs-function">'; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onload</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt; { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texture</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activeTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL['TEXTURE' + index])</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindTexture</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, texture)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pixelStorei</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.UNPACK_FLIP_Y_WEBGL, true)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texImage2D</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, 0, GL.RGB, GL.RGB, GL.UNSIGNED_BYTE, image)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">texParameteri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1i</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_textures[' + index + ']')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-function">); }; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">src</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URLS</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">textures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[index]</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  Rien d'inhabituel ne s'est produit, nous venons de remplacer les z√©ros par le param√®tre <code>index</code> et de r√©utiliser le code existant pour charger les trois textures.  Dans le shader, nous avons maintenant un tableau de textures: </p><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUMBER_OF_TEXTURES 3 uniform sampler2D u_textures[NUMBER_OF_TEXTURES];</span></span></code> </pre> <br><p>  Maintenant, nous pouvons utiliser le num√©ro de zone enregistr√© pr√©c√©demment afin de s√©lectionner l'une des trois textures.  Mais ... </p><br><p>  Mais avant cela, je voudrais faire une petite digression.  A propos de la plaie.  √Ä propos de la syntaxe.  Le Javascript moderne (conditionnellement ES6 +) est une langue agr√©able.  Il vous permet d'exprimer vos pens√©es au fur et √† mesure qu'elles surviennent, ne limite le cadre √† aucun paradigme de programmation sp√©cifique, compl√®te certains points pour nous et vous permet de vous concentrer davantage sur l'id√©e que sur sa mise en ≈ìuvre.  Pour le cr√©ateur - c'est tout.  Certaines personnes pensent qu'il donne trop de libert√© et passent par exemple √† TypeScript.  Pure C est un langage plus rigoureux.  Il permet √©galement beaucoup, vous pouvez attirer n'importe quoi dessus, mais apr√®s JS, il est per√ßu comme un peu maladroit, d√©mod√© ou quelque chose.  N√©anmoins, il est toujours bon.  GLSL tel qu'il existe dans les navigateurs est juste quelque chose.  Non seulement c'est un ordre de grandeur plus strict que C, mais il manque encore de nombreux op√©rateurs et constructions de syntaxe familiers.  C'est probablement le plus gros probl√®me lors de l'√©criture de shaders plus ou moins complexes pour WebGL.  Derri√®re l'horreur que le code se transforme, il peut √™tre tr√®s difficile de jeter un ≈ìil √† l'algorithme d'origine.  Certains codeurs pensent que jusqu'√† ce qu'ils apprennent le C, le chemin vers les shaders est ferm√© pour eux.  Donc: la connaissance de C ne sera pas particuli√®rement utile ici.  Voici une sorte de monde qui lui est propre.  Le monde de la folie, des dinosaures et des b√©quilles. </p><br><p>  Comment puis-je choisir l'une des trois textures ayant un num√©ro - le num√©ro de zone.  Le reste me vient √† l'esprit en divisant le nombre par le nombre de textures.  Excellente id√©e.  Seul l'op√©rateur <code>%</code> , que les mains √©crivent d√©j√†, n'est pas l√†.  L'impression de comprendre ce fait est bien d√©crite par l'image: </p><br><p><img src="https://habrastorage.org/webt/3j/w3/on/3jw3on4pazjczkana82degd6gcc.png" alt="image"></p><br><p>  Bien s√ªr, vous dites: "Oui, pas de probl√®me, il y a une fonction <code>mod</code> - prenons-la!".  Mais il s'av√®re qu'elle n'accepte pas deux entiers, seulement des entiers.  D'accord, faites-en un <code>float</code> .  Nous obtenons √©galement un <code>float</code> , mais nous avons besoin d'un <code>int</code> .  Vous devez tout reconvertir, sinon il y a une chance non fausse d'obtenir une erreur de compilation. </p><br><pre> <code class="hljs lisp">int texture_index = int(<span class="hljs-name"><span class="hljs-name">mod</span></span>(<span class="hljs-name"><span class="hljs-name">float</span></span>(<span class="hljs-name"><span class="hljs-name">area_index</span></span>), float(<span class="hljs-name"><span class="hljs-name">NUMBER_OF_TEXTURES</span></span>)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Et voici une question rh√©torique: peut-√™tre sera-t-il plus facile de r√©aliser sa fonction du reste de la division enti√®re que d'essayer de l'assembler √† partir de m√©thodes standard?  Et ceci est encore une fonction simple, et il arrive que des s√©quences tr√®s profond√©ment int√©gr√©es de telles transformations soient obtenues dans lesquelles il n'est plus clair de ce qui se passe. </p><br><p>  Bon, laissons tel quel pour l'instant.  Prenez simplement la couleur du pixel souhait√© dans la texture s√©lectionn√©e et affectez-la √† la variable <code>gl_FragColor</code> .  Alors?  Avons-nous d√©j√† fait cela?  Et puis ce chat r√©appara√Æt.  Vous ne pouvez pas utiliser une non constante lors de l'acc√®s √† un tableau.  Et tout ce que nous avons calcul√© n'est plus une constante.  Ba-dum-tsss !!! </p><br><p>  Vous devez faire quelque chose comme √ßa: </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">0</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">1</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-number"><span class="hljs-number">2</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">2</span></span>], texture_coord); }</code> </pre> <br><p>  D'accord, un tel code est un chemin direct vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">govnokod.ru</a> , mais n√©anmoins, il est diff√©rent de quelque fa√ßon que ce soit.  M√™me l' <code>switch-case</code> n'est pas l√† pour au moins en quelque sorte ennoblir cette honte.  Il existe vraiment une autre b√©quille moins √©vidente qui r√©sout le m√™me probl√®me: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (texture_index == <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { gl_FragColor = texture2D(u_textures[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>], texture_coord); } }</code> </pre> <br><p>  Compteurs de cycles, qui augmentent d'une unit√©, le compilateur peut compter comme une constante.  Mais cela n'a pas fonctionn√© avec un tableau de textures - dans le dernier Chrome, une erreur est apparue disant qu'il √©tait impossible de le faire avec un tableau de textures.  Avec un tableau de nombres, cela a fonctionn√©.  Devinez pourquoi cela fonctionne avec un tableau, mais pas avec un autre?  Si vous pensiez que le syst√®me de fonte de type dans JS √©tait plein de magie - triez le syst√®me "constant - pas constant" dans GLSL.  Le plus dr√¥le est que les r√©sultats d√©pendent √©galement de la carte vid√©o utilis√©e, donc les b√©quilles d√©licates qui fonctionnaient sur la carte graphique NVIDIA peuvent tr√®s bien tomber en panne sur AMD. </p><br><blockquote>  Il vaut mieux √©viter de telles d√©cisions bas√©es sur des hypoth√®ses sur le compilateur.  Ils ont tendance √† se casser et sont difficiles √† tester. </blockquote><p>  La tristesse est la tristesse.  Mais, si nous voulons faire des choses int√©ressantes, nous devons nous abstenir de tout cela et continuer. </p><br><p>  Pour le moment, nous avons obtenu une mosa√Øque de photos.  Mais il y a un d√©tail: si les points sont tr√®s proches les uns des autres, alors il y a une transition rapide de deux domaines.  Ce n'est pas tr√®s joli.  Vous devez ajouter un algorithme qui ne permet pas aux points de se rapprocher.  Vous pouvez faire une option simple, dans laquelle les distances entre les points sont v√©rifi√©es et, si elle est inf√©rieure √† une certaine valeur, nous les √©cartons.  Cette option n'est pas sans inconv√©nients, en particulier, elle conduit parfois √† un peu de contraction des points, mais dans de nombreux cas, elle peut √™tre suffisante, d'autant plus qu'il n'y a pas beaucoup de calculs ici.  Des options plus avanc√©es seraient un syst√®me de charges mobiles et une "toile d'araign√©e" dans laquelle des paires de points sont reli√©es par des ressorts invisibles.  Si vous √™tes int√©ress√© √† les mettre en ≈ìuvre, vous pouvez facilement trouver toutes les formules dans le livre de r√©f√©rence sur la physique pour le lyc√©e. </p><br><pre> <code class="hljs powershell"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUMBER_OF_POINTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let j = i; j &lt; NUMBER_OF_POINTS; j++) { let deltaX = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; let deltaY = POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] - POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>]; let distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; <span class="hljs-number"><span class="hljs-number">0.1</span></span>) { POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">i</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] += <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaX); POINTS[<span class="hljs-type"><span class="hljs-type">j</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] -= <span class="hljs-number"><span class="hljs-number">0.001</span></span> * Math.sign(deltaY); } } }</code> </pre> <br><p>  Le principal probl√®me avec cette approche, ainsi que celle que nous avons utilis√©e dans le shader, est de comparer tous les points avec tous.  Vous n'avez pas besoin d'√™tre un grand math√©maticien pour comprendre que le nombre de calculs de distance sera incroyable si nous ne faisons pas 10 points, mais 1000. Oui, m√™me 100 suffisent pour que tout ralentisse.  Par cons√©quent, il est logique de l'appliquer uniquement pour un petit nombre de points. </p><br><p>  Si nous voulons faire une telle mosa√Øque pour un grand nombre de points, alors nous pouvons utiliser la division famili√®re du plan en carr√©s identiques.  L'id√©e est de mettre un point dans chaque carr√©, puis d'effectuer toutes les comparaisons uniquement avec les points des carr√©s voisins.  Une bonne id√©e, mais des exp√©riences ont montr√© qu'avec un grand nombre de points, les ordinateurs portables bon march√© avec des cartes vid√©o int√©gr√©es ne peuvent toujours pas faire face.  Par cons√©quent, il vaut la peine de r√©fl√©chir dix fois avant de d√©cider de faire une telle mosa√Øque sur votre site √† partir d'un grand nombre de fragments. </p><br><blockquote>  Ne soyez pas radis, v√©rifiez les performances de votre artisanat non seulement sur votre ferme mini√®re, mais aussi sur des ordinateurs portables ordinaires.  Ce sont essentiellement les utilisateurs. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEYN" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="razbienie-ploskosti-na-chasti-po-grafiku-funkcii">  Partitionnement d'un plan selon un graphe de fonction </h2><br><p>  Voyons une autre option pour diviser un plan en parties.  Il n'aura plus besoin d'une grande puissance de calcul.  L'id√©e principale est de prendre une fonction math√©matique et de construire son graphique.  La ligne r√©sultante divisera simplement l'avion en deux parties.  Si nous utilisons une fonction de la forme <code>y = f(x)</code> , nous obtenons la division sous la forme d'une coupe.  En rempla√ßant X par Y, nous pouvons changer la section horizontale en verticale.  Si vous prenez la fonction en coordonn√©es polaires, vous devez tout traduire en cart√©sien et vice versa, mais l'essence des calculs ne changera pas.  Dans ce cas, le r√©sultat n'est pas une coupe en deux parties, mais plut√¥t une coupe de trou.  Mais nous verrons la premi√®re option. </p><br><p>  Pour chaque Y, nous calculerons la valeur de X pour faire une coupe verticale.  Nous pourrions prendre une onde sinuso√Ødale √† ces fins, par exemple, mais c'est trop ennuyeux.  Il est pr√©f√©rable de prendre quelques morceaux √† la fois et de les plier. </p><br><p>  Nous prenons plusieurs sinuso√Ødes, dont chacune est li√©e √† une coordonn√©e le long de Y et au temps, et les ajoutons.  Les physiciens appellent cette superposition d'addition.  √âvidemment, en multipliant le r√©sultat entier par un certain nombre, nous changeons l'amplitude.  Retirez-le dans une macro distincte.  Si vous multipliez les coordonn√©es - le param√®tre sinus, la fr√©quence changera.  Nous l'avons d√©j√† vu dans un article pr√©c√©dent.  Nous supprimons √©galement le modificateur de fr√©quence commun √† toutes les sinuso√Ødes de la formule.  Il ne sera pas superflu de jouer avec le temps, un signe n√©gatif donnera l'effet de d√©placer la ligne dans la direction oppos√©e. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span> = u_time * SPEED; <span class="hljs-type"><span class="hljs-type">float</span></span> x = (sin(texture_coord.y * FREQUENCY) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.1</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">1.72</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">1.121</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">2.221</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">0.437</span></span>) + sin(texture_coord.y * FREQUENCY * <span class="hljs-number"><span class="hljs-number">3.1122</span></span> + <span class="hljs-type"><span class="hljs-type">time</span></span> * <span class="hljs-number"><span class="hljs-number">4.269</span></span>)) * AMPLITUDE;</code> </pre> <br><p>  Apr√®s avoir fait de tels r√©glages globaux pour notre fonction, nous serons confront√©s au probl√®me de r√©p√©ter le m√™me mouvement √† des intervalles assez courts.  Pour r√©soudre ce probl√®me, nous devons tout multiplier par des coefficients pour lesquels le plus petit multiple commun est tr√®s grand.  Quelque chose de similaire est √©galement utilis√© dans le g√©n√©rateur de nombres al√©atoires, rappelez-vous?  Dans ce cas, nous n'avons pas r√©fl√©chi et avons pris des chiffres pr√™ts √† l'emploi √† partir d'un exemple provenant d'Internet, mais personne ne prend la peine d'exp√©rimenter nos valeurs. </p><br><p>  Il ne reste plus qu'√† choisir l'une des deux textures pour les points au-dessus de notre graphique de fonction et la seconde pour les points en dessous.  Plus pr√©cis√©ment √† gauche et √† droite, nous avons tous tourn√©: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (texture_coord.x - <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> &gt; x) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord); }</code> </pre> <br><p>  Ce que nous avons re√ßu ressemble √† des ondes sonores.  Plus pr√©cis√©ment, leur image sur l'oscilloscope.  En effet, nous pourrions au lieu de nos sinuso√Ødes transmettre des donn√©es √† partir d'une sorte de fichier son.  Mais travailler avec le son est un sujet pour un article s√©par√©. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/VGmEeO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="maski">  Masques </h2><br><p>  Les exemples pr√©c√©dents devraient conduire √† une remarque assez logique: tout cela ressemble au travail des masques en SVG (si vous n'avez pas travaill√© avec eux, voir les exemples de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Masques SVG et effets wow</a> ).  C'est juste qu'ici nous les faisons un peu diff√©remment.  Et le r√©sultat est le m√™me: certaines zones sont peintes avec une texture, d'autres avec une autre.  Seules les transitions en douceur ne l'ont pas encore √©t√©.  Alors faisons-en un. </p><br><p>  Nous supprimons tous les inutiles et retournons les coordonn√©es de la souris.  Faites un d√©grad√© radial avec le centre √† l'emplacement du curseur et utilisez-le comme masque.  Dans cet exemple, le comportement du shader ressemblera plus √† la logique des masques en SVG que dans les exemples pr√©c√©dents.  Nous avons besoin d'une fonction de <code>mix</code> et d'une fonction de distance.  Le premier m√©langera les valeurs de couleur des pixels des deux textures, en prenant comme troisi√®me param√®tre un coefficient (de 0 √† 1) qui d√©termine laquelle des valeurs pr√©vaudra en cons√©quence.  Nous prenons le module sinus en fonction de la distance - cela donnera juste un changement en douceur de la valeur entre 0 et 1. </p><br><pre> <code class="hljs lisp">gl_FragColor = mix( <span class="hljs-name"><span class="hljs-name">texture2D</span></span>(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord), texture2D(<span class="hljs-name"><span class="hljs-name">u_textures</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], texture_coord), abs(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">length</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span> - u_mouse_position / u_canvas_size))))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  C'est tout.  Regardons le r√©sultat: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/bxBmwB" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Le principal avantage sur SVG est √©vident: </p><br><blockquote>  Contrairement √† SVG, ici, nous pouvons facilement cr√©er des gradients lisses pour diverses fonctions math√©matiques, et non les collecter √† partir de nombreux gradients lin√©aires. </blockquote><p>  Si vous avez une t√¢che plus simple qui ne n√©cessite pas de transitions fluides ou de formes complexes calcul√©es dans le processus, il sera probablement plus facile √† mettre en ≈ìuvre sans utiliser de shaders.  Oui, et les performances sur un mat√©riel faible devraient √™tre meilleures.  Choisissez un outil en fonction de vos t√¢ches. </p><br><p>  √Ä des fins √©ducatives, voyons un autre exemple.  Tout d'abord, faites un cercle dans lequel la texture restera telle qu'elle est: </p><br><pre> <code class="hljs objectivec">gl_FragColor = texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], texture_coord); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist = distance(texture_coord, u_mouse_position / u_canvas_size); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0.3</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  Et remplissez le reste de rayures diagonales: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = sin((texture_coord.y - texture_coord.x) * <span class="hljs-number"><span class="hljs-number">200.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>) { gl_FragColor.rgb *= dist; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { gl_FragColor.rgb *= dist / <span class="hljs-number"><span class="hljs-number">10.0</span></span>; }</code> </pre> <br><p>  Les acceptations sont les m√™mes - on multiplie le param√®tre du sinus pour augmenter la fr√©quence des rayures;  divisez les valeurs obtenues en deux parties;  pour chacune des moiti√©s, nous transformons la couleur des pixels √† notre mani√®re.  Il est utile de se rappeler que dessiner des lignes diagonales est g√©n√©ralement associ√© √† l'ajout de coordonn√©es en X et Y. Notez que nous utilisons √©galement la distance au curseur de la souris lors du changement de couleurs, cr√©ant ainsi une sorte d'ombre.  De la m√™me mani√®re, vous pouvez l'utiliser avec des transformations g√©om√©triques, nous le verrons bient√¥t sur l'exemple de la pixellisation.  En attendant, jetez un ≈ìil au r√©sultat de ce shader: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/rZWqyK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Simple et joli. </p><br><blockquote>  Et oui, si vous √™tes un peu confus, vous pouvez cr√©er des textures non pas √† partir d'images, mais √† partir d'images de vid√©os (il existe de nombreux exemples sur le r√©seau, vous pouvez facilement les comprendre) et leur appliquer tous nos effets.  De nombreux sites d'annuaire comme Awwwards utilisent ces effets conjointement avec la vid√©o. </blockquote><p>  Il convient de rappeler une derni√®re pens√©e: </p><br><blockquote>  Personne ne prend la peine d'utiliser l'une des textures comme masque.  Nous pouvons prendre une photo et utiliser les valeurs de couleur de ses pixels dans nos transformations, que ce soit des changements dans d'autres couleurs, des d√©calages sur les c√¥t√©s ou autre chose qui vous vient √† l'esprit. </blockquote><p>  Mais revenons √† diviser l'avion en plusieurs parties. </p><br><h2 id="pikselizaciya">  Pix√©lisation </h2><br><p>  Cet effet est quelque peu √©vident, mais en m√™me temps, il est si courant qu'il serait faux de passer.  Divisez notre avion en carr√©s, de la m√™me mani√®re que dans l'exemple avec le g√©n√©rateur de bruit, puis pour tous les pixels √† l'int√©rieur de chaque carr√©, nous d√©finissons la m√™me couleur.  Il est obtenu en m√©langeant les valeurs des coins d'un carr√©, nous avons d√©j√† fait quelque chose de similaire.  Pour cet effet, nous n'avons pas besoin de formules complexes, alors additionnez simplement toutes les valeurs et divisez par 4 - le nombre d'angles du carr√©. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin(u_time)) / <span class="hljs-number"><span class="hljs-number">20.0</span></span>; vec2 block_position = floor(texture_coord / block_size) * block_size; gl_FragColor = ( texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) + texture2D(u_textures[<span class="hljs-number"><span class="hljs-number">0</span></span>], block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * block_size) ) / <span class="hljs-number"><span class="hljs-number">4.0</span></span>;</code> </pre> <br><p>  Nous avons √† nouveau li√© l'un des param√®tres au temps dans le module sinus pour voir visuellement ce qui se passe quand il change. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/eLBPej" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="pikselnye-volny">  Ondes de pixels </h2><br><p>            ,       . </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> block_size = abs(sin( length(texture_coord - u_mouse_position / u_canvas_size) * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - u_time)) / <span class="hljs-number"><span class="hljs-number">100.0</span></span> + <span class="hljs-number"><span class="hljs-number">0.001</span></span>;</code> </pre> <br><p>   ,       0  1;        , ,    ,     .       ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://codepen.io/sfi0zy/embed/preview/EeNdEr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>    "" ,              ,    -.     .       " ",     ,         .     .      ‚Äî  .       . </p><br><h2 id="itogi">  R√©sum√© </h2><br><p>         ,     ,  ,    ,           .                    -.     -       -  .          .          .    ,      ,      ,      . </p><br><hr><br><p> <em>PS:  ,   WebGL (      )          ?     ,   ,   .          ?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421821/">https://habr.com/ru/post/fr421821/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421809/index.html">API de concurrence Java EE</a></li>
<li><a href="../fr421811/index.html">L'IETF a propos√© une nouvelle norme pour la messagerie - ce que vous devez savoir</a></li>
<li><a href="../fr421815/index.html">M√©tal liquide dans un ordinateur portable six mois plus tard</a></li>
<li><a href="../fr421817/index.html">Utilisation de formulaires dans React.js √† l'aide d'outils de base</a></li>
<li><a href="../fr421819/index.html">ELK Stack pour stocker les journaux des applications Django</a></li>
<li><a href="../fr421823/index.html">Comment nous avons introduit X-Ray x64</a></li>
<li><a href="../fr421827/index.html">Que lire sur Java en ce moment?</a></li>
<li><a href="../fr421829/index.html">L'anomalie de Frango - une romance fantastique avec de vraies personnes de l'informatique</a></li>
<li><a href="../fr421833/index.html">Nous √©crivons notre programme le plus simple pour ARM Cortex-M3</a></li>
<li><a href="../fr421835/index.html">La Commission interinstitutions d√©veloppe une nouvelle technologie pour bloquer Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>