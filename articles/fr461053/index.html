<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö∞ üé• üéã Nous connectons des cartes en ligne au navigateur sur le smartphone. Partie 2 - Cartes vectorielles ‚õàÔ∏è üíâ üåó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous √©crivons une application serveur qui g√©n√©rera des tuiles raster PNG bas√©es sur des cartes vectorielles en ligne. Utilisez le grattage Web avec Pu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous connectons des cartes en ligne au navigateur sur le smartphone. Partie 2 - Cartes vectorielles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461053/"><p>  Nous √©crivons une application serveur qui g√©n√©rera des tuiles raster PNG bas√©es sur des cartes vectorielles en ligne.  Utilisez le grattage Web avec Puppeteer pour obtenir des donn√©es cartographiques. </p><a name="habracut"></a><br><h3 id="soderzhanie">  Contenu: </h3><br><p> 1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Introduction.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes raster standard</a> <br>  2 - Suite.  √âcrire un rasterizer simple pour les cartes vectorielles <br>  3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Un cas particulier.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous connectons la carte OverpassTurbo</a> </p><br><h3 id="prodolzhenie">  Continuation </h3><br><p>  Et nous sommes donc arriv√©s au sujet le plus int√©ressant.  Imaginez que nous avons trouv√© un site avec une carte que nous voulons vraiment ajouter √† notre navigateur.  Nous faisons tout conform√©ment aux instructions de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie pr√©c√©dente</a> .  Nous ouvrons la visualisation du contenu du site, et il n'y a pas de photos!  Absolument.  Eh bien, quelques ic√¥nes et c'est tout.  Et un autre fichier texte avec une liste de coordonn√©es. </p><br><p>  F√©licitations, nous avons trouv√© une carte vectorielle.  En gros, il est rendu en temps r√©el par votre navigateur.  Elle n'a donc pas du tout besoin de tuiles pr√©par√©es.  D'une part, il n'y a pas tellement de cartes vectorielles jusqu'√† pr√©sent.  Mais cette technologie est tr√®s prometteuse et au fil du temps, elle peut devenir plusieurs fois plus.  Eh bien, nous l'avons compris.  Et pourtant, que faisons-nous maintenant? </p><br><p>  Tout d'abord, vous pouvez essayer de t√©l√©charger un navigateur d'une tr√®s, tr√®s ancienne version.  Celui qui ne prend pas en charge les fonctions requises pour rendre la carte.  Il est possible qu'on vous montre une version diff√©rente du site.  Avec carte raster.  Eh bien, ce que vous devez en faire, vous le savez d√©j√†. </p><br><p>  Cependant, si cette astuce n'a pas fonctionn√©, mais que vous souhaitez toujours obtenir cette carte, et, en outre, pas dans le navigateur du smartphone, √† savoir dans votre navigateur, il existe un moyen. </p><br><h3 id="osnovnaya-ideya">  Id√©e principale </h3><br><p>  Nous partirons du fait que nous voulons obtenir une carte qui peut √™tre ouverte dans n'importe lequel des navigateurs.  Ensuite, nous avons besoin d'un adaptateur - une sorte d'interm√©diaire qui va g√©n√©rer pour nous des tuiles au format PNG. </p><br><p>  Il s'av√®re que vous avez besoin <del>  inventer un v√©lo </del>  d√©velopper un autre moteur de visualisation des donn√©es vectorielles.  Eh bien, ou vous pouvez √©crire un script qui ira sur le site, lui permettant de dessiner sa propre carte vectorielle par lui-m√™me.  Et puis il attendra le t√©l√©chargement, fera une capture d'√©cran, recadrera et reviendra √† l'utilisateur.  Je choisirai peut-√™tre la deuxi√®me option. </p><br><p>  Pour prendre des captures d'√©cran, j'utiliserai un "navigateur de contr√¥le √† distance" - Chrome sans t√™te.  Vous pouvez le contr√¥ler √† l'aide de la biblioth√®que de n≈ìuds js <strong>Puppeteer</strong> .  Vous pouvez en apprendre davantage sur les bases de l'utilisation de cette biblioth√®que √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> . </p><br><h3 id="hello-world-ili-sozdaem-i-nastraivaem-proekt">  Bonjour tout le monde!  Ou cr√©ez et personnalisez un projet </h3><br><p>  Si vous n'avez pas encore install√© Node.js, rendez-vous sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">telle</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">telle</a> page, s√©lectionnez votre syst√®me d'exploitation et terminez l'installation selon les instructions. </p><br><p>  Cr√©ez un nouveau dossier pour le projet et ouvrez-le dans le terminal. </p><br><pre><code class="plaintext hljs">$ cd /Mapshoter_habr</code> </pre> <br><p>  Nous commen√ßons le gestionnaire de cr√©ation d'un nouveau projet </p><br><pre> <code class="plaintext hljs">$ npm init</code> </pre> <br><p>  Ici, vous pouvez sp√©cifier le nom du projet ( <strong>nom du package</strong> ), le nom du fichier pour entrer dans l'application ( <strong>point d'entr√©e</strong> ) et le nom de l'auteur ( <strong>auteur</strong> ).  Pour toutes les autres demandes, nous acceptons les param√®tres par d√©faut: nous n'entrons rien et nous n'appuyons que sur <strong>Entr√©e</strong> .  √Ä la fin - appuyez sur <strong>y</strong> et sur <strong>Entr√©e</strong> . </p><br><p>  Ensuite, installez les cadres n√©cessaires au travail.  Express pour cr√©er un serveur et Puppeteer pour travailler avec un navigateur. </p><br><pre> <code class="plaintext hljs">$ npm install express $ npm i puppeteer</code> </pre> <br><p>  Par cons√©quent, le fichier de configuration du projet <strong>package.json</strong> appara√Æt dans le dossier du projet.  Dans mon cas, ceci: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapshoter_habr"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"nnngrach"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.17.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"puppeteer"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.18.1"</span></span> } }</code> </pre> <br><p>  J'ajouterai la ligne de d√©part √† la section des scripts pour lancer notre application plus facilement. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> },</code> </pre> <br><p>  Cr√©ez maintenant deux fichiers avec l'impl√©mentation de la fonctionnalit√© de base.  Le premier fichier est le point d'entr√©e de l'application.  Dans mon cas, <strong>router.js</strong> .  Il va cr√©er un serveur et faire du routage. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const express = require( 'express' ) const mapshoter = require( './mapshoter' ) //  ,       const PORT = process.env.PORT || 5000 //     const app = express() app.listen( PORT, () =&gt; { console.log( '    ', PORT ) }) //       // http://siteName.com/x/y/z app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { //      const x = req.params.x const y = req.params.y const z = req.params.z //      const screenshot = await mapshoter.makeTile( x, y, z ) //        const imageBuffer = Buffer.from( screenshot, 'base64' ) //    res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) //    res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Cr√©ez maintenant un deuxi√®me fichier.  Il contr√¥lera le navigateur et prendra des captures d'√©cran.  Je l'ai appel√© <strong>mapshoter.js</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   const browser = await puppeteer.launch() //       const page = await browser.newPage() await page.goto( 'https://www.google.ru/' ) //    const screenshot = await page.screenshot() //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Ex√©cutez notre script et v√©rifiez ses performances.  Pour ce faire, tapez dans la console: </p><br><p> <code>$ npm start</code> </p> <br><p>  Un message appara√Æt qui dit "Le serveur est cr√©√© sur le port 5000".  Ouvrez maintenant un navigateur sur votre ordinateur et acc√©dez √† l'adresse locale de notre serveur.  Au lieu des coordonn√©es <strong>x, y, z,</strong> vous pouvez saisir n'importe quel nombre.  J'ai entr√© 1, 2, 3. </p><br><p> <code>http://localhost:5000/1/2/3</code> </p> <br><p>  Si tout est fait correctement, une capture d'√©cran du site Google appara√Ætra. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66a/8db/ca5/66a8dbca5b15566f395ec6bf4163279c.png" alt="image"></p><br><p>  Appuyez sur Ctrl + C dans la console pour arr√™ter notre script. </p><br><p>  F√©licitations, la base de notre application est pr√™te!  Nous avons cr√©√© un serveur qui accepte nos requ√™tes html, prend une capture d'√©cran et nous renvoie une image.  Il est maintenant temps de passer √† la mise en ≈ìuvre des d√©tails. </p><br><h3 id="rasschitaem-koordinaty">  Calculez les coordonn√©es </h3><br><p>  L'id√©e est que le navigateur ouvre un site avec une carte et entre les coordonn√©es de l'endroit dont nous avons besoin dans la barre de recherche.  Apr√®s avoir cliqu√© sur le bouton "Rechercher", cet endroit sera exactement au centre de l'√©cran.  Il sera donc facile de d√©couper la zone dont nous avons besoin. </p><br><p>  Mais d'abord, vous devez calculer les coordonn√©es du centre de la tuile en fonction de son num√©ro de s√©rie.  Je vais le faire en fonction de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">formule</a> pour trouver le coin sup√©rieur gauche.  Je l'ai mis dans la fonction <strong>getCoordinates ()</strong> . </p><br><p>  Et puisque pour certains sites, en plus du centre de la tuile, vous devez √©galement sp√©cifier ses bordures, je les rechercherai √©galement.  Eh bien, cr√©ons un module s√©par√© pour ces calculs sous le nom <strong>geoTools.js</strong> .  Voici son code: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   function getCoordinates( x, y, z ) { const n = Math.pow( 2, z ) const lon = x / n * 360.0 - 180.0 const lat = 180.0 * ( Math.atan( Math.sinh( Math.PI * ( 1 - 2 * y / n) ) ) ) / Math.PI return { lat: lat, lon: lon } } //          function getCenter( left, rigth, top, bottom ) { let lat = ( left + rigth ) / 2 let lon = ( top + bottom ) / 2 return { lat: lat, lon: lon } } //        function getAllCoordinates( stringX, stringY, stringZ ) { //      const x = Number( stringX ) const y = Number( stringY ) const z = Number( stringZ ) //     //    -  -  const topLeft = getCoordinates( x, y, z ) const bottomRight = getCoordinates( x+1, y+1, z ) //   const center = getCenter( topLeft.lat, bottomRight.lat, topLeft.lon, bottomRight.lon ) //   const bBox = { latMin: bottomRight.lat, lonMin: topLeft.lon, latMax: topLeft.lat, lonMax: bottomRight.lon } return { bBox: bBox, center: center } } module.exports.getAllCoordinates = getAllCoordinates</span></span></code> </pre> <br><p>  Nous sommes maintenant pr√™ts √† commencer √† impl√©menter le script pour travailler avec le navigateur.  Examinons quelques sc√©narios sur la fa√ßon dont cela peut √™tre fait. </p><br><h3 id="scenariy-1--poisk-s-pomoschyu-api">  Sc√©nario 1 - Recherche d'API </h3><br><p>  Commen√ßons par le cas le plus simple lorsque vous pouvez simplement entrer les coordonn√©es dans l'URL de la page de la carte.  Par exemple, comme ceci: </p><br><p> <code>https://nakarte.me/#m=5/50.28144/89.30666&amp;l=O/Wp</code> </p> <br><p>  Regardons le script.  Remplacez, supprimez tout le contenu du fichier <strong>mapshoter.js</strong> et collez le code ci-dessous. </p><br><p>  Dans cette version, lors du d√©marrage du navigateur, nous sp√©cifions des param√®tres suppl√©mentaires qui lui permettront de d√©marrer et de fonctionner sur des serveurs Linux, tels que Heroku.  De plus, nous allons maintenant r√©duire la taille de la fen√™tre afin que le moins de tuiles de carte possible tiennent sur l'√©cran.  Ainsi, nous augmentons la vitesse de chargement des pages. </p><br><p>  Ensuite, nous calculons les coordonn√©es du centre de la tuile souhait√©e.  Nous les collons dans l'URL et cliquons dessus.  La tuile appara√Æt exactement au centre de l'√©cran.  Coupez un morceau de 256x256 pixels.  Ce sera la tuile dont nous avons besoin.  Il ne reste plus qu'√† le rendre √† l'utilisateur. </p><br><p>  Avant de passer au code, je note que pour plus de clart√©, toute la gestion des erreurs a √©t√© supprim√©e du script. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    Heroku const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) //        //       const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) //         URL const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" //   URL  ,    await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //    const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Maintenant, ex√©cutez notre script et consultez la carte de cette section. </p><br><p> <code>http://localhost:5000/24/10/5</code> </p> <br><p>  Si tout est fait correctement, le serveur doit retourner une telle tuile: </p><br><p><img src="https://habrastorage.org/webt/gg/t5/gr/ggt5grzq5iuw26bjt2zdhckeoic.png"></p><br><p>  Pour nous assurer de ne rien m√©langer lors du recadrage, comparez notre mosa√Øque avec l'original d'OpenStreetMaps.org </p><br><p><img src="https://habrastorage.org/webt/32/kp/fs/32kpfsblzjzrx3c16ap3gjpfgx4.png"></p><br><h3 id="scenariy-2--poisk-s-pomoschyu-interfeysa-sayta">  Sc√©nario 2 - Recherche √† l'aide de l'interface du site </h3><br><p>  Cependant, il n'est pas toujours possible de contr√¥ler une carte via une ligne de navigateur.  Eh bien, dans de tels cas, notre script se comportera comme un v√©ritable utilisateur vivant.  Il imprimera les coordonn√©es dans la zone de recherche et cliquera sur le bouton Rechercher.  Apr√®s cela, il supprimera le marqueur du point trouv√©, qui appara√Æt g√©n√©ralement au centre de l'√©cran.  Et puis il cliquera sur les boutons pour augmenter ou diminuer l'√©chelle jusqu'√† ce qu'il atteigne celui souhait√©.  Ensuite, il prendra une capture d'√©cran et la renverra √† l'utilisateur. </p><br><p>  Je note qu'en g√©n√©ral, apr√®s la recherche, la m√™me √©chelle est d√©finie.  15e, par exemple.  Dans notre exemple, cela ne se produit pas toujours.  Par cons√©quent, nous reconna√Ætrons le niveau de zoom √† partir des param√®tres des √©l√©ments html sur la page. </p><br><p>  Dans cet exemple √©galement, nous rechercherons des √©l√©ments d'interface √† l'aide de s√©lecteurs XPath.  Mais comment les reconnaissez-vous? </p><br><p>  Pour ce faire, ouvrez la page requise dans le navigateur et ouvrez la barre d'outils d√©veloppeur ( <strong>Ctll + Alt + I</strong> pour Google Chrome).  Appuyez sur le bouton pour s√©lectionner les √©l√©ments.  Nous cliquons sur l'√©l√©ment qui vous int√©resse (j'ai cliqu√© sur le champ de recherche). </p><br><p><img src="https://habrastorage.org/webt/rb/wu/37/rbwu37fuodlucpg4q_xqfsfk-my.png"></p><br><p>  La liste des √©l√©ments d√©file jusqu'√† celui sur lequel vous avez cliqu√© et elle est surlign√©e en bleu.  Cliquez sur le bouton avec trois points √† gauche du nom. </p><br><p>  Dans le menu contextuel, s√©lectionnez Copier.  Ensuite, si vous avez besoin d'un s√©lecteur standard, cliquez sur <strong>Copier le s√©lecteur</strong> .  Mais pour le m√™me exemple, nous utiliserons l'√©l√©ment <strong>Copy XPath</strong> . </p><br><p><img src="https://habrastorage.org/webt/p9/wo/t-/p9wot-lbr6ho7ttgvmsb9yrfica.png"></p><br><p>  Remplacez maintenant le contenu du fichier <strong>mapshoter.js</strong> par ce code.  Dans ce document, j'ai d√©j√† collect√© des s√©lecteurs pour tous les √©l√©ments d'interface n√©cessaires. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const searchFieldXPath = '//*[@id="map"]/div[1]/div[1]/div/input' const zoomPlusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[1]' const zoomMinusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[2]' const directionButonXPath = '//*[@id="gtm-poi-card-get-directions"]' const deletePinButonXPatch = '//*[@id="map"]/div[1]/div/div/div[1]/div[2]/div/div[4]/div/div[4]' //         () const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `lat=${coordinates.center.lat} lng=${coordinates.center.lon}` //      const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) const page = await browser.newPage() await page.setViewport( { width: 1100, height: 450 } ) //         const pageUrl = 'https://www.waze.com/en/livemap?utm_campaign=waze_website' await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //    ,      await click( searchFieldXPath, page ) //        await page.keyboard.type( centerCoordinates ) //  Enter    page.keyboard.press( 'Enter' ); //  500     await page.waitFor( 500 ) //       //       await click( directionButonXPath, page ) await page.waitFor( 100 ) await click( deletePinButonXPatch, page ) await page.waitFor( 100 ) //       //        while( z &gt; await fetchCurrentZoom( page )) { await click( zoomPlusXPath, page ) await page.waitFor( 300 ) } while( z &lt; await fetchCurrentZoom( page )) { await click( zoomMinusXPath, page ) await page.waitFor( 300 ) } //    const cropOptions = { fullPage: false, clip: { x: 422, y: 97, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await browser.close() return screenshot } //  : //        async function click( xPathSelector, page ) { await page.waitForXPath( xPathSelector ) const foundedElements = await page.$x( xPathSelector ) if ( foundedElements.length &gt; 0 ) { await foundedElements[0].click() } else { throw new Error( "XPath element not found: ", xPathSelector ) } } //         html  async function fetchCurrentZoom( page ) { const xPathSelector = '//*[@id="map"]/div[2]' await page.waitForXPath( xPathSelector ) const elems = await page.$x(xPathSelector) const elementParams = await page.evaluate((...elems) =&gt; { return elems.map(e =&gt; e.className); }, ...elems); const zoom = elementParams[0].split('--zoom-').pop() return zoom } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Ex√©cutez notre script et suivez le lien.  Si tout est fait correctement, le script nous renverra quelque chose comme cette tuile. </p><br><p> <code>http://localhost:5000/1237/640/11</code> </p> <br><p><img src="https://habrastorage.org/webt/3c/oo/0l/3coo0lmxp12svhu_m16vecfbjsw.png"></p><br><h3 id="optimizaciya">  Optimisation </h3><br><p>  En principe, les deux m√©thodes d√©crites ci-dessus suffisent pour se connecter √† de nombreux sites avec des cartes vectorielles.  Mais si vous avez soudainement besoin d'acc√©der √† une nouvelle carte, vous n'aurez qu'√† modifier l√©g√®rement le script dans le fichier mapshoter.js.  Autrement dit, cette m√©thode facilite l'ajout de nouvelles cartes.  Cela vient de ses avantages. </p><br><p>  Mais il y a aussi des inconv√©nients.  Et le principal est la vitesse de travail.  Il suffit de comparer.  En moyenne, il faut environ 0,5 seconde pour t√©l√©charger une tuile raster ordinaire.  La r√©ception d'une tuile de notre script prend actuellement environ 8 secondes. </p><br><p>  Mais ce n‚Äôest pas tout!  Nous utilisons le n≈ìud js √† un seul thread et nos longues requ√™tes finiront par bloquer le thread principal, qui de l'ext√©rieur ressemblera √† une file d'attente synchrone r√©guli√®re.  Et lorsque nous essayons de t√©l√©charger la carte pour tout l'√©cran (sur lequel, par exemple, 24 tuiles sont plac√©es), c'est qu'il y a un risque de rencontrer un probl√®me. </p><br><p>  Et encore une chose.  Certains navigateurs ont un timeout: ils arr√™teront le chargement apr√®s 30 secondes.  Et cela signifie qu'avec l'impl√©mentation actuelle, seulement 3-4 tuiles auront le temps de se charger.  Eh bien, voyons ce que nous pouvons y faire. </p><br><p>  Le moyen le plus √©vident est probablement d'augmenter simplement le nombre de serveurs sur lesquels notre script s'ex√©cutera.  Par exemple, si nous avons 10 serveurs, ils auront le temps de traiter les tuiles pour l'ensemble de l'√©cran en 30 secondes.  (Si vous ne voulez pas payer beaucoup d'argent, vous pouvez l'obtenir en enregistrant plusieurs comptes gratuits sur Heroku) </p><br><p>  Deuxi√®mement, il est toujours possible d'impl√©menter le multithreading sur le n≈ìud js en utilisant le module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">worker_threads</a> .  Selon mes observations, sur un serveur avec un processeur monoc≈ìur sur un compte Heroku gratuit, j'arrive √† d√©marrer trois threads.  Trois flux avec un navigateur s√©par√© dans chacun, qui peuvent fonctionner simultan√©ment sans se bloquer.  En toute honn√™tet√©, je note qu'en raison de la charge accrue sur le processeur, la vitesse de t√©l√©chargement d'une tuile a m√™me l√©g√®rement augment√©.  Cependant, si vous essayez de t√©l√©charger une carte pour tout l'√©cran, au bout de 30 secondes, plus de la moiti√© de la carte aura le temps de se charger.  Plus de 12 tuiles.  D√©j√† mieux. </p><br><p>  Troisi√®mement.  Dans l'impl√©mentation actuelle du script, √† chaque demande, nous passons du temps √† t√©l√©charger le navigateur Chrome, puis √† le terminer.  Nous allons maintenant cr√©er un navigateur √† l'avance et transf√©rer un lien vers celui-ci dans mapshoter.js.  Par cons√©quent, la vitesse ne changera pas pour la premi√®re demande.  Mais pour toute vitesse de t√©l√©chargement ult√©rieure d'une tuile est r√©duite √† 4 secondes.  Et apr√®s 30 secondes, toute la carte a le temps de se charger - les 24 tuiles qui sont plac√©es sur mon √©cran. </p><br><p>  Eh bien, si vous impl√©mentez tout cela, le script peut devenir tout √† fait viable.  Commen√ßons donc.  Pour un travail plus simple avec le multithreading, j'utiliserai le module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">node-worker-threads-pool</a> - une sorte de wrapper sur worker_threads.  Installons-le. </p><br><p> <code>$ npm install node-worker-threads-pool --save</code> </p> <br><p>  Corrigez le fichier router.js.  Ajoutez-y la cr√©ation d'un pool de threads.  Les fils seront de 3 pi√®ces.  Leur code sera d√©crit dans le fichier <strong>worker.js</strong> , nous le verrons plus tard.  En attendant, supprimez directement le lancement du module de capture d'√©cran.  Au lieu de cela, nous ajouterons une nouvelle t√¢che au pool de threads.  Ils commenceront √† le traiter lorsque l'un des threads sera lib√©r√©. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-comment"><span class="hljs-comment">//   . const { StaticPool } = require( 'node-worker-threads-pool' ) const worker = "./worker.js" const workersPool = new StaticPool({ size: 3, task: worker, workerData: "no" }) app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z //       //       const screenshot = await workersPool.exec( { x, y, z } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Jetez maintenant un ≈ìil au fichier <strong>worker.js</strong> .  Chaque fois qu'une nouvelle t√¢che <strong>arrive, la</strong> m√©thode <strong>parentPort.on ()</strong> sera lanc√©e.  Malheureusement, il ne peut pas g√©rer les fonctions asynchrones / attendent.  Nous allons donc utiliser la fonction adaptateur sous la forme de la m√©thode <strong>doMyAsyncCode ()</strong> . </p><br><p>  Dans celui-ci dans un format lisible pratique, nous mettrons la logique du travailleur.  Autrement dit, lancez le navigateur (s'il n'est pas d√©j√† en cours d'ex√©cution) et activez la m√©thode pour prendre une capture d'√©cran.  Au d√©marrage, nous transmettrons √† cette m√©thode un lien vers le navigateur en cours d'ex√©cution. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//     var browser = "empty" //         //    ,     parentPort.on( "message", ( params ) =&gt; { doMyAsyncCode( params ) .then( ( result) =&gt; { parentPort.postMessage( result ) }) }) //  ,    async/aswit //     async function doMyAsyncCode( params ) { //      await prepareEnviroment() //     const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, browser ) return screenshot } //  .     ,    async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  Pour plus de clart√©, revenons √† la premi√®re version de <strong>mapshoter.js</strong> .  Cela ne changera pas grand-chose.  Maintenant, dans les param√®tres d'entr√©e, il acceptera un lien vers le navigateur, et lorsque le script se terminera, il ne d√©sactivera pas le navigateur, mais fermera simplement l'onglet cr√©√©. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const browser = await browserLink //      const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   .   . await page.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  En principe, c'est tout.  Vous pouvez maintenant t√©l√©charger le r√©sultat sur le serveur de la mani√®re qui vous convient.  Par exemple, via docker.  Si vous souhaitez consulter le r√©sultat final, vous pouvez cliquer sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ce lien</a> .  Vous pouvez √©galement trouver le code de projet complet sur mon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">GitHub</a> . </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Maintenant, √©valuons le r√©sultat.  D'une part, m√™me malgr√© toutes les astuces effectu√©es, la vitesse de t√©l√©chargement est toujours tr√®s faible.  De plus, √† cause des freins, une telle carte est tout simplement d√©sagr√©able √† faire d√©filer. </p><br><p>  D'autre part, ce script fait n√©anmoins face √† des cartes qui auparavant, il √©tait g√©n√©ralement impossible de se connecter au navigateur sur le smartphone.  Il est peu probable que cette solution soit appliqu√©e comme m√©thode principale d'obtention des donn√©es cartographiques.  Mais ici comme une suppl√©mentaire, √† l'aide de laquelle, si n√©cessaire, il sera possible d'ouvrir une carte exotique - c'est tout √† fait possible. </p><br><p>  De plus, les avantages de ce script incluent le fait qu'il est facile de travailler avec lui.  C'est facile √† √©crire.  Et, plus important encore, il peut √™tre extr√™mement facilement refait pour connecter n'importe quelle autre carte en ligne. </p><br><p>  Eh bien, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le prochain article,</a> je traiterai juste de cela.  Je vais transformer le script en une sorte d'API pour travailler avec la carte interactive OverpassTurbo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461053/">https://habr.com/ru/post/fr461053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461043/index.html">La gestion des conflits en √©quipe - un √©quilibre ou une n√©cessit√© vitale?</a></li>
<li><a href="../fr461045/index.html">Obtenez un extrait de Rosreestr via FSIS USRN et python. Partie 1</a></li>
<li><a href="../fr461047/index.html">√âcrire ou ne pas √©crire. Lettres aux autorit√©s lors des √©v√©nements</a></li>
<li><a href="../fr461049/index.html">ONYX BOOX Faust - Celui qui cherche n'est pas oblig√© d'errer</a></li>
<li><a href="../fr461051/index.html">Top 10 des erreurs les plus courantes que j'ai rencontr√©es dans les projets Go</a></li>
<li><a href="../fr461055/index.html">Rekko Challenge 2019: comment c'√©tait</a></li>
<li><a href="../fr461057/index.html">Cha√Ænes de t√©l√©gramme sur le d√©veloppement de jeux</a></li>
<li><a href="../fr461059/index.html">√âcrire une application Android pour les fans de films - Partie 1 (Prototypage)</a></li>
<li><a href="../fr461061/index.html">Alliages de magn√©sium, fronti√®res jumelles et s√©gr√©gation</a></li>
<li><a href="../fr461063/index.html">Interaction de R avec des bases de donn√©es sur l'exemple de Microsoft SQL Server et d'autres SGBD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>