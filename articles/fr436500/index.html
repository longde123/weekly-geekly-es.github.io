<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😵 👎 🙅 Comment le cadre de Rise of the Tomb Raider est rendu 😝 👩🏼‍🏭 📢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rise of the Tomb Raider (2015) est la suite de l'excellent redémarrage de Tomb Raider (2013). Personnellement, je trouve les deux parties intéressante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment le cadre de Rise of the Tomb Raider est rendu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436500/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1k/5p/s6/1k5ps6qnv2soku_ymxsemz7wnxa.gif"></div><br>  Rise of the Tomb Raider (2015) est la suite de l'excellent redémarrage de Tomb Raider (2013).  Personnellement, je trouve les deux parties intéressantes parce qu'elles s'éloignent de la série originale stagnante et racontent à nouveau l'histoire de Lara.  Dans ce jeu, comme dans la préquelle, l'intrigue occupe le devant de la scène, elle fournit des mécanismes fascinants d'artisanat, de chasse et d'escalade / recherche. <br><br>  Tomb Raider a utilisé Crystal Engine, développé par Crystal Dynamics, également utilisé dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deus Ex: Human Revolution</a> .  La suite a utilisé un nouveau moteur appelé Foundation, précédemment développé pour Lara Croft et le Temple d'Osiris (2014).  Son rendu peut généralement être décrit comme un moteur de tuile avec un passage d'éclairage préalable, et nous verrons plus tard ce que cela signifie.  Le moteur vous permet de choisir entre les moteurs de rendu DX11 et DX12;  J'ai choisi ce dernier, pour les raisons que nous discutons ci-dessous.  Pour capturer le cadre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Renderdoc</a> 1.2 a été utilisé sur la Geforce 980 Ti, le jeu comprend toutes les fonctions et décorations. <br><br><h2>  Trame analysée </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/254/df9/0bb/254df90bbbfd5498710f37624e12d1f4.jpg"></div><br>  Pour éviter les spoilers, je dirai que dans ce cadre, les méchants poursuivent Lara, car elle cherche un artefact qu'ils recherchent.  Ce conflit d'intérêts ne peut être résolu sans armes.  Lara s'est faufilée dans la base ennemie la nuit.  J'ai choisi un cadre avec un éclairage d'ambiance et de contraste, dans lequel le moteur peut se montrer. <a name="habracut"></a><br><br><h4>  Avance en profondeur </h4><br>  Ici, l'optimisation habituelle pour de nombreux jeux est effectuée - une petite passe préliminaire de la profondeur (environ 100 appels de tirage).  Le jeu affiche les plus gros objets (et non ceux qui occupent plus d'espace sur l'écran) pour profiter des fonctionnalités du processeur vidéo Early-Z.  En savoir plus à ce sujet dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article Intel</a> .  En bref, les GPU peuvent éviter d'exécuter un pixel shader s'ils peuvent déterminer qu'il est chevauché par le pixel précédent.  Il s'agit d'un passage assez peu coûteux, préremplissant le tampon Z avec des valeurs de profondeur. <br><br>  À ce stade, j'ai découvert une technique intéressante de niveau de détail (LOD) appelée «fizzle» ou «damier».  Il s'agit d'un moyen courant d'afficher ou de masquer progressivement des objets à distance, afin qu'ils puissent ensuite être remplacés par un maillage de qualité inférieure ou les masquer complètement.  Regardez ce camion.  Il semble qu'il effectue un rendu deux fois, mais en fait, il effectue un rendu avec un LOD élevé et un LOD faible dans la même position.  Chacun des niveaux rend les pixels que l'autre n'a pas rendus.  Le premier LOD a 182226 sommets, et le second LOD a 47250. À une grande distance, ils sont indiscernables, mais l'un d'eux est trois fois moins cher.  Dans ce cadre, le LOD 0 disparaît presque et le LOD 1 est presque entièrement rendu.  Après la disparition complète de LOD 0, seul LOD 1 sera rendu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/d8d/24e/c31d8d24e58229c27fb4edf6f635974d.png"></div><br>  <i>LOD 0</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/3b4/5bb/7bf3b45bbe13521b4bae010f72a702a7.png"></div><br>  <i>LOD 1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/7r/it/jy7rit_bwqm4n0lwpzzlydyx5rs.gif"></div><br>  La texture pseudo-aléatoire et le coefficient de probabilité nous permettent d'éliminer les pixels qui n'ont pas dépassé la valeur seuil.  Cette texture est utilisée dans ROTR.  On peut se demander pourquoi le mélange alpha n'est pas utilisé.  Le mélange alpha présente de nombreux inconvénients par rapport à la décoloration pétillante. <br><br><ol><li>  <strong>Commodité pour le passage préliminaire des profondeurs:</strong> grâce au rendu d'un objet opaque avec des trous pratiqués, nous pouvons effectuer le rendu dans le passage préliminaire et utiliser early-z.  Les objets avec un mélange alpha à un stade aussi précoce ne seront pas rendus dans le tampon de profondeur en raison de problèmes de tri. </li><li>  <strong>Le besoin de shaders supplémentaires</strong> : si un rendu différé est utilisé, le shader des objets opaques ne contient aucun éclairage.  Si vous devez remplacer un objet opaque par un objet transparent, vous avez besoin d'une option distincte dans laquelle il y a de l'éclairage.  En plus d'augmenter la quantité de mémoire nécessaire et la complexité due à au moins un shader supplémentaire pour tous les objets opaques, ils doivent être précis afin d'éviter que les objets avancent.  C'est compliqué pour de nombreuses raisons, mais tout se résume au fait que le rendu est désormais effectué dans un chemin de code différent. </li><li>  <strong>Redessins plus importants</strong> : le mélange alpha peut créer de grands redessins et, à un certain niveau de complexité des objets, une grande partie de la bande passante peut être nécessaire pour ombrer le LOD. </li><li>  <strong>Conflits Z</strong> : les <strong>conflits</strong> Z sont un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effet de scintillement</a> lorsque deux polygones sont rendus à une profondeur très proche l'un de l'autre.  Dans ce cas, l'inexactitude des calculs en virgule flottante les oblige à être rendus tour à tour.  Si nous rendons deux LOD consécutifs, en cachant progressivement un et en montrant le second, alors ils peuvent provoquer un conflit z, car ils sont très proches l'un de l'autre.  Il existe toujours des moyens de contourner ce problème, par exemple en préférant un polygone à un autre, mais un tel système est complexe. </li><li>  <strong>Effets Z-Buffer</strong> : De nombreux effets comme SSAO n'utilisent que le buffer de profondeur.  Si nous rendions des objets transparents à la fin du pipeline alors que l'occlusion ambiante était déjà terminée, nous ne pourrions pas en tenir compte. </li></ol><br>  L'inconvénient de cette technique est qu'elle a l'air pire que le mélange alpha, mais un bon motif de bruit, un flou après fizzle ou un anti-aliasing temporaire peut le cacher presque complètement.  À cet égard, ROTR ne fait rien de particulièrement inhabituel. <br><br><h4>  Passe normale </h4><br>  Crystal Dynamics utilise un modèle d'éclairage plutôt inhabituel dans ses jeux, que nous couvrirons dans l'allée d'éclairage.  Pour l'instant, il suffit de dire que le moteur n'a pas de passe G-buffer;  au moins dans la mesure où cela est familier dans d'autres jeux.  Sur ce passage, les objets transmettent uniquement des informations sur la profondeur et les normales à la sortie.  Les normales sont enregistrées dans la cible de rendu du format RGBA16_SNORM dans l'espace universel.  Il est curieux que ce moteur utilise le schéma Z-up, pas le Y-up (l'axe Z est dirigé vers le haut, pas l'axe Y), qui est plus souvent utilisé dans d'autres moteurs / packages de modélisation.  Le canal alpha contient de la brillance, qui est ensuite décompressée en <code>exp2(glossiness * 12 + 1.0)</code> .  La valeur de brillance peut également être négative, car le signe est utilisé comme indicateur indiquant si la surface est métallique.  Cela peut être remarqué par lui-même, car toutes les couleurs sombres du canal alpha sont liées à des objets métalliques. <br><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="0000ff">B</font></strong> </td><td></td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal.y</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <b>Brillance + Metalness</b> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/209/484/1e8209484fe730d178c4afffef4c8f93.jpg"></div><br>  <i>Normal</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/dd3/b2d/8fbdd3b2d2ddbce3111a4c017e7daef3.jpg"></div><br>  <i>Brillance / métal</i> <br><br>  <strong>Avantages du départ</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/b15/52b/aa1b1552b0f81c2122d094441e531f3f.jpg"></div><br>  Rappelez-vous que dans la section «Profondeur préliminaire», nous avons parlé d'économiser les coûts en pixels?  Je vais revenir un peu en arrière pour l'illustrer.  Prenez l'image suivante.  Cela rend la partie détaillée de la montagne dans le tampon normal.  Renderdoc a gentiment mis en évidence les pixels qui ont réussi le test de profondeur avec du vert et ceux qui ne l'ont pas passé avec du rouge (ils ne seront pas rendus).  Le nombre total de pixels qui seraient rendus sans cette passe préliminaire est approximativement égal à 104518 (calculé dans Photoshop).  Le nombre total de pixels réellement rendus est de 23858 (calculé par Renderdoc).  Économisez environ 77%!  Comme on le voit, avec une utilisation intelligente, cette passe préliminaire peut donner un gros gain, et elle ne nécessite qu'une centaine d'appels de tirage. <br><br>  <strong>Enregistrement de commandes multithread</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/5d0/623/9195d06236fd6247cea6e6065f05e9e8.png"></div><br>  Il convient de noter un aspect intéressant, à cause duquel j'ai choisi le rendu DX12 - l'enregistrement de commandes multi-thread.  Dans les API précédentes, telles que DX11, le rendu est généralement effectué dans un seul thread.  Le pilote graphique a reçu des commandes de rendu du jeu et a constamment transmis des demandes de GPU, mais le jeu ne savait pas quand cela se produirait.  Cela conduit à l'inefficacité, car le pilote doit en quelque sorte deviner ce que l'application essaie de faire, et ne s'adapte pas à plusieurs threads.  Les API plus récentes telles que DX12 confient le contrôle à un développeur qui peut décider comment écrire des commandes et quand les envoyer.  Bien que Renderdoc ne puisse pas montrer comment l'enregistrement est effectué, vous verrez qu'il y a sept passes de couleur marquées comme Color Pass N, et chacune d'entre elles est enveloppée dans une paire de ExecuteCommandList: Reset / Close.  Il marque le début et la fin de la liste des commandes.  La liste représente environ 100-200 appels de tirage.  Cela ne signifie pas qu'ils ont été enregistrés à l'aide de plusieurs flux, mais y fait allusion. <br><br>  <strong>Empreintes de pas dans la neige</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/d21/2e8/ca6d212e89b61f52738dfbd01363e366.jpg"></div><br>  Si vous regardez Lara, vous pouvez voir qu'en se déplaçant devant la capture d'écran, elle a laissé des traces dans la neige.  Dans chaque cadre, un shader de calcul est exécuté, qui enregistre les déformations dans certaines zones et les applique en fonction du type et de la hauteur de la surface.  Ici, seule la carte normale est appliquée à la neige (c'est-à-dire que la géométrie ne change pas), mais dans certaines zones où la neige est plus épaisse, la déformation est en fait effectuée!  Vous pouvez également voir comment la neige "tombe" en place et remplit les traces laissées par Lara.  Cette technique est décrite de manière beaucoup plus détaillée dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GPU Pro 7</a> .  La texture de la chaîne de neige est une sorte de carte d'élévation qui suit les mouvements de Lara et collée sur les bords afin que le shader d'échantillonnage puisse profiter de ce pliage. <br><br><h4>  Atlas des ombres </h4><br>  Lors de la création du mappage des ombres, une approche assez courante est utilisée - regroupant autant de cartes d'ombre que possible dans une texture d'ombre commune.  Un tel atlas d'ombres est en fait une énorme texture 16 bits avec une taille de 16384 × 8196.  Cela vous permet de réutiliser et de mettre à l'échelle de manière très flexible les cartes d'ombre dans l'atlas.  Dans le cadre que nous analysons, 8 cartes d'ombre sont enregistrées dans l'atlas.  Quatre d'entre eux concernent la principale source d'éclairage directionnel (la lune, car elle se produit la nuit), car ils utilisent des cartes d'ombres en cascade - une technique assez standard d'ombres à longue distance pour l'éclairage directionnel, que j'ai déjà expliqué un peu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus tôt</a> .  Plus intéressant, plusieurs sources de projection et de projecteur sont également incluses dans la capture de cette image.  Le fait que 8 plans d'ombre soient enregistrés dans ce cadre ne signifie pas qu'il n'y a que 8 sources de projection d'éclairage d'ombre.  Le jeu peut mettre en cache les calculs d'ombre, c'est-à-dire que l'éclairage qui n'a pas changé la position de la source ou la géométrie dans la portée ne doit pas mettre à jour sa carte d'ombre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/8d9/169/f008d9169bd3490c26f923bcc4ea8e85.jpg"></div><br>  Il semble que le rendu des mappages d'ombre profite également de l'écriture de commandes multithread dans la liste, et dans ce cas, jusqu'à 19 listes de commandes ont été écrites pour le rendu des mappages d'ombre. <br><br>  <strong>Ombres de l'éclairage directionnel</strong> <br><br>  Les ombres de l'éclairage directionnel sont calculées avant le passage de l'éclairage et ensuite échantillonnées.  Je ne sais pas ce qui se passerait s'il y avait plusieurs sources d'éclairage directionnel dans la scène. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/209/845/cef209845628db5e68588f07880542eb.jpg"></div><br><h4>  Occlusion ambiante </h4><br>  Pour l'occlusion ambiante, ROTR vous permet d'utiliser soit HBAO soit une variante de HBAO + (cette technique a été initialement publiée par NVIDIA).  Il existe plusieurs variantes de cet algorithme, je vais donc considérer celui que j'ai trouvé dans ROTR.  Tout d'abord, le tampon de profondeur est divisé en 16 textures, chacune contenant 1/16 de toutes les valeurs de profondeur.  La séparation est effectuée de manière à ce que chaque texture contienne une valeur d'un bloc 4 × 4 de la texture d'origine illustrée dans la figure ci-dessous.  La première texture contient toutes les valeurs marquées en rouge (1), la seconde contient les valeurs marquées en bleu (2), etc.  Si vous souhaitez en savoir plus sur cette technique, voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Louis Bavoil</a> , qui était également l'un des auteurs de l'article sur HBAO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c9/2dc/60f/1c92dc60fe369caed766efe18dd2739d.png"></div><br>  L'étape suivante calcule l'occlusion ambiante pour chaque texture, ce qui nous donne 16 textures AO.  Une occlusion ambiante est générée comme suit: le tampon de profondeur est échantillonné plusieurs fois, recréant la position et accumulant le résultat du calcul pour chacun des échantillons.  Chaque texture d'occlusion ambiante est calculée en utilisant différentes coordonnées d'échantillonnage, c'est-à-dire que dans un bloc de pixels 4x4, chaque pixel raconte sa propre partie de l'histoire.  Cette opération est effectuée pour des raisons de performances.  Chaque pixel échantillonne déjà 32 fois le tampon de profondeur, et le plein effet nécessitera 16 × 32 = 512 échantillons, ce qui est un buste même pour les GPU les plus puissants.  Ensuite, ils se recombinent en une seule texture plein écran, ce qui s'avère assez bruyant, donc pour lisser les résultats juste après cela, une passe de flou plein écran est effectuée.  Nous avons vu une solution très similaire dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shadow of Mordor</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/e57/dd8/25fe57dd8001f561e9a971b36b57085e.png" alt="image"></div><br>  <i>Pièces HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/e1b/7d0/113e1b7d065a25b8f4dfb8dce29c808c.png" alt="image"></div><br>  <i>HBAO complet avec bruit</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/bfe/cd1/063bfecd15cdf8d62a0b6221fddfe4ee.png" alt="image"></div><br>  <i>Flou horizontal complet HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/af9/8e2/51daf98e295b549a57089b4d17df1975.png" alt="image"></div><br>  <i>Prêt HBAO</i> <br><br><h4>  Pré-passage d'éclairage carrelé </h4><br>  Le Light Prepass est une technique assez inhabituelle.  La plupart des équipes de développement utilisent une combinaison de calcul d'éclairage différé + direct (avec des variations, par exemple, avec une tuile, un cluster) ou complètement direct pour certains effets de l'espace d'écran.  La technique de pré-éclairage est si inhabituelle qu'elle mérite une explication.  Si le concept d'éclairage différé traditionnel consiste à séparer les propriétés des matériaux de l'éclairage, alors l'idée de séparer l'éclairage des propriétés des matériaux est la pierre angulaire du passage préliminaire de l'éclairage.  Bien que cette formulation semble un peu idiote, la différence par rapport à l'éclairage différé traditionnel est que nous stockons toutes les propriétés des matériaux (tels que l'albédo, la couleur spéculaire, la rugosité, la métallicité, la micro-occlusion, l'émissif) dans un énorme tampon G, et l'utiliser plus tard comme données d'entrée pour les passages d'éclairage ultérieurs.  L'éclairage différé traditionnel peut présenter une charge importante sur le débit;  plus les matériaux sont complexes, plus il faut d'informations et d'opérations dans le G-buffer.  Cependant, dans la passe d'éclairage préliminaire, nous accumulons d'abord tout l'éclairage séparément, en utilisant le minimum de données, puis les appliquons dans les passes suivantes aux matériaux.  Dans ce cas, l'éclairage n'est suffisant que pour les normales, la rugosité et la métallité.  Les shaders (deux passes sont utilisées ici) produisent des données dans trois formats de rendu RGBA16F cibles.  L'une contient un éclairage diffus, la seconde contient un éclairage spéculaire et la troisième contient un éclairage ambiant.  À ce stade, toutes les données fantômes sont prises en compte.  Il est curieux que dans la première passe (éclairage diffus + miroir) pour une passe plein écran, un quadrilatère de deux triangles soit utilisé, et dans d'autres effets, un triangle plein écran soit utilisé (pourquoi c'est important, vous pouvez le découvrir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  De ce point de vue, l'ensemble du cadre n'est pas intégral. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/6ba/a3b/41d6baa3b45cc3e0df1423eaf015d416.jpg" alt="image"></div><br>  <i>Éclairage diffus</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/0c5/137/9cd0c513782787daa220b7627b11b28e.jpg" alt="image"></div><br>  <i>Éclairage miroir</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/ed9/cbc/33ded9cbc62470319b7729b542b7e830.jpg" alt="image"></div><br>  <i>Éclairage ambiant</i> <br><br>  <strong>Optimisation des carreaux</strong> <br><br>  L'éclairage en mosaïque est une technique d'optimisation conçue pour restituer un grand nombre de sources lumineuses.  ROTR divise l'écran en carreaux 16 × 16, puis enregistre des informations sur les sources qui coupent chaque carreau, c'est-à-dire que les calculs d'éclairage ne seront effectués que pour les sources liées aux carreaux.  Au début du cadre, une séquence de shaders de calcul est lancée, qui détermine quelles sources se rapportent aux tuiles.  Au stade de l'éclairage, chaque pixel détermine dans quelle tuile il se trouve et boucle à travers chaque source de lumière dans la tuile, effectuant tous les calculs d'éclairage.  Si les sources sont liées aux tuiles de manière efficace, vous pouvez économiser beaucoup de calculs et la majeure partie de la bande passante, ainsi qu'augmenter la productivité. <br><br>  <strong>Zoom en profondeur</strong> <br><br>  Le suréchantillonnage basé sur la profondeur est une technique intéressante utile pour cette passe et les suivantes.  Parfois, les algorithmes coûteux en calcul ne peuvent pas être rendus à pleine résolution, ils sont donc rendus à une résolution inférieure, puis agrandis.  Dans notre cas, l'éclairage ambiant est calculé en demi-résolution, c'est-à-dire qu'après les calculs, l'éclairage doit être correctement recréé.  Dans la forme la plus simple, 4 pixels basse résolution sont pris et interpolés pour obtenir quelque chose ressemblant à l'image d'origine.  Cela fonctionne pour des transitions en douceur, mais ne semble pas bon sur les discontinuités, car là, nous mélangeons des valeurs non liées qui peuvent être adjacentes dans l'espace de l'écran, mais éloignées les unes des autres dans l'espace du monde.  Pour résoudre ce problème, plusieurs échantillons de tampon de profondeur sont généralement prélevés et comparés à l'échantillon de profondeur que nous voulons recréer.  Si l'échantillon est trop éloigné, nous ne le prenons pas en compte lors de la reconstruction.  Un tel schéma fonctionne bien, mais cela signifie que le shader de loisirs est très gourmand en bande passante. <br><br>  ROTR fait un pas délicat avec la suppression précoce du pochoir.  Après avoir passé les normales, le tampon de profondeur est complètement plein, le moteur effectue donc une passe plein écran, marquant tous les pixels interrompus dans le tampon de gabarit.  Lorsque vient le temps de recréer le tampon d'éclairage ambiant, le moteur utilise deux shaders: l'un est très simple pour les zones sans espaces de profondeur, l'autre est plus complexe pour les pixels avec des espaces.  Le premier pochoir supprime les pixels s'ils n'appartiennent pas à la région correspondante, c'est-à-dire qu'il n'y a des coûts que dans les régions nécessaires.  Les images suivantes sont beaucoup plus claires: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/747/912/729/747912729abfecffd281c72e8ca4e258.jpg" alt="image"></div><br>  <i>Éclairage ambiant demi-résolution</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0d/e46/b7e/f0de46b7e19ace552377d1a39d86ed22.png" alt="image"></div><br>  <i>Échelle des profondeurs de l'intérieur</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/354/63b/d6435463b209e7361831b279abcf1ae1.jpg" alt="image"></div><br>  <i>Éclairage ambiant pleine résolution, sans nervures</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/e12/702/db5e1270220121c5ca9c2a9277d519ed.png" alt="image"></div><br>  <i>Augmenter la profondeur des côtes</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/971/5cf/3ea9715cf0c57785d926b0711808b256.jpg" alt="image"></div><br>  <i>Éclairage d'ambiance prêt</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/5d2/128/4a55d2128ab191fb120ca3c1c4310c95.jpg" alt="image"></div><br>  <i>Vue demi-résolution</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd4/eaa/a07/cd4eaaa0719a527bcdd1add09f00597b.jpg" alt="image"></div><br>  <i>Une vue rapprochée de l'image recréée</i> <br><br>  Après un premier passage d'éclairage, la géométrie est transférée sur le convoyeur, mais cette fois, chaque objet échantillonne les textures d'éclairage, la texture d'occlusion ambiante et d'autres propriétés des matériaux que nous n'avons pas écrites dans le G-buffer depuis le début.  C'est bien, car la bande passante est considérablement économisée ici car vous n'avez pas besoin de lire un tas de textures pour les écrire dans un grand G-buffer, puis de les lire / décoder à nouveau.  L'inconvénient évident de cette approche est que toute la géométrie doit être retransmise, et la texture du passage préliminaire de l'éclairage représente en soi une charge importante sur le débit.  Je me suis demandé pourquoi ne pas utiliser un format plus léger, par exemple R11G11B10F, pour les textures d'éclairage de passage préliminaire, mais il y a des informations supplémentaires dans le canal alpha, donc ce serait impossible.  Quoi qu'il en soit, c'est une solution technique intéressante.  À ce stade, toute la géométrie opaque est déjà rendue et éclairée.  Notez qu'il comprend des objets émettant de la lumière tels que le ciel et l'écran d'un ordinateur portable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/3cb/0a3/2eb3cb0a3f58c521079fc2bbd1b3fd67.jpg"></div><br><h4>  Réflexions </h4><br>  Cette scène n'est pas un bon exemple de démonstration de reflets, j'ai donc choisi une autre.  Le shader de réflexion est une combinaison de cycles assez compliquée, qui peut être réduite en deux parties: l'une échantillonne les cartes cubiques, et l'autre effectue la SSR (Réflexion de l'espace d'écran - calcul des réflexions dans l'espace d'écran);  tout cela se fait en un seul passage et à la fin il est mélangé en tenant compte du coefficient déterminant si la SSR a détecté une réflexion (probablement le coefficient n'est pas binaire, mais est une valeur dans l'intervalle [0, 1]).  La SSR fonctionne de manière standard pour de nombreux jeux - elle trace à plusieurs reprises le tampon de profondeur, essayant de trouver la meilleure intersection entre le rayon réfléchi par la surface ombrée et une autre surface n'importe où sur l'écran.  SSR fonctionne avec la chaîne mip de l'échelle précédemment réduite du tampon HDR actuel, et non avec l'ensemble du tampon. <br><br>  Il existe également des facteurs de correction tels que la luminosité de la réflexion, ainsi que la texture particulière de Fresnel, qui a été calculée avant ce passage, sur la base des normales et de la rugosité.  Je ne suis pas complètement sûr, mais après avoir étudié le code d'assemblage, il me semble que ROTR ne peut calculer le SSR que pour les surfaces lisses.  Le moteur n'a pas de chaîne mip flou après l'étape SSR, qui existe dans d'autres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteurs</a> , et il n'y a même rien de tel que le traçage du tampon de profondeur à l'aide de rayons, qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">varie en fonction de la rugosité</a> .  En général, les surfaces rugueuses reçoivent des réflexions des cartes cubiques ou ne les reçoivent pas du tout.  Néanmoins, là où la SSR fonctionne, sa qualité est très élevée et stable, compte tenu du fait qu'elle ne s'accumule pas dans le temps et qu'un flou spatial n'est pas effectué pour elle.  Les données alpha prennent également en charge la SSR (dans certains temples, vous pouvez voir de très beaux reflets dans l'eau) et c'est un bon ajout que vous ne voyez pas souvent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/b6f/093/5afb6f0937fe9b172b8e38d3f0459b9b.jpg" alt="image"></div><br>  <i>Réflexions sur</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/66d/c6c/ecc66dc6ca98108593b9a5ec4695dc63.jpg" alt="image"></div><br>  <i>Tampon de réflexion</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec9/6ff/e57/ec96ffe5730e775b678a47ae23906b73.jpg" alt="image"></div><br>  <i>Réflexions après</i> <br><br><h4>  Brouillard éclairé </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/578/565/d2a/578565d2af38eac19d8aff86b82cf710.jpg"></div><br>  Dans notre scène, le brouillard est mal représenté car il assombrit l'arrière-plan et est donc créé par des particules, de sorte que nous reprenons l'exemple avec des reflets.  Le brouillard est relativement simple, mais assez efficace.  Il existe deux modes: global, la couleur générale du brouillard et la couleur de la diffusion vers l'intérieur obtenue à partir de la carte cubique.  Peut-être que la carte cubique a été à nouveau tirée des cartes de réflexion cubique, ou peut-être créée à nouveau.  Dans les deux modes, la raréfaction du brouillard est tirée de la texture de raréfaction globale, dans laquelle les courbes de raréfaction sont compressées pour plusieurs effets.  Dans un tel schéma, il est remarquable qu'il donne un brouillard lumineux très peu coûteux, c'est-à-dire  dispersant les changements intérieurs dans l'espace, créant l'illusion de l'interaction du brouillard avec un éclairage distant.  Cette approche peut également être utilisée pour la diffusion atmosphérique vers l'intérieur près du ciel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/e0e/c3a/e33e0ec3aee95a3cd5a669b332946083.jpg" alt="image"></div><br>  <i>Brouillard à</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/5ed/c78/acb5edc78ab74eb97b9350c1e7aba261.jpg" alt="image"></div><br>  <i>Brouillard après</i> <br><br><h4>  Éclairage volumétrique </h4><br>  Aux premiers stades du cadre, plusieurs opérations sont effectuées pour préparer l'éclairage volumétrique.  Deux tampons sont copiés du CPU vers le GPU: les index de source lumineuse et les données de source lumineuse.  Les deux sont lus par un shader de calcul qui produit une texture 3D 40x23x16 de la vue de la caméra contenant le nombre de sources de lumière traversant cette zone.  La texture est de 40 × 23 car chaque tuile occupe 32 × 32 pixels (1280/32 = 40, 720/32 = 22,5), et 16 est le nombre de pixels en profondeur.  La texture n'inclut pas toutes les sources lumineuses, mais seulement celles qui sont marquées comme volumineuses (il y en a trois dans notre scène).  Comme nous le verrons ci-dessous, il existe d'autres faux effets volumétriques créés par des textures plates.  La texture affichée a une résolution plus élevée - 160x90x64.  Après avoir déterminé le nombre de sources lumineuses par tuile et leur indice, trois shaders de calcul sont exécutés séquentiellement, effectuant les opérations suivantes: <br><br><ol><li>  Le premier passage détermine la quantité de lumière entrant dans la cellule dans le volume sous la forme d'une pyramide de visibilité.  Chaque cellule accumule l'influence de toutes les sources de lumière, comme si elles avaient des particules en suspension qui réagissent à la lumière et en renvoient une partie à la caméra. </li><li>  La deuxième passe brouille l'éclairage avec un petit rayon.  Ceci est probablement nécessaire pour éviter le scintillement lors du déplacement de la caméra, car la résolution est très faible. </li><li>  La troisième passe contourne la texture du volume d'avant en arrière, ajoutant progressivement l'influence de chaque source et donnant la texture finale.  En fait, il simule la quantité totale d'éclairage entrant le long du faisceau jusqu'à une distance donnée.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque chaque cellule contient une partie de la lumière réfléchie par les particules vers la caméra, dans chacune d'elles, nous recevrons une contribution conjointe de toutes les cellules précédemment passées. </font><font style="vertical-align: inherit;">Ce passage est également flou.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque tout cela est terminé, nous obtenons une texture 3D qui indique la quantité de lumière reçue par une position particulière par rapport à la caméra. </font><font style="vertical-align: inherit;">Tout ce qui reste à faire dans le passage plein écran est de déterminer cette position, de trouver le voxel correspondant de la texture et de l'ajouter au buffer HDR. </font><font style="vertical-align: inherit;">Le shader d'éclairage lui-même est très simple et ne contient qu'environ 16 instructions.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/939/e8a/b58939e8ae5abf2320c519abc51f6e8a.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Éclairage volumétrique</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ab/006/e9d/1ab006e9d0b62e0ea0470751185ffe41.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Éclairage volumétrique après</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendu des cheveux </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la fonction PureHair n'est pas activée, les couches de cheveux standard sont rendues les unes sur les autres. </font><font style="vertical-align: inherit;">Cette solution a toujours fière allure, mais je voudrais me concentrer sur les dernières technologies. </font><font style="vertical-align: inherit;">Si la fonction est activée, le cadre commence par une simulation des cheveux de Lara avec une séquence de shaders de calcul. </font><font style="vertical-align: inherit;">La première partie de Tomb Raider a utilisé une technologie appelée TressFX, et dans la suite Crystal Dynamics a implémenté une technologie améliorée. </font><font style="vertical-align: inherit;">Après les calculs initiaux, nous obtenons jusqu'à 7 tampons. </font><font style="vertical-align: inherit;">Tous sont utilisés pour contrôler les cheveux de Lara. </font><font style="vertical-align: inherit;">Le processus est le suivant:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancer un shader de calcul pour calculer les valeurs de mouvement en fonction des positions précédentes et actuelles (pour le flou de mouvement) </font></font></li><li>          1×1        () </li><li>   122       (Triangle Strip) (   —  ).     ,         .    7 ,      .     ,      ,  .      « ». </li><li>  /   quad    ,     ,     .  ,          ,    . </li><li>       4,      (    « ») </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez en savoir plus à ce sujet, AMD dispose de nombreuses </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ressources</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">présentations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car il s'agit d'une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bibliothèque publique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> créée par l'entreprise </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">J'ai été troublé par l'étape précédant l'étape 1, dans laquelle le même appel de tirage est effectué que dans l'étape 3, on dit qu'il ne rend que des valeurs de profondeur, mais en fait le contenu n'est pas rendu, et c'est intéressant; </font><font style="vertical-align: inherit;">peut-être que Renderdoc ne me dit rien. </font><font style="vertical-align: inherit;">Je soupçonne qu'il a peut-être tenté d'exécuter une demande de rendu conditionnel, mais je ne vois aucun appel de prédiction.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21f/127/76f/21f12776f41f0893c37a677deca12529.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheveux en l'air</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/f49/ecd/832f49ecd96406db87ee99f3b1089de0.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixels capillaires visibles</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/33e/030/28933e0309107cfcb3120564d55fd412.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheveux ombragés</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendu en mosaïque de données alpha et de particules </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets transparents utilisent à nouveau la classification des tuiles des sources lumineuses calculée pour le passage d'éclairage préliminaire des tuiles. Chaque objet transparent calcule son propre éclairage en une seule passe, c'est-à-dire que le nombre d'instructions et de cycles devient assez effrayant (c'est pourquoi la passe préliminaire d'éclairage a été utilisée pour les objets opaques). Les objets transparents peuvent même effectuer des réflexions dans l'espace de l'écran s'ils sont activés! Chaque objet est rendu dans l'ordre de tri de l'arrière vers l'avant directement dans le tampon HDR, y compris le verre, la flamme, l'eau d'ornière, etc. Le passage alpha rend également les bords mis en évidence lorsque Lara se concentre sur un objet (par exemple, une bouteille avec un mélange combustible sur une boîte à gauche).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/4a8/311/4454a83115f4118ab092fc1ff3bcaaf1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, les particules sont rendues dans un tampon à demi-résolution afin de lisser l'énorme charge sur la bande passante créée par leur repeinture, en particulier lorsque beaucoup de grosses particules couvrant l'écran sont utilisées pour créer du brouillard, du brouillard, de la flamme, etc. Par conséquent, le tampon HDR et le tampon de profondeur diminuent de moitié de chaque côté, après quoi le rendu des particules commence. Les particules créent une énorme quantité de redessin, certains pixels sont ombrés environ 40 fois. La carte thermique montre ce que je veux dire. Comme les particules ont été rendues en demi-résolution, la même astuce de zoom intelligent est utilisée ici que dans l'éclairage ambiant (les espaces sont marqués dans le pochoir, la première passe se transforme en pixels internes, la seconde recrée les bords). Vous remarquerez peut-être que les particules se traduisent par certains autres effets alpha, tels que la flamme,briller, etc. Cela est nécessaire pour que l'alpha puisse être correctement trié par rapport, par exemple, à la fumée. Vous pouvez également remarquer que des rayons de lumière «volumétriques» apparaissent ici, provenant de projecteurs de sécurité. Ils sont ajoutés ici, et non créés au stade de l'éclairage volumétrique. Il s'agit d'un moyen peu coûteux mais réaliste de les créer sur de longues distances.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e78/0f1/c77/e780f1c77d8c9031e10b1ddc6faf6b20.jpg" alt="image"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/409/09c/1db40909cea712bec3b9f1d4eab109d7.jpg" alt="image"></div><br> <i> -</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/8f2/80a/2c18f280ab65f272470ff711def4b89e.jpg" alt="image"></div><br> <i>   1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/e29/66c/098e2966cf5d8bdc62a7d76bfdc2344e.jpg" alt="image"></div><br> <i>   2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/c73/f5a/e0bc73f5ab35af88840eebe45f175074.jpg" alt="image"></div><br> <i>   3</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/6ef/e9e/eb06efe9eb6fe1db3e749e6b1a6c1c9c.jpg" alt="image"><br> <i>   </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56e/263/ba6/56e263ba63ae60ee5af108c172711410.jpg" alt="image"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8f/564/288/e8f564288ae2310272be7ac9899409d9.jpg" alt="image"></div><br> <i> -</i> <br><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROTR effectue la vitesse d'obturation et la correction de tonalité en une seule passe. Cependant, bien que nous croyions généralement que la correction gamma se produit avec la correction de tonalité, ce n'est pas le cas ici. Il existe de nombreuses façons de mettre en œuvre l'exposition, comme nous l'avons vu avec d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autres </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jeux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le calcul de la luminance dans ROTR est très intéressant et ne nécessite presque pas de données intermédiaires ou de passes, nous allons donc expliquer ce processus plus en détail. L'écran entier est divisé en 64 × 64 tuiles, après quoi le calcul des groupes (20, 12, 1) de 256 flux dans chacun commence à remplir tout l'écran. Chaque thread effectue essentiellement la tâche suivante (un pseudo-code est présenté ci-dessous):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; ++i) { uint2 iCoord = CalculateCoord(threadID, i, j); <span class="hljs-comment"><span class="hljs-comment">// Obtain coordinate float3 hdrValue = Load(hdrTexture, iCoord.xyz); // Read HDR float maxHDRValue = max3(hdrValue); // Find max component float minHDRValue = min3(hdrValue); // Find min component float clampedAverage = max(0.0, (maxHDRValue + minHDRValue) / 2.0); float logAverage = log(clampedAverage); // Natural logarithm sumLogAverage += logAverage; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque groupe calcule la somme logarithmique des 64 pixels (256 threads, chacun traitant 16 valeurs). Au lieu de stocker la valeur moyenne, il enregistre la somme et le nombre de pixels réellement traités (tous les groupes ne traitent pas exactement 64 × 64 pixels, car, par exemple, ils peuvent dépasser les bords de l'écran). Shader utilise judicieusement le stockage des threads locaux pour diviser la somme; chaque flux fonctionne d'abord avec 16 valeurs horizontales, puis des flux séparés résument toutes ces valeurs verticalement, et enfin le flux de contrôle de ce groupe (flux 0) ajoute le résultat et les enregistre tous dans le tampon. Ce tampon contient 240 éléments, nous donnant essentiellement la luminosité moyenne de nombreuses zones de l'écran. La commande suivante démarre 64 threads qui bouclent autour de toutes ces valeurs et les ajoutent,pour obtenir la luminosité finale de l'écran. Il revient également du logarithme en unités linéaires.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai pas beaucoup d'expérience avec les techniques d'exposition, mais la lecture de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce post de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Krzysztof Narkovic a clarifié certaines choses. L'enregistrement dans un tableau de 64 éléments est nécessaire pour calculer la moyenne mobile, dans laquelle vous pouvez afficher les valeurs calculées précédentes et lisser la courbe pour éviter des changements très brusques de luminosité, créant des changements brusques de vitesse d'obturation. Il s'agit d'un shader très complexe et je n'ai toujours pas compris tous ses détails, mais le résultat final est la valeur de la vitesse d'obturation correspondant à l'image actuelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir trouvé des vitesses d'obturation adéquates, un passage effectue la vitesse d'obturation finale plus la correction tonale. ROTR semble utiliser la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cartographie photographique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui explique l'utilisation de moyens logarithmiques au lieu des moyens habituels. </font><font style="vertical-align: inherit;">La formule de correction tonale dans le shader (après exposition) peut être développée comme suit:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/yv/-k/bzyv-kjhv-hs6lj3mh4yfrh427w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/zn/1d/idzn1d3rn-3qs7vrokrn94d9z1m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une brève explication peut être trouvée </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Je n'ai pas pu comprendre pourquoi une division supplémentaire par Lm est nécessaire, car elle annule l'influence de la multiplication. </font><font style="vertical-align: inherit;">Dans tous les cas, whitePoint est 1.0, donc le processus ne fait pas grand chose dans ce cadre, l'image ne fait que changer la vitesse d'obturation. </font><font style="vertical-align: inherit;">Il n'y a même pas de limite aux valeurs de l'intervalle LDR! </font><font style="vertical-align: inherit;">Cela se produit pendant l'étalonnage des couleurs, lorsque le cube de couleur limite indirectement les valeurs supérieures à 1,0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1a/92f/2e8/e1a92f2e852892aa137c170a56718f8e.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposition à</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/c4f/905/788c4f905eecffaa8d5dbd12d1c8972d.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposition après</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Éblouissement de l'objectif </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les reflets de l'objectif sont rendus de manière intéressante. Une petite passe préliminaire calcule une texture 1xN (où N est le nombre total d'éléments d'éblouissement qui seront rendus sous forme de reflets de lentille, dans notre cas il y en a 28). Cette texture contient la valeur alpha de la particule et d'autres informations inutilisées, mais au lieu de la calculer à partir d'une demande de visibilité ou quelque chose de similaire, le moteur la calcule en analysant le tampon de profondeur autour de la particule dans le cercle. Pour ce faire, les informations sur les sommets sont stockées dans un tampon disponible pour le pixel shader.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/604/e96/8a0604e96d5a4fe4ebf691719f03d75f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, chaque élément est rendu comme de simples plans alignés sur le plan émis par des sources lumineuses. </font><font style="vertical-align: inherit;">Si la valeur alpha est inférieure à 0,01, alors la valeur NaN est affectée à la position afin que cette particule ne pixellise pas. </font><font style="vertical-align: inherit;">Ils sont un peu comme l'effet de floraison et ajoutent de l'éclat, mais cet effet lui-même est créé plus tard.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/526/da9/a18/526da9a184f303dc8e3bfd82cd16034a.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La lentille éclate</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/440/335/4654403353e5b94dc7bae2a68b95ed88.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Éléments de lumière parasite</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/f10/c43/5c1f10c4396cbd6a8502a28b5a53fe0f.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Éblouissement de l'objectif après</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloom </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom utilise une approche standard: sous-échantillonner le tampon HDR, les pixels lumineux sont isolés, puis leur échelle est augmentée séquentiellement avec du flou pour étendre leur zone d'influence. Le résultat est agrandi à la résolution de l'écran et le compositing est superposé dessus. Il y a quelques points intéressants à explorer. L'ensemble du processus est effectué à l'aide de 7 shaders de calcul: 2 pour le sous-échantillonnage, 1 pour le flou simple, 4 pour le zoom avant.</font></font><br><br><ol><li>                  target   (mip 1).        .  ,   mip-    ,           0.02. </li><li>     mip      mip 2, 3, 4  5. </li><li>       mip 5.        ,    .       ,             . </li><li>   —   .  3          ,   mip N    mip N + 1,       ,     .     bloom      ,     . </li><li>     mip 1      HDR-,      bloom. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/478/bc7/b0c478bc7ccc0c4774cea8b2aaa4ec8b.jpg" alt="image"></div><br> <i>Bloom </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/b74/99b/f77b7499b451e0f232b06d183ccc04f4.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/ae2/875/c65ae2875487b8a9b441a9ce0b137430.jpg"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/9a4/757/55b9a4757f48867201dc76df90ea0dd1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba5/17d/a6f/ba517da6f179cca1067a08115579c155.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/91f/44d/33f91f44dcc1f9a395375fce8535ac2d.jpg" alt="image"></div><br> <i>MIP 5   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/561/33d/ecb56133d1965bcc93024c5cded95ec7.jpg"></div><br> <i> MIP 5  Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/0ed/474/2350ed47490101cda12baffbd61fc8f0.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff0/cfb/4df/ff0cfb4dfeea995b8666d4b8aec057a1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/980/7ca/a31/9807caa31251495050af2e2fd32b5e90.jpg" alt="image"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/857/4be/854/8574be854f2526857ef9b6854d6f7235.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9be/aa8/8a1/9beaa88a1bf00876801bb103ef85dd16.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Floraison après L'</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aspect curieux est que les textures à échelle réduite modifient le rapport d'aspect. </font><font style="vertical-align: inherit;">Par souci de visualisation, je les ai corrigées, et je ne peux que deviner les raisons de cela; </font><font style="vertical-align: inherit;">peut-être que cela est fait pour que les tailles de texture soient des multiples de 16. Un autre point intéressant: comme ces shaders sont généralement très limités en bande passante, les valeurs stockées dans la mémoire partagée de groupe sont converties de float32 à float16! </font><font style="vertical-align: inherit;">Cela permet au shader d'échanger des opérations mathématiques pour doubler la mémoire libre et la bande passante. </font><font style="vertical-align: inherit;">Pour que cela devienne un problème, la plage de valeurs doit devenir assez large.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fxaa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROTR prend en charge un large éventail de différentes techniques d'anticrénelage, telles que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FXAA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Fast Approximate AA) et SSAA (Super Sampling AA). </font><font style="vertical-align: inherit;">Il est à noter que l'option d'activation de l'AA temporel est absente, car pour la plupart des jeux AAA modernes, elle devient standard. </font><font style="vertical-align: inherit;">Quoi qu'il en soit, FXAA fait face à sa tâche de manière remarquable, SSAA fonctionne également bien, c'est une option plutôt "lourde" si le jeu manque de performances.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flou de mouvement </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que Motion blur utilise une approche très similaire à la solution dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadows of Mordor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Après avoir rendu l'éclairage volumétrique, une passe de rendu distincte renvoie les vecteurs de mouvement des objets animés vers le tampon de mouvement. Ensuite, ce tampon est combiné avec le mouvement provoqué par la caméra, et le tampon de mouvement final devient entré dans la passe de flou, qui effectue le flou dans la direction indiquée par les vecteurs de mouvement de l'espace d'écran. Pour estimer le rayon de flou en quelques passes, la texture des vecteurs de mouvement à une échelle réduite est calculée de sorte que chaque pixel ait une idée approximative du type de mouvement à proximité. Le flou est effectué en plusieurs passes à demi-résolution et, comme nous l'avons vu, plus tard, son échelle à l'aide du pochoir augmente en deux passes. Plusieurs passes sont effectuées pour deux raisons: premièrement,pour réduire le nombre de lectures de texture nécessaires pour créer un flou avec un rayon potentiellement très grand, et deuxièmement parce que différents types de flou sont effectués. Cela dépend si le personnage animé était sur les pixels actuels.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/91d/df6/3f491ddf60c6a1a6b9caeaec316eab4f.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flou de mouvement</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e5/eb5/d42/2e5eb5d42d4e0c36c4c96e764538f8c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse de flou de mouvement</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/3ed/2e7/edf3ed2e7144ec27ba21b3b16e606c7f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 1</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/c65/931/7c5c6593183900a85a3d0372fce9eb03.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 2</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/bc5/bcc/8a3bc5bcc85c92d698fc081e49c0f318.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 3</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/5e1/a7e/04f5e1a7e722d9818c8a23ef5759c172.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 4</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/98f/579/f9d98f579e02acec8e3ef99e90bdd0c0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 5</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/3ca/b5c/99e3cab5cbf5d25b2eea0d3311eae7cf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 6</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/af0/5bd/042af05bd488751c53bd97c73cb037fc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flou de mouvement, zoom avant et arrière</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/26d/c47/e1026dc47d9035e8713422ad8210e6a7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flou de mouvement, zoom des bords</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caractéristiques et détails supplémentaires </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il y a quelques autres choses qui méritent d'être mentionnées sans trop de détails. </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gel de l'appareil photo: par temps froid, ajoute des flocons de neige et du givre à l'appareil photo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caméra sale: ajoute de la saleté à la caméra. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correction des couleurs: à la fin du cadre, une petite correction des couleurs est effectuée, en utilisant un cube de couleurs assez standard pour effectuer la correction des couleurs, comme décrit ci-dessus, et ajoute également du bruit pour rendre certaines scènes plus graves </font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interface utilisateur est implémentée un peu inhabituelle - elle rend tous les éléments dans l'espace linéaire. </font><font style="vertical-align: inherit;">Habituellement, au moment du rendu, l'interface utilisateur avait déjà effectué une correction de tonalité et une correction gamma. </font><font style="vertical-align: inherit;">Cependant, ROTR utilise un espace linéaire jusqu'à la fin du cadre. </font><font style="vertical-align: inherit;">Cela a du sens, car le jeu rappelle une interface utilisateur 3D; </font><font style="vertical-align: inherit;">cependant, avant d'enregistrer des images sRGB dans le tampon HDR, elles doivent être converties en espace linéaire afin que l'opération la plus récente (correction gamma) ne déforme pas les couleurs.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour résumer </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'espère que vous avez apprécié la lecture de cette analyse de la même manière que je l'ai fait. </font><font style="vertical-align: inherit;">Personnellement, j'en ai certainement beaucoup appris. </font><font style="vertical-align: inherit;">Félicitations aux talentueux développeurs de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crystal Dynamics</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le travail fantastique accompli pour créer ce moteur. </font><font style="vertical-align: inherit;">Je tiens également à remercier Baldur Karlsson pour son travail fantastique sur Renderdoc. </font><font style="vertical-align: inherit;">Son travail a fait du débogage des graphiques sur un PC un processus beaucoup plus pratique. </font><font style="vertical-align: inherit;">Je pense que la seule chose un peu compliquée dans cette analyse était le suivi des lancements de shader eux-mêmes, car au moment de la rédaction de cette fonctionnalité, elle n'était pas disponible pour DX12. </font><font style="vertical-align: inherit;">J'espère qu'avec le temps cela apparaîtra et nous serons tous très heureux.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436500/">https://habr.com/ru/post/fr436500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436490/index.html">Motorola prévoit d'introduire l'incarnation de Razr v3</a></li>
<li><a href="../fr436492/index.html">Nous recherchons des conférenciers au 10e DIY Mitap 17 février 2019</a></li>
<li><a href="../fr436494/index.html">Remplacement d'un disque tout en conservant une numérotation correcte dans CEPH</a></li>
<li><a href="../fr436496/index.html">PVS-Studio pour Java</a></li>
<li><a href="../fr436498/index.html">Software AG: pas seulement ARIS</a></li>
<li><a href="../fr436502/index.html">Abonnement Pampers ou comment vendre plus aux mêmes clients</a></li>
<li><a href="../fr436504/index.html">Système en emballage ou contenu de l'emballage sous puce?</a></li>
<li><a href="../fr436506/index.html">Comment créer un IA-raciste sans trop d'effort</a></li>
<li><a href="../fr436508/index.html">10 millions de dollars d'investissements et les louanges de Wozniak - créer un ordinateur éducatif pour les enfants</a></li>
<li><a href="../fr436510/index.html">Données de base en détail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>