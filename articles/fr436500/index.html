<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòµ üëé üôÖ Comment le cadre de Rise of the Tomb Raider est rendu üòù üë©üèº‚Äçüè≠ üì¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rise of the Tomb Raider (2015) est la suite de l'excellent red√©marrage de Tomb Raider (2013). Personnellement, je trouve les deux parties int√©ressante...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment le cadre de Rise of the Tomb Raider est rendu</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436500/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1k/5p/s6/1k5ps6qnv2soku_ymxsemz7wnxa.gif"></div><br>  Rise of the Tomb Raider (2015) est la suite de l'excellent red√©marrage de Tomb Raider (2013).  Personnellement, je trouve les deux parties int√©ressantes parce qu'elles s'√©loignent de la s√©rie originale stagnante et racontent √† nouveau l'histoire de Lara.  Dans ce jeu, comme dans la pr√©quelle, l'intrigue occupe le devant de la sc√®ne, elle fournit des m√©canismes fascinants d'artisanat, de chasse et d'escalade / recherche. <br><br>  Tomb Raider a utilis√© Crystal Engine, d√©velopp√© par Crystal Dynamics, √©galement utilis√© dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Deus Ex: Human Revolution</a> .  La suite a utilis√© un nouveau moteur appel√© Foundation, pr√©c√©demment d√©velopp√© pour Lara Croft et le Temple d'Osiris (2014).  Son rendu peut g√©n√©ralement √™tre d√©crit comme un moteur de tuile avec un passage d'√©clairage pr√©alable, et nous verrons plus tard ce que cela signifie.  Le moteur vous permet de choisir entre les moteurs de rendu DX11 et DX12;  J'ai choisi ce dernier, pour les raisons que nous discutons ci-dessous.  Pour capturer le cadre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Renderdoc</a> 1.2 a √©t√© utilis√© sur la Geforce 980 Ti, le jeu comprend toutes les fonctions et d√©corations. <br><br><h2>  Trame analys√©e </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/254/df9/0bb/254df90bbbfd5498710f37624e12d1f4.jpg"></div><br>  Pour √©viter les spoilers, je dirai que dans ce cadre, les m√©chants poursuivent Lara, car elle cherche un artefact qu'ils recherchent.  Ce conflit d'int√©r√™ts ne peut √™tre r√©solu sans armes.  Lara s'est faufil√©e dans la base ennemie la nuit.  J'ai choisi un cadre avec un √©clairage d'ambiance et de contraste, dans lequel le moteur peut se montrer. <a name="habracut"></a><br><br><h4>  Avance en profondeur </h4><br>  Ici, l'optimisation habituelle pour de nombreux jeux est effectu√©e - une petite passe pr√©liminaire de la profondeur (environ 100 appels de tirage).  Le jeu affiche les plus gros objets (et non ceux qui occupent plus d'espace sur l'√©cran) pour profiter des fonctionnalit√©s du processeur vid√©o Early-Z.  En savoir plus √† ce sujet dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article Intel</a> .  En bref, les GPU peuvent √©viter d'ex√©cuter un pixel shader s'ils peuvent d√©terminer qu'il est chevauch√© par le pixel pr√©c√©dent.  Il s'agit d'un passage assez peu co√ªteux, pr√©remplissant le tampon Z avec des valeurs de profondeur. <br><br>  √Ä ce stade, j'ai d√©couvert une technique int√©ressante de niveau de d√©tail (LOD) appel√©e ¬´fizzle¬ª ou ¬´damier¬ª.  Il s'agit d'un moyen courant d'afficher ou de masquer progressivement des objets √† distance, afin qu'ils puissent ensuite √™tre remplac√©s par un maillage de qualit√© inf√©rieure ou les masquer compl√®tement.  Regardez ce camion.  Il semble qu'il effectue un rendu deux fois, mais en fait, il effectue un rendu avec un LOD √©lev√© et un LOD faible dans la m√™me position.  Chacun des niveaux rend les pixels que l'autre n'a pas rendus.  Le premier LOD a 182226 sommets, et le second LOD a 47250. √Ä une grande distance, ils sont indiscernables, mais l'un d'eux est trois fois moins cher.  Dans ce cadre, le LOD 0 dispara√Æt presque et le LOD 1 est presque enti√®rement rendu.  Apr√®s la disparition compl√®te de LOD 0, seul LOD 1 sera rendu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c31/d8d/24e/c31d8d24e58229c27fb4edf6f635974d.png"></div><br>  <i>LOD 0</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/3b4/5bb/7bf3b45bbe13521b4bae010f72a702a7.png"></div><br>  <i>LOD 1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/7r/it/jy7rit_bwqm4n0lwpzzlydyx5rs.gif"></div><br>  La texture pseudo-al√©atoire et le coefficient de probabilit√© nous permettent d'√©liminer les pixels qui n'ont pas d√©pass√© la valeur seuil.  Cette texture est utilis√©e dans ROTR.  On peut se demander pourquoi le m√©lange alpha n'est pas utilis√©.  Le m√©lange alpha pr√©sente de nombreux inconv√©nients par rapport √† la d√©coloration p√©tillante. <br><br><ol><li>  <strong>Commodit√© pour le passage pr√©liminaire des profondeurs:</strong> gr√¢ce au rendu d'un objet opaque avec des trous pratiqu√©s, nous pouvons effectuer le rendu dans le passage pr√©liminaire et utiliser early-z.  Les objets avec un m√©lange alpha √† un stade aussi pr√©coce ne seront pas rendus dans le tampon de profondeur en raison de probl√®mes de tri. </li><li>  <strong>Le besoin de shaders suppl√©mentaires</strong> : si un rendu diff√©r√© est utilis√©, le shader des objets opaques ne contient aucun √©clairage.  Si vous devez remplacer un objet opaque par un objet transparent, vous avez besoin d'une option distincte dans laquelle il y a de l'√©clairage.  En plus d'augmenter la quantit√© de m√©moire n√©cessaire et la complexit√© due √† au moins un shader suppl√©mentaire pour tous les objets opaques, ils doivent √™tre pr√©cis afin d'√©viter que les objets avancent.  C'est compliqu√© pour de nombreuses raisons, mais tout se r√©sume au fait que le rendu est d√©sormais effectu√© dans un chemin de code diff√©rent. </li><li>  <strong>Redessins plus importants</strong> : le m√©lange alpha peut cr√©er de grands redessins et, √† un certain niveau de complexit√© des objets, une grande partie de la bande passante peut √™tre n√©cessaire pour ombrer le LOD. </li><li>  <strong>Conflits Z</strong> : les <strong>conflits</strong> Z sont un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">effet de scintillement</a> lorsque deux polygones sont rendus √† une profondeur tr√®s proche l'un de l'autre.  Dans ce cas, l'inexactitude des calculs en virgule flottante les oblige √† √™tre rendus tour √† tour.  Si nous rendons deux LOD cons√©cutifs, en cachant progressivement un et en montrant le second, alors ils peuvent provoquer un conflit z, car ils sont tr√®s proches l'un de l'autre.  Il existe toujours des moyens de contourner ce probl√®me, par exemple en pr√©f√©rant un polygone √† un autre, mais un tel syst√®me est complexe. </li><li>  <strong>Effets Z-Buffer</strong> : De nombreux effets comme SSAO n'utilisent que le buffer de profondeur.  Si nous rendions des objets transparents √† la fin du pipeline alors que l'occlusion ambiante √©tait d√©j√† termin√©e, nous ne pourrions pas en tenir compte. </li></ol><br>  L'inconv√©nient de cette technique est qu'elle a l'air pire que le m√©lange alpha, mais un bon motif de bruit, un flou apr√®s fizzle ou un anti-aliasing temporaire peut le cacher presque compl√®tement.  √Ä cet √©gard, ROTR ne fait rien de particuli√®rement inhabituel. <br><br><h4>  Passe normale </h4><br>  Crystal Dynamics utilise un mod√®le d'√©clairage plut√¥t inhabituel dans ses jeux, que nous couvrirons dans l'all√©e d'√©clairage.  Pour l'instant, il suffit de dire que le moteur n'a pas de passe G-buffer;  au moins dans la mesure o√π cela est familier dans d'autres jeux.  Sur ce passage, les objets transmettent uniquement des informations sur la profondeur et les normales √† la sortie.  Les normales sont enregistr√©es dans la cible de rendu du format RGBA16_SNORM dans l'espace universel.  Il est curieux que ce moteur utilise le sch√©ma Z-up, pas le Y-up (l'axe Z est dirig√© vers le haut, pas l'axe Y), qui est plus souvent utilis√© dans d'autres moteurs / packages de mod√©lisation.  Le canal alpha contient de la brillance, qui est ensuite d√©compress√©e en <code>exp2(glossiness * 12 + 1.0)</code> .  La valeur de brillance peut √©galement √™tre n√©gative, car le signe est utilis√© comme indicateur indiquant si la surface est m√©tallique.  Cela peut √™tre remarqu√© par lui-m√™me, car toutes les couleurs sombres du canal alpha sont li√©es √† des objets m√©talliques. <br><br><table><tbody><tr><td>  <strong><font color="#ff0000">R</font></strong> </td><td>  <strong><font color="#00ff00">G</font></strong> </td><td>  <strong><font color="0000ff">B</font></strong> </td><td></td></tr><tr><td>  <strong>Normal.x</strong> </td><td>  <strong>Normal.y</strong> </td><td>  <strong>Normal.z</strong> </td><td>  <b>Brillance + Metalness</b> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/209/484/1e8209484fe730d178c4afffef4c8f93.jpg"></div><br>  <i>Normal</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/dd3/b2d/8fbdd3b2d2ddbce3111a4c017e7daef3.jpg"></div><br>  <i>Brillance / m√©tal</i> <br><br>  <strong>Avantages du d√©part</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa1/b15/52b/aa1b1552b0f81c2122d094441e531f3f.jpg"></div><br>  Rappelez-vous que dans la section ¬´Profondeur pr√©liminaire¬ª, nous avons parl√© d'√©conomiser les co√ªts en pixels?  Je vais revenir un peu en arri√®re pour l'illustrer.  Prenez l'image suivante.  Cela rend la partie d√©taill√©e de la montagne dans le tampon normal.  Renderdoc a gentiment mis en √©vidence les pixels qui ont r√©ussi le test de profondeur avec du vert et ceux qui ne l'ont pas pass√© avec du rouge (ils ne seront pas rendus).  Le nombre total de pixels qui seraient rendus sans cette passe pr√©liminaire est approximativement √©gal √† 104518 (calcul√© dans Photoshop).  Le nombre total de pixels r√©ellement rendus est de 23858 (calcul√© par Renderdoc).  √âconomisez environ 77%!  Comme on le voit, avec une utilisation intelligente, cette passe pr√©liminaire peut donner un gros gain, et elle ne n√©cessite qu'une centaine d'appels de tirage. <br><br>  <strong>Enregistrement de commandes multithread</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/919/5d0/623/9195d06236fd6247cea6e6065f05e9e8.png"></div><br>  Il convient de noter un aspect int√©ressant, √† cause duquel j'ai choisi le rendu DX12 - l'enregistrement de commandes multi-thread.  Dans les API pr√©c√©dentes, telles que DX11, le rendu est g√©n√©ralement effectu√© dans un seul thread.  Le pilote graphique a re√ßu des commandes de rendu du jeu et a constamment transmis des demandes de GPU, mais le jeu ne savait pas quand cela se produirait.  Cela conduit √† l'inefficacit√©, car le pilote doit en quelque sorte deviner ce que l'application essaie de faire, et ne s'adapte pas √† plusieurs threads.  Les API plus r√©centes telles que DX12 confient le contr√¥le √† un d√©veloppeur qui peut d√©cider comment √©crire des commandes et quand les envoyer.  Bien que Renderdoc ne puisse pas montrer comment l'enregistrement est effectu√©, vous verrez qu'il y a sept passes de couleur marqu√©es comme Color Pass N, et chacune d'entre elles est envelopp√©e dans une paire de ExecuteCommandList: Reset / Close.  Il marque le d√©but et la fin de la liste des commandes.  La liste repr√©sente environ 100-200 appels de tirage.  Cela ne signifie pas qu'ils ont √©t√© enregistr√©s √† l'aide de plusieurs flux, mais y fait allusion. <br><br>  <strong>Empreintes de pas dans la neige</strong> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca6/d21/2e8/ca6d212e89b61f52738dfbd01363e366.jpg"></div><br>  Si vous regardez Lara, vous pouvez voir qu'en se d√©pla√ßant devant la capture d'√©cran, elle a laiss√© des traces dans la neige.  Dans chaque cadre, un shader de calcul est ex√©cut√©, qui enregistre les d√©formations dans certaines zones et les applique en fonction du type et de la hauteur de la surface.  Ici, seule la carte normale est appliqu√©e √† la neige (c'est-√†-dire que la g√©om√©trie ne change pas), mais dans certaines zones o√π la neige est plus √©paisse, la d√©formation est en fait effectu√©e!  Vous pouvez √©galement voir comment la neige "tombe" en place et remplit les traces laiss√©es par Lara.  Cette technique est d√©crite de mani√®re beaucoup plus d√©taill√©e dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GPU Pro 7</a> .  La texture de la cha√Æne de neige est une sorte de carte d'√©l√©vation qui suit les mouvements de Lara et coll√©e sur les bords afin que le shader d'√©chantillonnage puisse profiter de ce pliage. <br><br><h4>  Atlas des ombres </h4><br>  Lors de la cr√©ation du mappage des ombres, une approche assez courante est utilis√©e - regroupant autant de cartes d'ombre que possible dans une texture d'ombre commune.  Un tel atlas d'ombres est en fait une √©norme texture 16 bits avec une taille de 16384 √ó 8196.  Cela vous permet de r√©utiliser et de mettre √† l'√©chelle de mani√®re tr√®s flexible les cartes d'ombre dans l'atlas.  Dans le cadre que nous analysons, 8 cartes d'ombre sont enregistr√©es dans l'atlas.  Quatre d'entre eux concernent la principale source d'√©clairage directionnel (la lune, car elle se produit la nuit), car ils utilisent des cartes d'ombres en cascade - une technique assez standard d'ombres √† longue distance pour l'√©clairage directionnel, que j'ai d√©j√† expliqu√© un peu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus t√¥t</a> .  Plus int√©ressant, plusieurs sources de projection et de projecteur sont √©galement incluses dans la capture de cette image.  Le fait que 8 plans d'ombre soient enregistr√©s dans ce cadre ne signifie pas qu'il n'y a que 8 sources de projection d'√©clairage d'ombre.  Le jeu peut mettre en cache les calculs d'ombre, c'est-√†-dire que l'√©clairage qui n'a pas chang√© la position de la source ou la g√©om√©trie dans la port√©e ne doit pas mettre √† jour sa carte d'ombre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f00/8d9/169/f008d9169bd3490c26f923bcc4ea8e85.jpg"></div><br>  Il semble que le rendu des mappages d'ombre profite √©galement de l'√©criture de commandes multithread dans la liste, et dans ce cas, jusqu'√† 19 listes de commandes ont √©t√© √©crites pour le rendu des mappages d'ombre. <br><br>  <strong>Ombres de l'√©clairage directionnel</strong> <br><br>  Les ombres de l'√©clairage directionnel sont calcul√©es avant le passage de l'√©clairage et ensuite √©chantillonn√©es.  Je ne sais pas ce qui se passerait s'il y avait plusieurs sources d'√©clairage directionnel dans la sc√®ne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cef/209/845/cef209845628db5e68588f07880542eb.jpg"></div><br><h4>  Occlusion ambiante </h4><br>  Pour l'occlusion ambiante, ROTR vous permet d'utiliser soit HBAO soit une variante de HBAO + (cette technique a √©t√© initialement publi√©e par NVIDIA).  Il existe plusieurs variantes de cet algorithme, je vais donc consid√©rer celui que j'ai trouv√© dans ROTR.  Tout d'abord, le tampon de profondeur est divis√© en 16 textures, chacune contenant 1/16 de toutes les valeurs de profondeur.  La s√©paration est effectu√©e de mani√®re √† ce que chaque texture contienne une valeur d'un bloc 4 √ó 4 de la texture d'origine illustr√©e dans la figure ci-dessous.  La premi√®re texture contient toutes les valeurs marqu√©es en rouge (1), la seconde contient les valeurs marqu√©es en bleu (2), etc.  Si vous souhaitez en savoir plus sur cette technique, voici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Louis Bavoil</a> , qui √©tait √©galement l'un des auteurs de l'article sur HBAO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c9/2dc/60f/1c92dc60fe369caed766efe18dd2739d.png"></div><br>  L'√©tape suivante calcule l'occlusion ambiante pour chaque texture, ce qui nous donne 16 textures AO.  Une occlusion ambiante est g√©n√©r√©e comme suit: le tampon de profondeur est √©chantillonn√© plusieurs fois, recr√©ant la position et accumulant le r√©sultat du calcul pour chacun des √©chantillons.  Chaque texture d'occlusion ambiante est calcul√©e en utilisant diff√©rentes coordonn√©es d'√©chantillonnage, c'est-√†-dire que dans un bloc de pixels 4x4, chaque pixel raconte sa propre partie de l'histoire.  Cette op√©ration est effectu√©e pour des raisons de performances.  Chaque pixel √©chantillonne d√©j√† 32 fois le tampon de profondeur, et le plein effet n√©cessitera 16 √ó 32 = 512 √©chantillons, ce qui est un buste m√™me pour les GPU les plus puissants.  Ensuite, ils se recombinent en une seule texture plein √©cran, ce qui s'av√®re assez bruyant, donc pour lisser les r√©sultats juste apr√®s cela, une passe de flou plein √©cran est effectu√©e.  Nous avons vu une solution tr√®s similaire dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shadow of Mordor</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/e57/dd8/25fe57dd8001f561e9a971b36b57085e.png" alt="image"></div><br>  <i>Pi√®ces HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/113/e1b/7d0/113e1b7d065a25b8f4dfb8dce29c808c.png" alt="image"></div><br>  <i>HBAO complet avec bruit</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/bfe/cd1/063bfecd15cdf8d62a0b6221fddfe4ee.png" alt="image"></div><br>  <i>Flou horizontal complet HBAO</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/af9/8e2/51daf98e295b549a57089b4d17df1975.png" alt="image"></div><br>  <i>Pr√™t HBAO</i> <br><br><h4>  Pr√©-passage d'√©clairage carrel√© </h4><br>  Le Light Prepass est une technique assez inhabituelle.  La plupart des √©quipes de d√©veloppement utilisent une combinaison de calcul d'√©clairage diff√©r√© + direct (avec des variations, par exemple, avec une tuile, un cluster) ou compl√®tement direct pour certains effets de l'espace d'√©cran.  La technique de pr√©-√©clairage est si inhabituelle qu'elle m√©rite une explication.  Si le concept d'√©clairage diff√©r√© traditionnel consiste √† s√©parer les propri√©t√©s des mat√©riaux de l'√©clairage, alors l'id√©e de s√©parer l'√©clairage des propri√©t√©s des mat√©riaux est la pierre angulaire du passage pr√©liminaire de l'√©clairage.  Bien que cette formulation semble un peu idiote, la diff√©rence par rapport √† l'√©clairage diff√©r√© traditionnel est que nous stockons toutes les propri√©t√©s des mat√©riaux (tels que l'alb√©do, la couleur sp√©culaire, la rugosit√©, la m√©tallicit√©, la micro-occlusion, l'√©missif) dans un √©norme tampon G, et l'utiliser plus tard comme donn√©es d'entr√©e pour les passages d'√©clairage ult√©rieurs.  L'√©clairage diff√©r√© traditionnel peut pr√©senter une charge importante sur le d√©bit;  plus les mat√©riaux sont complexes, plus il faut d'informations et d'op√©rations dans le G-buffer.  Cependant, dans la passe d'√©clairage pr√©liminaire, nous accumulons d'abord tout l'√©clairage s√©par√©ment, en utilisant le minimum de donn√©es, puis les appliquons dans les passes suivantes aux mat√©riaux.  Dans ce cas, l'√©clairage n'est suffisant que pour les normales, la rugosit√© et la m√©tallit√©.  Les shaders (deux passes sont utilis√©es ici) produisent des donn√©es dans trois formats de rendu RGBA16F cibles.  L'une contient un √©clairage diffus, la seconde contient un √©clairage sp√©culaire et la troisi√®me contient un √©clairage ambiant.  √Ä ce stade, toutes les donn√©es fant√¥mes sont prises en compte.  Il est curieux que dans la premi√®re passe (√©clairage diffus + miroir) pour une passe plein √©cran, un quadrilat√®re de deux triangles soit utilis√©, et dans d'autres effets, un triangle plein √©cran soit utilis√© (pourquoi c'est important, vous pouvez le d√©couvrir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ).  De ce point de vue, l'ensemble du cadre n'est pas int√©gral. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41d/6ba/a3b/41d6baa3b45cc3e0df1423eaf015d416.jpg" alt="image"></div><br>  <i>√âclairage diffus</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cd/0c5/137/9cd0c513782787daa220b7627b11b28e.jpg" alt="image"></div><br>  <i>√âclairage miroir</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33d/ed9/cbc/33ded9cbc62470319b7729b542b7e830.jpg" alt="image"></div><br>  <i>√âclairage ambiant</i> <br><br>  <strong>Optimisation des carreaux</strong> <br><br>  L'√©clairage en mosa√Øque est une technique d'optimisation con√ßue pour restituer un grand nombre de sources lumineuses.  ROTR divise l'√©cran en carreaux 16 √ó 16, puis enregistre des informations sur les sources qui coupent chaque carreau, c'est-√†-dire que les calculs d'√©clairage ne seront effectu√©s que pour les sources li√©es aux carreaux.  Au d√©but du cadre, une s√©quence de shaders de calcul est lanc√©e, qui d√©termine quelles sources se rapportent aux tuiles.  Au stade de l'√©clairage, chaque pixel d√©termine dans quelle tuile il se trouve et boucle √† travers chaque source de lumi√®re dans la tuile, effectuant tous les calculs d'√©clairage.  Si les sources sont li√©es aux tuiles de mani√®re efficace, vous pouvez √©conomiser beaucoup de calculs et la majeure partie de la bande passante, ainsi qu'augmenter la productivit√©. <br><br>  <strong>Zoom en profondeur</strong> <br><br>  Le sur√©chantillonnage bas√© sur la profondeur est une technique int√©ressante utile pour cette passe et les suivantes.  Parfois, les algorithmes co√ªteux en calcul ne peuvent pas √™tre rendus √† pleine r√©solution, ils sont donc rendus √† une r√©solution inf√©rieure, puis agrandis.  Dans notre cas, l'√©clairage ambiant est calcul√© en demi-r√©solution, c'est-√†-dire qu'apr√®s les calculs, l'√©clairage doit √™tre correctement recr√©√©.  Dans la forme la plus simple, 4 pixels basse r√©solution sont pris et interpol√©s pour obtenir quelque chose ressemblant √† l'image d'origine.  Cela fonctionne pour des transitions en douceur, mais ne semble pas bon sur les discontinuit√©s, car l√†, nous m√©langeons des valeurs non li√©es qui peuvent √™tre adjacentes dans l'espace de l'√©cran, mais √©loign√©es les unes des autres dans l'espace du monde.  Pour r√©soudre ce probl√®me, plusieurs √©chantillons de tampon de profondeur sont g√©n√©ralement pr√©lev√©s et compar√©s √† l'√©chantillon de profondeur que nous voulons recr√©er.  Si l'√©chantillon est trop √©loign√©, nous ne le prenons pas en compte lors de la reconstruction.  Un tel sch√©ma fonctionne bien, mais cela signifie que le shader de loisirs est tr√®s gourmand en bande passante. <br><br>  ROTR fait un pas d√©licat avec la suppression pr√©coce du pochoir.  Apr√®s avoir pass√© les normales, le tampon de profondeur est compl√®tement plein, le moteur effectue donc une passe plein √©cran, marquant tous les pixels interrompus dans le tampon de gabarit.  Lorsque vient le temps de recr√©er le tampon d'√©clairage ambiant, le moteur utilise deux shaders: l'un est tr√®s simple pour les zones sans espaces de profondeur, l'autre est plus complexe pour les pixels avec des espaces.  Le premier pochoir supprime les pixels s'ils n'appartiennent pas √† la r√©gion correspondante, c'est-√†-dire qu'il n'y a des co√ªts que dans les r√©gions n√©cessaires.  Les images suivantes sont beaucoup plus claires: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/747/912/729/747912729abfecffd281c72e8ca4e258.jpg" alt="image"></div><br>  <i>√âclairage ambiant demi-r√©solution</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0d/e46/b7e/f0de46b7e19ace552377d1a39d86ed22.png" alt="image"></div><br>  <i>√âchelle des profondeurs de l'int√©rieur</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d64/354/63b/d6435463b209e7361831b279abcf1ae1.jpg" alt="image"></div><br>  <i>√âclairage ambiant pleine r√©solution, sans nervures</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/e12/702/db5e1270220121c5ca9c2a9277d519ed.png" alt="image"></div><br>  <i>Augmenter la profondeur des c√¥tes</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/971/5cf/3ea9715cf0c57785d926b0711808b256.jpg" alt="image"></div><br>  <i>√âclairage d'ambiance pr√™t</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a5/5d2/128/4a55d2128ab191fb120ca3c1c4310c95.jpg" alt="image"></div><br>  <i>Vue demi-r√©solution</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd4/eaa/a07/cd4eaaa0719a527bcdd1add09f00597b.jpg" alt="image"></div><br>  <i>Une vue rapproch√©e de l'image recr√©√©e</i> <br><br>  Apr√®s un premier passage d'√©clairage, la g√©om√©trie est transf√©r√©e sur le convoyeur, mais cette fois, chaque objet √©chantillonne les textures d'√©clairage, la texture d'occlusion ambiante et d'autres propri√©t√©s des mat√©riaux que nous n'avons pas √©crites dans le G-buffer depuis le d√©but.  C'est bien, car la bande passante est consid√©rablement √©conomis√©e ici car vous n'avez pas besoin de lire un tas de textures pour les √©crire dans un grand G-buffer, puis de les lire / d√©coder √† nouveau.  L'inconv√©nient √©vident de cette approche est que toute la g√©om√©trie doit √™tre retransmise, et la texture du passage pr√©liminaire de l'√©clairage repr√©sente en soi une charge importante sur le d√©bit.  Je me suis demand√© pourquoi ne pas utiliser un format plus l√©ger, par exemple R11G11B10F, pour les textures d'√©clairage de passage pr√©liminaire, mais il y a des informations suppl√©mentaires dans le canal alpha, donc ce serait impossible.  Quoi qu'il en soit, c'est une solution technique int√©ressante.  √Ä ce stade, toute la g√©om√©trie opaque est d√©j√† rendue et √©clair√©e.  Notez qu'il comprend des objets √©mettant de la lumi√®re tels que le ciel et l'√©cran d'un ordinateur portable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2eb/3cb/0a3/2eb3cb0a3f58c521079fc2bbd1b3fd67.jpg"></div><br><h4>  R√©flexions </h4><br>  Cette sc√®ne n'est pas un bon exemple de d√©monstration de reflets, j'ai donc choisi une autre.  Le shader de r√©flexion est une combinaison de cycles assez compliqu√©e, qui peut √™tre r√©duite en deux parties: l'une √©chantillonne les cartes cubiques, et l'autre effectue la SSR (R√©flexion de l'espace d'√©cran - calcul des r√©flexions dans l'espace d'√©cran);  tout cela se fait en un seul passage et √† la fin il est m√©lang√© en tenant compte du coefficient d√©terminant si la SSR a d√©tect√© une r√©flexion (probablement le coefficient n'est pas binaire, mais est une valeur dans l'intervalle [0, 1]).  La SSR fonctionne de mani√®re standard pour de nombreux jeux - elle trace √† plusieurs reprises le tampon de profondeur, essayant de trouver la meilleure intersection entre le rayon r√©fl√©chi par la surface ombr√©e et une autre surface n'importe o√π sur l'√©cran.  SSR fonctionne avec la cha√Æne mip de l'√©chelle pr√©c√©demment r√©duite du tampon HDR actuel, et non avec l'ensemble du tampon. <br><br>  Il existe √©galement des facteurs de correction tels que la luminosit√© de la r√©flexion, ainsi que la texture particuli√®re de Fresnel, qui a √©t√© calcul√©e avant ce passage, sur la base des normales et de la rugosit√©.  Je ne suis pas compl√®tement s√ªr, mais apr√®s avoir √©tudi√© le code d'assemblage, il me semble que ROTR ne peut calculer le SSR que pour les surfaces lisses.  Le moteur n'a pas de cha√Æne mip flou apr√®s l'√©tape SSR, qui existe dans d'autres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">moteurs</a> , et il n'y a m√™me rien de tel que le tra√ßage du tampon de profondeur √† l'aide de rayons, qui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">varie en fonction de la rugosit√©</a> .  En g√©n√©ral, les surfaces rugueuses re√ßoivent des r√©flexions des cartes cubiques ou ne les re√ßoivent pas du tout.  N√©anmoins, l√† o√π la SSR fonctionne, sa qualit√© est tr√®s √©lev√©e et stable, compte tenu du fait qu'elle ne s'accumule pas dans le temps et qu'un flou spatial n'est pas effectu√© pour elle.  Les donn√©es alpha prennent √©galement en charge la SSR (dans certains temples, vous pouvez voir de tr√®s beaux reflets dans l'eau) et c'est un bon ajout que vous ne voyez pas souvent. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5af/b6f/093/5afb6f0937fe9b172b8e38d3f0459b9b.jpg" alt="image"></div><br>  <i>R√©flexions sur</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/66d/c6c/ecc66dc6ca98108593b9a5ec4695dc63.jpg" alt="image"></div><br>  <i>Tampon de r√©flexion</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec9/6ff/e57/ec96ffe5730e775b678a47ae23906b73.jpg" alt="image"></div><br>  <i>R√©flexions apr√®s</i> <br><br><h4>  Brouillard √©clair√© </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/578/565/d2a/578565d2af38eac19d8aff86b82cf710.jpg"></div><br>  Dans notre sc√®ne, le brouillard est mal repr√©sent√© car il assombrit l'arri√®re-plan et est donc cr√©√© par des particules, de sorte que nous reprenons l'exemple avec des reflets.  Le brouillard est relativement simple, mais assez efficace.  Il existe deux modes: global, la couleur g√©n√©rale du brouillard et la couleur de la diffusion vers l'int√©rieur obtenue √† partir de la carte cubique.  Peut-√™tre que la carte cubique a √©t√© √† nouveau tir√©e des cartes de r√©flexion cubique, ou peut-√™tre cr√©√©e √† nouveau.  Dans les deux modes, la rar√©faction du brouillard est tir√©e de la texture de rar√©faction globale, dans laquelle les courbes de rar√©faction sont compress√©es pour plusieurs effets.  Dans un tel sch√©ma, il est remarquable qu'il donne un brouillard lumineux tr√®s peu co√ªteux, c'est-√†-dire  dispersant les changements int√©rieurs dans l'espace, cr√©ant l'illusion de l'interaction du brouillard avec un √©clairage distant.  Cette approche peut √©galement √™tre utilis√©e pour la diffusion atmosph√©rique vers l'int√©rieur pr√®s du ciel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e33/e0e/c3a/e33e0ec3aee95a3cd5a669b332946083.jpg" alt="image"></div><br>  <i>Brouillard √†</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/acb/5ed/c78/acb5edc78ab74eb97b9350c1e7aba261.jpg" alt="image"></div><br>  <i>Brouillard apr√®s</i> <br><br><h4>  √âclairage volum√©trique </h4><br>  Aux premiers stades du cadre, plusieurs op√©rations sont effectu√©es pour pr√©parer l'√©clairage volum√©trique.  Deux tampons sont copi√©s du CPU vers le GPU: les index de source lumineuse et les donn√©es de source lumineuse.  Les deux sont lus par un shader de calcul qui produit une texture 3D 40x23x16 de la vue de la cam√©ra contenant le nombre de sources de lumi√®re traversant cette zone.  La texture est de 40 √ó 23 car chaque tuile occupe 32 √ó 32 pixels (1280/32 = 40, 720/32 = 22,5), et 16 est le nombre de pixels en profondeur.  La texture n'inclut pas toutes les sources lumineuses, mais seulement celles qui sont marqu√©es comme volumineuses (il y en a trois dans notre sc√®ne).  Comme nous le verrons ci-dessous, il existe d'autres faux effets volum√©triques cr√©√©s par des textures plates.  La texture affich√©e a une r√©solution plus √©lev√©e - 160x90x64.  Apr√®s avoir d√©termin√© le nombre de sources lumineuses par tuile et leur indice, trois shaders de calcul sont ex√©cut√©s s√©quentiellement, effectuant les op√©rations suivantes: <br><br><ol><li>  Le premier passage d√©termine la quantit√© de lumi√®re entrant dans la cellule dans le volume sous la forme d'une pyramide de visibilit√©.  Chaque cellule accumule l'influence de toutes les sources de lumi√®re, comme si elles avaient des particules en suspension qui r√©agissent √† la lumi√®re et en renvoient une partie √† la cam√©ra. </li><li>  La deuxi√®me passe brouille l'√©clairage avec un petit rayon.  Ceci est probablement n√©cessaire pour √©viter le scintillement lors du d√©placement de la cam√©ra, car la r√©solution est tr√®s faible. </li><li>  La troisi√®me passe contourne la texture du volume d'avant en arri√®re, ajoutant progressivement l'influence de chaque source et donnant la texture finale.  En fait, il simule la quantit√© totale d'√©clairage entrant le long du faisceau jusqu'√† une distance donn√©e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puisque chaque cellule contient une partie de la lumi√®re r√©fl√©chie par les particules vers la cam√©ra, dans chacune d'elles, nous recevrons une contribution conjointe de toutes les cellules pr√©c√©demment pass√©es. </font><font style="vertical-align: inherit;">Ce passage est √©galement flou.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque tout cela est termin√©, nous obtenons une texture 3D qui indique la quantit√© de lumi√®re re√ßue par une position particuli√®re par rapport √† la cam√©ra. </font><font style="vertical-align: inherit;">Tout ce qui reste √† faire dans le passage plein √©cran est de d√©terminer cette position, de trouver le voxel correspondant de la texture et de l'ajouter au buffer HDR. </font><font style="vertical-align: inherit;">Le shader d'√©clairage lui-m√™me est tr√®s simple et ne contient qu'environ 16 instructions.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/939/e8a/b58939e8ae5abf2320c519abc51f6e8a.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âclairage volum√©trique</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1ab/006/e9d/1ab006e9d0b62e0ea0470751185ffe41.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âclairage volum√©trique apr√®s</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendu des cheveux </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la fonction PureHair n'est pas activ√©e, les couches de cheveux standard sont rendues les unes sur les autres. </font><font style="vertical-align: inherit;">Cette solution a toujours fi√®re allure, mais je voudrais me concentrer sur les derni√®res technologies. </font><font style="vertical-align: inherit;">Si la fonction est activ√©e, le cadre commence par une simulation des cheveux de Lara avec une s√©quence de shaders de calcul. </font><font style="vertical-align: inherit;">La premi√®re partie de Tomb Raider a utilis√© une technologie appel√©e TressFX, et dans la suite Crystal Dynamics a impl√©ment√© une technologie am√©lior√©e. </font><font style="vertical-align: inherit;">Apr√®s les calculs initiaux, nous obtenons jusqu'√† 7 tampons. </font><font style="vertical-align: inherit;">Tous sont utilis√©s pour contr√¥ler les cheveux de Lara. </font><font style="vertical-align: inherit;">Le processus est le suivant:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lancer un shader de calcul pour calculer les valeurs de mouvement en fonction des positions pr√©c√©dentes et actuelles (pour le flou de mouvement) </font></font></li><li>          1√ó1        () </li><li>   122       (Triangle Strip) (   ‚Äî  ).     ,         .    7 ,      .     ,      ,  .      ¬´ ¬ª. </li><li>  /   quad    ,     ,     .  ,          ,    . </li><li>       4,      (    ¬´ ¬ª) </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez en savoir plus √† ce sujet, AMD dispose de nombreuses </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ressources</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©sentations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , car il s'agit d'une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioth√®que publique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cr√©√©e par l'entreprise </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">J'ai √©t√© troubl√© par l'√©tape pr√©c√©dant l'√©tape 1, dans laquelle le m√™me appel de tirage est effectu√© que dans l'√©tape 3, on dit qu'il ne rend que des valeurs de profondeur, mais en fait le contenu n'est pas rendu, et c'est int√©ressant; </font><font style="vertical-align: inherit;">peut-√™tre que Renderdoc ne me dit rien. </font><font style="vertical-align: inherit;">Je soup√ßonne qu'il a peut-√™tre tent√© d'ex√©cuter une demande de rendu conditionnel, mais je ne vois aucun appel de pr√©diction.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21f/127/76f/21f12776f41f0893c37a677deca12529.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheveux en l'air</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/832/f49/ecd/832f49ecd96406db87ee99f3b1089de0.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pixels capillaires visibles</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/289/33e/030/28933e0309107cfcb3120564d55fd412.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheveux ombrag√©s</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendu en mosa√Øque de donn√©es alpha et de particules </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les objets transparents utilisent √† nouveau la classification des tuiles des sources lumineuses calcul√©e pour le passage d'√©clairage pr√©liminaire des tuiles. Chaque objet transparent calcule son propre √©clairage en une seule passe, c'est-√†-dire que le nombre d'instructions et de cycles devient assez effrayant (c'est pourquoi la passe pr√©liminaire d'√©clairage a √©t√© utilis√©e pour les objets opaques). Les objets transparents peuvent m√™me effectuer des r√©flexions dans l'espace de l'√©cran s'ils sont activ√©s! Chaque objet est rendu dans l'ordre de tri de l'arri√®re vers l'avant directement dans le tampon HDR, y compris le verre, la flamme, l'eau d'orni√®re, etc. Le passage alpha rend √©galement les bords mis en √©vidence lorsque Lara se concentre sur un objet (par exemple, une bouteille avec un m√©lange combustible sur une bo√Æte √† gauche).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/445/4a8/311/4454a83115f4118ab092fc1ff3bcaaf1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, les particules sont rendues dans un tampon √† demi-r√©solution afin de lisser l'√©norme charge sur la bande passante cr√©√©e par leur repeinture, en particulier lorsque beaucoup de grosses particules couvrant l'√©cran sont utilis√©es pour cr√©er du brouillard, du brouillard, de la flamme, etc. Par cons√©quent, le tampon HDR et le tampon de profondeur diminuent de moiti√© de chaque c√¥t√©, apr√®s quoi le rendu des particules commence. Les particules cr√©ent une √©norme quantit√© de redessin, certains pixels sont ombr√©s environ 40 fois. La carte thermique montre ce que je veux dire. Comme les particules ont √©t√© rendues en demi-r√©solution, la m√™me astuce de zoom intelligent est utilis√©e ici que dans l'√©clairage ambiant (les espaces sont marqu√©s dans le pochoir, la premi√®re passe se transforme en pixels internes, la seconde recr√©e les bords). Vous remarquerez peut-√™tre que les particules se traduisent par certains autres effets alpha, tels que la flamme,briller, etc. Cela est n√©cessaire pour que l'alpha puisse √™tre correctement tri√© par rapport, par exemple, √† la fum√©e. Vous pouvez √©galement remarquer que des rayons de lumi√®re ¬´volum√©triques¬ª apparaissent ici, provenant de projecteurs de s√©curit√©. Ils sont ajout√©s ici, et non cr√©√©s au stade de l'√©clairage volum√©trique. Il s'agit d'un moyen peu co√ªteux mais r√©aliste de les cr√©er sur de longues distances.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e78/0f1/c77/e780f1c77d8c9031e10b1ddc6faf6b20.jpg" alt="image"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/409/09c/1db40909cea712bec3b9f1d4eab109d7.jpg" alt="image"></div><br> <i> -</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c1/8f2/80a/2c18f280ab65f272470ff711def4b89e.jpg" alt="image"></div><br> <i>   1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/098/e29/66c/098e2966cf5d8bdc62a7d76bfdc2344e.jpg" alt="image"></div><br> <i>   2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/c73/f5a/e0bc73f5ab35af88840eebe45f175074.jpg" alt="image"></div><br> <i>   3</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb0/6ef/e9e/eb06efe9eb6fe1db3e749e6b1a6c1c9c.jpg" alt="image"><br> <i>   </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56e/263/ba6/56e263ba63ae60ee5af108c172711410.jpg" alt="image"></div><br> <i>  </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8f/564/288/e8f564288ae2310272be7ac9899409d9.jpg" alt="image"></div><br> <i> -</i> <br><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROTR effectue la vitesse d'obturation et la correction de tonalit√© en une seule passe. Cependant, bien que nous croyions g√©n√©ralement que la correction gamma se produit avec la correction de tonalit√©, ce n'est pas le cas ici. Il existe de nombreuses fa√ßons de mettre en ≈ìuvre l'exposition, comme nous l'avons vu avec d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autres </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jeux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Le calcul de la luminance dans ROTR est tr√®s int√©ressant et ne n√©cessite presque pas de donn√©es interm√©diaires ou de passes, nous allons donc expliquer ce processus plus en d√©tail. L'√©cran entier est divis√© en 64 √ó 64 tuiles, apr√®s quoi le calcul des groupes (20, 12, 1) de 256 flux dans chacun commence √† remplir tout l'√©cran. Chaque thread effectue essentiellement la t√¢che suivante (un pseudo-code est pr√©sent√© ci-dessous):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">16</span></span>; ++i) { uint2 iCoord = CalculateCoord(threadID, i, j); <span class="hljs-comment"><span class="hljs-comment">// Obtain coordinate float3 hdrValue = Load(hdrTexture, iCoord.xyz); // Read HDR float maxHDRValue = max3(hdrValue); // Find max component float minHDRValue = min3(hdrValue); // Find min component float clampedAverage = max(0.0, (maxHDRValue + minHDRValue) / 2.0); float logAverage = log(clampedAverage); // Natural logarithm sumLogAverage += logAverage; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chaque groupe calcule la somme logarithmique des 64 pixels (256 threads, chacun traitant 16 valeurs). Au lieu de stocker la valeur moyenne, il enregistre la somme et le nombre de pixels r√©ellement trait√©s (tous les groupes ne traitent pas exactement 64 √ó 64 pixels, car, par exemple, ils peuvent d√©passer les bords de l'√©cran). Shader utilise judicieusement le stockage des threads locaux pour diviser la somme; chaque flux fonctionne d'abord avec 16 valeurs horizontales, puis des flux s√©par√©s r√©sument toutes ces valeurs verticalement, et enfin le flux de contr√¥le de ce groupe (flux 0) ajoute le r√©sultat et les enregistre tous dans le tampon. Ce tampon contient 240 √©l√©ments, nous donnant essentiellement la luminosit√© moyenne de nombreuses zones de l'√©cran. La commande suivante d√©marre 64 threads qui bouclent autour de toutes ces valeurs et les ajoutent,pour obtenir la luminosit√© finale de l'√©cran. Il revient √©galement du logarithme en unit√©s lin√©aires.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je n'ai pas beaucoup d'exp√©rience avec les techniques d'exposition, mais la lecture de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce post de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Krzysztof Narkovic a clarifi√© certaines choses. L'enregistrement dans un tableau de 64 √©l√©ments est n√©cessaire pour calculer la moyenne mobile, dans laquelle vous pouvez afficher les valeurs calcul√©es pr√©c√©dentes et lisser la courbe pour √©viter des changements tr√®s brusques de luminosit√©, cr√©ant des changements brusques de vitesse d'obturation. Il s'agit d'un shader tr√®s complexe et je n'ai toujours pas compris tous ses d√©tails, mais le r√©sultat final est la valeur de la vitesse d'obturation correspondant √† l'image actuelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir trouv√© des vitesses d'obturation ad√©quates, un passage effectue la vitesse d'obturation finale plus la correction tonale. ROTR semble utiliser la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cartographie photographique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui explique l'utilisation de moyens logarithmiques au lieu des moyens habituels. </font><font style="vertical-align: inherit;">La formule de correction tonale dans le shader (apr√®s exposition) peut √™tre d√©velopp√©e comme suit:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bz/yv/-k/bzyv-kjhv-hs6lj3mh4yfrh427w.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/zn/1d/idzn1d3rn-3qs7vrokrn94d9z1m.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une br√®ve explication peut √™tre trouv√©e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Je n'ai pas pu comprendre pourquoi une division suppl√©mentaire par Lm est n√©cessaire, car elle annule l'influence de la multiplication. </font><font style="vertical-align: inherit;">Dans tous les cas, whitePoint est 1.0, donc le processus ne fait pas grand chose dans ce cadre, l'image ne fait que changer la vitesse d'obturation. </font><font style="vertical-align: inherit;">Il n'y a m√™me pas de limite aux valeurs de l'intervalle LDR! </font><font style="vertical-align: inherit;">Cela se produit pendant l'√©talonnage des couleurs, lorsque le cube de couleur limite indirectement les valeurs sup√©rieures √† 1,0.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1a/92f/2e8/e1a92f2e852892aa137c170a56718f8e.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposition √†</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/c4f/905/788c4f905eecffaa8d5dbd12d1c8972d.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exposition apr√®s</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âblouissement de l'objectif </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les reflets de l'objectif sont rendus de mani√®re int√©ressante. Une petite passe pr√©liminaire calcule une texture 1xN (o√π N est le nombre total d'√©l√©ments d'√©blouissement qui seront rendus sous forme de reflets de lentille, dans notre cas il y en a 28). Cette texture contient la valeur alpha de la particule et d'autres informations inutilis√©es, mais au lieu de la calculer √† partir d'une demande de visibilit√© ou quelque chose de similaire, le moteur la calcule en analysant le tampon de profondeur autour de la particule dans le cercle. Pour ce faire, les informations sur les sommets sont stock√©es dans un tampon disponible pour le pixel shader.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/604/e96/8a0604e96d5a4fe4ebf691719f03d75f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, chaque √©l√©ment est rendu comme de simples plans align√©s sur le plan √©mis par des sources lumineuses. </font><font style="vertical-align: inherit;">Si la valeur alpha est inf√©rieure √† 0,01, alors la valeur NaN est affect√©e √† la position afin que cette particule ne pixellise pas. </font><font style="vertical-align: inherit;">Ils sont un peu comme l'effet de floraison et ajoutent de l'√©clat, mais cet effet lui-m√™me est cr√©√© plus tard.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/526/da9/a18/526da9a184f303dc8e3bfd82cd16034a.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La lentille √©clate</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/465/440/335/4654403353e5b94dc7bae2a68b95ed88.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âl√©ments de lumi√®re parasite</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/f10/c43/5c1f10c4396cbd6a8502a28b5a53fe0f.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âblouissement de l'objectif apr√®s</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bloom </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bloom utilise une approche standard: sous-√©chantillonner le tampon HDR, les pixels lumineux sont isol√©s, puis leur √©chelle est augment√©e s√©quentiellement avec du flou pour √©tendre leur zone d'influence. Le r√©sultat est agrandi √† la r√©solution de l'√©cran et le compositing est superpos√© dessus. Il y a quelques points int√©ressants √† explorer. L'ensemble du processus est effectu√© √† l'aide de 7 shaders de calcul: 2 pour le sous-√©chantillonnage, 1 pour le flou simple, 4 pour le zoom avant.</font></font><br><br><ol><li>                  target   (mip 1).        .  ,   mip-    ,           0.02. </li><li>     mip      mip 2, 3, 4  5. </li><li>       mip 5.        ,    .       ,             . </li><li>   ‚Äî   .  3          ,   mip N    mip N + 1,       ,     .     bloom      ,     . </li><li>     mip 1      HDR-,      bloom. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/478/bc7/b0c478bc7ccc0c4774cea8b2aaa4ec8b.jpg" alt="image"></div><br> <i>Bloom </i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f77/b74/99b/f77b7499b451e0f232b06d183ccc04f4.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c65/ae2/875/c65ae2875487b8a9b441a9ce0b137430.jpg"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/9a4/757/55b9a4757f48867201dc76df90ea0dd1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba5/17d/a6f/ba517da6f179cca1067a08115579c155.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/91f/44d/33f91f44dcc1f9a395375fce8535ac2d.jpg" alt="image"></div><br> <i>MIP 5   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecb/561/33d/ecb56133d1965bcc93024c5cded95ec7.jpg"></div><br> <i> MIP 5  Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/235/0ed/474/2350ed47490101cda12baffbd61fc8f0.jpg"></div><br> <i>MIP 4   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff0/cfb/4df/ff0cfb4dfeea995b8666d4b8aec057a1.jpg"></div><br> <i>MIP 3   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/980/7ca/a31/9807caa31251495050af2e2fd32b5e90.jpg" alt="image"></div><br> <i>MIP 2   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/857/4be/854/8574be854f2526857ef9b6854d6f7235.jpg"></div><br> <i>MIP 1   Bloom</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9be/aa8/8a1/9beaa88a1bf00876801bb103ef85dd16.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Floraison apr√®s L'</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aspect curieux est que les textures √† √©chelle r√©duite modifient le rapport d'aspect. </font><font style="vertical-align: inherit;">Par souci de visualisation, je les ai corrig√©es, et je ne peux que deviner les raisons de cela; </font><font style="vertical-align: inherit;">peut-√™tre que cela est fait pour que les tailles de texture soient des multiples de 16. Un autre point int√©ressant: comme ces shaders sont g√©n√©ralement tr√®s limit√©s en bande passante, les valeurs stock√©es dans la m√©moire partag√©e de groupe sont converties de float32 √† float16! </font><font style="vertical-align: inherit;">Cela permet au shader d'√©changer des op√©rations math√©matiques pour doubler la m√©moire libre et la bande passante. </font><font style="vertical-align: inherit;">Pour que cela devienne un probl√®me, la plage de valeurs doit devenir assez large.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fxaa </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROTR prend en charge un large √©ventail de diff√©rentes techniques d'anticr√©nelage, telles que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FXAA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Fast Approximate AA) et SSAA (Super Sampling AA). </font><font style="vertical-align: inherit;">Il est √† noter que l'option d'activation de l'AA temporel est absente, car pour la plupart des jeux AAA modernes, elle devient standard. </font><font style="vertical-align: inherit;">Quoi qu'il en soit, FXAA fait face √† sa t√¢che de mani√®re remarquable, SSAA fonctionne √©galement bien, c'est une option plut√¥t "lourde" si le jeu manque de performances.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flou de mouvement </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il semble que Motion blur utilise une approche tr√®s similaire √† la solution dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadows of Mordor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Apr√®s avoir rendu l'√©clairage volum√©trique, une passe de rendu distincte renvoie les vecteurs de mouvement des objets anim√©s vers le tampon de mouvement. Ensuite, ce tampon est combin√© avec le mouvement provoqu√© par la cam√©ra, et le tampon de mouvement final devient entr√© dans la passe de flou, qui effectue le flou dans la direction indiqu√©e par les vecteurs de mouvement de l'espace d'√©cran. Pour estimer le rayon de flou en quelques passes, la texture des vecteurs de mouvement √† une √©chelle r√©duite est calcul√©e de sorte que chaque pixel ait une id√©e approximative du type de mouvement √† proximit√©. Le flou est effectu√© en plusieurs passes √† demi-r√©solution et, comme nous l'avons vu, plus tard, son √©chelle √† l'aide du pochoir augmente en deux passes. Plusieurs passes sont effectu√©es pour deux raisons: premi√®rement,pour r√©duire le nombre de lectures de texture n√©cessaires pour cr√©er un flou avec un rayon potentiellement tr√®s grand, et deuxi√®mement parce que diff√©rents types de flou sont effectu√©s. Cela d√©pend si le personnage anim√© √©tait sur les pixels actuels.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f4/91d/df6/3f491ddf60c6a1a6b9caeaec316eab4f.jpg" alt="image"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flou de mouvement</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e5/eb5/d42/2e5eb5d42d4e0c36c4c96e764538f8c8.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vitesse de flou de mouvement</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/3ed/2e7/edf3ed2e7144ec27ba21b3b16e606c7f.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 1</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c5/c65/931/7c5c6593183900a85a3d0372fce9eb03.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 2</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a3/bc5/bcc/8a3bc5bcc85c92d698fc081e49c0f318.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 3</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/5e1/a7e/04f5e1a7e722d9818c8a23ef5759c172.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 4</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9d/98f/579/f9d98f579e02acec8e3ef99e90bdd0c0.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 5</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99e/3ca/b5c/99e3cab5cbf5d25b2eea0d3311eae7cf.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Motion Blur Pass 6</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/042/af0/5bd/042af05bd488751c53bd97c73cb037fc.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flou de mouvement, zoom avant et arri√®re</font></font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e10/26d/c47/e1026dc47d9035e8713422ad8210e6a7.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flou de mouvement, zoom des bords</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caract√©ristiques et d√©tails suppl√©mentaires </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il y a quelques autres choses qui m√©ritent d'√™tre mentionn√©es sans trop de d√©tails. </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gel de l'appareil photo: par temps froid, ajoute des flocons de neige et du givre √† l'appareil photo </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cam√©ra sale: ajoute de la salet√© √† la cam√©ra. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Correction des couleurs: √† la fin du cadre, une petite correction des couleurs est effectu√©e, en utilisant un cube de couleurs assez standard pour effectuer la correction des couleurs, comme d√©crit ci-dessus, et ajoute √©galement du bruit pour rendre certaines sc√®nes plus graves </font></font></li></ol><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'interface utilisateur est impl√©ment√©e un peu inhabituelle - elle rend tous les √©l√©ments dans l'espace lin√©aire. </font><font style="vertical-align: inherit;">Habituellement, au moment du rendu, l'interface utilisateur avait d√©j√† effectu√© une correction de tonalit√© et une correction gamma. </font><font style="vertical-align: inherit;">Cependant, ROTR utilise un espace lin√©aire jusqu'√† la fin du cadre. </font><font style="vertical-align: inherit;">Cela a du sens, car le jeu rappelle une interface utilisateur 3D; </font><font style="vertical-align: inherit;">cependant, avant d'enregistrer des images sRGB dans le tampon HDR, elles doivent √™tre converties en espace lin√©aire afin que l'op√©ration la plus r√©cente (correction gamma) ne d√©forme pas les couleurs.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pour r√©sumer </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'esp√®re que vous avez appr√©ci√© la lecture de cette analyse de la m√™me mani√®re que je l'ai fait. </font><font style="vertical-align: inherit;">Personnellement, j'en ai certainement beaucoup appris. </font><font style="vertical-align: inherit;">F√©licitations aux talentueux d√©veloppeurs de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crystal Dynamics</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le travail fantastique accompli pour cr√©er ce moteur. </font><font style="vertical-align: inherit;">Je tiens √©galement √† remercier Baldur Karlsson pour son travail fantastique sur Renderdoc. </font><font style="vertical-align: inherit;">Son travail a fait du d√©bogage des graphiques sur un PC un processus beaucoup plus pratique. </font><font style="vertical-align: inherit;">Je pense que la seule chose un peu compliqu√©e dans cette analyse √©tait le suivi des lancements de shader eux-m√™mes, car au moment de la r√©daction de cette fonctionnalit√©, elle n'√©tait pas disponible pour DX12. </font><font style="vertical-align: inherit;">J'esp√®re qu'avec le temps cela appara√Ætra et nous serons tous tr√®s heureux.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr436500/">https://habr.com/ru/post/fr436500/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr436490/index.html">Motorola pr√©voit d'introduire l'incarnation de Razr v3</a></li>
<li><a href="../fr436492/index.html">Nous recherchons des conf√©renciers au 10e DIY Mitap 17 f√©vrier 2019</a></li>
<li><a href="../fr436494/index.html">Remplacement d'un disque tout en conservant une num√©rotation correcte dans CEPH</a></li>
<li><a href="../fr436496/index.html">PVS-Studio pour Java</a></li>
<li><a href="../fr436498/index.html">Software AG: pas seulement ARIS</a></li>
<li><a href="../fr436502/index.html">Abonnement Pampers ou comment vendre plus aux m√™mes clients</a></li>
<li><a href="../fr436504/index.html">Syst√®me en emballage ou contenu de l'emballage sous puce?</a></li>
<li><a href="../fr436506/index.html">Comment cr√©er un IA-raciste sans trop d'effort</a></li>
<li><a href="../fr436508/index.html">10 millions de dollars d'investissements et les louanges de Wozniak - cr√©er un ordinateur √©ducatif pour les enfants</a></li>
<li><a href="../fr436510/index.html">Donn√©es de base en d√©tail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>