<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”¹ ğŸ›€ğŸ» ğŸ‘©ğŸ»â€ğŸ¤ Cara kerja rendering game 3D: pemrosesan vertex â›…ï¸ ğŸ’ ğŸ‘›</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam posting ini kita akan mempertimbangkan tahap kerja dengan simpul. Artinya, kita harus kembali mendapatkan buku teks matematika dan mengingat alj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara kerja rendering game 3D: pemrosesan vertex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472688/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/070/e30/bd5/070e30bd57f6af2d7c1e36abe15f949b.jpg" alt="gambar"></div><br>  Dalam posting ini kita akan mempertimbangkan tahap kerja dengan simpul.  Artinya, kita harus kembali mendapatkan buku teks matematika dan mengingat aljabar linier, matriks, dan trigonometri.  Hore! <br><br>  Kami akan mencari tahu bagaimana model 3D ditransformasikan dan sumber cahaya diperhitungkan.  Kami juga akan menjelaskan secara detail perbedaan antara vertex dan geometri shaders, dan Anda akan mengetahui pada tahap apa tempat tessellation.  Untuk memfasilitasi pemahaman, kami menggunakan diagram dan contoh kode yang menunjukkan bagaimana permainan melakukan perhitungan dan memproses nilai. <br><br>  Tangkapan layar di awal posting menunjukkan GTA V game dalam mode tampilan gambar rangka.  Bandingkan dengan gambar rangka setengah Life yang jauh lebih kompleks. Gambar dibuat oleh thalixte dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReShade</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c4/562/7ee/4c45627ee9916f0bcdce6858b510b6a6.jpg"></div><a name="habracut"></a><br><h2>  Apa gunanya </h2><br>  Dalam dunia matematika, sebuah titik hanyalah sebuah tempat dalam ruang geometris.  Tidak ada yang lebih kecil dari titik, itu tidak memiliki ukuran, sehingga titik dapat digunakan untuk menentukan lokasi yang tepat dari awal dan akhir objek seperti segmen garis, bidang dan volume. <br><br>  Untuk grafik 3D, informasi tersebut sangat penting, penampilan semuanya tergantung padanya, karena semua objek ditampilkan sebagai set segmen garis, bidang, dll.  Gambar di bawah ini menunjukkan tangkapan layar dari Bethesda 2015 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fallout 4</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87b/33c/f82/87b33cf825a8ed9d87b7c8a7cc873e69.jpg"></div><br>  Mungkin tidak mudah bagi Anda untuk melihat bahwa ini hanyalah sekelompok besar titik dan garis, jadi kami akan menunjukkan kepada Anda bagaimana pemandangan yang sama terlihat dalam mode wireframe.  Dalam mode ini, mesin rendering 3D melewatkan tekstur dan efek yang dilakukan pada tahap piksel dan hanya menggambar garis multi-warna yang menghubungkan titik-titik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/430/8a0/f67/4308a0f6729ff459c600275d8755f12c.jpg"></div><br>  Sekarang semuanya terlihat sangat berbeda, tetapi kita melihat bagaimana semua garis digabungkan untuk membentuk berbagai objek, lingkungan, dan latar belakang.  Beberapa hanya terdiri dari puluhan garis, misalnya, batu di latar depan, sementara yang lain mengandung begitu banyak garis sehingga terlihat kokoh. <br><br>  Setiap titik di awal dan akhir setiap baris diproses dengan melakukan sejumlah kalkulasi.  Beberapa perhitungan sangat sederhana dan cepat, yang lain jauh lebih rumit.  Dengan memproses poin dalam kelompok, terutama dalam bentuk segitiga, Anda dapat mencapai peningkatan produktivitas yang signifikan, jadi mari kita lihat lebih dekat. <br><br><h2>  Apa yang dibutuhkan untuk sebuah segitiga? </h2><br>  <em>Segitiga</em> nama memperjelas bahwa sosok tersebut memiliki tiga sudut internal;  Untuk melakukan ini, ia membutuhkan tiga titik sudut dan tiga segmen yang menghubungkannya.  Memang benar untuk memanggil titik sudut <em>vertex (vertex)</em> (dalam bentuk jamak - verteks);  setiap titik didefinisikan oleh suatu titik.  Karena kita berada di dunia geometris tiga dimensi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sistem koordinat Cartesian</a> digunakan untuk poin.  Biasanya koordinat ditulis dalam bentuk tiga nilai, misalnya, (1, 8, -3), atau secara umum ( <em>x, y, z</em> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64c/b9e/77f/64cb9e77ffcc16159b4d201026a4ba04.png"></div><br>  Selanjutnya, kita bisa menambahkan dua simpul lagi untuk membentuk segitiga: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/732/482/c6b/732482c6b6faef01c7a7281f9b30da31.png"></div><br>  Perhatikan bahwa garis yang ditampilkan adalah opsional - kita dapat mengatur titik dan memberi tahu sistem bahwa ketiga simpul ini membentuk segitiga.  Semua data vertex disimpan dalam blok memori yang berdekatan yang disebut <em>vertex buffer</em> ;  informasi tentang gambar yang mereka bentuk dikodekan secara langsung dalam program rendering, atau disimpan dalam blok memori lain yang disebut <em>buffer indeks</em> . <br><br>  Jika informasi dikodekan dalam program rendering, maka berbagai bentuk yang dapat dibentuk oleh simpul disebut <em>primitif</em> .  Direct3D menyarankan menggunakan daftar untuk mereka, strip dan kipas dalam bentuk titik, garis, dan segitiga.  Ketika digunakan dengan benar, garis-garis segitiga menggunakan simpul untuk lebih dari satu segitiga, yang meningkatkan produktivitas.  Dalam contoh di bawah ini, kita melihat bahwa untuk membuat dua segitiga terhubung bersama, hanya empat simpul yang diperlukan - jika mereka dipisahkan, maka kita perlu enam simpul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41e/9cb/a1e/41e9cba1ee23a0b9787994ef7249d6ff.png"></div><br>  <i>Dari kiri ke kanan: daftar titik, daftar garis dan strip segitiga</i> <br><br>  Jika kita perlu memproses set simpul yang lebih besar, misalnya, dalam model NPC game, maka lebih baik menggunakan objek yang disebut <em>mesh</em> , blok memori lain, tetapi terdiri dari beberapa buffer (simpul, indeks, dll.) Dan memodelkan sumber daya tekstur .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dokumentasi online</a> Microsoft memiliki penjelasan singkat tentang cara menggunakan buffer ini. <br><br>  Untuk saat ini, mari kita fokus pada apa yang terjadi pada simpul-simpul ini dalam game 3D saat merender setiap frame baru.  Singkatnya, mereka melakukan salah satu dari dua operasi: <br><br><ul><li>  Vertex bergerak ke posisi baru. </li><li>  Perubahan warna vertex </li></ul><br>  Siap untuk matematika?  Luar biasa, karena kita membutuhkannya. <br><br><h2>  Vektor muncul di atas panggung. </h2><br>  Bayangkan Anda memiliki segitiga di layar dan Anda menekan tombol untuk memindahkannya ke kiri.  Secara alami, kami mengharapkan angka ( <em>x, y, z</em> ) dari setiap titik akan berubah sesuai;  itulah yang terjadi, tetapi cara yang agak tak terduga <em>untuk</em> menerapkan perubahan.  Alih-alih hanya mengubah koordinat, sebagian besar sistem rendering grafik 3D menggunakan alat matematika khusus: maksud kami <em>vektor</em> . <br><br>  Vektor dapat direpresentasikan sebagai panah yang menunjuk ke titik tertentu dalam ruang dan memiliki panjang yang diinginkan.  Verteks biasanya diset menggunakan vektor berdasarkan koordinat Cartesius: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/5e4/79d/1c55e479dbf4da359cfa6ef7e3d55e8f.png"></div><br>  Perhatikan bahwa panah biru dimulai di satu tempat (dalam hal ini, <em>titik asal</em> ) dan meluas ke atas.  Untuk mengatur vektor, kami menggunakan <em>catatan dalam kolom</em> , tetapi sangat mungkin untuk menggunakan <em>catatan dalam satu baris</em> .  Anda mungkin telah memperhatikan bahwa ada nilai lain, keempat, yang biasa disebut <em>komponen-w</em> .  Ini digunakan untuk menunjukkan apa kepanjangan dari vektor: posisi titik ( <em>vektor posisi</em> ) atau arah umum (vektor <em>arah</em> ).  Dalam kasus vektor arah, akan terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb2/73e/525/bb273e52588aa21666075a11a34ee32d.png"></div><br>  Vektor ini menunjuk ke arah yang sama dan memiliki panjang yang sama dengan vektor posisi sebelumnya, yaitu nilainya ( <em>x, y, z</em> ) akan sama;  Namun, komponen <em>w</em> bukan 1, tetapi nol.  Kami akan menjelaskan penggunaan vektor arah nanti, tetapi untuk sekarang, ingat fakta bahwa semua simpul dalam adegan 3D akan dijelaskan dengan cara ini.  Mengapa  Karena dalam format ini lebih mudah untuk memindahkannya. <br><br><h2>  Matematika, matematika, dan matematika lagi </h2><br>  Ingatlah bahwa kita memiliki segitiga sederhana dan kami ingin memindahkannya ke kiri.  Setiap simpul dijelaskan oleh vektor posisi, oleh karena itu, "matematika gerakan" (disebut <em>transformasi</em> ) harus bekerja dengan vektor-vektor ini.  Alat baru muncul: <em>matriks</em> ( <em>matriks</em> dalam bentuk tunggal).  Ini adalah array nilai yang ditulis dalam format yang mirip dengan spreadsheet Excel, dengan baris dan kolom. <br><br>  Untuk setiap jenis transformasi ada matriks yang sesuai, dan untuk transformasi itu cukup dengan melipatgandakan matriks transformasi dan vektor posisi.  Kami tidak akan membahas secara terperinci bagaimana dan mengapa hal ini terjadi, tetapi hanya melihat bagaimana tampilannya. <br><br>  Memindahkan simpul dalam ruang 3D disebut <em>terjemahan,</em> dan membutuhkan perhitungan berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/c9b/eca/530c9beca19d9b0c8d61db78ecb8682a.png"></div><br>  Nilai <em>x <sub>0</sub></em> , dll.  mewakili koordinat asli vektor;  <em>nilai delta</em> - <em>x</em> mewakili jumlah titik yang perlu dipindahkan.  Penggandaan matriks dan vektor mengarah pada fakta bahwa mereka hanya meringkas (perhatikan bahwa komponen- <em>w</em> tetap tidak berubah sehingga jawaban yang sudah selesai tetap vektor posisi seperti sebelumnya). <br><br>  Selain bergerak, kita mungkin juga perlu memutar segitiga atau mengubah skalanya - untuk operasi ini, ada juga transformasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1fc/ba4/d0b/1fcba4d0b2a678e94c17c49a09af0591.png"></div><br>  <i>Transformasi ini memutar titik di sekitar sumbu z pada bidang XY</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5eb/1d5/26e/5eb1d526eb15b522f3fddb0dadffa8cf.png"></div><br>  <em>Dan ini digunakan jika Anda perlu mengubah skala gambar</em> <br><br>  Kita dapat menggunakan alat grafis berbasis WebGL dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Real-Time Rendering</a> untuk memvisualisasikan perhitungan ini untuk keseluruhan gambar.  Mari kita mulai dengan kotak di posisi standar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/5d7/3d2/2205d73d2920758e3fb11f6829cb924d.jpg"></div><br>  Dalam alat online ini, titik model adalah vektor posisi, matriks dunia adalah matriks transformasi, dan titik ruang-dunia adalah vektor posisi untuk transformasi verteks. <br><br>  Mari kita terapkan berbagai transformasi pada kotak: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/820/d7b/5d6/820d7b5d618f68de9446d0ee005a50da.jpg"></div><br>  Pada gambar di atas, gambar <em>dipindahkan</em> 5 unit di sepanjang setiap sumbu.  Nilai-nilai ini dapat dilihat di kolom terakhir dari matriks besar menengah.  Vektor posisi asli (4, 5, 3, 1) tetap sama seperti seharusnya, tetapi vertex yang ditransformasikan sekarang dipindahkan ke (9, 10, 8, 1). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a1/8c4/6fd/9a18c46fd6df9936f3632fd4e4b2a287.jpg"></div><br>  Dalam transformasi ini, semuanya diskalakan dengan faktor 2: sekarang sisi kotak menjadi dua kali lebih panjang.  Akhirnya, lihat contoh rotasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/beb/340/21cbeb3409b55b736d2dd1322a1d80b0.jpg"></div><br><br>  Paralipipip diputar melalui sudut 45 Â°, tetapi <em>sinus</em> dan <em>kosinus</em> sudut ini digunakan dalam matriks.  Setelah memeriksa kalkulator ilmiah, kita dapat melihat bahwa <em>dosa (45 Â°)</em> = 0,7071 ..., yang dibulatkan ke nilai yang ditunjukkan 0,71.  Kami mendapatkan jawaban yang sama untuk nilai <em>cosinus</em> . <br><br>  Matriks dan vektor adalah opsional;  Alternatif yang populer bagi mereka, terutama ketika menangani belokan kompleks, adalah penggunaan bilangan kompleks dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">angka empat</a> .  Perhitungan ini sangat berbeda dari vektor, jadi kami tidak akan mempertimbangkannya, terus bekerja dengan transformasi. <br><br><h2>  Vertex Shader Power </h2><br>  Pada tahap ini, kita perlu memahami bahwa semua ini dilakukan oleh orang yang memprogram kode rendering.  Jika pengembang game menggunakan mesin pihak ketiga (misalnya, Unity atau Unreal), maka semua ini telah dilakukan untuknya;  tetapi jika seseorang membuat mesinnya dari awal, maka dia harus melakukan semua perhitungan ini dengan simpul. <br><br>  Tetapi bagaimana semua ini terlihat dari segi kode? <br><br>  Untuk memahami ini, kami akan menggunakan contoh dari situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Braynzar Soft yang</a> menakjubkan.  Jika Anda ingin mulai bekerja dengan pemrograman 3D sendiri, maka ini adalah tempat yang tepat untuk mempelajari dasar-dasarnya, serta hal-hal yang lebih kompleks ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/726/99f/664/72699f66423a8f3094cb911bc99a18e2.png"></div><br>  Ini adalah contoh dari transformasi all-in-one.  Ini menciptakan matriks transformasi yang sesuai berdasarkan input keyboard, dan kemudian menerapkannya ke vektor posisi asli dalam satu operasi.  Perhatikan bahwa ini selalu dilakukan dalam urutan yang diberikan (penskalaan - rotasi - transfer), karena cara lain akan benar-benar merusak hasilnya. <br><br>  Blok kode semacam itu disebut <em>vertex shaders</em> , kompleksitas dan ukurannya dapat sangat bervariasi.  Contoh di atas sederhana, <em>hanya</em> vertex shader yang tidak menggunakan sifat penuh shader yang dapat diprogram.  Urutan shader yang lebih kompleks dapat mengubah objek dalam ruang 3D, memproses penampilan mereka dari sudut pandang kamera pemandangan, dan kemudian mentransfer data ke tahap selanjutnya dari proses rendering.  Mempertimbangkan urutan pemrosesan vertex, kita akan mempelajari contoh-contoh lain. <br><br>  Tentu saja, mereka dapat digunakan lebih banyak lagi, jadi ketika memainkan game 3D, jangan lupa bahwa semua gerakan yang Anda lihat dibuat oleh GPU yang menjalankan perintah vertex shader. <br><br>  Namun, ini tidak selalu terjadi.  Jika Anda kembali ke pertengahan akhir 1990-an, maka kartu grafis pada zaman itu tidak memiliki kemampuan untuk secara mandiri memproses simpul dan primitif, hanya prosesor pusat yang melakukan semua ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/954/1d1/c15/9541d1c150a6ef926d98449addf51206.jpg"></div><br>  Salah satu prosesor pertama dengan akselerasi perangkat keras mereka sendiri dari proses ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nvidia GeForce, dirilis pada tahun 2000</a> , dan fungsi ini disebut <em>Hardware Transform and Lighting</em> (singkatnya, Hardware TnL).  Proses yang dapat ditangani oleh peralatan ini sangat terbatas dalam hal tim, tetapi dengan merilis chip baru, situasinya berubah dengan cepat.  Saat ini, tidak ada peralatan terpisah untuk memproses simpul, dan satu perangkat melakukan semuanya sekaligus: titik, primitif, piksel, tekstur, dll. <br><br>  Ngomong-ngomong, tentang <em>pencahayaan</em> : perlu dicatat bahwa kita melihat semuanya berkat cahaya, jadi mari kita lihat bagaimana hal itu dapat diproses pada tahap puncak.  Untuk melakukan ini, kita perlu mengambil keuntungan dari apa yang kita bicarakan sebelumnya. <br><br><h2>  Cahaya, kamera, motor! </h2><br>  Bayangkan gambar ini: pemain berdiri di ruangan gelap, diterangi oleh satu sumber cahaya di sebelah kanan.  Di tengah ruangan ada ketel besar.  Anda mungkin perlu bantuan untuk hal ini, jadi mari gunakan situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Real-Time Rendering</a> dan lihat tampilannya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1a/6a4/5f4/b1a6a45f47e81bec587c4f7bda1bf3ae.jpg"></div><br>  Jangan lupa bahwa objek ini adalah seperangkat segitiga datar yang saling terhubung;  artinya, bidang setiap segitiga akan diarahkan ke arah tertentu.  Beberapa dari mereka diarahkan ke kamera, beberapa - yang lain, beberapa akan terdistorsi.  Cahaya dari sumber jatuh pada setiap bidang dan dipantulkan dari sana pada sudut tertentu. <br><br>  Tergantung di mana cahaya dipantulkan, warna dan kecerahan pesawat dapat berubah, dan agar warna objek terlihat benar, semua ini perlu dihitung dan diperhitungkan. <br><br>  Untuk memulainya, kita perlu mencari tahu di mana setiap pesawat diarahkan, dan untuk ini kita perlu <em>vektor normal</em> pesawat.  Ini adalah panah lain, tetapi tidak seperti vektor posisi, ukurannya tidak penting (pada kenyataannya, setelah menghitung skala vektor normal selalu berkurang sehingga mereka memiliki panjang 1), dan selalu diarahkan <em>tegak lurus</em> (pada sudut kanan) ke pesawat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/228/84c/836/22884c83697e201f3b00bb7d06f6f95f.png"></div><br>  Normal ke bidang setiap segitiga dihitung dengan menentukan produk vektor dari vektor dua arah (ditunjukkan di atas <strong>p</strong> dan <strong>q</strong> ) yang membentuk sisi-sisi segitiga.  Sebenarnya, lebih baik untuk menghitung mereka untuk setiap titik, dan bukan untuk segitiga, tetapi karena selalu ada lebih banyak dari yang pertama daripada yang terakhir, akan lebih cepat untuk menghitung normal untuk segitiga. <br><br>  Setelah menerima yang normal ke permukaan, Anda dapat mulai mempertimbangkan sumber cahaya dan kamera.  Dalam rendering 3D, sumber cahaya bisa dari berbagai jenis, tetapi dalam artikel ini kami hanya akan mempertimbangkan sumber <em>arah</em> , misalnya, lampu sorot.  Seperti bidang segitiga, sorotan dan kamera akan menunjuk ke arah tertentu, sesuatu seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a8/f24/b91/3a8f24b915d631a9608faaf106b04300.png"></div><br>  Vektor sumber cahaya dan vektor normal dapat digunakan untuk menghitung sudut di mana cahaya jatuh di permukaan (menggunakan hubungan antara produk skalar vektor dan produk ukurannya).  Verteks segitiga akan berisi informasi tambahan tentang warna dan bahannya.  Materi menggambarkan apa yang terjadi pada cahaya ketika menyentuh permukaan. <br><br>  Permukaan logam yang halus akan memantulkan hampir semua cahaya yang terjadi pada sudut jatuh, dan nyaris tidak mengubah warna objek.  Bahan matte kasar menyebarkan cahaya dengan cara yang tidak dapat diprediksi dan sedikit berubah warna.  Untuk memperhitungkan ini, Anda perlu menambahkan nilai tambahan ke simpul: <br><br><ul><li>  Warna dasar asli </li><li>  Ambient Material Attribute - nilai yang menentukan seberapa banyak pencahayaan "latar belakang" dapat menyerap dan memantulkan suatu titik </li><li>  Atribut bahan Diffuse adalah nilai lain, tetapi kali ini menentukan "kekasaran" dari titik, yang, pada gilirannya, mempengaruhi jumlah penyerapan dan refleksi dari cahaya yang tersebar. </li><li>  Atribut Bahan Specular - Dua Nilai yang Menentukan Gloss Vertex </li></ul><br>  Model pencahayaan yang berbeda menggunakan rumus matematika yang berbeda untuk mengelompokkan semua atribut ini, dan hasil perhitungannya adalah vektor pencahayaan keluar.  Dalam kombinasi dengan vektor kamera, ini memungkinkan Anda untuk menentukan keseluruhan tampilan segitiga. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/627/648/a21/627648a213ed357982314f7ed7fdd915.jpg"></div><br>  <i>Satu sumber cahaya terarah menerangi banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">demo Nvidia yang</a> berbeda</i> <br><br>  Kami menghilangkan banyak detail, dan untuk alasan yang baik: buka tutorial rendering 3D apa pun, dan Anda akan melihat bahwa seluruh bab dikhususkan untuk proses ini.  Namun, dalam gim modern, sebagian besar dari semua perhitungan pencahayaan dan efek material dilakukan pada tahap pemrosesan piksel, jadi kami akan kembali ke mereka di artikel berikutnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/8b7/3b0/d7c8b73b0185c20eb23b2a9fdee1cba6.png"></div><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sampel</a> B. Anguelov menunjukkan bagaimana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model refleksi cahaya Phong</a> dapat diproses dalam vertex shader.</i> <br><br>  Semua yang kami periksa di atas dilakukan oleh vertex shaders, dan tampaknya tidak ada yang mustahil bagi mereka;  sayangnya tidak demikian.  Vertex shaders tidak dapat membuat simpul baru, dan setiap shader harus memproses setiap vertex individu.  Akan lebih mudah jika Anda bisa menggunakan kode untuk membuat segitiga baru di antara yang sudah kita miliki (untuk meningkatkan kualitas visual), dan memiliki shader yang memproses keseluruhan primitif (untuk mempercepat pemrosesan).  Nah, dalam GPU modern kita <em>bisa</em> melakukannya! <br><br><h2>  Tolong pak, saya ingin lebih (segitiga) </h2><br>  Chip grafis modern sangat kuat dan mampu melakukan jutaan perhitungan matriks-vektor setiap detik;  mereka dengan mudah mengatasi tumpukan besar puncak sekaligus.  Di sisi lain, membuat model yang sangat rinci untuk rendering adalah proses yang sangat panjang, dan jika model agak jauh dari tempat kejadian, maka semua detail ini akan sia-sia. <br><br>  Artinya, kita perlu entah bagaimana memerintahkan prosesor untuk membagi primitif besar, misalnya, satu segitiga datar menjadi satu set segitiga lebih kecil yang terletak di dalam yang asli.  Proses semacam itu disebut <em>tesselation,</em> dan chip grafis telah belajar untuk melakukannya dengan sangat baik;  selama bertahun-tahun pembangunan, tingkat kontrol yang dimiliki programmer atas proses ini telah meningkat. <br><br>  Untuk melihat ini dalam tindakan, kita akan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat benchmark Heaven dari mesin Unigine</a> , karena itu memungkinkan kita untuk menerapkan nilai tessellation yang berbeda untuk model yang digunakan dalam pengujian. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d11/630/5fd/d116305fd0fa789635bc3631a4463829.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk memulai, mari kita mengambil tempat di benchmark dan mempelajarinya tanpa menggunakan tessellation. </font><font style="vertical-align: inherit;">Perhatikan bahwa batu bulat di tanah terlihat sangat tidak wajar - tekstur yang digunakan efektif, tetapi tampaknya salah. </font><font style="vertical-align: inherit;">Mari kita terapkan tessellation ke TKP: mesin Unigine hanya menerapkannya pada masing-masing bagian, tetapi perbedaannya akan signifikan.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1c/8fb/399/e1c8fb3998d448711164832c4b3af2ff.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tanah, tepi bangunan dan pintu terlihat jauh lebih realistis. </font><font style="vertical-align: inherit;">Kita bisa melihat bagaimana ini dicapai dengan memulai proses lagi, tapi kali ini dengan pemilihan semua primitif (yaitu, dalam mode rangka gambar):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c2/691/fec/0c2691fec046708d4c65058ed3cec016.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terlihat jelas mengapa bumi terlihat sangat aneh - benar-benar datar! Pintunya menyatu dengan dinding, dan ujung-ujung bangunannya sejajar sederhana. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam Direct3D, primitif dapat dibagi menjadi sekelompok bagian yang lebih kecil (proses ini disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sub-divisi) dengan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> melakukan proses tiga langkah. Pertama, programmer menulis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">surface shader (hull shader)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - pada kenyataannya, kode ini menciptakan struktur yang disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patch geometri</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Anda dapat menganggapnya sebagai peta yang memberi tahu prosesor tempat titik dan garis baru akan muncul di dalam primitif awal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian, blok tessellator di dalam GPU menerapkan tambalan ini ke primitif. Pada akhirnya, </font><em><font style="vertical-align: inherit;">shader domain</font></em><font style="vertical-align: inherit;"> dijalankan</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menghitung posisi semua simpul baru. Jika perlu, data ini dapat ditransfer kembali ke vertex buffer sehingga perhitungan pencahayaan dapat dilakukan lagi, tetapi kali ini dengan hasil yang lebih baik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti apa bentuknya? Mari kita luncurkan versi gambar rangka dari adegan tessellated:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c0/ca9/5af/3c0ca95af3ce89f1ae854706dfd04adc.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jujur, kami menetapkan tingkat tessellation yang agak tinggi untuk membuat penjelasan proses lebih terlihat. Tidak peduli seberapa bagus chip grafis modern, ini tidak boleh dilakukan di setiap adegan - lihat, misalnya, pada lampu di sebelah pintu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam gambar dengan bingkai gambar dinonaktifkan, Anda tidak akan menemukan perbedaan pada jarak ini, dan kami melihat bahwa tingkat tessellation seperti menambahkan begitu banyak segitiga sehingga sulit untuk memisahkan mereka dari satu sama lain. Namun, ketika digunakan dengan benar, fungsi pemrosesan dhuwur ini dapat menciptakan efek visual yang fantastis, terutama ketika mensimulasikan tabrakan benda lunak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari kita lihat bagaimana tampilannya dalam hal kode Direct3D; untuk ini kami menggunakan contoh dari situs web hebat lainnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RasterTek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Berikut adalah segitiga hijau sederhana yang di-tessellated menjadi banyak segitiga kecil ... </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/3bd/3d4/13a3bd3d482f26404d92d3ab60694fa3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan </font><font style="vertical-align: inherit;">vertex </font><font style="vertical-align: inherit;">dilakukan oleh tiga shader terpisah (lihat </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contoh kode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ): shader vertex yang menyiapkan segitiga untuk tessellation, shader permukaan yang menghasilkan tambalan, dan shader domain yang memproses simpul baru. </font><font style="vertical-align: inherit;">Hasilnya cukup jelas, tetapi contoh Unigine menunjukkan manfaat potensial dan bahaya penghentian penggunaan di mana-mana.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Besi" tidak tahan! </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingat, kami mengatakan bahwa vertex shader selalu memproses setiap titik tunggal dalam sebuah adegan? Mudah dipahami bahwa penghentian bisa menjadi masalah serius di sini. Dan ada banyak efek visual di mana Anda perlu memproses versi yang berbeda dari satu primitif, tetapi tanpa membuatnya dari awal, misalnya, rambut, bulu, rumput, dan partikel ledakan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untungnya, terutama untuk hal-hal seperti itu, ada shader lain - </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shader geometris</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini adalah versi vertex shader yang lebih terbatas, tetapi dapat diterapkan ke seluruh primitif. Dalam kombinasi dengan tessellation, itu memberi programmer peningkatan kontrol atas kelompok besar simpul.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/602/97d/f09/60297df09a132ab07b00140fa2a07b77.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3DMark Vantage UL Benchmark - partikel proses shader geometri dan bendera</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Direct3D, seperti semua API grafik modern, memungkinkan Anda untuk melakukan banyak perhitungan dengan simpul. Data yang sudah jadi dapat ditransfer ke tahap selanjutnya dari proses rendering ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rasterisasi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), atau dikembalikan ke kumpulan memori untuk diproses ulang atau dibaca oleh prosesor pusat untuk tujuan lain. Seperti yang </font><font style="vertical-align: inherit;">dijelaskan oleh </font><font style="vertical-align: inherit;">dokumentasi Microsoft pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct3D</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ini dapat diimplementasikan sebagai aliran data:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/638/134/de2/638134de2960977f2847aab27c88df84.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">output stream adalah</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> opsional, terutama karena hanya dapat mentransfer seluruh primitif (daripada simpul individu) kembali ke siklus rendering, tetapi berguna untuk efek yang membutuhkan sejumlah besar partikel. Trik yang sama dapat dilakukan dengan menggunakan </font><font style="vertical-align: inherit;">buffer vertex </font><font style="vertical-align: inherit;">variabel atau </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dinamis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi lebih baik untuk menjaga buffer input tidak berubah, karena ketika Anda membukanya untuk diedit, kinerja berkurang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrosesan vertex adalah bagian penting dari rendering, karena menentukan seperti apa pemandangan itu dari perspektif kamera. Dalam gim modern, jutaan segitiga dapat digunakan untuk membangun dunia, dan masing-masing simpul ini entah bagaimana diubah dan diterangi.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bdd/760/829/bdd760829e81753b4938fd8ff3076b6d.jpg"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segitiga. </font><font style="vertical-align: inherit;">Ada jutaan dari mereka. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memproses semua perhitungan dan matematika ini mungkin tampak seperti mimpi buruk logistik, tetapi prosesor grafis (GPU) dan API dirancang dengan semua ini dalam pikiran - bayangkan sebuah pabrik yang berfungsi sempurna melewati satu produk pada suatu waktu melalui pipa produksi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemrogram </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rendering game 3D yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berpengalaman </font><font style="vertical-align: inherit;">memiliki pengetahuan dasar dalam matematika dan fisika; </font><font style="vertical-align: inherit;">mereka menggunakan semua trik dan alat yang mungkin untuk mengoptimalkan operasi, mengompresi tahap pemrosesan vertex menjadi hanya beberapa milidetik. </font><font style="vertical-align: inherit;">Tapi ini baru permulaan membangun bingkai 3D - tahap selanjutnya adalah rasterisasi, kemudian pemrosesan piksel dan tekstur yang sangat kompleks, dan baru kemudian gambar tersebut masuk ke monitor.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472688/">https://habr.com/ru/post/id472688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472674/index.html">Variabel Lingkungan untuk Proyek Python</a></li>
<li><a href="../id472676/index.html">Kami membuat departemen jones untuk membantu tim utama, hanya menggunakan Slack, Jira dan pita listrik biru</a></li>
<li><a href="../id472682/index.html">Memperlambat Penuaan dengan Sinergi Narkoba di C. elegans</a></li>
<li><a href="../id472684/index.html">Surprise fsync () PostgreSQL</a></li>
<li><a href="../id472686/index.html">Studio Video Berdasarkan i486</a></li>
<li><a href="../id472690/index.html">Apa yang Baru di Zabbix 4.4</a></li>
<li><a href="../id472694/index.html">Lebih dari Ceph: MCS Block Cloud Storage</a></li>
<li><a href="../id472702/index.html">JH Rainwater "Cara merumput kucing": keturunan programmer dan fitur pembiakan mereka</a></li>
<li><a href="../id472708/index.html">Imperva mengungkapkan rincian teknis peretasan Cloud WAF</a></li>
<li><a href="../id472714/index.html">Dimana pekerja front-end untuk mencari pekerjaan dan tidak jatuh cinta: Telegram, Slack dan tidak hanya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>