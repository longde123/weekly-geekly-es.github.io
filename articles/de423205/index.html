<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😿 ♊️ 🚘 Speicherprojekt auf MS SQL Server, Integration in 1C 7.7 und Entwicklungsautomatisierung in SSDT 📋 ⛲️ 👩🏿‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Zeit läuft davon und bald wird fast nichts mehr von dieser Entwicklung übrig sein, aber ich hatte immer noch keine Zeit, sie zu beschreiben. 



 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Speicherprojekt auf MS SQL Server, Integration in 1C 7.7 und Entwicklungsautomatisierung in SSDT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423205/">  Die Zeit läuft davon und bald wird fast nichts mehr von dieser Entwicklung übrig sein, aber ich hatte immer noch keine Zeit, sie zu beschreiben. <br><br><img src="https://habrastorage.org/webt/fi/5s/if/fi5siftwc5fvceqqsjgxfnqubum.png"><br><br>  Es geht um ein Unternehmen auf Bundesebene mit einer Vielzahl von Niederlassungen und Unterzweigen.  Aber wie immer hat alles vor langer Zeit mit einem kleinen Laden angefangen.  Im Laufe der Jahre fand eine ziemlich schnelle und spontane Entwicklung statt, Zweigstellen, Abteilungen und andere Büros erschienen, und die IT-Infrastruktur wurde in jenen Tagen nicht angemessen berücksichtigt, und dies ist auch ein häufiges Ereignis.  Natürlich wurde 1C77 überall verwendet, ohne dass eine Replikation und Skalierung erforderlich war. Daher kamen wir am Ende zu dem Schluss, dass ein Sprut-Frankenstein mit Tentakeln erzeugt wurde, die mit Klebeband gebunden waren - in jedem Zweig gab es eine autonome Mutante, die mit der zentralen Basis ausgetauscht wurde im "kniehohen" Modus nur wenige Nachschlagewerke, ohne die es überhaupt nicht möglich war, und der Rest ist autonom.  Für einige Zeit begnügten sie sich mit Kopien (Dutzende von ihnen!) Von Zweigstellen in der Zentrale, aber die Daten in ihnen blieben mehrere Tage zurück. <br><br>  Für die Realität ist es jedoch erforderlich, Informationen schneller und flexibler zu erhalten, und damit muss noch etwas anderes getan werden.  Der Übergang von einem Buchhaltungssystem zu einem anderen in einer solchen Größenordnung ist immer noch ein Sumpf.  Daher wurde beschlossen, ein Data Warehouse (DX) zu erstellen, in dem Informationen aus verschiedenen Datenbanken fließen, damit später andere Dienste und das Analysesystem in Form von Cubes, SSRS-Berichten und Leckagen Daten von dieser CD erhalten können. <br><br>  Mit Blick auf die Zukunft werde ich sagen, dass der Übergang zu einem neuen Buchhaltungssystem fast abgeschlossen ist und der größte Teil des hier beschriebenen Projekts in naher Zukunft als unnötig gekürzt wird.  Entschuldigung, aber nichts kann getan werden. <br><br>  Das Folgende ist ein langer Artikel, aber bevor Sie mit dem Lesen beginnen, möchte ich darauf hinweisen, dass ich diese Entscheidung in keinem Fall als Standard übergebe, aber vielleicht findet jemand etwas Nützliches darin. <br><a name="habracut"></a><br>  Ich beginne mit einer allgemeinen Herangehensweise an das Projekt, für das SSDT als Entwicklungsumgebung ausgewählt wurde, mit der anschließenden Veröffentlichung des Projekts in Git.  Ich denke, dass es heute genug verschiedene Artikel und Tutorials gibt, die die Stärken dieses Tools beschreiben.  Es gibt jedoch einige Punkte, deren Problem außerhalb dieser Umgebung liegt. <br><br><h4>  Speicherung von Aufzählungen und Datenbankversionen </h4><br>  In Bezug auf Versionen und Aufzählungen bedeuteten die Anforderungen für das Projekt: <br><br><ul><li>  Bequemes Bearbeiten und Verfolgen von Änderungen in der Datenbankversion innerhalb des Projekts </li><li>  Bequemes Anzeigen der Datenbankversion über SSMS für Administratoren </li><li>  Speichern des Verlaufs von Versionsänderungen in der Datenbank selbst (wer und wann hat die Bereitstellung durchgeführt) </li><li>  Aufzählungen in einem Projekt speichern </li><li>  Einfache Bearbeitung und Verfolgung von Änderungen bei Übertragungen </li><li>  Datenbankbereitstellungssperre über einer vorhandenen, wenn keine inkrementelle Version vorhanden war </li><li>  Die Installation einer neuen Version, die Aufzeichnung des Verlaufs, der Übertragungen und die Umstrukturierung sollten in einer Transaktion durchgeführt und im Falle eines Ausfalls zu jedem Zeitpunkt vollständig zurückgesetzt werden </li></ul><br>  Weil  Übertragungen enthalten häufig Logik und sind Grundwerte, ohne die das Hinzufügen von Datensätzen zu anderen Tabellen (aufgrund von FK-Fremdschlüsseln) unmöglich wird. Im Wesentlichen sind sie zusammen mit Metadaten Teil der Datenbankstruktur.  Daher führt eine Änderung eines Aufzählungselements zu einer Erhöhung der Datenbankversion. Zusammen mit dieser Version muss garantiert werden, dass die Datensätze während der Bereitstellung aktualisiert werden. <br><br>  Ich denke, alle Vorteile des Blockierens der Bereitstellung ohne Inkrementieren der Version liegen auf der Hand. Eine davon ist die Unfähigkeit, das Veröffentlichungsskript erneut auszuführen, wenn es bereits früher erfolgreich ausgeführt wurde. <br><br>  Obwohl dem Datenbanknetzwerk häufig vorgeschlagen wird, nur die Hauptversion (ohne Brüche) zu verwenden, haben wir uns für Versionen im XY-Format entschieden, wobei Y der Patch ist, als ein Tippfehler in der Beschreibung der Tabelle, Spalte, des Namens des Auflistungselements oder etwas anderem Kleinen korrigiert wurde. B. Hinzufügen eines Kommentars zu einer gespeicherten Prozedur usw.  In allen anderen Fällen wird die Hauptversion erstellt. <br><br>  Vielleicht gibt es für jemanden nichts <i>dergleichen</i> und alles ist offensichtlich.  Aber ich habe zu gegebener Zeit ziemlich viel Nerven und Energie in interne Streitigkeiten über das Speichern von Übertragungen im Datenbankprojekt gesteckt, so dass es Feng Shui war ( <i>gemäß meiner Vorstellung davon</i> ) und es bequem war, mit ihnen zu arbeiten. bei gleichzeitiger Minimierung der Fehlerwahrscheinlichkeit. <br><br>  Bei Übertragungen ist im Allgemeinen alles einfach: Wir erstellen eine PostDeploy-Datei im Projekt und schreiben Code darin, um die Tabellen zu füllen.  Mit Merges oder Trankates - so gefällt es Ihnen.  Wir haben es vorgezogen zu blinken und vorab zu prüfen, ob die Anzahl der Datensätze in der Zieltabelle die Anzahl der Datensätze in der Quelle (im Projekt) überschreitet.  Wenn es überschreitet, wird eine Ausnahme ausgelöst, um die Aufmerksamkeit darauf zu lenken, weil es seltsam ist.  Warum enthält die Quelle weniger Datensätze?  Weil man überflüssig ist?  Warum plötzlich?  Und wenn die Datenbank bereits Links dazu hat?  Obwohl wir Fremdschlüssel (FK) verwenden, mit denen Sie den Datensatz nicht löschen können, lassen wir diese Option lieber, wenn Links dazu vorhanden sind.  Infolgedessen wurde PostDeploy zu einem unlesbaren Blatt, da für jede zu füllende Tabelle zusätzlich zu den Werten selbst auch ein Bestätigungscode, eine Zusammenführung usw. vorhanden ist. <br><br>  Wenn Sie jedoch PostDeploy im SQLCMD-Modus verwenden, können Codeblöcke in separate Dateien extrahiert werden. Daher bleibt nur eine strukturierte Liste von Dateinamen übrig, um die Aufzählungen in PostDeploy auszufüllen. <br><br>  Es gibt einige Nuancen bei Datenbankversionen.  Das Internet hat lange darüber diskutiert, wo die Datenbankversion gespeichert werden soll, wie sie aussehen soll und ob sie im Allgemeinen irgendwo gespeichert werden muss.  Angenommen, wir entscheiden, dass wir es brauchen, an welchem ​​Ort des Projekts, um es zu speichern?  Irgendwo in der Wildnis eines PostDeploy-Skripts oder in einer Variablen, die in der ersten Zeile des Skripts deklariert ist? <br><br>  Meiner Meinung nach weder der eine noch der andere.  Es ist bequemer, wenn es in einer separaten Datei gespeichert ist und dort nichts mehr vorhanden ist. <br><br>  Jemand wird sagen - in den Projekteigenschaften befindet sich Dacpac, und Sie können die Version darin festlegen.  Natürlich können Sie diese Version auch in Ihr Skript ziehen, wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> beschrieben, aber dies ist unpraktisch - um die Datenbankversion zu ändern, müssen Sie irgendwo weit gehen und auf eine Reihe von Schaltflächen klicken.  Ich verstehe die Logik von Microsoft nicht - sie haben sie in einer entfernten Ecke versteckt, zusammen mit Datenbankparametern wie Sortierung, Kompatibilitätsstufe usw., weil sich die Datenbankversion so "oft" ändert wie die Sortierparameter, oder?  Bei ständiger Entwicklung wird die Version mit jeder neuen Bereitstellung aufgebaut. Die Bequemlichkeit der Nachverfolgung von Änderungen spielt ebenfalls eine wichtige Rolle. Wenn eine geänderte Datei mit einem Anzeigenamen leuchtet, ist dies eine Sache, und wenn die .sqlproj-Projektdatei leuchtet, in der viele Zeilen im XML-Format vorhanden sind und unter ihnen irgendwo in der Mitte der Zeile wird eine geänderte Ziffer hervorgehoben, irgendwie nicht sehr. <br><br><img src="https://habrastorage.org/webt/bg/i3/48/bgi3485rgezdefuaami2weappqy.png"><br><br>  So ist es besser <br><br><img src="https://habrastorage.org/webt/ro/9y/ld/ro9yldaaeoqcmubpi42adq-so50.png"><br><br>  Vielleicht sind dies jedoch nur meine Kakerlaken, und Sie sollten nicht auf sie achten. <br><br>  Die Frage ist nun: Wo soll diese Version bereits in der bereitgestellten Datenbank gespeichert werden?  Wieder scheint es, dass dacpac es wunderbar macht - es schreibt alles auf die Systemplatten, aber um die Version zu sehen, müssen Sie die Anforderung ausführen (oder kann es anders sein, aber ich weiß nur nicht, wie man sie kocht? Es scheint, dass es in älteren Versionen von SSMS eine Schnittstelle dafür gab, und jetzt Nein) <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> msdb.dbo.sysdac_instances_internal</code> </pre> <br>  Für den Administrator (und nicht nur) ist es nicht sehr praktisch.  Es ist viel logischer, dass die Version direkt in den Eigenschaften der Datenbank selbst angezeigt wird. <br><br><img src="https://habrastorage.org/webt/ed/ax/le/edaxle3ic1lfwvaeuhhhphmrulo.png"><br><br>  Oder nicht? <br><br>  Dazu müssen Sie dem im Build enthaltenen Projekt eine Datei hinzufügen, in der die erweiterten Eigenschaften beschrieben werden <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeployerName'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; GO <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeploymentDate'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>; GO <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DBVersion'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = <span class="hljs-string"><span class="hljs-string">''</span></span>;</code> </pre> <br>  Ja, sie sind leer und in einem Veröffentlichungsskript sieht es hässlich aus, aber Sie können nicht ohne sie auskommen.  Wenn sie nicht im Projekt beschrieben sind und sich in der Datenbank befinden, versucht das Studio, sie bei jeder Bereitstellung zu löschen.  (Es gab viele Versuche, dies kurz und bündig und ohne unnötige Bereitstellungsoptionen zu umgehen, aber ohne Erfolg) <br><br>  Wir werden die Werte für sie im PostDeploy-Skript festlegen. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @username <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>) = suser_sname() ,@curdatetime <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">getdate</span></span>(),<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy HH:mm:ss'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_updateextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeployerName'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = @username; <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_updateextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DBVersion'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = [$(DBVersion)]; <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_updateextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeploymentDate'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = @curdatetime;</code> </pre> <br>  <code>sp_updateextendedproperty</code> ohne Überprüfung aus, da zum Zeitpunkt des Starts des Blocks von PostDeploy aus alle Eigenschaften bereits erstellt wurden, wenn sie nicht vorhanden waren. <br><br>  Nun, es wäre schön, den Verlauf darüber zu führen, wer und wann die Datenbank bereitgestellt hat. <br><br>  Die Bereitstellung von Metadatenänderungen kann in der Transaktion mithilfe von Standardtools durchgeführt werden, indem das Kontrollkästchen <b>Transaktionsskripts aktivieren</b> im Fenster <b>Erweiterte Veröffentlichungsoptionen aktiviert</b> wird.  Dieses Flag wirkt sich jedoch nicht auf die Bereitstellung der Skripte (Pre / Post) aus und sie werden weiterhin ohne Transaktion ausgeführt.  Natürlich hindert nichts die Transaktion daran, am Anfang des PostDeploy-Skripts zu beginnen, aber es handelt sich um eine Transaktion, die von den Metadaten getrennt ist, und wir haben die Aufgabe, die Metadatenänderungen zurückzusetzen, wenn in PostDeploy eine Ausnahme aufgetreten ist. <br><br>  Die Lösung ist einfach: Starten Sie die Transaktion in PreDeploy und schreiben Sie sie in PostDeploy fest. Verwenden Sie für diese Zwecke keine Häkchen in den Veröffentlichungseinstellungen. <br><br>  Um die Datenbankversion bequem im Projekt zu speichern und während der Bereitstellung an den gewünschten Stellen zu registrieren, können Sie auf die SQLCMD-Variablen zurückgreifen.  Ich möchte die Version jedoch nicht irgendwo in der Wildnis des Codes speichern, sondern an der Oberfläche. <br><br><img src="https://habrastorage.org/webt/yg/qm/o9/ygqmo9wf5pnwnyx7kfnumsflps8.png"><br><br>  Um die Datenbankversion in einer separaten Datei abzulegen und die Version von dort auf Projektebene zu verwalten, fügen wir .sqlproj den folgenden Block hinzu: <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BeforeBuild"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReadLinesFromFile</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$(ProjectDir)\Properties\DBVersion"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Output</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TaskParameter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Lines"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">PropertyName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ExtDBVersion"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReadLinesFromFile</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">WriteLinesToFile</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$(ProjectDir)\\SetPreDepVarsTmp.sql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Lines</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">":setvar DBVersion $(ExtDBVersion)"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Overwrite</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Dies ist eine Anweisung für MSBuild, vor dem Erstellen eine Zeile aus einer Datei zu lesen und eine temporäre Datei basierend auf den gelesenen Daten zu erstellen.  MSBuild erstellt eine temporäre Datei <code>SetPreDepVarsTmp.sql</code> , die <code>:setvar DBVersion $(ExtDBVersion)</code> Zeile <code>:setvar DBVersion $(ExtDBVersion)</code> , wobei <code>$(ExtDBVersion)</code> der aus unserer Datei gelesene Wert ist, in dem die Version der Datenbank gespeichert ist. <br><br>  Nach solchen Manipulationen können Sie im PreDeploy-Skript auf diese temporäre Datei verweisen und die darin enthaltene globale Transaktion starten: <br><br><pre> <code class="sql hljs">:r .\SetPreDepVarsTmp.sql go :r ".\BeginTransaction.sql"</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Zwischenversion</b> <div class="spoiler_text">  Anfänglich wurden der Datei ExtendedProperties.sql keine leeren Werte zugewiesen, sondern Werte aus Variablen <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeployerName'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = [$(DeployerName)]; GO <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DeploymentDate'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = [$(DeploymentDate)]; GO <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> sp_addextendedproperty @<span class="hljs-keyword"><span class="hljs-keyword">name</span></span> = N<span class="hljs-string"><span class="hljs-string">'DBVersion'</span></span>, @<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = [$(DBVersion)];</code> </pre> <br>  Variablen wiederum wurden von MSBuild automatisch wie folgt automatisch in der Datei SetPreDepVarsTmp.sql registriert: <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CurrentDateTime</span></span></span><span class="hljs-tag">&gt;</span></span>$([System.DateTime]::Now.ToString(dd.MM.yyyy HH:mm:ss))<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">CurrentDateTime</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">NewLine</span></span></span><span class="hljs-tag">&gt;</span></span> -- <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">NewLine</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"BeforeBuild"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReadLinesFromFile</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$(ProjectDir)\DBVersion"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Output</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">TaskParameter</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Lines"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">PropertyName</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ExtDBVersion"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReadLinesFromFile</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">WriteLinesToFile</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">File</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"$(ProjectDir)\SetPreDepVarsTmp.sql"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Lines</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">":setvar DBVersion $(ExtDBVersion)$(NewLine):setvar DeploymentDate "</span></span></span><span class="hljs-tag">$(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">CurrentDateTime</span></span></span><span class="hljs-tag">)"$(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">NewLine</span></span></span><span class="hljs-tag">)</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">:setvar</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">DeploymentUser</span></span></span><span class="hljs-tag"> $(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">UserDomain</span></span></span><span class="hljs-tag">)\$(</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">UserName</span></span></span><span class="hljs-tag">)" </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Overwrite</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Target</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Bei diesem Ansatz müssen Sie diese Eigenschaften nicht in PostDeploy neu installieren. Das Problem besteht jedoch darin, dass SetPreDepVarsTmp.sql statische Werte enthielt und das Veröffentlichungsskript jetzt generiert, aber in einer Stunde oder, noch schlimmer, am nächsten Tag bereitgestellt wurde (der Entwickler hat es lange Zeit überprüft) Zum Beispiel visuell) unterscheidet sich das in den Eigenschaften angegebene Veröffentlichungsdatum vom tatsächlichen Veröffentlichungsdatum und stimmt nicht mit dem Datum in der Historie überein. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Inhalt der BeginTransaction.sql-Datei</b> <div class="spoiler_text">  Im Wesentlichen handelt es sich hierbei nur um das Kopieren und Einfügen aus dem Standard-Transaktionsstartblock, den das Studio generiert, wenn das Kontrollkästchen <b>Transaktionsskripte aktivieren</b> aktiviert ist. Wir verwenden es jedoch auf unsere eigene Weise.  Im Skript wurde nur der Name der temporären Tabelle von <code>#tmpErrors</code> in <code>#tmpErrorsManual</code> geändert, sodass kein Namenskonflikt besteht, wenn jemand das Kontrollkästchen <code>#tmpErrorsManual</code> . <br><br><pre> <code class="sql hljs">IF (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> OBJECT_ID(<span class="hljs-string"><span class="hljs-string">'tempdb..#tmpErrors'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpErrorsManual GO CREATE TABLE #tmpErrorsManual (Error int) GO SET XACT_ABORT ON GO SET TRANSACTION ISOLATION LEVEL READ COMMITTED GO BEGIN TRANSACTION GO</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">PostDeploy-Skript</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> @TableName <span class="hljs-built_in"><span class="hljs-built_in">VarChar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-comment"><span class="hljs-comment">--        if $(SkipEnumDeploy) = 0 begin PRINT N' ...' :r ..\\EnumTable1.sql end --   PRINT N'  ...'; declare @username varchar(256) = suser_sname() , @curdatetime varchar(20) = format(getdate(),'dd.MM.yyyy HH:mm:ss') if $(DBVersion) &gt; (select isnull( MAX( DBVersion),0) from zDBVersionHistory) begin insert into zDBVersionHistory( DBVersion, DeploymentDate, DeployerName) values ($(DBVersion),@curdatetime,@username) EXECUTE sp_updateextendedproperty @name = N'DeployerName', @value = @username; EXECUTE sp_updateextendedproperty @name = N'DBVersion', @value = [$(DBVersion)]; EXECUTE sp_updateextendedproperty @name = N'DeploymentDate', @value = @curdatetime; end else begin RaisError ( N':          ,  .      ,        DBVersion          .' , 16 , 1 ) WITH SETERROR; end GO :r ".\CaptureTransactionError.sql" :r ".\CommitTransaction.sql"</span></span></code> </pre> <br>  Mit der Variablen SkipEnumDeploy können Sie, wie bereits klar geworden ist, die Phase der Aktualisierung von Listen überspringen. Dies kann bei geringfügigen kosmetischen Änderungen hilfreich sein.  Obwohl dies aus religiöser Sicht möglicherweise nicht zutrifft, ist es in der Entwicklungsphase definitiv nützlich. <br></div></div><br>  Die Dateien <code>CaptureTransactionError.sql</code> und <code>CommitTransaction.sql</code> <code>CaptureTransactionError.sql</code> ebenfalls (mit geringfügigen Änderungen) aus dem Standardtransaktionsalgorithmus <code>CaptureTransactionError.sql</code> und <code>CommitTransaction.sql</code> , den das Studio generiert, wenn das obige Flag gesetzt ist und den wir jetzt selbst spielen. <br><br><div class="spoiler">  <b class="spoiler_title">Inhalt CaptureTransactionError.sql</b> <div class="spoiler_text"><pre> <code class="sql hljs">IF @@ERROR &lt;&gt; 0 AND @@TRANCOUNT &gt; 0 <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> @@TRANCOUNT = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpErrorsManual (Error) VALUES (1); BEGIN TRANSACTION; END</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">CommitTransaction.sql-Inhalt</b> <div class="spoiler_text"><pre> <code class="sql hljs">IF EXISTS (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpErrorsManual) ROLLBACK TRANSACTION GO DROP TABLE #tmpErrorsManual GO IF @@TRANCOUNT&gt;0 BEGIN PRINT N'     .' COMMIT TRANSACTION END ELSE RaisError ( N'    .' , 16 , 1 );</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Inhalt EnumTable1.sql</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @TableName = N<span class="hljs-string"><span class="hljs-string">'Table1'</span></span> PRINT N<span class="hljs-string"><span class="hljs-string">'  '</span></span>+@TableName+<span class="hljs-string"><span class="hljs-string">'...'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> nocount <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> <span class="hljs-comment"><span class="hljs-comment">#tmpEnums; select * into #tmpEnums from (values ( 0, ' 1') , ( 1, ' 2') , ( 2, ' 3') ) as tmp ( Id , Title ) set nocount off --         If ((select count(*) from Table1) &gt; (select count(*) from #tmpEnums)) begin RaisError ( N':      ,   .' , 0 , 1 ) WITH SETERROR; end set Identity_insert Table1 on Merge Table1 as target Using ( select * from #tmpEnums except select * from dbo.Table1 ) as source on target.Id = source.Id when matched then update set target.Title = source.Title when not matched by target then insert ( Id , Title ) values ( source.Id , source.Title ); set Identity_insert Table1 off drop table if exists #tmpEnums; END TRY begin catch IF @@trancount &gt; 0 ROLLBACK TRANSACTION set @Error_Message = Error_Message(); RaisError ( N': %s.' , 0 , 1 , @Error_Message ) WITH SETERROR; end catch :r "..\\CaptureTransactionError.sql"</span></span></code> </pre> <br></div></div><br>  Bei der Bereitstellung von <code>Publish</code> Skript die folgende Struktur <br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- PreDeploy ----:setvar DBVersion "10.6" --   ,     DBVersion ----   --    ,           -- PostDeploy ----  ----   ----  </span></span></code> </pre> <br><br>  Idealerweise möchte ich natürlich, dass die Version zum Zeitpunkt der Veröffentlichung angezeigt wird <br><img src="https://habrastorage.org/webt/8a/9w/o2/8a9wo2o5lemfglm1ru1kt5yntdm.png"><br><br>  Sie können den Wert jedoch nicht aus der Datei in dieses Fenster ziehen, obwohl MSBuild ihn liest und mithilfe zusätzlicher Anweisungen in der .sqlproj-Datei in die ExtDBVersion-Eigenschaft einfügt, wie im obigen Beispiel, sondern in der Konstruktion <br><br><pre> <code class="xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SqlCmdVariable</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"DBVersion"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DefaultValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">DefaultValue</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span>$(ExtDBVersion)<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SqlCmdVariable</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  rollt nicht. <br><br>  Die Nachfolger der Entwickler in ihrem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Web-Tagebuch</a> schreiben, wie das gemacht wird.  Entsprechend ihrer Version liegt die Magie in der Anweisung <code>SqlCommandVariableOverride</code> , die einfach ist - fügen Sie der .sqlproj-Projektdatei ein paar Zeilen hinzu <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">SqlCommandVariableOverride</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"DBVersion=$(ExtDBVersion)"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  und fertig.  Netter Versuch, aber nein.  Vielleicht hat bei der Veröffentlichung dieses Blogposts alles funktioniert, aber seitdem haben Sie in Amerika drei Präsidentschaftswahlen abgehalten, und niemand weiß, welche Anweisungen morgen möglicherweise nicht mehr funktionieren. <br><br><img src="https://habrastorage.org/webt/xv/d9/li/xvd9liiwyjicnv5icr9d1utjnxs.jpeg"><br><br>  Und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> versuchte ein Kamerad alle Optionen, aber keiner von ihnen startete. <br><br>  Nehmen Sie daher entweder die Version von dacpac oder speichern Sie sie in PostDeploy oder in einer separaten Datei oder _________ (geben Sie Ihre Version ein). <br><br><h4>  Integration mit 1C </h4><br>  Das erste Problem war, dass 1C77 keinen Anwendungsserver oder anderen Dämon hat, mit dem es interagieren kann, ohne die Plattform zu starten.  Diejenigen, die mit 1C77 gearbeitet haben, wissen, dass sie keinen vollständigen Konsolenmodus hat.  Sie können die Plattform mit Parametern ausführen und sogar etwas basierend darauf tun, aber es gibt nur sehr wenige Konsolenparameter und ihr Zweck war unterschiedlich.  Aber auch mit ihrer Hilfe können Sie einen ganzen Mähdrescher nakolkhozit.  Es kann jedoch unvorhersehbar herausfliegen, ein modales Fenster öffnen und darauf warten, dass jemand auf OK und andere Reize klickt.  Und vielleicht das größte Problem - die Geschwindigkeit der Plattform lässt zu wünschen übrig ... Daher gibt es nur eine Lösung - direkte Abfragen an die 1C-Datenbank.  Angesichts der Struktur können Sie diese Abfragen nicht einfach annehmen und schreiben, aber der Vorteil ist, dass es eine ganze Community gibt, die einmal ein wunderbares Tool entwickelt hat - 1C ++ (1cpp.dll), was für sie unglaublich ist. DANKE!  In der Bibliothek können Sie Abfragen in Form von 1C schreiben, die dann in echte Namen von Tabellen und Feldern umgewandelt werden.  Wenn jemand es nicht weiß, kann die Anfrage unter Verwendung eines Pseudonamens geschrieben werden und es wird so aussehen <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> $.</code> </pre> <br>  Eine solche Anfrage ist für Menschen verständlich, aber es gibt keine solche Tabelle und kein solches Feld auf dem Server, es gibt andere Namen, also wird 1C ++ daraus <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> SP5278 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> SC2235</code> </pre> <br>  und eine solche Anfrage wird vom Server bereits verstanden.  Jeder ist glücklich, niemand schwört - weder eine Person noch ein Server.  Hier scheint das Problem behoben zu sein. <br><br>  Das zweite Problem lag in der Konfigurationsebene: Eine Konfiguration wurde in den Filialen verwendet, eine andere in der Zentrale und die dritte in den Filialen!  Klasse? !! 1 Ich denke auch.  Darüber hinaus sind sie kein typisches und nicht einmal typisches Erbe, sondern wurden während der Wikinger von Grund auf neu geschrieben, und leider haben nicht die besten Architekten den Grundstein für diese ... Die Implementierung von Dokumenten hat beispielsweise in jeder Konfiguration unterschiedliche Details.  Aber nicht nur die Namen einiger Felder unterscheiden sich, was viel mehr Spaß macht, wenn die Namen der Details gleich sind, sondern die Bedeutung der darin gespeicherten Daten ist UNTERSCHIEDLICH. <br><br><img src="https://habrastorage.org/webt/hs/jx/sv/hsjxsv_f7qy4xlgpwjiw7uir0ko.jpeg"><br><br>  In den Konfigurationen werden fast keine Register verwendet, alles baut auf den Feinheiten von Dokumenten auf.  Daher musste ich manchmal ein ganzes Blatt für eine saubere Transaktion mit einer Reihe von Fällen und Verknüpfungen schreiben, um die Logik einer Prozedur aus der Konfiguration zu wiederholen, die einige Informationen im Textfeld des Formulars anzeigt. <br><br>  Wir müssen dem Entwicklungsteam Tribut zollen, das all die Jahre das unterstützt hat, was es von den "Implementierern" geerbt hat. Es ist eine große Aufgabe - dies zu unterstützen und sogar etwas zu optimieren.  Bis Sie sehen - Sie verstehen nicht, ich selbst habe zunächst nicht geglaubt, dass alles so kompliziert sein könnte.  Fragen Sie - warum nicht von Grund auf neu schreiben?  Banaler Mangel an Ressourcen.  Das Unternehmen entwickelte sich so schnell, dass sie trotz eines großen Teams von Programmierern einfach nicht mit den Anforderungen des Unternehmens Schritt halten konnten, ganz zu schweigen von der Neufassung des gesamten Konzepts. <br><br>  Wir setzen die Geschichte der Anfragen fort.  Offensichtlich wurden alle Blöcke für die Datenextraktion zu Speichern, damit sie später auf der Serverseite unter Umgehung der 1C-Plattform gestartet werden konnten.  Die Regel lautete: Ein Speicher ist für das Abrufen einer Entität verantwortlich.  Weil  Die Wunschliste in der Startphase hat sich bereits sehr angesammelt, da sie im Laufe der Jahre schmerzhaft geworden ist. Dann haben sich Dutzende von Speicherdateien herausgestellt. <br><br>  Das dritte Problem ist, wie man die Geschwindigkeit und Qualität der Entwicklung erhöht und wie man dann all dieses Monster unterstützt.  Schreiben Sie eine Anfrage für 1C ++ und kopieren Sie das Ergebnis der Konvertierung in einen Speicher?  Es ist sehr unpraktisch und langwierig, außerdem besteht eine hohe Fehlerwahrscheinlichkeit - kopieren Sie die falsche oder die falsche oder wählen Sie nicht die letzte Zeile der Abfrage aus und kopieren Sie ohne diese.  Dies gilt insbesondere für direkte 1C-Abfragen, da es keinen Pseudonamen wie <i>Directory gibt.</i> Nomenklatur. Artikel, nur echte Namen <i>SC2235.SP5278</i> und daher das Kopieren einer Anfrage aus dem Warenverzeichnis in ein Geschäft, das Kunden abruft, ist sehr einfach.  Natürlich wird die Anforderung höchstwahrscheinlich aufgrund der Nichtübereinstimmung von Typen und Anzahl der Felder in der Zieltabelle fallen, aber es gibt identische Kennzeichen, z. B. Aufzählungen, bei denen nur zwei Spalten ID und Name sind.  Im Allgemeinen bleibt nur eine Art von Automatisierung anzuwenden.  Nun, genug Texte, lasst uns zur Sache kommen! <br><br>  Ich wollte, dass der Speicherentwicklungsprozess wie folgt abläuft: <br><br><ol><li>  Wir korrigieren die SQL-Abfrage mit Pseudonamen und speichern sie </li><li>  Wir drücken einen <b>magischen Knopf</b> und am Ausgang erhalten wir die korrigierte gespeicherte Prozedur auf dem konvertierten SQL, die für den Server freigegeben ist </li></ol><br><h4>  Einige Details </h4><br>  Um das dritte Problem zu lösen, wurde eine externe Verarbeitung (.ert) geschrieben.  Es gibt eine Reihe von Prozeduren in der Verarbeitung, von denen jede den Abfragetext zum Extrahieren einer Entität unter Verwendung eines Pseudonamens enthält, wie z <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> $.</code> </pre> <br>  Auf dem Verarbeitungsformular gibt es ein Feld zum Anzeigen des Ergebnisses einer bestimmten Prozedur, d.h.  Anfrage in ein für den Server verständliches Formular konvertiert, damit Sie es schnell ausprobieren können.  Außerdem wird dieser Anforderung immer ein <b>Debug-Block</b> hinzugefügt, der die Deklaration von Variablen, die Namen von Testdatenbanken, Servern und mehr enthält.  Es bleibt nur das Kopieren und Einfügen in SSMS und das Drücken von F5.  Sie können diese Anforderung natürlich über die Verarbeitung selbst ausführen, aber den Anforderungsplan und all das, na ja, Sie verstehen ... Im Allgemeinen erfolgt das Debuggen auf diese Weise.  Weil  Es gibt verschiedene Konfigurationen. Bei der Verarbeitung ist es möglich, dieselben Abfragetexte mit Pseudonamen von Objekten in endgültige Abfragen für verschiedene Konfigurationen zu konvertieren.  In der Tat ist in einer Konferenz die Nomenklatur SC123 und in einer anderen - SC321.  Mit 1C ++ können Sie jedoch zur Laufzeit verschiedene Konfigurationen laden und für jede eine entsprechende Ausgabe gemäß dem Wörterbuch generieren. <br><br>  Als nächstes wurde der Verarbeitung ein Stapellaufmodus hinzugefügt, in dem jede der Prozeduren für jede Konfiguration automatisch gestartet wird und die Ausgabe jeder dieser Prozeduren in SQL-Dateien (im Folgenden die Basisdateien) geschrieben wird.  Auf diese Weise erhalten wir eine Reihe von Kombinationen von Basisdateien, die anschließend mithilfe von VS automatisch in gespeicherte Prozeduren umgewandelt werden sollen.  Es ist erwähnenswert, dass die Basisdateien <b>einen Debug-Block enthalten</b> . <br><br>  Es scheint, warum nicht sofort eine Schlussfolgerung zu den endgültigen Dateien der gespeicherten Prozeduren ziehen und alles in dieser Verarbeitung behalten?  Tatsache ist, dass für einige Tests Debug-Versionen von Abfragen in Stapeln ausgeführt werden müssen, in denen alle Variablen deklariert sind. Außerdem wollte ich, dass die Namen der gespeicherten Prozeduren von VS aus unter Umgehung von 1C verwaltet werden, da dies logisch ist, nicht wahr? <br><br>  Übrigens werden die Basisdateien auch im Projekt gespeichert, natürlich auch die Dateien der vorgefertigten gespeicherten Prozeduren.  Ohne 1C zu starten, können Sie die Basisdatei jederzeit in SSMS öffnen und ausführen, ohne sich um Variablendeklarationen zu kümmern. <br><br>  Bei der Verarbeitung sind alle Prozeduren mit Anforderungen auch Vorlagen mit demselben Parametersatz, aber in dieser oder jener Prozedur werden nur die erforderlichen Parameter verwendet.  In einigen Fällen ist alles involviert, und in einigen Fällen reichen zwei aus.  Wenn Sie also eine neue Prozedur hinzufügen, müssen Sie die Vorlage kopieren und die Parameter mit den Abfragen selbst ausfüllen. <br><br>  Der Code einer der Verarbeitungsprozeduren, die sich danach in eine gespeicherte Prozedur verwandeln <br><img src="https://habrastorage.org/webt/ci/ev/sb/cievsb9urq5miainrvoqu9mkig0.png"><br><br>  Die letzte Abfrage sieht ungefähr so ​​aus: <br><pre> <code class="1c hljs">++<span class="hljs-string"><span class="hljs-string">"("</span></span>+OPENQUERY()+<span class="hljs-string"><span class="hljs-string">")"</span></span>+ </code> </pre> <br>  Aussehen der Verarbeitung <br><img src="https://habrastorage.org/webt/yv/n4/in/yvn4injz09-m8ljnqhbediqvmqy.png"><br><br>  Beim Wechseln der Konfiguration ändert sich die Liste der verfügbaren (erforderlichen) Elemente zum Entladen von Elementen in der Datenliste.  Wenn möglich, wurde der Prozedurcode in 1C so weit wie möglich vereinheitlicht.  Wenn Gegenparteien extrahiert werden und diese Verzeichnisse in unterschiedlichen Konfigurationen inkonsistent sind, gibt es innerhalb der Generierungsprozedur verschiedene Fälle, z. B.: Dieser Block ist für alle festgelegt, dieser wird nur für eine solche Konfiguration zur endgültigen Anforderung hinzugefügt, und es gibt einen für die andere.  Es stellt sich heraus, dass sich gespeicherte Prozeduren für eine Entität, aber unterschiedliche Konfigurationen nicht nur durch Tabellennamen unterscheiden können, sondern auch durch ganze Verknüpfungsblöcke, die in einer vorhanden sind und in einer anderen fehlen.  Die Menge der Ausgabefelder ist natürlich dieselbe und entspricht der Empfängertabelle oder dem Container des SSIS-Pakets. Einige Felder sind mit Stubs für Konfigurationen verstopft, bei denen diese Details im Prinzip nicht vorliegen. <br><br>  <b>Magischer Knopf</b> <br><br>  Visual Studio verfügt über Tools wie MSbuild und die fantastischen T4-Vorlagen.  Daher wurde als magischer Knopf ein Skript in C # für T4 geschrieben, das: <br><br><ol><li>  Registriert eine leere Konfiguration in der Registrierung (andernfalls zeigt 1C ein modales Fenster mit einem Vorschlag zum Registrieren einer Conf an und wartet auf Benutzeraktionen). </li><li>  Erstellt eine leere Datenbank für diese Konf auf dem SQL Server, da 1C ohne diese Datei einen Fehler ausgibt </li><li>  Startet 1C und weist OLE an, die Verarbeitung auszuführen (dieselbe .ert) und eine eindeutige GUID an 1C zu übertragen </li><li>  Die Ausgabe besteht aus einer Reihe von Dateien mit vorgefertigten (konvertierten) Anforderungen und einer Markierungsdatei, in die die beim Start empfangene GUID geschrieben wird </li><li>  Die Registrierung der conf wird aus der Registrierung gelöscht und eine temporäre leere Datenbank wird vom Server gelöscht </li><li>  Überprüft den Inhalt der Token-Datei.  Wenn die Markierungsdatei die GUID enthält, die wir beim Start an 1C übergeben haben, bedeutet dies, dass sie bis zum Ende funktioniert hat, nicht abgestürzt ist usw., dann fahren Sie mit dem nächsten Schritt fort, oder es wird ein Fehler angezeigt </li><li>  Wir schaffen Lager. </li><li>  Wir dekompilieren die .ert-Datei mit gcomp, um die Modultexte und Verarbeitungsformulare zu erhalten. Nun, wir konvertieren in Unicode, um sie anschließend an Git zu senden und dort korrekt anzuzeigen.  Für diejenigen, die nicht mit 1C gearbeitet haben: Die .ert-Datei ist eine Binärdatei, und das Studio bläst zusammen mit dem Git, dass die .ert-Datei geändert wurde, aber es ist nicht klar, was genau sich darin geändert hat. Vielleicht hat nur jemand die Schaltfläche einen Pixel nach links verschoben (welche ohne Begründung inakzeptabel) </li></ol><br><br>     T4       ,     (   ,    )        .      ,          .         ,     ,       ,      ,         - —   1. <br><br>  ,  ,    ,        ,        ,          .      —   1,     1,  -   . <br><br>      :       ? <br><br><ol><li>     / ; </li><li>    VS     ,     ; </li><li>   4; </li><li> <s>.</s>  Fertig. </li></ol><br><div class="spoiler"> <b class="spoiler_title">?</b> <div class="spoiler_text">  Weil               ,       ,    .sqlproj,  <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">None</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" \1.sql"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">None</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" \2.sql"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">None</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" \3.sql"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Ein <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Content</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">" \*.sql"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>       «     ».   ,  ,   ,     :) <br><br>     , ,    (, )     .           ( ),         , -   - -       ,             . <br></div></div><br>         ,      .      . , ,      ,      ,       ,       (    ),      . ,    (   ,      )  ,        ,  ,          .           ,   . ,     ,      ,     ,   ,     (   ,          1, ,    MD ). <br><br>      ,         <i>OPENQUERY</i> ,     1   ,     ,       ,       ,         <i>EXEC</i> . <i>OPENQUERY</i>    ,      ,   ,   . <br><br>  177 (  )   SQL2000,   varchar(max)  ,  varchar(8000),     9, … ,          EXEC(@SQL1+@SQL2).    ,       SQL2016,     SQL2000.     ,     ,    . <br><br><div class="spoiler"> <b class="spoiler_title">      </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> @<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName.dbo.$. <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> @<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName.dbo.$. <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> xxx = <span class="hljs-string"><span class="hljs-string">'hello!'</span></span> ^<span class="hljs-comment"><span class="hljs-comment">--       8 , ,        ,       ,   .          ,             .. ... join ... ) join ...</span></span></code> </pre> </div></div><br><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> [dbo].[SP1] @LinkedServerName <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>) ,@<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Declare</span></span> @TSQL0 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">8000</span></span>), @TSQL1 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">8000</span></span>), @TSQL2 <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">8000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @TSQL0=<span class="hljs-string"><span class="hljs-string">' select ... from OPENQUERY('</span></span>+@LinkedName+<span class="hljs-string"><span class="hljs-string">','' select ... from '</span></span>+@<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName+<span class="hljs-string"><span class="hljs-string">'.dbo.DH123. join '</span></span>+@<span class="hljs-number"><span class="hljs-number">1</span></span>CDBName+<span class="hljs-string"><span class="hljs-string">'.SC123. ... where '</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @TSQL1=<span class="hljs-string"><span class="hljs-string">' xxx = ''''hello!'''' join ... join ... )'' join ... '''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> @TSQL2=<span class="hljs-string"><span class="hljs-string">' ... EXEC(@TSQL0+@TSQL1+@TSQL2) END</span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie Sie dem Code entnehmen können, ist die gespeicherte Prozedur nicht formatiert. </font><font style="vertical-align: inherit;">Beim Erstellen einer Basisdatei werden alle Formatierungen (Leerzeichen, Tabulatoren) links und rechts, die in der ursprünglichen Anforderung mit Pseudonamen enthalten waren, gelöscht, da sich der Server nicht um die Formatierung kümmert. Das Speichern ist direkt sinnvoll, da Sie eine beliebige Anzahl von Variablen erzeugen können und OPENQUERY ein Limit von 8 KB hat Zeichen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die .ert-Verarbeitung bestimmt die Länge der endgültigen Anforderung unter Berücksichtigung der Remote-Formatierung und berechnet die Anzahl der Variablen, in die all dies passen soll usw. </font><font style="vertical-align: inherit;">Im Allgemeinen trank diese Behandlung viel Blut. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manuell werden niemals Änderungen an den gespeicherten Prozeduren selbst vorgenommen, nur durch Verarbeitungskorrekturen.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ETL </font></font></h4><br> ,       (  ).      (Stage).   ,  ETL    SSIS , ,   ,     ,      .      .                    (  ),            . <br><br>                 ,     (   ) ,   ,        (..   ),            ,        . <br><br>          ,     ,      . ,     .     zabbix. <br><br>             . <br><br>  Weil    1     ,        ,            .      ,   ,   <code>truncate</code>  . <br><br> ,       (  )       -,  « 1-»     . <br><br>     SSIS  <br><br><img src="https://habrastorage.org/webt/al/nl/u_/alnlu_3yriilaxfcwlhq_mcf_ce.png"><br><br>      <br><br><img src="https://habrastorage.org/webt/rh/eh/c8/rhehc8b9jtn6qf6polrfqjiduuk.png"><br><br><h4>  ,   </h4><br>         SSIS     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> SQL Server</a> (SQL Server Destination),     ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> OLE DB</a> (OLE DB Destination). <br><br>      ,       ,     ,             .    ,        ,   . (,     ) <br><br>       .           ,    ,      ,        (/  ). <br>                      . <br><br>          ,         (  ).  Das heißt,       ,        .      ,        ,         .    -        —          .            . <br><br>                  ,         (.. )   . <br><br>       ,     ,          . <br><br><h4>  PS </h4><br>     ,     ,      ,    ,   .   —   ,    .           -  ,       ,   . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423205/">https://habr.com/ru/post/de423205/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423191/index.html">Einführung der Elemente von Offshore-Plattformen. Teil 1</a></li>
<li><a href="../de423193/index.html">Konfigurieren Sie Web-Push-Benachrichtigungen mithilfe von pywebpush Schritt für Schritt</a></li>
<li><a href="../de423195/index.html">Was ist neu in JPA 2.2?</a></li>
<li><a href="../de423197/index.html">LOLWUT: ein Kunstwerk in einem DB-Team</a></li>
<li><a href="../de423203/index.html">Cooler Teamleiter wird für den Service verantwortlich sein</a></li>
<li><a href="../de423207/index.html">So erstellen Sie ein automatisches Update eines Online-Spieleclients</a></li>
<li><a href="../de423209/index.html">Killer Form 2? Übersicht über den MoonRay S100 Dental 3D-Drucker</a></li>
<li><a href="../de423211/index.html">State Duma Committee: Likes und Reposts bleiben strafrechtlich haftbar</a></li>
<li><a href="../de423213/index.html">Wie im alten Russisch wird es "das ist ein Test" geben</a></li>
<li><a href="../de423215/index.html">Wo ist mein Geld, Mann? Worüber schweigt Steam?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>