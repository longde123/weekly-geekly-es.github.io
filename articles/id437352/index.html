<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì© üòä üå≠ Komputasi kuantum dalam game, atau menjadi gila dengan serius üßñüèΩ üö¥üèª üç¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda hidup di antara orang-orang gila, Anda harus belajar menjadi orang gila sendiri 

 Pernahkah Anda mencoba "belajar untuk menjadi gila"? Tuga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Komputasi kuantum dalam game, atau menjadi gila dengan serius</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437352/">  <i>Jika Anda hidup di antara orang-orang gila, Anda harus belajar menjadi orang gila sendiri</i> <br><br>  Pernahkah Anda mencoba "belajar untuk menjadi gila"?  Tugas non-sepele.  Anda bahkan tidak akan menemukan teknik normal, karena semua orang menjadi gila dengan caranya sendiri.  Upaya pertama saya: teori konspirasi.  Teorinya tidak melibatkan praktik, yang berarti Anda tidak perlu bekerja keras.  Sekali lagi, dalam situasi apa pun, tidak ada yang akan menderita. <br><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara membuat teori konspirasi?</b> <div class="spoiler_text">  Membuat teori konspirasi relatif sederhana.  Kami membutuhkan ide yang cukup sederhana untuk diterima oleh 90% populasi.  Itu harus kontroversial sehingga 5% dari populasi dapat menjelaskan 90% idiot apa mereka.  Akhirnya, kita perlu penelitian yang tidak dimengerti oleh 95% orang, tetapi digunakan 90% sebagai argumen "orang terbukti lebih pintar daripada kita ...". <br><br>  Komputasi kuantum adalah bidang yang bagus untuk studi semacam itu.  Anda dapat menggulung skema sederhana, tetapi kata "kuantum" akan menambah bobot pada hasilnya. <br><br>  Objek penelitian adalah permainan, karena objeknya adalah karena anak muda yang sederhana dan akrab.  Siapa yang terlibat dalam komputasi kuantum dan game?  Google <br></div></div><br>  Jadi, teori sesat: setelah 5 tahun, Page dan Green akan memutuskan siapa yang akan menjadi hal utama di Google, dan melakukannya dengan bantuan permainan.  Masing-masing dari mereka memiliki sekelompok peneliti.  Tim AlphaGo dengan jaringan saraf <s>tempur</s> mereka menarik lawan di Go.  Lawan terpaksa mencari metode baru, dan masih menemukan instrumen keunggulan <s>total</s> : komputasi kuantum. <br><br>  Bisakah saya menggunakan Quantum Computing untuk game?  Mudah  Mari kita tunjukkan misalnya bahwa permainan "pemburu rubah" dapat "diselesaikan" dalam 6 gerakan.  Demi kredibilitas, kami membatasi diri hingga 15 qubit (quirk editor online tidak meniru lebih dari lima belas), demi kesederhanaan, kami mengabaikan batasan arsitektur prosesor dan koreksi kesalahan. <br><a name="habracut"></a><br><h3>  Aturannya </h3><br>  Sangat sederhana.  <i>Ada lima lubang yang disusun secara berurutan (kami beri nomor 0-1-2-3-4).</i>  <i>Salah satunya adalah rubah.</i>  <i>Setiap malam, rubah bergerak ke bulu berikutnya ke kiri atau ke kanan.</i>  <i>Setiap pagi, pemburu dapat memeriksa satu lubang untuk dipilih.</i>  <i>Tugas pemburu adalah menangkap rubah.</i>  <i>Tugas rubah adalah untuk bertahan hidup.</i>  Secara teori, rubah dapat lari dari pemburu selamanya.  Dalam praktiknya, ada strategi kemenangan: periksa lubang 1-2-3-1-2-3.  Hanya strategi ini yang akan saya uji. <br><br><h3>  Membangun skema </h3><br>  Mari kita mulai dengan inisiasi qubit 0-1-2-3-4 (5 lubang).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini Anda dapat mengedit</a> <br><img src="https://habrastorage.org/webt/jc/o3/-g/jco3-geebiz5bpjtpur3gvcctxm.png"><br><br>  Bahkan, setelah inisiasi, kami memiliki sistem di mana, setelah pengukuran, satu qubit akan tunggal.  Probabilitas "kesatuan" berbeda untuk setiap qubit, tetapi dalam kasus kami ini tidak kritis.  Kita harus meninggalkan ruang untuk diskusi tentang skema (dan teori kita pada saat bersamaan). <br><br>  Pada Q #, kami mendapatkan kode seperti ini: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history InitFoxHoles(qubits); ResetAll(qubits); // ALWAYS clean after yourself } return Zero; } // Inits fox holes, with almost equal probabilities operation InitFoxHoles(register: Qubit[]) : Unit { body { ResetAll(register); // Step 1 H(register[0]); H(register[2]); // Step 2 (Controlled (X))([register[0],register[2]], register[3]); // Step 3 X(register[0]); X(register[2]); (Controlled (X))([register[0],register[2]], register[3]); X(register[0]); X(register[2]); // Step 4 CNOT(register[3], register[0]); CNOT(register[3], register[2]); // Step 5 (Controlled (H))([register[3]], register[4]); // Step 6 CNOT(register[4], register[3]); } }</span></span></code> </pre> <br>  TestStrategy akan menguji strategi kami 1-2-3-1-2-3, InitFoxHoles () bertanggung jawab hanya untuk inisiasi lubang rubah.  Mari kita periksa inisiasinya.  Salin TestStrategy, mulai inisiasi, ukur 5 qubit pertama dan kembalikan nilainya. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result, Result, Result, Result, Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history InitFoxHoles(qubits); set res0 = M(qubits[0]); set res1 = M(qubits[1]); set res2 = M(qubits[2]); set res3 = M(qubits[3]); set res4 = M(qubits[4]); ResetAll(qubits); // ALWAYS clean after yourself } return (res0, res1, res2, res3, res4); } }</span></span></code> </pre> <br>  Kami akan menjalankan tes seribu kali (beberapa kali berjalan adalah khas dari algoritma kuantum, di beberapa tempat bahkan diperlukan).  Kode panggilan - di bawah spoiler, hasil: pada layar di bawah ini. <br><br><div class="spoiler">  <b class="spoiler_title">Uji inisiasi dengan cepat</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestInitiation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initedQubitsValues = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .ToDictionary(qubitIndex =&gt; qubitIndex, oneMesaured =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result) result = TestInit.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">0</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">1</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">2</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">3</span></span>]++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedQubitsValues[<span class="hljs-number"><span class="hljs-number">4</span></span>]++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-0 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-1 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-2 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-3 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Qubit-4 initiations: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedQubitsValues[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">4</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/fb/oa/bs/fboabsw9fsu64gh7bl9a8mofh_y.png"><br><br>  Ada yang salah.  Distribusi yang hampir seragam diharapkan.  Alasannya sederhana: pada langkah 3, saya membalikkan qubit ketiga, bukan yang pertama: (Terkendali (X)) ([daftar [0], daftar [2]], daftar [3]);  <s>tidak</s> baik copy-paste lama. <br><br>  Kami memperbaiki kode, menjalankan tes: <br><br><div class="spoiler">  <b class="spoiler_title">Inisiasi yang Dikoreksi</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Inits fox holes, with almost equal probabilities operation InitFoxHoles(register: Qubit[]) : Unit { body { ResetAll(register); // Step 1 H(register[0]); H(register[2]); // Step 2 (Controlled (X))([register[0],register[2]], register[3]); // Step 3 X(register[0]); X(register[2]); (Controlled (X))([register[0],register[2]], register[1]); X(register[0]); X(register[2]); // Step 4 CNOT(register[3], register[0]); CNOT(register[3], register[2]); // Step 5 (Controlled (H))([register[3]], register[4]); // Step 6 CNOT(register[4], register[3]); } } }</span></span></code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/06/q2/7b/06q27bfcca3-udvpnaarut9zmhi.png"><br><br>  Sudah lebih baik.  Anda dapat melihat kode di lobak, versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komit 1</a> <br><br><h3>  Di mana menjalankan rubah? </h3><br>  Pilih qubit kelima (penomoran dimulai dari atas) di bawah arahan rubah saat ini.  Kami setuju bahwa nol berarti gerakan ke bawah, unit berarti gerakan ke atas.  Jelas, jika rubah sudah berada di lubang nol - itu harus bergerak ke bawah.  Jika rubah berada di lubang keempat, ia bergerak ke atas.  Dalam kasus lain, rubah dapat bergerak ke atas dan ke bawah.  Menurut aturan sederhana ini, kita dapat mengatur "qubit dari arah saat ini" ke 0, 1, atau superposisi nol dan satu.  Kami melihat kode di repositori, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komit 2</a> . <br><br><img src="https://habrastorage.org/webt/dr/tg/zd/drtgzd1c2y9jyb0n7zwrxp5qg2c.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skema di editor.</a> <br><br><div class="spoiler">  <b class="spoiler_title">Kode dan tes</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Select next Fox movement direction, updating qubit 5 // 1 means go up (4 -&gt; 3, 3 -&gt; 2, ... 1 -&gt; 0) // 0 means go down (0 -&gt; 1, 1 -&gt; 2, ... 3 -&gt; 4) operation SetupMovementDirection(qubits: Qubit[]) : Unit { body { // Step 1 CNOT(qubits[4], qubits[5]); // Step 2 (Controlled (H))([qubits[3]], qubits[5]); // Step 3 (Controlled (H))([qubits[2]], qubits[5]); // Step 4 (Controlled (H))([qubits[1]], qubits[5]); } } operation TestMovementDirectionSetup(): (Result, Result, Result, Result, Result, Result) { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; mutable res5 = Zero; using(qubits=Qubit[16]) { InitFoxHoles(qubits); SetupMovementDirection(qubits); set res0 = M(qubits[0]); set res1 = M(qubits[1]); set res2 = M(qubits[2]); set res3 = M(qubits[3]); set res4 = M(qubits[4]); set res5 = M(qubits[5]); ResetAll(qubits); // ALWAYS clean after yourself } return (res0, res1, res2, res3, res4, res5); } }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMovementDirectionSetup</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> initedCubit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> moveDirection = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result, Result) result = Quantum.FoxHunter.TestMovementDirectionSetup.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"3"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"4"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item6 == Result.One) { moveDirection = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveDirection = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } results.Add(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedCubit}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{moveDirection}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results .GroupBy(result =&gt; result) .OrderBy(<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>.Key)) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Key}</span></span></span><span class="hljs-string"> was measured </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">group</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.Count()}</span></span></span><span class="hljs-string"> times"</span></span>); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"\r\nTotal measures: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{results.Count()}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre><br><br><img src="https://habrastorage.org/webt/1a/oa/vm/1aoavmvs9hscf8gywpbgfpbdpiq.png"><br></div></div><br><br><h3>  Gerakan </h3>  Diimplementasikan oleh SWAP yang terkontrol.  Jika qubit pengendali adalah single - swap down.  Jika qubit pengontrol adalah nol, kami bertukar. <br><br><img src="https://habrastorage.org/webt/zs/n8/os/zsn8osjcozts2nip6lbunqjcg_w.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skema di editor</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Operator Q #</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">// Makes a movement based on the 5'th qubit value // 1 means go up (4 -&gt; 3, 3 -&gt; 2, ... 1 -&gt; 0) // 0 means go down (0 -&gt; 1, 1 -&gt; 2, ... 3 -&gt; 4) operation MakeMovement(qubits: Qubit[]) : Unit { body { // Code movement Up // Step 1 mutable qubitsToSwap = [qubits[0], qubits[1]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 2 set qubitsToSwap = [qubits[1], qubits[2]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 3 set qubitsToSwap = [qubits[2], qubits[3]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 4 set qubitsToSwap = [qubits[3], qubits[4]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // COde movement down X(qubits[5]); // Invert direction qubit for the ZeroControlled operations // Step 5 set qubitsToSwap = [qubits[3], qubits[4]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 6 set qubitsToSwap = [qubits[2], qubits[3]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 7 set qubitsToSwap = [qubits[1], qubits[2]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); // Step 8 set qubitsToSwap = [qubits[0], qubits[1]]; (Controlled(SwapReverseRegister))([qubits[5]],qubitsToSwap); X(qubits[5]); // Back-invert for the direction qubit } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: pernyataan untuk tes</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFirstMovement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result, Result, Result, Result, Result, Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res0 = Zero; mutable res1 = Zero; mutable res2 = Zero; mutable res3 = Zero; mutable res4 = Zero; mutable res5 = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { InitFoxHoles(qubits); SetupMovementDirection(qubits); MakeMovement(qubits); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res0 = M(qubits[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res1 = M(qubits[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res2 = M(qubits[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res3 = M(qubits[<span class="hljs-number"><span class="hljs-number">3</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res4 = M(qubits[<span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> res5 = M(qubits[<span class="hljs-number"><span class="hljs-number">5</span></span>]); ResetAll(qubits); <span class="hljs-comment"><span class="hljs-comment">// ALWAYS clean after yourself } return (res0, res1, res2, res3, res4, res5); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Kode C #</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestFirstMove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; results = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> initedCubit = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> moveDirection = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { (Result, Result, Result, Result, Result, Result) result = Quantum.FoxHunter.TestFirstMovement.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item1 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item2 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item3 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"2"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item4 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"3"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item5 == Result.One) { initedCubit = <span class="hljs-string"><span class="hljs-string">"4"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Item6 == Result.One) { moveDirection = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { moveDirection = <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } results.Add(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{initedCubit}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{moveDirection}</span></span></span><span class="hljs-string">"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">// Holes measurements foreach (var group in results .GroupBy(result =&gt; result[0]) .OrderBy(group =&gt; group.Key)) { Console.WriteLine($"{group.Key} hole was measured {group.Count()} times"); } // Directions measuremetns foreach (var group in results .GroupBy(result =&gt; result[1]) .OrderBy(group =&gt; group.Key)) { Console.WriteLine($"{group.Key} direction was measured {group.Count()} times"); } Console.WriteLine($"\r\nTotal measures: {results.Count()}"); } }</span></span></code> </pre> <br></div></div><br>  Kode dapat dilihat di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komit 3</a> . <br><br><h3>  Kami membuat 6 gerakan </h3><br>  Akhirnya, kami memilih qubit keenam untuk status permainan (rubah gratis / rubah tidak gratis).  Unit ini sesuai dengan rubah gratis.  Kami akan bergerak lebih jauh hanya dengan qubit status tunggal. <br><br>  Qubit 7,8,9,10,11 akan menyimpan sejarah pergerakan.  Setelah setiap gerakan, kita akan menukar salah satu dari mereka dengan qubit dari arah saat ini (ini akan memungkinkan kita untuk menyimpan sejarah bergerak dan mengatur ulang qubit dari arah saat ini sebelum setiap gerakan). <br><img src="https://habrastorage.org/webt/a0/1t/_t/a01t_t8jo_9nt9w1nimamxrd-i0.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skema terlampir</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Operator Q #</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Make 6 movements. Every movement is controlled by the 6'th qubit. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> After the every qubit we check if the fox has been captured and invert the 6'th qubit </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Reminder: 6'th qubit equal to One means "Fox is free, go further" operation MakeSixMovements(qubits: Qubit[]) : Unit { body { // Move 1 (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Reverse Fox State if it's shot // Move 2 SwapReverseRegister([qubits[5], qubits[7]]); // Move the first move direction to the qubit 7, qubit 5 is Zero again (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 3 SwapReverseRegister([qubits[5], qubits[8]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); // Move 4 SwapReverseRegister([qubits[5], qubits[9]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Move 5 SwapReverseRegister([qubits[5], qubits[10]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 6 SwapReverseRegister([qubits[5], qubits[11]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Q #: pernyataan untuk tes</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestSixMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>): (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { body { mutable res = Zero; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span>(qubits=Qubit[<span class="hljs-number"><span class="hljs-number">16</span></span>]) { ResetAll(qubits); InitFoxHoles(qubits); X(qubits[<span class="hljs-number"><span class="hljs-number">6</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// At the beginning of the game our fox is alive MakeSixMovements(qubits); set res = M(qubits[6]); ResetAll(qubits); // ALWAYS clean after yourself } return (res); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C #: pengujian</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> zerosCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { Result result = Quantum.FoxHunter.TestSixMovements.Run(sim).Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result == Result.Zero) { zerosCount++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"\r\nTotal zeroes: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{zerosCount}</span></span></span><span class="hljs-string">"</span></span>); } }</code> </pre> <br></div></div><br>  Kami melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Komit 4</a> . <br><br><h3>  Sentuhan akhir </h3><br>  Kami memiliki kesalahan di sirkuit.  Karena kami menguji strategi 1-2-3-1-2-3, kami memeriksa setiap lubang dua kali.  Dengan demikian, setelah menangkap rubah pada langkah pertama, kita akan melewati status qubit dua kali (pada langkah pertama dan keempat). <br><br>  Untuk menghindari situasi ini, kami menggunakan 12 qubit untuk memperbaiki status setelah bergerak 4-5-6.  Selain itu, kami menambahkan definisi kemenangan: jika setidaknya satu dari status qubit berubah menjadi nol, kami menang. <br><img src="https://habrastorage.org/webt/cs/pc/ug/cspcugcnyqdranjm_lifypt2evc.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Skema terakhir</a> . <br><br><div class="spoiler">  <b class="spoiler_title">T #: perbaiki operator 6 move</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MakeSixMovements</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">qubits: Qubit[]</span></span></span><span class="hljs-function">) : Unit</span></span> { body { <span class="hljs-comment"><span class="hljs-comment">// Move 1 (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[1], qubits[6]); // Reverse Fox State if it's shot // Move 2 SwapReverseRegister([qubits[5], qubits[7]]); // Move the first move direction to the qubit 7, qubit 5 is Zero again (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[2], qubits[6]); // Move 3 SwapReverseRegister([qubits[5], qubits[8]]); (Controlled(SetupMovementDirection))([qubits[6]],(qubits)); (Controlled(MakeMovement))([qubits[6]],(qubits)); CNOT(qubits[3], qubits[6]); // Move 4 SwapReverseRegister([qubits[5], qubits[9]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[1], qubits[12]); // Move 5 SwapReverseRegister([qubits[5], qubits[10]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[2], qubits[12]); // Move 6 SwapReverseRegister([qubits[5], qubits[11]]); (Controlled(SetupMovementDirection))([qubits[6], qubits[12]],(qubits)); (Controlled(MakeMovement))([qubits[6], qubits[12]],(qubits)); CNOT(qubits[3], qubits[12]); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">T #: memperbaiki strategi pengujian operator 1-2-3-1-2-3</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">operation </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0..4 - holes // 5 - current movement direction. Zero means "go down", One means "go up" // 6 - Game status. 1 means "fox is free, go further" // 7,8,9,10, 11 - movements history // 12 - another qubit of the fox live. 1 means "fox is still free, go further" // 13 Result qubit. If it's zero, the fox is alive body { mutable res = Zero; using(qubits=Qubit[14]) { ResetAll(qubits); // Init fox positions and the fox' live InitFoxHoles(qubits); X(qubits[6]); // At the beginning of the game our fox is alive X(qubits[12]); // The second qubit of the fox live. If it's one - the fox is alive. // Make moves MakeSixMovements(qubits); // Measure results. If the 13'th qubit is zero the fox is alive X(qubits[6]); X(qubits[12]); CNOT(qubits[6], qubits[13]); CNOT(qubits[12], qubits[13]); CCNOT(qubits[6], qubits[12], qubits[13]); set res = M(qubits[13]); ResetAll(qubits); // ALWAYS clean after yourself } return (res); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">C #: jalankan pemeriksaan terakhir</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunFoxHunt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stopwatch sw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stopwatch(); sw.Start(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sim = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuantumSimulator()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foxSurvives = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hunterWins = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = (Result)(TestStrategy.Run(sim).Result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == Result.Zero) { foxSurvives++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { hunterWins++; } } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Fox survives: \t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{foxSurvives}</span></span></span><span class="hljs-string">"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Hunter wins: \t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{hunterWins}</span></span></span><span class="hljs-string">"</span></span>); } sw.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Experiment finished. "</span></span> + <span class="hljs-string"><span class="hljs-string">$"Time spent: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.ElapsedMilliseconds / </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1000</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> seconds"</span></span>); }</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/qm/pr/a3/qmpra3x-ticzuunfcmlsl_8atnk.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berkomitmen 5</a> . <br><br><h3>  Apa yang mengikuti dari ini </h3><br>  Pada prinsipnya, skema ini dapat dioptimalkan baik dalam jumlah qubit dan dalam jumlah operasi.  Optimalisasi sepele untuk jumlah qubit adalah untuk menyingkirkan qubit-13, hanya mengembalikan 6 dan 12. Optimasi untuk operasi - untuk membuat bidikan pertama segera setelah inisiasi.  Namun, biarkan ini bekerja untuk teknisi Google. <br><br>  Seperti yang Anda lihat, siapa pun yang dangkal akrab dengan komputasi kuantum dapat dengan aman memainkan "pemburu rubah."  Jika kami memiliki sedikit qubit lagi, kami dapat menemukan solusi optimal, dan tidak memeriksa yang ada.  Sangat mungkin bahwa tic-tac-toe (dan versi kuantum mereka), catur, catur, Go akan jatuh berikutnya. <br><br>  Pada saat yang sama, masalah "solvabilitas" game seperti DotA, Starcraft dan Doom tetap terbuka.  Untuk komputasi kuantum, penyimpanan seluruh riwayat klik adalah karakteristik.  Kami mengambil APM (Tindakan Per Menit) dari 500, kalikan dengan jumlah pemain, kalikan dengan jumlah menit, tambahkan keacakan permainan itu sendiri - jumlah qubit yang diperlukan untuk menyimpan semua informasi tumbuh terlalu cepat. <br><br>  Jadi, memilih game dalam kompetisi kecil antara Brin dan Page dapat memainkan peran yang menentukan.  Namun, generasi game yang ‚Äúsama sulitnya‚Äù untuk komputer klasik dan kuantum layak mendapatkan teorinya sendiri. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437352/">https://habr.com/ru/post/id437352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437342/index.html">Cara memilih platform untuk pengawasan video: Cloud vs. DVR / NVR / VMS</a></li>
<li><a href="../id437344/index.html">Gunakan kasing untuk solusi visibilitas jaringan</a></li>
<li><a href="../id437346/index.html">Sebuah game (bukan) untuk orang bodoh. Kami menulis AI untuk "The Fool" (bagian 1)</a></li>
<li><a href="../id437348/index.html">Tingkatkan Produktivitas di GitHub: Kiat untuk Pemula dan Lainnya</a></li>
<li><a href="../id437350/index.html">Sebuah mobil di era multifungsi. Konversi apa yang mungkin?</a></li>
<li><a href="../id437354/index.html">Lemah gila, bagian 2: periode pemungutan suara untuk publikasi dan perubahan lainnya</a></li>
<li><a href="../id437356/index.html">Apa yang terjadi pada SSD pada tahun 2018</a></li>
<li><a href="../id437358/index.html">Manajemen Kompatibilitas Produk</a></li>
<li><a href="../id437360/index.html">Mengunduh pengontrol tanpa menggunakan konsol IDE Arduino</a></li>
<li><a href="../id437364/index.html">Kontrol atas Tele2 akan menelan biaya Rostelecom 240 miliar rubel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>