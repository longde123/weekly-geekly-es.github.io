<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∞Ô∏è üé™ üßñ Minen unter Leistung warten in den Fl√ºgeln üßïüèª ‚öíÔ∏è ü§ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich √ºber Minen sprechen, die unter der Auff√ºhrung liegen, sowie √ºber ihre Entdeckung (vorzugsweise sogar vor der Explosion) un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Minen unter Leistung warten in den Fl√ºgeln</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443206/"><p>  In diesem Artikel werde ich √ºber Minen sprechen, die unter der Auff√ºhrung liegen, sowie √ºber ihre Entdeckung (vorzugsweise sogar vor der Explosion) und ihre R√§umung. </p><br><div class="spoiler">  <b class="spoiler_title">Ein Bild, um Aufmerksamkeit zu erregen</b> <div class="spoiler_text"><p><img src="https://ic.pics.livejournal.com/ivagkin/26880913/58954/58954_original.jpg" alt="Bild"></p></div></div><a name="habracut"></a><br><h4 id="chto-takoe-mina">  Was ist eine Mine? </h4><br><p>  Beginnen wir mit dem, was den Urspr√ºngen eines Wissens zugrunde liegt - mit der Definition.  Die Alten sagten, richtig zu benennen bedeutet richtig zu verstehen.  Ich denke, dass die Definition einer Mine unter Leistung am besten ausgedr√ºckt wird, indem man sie einem offensichtlichen Fehler gegen√ºberstellt, zum Beispiel: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... strings)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : strings) { result += str; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Selbst unerfahrene Entwickler wissen, dass die Linien unver√§nderlich sind. Wenn Sie sie in einer Schleife zusammenkleben, bedeutet dies nicht, dass Sie dem Ende einer vorhandenen Linie Daten hinzuf√ºgen, sondern mit jedem Durchgang eine <strong>neue</strong> Linie erstellen.  Wenn Sie sich irren, lassen Sie sich nicht entmutigen - die ‚ÄûIdee‚Äú warnt Sie sofort vor der Gefahr, und das ‚ÄûSonar‚Äú wird Ihre Versammlung mit Sicherheit √ºberfluten. </p><br><p>  Dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Code</a> wird jedoch viel weniger Aufmerksamkeit erregen und die Idee ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vor Version 2018.2</a> ) wird still sein: </p><br><pre> <code class="java hljs">Long total = <span class="hljs-number"><span class="hljs-number">0L</span></span>; List&lt;Long&gt; totals = query.getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long element : totals) { total += element == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : element; }</code> </pre> <br><p>  Das Problem ist hier dasselbe: Die Wrapper f√ºr einfache Typen sind unver√§nderlich, was bedeutet, dass das Hinzuf√ºgen von 5 Einheiten zur Objektnummer das Erstellen eines neuen Wrappers und das Schreiben der Nummer 6 bedeutet. </p><br><p>  Der Witz hier ist das Vorhandensein von zwei Darstellungen bestimmter Arten von Daten in Java - einfach und objektiv - sowie deren automatische Transformation mittels der Sprache selbst.  Aus diesem Grund denken viele unerfahrene Entwickler ungef√§hr so: "Nun, die Ausf√ºhrung transformiert sie dort irgendwie von selbst, es ist nur eine Zahl." </p><br><p>  In der Tat ist nicht alles so einfach.  Nehmen Sie den <a href="">Benchmark</a> und versuchen Sie, die Zahlen auf die angegebene Weise hinzuzuf√ºgen: </p><br><div class="spoiler">  <b class="spoiler_title">Pl√∂tzlich kam es sehr, sehr billig heraus (im Folgenden JDK 11, sofern nicht ausdr√ºcklich anders angegeben)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> (size) Mode Cnt Score Error Units wrapper 10 avgt 100 23,5 ¬± 0,1 ns/op wrapper 100 avgt 100 352,3 ¬± 2,1 ns/op wrapper 1000 avgt 100 4424,5 ¬± 25,2 ns/op wrapper 10 avgt 100 0 ¬± 0 B/op wrapper 100 avgt 100 1872 ¬± 0 B/op wrapper 1000 avgt 100 23472 ¬± 0 B/op</code> </pre> <br><p>  Vergleichen Sie mit einem einfachen Typ: </p><br><pre> <code class="plaintext hljs">primitive 10 avgt 100 6,4 ¬± 0,0 ns/op primitive 100 avgt 100 39,8 ¬± 0,1 ns/op primitive 1000 avgt 100 252,5 ¬± 1,3 ns/op primitive 10 avgt 100 0 ¬± 0 B/op primitive 100 avgt 100 0 ¬± 0 B/op primitive 1000 avgt 100 0 ¬± 0 B/op</code> </pre> </div></div><br><p>  Von hier leiten wir eine der Definitionen von Minen unter Leistung ab - dies ist Code, der nicht ins Auge f√§llt, von statischen Analyseger√§ten nicht erkannt wird (zumindest zu dem Zeitpunkt, als Sie darauf gesto√üen sind), aber bei einigen Anwendungen langsamer werden kann.  In unserem Fall werden, w√§hrend die Summe 127 nicht √ºberschreitet, Objekte aus dem Cache entnommen und <code>Long</code> nur viermal langsamer als <code>long</code> .  Bei einem Array der Gr√∂√üe 100 ist die Geschwindigkeit jedoch fast zehnmal niedriger. </p><br><h4 id="bolshie-melochi">  Gro√üe kleine Dinge </h4><br><p>  Manchmal wird eine kleine √Ñnderung, die die Bedeutung der Ausf√ºhrung <em>fast</em> nicht √§ndert, unter <em>bestimmten</em> Umst√§nden zu einer starken Bremse. </p><br><p>  Angenommen, wir haben einen Code: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); if (info == null) { info = getAlias.apply(alias); cache.put(alias, info); } return info; }</span></span></code> </pre> <br><p>  Wie sieht die Methodenlogik aus? </p><br><div class="spoiler">  <b class="spoiler_title">Beeilen Sie sich nicht, um zu gucken</b> <div class="spoiler_text"><p>  Dies ist <code>ConcurrentHashMap::computeIfAbsent</code> ! </p></div></div><br><p>  Wir haben die "Acht" und k√∂nnen den Code k√ºhl verbessern: Ersetzen Sie 6 Zeilen durch eine, wodurch der Code k√ºrzer und verst√§ndlicher wird.  √úbrigens werden Kenner des Multithreading wahrscheinlich auf eine weitere Verbesserung hinweisen, die <code>ConcurrentHashMap::computeIfAbsent</code> bringt, aber etwas sp√§ter;) </p><br><p>  Lassen Sie uns einen gro√üen Gedanken wahr werden lassen: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { return cache.computeIfAbsent(alias, getAlias); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Versammelt, angefangen, geweint</b> <div class="spoiler_text"><p>  Um die volle Gr√∂√üe zu sehen, klicken Sie mit der rechten Maustaste auf das Bild und w√§hlen Sie "Bild in neuem Tab √∂ffnen". <br><img src="https://habrastorage.org/getpro/habr/post_images/9f0/2aa/0e0/9f02aa0e028903e85a63d08207d93509.png" alt="Bild"></p></div></div><br><p>  W√§hrend die Anwendung mit einem Thread arbeitete, war alles mehr oder weniger gut.  Streams wurden mehr und deutlich schlechter.  Es <code>ConcurrentHashMap::computeIfAbsent</code> heraus, dass <code>ConcurrentHashMap::computeIfAbsent</code> blockiert ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auch wenn der Schl√ºssel <strong>bereits</strong> zum W√∂rterbuch hinzugef√ºgt wurde</a> .  Und dies wurde der Grund f√ºr einen ziemlichen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehler</a> in Spring Date Mongo. </p><br><p>  Sie k√∂nnen dies mit einer einfachen <a href="">Messung</a> ("acht") √ºberpr√ºfen.  Hier ist seine Schlussfolgerung: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 19,405 ¬± 0,411 ns/op getAndPut avgt 20 4,578 ¬± 0,045 ns/op 2 threads computeIfAbsent avgt 20 66,492 ¬± 2,036 ns/op getAndPut avgt 20 4,454 ¬± 0,110 ns/op 4 threads computeIfAbsent avgt 20 155,975 ¬± 8,850 ns/op getAndPut avgt 20 5,616 ¬± 2,073 ns/op 6 threads computeIfAbsent avgt 20 203,188 ¬± 10,547 ns/op getAndPut avgt 20 7,024 ¬± 0,456 ns/op 8 threads computeIfAbsent avgt 20 302,036 ¬± 31,702 ns/op getAndPut avgt 20 7,990 ¬± 0,144 ns/op</code> </pre> <br><p>  Kann dies von den Entwicklern eindeutig als Fehler angesehen werden?  Meiner bescheidenen Meinung nach nein, nein.  Die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> sagt: </p><br><blockquote>  Einige versuchte Aktualisierungsvorg√§nge auf dieser Karte durch andere Threads werden m√∂glicherweise blockiert, w√§hrend die Berechnung ausgef√ºhrt wird. Daher sollte die Berechnung kurz und einfach sein und darf nicht versuchen, andere Zuordnungen dieser Karte zu aktualisieren </blockquote><p>  Mit anderen Worten, <code>ConcurrentHashMap::computeIfAbsent</code> schlie√üt die Zelle mit dem Schl√ºssel von au√üen (im Gegensatz zu <code>ConcurrentHashMap::get</code> ), was im Allgemeinen der Fall ist, da Sie dem Rennen ausweichen k√∂nnen, w√§hrend Sie eine Methode aus verschiedenen Threads aufrufen, wenn der Schl√ºssel noch nicht hinzugef√ºgt wurde. </p><br><p>  Andererseits erfolgt in der gebr√§uchlichsten Betriebsart die Berechnung des Wertes und seine Bindung mit dem Schl√ºssel nur beim ersten Aufruf, und alle nachfolgenden Aufrufe geben nur den zuvor berechneten Wert zur√ºck.  Daher ist es sinnvoll, die Logik so zu √§ndern, dass die Sperre nur beim √Ñndern gesetzt wird.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Es wurde hier gemacht</a> . </p><br><p>  In neueren Editionen (&gt; 8) ist <code>ConcurrentHashMap::computeIfAbsent</code> geworden: </p><br><pre> <code class="plaintext hljs">JDK 11 Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 6,983 ¬± 0,066 ns/op getAndPut avgt 20 5,291 ¬± 1,220 ns/op 2 threads computeIfAbsent avgt 20 7,173 ¬± 0,249 ns/op getAndPut avgt 20 5,118 ¬± 0,395 ns/op 4 threads computeIfAbsent avgt 20 7,991 ¬± 0,447 ns/op getAndPut avgt 20 5,270 ¬± 0,366 ns/op 6 threads computeIfAbsent avgt 20 11,919 ¬± 0,865 ns/op getAndPut avgt 20 7,249 ¬± 0,199 ns/op 8 threads computeIfAbsent avgt 20 14,360 ¬± 0,892 ns/op getAndPut avgt 20 8,511 ¬± 0,229 ns/op</code> </pre> <br><p>  Achten Sie auf die Hinterlist dieses Beispiels: Der semantische Inhalt <em>hat sich</em> nicht wesentlich ge√§ndert, da wir auf den ersten Blick nur eine erweiterte Syntax verwendet haben.  W√§hrend die Anwendung in einem Thread ausgef√ºhrt wird, sp√ºrt der Benutzer den Unterschied fast nicht!  So scheinbar harmlos ver√§ndert sich <del>  das Schwein </del>  meins unter unserer Leistung. </p><br><div class="spoiler">  <b class="spoiler_title">Warum ich "fast unver√§ndert" schrieb</b> <div class="spoiler_text"><p>  <code>ConcurrentHashMap::computeIfAbsent</code> nicht immer mit dem Ausdruck <code>getAndPut</code> austauschbar, da <code>ConcurrentHashMap::computeIfAbsent</code> eine atomare Operation ist.  Im gleichen Code </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { info = getAlias.apply(alias); cache.put(alias, info); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; }</code> </pre> <br><p>  Aufgrund der fehlenden externen Synchronisation <strong>erscheint ein Rennen</strong> .  Wenn die an <code>ConcurrentHashMap::computeIfAbsent</code> f√ºr den angegebenen Schl√ºssel √ºbergebene Funktion immer denselben Wert zur√ºckgibt, handelt es sich um ein "sicheres" Rennen. Wir m√ºssen h√∂chstens <code>ConcurrentHashMap::computeIfAbsent</code> oder mehrmals denselben Wert berechnen.  Wenn es keine solchen Garantien gibt, ist ein mechanischer Ersatz mit einer Aufschl√ºsselung der Anwendung behaftet.  Seid vorsichtig! </p></div></div><br><h4 id="eti-ruki-nichego-ne-menyali">  Diese H√§nde haben nichts ver√§ndert </h4><br><p>  Es kommt auch vor, dass sich der Code √ºberhaupt nicht √§ndert, aber pl√∂tzlich langsamer wird. </p><br><p>  Stellen Sie sich vor, wir stehen vor der Aufgabe, die Elemente eines Arrays in eine Sammlung zu verschieben.  Am logischsten w√§re es, die vorgefertigte <code>Collection::addAll</code> , aber hier ist das Pech - sie akzeptiert die Sammlung: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span></span>; }</code> </pre> <br><p>  Am einfachsten ist es, das Array in <code>Arrays::asList</code> .  Es wird sich so etwas herausstellen </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.addAll(Arrays.asList(items)); }</code> </pre> <br><p>  W√§hrend des Korrekturlesens werden uns leistungsbewusste Kollegen wahrscheinlich mitteilen, dass dieser Code gleichzeitig zwei Probleme aufweist: </p><br><ul><li>  Einschlie√üen eines Arrays in eine Liste (zus√§tzliches Objekt) </li><li>  Erstellen eines Iterators (ein weiteres zus√§tzliches Objekt) und Durchlaufen </li></ul><br><p>  In der Referenzimplementierung von <code>Collection::addAll</code> wir <code>Collection::addAll</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> modified = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : c) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (add(e)) modified = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; } }</code> </pre> <br><p>  Hier wird also ein Iterator erstellt und die Elemente damit sortiert.  Erfahrene Genossen bieten daher ihre L√∂sung an: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Im Code zu Recht produktiver: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T element : elements) result |= c.add(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Erstens wird kein Iterator erstellt.  Zweitens verl√§uft der Durchlauf im √ºblichen Z√§hlzyklus. Au√üerdem passen die Arrays gut in die Caches, ihre Elemente befinden sich nacheinander im Speicher (was bedeutet, dass nur wenige Cache-Fehler auftreten), und der Zugriff per Index ist sehr schnell.  Nun, eine Wrapper-Liste wird auch nicht erstellt.  Es klingt gut und klingt. </p><br><p>  Schlie√ülich zitieren Kollegen Ultima Ratio Regum: Dokumentation.  Und dort sagt Grau auf Wei√ü (oder Gr√ºn auf Schwarz): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ... * The behavior of this convenience method is identical to that of * c.addAll(Arrays.asList(elements)), but this method is likely * to run significantly faster under most implementations. &lt;---- * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.5 */</span></span> <span class="hljs-meta"><span class="hljs-meta">@SafeVarargs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Das hei√üt, die Entwickler selbst (und wem sollten sie glauben, wenn nicht ihnen?) Schreiben Sie, dass die Dienstprogrammmethode f√ºr die meisten Implementierungen <em>viel</em> schneller funktioniert.  Und er ist wirklich schneller.  Manchmal. </p><br><p>  Der <a href="">Benchmark</a> , den wir f√ºr das <code>HashSet</code> auf dem G8 starten werden, wird dazu beitragen, <code>HashSet</code> zu <code>HashSet</code> : </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 155,2 ¬± 2,8 ns/op addAll HashSet 100 avgt 100 1884,4 ¬± 37,4 ns/op addAll HashSet 1000 avgt 100 17917,3 ¬± 298,8 ns/op collectionsAddAll HashSet 10 avgt 100 136,1 ¬± 0,8 ns/op collectionsAddAll HashSet 100 avgt 100 1538,3 ¬± 31,4 ns/op collectionsAddAll HashSet 1000 avgt 100 15168,6 ¬± 289,4 ns/op</code> </pre> <br><p>  Es scheint, dass die erfahreneren Kameraden Recht hatten.  Fast. </p><br><p>  In sp√§teren Ausgaben (zum Beispiel in 11) wird die Brillanz der Utility-Methode etwas nachlassen: </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 143,1 ¬± 0,6 ns/op addAll HashSet 100 avgt 100 1738,4 ¬± 7,3 ns/op addAll HashSet 1000 avgt 100 16853,9 ¬± 101,0 ns/op collectionsAddAll HashSet 10 avgt 100 132,1 ¬± 1,1 ns/op collectionsAddAll HashSet 100 avgt 100 1661,1 ¬± 7,1 ns/op collectionsAddAll HashSet 1000 avgt 100 15450,9 ¬± 93,9 ns/op</code> </pre> <br><p>  Es ist zu sehen, dass es sich nicht um eine "viel schnellere" handelt.  Und wenn wir das Experiment f√ºr <code>ArrayList</code> -a wiederholen, stellt sich heraus, dass die Utility-Methode viel verliert (je weiter desto st√§rker): </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units JDK 8 addAll ArrayList 10 avgt 100 38,5 ¬± 0,5 ns/op addAll ArrayList 100 avgt 100 188,4 ¬± 7,0 ns/op addAll ArrayList 1000 avgt 100 1278,8 ¬± 42,9 ns/op collectionsAddAll ArrayList 10 avgt 100 62,7 ¬± 0,7 ns/op collectionsAddAll ArrayList 100 avgt 100 495,1 ¬± 2,0 ns/op collectionsAddAll ArrayList 1000 avgt 100 4892,5 ¬± 48,0 ns/op JDK 11 addAll ArrayList 10 avgt 100 26,1 ¬± 0,0 ns/op addAll ArrayList 100 avgt 100 161,1 ¬± 0,4 ns/op addAll ArrayList 1000 avgt 100 1276,7 ¬± 3,7 ns/op collectionsAddAll ArrayList 10 avgt 100 41,6 ¬± 0,0 ns/op collectionsAddAll ArrayList 100 avgt 100 492,6 ¬± 1,5 ns/op collectionsAddAll ArrayList 1000 avgt 100 6792,7 ¬± 165,5 ns/op</code> </pre> <br><p>  Hier gibt es nichts Unerwartetes. <code>ArrayList</code> auf einem Array. <code>Collection::addAll</code> haben die Entwickler die <code>Collection::addAll</code> weitsichtig neu definiert: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ Object[] a = c.toArray(); modCount++; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numNew = a.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Object[] elementData; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew &gt; (elementData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData).length - (s = size)) elementData = grow(s + numNew); System.arraycopy(a, <span class="hljs-number"><span class="hljs-number">0</span></span>, elementData, s, numNew); &lt;---    size = s + numNew; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p>  Nun zur√ºck zu unseren Minen.  Angenommen, wir haben die beim Korrekturlesen vorgeschlagene L√∂sung dennoch akzeptiert und diesen Code belassen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Im Moment ist alles in Ordnung, aber nach dem Hinzuf√ºgen neuer Funktionen wird die Methode manchmal hei√ü und verlangsamt sich.  Wir √∂ffnen Quellcodes - der Code hat sich nicht ge√§ndert.  Die Datenmenge ist gleich.  Und die Leistung sank sehr.  Dies ist eine andere Art von mir. </p><br><p>  Entdecken Sie den Debugger und finden Sie das Sch√∂ne: </p><br><p><img src="https://habrastorage.org/webt/nw/og/mu/nwogmu0_mvl-ix_hdyoxdaoydik.png"></p><br><p>  Bitte beachten Sie: Wir haben den Algorithmus nicht ge√§ndert, die Menge der verarbeiteten Daten hat sich nicht ge√§ndert, aber ihre Art hat sich ge√§ndert und ein Leistungsproblem ist in unserem Code aufgetreten: </p><br><pre> <code class="plaintext hljs"> Java 8 Java 11  addAll 10 56,9 25,2 ns/op collectionsAddAll 10 352,2 142,9 ns/op addAll 100 159,9 84,3 ns/op collectionsAddAll 100 4607,1 3964,3 ns/op addAll 1000 1244,2 760,2 ns/op collectionsAddAll 1000 355796,9 364677,0 ns/op</code> </pre> <br><p>  Bei gro√üen Arrays <code>Collections::addAll</code> der Unterschied zwischen <code>Collections::addAll</code> und <code>Collection::addAll</code> 500-mal bescheidene <code>Collection::addAll</code> .  Tatsache ist, dass <code>COWList</code> nicht nur das vorhandene Array erweitert, sondern jedes Mal, wenn Elemente hinzugef√ºgt werden, ein neues erstellt: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (lock) { Object[] es = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = es.length; es = Arrays.copyOf(es, len + <span class="hljs-number"><span class="hljs-number">1</span></span>); &lt;----    es[len] = e; setArray(es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p><del>  Wer ist schuld? </del></p><br><div class="spoiler">  <b class="spoiler_title">Was zu tun ist?</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://bugs.openjdk.java.net/browse/JDK-8193031</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">http://cr.openjdk.java.net/~martin/webrevs/jdk/Collections-addAll/</a> </p></div></div><br><p>  Das Hauptproblem hierbei ist, dass die <code>Collections::addAll</code> eine Schnittstelle akzeptiert, w√§hrend die <code>addAll</code> Methode keinen Body hat.  Kein K√∂rper - kein Gesch√§ft, daher basiert die Dokumentation auf der Implementierung in <code>AbstractCollection::addAll</code> , einem verallgemeinerten Algorithmus, der f√ºr alle Sammlungen gilt.  Dies bedeutet, dass spezifischere Implementierungen von Datenstrukturen, die sich auf einer niedrigeren Abstraktionsebene befinden, dieses Verhalten √§ndern k√∂nnen. </p><br><div class="spoiler">  <b class="spoiler_title">Jetzt menschlich</b> <div class="spoiler_text"><pre> <code class="java hljs"> Collection::addAll ‚Äì   AbstractCollection::addAll ‚Äì   &lt;---    ArrayList::addAll HashSet::addAll ‚Äì   &lt;---      COWList::addAll</code> </pre> </div></div><br><h4 id="eschyo-ob-abstrakciyah">  Mehr √ºber Abstraktionen </h4><br><p>  Da wir √ºber die Abstraktionsebenen sprechen, erz√§hle ich Ihnen ein Beispiel aus dem Leben. </p><br><p>  Vergleichen wir diese beiden M√∂glichkeiten zum Speichern der n-ten Anzahl von Entit√§ten in der Datenbank: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  Auf den ersten Blick sollte die Leistung beider Methoden nicht sehr unterschiedlich sein, weil </p><br><ul><li>  In beiden F√§llen wird die gleiche Anzahl von Entit√§ten in der Datenbank gespeichert </li><li>  Wenn die Taste aus der Sequenz entnommen wird, ist die Anzahl der Anrufe gleich </li><li>  Die √ºbertragene Datenmenge ist gleich </li></ul><br><p>  <code>SimpleJpaRepository::saveAndFlush</code> an die <code>SimpleJpaRepository::saveAndFlush</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveAndFlush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ S result = save(entity); flush(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ em.flush(); }</code> </pre> <br><p>  Der dunkle Fleck hier ist die <code>flush()</code> -Methode.  Warum dumm?  Es scheint mir, dass die Offenlegung in der <code>JpaRepository</code> Oberfl√§che ein Entwicklerfehler war.  Ich werde versuchen, meinen Gedanken zu rechtfertigen.  In der Regel wird diese Methode vom Entwickler √ºberhaupt nicht verwendet, da der Aufruf von <code>EntityManager::flush</code> an den Abschluss einer von Spring kontrollierten Transaktion gebunden <code>EntityManager::flush</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     @Transactional public void method() { &lt;--  Session::open /*.*/ } &lt;--  Session::flush</span></span></code> </pre> <br><p>  Bitte beachten Sie: <code>EntityManager</code> ist Teil der <code>JPA</code> Spezifikation, die in Hibernate als Sitzung implementiert ist (Sitzungsschnittstelle bzw. SessionImpl-Klasse).  Spring Date ist ein Framework, das auf einem ORM ausgef√ºhrt wird, in diesem Fall auf Hibernate.  Es stellt sich heraus, dass die <code>JpaRepository::saveAndFlush</code> uns Zugriff auf die unteren Ebenen der API gew√§hrt, obwohl das Framework die Aufgabe hat, die Details auf niedriger Ebene auszublenden (die Situation √§hnelt in gewisser Weise der unsicheren Story im JDK). <br>  In unserem Fall gelangen wir bei Verwendung von <code>JpaRepository::saveAndFlush</code> in die unteren Ebenen der Anwendung und brechen dadurch etwas. </p><br><div class="spoiler">  <b class="spoiler_title">Nehmen Sie sich Zeit f√ºr einen Blick, denken Sie selbst</b> <div class="spoiler_text"><p>  Die F√§higkeit von Hibernate, Daten <code>jdbc.batch_size</code> zu senden, ist <code>jdbc.batch_size</code> ist ein Vielfaches der Einstellung <code>jdbc.batch_size</code> , die in <code>application.yml</code> : </p><br><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate: jdbc.batch_size: 500</code> </pre> <br><p>  Die Arbeit von Hibernate basiert auf Ereignissen. Wenn Sie also 1000 Entit√§ten wie diese speichern </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } }</code> </pre> <br><p>  Das Aufrufen von <code>repository.save(e)</code> wird nicht sofort <code>repository.save(e)</code> .  Stattdessen wird ein Ereignis erstellt, das sich in der Warteschlange befindet.  Nach Abschluss der Transaktion werden die Daten mit <code>EntityManager::flush</code> , wodurch die Einf√ºgungen / Aktualisierungen in mehrere B√ºndel von <code>jdbc.batch_size</code> und Anforderungen daraus erstellt werden.  In unserem Fall bedeutet <code>jdbc.batch_size: 500</code> , dass das Speichern von 1000 Entit√§ten in der Realit√§t nur 2 Anforderungen bedeutet. </p><br><p>  Aber mit einer manuellen Entladung der Sitzung bei jedem Durchgang des Zyklus </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  Die Warteschlange wird gel√∂scht und das Speichern von 1000 Entit√§ten bedeutet 1000 Abfragen. </p></div></div><br><p>  Eine St√∂rung der unteren Schichten der Anwendung kann daher leicht zu einer Mine und nicht nur zu einer Produktivit√§tsmine werden (siehe Unsicher und ihre unkontrollierte Verwendung). </p><br><p>  Wie viel verlangsamt es sich?  Nehmen Sie den besten Fall (f√ºr uns) - die Datenbank befindet sich auf demselben Host wie die Anwendung.  Meine <a href="">Messung</a> zeigt folgendes Bild: </p><br><pre> <code class="plaintext hljs"> (entityCount) Mode Cnt Score Error Units bulkSave 10 ss 500 16,613 ¬± 1,714 ms/op bulkSave 100 ss 500 31,371 ¬± 1,453 ms/op bulkSave 1000 ss 500 35,687 ¬± 1,973 ms/op bulkSaveUsingFlush 10 ss 500 32,653 ¬± 2,166 ms/op bulkSaveUsingFlush 100 ss 500 61,983 ¬± 6,304 ms/op bulkSaveUsingFlush 1000 ss 500 184,814 ¬± 6,976 ms/op</code> </pre> <br><p>  Wenn sich die Datenbank auf einem Remote-Host befindet, werden die Kosten f√ºr die Daten√ºbertragung mit zunehmendem Datenvolumen offensichtlich immer schlechter. </p><br><p>  Wenn Sie also auf der falschen Abstraktionsebene arbeiten, kann dies leicht zu einer Zeitbombe f√ºhren.  √úbrigens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habe</a> ich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einem meiner vorherigen Artikel</a> √ºber einen merkw√ºrdigen Versuch gesprochen, <code>StringBuilder</code> -a zu verbessern: Dort war ich nur erfolglos, als ich versuchte, in eine abstraktere Codeebene zu gelangen. </p><br><h4 id="granicy-minnyh-poley">  Minenfeldgrenzen </h4><br><p>  Lass uns einen Pionier spielen?  Finde meine: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); Assert.notNull(key, "Null key ..." + context.metadata.operation); // ... return key; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Gefunden?</b>  <b class="spoiler_title">√úberpr√ºfen Sie die richtige Antwort.</b> <div class="spoiler_text"><pre> <code class="java hljs"> | \ / <span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport | \ / Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); | \ / Assert.notNull(key, "Null key ..." + context.metadata.operation); return key; }</span></span></code> </pre> </div></div><br><p>  "Willst du mich ver√§ppeln?", Ruft der Kritiker aus. "Aber gibt es nur ein Kleben von zwei Linien? Was bedeutet das in blutigem E.?"  Lassen Sie mich Ihre Aufmerksamkeit auf die Tatsache lenken, dass ich nicht nur das Verkleben von Zeichenfolgen hervorgehoben habe, sondern auch den Namen der Klasse und den Namen der Methode.  In der Tat besteht die Gefahr des Klebens von Zeichenfolgen nicht darin, sich selbst zu kleben, sondern in dem, was in der Methode geschieht, die die Schl√ºssel f√ºr den Cache erstellt, d. H. In bestimmten Szenarien haben wir viele Zugriffe auf diese Methode, was viele M√ºllzeilen bedeutet. <br>  Daher sollte eine Fehlermeldung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nur erstellt werden,</a> wenn dieser Fehler tats√§chlich ausgel√∂st wird: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); if (key == null) { throw new IAE("Null key ..." + context.metadata.operation); } // ... return key; }</span></span></code> </pre> <br><p>  Minenfelder haben also Grenzen - dies ist die Datenmenge, die H√§ufigkeit des Zugriffs auf die Methode usw. Quantitative Indikatoren bei Erreichen und √úberschreiten, bei denen ein geringf√ºgiger Nachteil statistisch signifikant wird. </p><br><p>  Auf der anderen Seite ist dies das Merkmal, an dessen Schnittpunkt die Komplikation des Codes keine signifikante (messbare) Verbesserung ergibt. </p><br><p>  Dies ist eine weitere Schlussfolgerung f√ºr den Entwickler: In den meisten F√§llen ist T√§uschung b√∂se, was zu einer bedeutungslosen Komplikation des Codes f√ºhrt.  In 99 von 100 F√§llen gewinnen wir nichts. </p><br><p>  Es sollte daran erinnert werden, dass es immer gibt </p><br><h4 id="tot-samyy-sotyy-sluchay">  Der einhundertste Fall </h4><br><p>  Hier ist der Code, den Nitzan Wakart in seinem Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">The volatile read √ºberraschend gibt</a> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoopyBenchmarks</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({ <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"1024"</span></span>, <span class="hljs-string"><span class="hljs-string">"32768"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bunn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { <span class="hljs-comment"><span class="hljs-comment">// good old C style for (the win?) fox.consume(bunn[y]); } } @Benchmark public void sweetLoop(Blackhole fox) { for (byte bunny : bunn) { // syntactic sugar loop goodness fox.consume(bunny); } } }</span></span></code> </pre> <br><p>  Wenn wir die Erfahrung einrichten, werden wir einen erstaunlichen Unterschied zwischen den beiden M√∂glichkeiten entdecken, √ºber ein Array zu iterieren: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoop 32 46.630 0.097 ns/op goodOldLoop 1024 1199.338 0.705 ns/op goodOldLoop 32768 37813.600 56.081 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>  Hier kann ein unerfahrener Entwickler eine so offensichtliche und Benchmark-Schlussfolgerung ziehen: Das Durchlaufen eines Arrays mit der neuen Syntax funktioniert schneller als ein Z√§hlzyklus.  Dies ist die falsche Schlussfolgerung, da es sich lohnt, die <code>goodOldLoop</code> Methode ein <code>goodOldLoop</code> zu √§ndern: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoopReturns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sunn = bunn; <span class="hljs-comment"><span class="hljs-comment">// make a local copy of the field for (int y = 0; y &lt; sunn.length; y++) { fox.consume(sunn[y]); } }</span></span></code> </pre> <br><p>  und seine Leistung ist vergleichbar mit der der "schnelleren" <code>sweetLoop</code> Methode: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoopReturns 32 19.306 0.045 ns/op goodOldLoopReturns 1024 476.493 1.190 ns/op goodOldLoopReturns 32768 14292.286 16.046 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>     <code>Blackhole::consume</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//... public volatile byte b1, b2; public volatile BlackholeL2 nullBait = null; /** * Consume object. This call provides a side effect preventing JIT to eliminate dependent computations. * * @param b object to consume. */ public final void consume(byte b) { if (b == b1 &amp; b == b2) { // SHOULD NEVER HAPPEN nullBait.b1 = b; // implicit null pointer exception } }</span></span></code> </pre> <br><p>         ,    ,      .     <code>goodOldLoop</code>       <code>this.bunn</code>    ,  <code>for-each</code>     ,        (,  Java Concurrency In Practice   "  ").      . </p><br><p>    : "      ?   , <code>Blackhole::consume</code> ‚Äî   JMH       .  ,  ,       ?" </p><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>   ?  Richtig?  ,    : </p><br><pre> <code class="java hljs">E[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;E&gt; fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>  <code>Iterable::forEach</code> !        ,   ,        ,       (   JDK 13): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) action.accept(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); } //Arrays$ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (E e : a) { action.accept(e); } } //CopyOnWriteArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (Object x : getArray()) { @SuppressWarnings("unchecked") E e = (E) x; action.accept(e); } } //ArrayDeque public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final Object[] es = elements; for (int i = head, end = tail, to = (i &lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i &lt; to; i++) action.accept(elementAt(es, i)); if (to == end) { if (end != tail) throw new ConcurrentModificationException(); break; } } }</span></span></code> </pre> <br><p>     ,          . ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> <code>Collections.nCopies()::forEach</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(action); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n; i++) { action.accept(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } }</code> </pre> <br><p>            , . .   <code>this.n</code>  <code>this.element</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopiesList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> E element; CopiesList(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, E e) { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n = n; element = e; }</code> </pre> <br><p>  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a> <code>@Stable</code> . </p><br><p>  :  99   100  ,     ,    1   100,             .     ,     . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a>          "  volatile". </p><br><h4 id="eho-voyny">   </h4><br><p>      ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.Integer @HotSpotIntrinsicCandidate public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); }</span></span></code> </pre> <br><p> -   ,         ( <code>java.lang.Integer</code> , <code>java.lang.Long</code> , <code>java.lang.Short</code> , <code>java.lang.Byte</code> , <code>java.lang.Character</code> ).  ,     ,     </p><br><pre> <code class="java hljs">Integer intgr = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>    . </p><br><p>      : </p><br><pre> <code class="java hljs">Integer intgr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>        ,         ,       <code>Integer::valueOf</code>   . </p><br><p>         :      .                ,   ,      ""  (         ).   ,        ,         <code>Integer::valueOf</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"  "</a> . </p><br><p>   . ,              . ,       .      ,    ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443206/">https://habr.com/ru/post/de443206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443196/index.html">Keine Minute offline - Auswahl eines industriellen LTE-Routers</a></li>
<li><a href="../de443198/index.html">Laut Mark Zuckerberg arbeitet Facebook an einer neuronalen Schnittstelle zum Lesen von Gedanken</a></li>
<li><a href="../de443200/index.html">Iranische Hacker stehlen Terabyte an Daten von Citrix</a></li>
<li><a href="../de443202/index.html">Kundgebung gegen die Isolation von Runet</a></li>
<li><a href="../de443204/index.html">Frontend Weekly Digest (4. - 10. M√§rz 2019)</a></li>
<li><a href="../de443208/index.html">Firmenmaus</a></li>
<li><a href="../de443210/index.html">React Tutorial Teil 21: Zweite Lektion und Workshop zum bedingten Rendern</a></li>
<li><a href="../de443214/index.html">React Tutorial Teil 23: Erste Formulare Lektion</a></li>
<li><a href="../de443216/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 355 (4. - 10. M√§rz 2019)</a></li>
<li><a href="../de443218/index.html">Kommerzielle Perspektiven von Roscosmos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>