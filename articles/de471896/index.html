<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚶🏽 🈂️ 😴 Das Inside Playbook. Netzwerkfunktionen in der neuen Ansible Engine 2.9 👩🏾‍🤝‍👩🏻 🙎 🧕🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die bevorstehende Version von Red Hat Ansible Engine 2.9 wartet mit beeindruckenden Verbesserungen auf Sie, von denen einige in diesem Artikel beschri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Inside Playbook. Netzwerkfunktionen in der neuen Ansible Engine 2.9</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/471896/"><p><img src="https://habrastorage.org/webt/db/2m/xd/db2mxdllzxasqtz4syfggtayzw4.jpeg"></p><br><p>  Die bevorstehende Version von Red Hat Ansible Engine 2.9 wartet mit beeindruckenden Verbesserungen auf Sie, von denen einige in diesem Artikel beschrieben werden.  Wie üblich haben wir mit Unterstützung der Community offen Verbesserungen für Ansible Network entwickelt.  Beitreten - Sehen Sie sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Task Board auf GitHub an</a> und lesen Sie den Entwicklungsplan für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Veröffentlichung von Red Hat Ansible Engine 2.9</a> auf der Wiki-Seite für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ansible Network</a> . </p><br><p>  Wie kürzlich angekündigt, enthält die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Red Hat Ansible Automation Platform</a> jetzt Ansible Tower, Ansible Engine und alle Inhalte von Ansible Network.  Die gängigsten Netzwerkplattformen werden jetzt über Ansible-Module implementiert.  Zum Beispiel: </p><br><ul><li>  Arista eos </li><li>  Cisco IOS </li><li>  Cisco IOS XR </li><li>  Cisco NX-OS </li><li>  Wacholder Junos </li><li>  Vyos </li></ul><br><p>  Eine vollständige Liste der Plattformen, die von Red Hat über Ansible Automation vollständig unterstützt werden, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><a name="habracut"></a><br><h2 id="chemu-my-nauchilis">  Was haben wir gelernt? </h2><br><p> In den letzten vier Jahren haben wir viel über die Entwicklung einer Plattform für die Netzwerkautomatisierung gelernt.  Wir haben auch gelernt, wie Endbenutzer Plattformartefakte in Ansible-Playbooks und -Rollen spielen.  Und hier ist, was wir herausgefunden haben: </p><br><ul><li>  Unternehmen automatisieren Geräte nicht nur von einem, sondern von vielen Anbietern. </li><li>  Automatisierung ist nicht nur ein technisches, sondern auch ein kulturelles Phänomen. </li><li>  Die groß angelegte Automatisierung von Netzwerken ist aufgrund der grundlegenden Architekturprinzipien des Automatisierungsdesigns komplizierter als es scheint. </li></ul><br><p>  Als wir vor über einem Jahr über unsere langfristigen Entwicklungspläne diskutierten, forderten unsere Firmenkunden Folgendes an: </p><br><ul><li>  Die Erfassung von Fakten muss besser standardisiert und an den Automatisierungsworkflow für jedes Gerät angepasst werden. </li><li>  Das Aktualisieren von Konfigurationen auf dem Gerät muss ebenfalls standardisiert und harmonisiert werden, damit Ansible-Module die zweite Hälfte des Zyklus nach dem Sammeln der Fakten verarbeiten. </li><li>  Wir benötigen strenge und unterstützte Methoden, um die Gerätekonfiguration in strukturierte Daten umzuwandeln.  Auf dieser Basis kann die Wahrheitsquelle von einem Netzwerkgerät verschoben werden. </li></ul><br><h2 id="uluchsheniya-faktov">  Faktenverbesserungen </h2><br><p>  Das Sammeln von Fakten von Netzwerkgeräten mit Ansible erfolgt häufig nach dem Zufallsprinzip.  Netzwerkplattformen sind in unterschiedlichem Maße mit der Fähigkeit ausgestattet, Fakten zu sammeln, haben jedoch fast keine oder gar keine Funktionen zum Parsen und Standardisieren der Darstellung von Daten in Schlüssel-Wert-Paaren.  Lesen Sie in Ken Celenzas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beitrag,</a> wie schwierig und schmerzhaft es ist, Fakten zu analysieren und zu standardisieren. </p><br><p>  Möglicherweise haben Sie bemerkt, wie wir an der Rolle der Ansible Network Engine gearbeitet haben.  Natürlich wurde die Network Engine-Rolle 24.000 Downloads später schnell zu einer der beliebtesten Rollen von Ansible in Ansible Galaxy für Netzwerkautomatisierungsszenarien.  Bevor wir einen Großteil davon auf Ansible 2.8 migrierten, um uns auf die Anforderungen von Ansible 2.9 vorzubereiten, stellte diese Ansible-Rolle die ersten Tools zur Verfügung, die das Parsen von Befehlen, die Befehlsverwaltung und die Datenerfassung für Netzwerkgeräte unterstützen. </p><br><p>  Wenn Sie Network Engine gut beherrschen, ist dies eine sehr effiziente Methode zum Sammeln, Analysieren und Standardisieren von Faktendaten für die Verwendung mit Ansible.  Der Nachteil dieser Rolle besteht darin, dass Sie für jede Plattform und für alle Netzwerkaktivitäten eine ganze Reihe von Parsern erstellen müssen.  Um zu verstehen, wie schwierig es ist, Parser zu erstellen, zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">versenden</a> und zu warten, schauen Sie sich die über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">1200 Parser</a> der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mitarbeiter</a> von Cisco an. </p><br><p>  Kurz gesagt, für eine groß angelegte Automatisierung ist es sehr wichtig, Fakten von Geräten zu empfangen und sie in Schlüssel-Wert-Paare zu normalisieren. Dies ist jedoch schwierig zu erreichen, wenn Sie viele Anbieter und Netzwerkplattformen haben. </p><br><p>  Jedes Netzwerk-Faktmodul in Ansible 2.9 kann jetzt die Konfiguration eines Netzwerkgeräts analysieren und strukturierte Daten zurückgeben - ohne zusätzliche Bibliotheken, Ansible-Rollen oder benutzerdefinierte Parser. </p><br><p>  Ab Ansible 2.9 wird mit jeder Version des aktualisierten Netzwerkmoduls das Faktmodul verbessert, um Informationen zu diesem Konfigurationsabschnitt bereitzustellen.  Das heißt, die Entwicklung von Fakten und Modulen erfolgt jetzt im gleichen Tempo und sie werden immer eine gemeinsame Datenstruktur haben. </p><br><p> Die Ressourcenkonfiguration auf einem Netzwerkgerät kann auf zwei Arten extrahiert und in strukturierte Daten konvertiert werden.  Auf beide Arten können Sie eine bestimmte Liste von Ressourcen mit dem neuen <code>gather_network_resources</code> kompilieren und konvertieren.  Ressourcennamen entsprechen Modulnamen, und dies ist sehr praktisch. </p><br><h3 id="vo-vremya-sbora-faktov">  Zum Zeitpunkt der Erfassung der Fakten: </h3><br><p>  Mit dem <code>gather_facts</code> Sie die aktuelle Gerätekonfiguration am Anfang des Playbooks extrahieren und dann im gesamten Playbook verwenden.  Geben Sie die einzelnen Ressourcen an, die vom Gerät abgerufen werden sollen. </p><br><pre> <code class="plaintext hljs">- hosts: arista module_defaults: eos_facts: gather_subset: min gather_network_resources: - interfaces gather_facts: True</code> </pre> <br><p>  Möglicherweise stellen Sie in diesen Beispielen etwas Neues fest, nämlich <code>gather_facts: true</code> jetzt für die native <code>gather_facts: true</code> für Netzwerkgeräte verfügbar. </p><br><h3 id="ispolzovanie-modulya-setevyh-faktov-napryamuyu">  Direktes Verwenden des Network Facts-Moduls: </h3><br><pre> <code class="plaintext hljs">- name: collect interface configuration facts eos_facts: gather_subset: min gather_network_resources: - interfaces</code> </pre> <br><h3 id="pleybuk-vozvraschaet-sleduyuschie-fakty-ob-interfeyse">  Das Playbook gibt die folgenden Fakten über die Benutzeroberfläche zurück: </h3><br><pre> <code class="plaintext hljs">ansible_facts: ansible_network_resources: interfaces: - enabled: true name: Ethernet1 mtu: '1476' - enabled: true name: Loopback0 - enabled: true name: Loopback1 - enabled: true mtu: '1476' name: Tunnel0 - enabled: true name: Ethernet1 - enabled: true name: Tunnel1 - enabled: true name: Ethernet1</code> </pre> <br><p>  Beachten Sie, wie Ansible die native Konfiguration vom Arista-Gerät abruft und in strukturierte Daten konvertiert, um sie als Standardschlüssel-Wert-Paare für nachfolgende Aufgaben und Vorgänge zu verwenden. </p><br><p>  Schnittstellenfakten können zu gespeicherten Ansible-Variablen hinzugefügt und sofort oder später als Eingabe für das Ressourcenmodul <code>eos_interfaces</code> ohne zusätzliche Verarbeitung oder Konvertierung verwendet werden. </p><br><h3 id="moduli-resursov">  Ressourcenmodule </h3><br><p>  Also haben wir die Fakten extrahiert, die Daten normalisiert, sie in ein standardisiertes internes Schema der Datenstruktur eingegeben und eine fertige Quelle der Wahrheit gefunden.  Hurra!  Das ist natürlich großartig, aber wir müssen die Schlüssel-Wert-Paare trotzdem irgendwie wieder in die spezifische Konfiguration konvertieren, die eine bestimmte Geräteplattform erwartet.  Jetzt benötigen wir Module für bestimmte Plattformen, um diese neuen Anforderungen an das Sammeln und Normalisieren von Fakten zu erfüllen. </p><br><p>  Was ist ein Ressourcenmodul?  Die Gerätekonfigurationsabschnitte können als die von diesem Gerät bereitgestellten Ressourcen betrachtet werden.  Netzwerkressourcenmodule sind absichtlich auf eine Ressource beschränkt und können wie Bausteine ​​gestapelt werden, um komplexe Netzwerkdienste zu konfigurieren.  Infolgedessen werden die Anforderungen und Spezifikationen für das Ressourcenmodul natürlich vereinfacht, da das Ressourcenmodul einen bestimmten Netzwerkdienst auf einem Netzwerkgerät lesen <em>und</em> konfigurieren kann. </p><br><p>  Um zu erklären, was das Ressourcenmodul tut, schauen wir uns ein Beispiel eines Playbooks an, das eine idempoente Operation unter Verwendung neuer Fakten aus einer Netzwerkressource und dem Modul <code>eos_l3_interface</code> . </p><br><pre> <code class="plaintext hljs">- name: example of facts being pushed right back to device. hosts: arista gather_facts: false tasks: - name: grab arista eos facts eos_facts: gather_subset: min gather_network_resources: l3_interfaces - name: ensure that the IP address information is accurate eos_l3_interfaces: config: "{{ ansible_network_resources['l3_interfaces'] }}" register: result - name: ensure config did not change assert: that: not result.changed</code> </pre> <br><p>  Wie Sie sehen, werden die vom Gerät gesammelten Daten ohne Konvertierung direkt an das entsprechende Ressourcenmodul übertragen.  Beim Start ruft das Playbook die Werte vom Gerät ab und vergleicht sie mit den erwarteten.  In diesem Beispiel entsprechen die erhaltenen Werte den erwarteten Werten (dh die Konfigurationsabweichungen werden überprüft) und eine Meldung wird angezeigt, wenn sich die Konfiguration geändert hat. </p><br><p>  Ein idealer Weg, um Konfigurationsabweichungen zu erkennen, besteht darin, die Fakten in gespeicherten Ansible-Variablen zu speichern und sie regelmäßig mit dem Ressourcenmodul im Prüfmodus zu verwenden.  Dies ist eine einfache Methode, um festzustellen, ob jemand die Werte manuell geändert hat.  In den meisten Fällen erlauben Organisationen manuelle Änderungen und Konfigurationen, obwohl viele Vorgänge über Ansible Automation ausgeführt werden. </p><br><h2 id="chem-novye-moduli-resursa-otlichayutsya-ot-predyduschih">  Wie unterscheiden sich neue Ressourcenmodule von früheren? </h2><br><p>  Für einen Netzwerkautomatisierungsingenieur gibt es drei Hauptunterschiede zwischen Ressourcenmodulen in Ansible 2.9 und früheren Versionen. </p><br><p>  1) Für eine bestimmte Netzwerkressource (die auch als Konfigurationsabschnitt betrachtet werden kann) werden die Module und Fakten in allen unterstützten Netzwerkbetriebssystemen gleichzeitig entwickelt.  Wir sind der Meinung, dass Ansible, wenn es die Ressourcenkonfiguration auf einer einzelnen Netzwerkplattform unterstützt, diese überall unterstützen sollte.  Dies vereinfacht die Verwendung von Ressourcenmodulen, da ein Netzwerkautomatisierungstechniker jetzt eine Ressource (z. B. LLDP) in allen Netzwerkbetriebssystemen mit nativen und unterstützten Modulen konfigurieren kann. </p><br><p>  2) Ressourcenmodule enthalten jetzt einen Statuswert. </p><br><ul><li>  <code>merged</code> : Die Konfiguration wird mit der bereitgestellten Konfiguration zusammengeführt (Standard). </li><li>  <code>replaced</code> : Die Ressourcenkonfiguration wird durch die bereitgestellte Konfiguration ersetzt. </li><li>  <code>overridden</code> : Die Ressourcenkonfiguration wird durch die bereitgestellte Konfiguration ersetzt.  überschüssige Ressourceninstanzen werden gelöscht; </li><li>  <code>deleted</code> : Die Ressourcenkonfiguration wird standardmäßig gelöscht / wiederhergestellt. </li></ul><br><p><img src="https://habrastorage.org/webt/yg/0m/_c/yg0m_c1thcp9wm30_de2tqjs810.jpeg"></p><br><p>  3) Ressourcenmodule enthalten jetzt stabile Rückgabewerte.  Wenn das Netzwerkressourcenmodul die erforderlichen Änderungen am Netzwerkgerät vorgenommen (oder vorgeschlagen) hat, gibt es dieselben Schlüssel-Wert-Paare an das Playbook zurück. </p><br><ul><li>  <code>before</code> : Konfiguration auf dem Gerät in Form von strukturierten Daten vor der Aufgabe; </li><li>  <code>after</code> : Wenn sich das Gerät geändert hat (oder sich ändern kann, wenn der Überprüfungsmodus verwendet wird), wird die resultierende Konfiguration in Form strukturierter Daten zurückgegeben. </li><li>  <code>commands</code> : Alle Konfigurationsbefehle, die auf dem Gerät ausgeführt werden, um es in den gewünschten Zustand zu bringen. </li></ul><br><p><img src="https://habrastorage.org/webt/si/jq/r2/sijqr2ujxrhob-6mvsg2wjcmhrw.jpeg"></p><br><p><img src="https://habrastorage.org/webt/tn/1s/cq/tn1scqim6qomensla3ksk3bn8s4.jpeg"></p><br><h2 id="chto-vse-eto-znachit-pochemu-eto-vazhno">  Was bedeutet das alles?  Warum ist das wichtig? </h2><br><p>  Dieser Beitrag beschreibt viele komplexe Konzepte, aber wir hoffen, dass Sie am Ende besser verstehen, dass Unternehmenskunden nach Fakten, Datennormalisierung und Schleifenkonfiguration für die Automatisierungsplattform fragen.  Aber warum brauchen sie diese Verbesserungen?  Viele Unternehmen befassen sich derzeit mit der digitalen Transformation, um ihre IT-Umgebungen flexibler und wettbewerbsfähiger zu gestalten.  Ob gut oder schlecht, viele Netzwerktechniker werden zu Netzentwicklern, entweder aus eigenem Interesse oder auf Geheiß von Managern. </p><br><p>  Unternehmen wissen, dass die Automatisierung einzelner Netzwerkvorlagen das Fragmentierungsproblem nicht löst und die Effizienz nur bis zu einer bestimmten Grenze erhöht.  Die Red Hat Ansible Automation Platform bietet strenge und normative Ressourcendatenmodelle zur programmgesteuerten Verwaltung der zugrunde liegenden Daten auf einem Netzwerkgerät.  Das heißt, Benutzer geben nach und nach einzelne Konfigurationsmethoden zugunsten modernerer Methoden auf, wobei der Schwerpunkt auf Technologien (z. B. IP-Adressen, VLAN, LLDP usw.) und nicht auf einer bestimmten Herstellerimplementierung liegt. </p><br><p>  Bedeutet dies, dass die Tage zuverlässiger und bewährter Befehlsmodule und -konfigurationen gezählt sind?  Auf keinen Fall.  Die erwarteten Netzwerkressourcenmodule sind nicht in allen Fällen und nicht für jeden Anbieter anwendbar, sodass die Netzwerktechniker für bestimmte Implementierungen weiterhin die Befehls- und Konfigurationsmodule benötigen.  Der Zweck von Ressourcenmodulen besteht darin, große Jinja-Vorlagen zu vereinfachen und unstrukturierte Gerätekonfigurationen in ein strukturiertes JSON-Format zu normalisieren.  Mit Ressourcenmodulen wird es für vorhandene Netzwerke einfacher sein, ihre Konfiguration in strukturierte Schlüssel-Wert-Paare umzuwandeln, die eine leicht lesbare Quelle der Wahrheit darstellen.  Wenn Sie strukturierte Schlüssel-Wert-Paare verwenden, können Sie von laufenden Konfigurationen auf jedem Gerät zur Arbeit mit unabhängigen strukturierten Daten wechseln und Netzwerke mit dem Ansatz „Infrastruktur als Code“ in den Vordergrund rücken. </p><br><h2 id="kakie-moduli-resursov-poyavyatsya-v-ansible-engine-29">  Welche Ressourcenmodule werden in Ansible Engine 2.9 angezeigt? </h2><br><p>  Bevor wir detailliert erklären, was in Ansible 2.9 passieren wird, erinnern wir uns daran, wie wir den gesamten Arbeitsaufwand aufgeteilt haben. </p><br><p>  Wir haben 7 Kategorien identifiziert und jeder bestimmte Netzwerkressourcen zugewiesen: </p><br><p><img src="https://habrastorage.org/webt/qs/io/au/qsioaupl7rqnsvfnmiyzygd9zqs.png"></p><br><p>  Hinweis: In Ansible 2.9 wurden mutige Ressourcen geplant und implementiert. <br>  Basierend auf dem Feedback von Unternehmenskunden und der Community war es logisch, sich zunächst mit den Modulen zu befassen, die sich auf Netzwerktopologieprotokolle, Virtualisierung und Schnittstellen beziehen. <br>  Die folgenden Ressourcenmodule wurden vom Ansible Network-Team entwickelt und entsprechen den von Red Hat unterstützten Plattformen: </p><br><p><img src="https://habrastorage.org/webt/um/n8/lr/umn8lrzquzbuxlxbb10vaebxavw.png"></p><br><p>  Die folgenden Module werden von der Ansible-Community entwickelt: </p><br><ul><li>  <code>exos_lldp_global</code> - von Extreme Networks. </li><li>  <code>nxos_bfd_interfaces</code> - von Cisco </li><li>  <code>nxos_telemetry</code> - von Cisco </li></ul><br><p>  Wie Sie sehen, passt das Konzept der Ressourcenmodule in unsere Plattformorientierungsstrategie.  Das heißt, wir nehmen die erforderlichen Features und Funktionen in Ansible selbst auf, um die Standardisierung bei der Entwicklung von Netzwerkmodulen zu unterstützen und die Arbeit der Benutzer auf der Ebene der Ansible-Rollen und Playbooks zu vereinfachen.  Um die Entwicklung von Ressourcenmodulen zu erweitern, hat das Ansible-Team das Tool Module Builder veröffentlicht. </p><br><h2 id="plany-na-ansible-210-i-dalshe">  Pläne ab Ansible 2.10 </h2><br><p>  Nach der Veröffentlichung von Ansible 2.9 werden wir uns mit den folgenden Ressourcenmodulen für Ansible 2.10 befassen, mit denen die Topologie und die Netzwerkrichtlinie weiter konfiguriert werden können, z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ACL, OSPF und BGP</a> .  Der Entwicklungsplan kann weiterhin angepasst werden. Wenn Sie also Kommentare haben, melden Sie diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Ansible Network-Community</a> . </p><br><h2 id="resursy-i-nachalo-raboty">  Ressourcen und erste Schritte </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pressemitteilung der Ansible Automation Platform</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ansible Automation Platform Blog</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Zukunft der Inhaltsbereitstellung bei Ansible</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überlegungen zum Ändern der Ansible-Projektstruktur</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471896/">https://habr.com/ru/post/de471896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471878/index.html">Wie schreibe ich einen intelligenten Vertrag für WebAssembly in einem Ontology-Netzwerk? Teil 1: Rost</a></li>
<li><a href="../de471884/index.html">10 kostenlose ApexSQL-Dienstprogramme zum Verwalten von Microsoft SQL Server-Datenbanken</a></li>
<li><a href="../de471886/index.html">VMmanager 6: Einführung in die Box und Vergleich mit der vorherigen Generation</a></li>
<li><a href="../de471890/index.html">Variationsinferenz - was ist das und was isst es?</a></li>
<li><a href="../de471892/index.html">6 praktische Geschichten von unseren SRE-Wochentagen</a></li>
<li><a href="../de471904/index.html">Ressourcenplaner bei HPE InfoSight</a></li>
<li><a href="../de471906/index.html">Die Gefahren unsachgemäßer Optimierungen</a></li>
<li><a href="../de471908/index.html">Die unerwartete Schönheit von Primzahlen</a></li>
<li><a href="../de471912/index.html">Englisch lernen: 7 praktische Möglichkeiten, Ihren Wortschatz zu erweitern</a></li>
<li><a href="../de471914/index.html">Funktionsweise des Sega Mega Drive-Grafiksystems: Videoanzeigeprozessor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>