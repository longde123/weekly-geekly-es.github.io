<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👮 ✴️ 🔍 Haproxy文档漫游历史记录或配置时查找的内容 🤚🏻 🎊 📇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好！ 

 上次，我们讨论了在Ostrovok.ru中选择一种工具来解决将大量请求代理到外部服务的问题，而无需同时放置任何人。 文章以精选的Haproxy结尾 。 今天，我将分享使用该解决方案时必须面对的细微差别。 



 代理配置 
 第一个困难是maxconn选项根据上下文而有所不同： 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Haproxy文档漫游历史记录或配置时查找的内容</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ostrovok/blog/438966/"> 你好！ <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上次，</a>我们讨论了在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ostrovok.ru中</a>选择一种工具来解决将大量请求代理到外部服务的问题，而无需同时放置任何人。 文章以精选的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Haproxy结尾</a> 。 今天，我将分享使用该解决方案时必须面对的细微差别。 <br><br><img src="https://habrastorage.org/webt/ns/mz/sb/nsmzsbtu2c1rgib_avecisgyrlk.jpeg"><br><a name="habracut"></a><br><h3> 代理配置 </h3><br> 第一个困难是<code>maxconn</code>选项根据上下文而有所不同： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">maxconn（性能调整）；</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">maxconn（绑定选项）;</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">maxconn（服务器和默认服务器选项）。</a> </li></ul><br> 出于习惯，我仅调整了第一个选项（ <code>performance tuning</code> ）。 这是文档中关于此选项的说明： <br><blockquote> 将每个进程的最大并发连接数设置为&lt;number&gt;。 它 <br> 等效于命令行参数“ -n”。 代理将停止接受 <br> 达到此限制时连接。 <br></blockquote><br> 似乎需要什么。 但是，当我发现与代理服务器的新连接并没有马上消失的事实时，我开始更仔细地阅读文档，并且在那里我已经找到了第二个参数（ <code>bind options</code> ）： <br><blockquote> 将套接字限制为此并发连接数。 外来的 <br> 连接将保留在系统的待办事项中，直到建立连接为止 <br> 已发布。 如果未指定，则限制将与前端的maxconn相同。 <br></blockquote><br> 所以， <code>frontends maxconn</code>吧，然后寻找<code>frontends maxconn</code> ： <br><blockquote> 固定前端的最大并发连接数 <br>  ... <br> 默认情况下，此值设置为2000。 <br></blockquote><br> 太好了，您需要什么。 添加到配置： <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">global</span></span> daemon maxconn 524288 ... defaults mode http maxconn 524288</code> </pre><br> 下一个问题是Haproxy是单线程的。 我非常习惯Nginx中的模型，因此这种细微差别一直令我沮丧。 但是请不要绝望<i>-Willy Tarreau（Haproxy的开发人员</i> ）了解他在做什么，因此他添加了选项<code>nbproc</code> 。 <br><br> 但是，直接在文档中显示： <br><blockquote> 使用多个过程 <br> 很难调试，因此非常不高兴。 <br></blockquote> 如果您需要，此选项确实会使您头痛： <br><br><ul><li> 限制与服务器的请求/连接数（因为您已经没有一个进程带有一个计数器，而是很多进程，并且每个进程都有自己的计数器）； </li><li> 从Haproxy管理套接字收集统计信息 </li><li> 通过控制套接字启用/禁用后端； </li><li>  ...也许其他的东西。  ¯\ _（ツ）_ /¯ </li></ul><br> 尽管如此，众神给了我们多核处理器，所以我想最大限度地使用它们。 就我而言，两个物理核心中有四个核心。 对于Haproxy，我选择了第一个核心，它看起来像这样： <br><br><pre> <code class="apache hljs"> <span class="hljs-attribute"><span class="hljs-attribute">nbproc</span></span> 4 cpu-map 1 0 cpu-map 2 1 cpu-map 3 2 cpu-map 4 3</code> </pre><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cpu-map，</a>我们将Haproxy进程绑定到特定的核心。 操作系统调度程序不再需要考虑在何处计划Haproxy，从而使<code>content switch</code>保持凉爽，并使CPU缓存保持温暖。 <br><br><h4> 有很多缓冲区，但在我们这里没有 </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tune.bufsize-</a>在我们的情况下，没有必要运行它，但是如果您对代码<code>400 (Bad Request)</code>有错误，则可能是您的情况。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://cbonte.github.io/haproxy-dconv/1.9/configuration.html&amp;usg=ALkJrhig2SylYJqvRQvmAyvnr9WLJ3EutA#tune.">tune.http.cookielen-</a>如果您向用户分发大的cookie，则为了避免在网络传输过程中造成损坏，也有必要增加此缓冲区。 </li><li> 如果标题太多，则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://cbonte.github.io/haproxy-dconv/1.9/configuration.html&amp;usg=ALkJrhig2SylYJqvRQvmAyvnr9WLJ3EutA#tune.">tune.http.maxhdr</a>是400个响应代码的另一个可能来源。 </li></ul><br><h4> 现在考虑下层的东西 </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tune.rcvbuf.client</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tune.rcvbuf.server</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tune.sndbuf.client</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tune.sndbuf.server-</a>该文档显示以下内容： <br><blockquote> 通常不应设置该值，默认大小（0）可使内核根据可用内存量自动调整该值。 <br></blockquote><br> 但是对我来说，显而易见的要比隐含的好，所以我强迫这些选项的值来确保明天。 <br><br> 另一个与缓冲区无关但很重要的参数是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">tune.maxaccept</a> 。 <br><blockquote> 设置进程可以接受的最大连续连接数 <br> 切换到其他工作之前 在单进程模式下，更高的数字 <br> 在高连接速率下提供更好的性能。 但是在多进程中 <br> 模式，一般来说，保持流程之间的公平性更好 <br> 提高性能。 <br></blockquote><br> 在我们的例子中，生成了很多代理请求，因此我提高了此值以一次接受更多请求。 但是，正如文档所述，值得测试的是，在多线程模式下，负载应尽可能均匀地分布在各个进程之间。 <br><br> 所有参数一起： <br><br><pre> <code class="apache hljs"> <span class="hljs-attribute"><span class="hljs-attribute">tune</span></span>.bufsize 16384 tune.http.cookielen 63 tune.http.maxhdr 101 tune.maxaccept 256 tune.rcvbuf.client 33554432 tune.rcvbuf.server 33554432 tune.sndbuf.client 33554432 tune.sndbuf.server 33554432</code> </pre><br><h4> 永远不会发生超时。 没有他们我们该怎么办？ </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">超时连接</a> -与后端建立<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">连接的</a>时间。 如果与后端的连接不是很好，那么最好在此超时之前将其禁用，直到网络恢复正常。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">超时客户端</a> -传输数据的第一个字节的超时。 它有助于断开那些“保留”请求的人。 </li></ul><br><div class="spoiler">  <b class="spoiler_title">有关Go中HTTP客户端的Kulstory</b> <div class="spoiler_text">  Go具有一个常规HTTP客户端，该客户端能够保留与服务器的连接池。 因此发生了一个有趣的故事，其中HTTP客户端中的上述超时和连接池参与其中。 一旦开发人员投诉他定期从代理收到408错误。 我们查看了客户端代码，并在其中看到了以下逻辑： <br><br><ul><li> 我们正在尝试从池中建立免费的已建立连接； </li><li> 如果无法解决，请在goroutine中开始安装新连接； </li><li> 再次检查游泳池； </li><li> 如果池中有可用的东西-我们将其拿走，然后将新的放入池中；如果没有，请使用新的。 </li></ul><br> 已经了解盐是什么？ <br><br> 如果客户端已建立新连接但尚未使用，则服务器在五秒钟后关闭它，并且情况已结束。 客户端仅在它已经从池中获取连接并尝试使用它时才捕获此连接。 值得牢记这一点。 <br></div></div><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">超时服务器</a> -等待服务器响应的最长时间。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">超时client-fin</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">超时server-fin-</a>在这里，我们保护自己免受半封闭连接的影响，以免将其累积在操作系统表中。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://cbonte.github.io/haproxy-dconv/1.9/configuration.html&amp;usg=ALkJrhig2SylYJqvRQvmAyvnr9WLJ3EutA#timeout%20">超时http-request</a>是最合适的超时之一。 允许您斩断无法在分配的时间内向其发出HTTP请求的慢速客户端。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://cbonte.github.io/haproxy-dconv/1.9/configuration.html&amp;usg=ALkJrhig2SylYJqvRQvmAyvnr9WLJ3EutA#timeout%20">超时http-keep-alive-</a>在我们的情况下，特别是如果<code>keep-alive</code>连接在没有请求的情况下挂起超过50秒，则很可能出现了问题，可以关闭连接，从而为新的空间释放了内存轻。 </li></ul><br> 所有超时一起： <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">defaults</span></span> mode http maxconn 524288 timeout connect 5s timeout client 10s timeout server 120s timeout client-fin 1s timeout server-fin 1s timeout http-request 10s timeout http-keep-alive 50s</code> </pre><br><h4> 记录中 为什么这么难？ </h4><br> 如我先前所写，在我的决策中，大多数时候我都使用Nginx，因此，它的语法和修改日志格式的简单性让我着迷。 我特别喜欢杀手级功能-以json的形式格式化日志，然后将其与任何标准库一起解析。 <br><br> 在Haproxy我们有什么？ 有这样的机会，只有您才能以syslog独占方式编写，并且配置语法要稍微包装一些。 <br> 我将为您提供一个示例配置，并提供注释： <br><br><pre> <code class="apache hljs"><span class="hljs-comment"><span class="hljs-comment">#  ,     ,    (   # error.log  nginx) log 127.0.0.1:2514 len 8192 local1 notice emerg #    -  access.log log 127.0.0.1:2514 len 8192 local7 info</span></span></code> </pre><br> 特殊的疼痛是由以下时刻引起的： <br><ul><li> 短变量名，尤其是它们的组合，例如％HU或％fp </li><li> 格式不能分为几行，因此您必须在一行中写上脚印。 难以添加/删除新的/不必要的项目 </li><li> 为了使某些变量起作用，必须通过捕获请求标头明确声明它们 </li></ul><br> 结果，要获得一些有趣的东西，您就必须拥有这样的鞋履： <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">log</span></span>-format '{<span class="hljs-string"><span class="hljs-string">"status"</span></span>:<span class="hljs-string"><span class="hljs-string">"%ST"</span></span>,<span class="hljs-string"><span class="hljs-string">"bytes_read"</span></span>:<span class="hljs-string"><span class="hljs-string">"%B"</span></span>,<span class="hljs-string"><span class="hljs-string">"bytes_uploaded"</span></span>:<span class="hljs-string"><span class="hljs-string">"%U"</span></span>,<span class="hljs-string"><span class="hljs-string">"hostname"</span></span>:<span class="hljs-string"><span class="hljs-string">"%H"</span></span>,<span class="hljs-string"><span class="hljs-string">"method"</span></span>:<span class="hljs-string"><span class="hljs-string">"%HM"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_uri"</span></span>:<span class="hljs-string"><span class="hljs-string">"%HU"</span></span>,<span class="hljs-string"><span class="hljs-string">"handshake_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Th"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_idle_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Ti"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%TR"</span></span>,<span class="hljs-string"><span class="hljs-string">"response_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Tr"</span></span>,<span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Ts"</span></span>,<span class="hljs-string"><span class="hljs-string">"client_ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"%ci"</span></span>,<span class="hljs-string"><span class="hljs-string">"client_port"</span></span>:<span class="hljs-string"><span class="hljs-string">"%cp"</span></span>,<span class="hljs-string"><span class="hljs-string">"frontend_port"</span></span>:<span class="hljs-string"><span class="hljs-string">"%fp"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_request"</span></span>:<span class="hljs-string"><span class="hljs-string">"%r"</span></span>,<span class="hljs-string"><span class="hljs-string">"ssl_ciphers"</span></span>:<span class="hljs-string"><span class="hljs-string">"%sslc"</span></span>,<span class="hljs-string"><span class="hljs-string">"ssl_version"</span></span>:<span class="hljs-string"><span class="hljs-string">"%sslv"</span></span>,<span class="hljs-string"><span class="hljs-string">"date_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%t"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_host"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(0)]"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_referer"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(1)]"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_user_agent"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(2)]"</span></span>}'</code> </pre><br><h4> 好吧，似乎没什么，但是很好 </h4><br> 我在上面描述了日志的格式，但不是那么简单。 在其中存放一些元素，例如： <br><br><ul><li>  http_host </li><li>  http_referer， </li><li>  http_user_agent， </li></ul><br> 首先，您需要从请求中捕获此数据（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">capture</a> ）并将其放入捕获值数组中。 <br><br> 这是一个例子： <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">capture</span></span> request header Host len 32 capture request header Referer len 128 capture request header User-Agent len 128</code> </pre><br> 结果，我们现在可以通过这种方式访问​​所需的元素： <br>  <code>%[capture.req.hdr(N)]</code> ，其中N是捕获组定义的序列号。 <br> 在上面的示例中，Host标头将位于数字0，而User-Agent将位于数字2。 <br><br>  Haproxy具有一个特殊性：它在启动时解析后端的DNS地址，并且，如果它不能解析任何地址，则将失去勇气。 <br><br> 在我们的情况下，这不是很方便，因为后端很多，我们不对其进行管理，因此从Haproxy获取503最好比整个代理服务器由于一个提供程序而拒绝启动更好。 以下选项可以帮助我们： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">init-addr</a> 。 <br><br> 直接从文档中摘录的一行使我们可以研究所有可用的方法来解析地址，对于文件，只需将其推迟到以后再继续： <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">default</span></span>-server init-addr last,libc,none</code> </pre> <br> 最后，我最喜欢的是：后端选择。 <br> 每个人都熟悉Haproxy后端选择配置的语法： <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">use_backend</span></span> &lt;backend1_name&gt; if &lt;condition1&gt; use_backend &lt;backend2_name&gt; if &lt;condition2&gt; default-backend &lt;backend3&gt;</code> </pre><br> 但是，正确的说，不是很正确。 我已经以自动化的方式描述了所有后端（请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上一篇文章</a> ），也可以在这里生成<code>use_backend</code> ，不好的事情并不棘手，但我不想这么做。 结果，找到了另一种方法： <br><br><pre> <code class="apache hljs"> <span class="hljs-attribute"><span class="hljs-attribute">capture</span></span> request header Host len 32 capture request header Referer len 128 capture request header User-Agent len 128 #   host_present      Host acl host_present hdr(host) -m len gt 0 #    ,     use_backend %[req.hdr(host),lower,field(1,'.')] if host_present #      ,    default_backend default backend default mode http server no_server 127.0.0.1:65535</code> </pre><br> 因此，我们标准化了后端和URL的名称，您可以通过它们来访问它们。 <br><br> 好了，现在将以上示例编译成一个文件： <br><br><div class="spoiler">  <b class="spoiler_title">完整版本的配置</b> <div class="spoiler_text"><pre> <code class="apache hljs"> <span class="hljs-attribute"><span class="hljs-attribute">global</span></span> daemon maxconn 524288 nbproc 4 cpu-map 1 0 cpu-map 2 1 cpu-map 3 2 cpu-map 4 3 tune.bufsize 16384 tune.comp.maxlevel 1 tune.http.cookielen 63 tune.http.maxhdr 101 tune.maxaccept 256 tune.rcvbuf.client 33554432 tune.rcvbuf.server 33554432 tune.sndbuf.client 33554432 tune.sndbuf.server 33554432 stats socket /run/haproxy.sock mode 600 level admin log /dev/stdout local0 debug defaults mode http maxconn 524288 timeout connect 5s timeout client 10s timeout server 120s timeout client-fin 1s timeout server-fin 1s timeout http-request 10s timeout http-keep-alive 50s default-server init-addr last,libc,none log 127.0.0.1:2514 len 8192 local1 notice emerg log 127.0.0.1:2514 len 8192 local7 info log-format '{<span class="hljs-string"><span class="hljs-string">"status"</span></span>:<span class="hljs-string"><span class="hljs-string">"%ST"</span></span>,<span class="hljs-string"><span class="hljs-string">"bytes_read"</span></span>:<span class="hljs-string"><span class="hljs-string">"%B"</span></span>,<span class="hljs-string"><span class="hljs-string">"bytes_uploaded"</span></span>:<span class="hljs-string"><span class="hljs-string">"%U"</span></span>,<span class="hljs-string"><span class="hljs-string">"hostname"</span></span>:<span class="hljs-string"><span class="hljs-string">"%H"</span></span>,<span class="hljs-string"><span class="hljs-string">"method"</span></span>:<span class="hljs-string"><span class="hljs-string">"%HM"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_uri"</span></span>:<span class="hljs-string"><span class="hljs-string">"%HU"</span></span>,<span class="hljs-string"><span class="hljs-string">"handshake_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Th"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_idle_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Ti"</span></span>,<span class="hljs-string"><span class="hljs-string">"request_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%TR"</span></span>,<span class="hljs-string"><span class="hljs-string">"response_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Tr"</span></span>,<span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>:<span class="hljs-string"><span class="hljs-string">"%Ts"</span></span>,<span class="hljs-string"><span class="hljs-string">"client_ip"</span></span>:<span class="hljs-string"><span class="hljs-string">"%ci"</span></span>,<span class="hljs-string"><span class="hljs-string">"client_port"</span></span>:<span class="hljs-string"><span class="hljs-string">"%cp"</span></span>,<span class="hljs-string"><span class="hljs-string">"frontend_port"</span></span>:<span class="hljs-string"><span class="hljs-string">"%fp"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_request"</span></span>:<span class="hljs-string"><span class="hljs-string">"%r"</span></span>,<span class="hljs-string"><span class="hljs-string">"ssl_ciphers"</span></span>:<span class="hljs-string"><span class="hljs-string">"%sslc"</span></span>,<span class="hljs-string"><span class="hljs-string">"ssl_version"</span></span>:<span class="hljs-string"><span class="hljs-string">"%sslv"</span></span>,<span class="hljs-string"><span class="hljs-string">"date_time"</span></span>:<span class="hljs-string"><span class="hljs-string">"%t"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_host"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(0)]"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_referer"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(1)]"</span></span>,<span class="hljs-string"><span class="hljs-string">"http_user_agent"</span></span>:<span class="hljs-string"><span class="hljs-string">"%[capture.req.hdr(2)]"</span></span>}' frontend http bind *:80 http-request del-header X-Forwarded-For http-request del-header X-Forwarded-Port http-request del-header X-Forwarded-Proto capture request header Host len 32 capture request header Referer len 128 capture request header User-Agent len 128 acl host_present hdr(host) -m len gt 0 use_backend %[req.hdr(host),lower,field(1,'.')] if host_present default_backend default backend default mode http server no_server 127.0.0.1:65535 resolvers dns hold valid 1s timeout retry 100ms nameserver dns1 127.0.0.1:53</code> </pre><br></div></div><br> 感谢那些读到最后的人。 但是，这还不是全部。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下次，</a>我们将研究与优化系统本身相关的低级事物，Haproxy可以在其中进行工作，以使其与他的操作系统配合使用，并且每个人都有足够的动力。 <br><br> 待会见！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438966/">https://habr.com/ru/post/zh-CN438966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438956/index.html">牙齿中的磁炎：壳软体动物的组织转录组测序</a></li>
<li><a href="../zh-CN438958/index.html">ILV确认其“空间站”的存在</a></li>
<li><a href="../zh-CN438960/index.html">在后端工作时，我如何放弃Ruby取而代之的是Python</a></li>
<li><a href="../zh-CN438962/index.html">在大多数情况下，芯片的未来前景乐观</a></li>
<li><a href="../zh-CN438964/index.html">谁真正背后流行的免费VPN？</a></li>
<li><a href="../zh-CN438968/index.html">俄罗斯的标志鞋：市场尚未准备就绪，但必须奏效</a></li>
<li><a href="../zh-CN438970/index.html">据说Haskell是一种天才和学者的语言。 对不对</a></li>
<li><a href="../zh-CN438972/index.html">从内部大脑（通过人工神经网络模型可视化模式的通过）</a></li>
<li><a href="../zh-CN438974/index.html">虚拟现实有助于应对精神疾病</a></li>
<li><a href="../zh-CN438976/index.html">《春天。 所有设计模式»</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>