<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤦 ⬇️ 😮 Métodos genéricos en óxido: cómo el exón se desplazó del hierro a la web Actix 🧞 ☹️ 👎🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El ecosistema de Rust todavía está creciendo. Como resultado, las nuevas bibliotecas con funcionalidad mejorada se lanzan con frecuencia a la comunida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Métodos genéricos en óxido: cómo el exón se desplazó del hierro a la web Actix</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitfury/blog/439258/">  El ecosistema de Rust todavía está creciendo.  Como resultado, las nuevas bibliotecas con funcionalidad mejorada se lanzan con frecuencia a la comunidad de desarrolladores, mientras que las bibliotecas más antiguas se vuelven obsoletas.  Cuando inicialmente diseñamos Exonum, utilizamos el framework web Iron.  En este artículo, describimos cómo portamos el framework Exonum a actix-web usando programación genérica. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/tc/vv/ye/tcvvye1qopj5cqsfv3rxp9-_sly.png"></a> <a name="habracut"></a><br><br><h2>  Exonum sobre hierro </h2><br>  En la plataforma Exonum, el marco de hierro se utilizó sin abstracciones.  Instalamos manejadores para ciertos recursos y obtuvimos parámetros de solicitud al analizar URL usando métodos auxiliares;  el resultado se devolvió simplemente en forma de cadena. <br><br>  El proceso se parecía (aproximadamente) al siguiente: <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_blocks_response</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blocks = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.required_param(req, <span class="hljs-string"><span class="hljs-string">"count"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> latest: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"latest"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> skip_empty_blocks: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"skip_empty_blocks"</span></span>)? .unwrap_or(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blocks(count, latest.map(Height), skip_empty_blocks)?; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ok_response(&amp;::serde_json::to_value(info).unwrap()) }; router.get(<span class="hljs-string"><span class="hljs-string">"/v1/blocks"</span></span>, blocks, <span class="hljs-string"><span class="hljs-string">"blocks"</span></span>); }</code> </pre> <br>  Además, utilizamos algunos complementos de middleware en forma de encabezados CORS.  Utilizamos mount para fusionar todos los controladores en una sola API. <br><br><h2>  Nuestra decisión de alejarnos del hierro </h2><br>  Iron era una buena biblioteca, con muchos complementos.  Sin embargo, fue escrito en los días en que no existían proyectos como futuros y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tokio</a> . <br><br>  La arquitectura de Iron implica el procesamiento de solicitudes sincrónicas, que pueden verse fácilmente afectadas por una gran cantidad de conexiones abiertas simultáneamente.  Para ser escalable, Iron necesitaba volverse asíncrono, lo que implicaría repensar y reescribir todo el marco.  Como resultado, hemos visto una desviación gradual del uso de Iron por parte de ingenieros de software. <br><br><h2>  Por qué elegimos Actix-Web </h2><br>  Actix-web es un marco popular que ocupa un lugar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">destacado</a> en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puntos de referencia de TechEmpower</a> .  Tiene una comunidad de desarrolladores activa, a diferencia de Iron, y tiene una API bien diseñada y una implementación de alta calidad basada en el marco del actor actix.  Las solicitudes son procesadas asincrónicamente por el grupo de subprocesos;  si la solicitud procesa el pánico, el actor se reinicia automáticamente. <br><br>  Anteriormente, se planteó la preocupación de que actix-web contenía una gran cantidad de código inseguro.  Sin embargo, la cantidad de código inseguro se redujo significativamente cuando el marco se reescribió en un lenguaje de programación seguro: Rust.  Los ingenieros de Bitfury han revisado este código ellos mismos y se sienten seguros de su estabilidad a largo plazo. <br><br>  Para el marco Exonum, el cambio a actix resolvió el problema de la estabilidad de la operación.  El marco de Iron podría fallar si hubiera una gran cantidad de conexiones.  También hemos descubierto que la API actix-web es más simple, más productiva y más unificada.  Estamos seguros de que a los usuarios y desarrolladores les resultará más fácil usar la interfaz de programación Exonum, que ahora puede operar más rápido gracias al diseño web actix. <br><br><h2>  Lo que requerimos de un marco web </h2><br>  Durante este proceso, nos dimos cuenta de que era importante para nosotros no simplemente cambiar los marcos, sino también diseñar una nueva arquitectura API independiente de cualquier marco web específico.  Dicha arquitectura permitiría crear controladores, con poca o ninguna preocupación por los detalles web, y transferirlos a cualquier backend.  Esta concepción puede implementarse escribiendo una interfaz que aplique tipos y rasgos básicos. <br><br>  Para comprender cómo debe verse esta interfaz, definamos qué es realmente cualquier API HTTP: <br><br><ul><li>  Las solicitudes son hechas exclusivamente por clientes;  el servidor solo responde a ellas (el servidor no inicia solicitudes). </li><li>  Solicita leer datos o cambiar datos. </li><li>  Como resultado del procesamiento de la solicitud, el servidor devuelve una respuesta, que contiene los datos requeridos, en caso de éxito;  o información sobre el error, en caso de falla. </li></ul><br>  Si vamos a analizar todas las capas de abstracción, resulta que cualquier solicitud HTTP es solo una llamada de función: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span></span>(context: &amp;ServiceContext, query: Query) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Response, ServiceError&gt;</code> </pre> <br>  Todo lo demás puede considerarse una extensión de esta entidad básica.  Por lo tanto, para ser independientes de una implementación específica de un marco web, necesitamos escribir controladores en un estilo similar al ejemplo anterior. <br><br><h2>  Rasgo `Punto final` para el procesamiento genérico de solicitudes HTTP </h2><br>  El enfoque más simple y directo sería declarar el rasgo `Endpoint`, que describe las implementaciones de solicitudes específicas: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// A trait describing GET request handlers. It should be possible to call each of the handlers from any freed // thread. This requirement imposes certain restrictions on the trait. Parameters and request results are // configured using associated types. trait Endpoint: Sync + Send + 'static { type Request: DeserializeOwned + 'static; type Response: Serialize + 'static; fn handle(&amp;self, context: &amp;Context, request: Self::Request) -&gt; Result&lt;Self::Response, io::Error&gt;; }</span></span></code> </pre> <br>  Ahora necesitamos implementar este controlador en un marco específico.  Por ejemplo, en actix-web tiene el siguiente aspecto: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Response type in actix-web. Note that they are asynchronous, even though `Endpoint` assumes that // processing is synchronous. type FutureResponse = actix_web::FutureResponse&lt;HttpResponse, actix_web::Error&gt;; // A raw request handler for actix-web. This is what the framework ultimately works with. The handler // receives parameters from an arbitrary context, through which the request parameters are passed. type RawHandler = dyn Fn(HttpRequest&lt;Context&gt;) -&gt; FutureResponse + 'static + Send + Sync; // For convenience, let's put everything we need from the handler into a single structure. #[derive(Clone)] struct RequestHandler { /// The name of the resource. pub name: String, /// HTTP method. pub method: actix_web::http::Method, /// The raw handler. Note that it will be used from multiple threads. pub inner: Arc&lt;RawHandler&gt;, }</span></span></code> </pre> <br>  Podemos usar estructuras para pasar parámetros de solicitud a través del contexto.  Actix-web puede deserializar parámetros automáticamente usando serde.  Por ejemplo, a = 15 &amp; b = hola se deserializa en una estructura como esta: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleQuery</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br>  Esta funcionalidad de deserialización concuerda bien con el tipo asociado Solicitud del rasgo `Punto final`. <br><br>  A continuación, ideemos un adaptador que envuelva una implementación específica de 'Endpoint' en un RequestHandler para actix-web.  Preste atención al hecho de que al hacerlo, la información sobre los tipos de Solicitud y Respuesta desaparece.  Esta técnica se denomina borrado de tipo: transforma el envío estático en uno dinámico. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> RequestHandler { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_endpoint</span></span></span></span>&lt;E: Endpoint&gt;(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, endpoint: E) -&gt; RequestHandler { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |request: HttpRequest&lt;Context&gt;| -&gt; FutureResponse { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = request.state(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;E::Request&gt;| query.into_inner()) .and_then(|query| endpoint.handle(context, query).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from)) .and_then(|value| <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(HttpResponse::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>().json(value))) .into_future(); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(future) }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { name: name.to_owned(), method: actix_web::http::Method::GET, inner: Arc::from(index) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Arc&lt;RawHandler&gt;, } } }</code> </pre> <br>  En esta etapa, sería suficiente agregar controladores para las solicitudes POST, ya que hemos creado un rasgo que es independiente de los detalles de implementación.  Sin embargo, descubrimos que esta solución no era lo suficientemente avanzada. <br><br><h2>  Los inconvenientes del rasgo `Punto final` </h2><br>  Se genera una gran cantidad de código auxiliar cuando se escribe un controlador: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// A structure with the context of the handler. struct ElementCountEndpoint { elements: Rc&lt;RefCell&lt;Vec&lt;Something&gt;&gt;&gt;, } // Implementation of the `Endpoint` trait. impl Endpoint for ElementCountEndpoint { type Request = (); type Result = usize; fn handle(&amp;self, context: &amp;Context, _request: ()) -&gt; Result&lt;usize, io::Error&gt; { Ok(self.elements.borrow().len()) } } // Installation of the handler in the backend. let endpoint = ElementCountEndpoint::new(elements.clone()); let handler = RequestHandler::from_endpoint("/v1/element_count", endpoint); actix_backend.endpoint(handler);</span></span></code> </pre> <br>  Idealmente, necesitamos poder pasar un cierre simple como manejador, reduciendo así significativamente la cantidad de ruido sintáctico. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = elements.clone(); actix_backend.endpoint(<span class="hljs-string"><span class="hljs-string">"/v1/elements_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(elements.borrow().len()) });</code> </pre> <br>  A continuación discutiremos cómo se puede hacer esto. <br><br><h2>  Inmersión ligera en programación genérica </h2><br>  Necesitamos agregar la capacidad de generar automáticamente un adaptador que implemente el rasgo `Endpoint` con los tipos asociados correctos.  La entrada consistirá solo en un cierre con un controlador de solicitud HTTP. <br><br>  Los argumentos y el resultado del cierre pueden tener diferentes tipos, por lo que tenemos que trabajar con métodos de sobrecarga aquí.  Rust no admite la sobrecarga directamente, pero permite que se emule usando los rasgos 'Into' y 'From'. <br><br>  Además, el tipo devuelto del valor de cierre no tiene que coincidir con el valor devuelto de la implementación `Endpoint`.  Para manipular este tipo, debe extraerse del tipo del cierre recibido. <br><br><h2>  Obteniendo tipos del rasgo `Fn` </h2><br>  En Rust, cada cierre tiene su propio tipo único, que no se puede indicar explícitamente en el programa.  Para manipulaciones con cierres, utilizamos el rasgo `Fn`.  El rasgo contiene la firma de la función con los tipos de argumentos y del valor devuelto, sin embargo, no es fácil recuperar estos elementos por separado. <br><br>  La idea principal es utilizar una estructura auxiliar de la siguiente forma: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Simplified example of extracting types from an F closure: Fn(A) -&gt; B. struct SimpleExtractor&lt;A, B, F&gt; { // The original function. inner: F, _a: PhantomData&lt;A&gt;, _b: PhantomData&lt;B&gt;, }</span></span></code> </pre> <br>  Tenemos que usar PhantomData, ya que Rust requiere que todos los parámetros genéricos estén indicados en la definición de la estructura.  Sin embargo, el tipo de cierre o función F en sí no es genérico (aunque implementa un rasgo genérico `Fn`).  Los parámetros de tipo A y B no se utilizan directamente en él. <br><br>  Es esta restricción del sistema de tipo Rust lo que nos impide aplicar una estrategia más simple al implementar el rasgo `Endpoint` directamente para los cierres: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span></span> = A; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span></span> = B; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, context: &amp;Context, request: A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;B, io::Error&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  En el caso anterior, el compilador devuelve un error: <br><br><pre> <code class="rust hljs">error[E0207]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span> `A` is not constrained by the <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">or</span></span></span></span> predicates --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { | ^ unconstrained <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span></code> </pre> <br>  La estructura auxiliar SimpleExtractor permite describir la conversión de `From`.  Esta conversión nos permite guardar cualquier función y extraer los tipos de sus argumentos: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SimpleExtractor&lt;A, B, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B, A: DeserializeOwned, B: Serialize, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(inner: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { SimpleExtractor { inner, _a: PhantomData, _b: PhantomData, } } }</code> </pre> <br>  El siguiente código se compila correctamente: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Query</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Verification of the ordinary structure. fn my_handler(_: &amp;Context, q: Query) -&gt; String { format!("{} has {} apples.", qb, qa) } let fn_extractor = SimpleExtractor::from(my_handler); // Verification of the closure. let c = 15; let my_closure = |_: &amp;Context, q: Query| -&gt; String { format!("{} has {} apples, but Alice has {}", qb, qa, c) }; let closure_extractor = SimpleExtractor::from(my_closure);</span></span></code> </pre> <br><h2>  Especialización y tipos de marcadores </h2><br>  Ahora tenemos una función con tipos de argumentos parametrizados explícitamente, que se pueden usar en lugar del rasgo `Endpoint`.  Por ejemplo, podemos implementar fácilmente la conversión de SimpleExtractor a RequestHandler.  Aún así, esta no es una solución completa.  Necesitamos distinguir de alguna manera entre los controladores para las solicitudes GET y POST a nivel de tipo (y entre los controladores síncronos y asíncronos).  En esta tarea, los tipos de marcadores nos ayudan. <br><br>  En primer lugar, reescribamos SimpleExtractor para que pueda distinguir entre resultados síncronos y asíncronos.  Al mismo tiempo, implementaremos el rasgo `De` para cada uno de los casos.  Tenga en cuenta que los rasgos se pueden implementar para variantes específicas de estructuras genéricas. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Generic handler for HTTP-requests. pub struct With&lt;Q, I, R, F&gt; { /// A specific handler function. pub handler: F, /// Structure type containing the parameters of the request. _query_type: PhantomData&lt;Q&gt;, /// Type of the request result. _item_type: PhantomData&lt;I&gt;, /// Type of the value returned by the handler. /// Note that this value can differ from the result of the request. _result_type: PhantomData&lt;R&gt;, } // Implementation of an ordinary synchronous returned value. impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, Result&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } } // Implementation of an asynchronous request handler. impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, FutureResult&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</span></span></code> </pre> <br>  Ahora necesitamos declarar la estructura que combinará el manejador de solicitudes con su nombre y tipo: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedWith</span></span></span></span>&lt;Q, I, R, F, K&gt; { <span class="hljs-comment"><span class="hljs-comment">/// The name of the handler. pub name: String, /// The handler with the extracted types. pub inner: With&lt;Q, I, R, F&gt;, /// The type of the handler. _kind: PhantomData&lt;K&gt;, }</span></span></code> </pre> <br>  A continuación, declaramos varias estructuras vacías que actuarán como tipos de marcadores.  Los marcadores nos permitirán implementar para cada controlador su propio código para convertir el controlador en el RequestHandler descrito anteriormente. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// A handler that does not change the state of the service. In HTTP, GET-requests correspond to this // handler. pub struct Immutable; /// A handler that changes the state of the service. In HTTP, POST, PUT, UPDATE and other similar //requests correspond to this handler, but for the current case POST will suffice. pub struct Mutable;</span></span></code> </pre> <br>  Ahora podemos definir cuatro implementaciones diferentes del rasgo `De` para todas las combinaciones de parámetros de plantilla R y K (el valor devuelto del controlador y el tipo de solicitud). <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Implementation of a synchronous handler of GET requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state(); let future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;Q&gt;| query.into_inner()) .and_then(|query| handler(context, query).map_err(From::from)) .and_then(|value| Ok(HttpResponse::Ok().json(value))) .into_future(); Box::new(future) }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of a synchronous handler of POST requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of an asynchronous handler of GET requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state().clone(); let handler = handler.clone(); Query::from_request(&amp;request, &amp;()) .map(move |query: Query&lt;Q&gt;| query.into_inner()) .into_future() .and_then(move |query| handler(&amp;context, query).map_err(From::from)) .map(|value| HttpResponse::Ok().json(value)) .responder() }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of an asynchronous handler of POST requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } }</span></span></code> </pre> <br><h2>  Fachada para el backend </h2><br>  El paso final es diseñar una fachada que acepte cierres y los agregue al backend correspondiente.  En el caso dado, tenemos un único backend: actix-web.  Sin embargo, existe el potencial de una implementación adicional detrás de la fachada.  Por ejemplo: un generador de especificaciones Swagger. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceApiScope</span></span></span></span> { actix_backend: actix::ApiBuilder, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ServiceApiScope { <span class="hljs-comment"><span class="hljs-comment">/// This method adds an Immutable handler to all backends. pub fn endpoint&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where // Here we list the typical restrictions which we have encountered earlier: Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, // Note that the list of restrictions includes the conversion from NamedWith into RequestHandler // we have implemented earlier. RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Immutable&gt;&gt;, { self.actix_backend.endpoint(name, endpoint); self } /// A similar method for Mutable handlers. pub fn endpoint_mut&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Mutable&gt;&gt;, { self.actix_backend.endpoint_mut(name, endpoint); self }</span></span></code> </pre> <br>  Observe cómo los tipos de los parámetros de solicitud, el tipo del resultado de la solicitud y la sincronía / asincronía del controlador se derivan automáticamente de su firma.  Además, debemos especificar explícitamente el nombre y el tipo de la solicitud. <br><br><h2>  Inconvenientes del enfoque </h2><br>  El enfoque descrito anteriormente, a pesar de ser bastante efectivo, tiene sus inconvenientes.  En particular, los <i>métodos endpoint y endpoint_mut deben considerar las peculiaridades de implementación de backends específicos</i> .  Esta restricción nos impide agregar backends sobre la marcha, aunque esta funcionalidad rara vez es necesaria. <br><br>  Otro problema es que <i>no podemos definir la especialización de un controlador sin argumentos adicionales</i> .  En otras palabras, si escribimos el siguiente código, no se compilará ya que está en conflicto con la implementación genérica existente: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;(), I, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> With&lt;(), I, <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;ServiceApiState) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(handler: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</code> </pre> <br>  Como resultado, las solicitudes que no tienen ningún parámetro aún deben aceptar la cadena JSON nula, que se deserializa en ().  Este problema podría resolverse mediante la especialización en estilo C ++, pero por ahora está disponible solo en la versión nocturna del compilador y no está claro cuándo se convertirá en una característica estable. <br><br>  Del mismo modo, <i>el tipo del valor devuelto no puede ser especializado</i> .  Incluso si la solicitud no implica un cierto tipo de valor devuelto, seguirá pasando JSON con nulo. <br><br>  <i>La decodificación de la consulta de URL en las solicitudes GET también impone algunas restricciones obvias sobre el tipo de parámetros</i> , pero este problema se relaciona más bien con las peculiaridades de la implementación codificada por el servidor. <br><br><h2>  Conclusión </h2><br>  Como se describió anteriormente, hemos implementado una API mejorada, que permite una creación simple y clara de controladores, sin la necesidad de preocuparse por los detalles web.  Estos manejadores pueden funcionar con cualquier backend o incluso con varios backends simultáneamente. <br><br><hr><br><ul><li>  Web: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bitfury.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exonum.com</a> </li><li>  Redes sociales: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Facebook</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LinkedIn</a> </li><li>  I + D: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">investigación y libros blancos</a> </li></ul><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439258/">https://habr.com/ru/post/439258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439242/index.html">Alrededor de Beta en 260 días: cómo aprendimos a escuchar a los usuarios</a></li>
<li><a href="../439244/index.html">FAS recomienda encarecidamente preinstalar el software ruso en teléfonos inteligentes y computadoras portátiles vendidos en la Federación Rusa</a></li>
<li><a href="../439248/index.html">Alan Kay: "¿Podrían los antiguos romanos construir una computadora?"</a></li>
<li><a href="../439252/index.html">6 razones para desarrollar una carrera de TI en Armenia</a></li>
<li><a href="../439254/index.html">Nuestro todo</a></li>
<li><a href="../439260/index.html">El autor de The Witcher seguirá recibiendo una compensación de CD Projekt Red</a></li>
<li><a href="../439262/index.html">Implemente el código directamente en el contenedor acoplable. O cómo no postergar después de cada compromiso</a></li>
<li><a href="../439264/index.html">Cómo gestionar proyectos técnicos complejos sin contratar PM: experiencia de DataLine</a></li>
<li><a href="../439266/index.html">La experiencia de crear un juego para Android solo desde cero y cómo se acreditó a Google Play</a></li>
<li><a href="../439268/index.html">Cómo funcionan juntos la impresión VR, AR y 3D: experiencia de concepto VR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>