<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游뱑 拘勇 游땵 M칠todos gen칠ricos en 칩xido: c칩mo el ex칩n se desplaz칩 del hierro a la web Actix 游 驕좶잺 游녩游낕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El ecosistema de Rust todav칤a est치 creciendo. Como resultado, las nuevas bibliotecas con funcionalidad mejorada se lanzan con frecuencia a la comunida...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M칠todos gen칠ricos en 칩xido: c칩mo el ex칩n se desplaz칩 del hierro a la web Actix</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitfury/blog/439258/">  El ecosistema de Rust todav칤a est치 creciendo.  Como resultado, las nuevas bibliotecas con funcionalidad mejorada se lanzan con frecuencia a la comunidad de desarrolladores, mientras que las bibliotecas m치s antiguas se vuelven obsoletas.  Cuando inicialmente dise침amos Exonum, utilizamos el framework web Iron.  En este art칤culo, describimos c칩mo portamos el framework Exonum a actix-web usando programaci칩n gen칠rica. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/tc/vv/ye/tcvvye1qopj5cqsfv3rxp9-_sly.png"></a> <a name="habracut"></a><br><br><h2>  Exonum sobre hierro </h2><br>  En la plataforma Exonum, el marco de hierro se utiliz칩 sin abstracciones.  Instalamos manejadores para ciertos recursos y obtuvimos par치metros de solicitud al analizar URL usando m칠todos auxiliares;  el resultado se devolvi칩 simplemente en forma de cadena. <br><br>  El proceso se parec칤a (aproximadamente) al siguiente: <br><br><pre><code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_blocks_response</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, router: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Router) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> blocks = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |req: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Request| -&gt; IronResult&lt;Response&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> count: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.required_param(req, <span class="hljs-string"><span class="hljs-string">"count"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> latest: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>&gt; = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"latest"</span></span>)?; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> skip_empty_blocks: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.optional_param(req, <span class="hljs-string"><span class="hljs-string">"skip_empty_blocks"</span></span>)? .unwrap_or(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> info = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.blocks(count, latest.map(Height), skip_empty_blocks)?; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ok_response(&amp;::serde_json::to_value(info).unwrap()) }; router.get(<span class="hljs-string"><span class="hljs-string">"/v1/blocks"</span></span>, blocks, <span class="hljs-string"><span class="hljs-string">"blocks"</span></span>); }</code> </pre> <br>  Adem치s, utilizamos algunos complementos de middleware en forma de encabezados CORS.  Utilizamos mount para fusionar todos los controladores en una sola API. <br><br><h2>  Nuestra decisi칩n de alejarnos del hierro </h2><br>  Iron era una buena biblioteca, con muchos complementos.  Sin embargo, fue escrito en los d칤as en que no exist칤an proyectos como futuros y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tokio</a> . <br><br>  La arquitectura de Iron implica el procesamiento de solicitudes sincr칩nicas, que pueden verse f치cilmente afectadas por una gran cantidad de conexiones abiertas simult치neamente.  Para ser escalable, Iron necesitaba volverse as칤ncrono, lo que implicar칤a repensar y reescribir todo el marco.  Como resultado, hemos visto una desviaci칩n gradual del uso de Iron por parte de ingenieros de software. <br><br><h2>  Por qu칠 elegimos Actix-Web </h2><br>  Actix-web es un marco popular que ocupa un lugar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">destacado</a> en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">puntos de referencia de TechEmpower</a> .  Tiene una comunidad de desarrolladores activa, a diferencia de Iron, y tiene una API bien dise침ada y una implementaci칩n de alta calidad basada en el marco del actor actix.  Las solicitudes son procesadas asincr칩nicamente por el grupo de subprocesos;  si la solicitud procesa el p치nico, el actor se reinicia autom치ticamente. <br><br>  Anteriormente, se plante칩 la preocupaci칩n de que actix-web conten칤a una gran cantidad de c칩digo inseguro.  Sin embargo, la cantidad de c칩digo inseguro se redujo significativamente cuando el marco se reescribi칩 en un lenguaje de programaci칩n seguro: Rust.  Los ingenieros de Bitfury han revisado este c칩digo ellos mismos y se sienten seguros de su estabilidad a largo plazo. <br><br>  Para el marco Exonum, el cambio a actix resolvi칩 el problema de la estabilidad de la operaci칩n.  El marco de Iron podr칤a fallar si hubiera una gran cantidad de conexiones.  Tambi칠n hemos descubierto que la API actix-web es m치s simple, m치s productiva y m치s unificada.  Estamos seguros de que a los usuarios y desarrolladores les resultar치 m치s f치cil usar la interfaz de programaci칩n Exonum, que ahora puede operar m치s r치pido gracias al dise침o web actix. <br><br><h2>  Lo que requerimos de un marco web </h2><br>  Durante este proceso, nos dimos cuenta de que era importante para nosotros no simplemente cambiar los marcos, sino tambi칠n dise침ar una nueva arquitectura API independiente de cualquier marco web espec칤fico.  Dicha arquitectura permitir칤a crear controladores, con poca o ninguna preocupaci칩n por los detalles web, y transferirlos a cualquier backend.  Esta concepci칩n puede implementarse escribiendo una interfaz que aplique tipos y rasgos b치sicos. <br><br>  Para comprender c칩mo debe verse esta interfaz, definamos qu칠 es realmente cualquier API HTTP: <br><br><ul><li>  Las solicitudes son hechas exclusivamente por clientes;  el servidor solo responde a ellas (el servidor no inicia solicitudes). </li><li>  Solicita leer datos o cambiar datos. </li><li>  Como resultado del procesamiento de la solicitud, el servidor devuelve una respuesta, que contiene los datos requeridos, en caso de 칠xito;  o informaci칩n sobre el error, en caso de falla. </li></ul><br>  Si vamos a analizar todas las capas de abstracci칩n, resulta que cualquier solicitud HTTP es solo una llamada de funci칩n: <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span></span>(context: &amp;ServiceContext, query: Query) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;Response, ServiceError&gt;</code> </pre> <br>  Todo lo dem치s puede considerarse una extensi칩n de esta entidad b치sica.  Por lo tanto, para ser independientes de una implementaci칩n espec칤fica de un marco web, necesitamos escribir controladores en un estilo similar al ejemplo anterior. <br><br><h2>  Rasgo `Punto final` para el procesamiento gen칠rico de solicitudes HTTP </h2><br>  El enfoque m치s simple y directo ser칤a declarar el rasgo `Endpoint`, que describe las implementaciones de solicitudes espec칤ficas: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// A trait describing GET request handlers. It should be possible to call each of the handlers from any freed // thread. This requirement imposes certain restrictions on the trait. Parameters and request results are // configured using associated types. trait Endpoint: Sync + Send + 'static { type Request: DeserializeOwned + 'static; type Response: Serialize + 'static; fn handle(&amp;self, context: &amp;Context, request: Self::Request) -&gt; Result&lt;Self::Response, io::Error&gt;; }</span></span></code> </pre> <br>  Ahora necesitamos implementar este controlador en un marco espec칤fico.  Por ejemplo, en actix-web tiene el siguiente aspecto: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Response type in actix-web. Note that they are asynchronous, even though `Endpoint` assumes that // processing is synchronous. type FutureResponse = actix_web::FutureResponse&lt;HttpResponse, actix_web::Error&gt;; // A raw request handler for actix-web. This is what the framework ultimately works with. The handler // receives parameters from an arbitrary context, through which the request parameters are passed. type RawHandler = dyn Fn(HttpRequest&lt;Context&gt;) -&gt; FutureResponse + 'static + Send + Sync; // For convenience, let's put everything we need from the handler into a single structure. #[derive(Clone)] struct RequestHandler { /// The name of the resource. pub name: String, /// HTTP method. pub method: actix_web::http::Method, /// The raw handler. Note that it will be used from multiple threads. pub inner: Arc&lt;RawHandler&gt;, }</span></span></code> </pre> <br>  Podemos usar estructuras para pasar par치metros de solicitud a trav칠s del contexto.  Actix-web puede deserializar par치metros autom치ticamente usando serde.  Por ejemplo, a = 15 &amp; b = hola se deserializa en una estructura como esta: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleQuery</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br>  Esta funcionalidad de deserializaci칩n concuerda bien con el tipo asociado Solicitud del rasgo `Punto final`. <br><br>  A continuaci칩n, ideemos un adaptador que envuelva una implementaci칩n espec칤fica de 'Endpoint' en un RequestHandler para actix-web.  Preste atenci칩n al hecho de que al hacerlo, la informaci칩n sobre los tipos de Solicitud y Respuesta desaparece.  Esta t칠cnica se denomina borrado de tipo: transforma el env칤o est치tico en uno din치mico. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> RequestHandler { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_endpoint</span></span></span></span>&lt;E: Endpoint&gt;(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, endpoint: E) -&gt; RequestHandler { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |request: HttpRequest&lt;Context&gt;| -&gt; FutureResponse { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> context = request.state(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;E::Request&gt;| query.into_inner()) .and_then(|query| endpoint.handle(context, query).map_err(<span class="hljs-built_in"><span class="hljs-built_in">From</span></span>::from)) .and_then(|value| <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(HttpResponse::<span class="hljs-literal"><span class="hljs-literal">Ok</span></span>().json(value))) .into_future(); <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(future) }; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { name: name.to_owned(), method: actix_web::http::Method::GET, inner: Arc::from(index) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Arc&lt;RawHandler&gt;, } } }</code> </pre> <br>  En esta etapa, ser칤a suficiente agregar controladores para las solicitudes POST, ya que hemos creado un rasgo que es independiente de los detalles de implementaci칩n.  Sin embargo, descubrimos que esta soluci칩n no era lo suficientemente avanzada. <br><br><h2>  Los inconvenientes del rasgo `Punto final` </h2><br>  Se genera una gran cantidad de c칩digo auxiliar cuando se escribe un controlador: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// A structure with the context of the handler. struct ElementCountEndpoint { elements: Rc&lt;RefCell&lt;Vec&lt;Something&gt;&gt;&gt;, } // Implementation of the `Endpoint` trait. impl Endpoint for ElementCountEndpoint { type Request = (); type Result = usize; fn handle(&amp;self, context: &amp;Context, _request: ()) -&gt; Result&lt;usize, io::Error&gt; { Ok(self.elements.borrow().len()) } } // Installation of the handler in the backend. let endpoint = ElementCountEndpoint::new(elements.clone()); let handler = RequestHandler::from_endpoint("/v1/element_count", endpoint); actix_backend.endpoint(handler);</span></span></code> </pre> <br>  Idealmente, necesitamos poder pasar un cierre simple como manejador, reduciendo as칤 significativamente la cantidad de ruido sint치ctico. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> elements = elements.clone(); actix_backend.endpoint(<span class="hljs-string"><span class="hljs-string">"/v1/elements_count"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(elements.borrow().len()) });</code> </pre> <br>  A continuaci칩n discutiremos c칩mo se puede hacer esto. <br><br><h2>  Inmersi칩n ligera en programaci칩n gen칠rica </h2><br>  Necesitamos agregar la capacidad de generar autom치ticamente un adaptador que implemente el rasgo `Endpoint` con los tipos asociados correctos.  La entrada consistir치 solo en un cierre con un controlador de solicitud HTTP. <br><br>  Los argumentos y el resultado del cierre pueden tener diferentes tipos, por lo que tenemos que trabajar con m칠todos de sobrecarga aqu칤.  Rust no admite la sobrecarga directamente, pero permite que se emule usando los rasgos 'Into' y 'From'. <br><br>  Adem치s, el tipo devuelto del valor de cierre no tiene que coincidir con el valor devuelto de la implementaci칩n `Endpoint`.  Para manipular este tipo, debe extraerse del tipo del cierre recibido. <br><br><h2>  Obteniendo tipos del rasgo `Fn` </h2><br>  En Rust, cada cierre tiene su propio tipo 칰nico, que no se puede indicar expl칤citamente en el programa.  Para manipulaciones con cierres, utilizamos el rasgo `Fn`.  El rasgo contiene la firma de la funci칩n con los tipos de argumentos y del valor devuelto, sin embargo, no es f치cil recuperar estos elementos por separado. <br><br>  La idea principal es utilizar una estructura auxiliar de la siguiente forma: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Simplified example of extracting types from an F closure: Fn(A) -&gt; B. struct SimpleExtractor&lt;A, B, F&gt; { // The original function. inner: F, _a: PhantomData&lt;A&gt;, _b: PhantomData&lt;B&gt;, }</span></span></code> </pre> <br>  Tenemos que usar PhantomData, ya que Rust requiere que todos los par치metros gen칠ricos est칠n indicados en la definici칩n de la estructura.  Sin embargo, el tipo de cierre o funci칩n F en s칤 no es gen칠rico (aunque implementa un rasgo gen칠rico `Fn`).  Los par치metros de tipo A y B no se utilizan directamente en 칠l. <br><br>  Es esta restricci칩n del sistema de tipo Rust lo que nos impide aplicar una estrategia m치s simple al implementar el rasgo `Endpoint` directamente para los cierres: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Request</span></span></span></span> = A; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span></span> = B; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, context: &amp;Context, request: A) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;B, io::Error&gt; { <span class="hljs-comment"><span class="hljs-comment">// ... } }</span></span></code> </pre> <br>  En el caso anterior, el compilador devuelve un error: <br><br><pre> <code class="rust hljs">error[E0207]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span> `A` is not constrained by the <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">or</span></span></span></span> predicates --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; Endpoint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> F <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B { | ^ unconstrained <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parameter</span></span></span></span></code> </pre> <br>  La estructura auxiliar SimpleExtractor permite describir la conversi칩n de `From`.  Esta conversi칩n nos permite guardar cualquier funci칩n y extraer los tipos de sus argumentos: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;A, B, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SimpleExtractor&lt;A, B, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;Context, A) -&gt; B, A: DeserializeOwned, B: Serialize, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(inner: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { SimpleExtractor { inner, _a: PhantomData, _b: PhantomData, } } }</code> </pre> <br>  El siguiente c칩digo se compila correctamente: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Query</span></span></span></span> { a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, b: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Verification of the ordinary structure. fn my_handler(_: &amp;Context, q: Query) -&gt; String { format!("{} has {} apples.", qb, qa) } let fn_extractor = SimpleExtractor::from(my_handler); // Verification of the closure. let c = 15; let my_closure = |_: &amp;Context, q: Query| -&gt; String { format!("{} has {} apples, but Alice has {}", qb, qa, c) }; let closure_extractor = SimpleExtractor::from(my_closure);</span></span></code> </pre> <br><h2>  Especializaci칩n y tipos de marcadores </h2><br>  Ahora tenemos una funci칩n con tipos de argumentos parametrizados expl칤citamente, que se pueden usar en lugar del rasgo `Endpoint`.  Por ejemplo, podemos implementar f치cilmente la conversi칩n de SimpleExtractor a RequestHandler.  A칰n as칤, esta no es una soluci칩n completa.  Necesitamos distinguir de alguna manera entre los controladores para las solicitudes GET y POST a nivel de tipo (y entre los controladores s칤ncronos y as칤ncronos).  En esta tarea, los tipos de marcadores nos ayudan. <br><br>  En primer lugar, reescribamos SimpleExtractor para que pueda distinguir entre resultados s칤ncronos y as칤ncronos.  Al mismo tiempo, implementaremos el rasgo `De` para cada uno de los casos.  Tenga en cuenta que los rasgos se pueden implementar para variantes espec칤ficas de estructuras gen칠ricas. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Generic handler for HTTP-requests. pub struct With&lt;Q, I, R, F&gt; { /// A specific handler function. pub handler: F, /// Structure type containing the parameters of the request. _query_type: PhantomData&lt;Q&gt;, /// Type of the request result. _item_type: PhantomData&lt;I&gt;, /// Type of the value returned by the handler. /// Note that this value can differ from the result of the request. _result_type: PhantomData&lt;R&gt;, } // Implementation of an ordinary synchronous returned value. impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, Result&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } } // Implementation of an asynchronous request handler. impl&lt;Q, I, F&gt; From&lt;F&gt; for With&lt;Q, I, FutureResult&lt;I&gt;, F&gt; where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt;, { fn from(handler: F) -&gt; Self { Self { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</span></span></code> </pre> <br>  Ahora necesitamos declarar la estructura que combinar치 el manejador de solicitudes con su nombre y tipo: <br><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Debug)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamedWith</span></span></span></span>&lt;Q, I, R, F, K&gt; { <span class="hljs-comment"><span class="hljs-comment">/// The name of the handler. pub name: String, /// The handler with the extracted types. pub inner: With&lt;Q, I, R, F&gt;, /// The type of the handler. _kind: PhantomData&lt;K&gt;, }</span></span></code> </pre> <br>  A continuaci칩n, declaramos varias estructuras vac칤as que actuar치n como tipos de marcadores.  Los marcadores nos permitir치n implementar para cada controlador su propio c칩digo para convertir el controlador en el RequestHandler descrito anteriormente. <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// A handler that does not change the state of the service. In HTTP, GET-requests correspond to this // handler. pub struct Immutable; /// A handler that changes the state of the service. In HTTP, POST, PUT, UPDATE and other similar //requests correspond to this handler, but for the current case POST will suffice. pub struct Mutable;</span></span></code> </pre> <br>  Ahora podemos definir cuatro implementaciones diferentes del rasgo `De` para todas las combinaciones de par치metros de plantilla R y K (el valor devuelto del controlador y el tipo de solicitud). <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Implementation of a synchronous handler of GET requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state(); let future = Query::from_request(&amp;request, &amp;()) .map(|query: Query&lt;Q&gt;| query.into_inner()) .and_then(|query| handler(context, query).map_err(From::from)) .and_then(|value| Ok(HttpResponse::Ok().json(value))) .into_future(); Box::new(future) }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of a synchronous handler of POST requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; Result&lt;I&gt; + 'static + Send + Sync + Clone, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, Result&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of an asynchronous handler of GET requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Immutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let context = request.state().clone(); let handler = handler.clone(); Query::from_request(&amp;request, &amp;()) .map(move |query: Query&lt;Q&gt;| query.into_inner()) .into_future() .and_then(move |query| handler(&amp;context, query).map_err(From::from)) .map(|value| HttpResponse::Ok().json(value)) .responder() }; Self { name: f.name, method: actix_web::http::Method::GET, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } } // Implementation of an asynchronous handler of POST requests. impl&lt;Q, I, F&gt; From&lt;NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;&gt; for RequestHandler where F: Fn(&amp;ServiceApiState, Q) -&gt; FutureResult&lt;I&gt; + 'static + Clone + Send + Sync, Q: DeserializeOwned + 'static, I: Serialize + 'static, { fn from(f: NamedWith&lt;Q, I, FutureResult&lt;I&gt;, F, Mutable&gt;) -&gt; Self { let handler = f.inner.handler; let index = move |request: HttpRequest| -&gt; FutureResponse { let handler = handler.clone(); let context = request.state().clone(); request .json() .from_err() .and_then(move |query: Q| { handler(&amp;context, query) .map(|value| HttpResponse::Ok().json(value)) .map_err(From::from) }) .responder() }; Self { name: f.name, method: actix_web::http::Method::POST, inner: Arc::from(index) as Arc&lt;RawHandler&gt;, } } }</span></span></code> </pre> <br><h2>  Fachada para el backend </h2><br>  El paso final es dise침ar una fachada que acepte cierres y los agregue al backend correspondiente.  En el caso dado, tenemos un 칰nico backend: actix-web.  Sin embargo, existe el potencial de una implementaci칩n adicional detr치s de la fachada.  Por ejemplo: un generador de especificaciones Swagger. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceApiScope</span></span></span></span> { actix_backend: actix::ApiBuilder, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> ServiceApiScope { <span class="hljs-comment"><span class="hljs-comment">/// This method adds an Immutable handler to all backends. pub fn endpoint&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where // Here we list the typical restrictions which we have encountered earlier: Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, // Note that the list of restrictions includes the conversion from NamedWith into RequestHandler // we have implemented earlier. RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Immutable&gt;&gt;, { self.actix_backend.endpoint(name, endpoint); self } /// A similar method for Mutable handlers. pub fn endpoint_mut&lt;Q, I, R, F, E&gt;(&amp;mut self, name: &amp;'static str, endpoint: E) -&gt; &amp;mut Self where Q: DeserializeOwned + 'static, I: Serialize + 'static, F: Fn(&amp;ServiceApiState, Q) -&gt; R + 'static + Clone, E: Into&lt;With&lt;Q, I, R, F&gt;&gt;, RequestHandler: From&lt;NamedWith&lt;Q, I, R, F, Mutable&gt;&gt;, { self.actix_backend.endpoint_mut(name, endpoint); self }</span></span></code> </pre> <br>  Observe c칩mo los tipos de los par치metros de solicitud, el tipo del resultado de la solicitud y la sincron칤a / asincron칤a del controlador se derivan autom치ticamente de su firma.  Adem치s, debemos especificar expl칤citamente el nombre y el tipo de la solicitud. <br><br><h2>  Inconvenientes del enfoque </h2><br>  El enfoque descrito anteriormente, a pesar de ser bastante efectivo, tiene sus inconvenientes.  En particular, los <i>m칠todos endpoint y endpoint_mut deben considerar las peculiaridades de implementaci칩n de backends espec칤ficos</i> .  Esta restricci칩n nos impide agregar backends sobre la marcha, aunque esta funcionalidad rara vez es necesaria. <br><br>  Otro problema es que <i>no podemos definir la especializaci칩n de un controlador sin argumentos adicionales</i> .  En otras palabras, si escribimos el siguiente c칩digo, no se compilar치 ya que est치 en conflicto con la implementaci칩n gen칠rica existente: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;(), I, F&gt; <span class="hljs-built_in"><span class="hljs-built_in">From</span></span>&lt;F&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> With&lt;(), I, <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, F&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;ServiceApiState) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;I&gt;, { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from</span></span></span></span>(handler: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { handler, _query_type: PhantomData, _item_type: PhantomData, _result_type: PhantomData, } } }</code> </pre> <br>  Como resultado, las solicitudes que no tienen ning칰n par치metro a칰n deben aceptar la cadena JSON nula, que se deserializa en ().  Este problema podr칤a resolverse mediante la especializaci칩n en estilo C ++, pero por ahora est치 disponible solo en la versi칩n nocturna del compilador y no est치 claro cu치ndo se convertir치 en una caracter칤stica estable. <br><br>  Del mismo modo, <i>el tipo del valor devuelto no puede ser especializado</i> .  Incluso si la solicitud no implica un cierto tipo de valor devuelto, seguir치 pasando JSON con nulo. <br><br>  <i>La decodificaci칩n de la consulta de URL en las solicitudes GET tambi칠n impone algunas restricciones obvias sobre el tipo de par치metros</i> , pero este problema se relaciona m치s bien con las peculiaridades de la implementaci칩n codificada por el servidor. <br><br><h2>  Conclusi칩n </h2><br>  Como se describi칩 anteriormente, hemos implementado una API mejorada, que permite una creaci칩n simple y clara de controladores, sin la necesidad de preocuparse por los detalles web.  Estos manejadores pueden funcionar con cualquier backend o incluso con varios backends simult치neamente. <br><br><hr><br><ul><li>  Web: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bitfury.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Exonum.com</a> </li><li>  Redes sociales: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Facebook</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LinkedIn</a> </li><li>  I + D: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">investigaci칩n y libros blancos</a> </li></ul><br><hr></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439258/">https://habr.com/ru/post/439258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439242/index.html">Alrededor de Beta en 260 d칤as: c칩mo aprendimos a escuchar a los usuarios</a></li>
<li><a href="../439244/index.html">FAS recomienda encarecidamente preinstalar el software ruso en tel칠fonos inteligentes y computadoras port치tiles vendidos en la Federaci칩n Rusa</a></li>
<li><a href="../439248/index.html">Alan Kay: "쯇odr칤an los antiguos romanos construir una computadora?"</a></li>
<li><a href="../439252/index.html">6 razones para desarrollar una carrera de TI en Armenia</a></li>
<li><a href="../439254/index.html">Nuestro todo</a></li>
<li><a href="../439260/index.html">El autor de The Witcher seguir치 recibiendo una compensaci칩n de CD Projekt Red</a></li>
<li><a href="../439262/index.html">Implemente el c칩digo directamente en el contenedor acoplable. O c칩mo no postergar despu칠s de cada compromiso</a></li>
<li><a href="../439264/index.html">C칩mo gestionar proyectos t칠cnicos complejos sin contratar PM: experiencia de DataLine</a></li>
<li><a href="../439266/index.html">La experiencia de crear un juego para Android solo desde cero y c칩mo se acredit칩 a Google Play</a></li>
<li><a href="../439268/index.html">C칩mo funcionan juntos la impresi칩n VR, AR y 3D: experiencia de concepto VR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>