<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👧 🙅🏽 🌞 返回 🔈 ♌️ 🐔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="现在，每个人都知道使用GOTO运算符不仅不好，而且很糟糕。 关于它的使用的争论结束于20世纪80年代，大多数现代编程语言都将其排除在外。 但是，作为一种真正的邪恶，他成功地伪装成自己，并在21世纪以例外的名义复活。 


 一方面，在现代编程语言中，异常是一个相当简单的概念。 另一方面，它们经常被错...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>返回</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484840/"><p>现在，每个人都知道使用GOTO运算符不仅不好，而且很糟糕。 关于它的使用的争论结束于20世纪80年代，大多数现代编程语言都将其排除在外。 但是，作为一种真正的邪恶，他成功地伪装成自己，并在21世纪以例外的名义复活。 </p><a name="habracut"></a><br><p> 一方面，在现代编程语言中，异常是一个相当简单的概念。 另一方面，它们经常被错误地使用。 有一个简单而众所周知的规则-例外仅用于处理损坏。 对“故障”概念的解释过于宽松，导致使用GOTO的所有问题。 </p><br><h2 id="teoreticheskiy-primer"> 理论实例 </h2><br><p> 故障和负面业务场景之间的区别可以在登录窗口中以非常简单的用例清楚地看到： </p><br><ol><li> 用户输入登录名/密码。 </li><li> 用户单击“登录”按钮。 </li><li> 客户端应用程序将请求发送到服务器。 </li><li> 服务器成功检查了用户名/密码（将相应对的存在视为成功）。 </li><li> 服务器将信息发送给客户端，表明身份验证已成功，并发送到转换页面的链接。 </li><li> 客户端转到指定页面。 </li></ol><br><p> 还有一个负面的延伸： </p><br><p>  4.1。 服务器找不到相应的登录名/密码对，并向客户端发送有关此信息的通知。 </p><br><p> 考虑到场景4.1是一个“问题”，因此必须使用异常来实现它是一个相当常见的错误。 实际上并非如此。 登录名和密码不匹配是脚本的业务逻辑所提供的标准用户体验的一部分。 我们的商业客户期望这一发展。 因此，这不是故障，您不能在此处使用异常。 </p><br><p> 故障包括：客户端与北方之间的连接断开，DBMS无法访问，数据库中的方案不正确。 还有超过一百万个原因破坏了我们的应用程序，并且与用户的业务逻辑无关。 </p><br><p> 在我参与的开发项目中，有一个更复杂的登录逻辑。 通过连续3次输入错误的密码，该用户被暂时阻止了15分钟。 用户连续获得3次临时锁定后，便收到了永久锁定。 根据用户类型，还有其他规则。 异常的实现使得引入新规则变得极为困难。 </p><br><p> 考虑这个例子会很有趣，但是它太大了，而且不是很直观。 在异常情况下，如何将代码与业务逻辑混淆变得清晰明了，我将在另一个示例中向您展示。 </p><br><h2 id="primer-zagruzka-svoystv"> 示例加载属性 </h2><br><p> 尝试看一下这段代码，清楚地了解它的作用。 具有相当简单的逻辑的过程并不大。 拥有良好的编程风格，对其本质的理解不应超过2-3分钟（我不记得我完全理解此代码所花的时间，但绝对超过15分钟）。 </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkspaceProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ Properties loadedProperties = readPropertiesFromFile(WORK_PROPERTIES_PATH, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">//These mappings will replace any mappings that this hashtable had for any of the //keys currently in the specified map. getProperties().putAll( loadedProperties ); //     loadedProperties = readPropertiesFromFile(MY_WORK_PROPERTIES_PATH, false); if (loadedProperties != null){ getProperties().putAll( loadedProperties ); } System.out.println("Loaded properties:" + getProperties()); } /** *  ,    . * @param filepath * @param throwIfNotFound -  FileNotFoundException,     * @return    null,      !throwIfNotFound * @throws FileNotFoundException throwIfNotFound        * @throws IOException     */ private Properties readPropertiesFromFile(String filepath, boolean throwIfNotExists){ Properties loadedProperties = new Properties(); System.out.println("Try loading workspace properties" + filepath); InputStream is = null; InputStreamReader isr = null; try{ int loadingTryLeft = 3; String relativePath = ""; while (loadingTryLeft &gt; 0){ try{ File file = new File(relativePath + filepath); is = new FileInputStream(file); isr = new InputStreamReader( is, "UTF-8"); loadedProperties.load(isr); loadingTryLeft = 0; } catch( FileNotFoundException e) { loadingTryLeft -= 1; if (loadingTryLeft &gt; 0) relativePath += "../"; else throw e; } finally { if (is != null) is.close(); if (isr != null) isr.close(); } } System.out.println("Found file " + filepath); } catch( FileNotFoundException e) { System.out.println("File not found " + filepath); if (throwIfNotExists) throw new RuntimeException("Can`t load workspace properties." + filepath + " not found", e ); }catch (IOException e){ throw new RuntimeException("Can`t read " + filepath, e); } return loadedProperties; }</span></span></code> </pre> <br><p> 因此，让我们揭示秘密-这里发生了什么。 从两个文件中<code>WORK_PROPERTIES</code>的属性-必需的<code>WORK_PROPERTIES</code>和附加的<code>MY_WORK_PROPERTIES</code> ，添加到共享属性存储中。 有一个细微差别-我们不知道特定属性文件的确切位置-它可以位于当前目录和祖先目录中（最多三个级别）。 </p><br><p> 至少有两件事令人困惑： <code>throwIfNotExists</code>参数和<code>catch FileNotFoundException</code>的大逻辑块。 所有这些不透明的暗示-异常用于实现业务逻辑（但是如何在一种情况下解释抛出异常是失败的，而在另一种情况下则不能解释）？ </p><br><h2 id="delaem-pravilnyy-kontrakt"> 订立正确的合同 </h2><br><p> 首先， <code>throwIfNotExists</code>处理<code>throwIfNotExists</code> 。 在处理异常时，了解用例方面需要在何处进行处理非常重要。 在这种情况下，很明显<code>readPropertiesFromFile</code>方法<code>readPropertiesFromFile</code>无法确定缺少文件的时间是“不好”还是何时不存在。 这样的决定是在调用时做出的。 注释表明，我们决定该文件是否应存在。 但实际上，我们对文件本身而不是文件设置感兴趣。 不幸的是，这并非源于代码。 </p><br><p> 我们修复了以下两个缺点： </p><br><pre> <code class="java hljs">Properties loadedProperties = readPropertiesFromFile(WORK_PROPERTIES_PATH); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadedProperties.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t load workspace properties"</span></span>); } loadedProperties = readPropertiesFromFile(MY_WORK_PROPERTIES_PATH); getProperties().putAll( loadedProperties );</code> </pre> <br><p> 现在已经清楚地显示了语义- <br> 必须指定<code>MY_WORK_PROPERTIES</code> ，但不能指定<code>MY_WORK_PROPERTIES</code> 。 另外，在重构时，我注意到<code>readPropertiesFromFile</code>永远不会返回<code>null</code> ，因此在读取<code>MY_WORK_PROPERTIES</code>时会利用<code>MY_WORK_PROPERTIES</code> 。 </p><br><h2 id="proveryaem-ne-lomaya"> 我们检查不间断 </h2><br><p> 先前的重构也影响了实现，但影响不大。 我刚刚删除了<code>throwIfNotExists</code>处理<code>throwIfNotExists</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (throwIfNotExists) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(…);</code> </pre> <br><p> 在仔细研究了实现之后，我们开始理解代码作者搜索文件的逻辑。 首先，检查文件是否在当前目录中，如果找不到，则在更高级别进行检查等。 即 显然，该算法提供了文件的缺失。 在这种情况下，检查是使用异常完成的。 即 违反了该原则-异常不是被视为“某些东西已损坏”，而是被视为业务逻辑的一部分。 </p><br><p> 有一个用于检查文件可用性以读取<code>File.canRead()</code> 。 使用它，您可以在<code>catch</code>摆脱业务逻辑<code>catch</code> </p><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader( is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); loadingTryLeft = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( FileNotFoundException e) { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) is.close(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isr != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) isr.close(); } }</code> </pre> <br><p> 更改代码，我们得到以下信息： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPropertiesFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String filepath)</span></span></span><span class="hljs-function"> </span></span>{ Properties loadedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Try loading workspace properties"</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadingTryLeft = <span class="hljs-number"><span class="hljs-number">3</span></span>; String relativePath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.canRead()) { InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; InputStreamReader isr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); loadingTryLeft = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) is.close(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isr != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) isr.close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(); } } } System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + filepath); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (FileNotFoundException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"File not found "</span></span> + filepath); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t read "</span></span> + filepath, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; }</code> </pre> <br><p> 我还将变量（ <code>is</code> ， <code>isr</code> ）的级别降低到了允许的最小值。 </p><br><p> 这种简单的重构极大地提高了代码的可读性。 代码直接显示算法（如果文件存在，那么我们将读取它，否则我们将减少尝试次数并查看上面的目录）。 </p><br><h2 id="vyyavlyaem-goto"> 显示GOTO </h2><br><p> 如果未找到文件，请详细考虑在某种情况下会发生什么情况： </p><br><pre> <code class="java hljs">} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(); } }</code> </pre> <br><p> 可以看出，这里的异常用于中断执行周期并实际执行GOTO功能。 </p><br><p> 对于怀疑者，我们将进行另一种更改。 与其以<code>loadingTryLeft = 0</code>的形式使用小拐杖（拐杖，因为实际上成功的尝试不会<code>loadingTryLeft = 0</code>剩余的尝试次数），我们明确指出读取文件会导致函数退出（不要忘记编写消息）： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> {</code> </pre> <br><p> 这使我们可以将<code>while (loadingTryLeft &gt; 0)</code>条件<code>while (loadingTryLeft &gt; 0)</code>替换为<code>while(true)</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadingTryLeft = <span class="hljs-number"><span class="hljs-number">3</span></span>; String relativePath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.canRead()) { InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; InputStreamReader isr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) is.close(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isr != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) isr.close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(); <span class="hljs-comment"><span class="hljs-comment">// GOTO: FFN } } } } catch (FileNotFoundException e) { // LABEL: FFN System.out.println("File not found " + filepath); } catch (IOException e) { throw new RuntimeException("Can`t read " + filepath, e); }</span></span></code> </pre> <br><p> 为了摆脱明显的臭味， <code>throw new FileNotFoundException</code> ，您需要记住函数协定。 无论如何，该函数都会返回一组属性，如果他们无法读取文件，我们将其返回为空。 因此，没有理由引发异常并捕获它。 通常的<code>while (loadingTryLeft &gt; 0)</code>条件<code>while (loadingTryLeft &gt; 0)</code>足够了： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPropertiesFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String filepath)</span></span></span><span class="hljs-function"> </span></span>{ Properties loadedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Try loading workspace properties"</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadingTryLeft = <span class="hljs-number"><span class="hljs-number">3</span></span>; String relativePath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.canRead()) { InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; InputStreamReader isr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); loadedProperties.load(isr); System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) is.close(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isr != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) isr.close(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; } } System.out.println(<span class="hljs-string"><span class="hljs-string">"file not found"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t read "</span></span> + filepath, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; }</code> </pre> <br><p> 原则上，从正确的工作观点出发（例外情况），一切都在这里。 如果出现IOException问题，是否有必要引发RuntimeException值得怀疑，但为了兼容性，我们还是将其保留。 </p><br><h2 id="navodim-losk"> 带来光泽 </h2><br><p> 还剩下一些小事情，我们可以使代码更加灵活和易于理解： </p><br><ul><li>  readPropertiesFromFile方法名称公开了其实现（顺便说一句，并抛出FileNotFoundException）。 最好称其为中性和简洁-loadProperties（...） </li><li> 该方法同时搜索和读取。 对我来说，这是两种不同的职责，可以用不同的方法来划分。 </li><li> 该代码最初是在Java 6下编写的，但现在在Java 7中使用。这允许使用可关闭的资源。 </li><li> 从经验中我知道，当显示有关已找到或未找到文件的信息时，最好使用文件的完整路径，而不是相对路径。 </li><li> <code>if (loadingTryLeft &gt; 0) relativePath += "../";</code>  -如果您仔细查看代码，则可以看到-此检查是不必要的，因为 如果搜索限制已用尽，则无论如何都不会使用新值。 如果代码中有多余的东西，那么这是应该删除的垃圾。 </li></ul><br><p> 最终版本的源代码： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkspaceProperties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defaultInstance != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(); Properties loadedProperties = readPropertiesFromFile(WORK_PROPERTIES_PATH); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (loadedProperties.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t load workspace properties"</span></span>); } getProperties().putAll(loadedProperties); loadedProperties = readPropertiesFromFile(MY_WORK_PROPERTIES_PATH); getProperties().putAll(loadedProperties); System.out.println(<span class="hljs-string"><span class="hljs-string">"Loaded properties:"</span></span> + getProperties()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPropertiesFromFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String filepath)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Try loading workspace properties"</span></span> + filepath); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadingTryLeft = <span class="hljs-number"><span class="hljs-number">3</span></span>; String relativePath = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (loadingTryLeft &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { File file = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(relativePath + filepath); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (file.canRead()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> read(file); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { relativePath += <span class="hljs-string"><span class="hljs-string">"../"</span></span>; loadingTryLeft -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } System.out.println(<span class="hljs-string"><span class="hljs-string">"file not found"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RuntimeException(<span class="hljs-string"><span class="hljs-string">"Can`t read "</span></span> + filepath, e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Properties </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (InputStream is = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(file); InputStreamReader isr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(is, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>)) { Properties loadedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Properties(); loadedProperties.load(isr); System.out.println(<span class="hljs-string"><span class="hljs-string">"Found file "</span></span> + file.getAbsolutePath()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadedProperties; } }</code> </pre> <br><h2 id="rezyume"> 总结 </h2><br><p> 解析的示例清楚地说明了源代码的粗心处理。 没有使用异常来处理故障，而是决定使用它来实现业务逻辑。 这立即导致其支持的复杂性，这反映在其为满足新要求而进行的进一步开发中，从而偏离了结构编程的原则。 使用简单的规则（仅针​​对故障的例外）将帮助您避免重返GOTO时代，并使代码保持整洁，可理解和可扩展。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484840/">https://habr.com/ru/post/zh-CN484840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484824/index.html">关灯之战</a></li>
<li><a href="../zh-CN484826/index.html">人工智能使不良药物更加恶化</a></li>
<li><a href="../zh-CN484834/index.html">如何制定培训和发展的企业战略</a></li>
<li><a href="../zh-CN484836/index.html">根据乌克兰2020年的绿色关税计算获利能力</a></li>
<li><a href="../zh-CN484838/index.html">在Google Ads中设置规则的13个示例[说明]</a></li>
<li><a href="../zh-CN484846/index.html">我与开源的关系</a></li>
<li><a href="../zh-CN484854/index.html">在MS-DOS上的C＃中运行游戏</a></li>
<li><a href="../zh-CN484860/index.html">实施名称和结果名称</a></li>
<li><a href="../zh-CN484862/index.html">通过混合应用程序从AngularJS迁移到Angular7</a></li>
<li><a href="../zh-CN484866/index.html">在ARM嵌入式计算机上使用Astra Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>