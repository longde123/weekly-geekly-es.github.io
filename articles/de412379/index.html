<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëº üç≠ üòò ModelSim-Prozessordesign ü§µüèæ üé≠ üßìüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teil I. 
 Teil II 
 Teil III 
 Teil iv 
 Teil v 

 Dies ist die Vollversion des vorherigen Artikels, zu dem Testbenches hinzugef√ºgt wurden. 

 Wir ent...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ModelSim-Prozessordesign</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412379/"><img align="right" src="https://habrastorage.org/webt/wc/de/un/wcdeunlviebjlcovj8ch7-tyu88.jpeg"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil I.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil II</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil III</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil iv</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil v</a> <br><br>  Dies ist die Vollversion des vorherigen Artikels, zu dem Testbenches hinzugef√ºgt wurden. <br><br>  Wir entwerfen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Little Man Computer</a> in Verilog. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Artikel</a> √ºber LMC war auf Habr√©. <br><br>  Online-Simulator dieses Computers ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Wir werden ein RAM-Modul schreiben, das aus vier (ADDR_WIDTH = 2) Vier-Bit-W√∂rtern (DATA_WIDTH = 4) besteht.  Daten werden von data_in bei adr in den RAM geladen, wenn das Taktsignal clk eintrifft. <br><br><pre><code class="plaintext hljs">module R0 #(parameter ADDR_WIDTH = 2, DATA_WIDTH = 4) ( input clk, //  input [ADDR_WIDTH-1:0] adr, // input [DATA_WIDTH-1:0] data_in, //   output [DATA_WIDTH-1:0] RAM_out //   ); reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; //  mem always @(posedge clk) //    clk mem [adr] &lt;= data_in; //     data_in assign RAM_out = mem[adr]; // RAM_out    endmodule</code> </pre> <a name="habracut"></a><br>  Laden Sie in der Testbench 0001 um 00, 0010 um 01, 0100 um 10, 1000 um 11: <br><div class="spoiler">  <b class="spoiler_title">Erstellen Sie eine Testbench</b> <div class="spoiler_text">  Erstellen Sie ein neues Projekt, erstellen Sie die Dateien R0.v und tR0.v (diese Dateien werden automatisch zum Projekt hinzugef√ºgt). <br>  Kompilieren Sie beide Dateien. <br>  F√ºhren Sie die Simulation der kompilierten Datei tR0.v aus <br></div></div><br><pre> <code class="plaintext hljs">module tR0; reg clk; reg [1:0] adr; reg [3:0] data_in; wire [3:0] RAM_out; R0 test_R0 (clk, adr, data_in,RAM_out); initial begin clk = 0; adr[0] = 0; adr[1] = 0; data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; #5 data_in[0] = 1; #5 clk = 1; #5 adr[0] = 1; data_in[0] = 0; data_in[1] = 1; clk = 0; #5 clk = 1; #5 adr[0] = 0; adr[1] = 1; data_in[1] = 0; data_in[2] = 1; clk = 0; #5 clk = 1; #5 adr[0] = 1; adr[1] = 1; data_in[2] = 0; data_in[3] = 1; clk = 0; #5 clk = 1; #5 adr[0] = 0; adr[1] = 0; data_in[3] = 0; clk = 0; #5 adr[0] = 1; adr[1] = 0; #5 adr[0] = 0; adr[1] = 1; #5 adr[0] = 1; adr[1] = 1; #5 adr[0] = 0; adr[1] = 0; #5 adr[0] = 1; adr[1] = 0; #5 adr[0] = 0; adr[1] = 1; #5 adr[0] = 1; adr[1] = 1; #5 adr[0] = 0; adr[1] = 0; #5 adr[0] = 1; adr[1] = 0; #5 adr[0] = 0; adr[1] = 1; #5 adr[0] = 1; adr[1] = 1; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/dn/gr/ty/dngrtyzyzto7g0fnxh6l2emzpyg.gif"><br><br>  Wir verbinden den Z√§hler mit dem Adresseneingang des RAM.  Es ist notwendig, einen Taktgenerator an den Z√§hlereingang anzuschlie√üen. <br><br>  Hier ist ein Beispielprogramm mit dem internen Generator ALTUFM_OSC.  Frequenz eines Standardgenerators 5,5 MHz (MAX II EPM240 CPLD Minimal Development Board). <br><br><pre> <code class="plaintext hljs">module inner_Clock ( output reg LED); ALTUFM_OSC osc( .oscena(1'b1), .osc(clk)); reg signal; reg [24:0] osc_counter; reg [24:0] const_data = 25'b10110111000110110000000; initial begin signal = 1'b0; osc_counter = 25'b0; end //  6 000 000    osc_counter always @(posedge clk) begin osc_counter &lt;= osc_counter+ 1'b1; if(osc_counter == const_data) begin signal &lt;= ~signal; osc_counter &lt;= 25'b0; end LED = signal; // LED  ~1   . end endmodule</code> </pre><br>  Sie k√∂nnen auch einen externen Generator verwenden, z. B. einen 555 CMOS-Timer (mit 3,3 V betrieben).  Wir verbinden den 555-Timer mit dem Z√§hler und den Z√§hler mit dem Adresseneingang des RAM. <br><br>  T.O.  Wenn ein Taktsignal am Z√§hler ankommt, gehen wir zur n√§chsten Zelle im Speicher.  Wir verbinden die Schaltfl√§che RAM_button mit dem RAM-Clock-Eingang - die Daten im RAM werden geladen, wenn auf diese Schaltfl√§che geklickt wird. <br><br><pre> <code class="plaintext hljs">module R1 (timer555, RAM_button, data_in, RAM_out, counter); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; input timer555; input RAM_button; //input [ADDR_WIDTH-1:0] adr; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; output reg [1:0] counter; // Counter always @(posedge timer555) counter &lt;= counter + 1; // RAM wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= data_in; assign RAM_out = mem[adr]; endmodule</code> </pre><br>  So funktioniert die Schaltung im RTL Viewer <br><br><img src="https://habrastorage.org/webt/ti/nb/fh/tinbfhfwohrryqhapu_j53qcbr4.gif"><br><br>  Im ModelSim-Simulator funktioniert dieses Schema nicht, da der Simulator den Anfangswert der Z√§hlerregister [1: 0] nicht kennt. <br>  Der Betrieb der Schaltung kann durch direktes Herunterladen des Programms auf das FPGA √ºberpr√ºft werden. <br><br>  F√ºgen Sie als N√§chstes die Download-Funktion zum Z√§hler hinzu.  Laden Sie von data_in [1: 0] herunter, indem Sie auf die Schaltfl√§che Counter_load klicken <br><br><pre> <code class="plaintext hljs">module R2 (counter, timer555, Counter_load, RAM_button, data_in, RAM_out); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; output [1:0] counter; input timer555, Counter_load; // input [N-1:0] adr; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; // Counter reg [1:0] counter; always @ (posedge timer555 or posedge Counter_load) if (Counter_load) counter &lt;= data_in[1:0]; else counter &lt;= counter + 2'b01; // RAM wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= data_in; assign RAM_out = mem[adr]; endmodule</code> </pre><br>  So sieht die Verbindung von Tasten und LEDs im Pin Planner aus: <br><br><img src="https://habrastorage.org/webt/wx/bp/4e/wxbp4e5g4akkoq-fa1oryd61cni.gif"><br><br>  Laden Sie 0001 um 00, 0010 um 01, 0100 um 10, 1000 um 11 herunter <br><br><pre> <code class="plaintext hljs">module tR2; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; reg timer555, Counter_load, RAM_button; wire [1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; R2 test_R2(counter, timer555, Counter_load, RAM_button, data_in, RAM_out); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; Counter_load = 0; RAM_button = 0; #5 data_in[0]=0; data_in[1]=0; Counter_load=1; RAM_button=0; #5 data_in[0]=1; data_in[1]=0; Counter_load=0; RAM_button=1; #5 data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=0; #5 data_in[0]=1; data_in[1]=0; Counter_load=1; RAM_button=0; #5 data_in[0]=0; data_in[1]=1; Counter_load=0; RAM_button=1; #5 data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=0; #5 data_in[0]=0; data_in[1]=1; Counter_load=1; RAM_button=0; #5 data_in[2]=1; data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=1; #5 data_in[2]=0; data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=0; #5 data_in[0]=1; data_in[1]=1; Counter_load=1; RAM_button=0; #5 data_in[3]=1; data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=1; #5 data_in[3]=0; data_in[0]=0; data_in[1]=0; Counter_load=0; RAM_button=0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/iq/6b/oz/iq6bozzaypik1sleuf4cgdl3pfg.gif"><br><br>  Erstellen Sie in einem separaten Modul ein 4-Bit-Register (Batterie). <br><br>  Daten werden in das Register geladen, wenn Sie auf die Schaltfl√§che reg_button klicken: <br><br><pre> <code class="plaintext hljs">module register4 ( input [3:0] reg_data, input reg_button, output reg [3:0] q ); always @(posedge reg_button) q &lt;= reg_data; endmodule</code> </pre><br>  F√ºgen Sie den Akkumulator, den MUX2-Multiplexer und den Summenaddierer zur allgemeinen Schaltung hinzu. <br>  Der Addierer addiert die Nummer in den Batterie-Acc-Nummern aus dem Speicher. <br>  Die Signaleing√§nge des Multiplexers erhalten die Zahlen data_in und sum. <br>  Die Nummer von MUX2 wird durch Dr√ºcken der Taste Acc_button in die Acc-Batterie geladen. <br>  Die Nummer von Ass wird in den RAM geladen, wenn die Taste RAM_button gedr√ºckt wird. <br><br><img src="https://habrastorage.org/webt/bd/hm/jb/bdhmjbihshxszwhzvi_3mqqvpus.gif"><br><br><img src="https://habrastorage.org/webt/jb/ks/k0/jbksk0dkioookg7qeskuvpsu77a.gif"><br><br><pre> <code class="plaintext hljs">module R3 (MUX_switch, Acc_button, Acc, counter, timer555, Counter_load, RAM_button, data_in, RAM_out); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; input MUX_switch; input Acc_button; output [3:0] Acc; input timer555, Counter_load; output [1:0] counter; // input [N-1:0] adr; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; // Counter reg [1:0] counter; always @ (posedge timer555 or posedge Counter_load) if (Counter_load) counter &lt;= data_in[1:0]; else counter &lt;= counter + 2'b01; // RAM wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= Acc; assign RAM_out = mem[adr]; // sum wire [3:0] sum; assign sum = Acc + RAM_out; // MUX2 reg [3:0] MUX2; always @* MUX2 = MUX_switch ? sum : data_in; //     Acc_button /* reg Acc_dff; always @(posedge Acc_button or negedge timer555) if (!timer555) Acc_dff &lt;= 1'b0; else Acc_dff &lt;= timer555; */ //Acc register4 Acc_reg( .reg_data(MUX2), //.reg_button(Acc_dff), .reg_button(Acc_button), .q(Acc) ); endmodule</code> </pre><br>  F√ºr die programmatische Unterdr√ºckung von Chatter k√∂nnen Sie das in den Kommentaren angegebene einfache Schema verwenden <br><blockquote>  / * reg Acc_dff; <br>  immer @ (posedge Acc_button oder negedge timer555) <br>  if (! timer555) <br>  Acc_dff &lt;= 1'b0; <br>  sonst <br>  Acc_dff &lt;= timer555;  * / <br></blockquote><br>  Informationen zur Unterdr√ºckung von Schaltfl√§chen-Chatter finden Sie auch in den Kommentaren zum Artikel. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wir flashen AVR manuell</a> <br><br>  Als n√§chstes werden wir die Zahlen hinzuf√ºgen, zum Beispiel 2 und 3. <br><br>  1. Laden Sie die Nummern in den RAM <br>  2. Null den Arsch <br>  3. Schalten Sie MUX2 um <br>  4. Laden Sie die erste Nummer aus dem RAM in Ass herunter <br>  5. F√ºgen Sie die zweite Nummer aus dem RAM zur Nummer in Ass hinzu <br>  6. Laden Sie den Betrag in den Arbeitsspeicher herunter <br><br><pre> <code class="plaintext hljs">module tR3; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; reg MUX_switch; reg Acc_button; wire [3:0] Acc; reg timer555, Counter_load, RAM_button; wire [1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; R3 test_R3(MUX_switch, Acc_button, Acc, counter, timer555, Counter_load, RAM_button, data_in, RAM_out); initial begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; Counter_load = 0; Acc_button = 0; RAM_button = 0; MUX_switch = 0; #5 Counter_load = 1; #5 data_in[0]=0; data_in[1]=1; Counter_load = 0; #5 Acc_button = 1; #5 RAM_button = 1; #5 data_in[0]=0; data_in[1] = 0; Acc_button = 0; RAM_button = 0; #5 data_in[0]=1; data_in[1]=1; #15 Acc_button = 1; #5 RAM_button = 1; #5 Acc_button = 0; #5 data_in[0]=0; data_in[1] = 0; RAM_button = 0; #10 Acc_button = 1; #10 Acc_button = 0; #60 MUX_switch = 1; #10 Acc_button = 1; #10 Acc_button = 0; #30 Acc_button = 1; #10 Acc_button = 0; #30 RAM_button = 1; #10 RAM_button = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/ax/gl/h1/axglh1txflcvc0xjlojb57zyh3u.gif"><br><br>  F√ºgen Sie dem Hauptmodul ein Element hinzu, das von der Nummer in der Batterie die im Speicher aufgezeichnete Nummer subtrahiert. <br><br><pre> <code class="plaintext hljs">wire [3:0] subtract; assign subract = Acc - RAM_out ;</code> </pre><br><br>  Wir ersetzen den Multiplexer mit zwei Eing√§ngen durch den Multiplexer mit vier Eing√§ngen <br><pre> <code class="plaintext hljs">always @* MUX4 = MUX_switch[1] ? (MUX_switch[0] ? RAM_out : subtract) : (MUX_switch[0] ? sum : data_in);</code> </pre><br>  Wir verbinden das Ausgabeger√§t mit der Batterie (4bit'ny Register), wir verbinden auch 2 Flags mit der Batterie: <br><br>  1. Das Flag "Null" ist ein Protokoll.  Element 4 ODER NICHT.  Das Flag wird gehisst, wenn der Inhalt von Ass Null ist. <br><br>  2. Das Flag ‚ÄûNull oder positive Zahl‚Äú ist ein Protokoll.  Das Element befindet sich NICHT auf dem hohen Niveau der vierstelligen Batterie.  Das Flag wird gesetzt, wenn der Inhalt von Ass gr√∂√üer oder gleich Null ist. <br><br><pre> <code class="plaintext hljs">// "" output Z_flag; assign Z_flag = ~(|Acc); //    // "   " output PZ_flag; assign PZ_flag = ~Acc[3];</code> </pre><br><img src="https://habrastorage.org/webt/mx/mv/eu/mxmveuu6yw0mzsn86w6xakho5sy.gif"><br><br>  F√ºgen Sie drei Teams hinzu <br><br>  1. Laden des Batterieinhalts in das Ausgabeger√§t data_out <br>  2. Laden der Adresse in den Z√§hler, wenn das Flag ‚ÄûNull‚Äú gesetzt ist (JMP, wenn Acc = 0) <br>  3. Laden der Adresse in den Z√§hler, wenn das Flag ‚ÄûNull oder eine positive Zahl‚Äú gesetzt ist (JMP, wenn Acc&gt; = 0) <br><br><pre> <code class="plaintext hljs">module R4 (JMP,Z_JMP,PZ_JMP,Z_flag,PZ_flag,Output_button,data_out,MUX_switch,Acc_button,Acc,counter,timer555,RAM_button,data_in,RAM_out); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; input JMP, Z_JMP, PZ_JMP; output Z_flag, PZ_flag; input Output_button; output [3:0] data_out; input [1:0] MUX_switch; input Acc_button; output [3:0] Acc; input timer555; output [1:0] counter; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; // flags wire Z,PZ; assign Z = Z_flag &amp; Z_JMP; assign PZ = PZ_flag &amp; PZ_JMP; // Counter reg [1:0] counter; always @ (posedge timer555 or posedge JMP or posedge Z or posedge PZ) if (JMP|Z|PZ) counter &lt;= data_in[1:0]; else counter &lt;= counter + 2'b01; // RAM wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= Acc; assign RAM_out = mem[adr]; // sum wire [3:0] sum; assign sum = Acc + RAM_out; //subtract wire [3:0] subtract; assign subtract = Acc - RAM_out; // MUX4 reg [3:0] MUX4; always @* MUX4 = MUX_switch[1] ? (MUX_switch[0] ? RAM_out : subtract) : (MUX_switch[0] ? sum : data_in); //Acc register4 Acc_reg( .reg_data(MUX4), .reg_button(Acc_button), .q(Acc) ); //data_out register4 Output_reg( .reg_data(Acc), .reg_button(Output_button), .q(data_out) ); assign Z_flag = ~(|Acc); assign PZ_flag = ~Acc[3]; endmodule</code> </pre><br><img src="https://habrastorage.org/webt/1-/o7/bg/1-o7bggvr_5vbojs9io1tlpsv4a.gif"><br><br>  1. Laden Sie die Nummern in den RAM <br>  2. Null den Arsch <br>  3. Schalten Sie MUX2 um <br>  4. Subtrahieren Sie die erste Zahl (im RAM geschrieben) von Ass <br>  5. Subtrahieren Sie die zweite Zahl (im RAM geschrieben) von Ass <br>  6. Laden Sie den Betrag in RAM und data_out herunter <br><br><pre> <code class="plaintext hljs">module tR4; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; reg JMP, Z_JMP, PZ_JMP; wire Z_flag, PZ_flag; reg Output_button; wire [3:0] data_out; reg [1:0] MUX_switch; reg Acc_button; wire [3:0] Acc; reg timer555, RAM_button; wire [1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; R4 test_R4 (JMP,Z_JMP,PZ_JMP,Z_flag,PZ_flag,Output_button,data_out,MUX_switch,Acc_button,Acc, counter,timer555,RAM_button,data_in,RAM_out); initial begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; JMP = 0; Z_JMP = 0; PZ_JMP = 0; Acc_button = 0; RAM_button = 0; Output_button = 0; MUX_switch[0] = 0; MUX_switch[1] = 0; #5 JMP = 1; #5 data_in[0]=0; data_in[1]=1; JMP = 0; #5 Acc_button = 1; #5 RAM_button = 1; #5 data_in[0]=0; data_in[1] = 0; Acc_button = 0; RAM_button = 0; #5 data_in[0]=1; data_in[1]=1; #15 Acc_button = 1; #5 RAM_button = 1; #5 Acc_button = 0; #5 data_in[0]=0; data_in[1] = 0; RAM_button = 0; #10 Acc_button = 1; #10 Acc_button = 0; #60 MUX_switch[1] = 1; #10 Acc_button = 1; #10 Acc_button = 0; #30 Acc_button = 1; #10 Acc_button = 0; #30 RAM_button = 1; Output_button = 1; #10 RAM_button = 0; Output_button = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/jb/fq/c4/jbfqc45piovx4besdmw0pkxz_oa.gif"><br><br>  √úberpr√ºfen Sie, ob der Z_JMP-√úbergang nicht auftritt, wenn eine positive Zahl in Ass liegt: <br><br><pre> <code class="plaintext hljs">module tR4_jmp; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 4; reg JMP, Z_JMP, PZ_JMP; wire Z_flag, PZ_flag; reg Output_button; wire [3:0] data_out; reg [1:0] MUX_switch; reg Acc_button; wire [3:0] Acc; reg timer555, RAM_button; wire [1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; R4 test_R4 (JMP,Z_JMP,PZ_JMP,Z_flag,PZ_flag,Output_button,data_out,MUX_switch,Acc_button,Acc, counter,timer555,RAM_button,data_in,RAM_out); initial begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; JMP = 0; Z_JMP = 0; PZ_JMP = 0; Acc_button = 0; RAM_button = 0; Output_button = 0; MUX_switch[0] = 0; MUX_switch[1] = 0; #5 JMP = 1; #5 data_in[0]=0; data_in[1]=1; JMP = 0; #5 Acc_button = 1; #5 data_in[0]=1; data_in[1]=1; Acc_button = 1; #5 data_in[0]=1; data_in[1]=1; Acc_button = 0; #5 Z_JMP = 1; #5 PZ_JMP = 1; Z_JMP = 0; #5 PZ_JMP = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/ij/l4/sg/ijl4sgivszbp5yahbkdipb-ngwk.gif"><br><br>  Setzen Sie den bedingungslosen Sprungbefehl in den RAM <br><br><img src="https://habrastorage.org/webt/j-/jc/lp/j-jclpg2nixlq2dkwu2klhsgog8.gif"><br><br>  Design anzeigen <br><br><pre> <code class="plaintext hljs">//wire Counter_load; always @ (posedge timer555) if (Counter_load) counter &lt;= RAM_out[3:0]; else counter &lt;= counter + 2'b01;</code> </pre><br>  ModelSim funktioniert nicht, daher verwenden wir den zus√§tzlichen Befehl reset_count, der den Z√§hler initialisiert und zur√ºcksetzt, d. H. <br><br><pre> <code class="plaintext hljs">module resCount (reset_count, counter, timer555, RAM_button, data_in, RAM_out); parameter ADDR_WIDTH = 4; parameter DATA_WIDTH = 8; input reset_count; output [ADDR_WIDTH-1:0] counter; input timer555; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; wire Counter_load; assign Counter_load = RAM_out[7]; reg [ADDR_WIDTH-1:0] counter; always @ (posedge timer555 or posedge reset_count) if (reset_count) counter &lt;= 4'b0000; else if (Counter_load) counter &lt;= RAM_out[3:0]; else counter &lt;= counter + 4'b0001; wire [ADDR_WIDTH-1:0] adr; assign adr = counter; reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= data_in; assign RAM_out = mem[adr]; endmodule</code> </pre><br>  Pr√ºfstand <br><br><pre> <code class="plaintext hljs">module tresCount; parameter ADDR_WIDTH = 4; parameter DATA_WIDTH = 8; reg reset_count; reg timer555, RAM_button; wire [ADDR_WIDTH-1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; resCount test_resCount(reset_count, counter, timer555, RAM_button, data_in, RAM_out); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; data_in[4] = 0; data_in[5] = 0; data_in[6] = 0; data_in[7] = 0; RAM_button = 0; reset_count =1; #5 reset_count =0; #1500 data_in[7] =1; #5 RAM_button = 1; #5 data_in[7] =0; RAM_button = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/mz/an/c_/mzanc_fhk-_f1bu77t-6dmmodcg.gif"><br><br>  F√ºgen Sie der Schaltung MUX2 und Ass hinzu.  Wir werden in Ass mit dem Befehl RAM_out [6] aufnehmen. <br><br><pre> <code class="plaintext hljs">assign Acc_button = RAM_out[6];</code> </pre><br>  Wir werden ein Protokoll mit dem Takteingang Ass verbinden.  Element UND <br><br><pre> <code class="plaintext hljs">//  regiser4  (posedge reg_button)  (negedge reg_button) .reg_button(Acc_button &amp; timer555),</code> </pre><br>  Die Bedeutung des Verbindens eines Protokolls.  Element Und zum Takteingang geh√∂rt, dass Sie jetzt an der Vorderseite des Timers 555 den Multiplexer schalten k√∂nnen und auf dem Abstieg in der Batterie aufnehmen k√∂nnen.  T.O.  Wir haben zwei Teams in einem Schlag. <br><br>  Wir werden MUX2 mit dem Befehl RAM_out wechseln [5] <br><br><pre> <code class="plaintext hljs">assign MUX_switch = RAM_out[5];</code> </pre><br><img src="https://habrastorage.org/webt/ch/nj/29/chnj29pkt2rhfzeghs4mvfy8eaw.gif"><br><br><pre> <code class="plaintext hljs">module register4 ( input [3:0] reg_data, input reg_button, output reg [3:0] q ); always @(negedge reg_button) //  "posedge"  "negedge" q &lt;= reg_data; endmodule module R50 (reset_count, counter, timer555, RAM_button, data_in, RAM_out, mux_switch_out, mux_out,Acc_out); parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 8; input reset_count; output [ADDR_WIDTH-1:0] counter; input timer555; input RAM_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM_out; output [3:0] Acc_out; output mux_switch_out; output [3:0] mux_out; wire Counter_load; assign Counter_load = RAM_out[7]; //Counter reg [ADDR_WIDTH-1:0] counter; always @ (posedge timer555 or posedge reset_count) if (reset_count) counter &lt;= 2'b00; else if (Counter_load) counter &lt;= RAM_out[1:0]; else counter &lt;= counter + 2'b01; wire [ADDR_WIDTH-1:0] adr; assign adr = counter; //RAM reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; always @(posedge RAM_button) mem [adr] &lt;= data_in; assign RAM_out = mem[adr]; // MUX2 wire MUX_switch; assign MUX_switch = RAM_out[5]; reg [3:0] MUX2; always @* MUX2 = MUX_switch ? RAM_out : data_in[3:0]; //  4   data_in assign mux_out = MUX2; assign mux_switch_out = MUX_switch; wire Acc_button; assign Acc_button = RAM_out[6]; //Acc register4 Acc_reg( .reg_data(mux_out), .reg_button(Acc_button &amp; timer555), .q(Acc_out) ); endmodule</code> </pre><br>  Schreiben Sie auf dem Pr√ºfstand die Nummer 0101 in Zelle 00 und die Nummer 1010 in Zelle 01;  Laden Sie diese Nummern in die Batterie <br><br><pre> <code class="plaintext hljs">module tR50; parameter ADDR_WIDTH = 2; parameter DATA_WIDTH = 8; reg reset_count; reg timer555, RAM_button; wire [ADDR_WIDTH-1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM_out; wire mux_switch_out; wire [3:0] mux_out; wire [3:0] Acc_out; R50 test_R50(reset_count, counter, timer555, RAM_button, data_in, RAM_out, mux_switch_out, mux_out,Acc_out); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 1; data_in[1] = 0; data_in[2] = 1; data_in[3] = 0; data_in[4] = 0; data_in[5] = 1; data_in[6] = 1; data_in[7] = 0; RAM_button = 0; reset_count =1; #5 RAM_button = 1; reset_count = 0; #5 data_in[0]=0; data_in[2]=0; data_in[5]=0; data_in[6]=0; RAM_button=0; #15 data_in[1]=1; data_in[3]=1; data_in[5]=1;data_in[6]=1; #5 RAM_button=1; #5 data_in[1]=0; data_in[3]=0; data_in[5]=0; data_in[6]=0; RAM_button=0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/nv/qt/vw/nvqtvw93g7qoemgtgb3kyxtonn0.gif"><br><br>  Wir platzieren den zweiten RAM in der allgemeinen Schaltung und schreiben mit dem Befehl RAM1_out [4] in den RAM. <br><br><pre> <code class="plaintext hljs">assign RAM2_button = RAM1_out[4];</code> </pre><br><img src="https://habrastorage.org/webt/ks/xh/sp/ksxhspsrqxu2rnldvqt-vks0bie.gif"><br><br><pre> <code class="plaintext hljs">module register4 ( input [3:0] reg_data, input reg_button, output reg [3:0] q ); always @(negedge reg_button) q &lt;= reg_data; endmodule module R51 (reset_count, counter, timer555, RAM1_button, data_in, RAM1_out, RAM2_out, mux_switch_out, mux_out,Acc_out); parameter ADDR_WIDTH = 3; parameter DATA_WIDTH = 8; input reset_count; output [ADDR_WIDTH-1:0] counter; input timer555; input RAM1_button; input [DATA_WIDTH-1:0] data_in; output [DATA_WIDTH-1:0] RAM1_out; output [3:0] RAM2_out; output [3:0] Acc_out; output mux_switch_out; output [3:0] mux_out; wire Counter_load; assign Counter_load = RAM1_out[7]; //Counter reg [ADDR_WIDTH-1:0] counter; always @ (posedge timer555 or posedge reset_count) if (reset_count) counter &lt;= 2'b00; else if (Counter_load) counter &lt;= RAM1_out[1:0]; else counter &lt;= counter + 2'b01; wire [ADDR_WIDTH-1:0] adr1; assign adr1 = counter; //RAM1 reg [DATA_WIDTH-1:0] mem1 [2**ADDR_WIDTH-1:0]; always @(posedge RAM1_button ) mem1 [adr1] &lt;= data_in; assign RAM1_out = mem1[adr1]; wire [ADDR_WIDTH-1:0] adr2; assign adr2 = RAM1_out[3:0]; wire RAM2_button; assign RAM2_button = RAM1_out[4]; //RAM2 reg [3:0] mem2 [2**ADDR_WIDTH-1:0]; always @(posedge RAM2_button) mem2 [adr2] &lt;= Acc_out; assign RAM2_out = mem2[adr2]; // MUX2 wire MUX_switch; assign MUX_switch = RAM1_out[5]; reg [3:0] MUX2; always @* MUX2 = MUX_switch ? RAM2_out : data_in[3:0]; assign mux_out = MUX2; assign mux_switch_out = MUX_switch; wire Acc_button; assign Acc_button = RAM1_out[6]; //Acc register4 Acc_reg( .reg_data(mux_out), .reg_button(Acc_button &amp; timer555), .q(Acc_out) ); endmodule</code> </pre><br>  Laden Sie in der Testbench die Nummern 0100 und 1000 von Ass auf Null 0000 und die ersten 0001 Zellen von RAM mem2 (laden Sie diese Nummern dann von RAM mem2 auf Ass). <br><br><pre> <code class="plaintext hljs">module tR51; parameter ADDR_WIDTH = 3; parameter DATA_WIDTH = 8; reg reset_count; reg timer555, RAM1_button; wire [ADDR_WIDTH-1:0] counter; reg [DATA_WIDTH-1:0] data_in; wire [DATA_WIDTH-1:0] RAM1_out; wire [3:0] RAM2_out; wire mux_switch_out; wire [3:0] mux_out; wire [3:0] Acc_out; R51 test_R51(reset_count, counter, timer555, RAM1_button, data_in, RAM1_out, RAM2_out, mux_switch_out, mux_out,Acc_out); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; data_in[4] = 0; data_in[5] = 0; data_in[6] = 1; data_in[7] = 0; RAM1_button = 0; reset_count =1; #5 RAM1_button = 1; reset_count = 0; #5 RAM1_button = 0; data_in[6] = 0; #10 data_in[4] = 1; #5 RAM1_button = 1; #5 data_in[4] = 0; RAM1_button = 0; #30 data_in[6] = 1; #5 RAM1_button = 1; #5 data_in[6] = 0; RAM1_button = 0; #30 data_in[4] = 1; data_in[0] = 1; #5 RAM1_button = 1; #5 data_in[4] = 0; data_in[0] = 0; RAM1_button = 0; #30 data_in[6] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[6] = 0; #30 data_in[5] = 1; data_in[6] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[5] = 0; data_in[6] = 0; #30 data_in[5] = 1; data_in[6] = 1; data_in[0] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[0] = 0; data_in[5] = 0; data_in[6] = 0; #70 data_in[2] = 1; #80 data_in[2] = 0; data_in[3] = 1; #40 data_in[3] = 0; end endmodule</code> </pre><br><img src="https://habrastorage.org/webt/3k/f2/6i/3kf26ig-1py9pazz7ixfzncercq.gif"><br><br>  Ich werde hinzuf√ºgen, dass das Schema c protokolliert.  Das And-Element am Takteingang der Batterie funktioniert nicht immer richtig (abh√§ngig von der Platine).  Ersetzen Sie das Protokoll.  Element Und beim Acc_dff-Trigger laden wir den Trigger an der negativen Flanke (bei Abnahme) des Timer555-Taktsignals, wir laden die Batterie an der positiven Flanke <br><br><pre> <code class="plaintext hljs">// Acc_dff reg Acc_dff; always @(negedge timer555) Acc_dff &lt;= Acc_button;</code> </pre><br>  Erstellen Sie also das R52-Modul (LMC), indem Sie die verbleibenden Befehle hinzuf√ºgen. <br><br><img src="https://habrastorage.org/webt/_l/uz/be/_luzbeu0mrsx2we-prdo3xn7lde.gif"><br><br><pre> <code class="plaintext hljs">module register4 ( input [3:0] reg_data, input reg_button, output reg [3:0] q ); always @(posedge reg_button) // negedge -&gt; posedge q &lt;= reg_data; endmodule module R52 (Z_flag, PZ_flag, reset_count, counter, timer555, RAM1_button, data_in, RAM1_out, RAM2_out, mux_switch_out, mux_out, Acc_out, data_out, Acc_dff); parameter ADDR_WIDTH = 4; parameter DATA_WIDTH = 12; input reset_count; input timer555; input RAM1_button; input [DATA_WIDTH-1:0] data_in; output [ADDR_WIDTH-1:0] counter; output [1:0] mux_switch_out; output [3:0] mux_out; output [3:0] Acc_out; output [3:0] data_out; output [DATA_WIDTH-1:0] RAM1_out; output [3:0] RAM2_out; output Z_flag, PZ_flag; output Acc_dff; wire JMP_button, Z_JMP_button,PZ_JMP_button; assign JMP_button = RAM1_out[6]; assign Z_JMP_button = RAM1_out[5]; assign PZ_JMP_button = RAM1_out[4]; wire Z_JMP,PZ_JMP; assign Z_JMP = Z_flag &amp; Z_JMP_button; assign PZ_JMP = PZ_flag &amp; PZ_JMP_button; //Counter reg [ADDR_WIDTH-1:0] counter; always @ (posedge timer555 or posedge reset_count) if (reset_count) counter &lt;= 4'b0000; else if (JMP_button|Z_JMP|PZ_JMP) counter &lt;= RAM1_out[3:0]; else counter &lt;= counter + 4'b0001; wire [ADDR_WIDTH-1:0] adr1; assign adr1 = counter; //RAM1 reg [DATA_WIDTH-1:0] mem1 [2**ADDR_WIDTH-1:0]; always @(posedge RAM1_button ) mem1 [adr1] &lt;= data_in; assign RAM1_out = mem1[adr1]; //RAM2_adr wire [ADDR_WIDTH-1:0] adr2; assign adr2 = RAM1_out[2:0]; //RAM2_button wire RAM2_button; assign RAM2_button = RAM1_out[11]; //RAM2 reg [3:0] mem2 [2**ADDR_WIDTH-1:0]; always @(posedge RAM2_button) mem2 [adr2] &lt;= Acc_out; assign RAM2_out = mem2[adr2]; // sum wire [3:0] sum; assign sum = Acc_out + RAM2_out; //subtract wire [3:0] subtract; assign subtract = Acc_out - RAM2_out; // MUX4 wire [1:0] mux_switch; assign mux_switch[0] = RAM1_out[7]; assign mux_switch[1] = RAM1_out[8]; reg [3:0] MUX4; always @* MUX4 = mux_switch[1] ? (mux_switch[0] ? RAM2_out : subtract) : (mux_switch[0] ? sum : data_in[3:0]); assign mux_out = MUX4; assign mux_switch_out[0] = mux_switch[0]; assign mux_switch_out[1] = mux_switch[1]; //Acc_button wire Acc_button; assign Acc_button = RAM1_out[10]; // Acc_dff reg Acc_dff; always @(negedge timer555) Acc_dff &lt;= Acc_button; //Acc register4 Acc_reg( .reg_data(mux_out), //.reg_button(Acc_button &amp; timer555), .reg_button(Acc_dff), .q(Acc_out) ); //data_out wire Output_button; assign Output_button = RAM1_out[9]; register4 Output_reg( .reg_data(Acc_out), .reg_button(Output_button), .q(data_out) ); // flags assign Z_flag = ~(|Acc_out); assign PZ_flag = ~Acc_out[3]; endmodule</code> </pre><br>  In der Testbench werden wir √ºberpr√ºfen, wie der Algorithmus zum Ermitteln der maximalen Anzahl funktioniert. <br><br>  Die Besonderheit beim Laden von Befehlen im RAM besteht darin, dass wir nach dem Laden aller Befehle (340 ns) zu Zelle 8 zur√ºckkehren und einen anderen Befehl laden m√ºssen <br><br><pre> <code class="plaintext hljs">module tR52; parameter ADDR_WIDTH = 4; parameter DATA_WIDTH = 12; reg reset_count; reg timer555; reg RAM1_button; reg [DATA_WIDTH-1:0] data_in; wire [ADDR_WIDTH-1:0] counter; wire [1:0]mux_switch_out; wire [3:0] mux_out; wire [3:0] Acc_out; wire [3:0] data_out; wire [DATA_WIDTH-1:0] RAM1_out; wire [3:0] RAM2_out; wire Z_flag, PZ_flag; wire Acc_dff; R52 test_R52(Z_flag, PZ_flag, reset_count, counter, timer555, RAM1_button, data_in, RAM1_out, RAM2_out, mux_switch_out, mux_out,Acc_out, data_out, Acc_dff); initial // Clock generator begin timer555 = 0; forever #20 timer555 = ~timer555; end initial begin data_in[0] = 0; data_in[1] = 0; data_in[2] = 0; data_in[3] = 0; data_in[4] = 0; data_in[5] = 0; data_in[6] = 0; data_in[7] = 0; data_in[8] = 0; data_in[9] = 0; data_in[10] = 1; data_in[11] = 0; RAM1_button = 0; reset_count =1; //  1-    #5 RAM1_button = 1; reset_count = 0; #5 RAM1_button = 0; data_in[10] = 0; data_in[0] = 0; //  1-    0 #10 data_in[11] = 1; #5 RAM1_button = 1; #5 data_in[11] = 0; RAM1_button = 0; //  2-    #30 data_in[10] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[10] = 0; //  2-    0 #30 data_in[11] = 1;data_in[0] = 1; #5 RAM1_button = 1; #5 data_in[11] = 0;data_in[0] = 0; RAM1_button = 0; // 1-    #30 data_in[8]=1; data_in[10] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[8]=0; data_in[10] = 0; //  Acc&gt;=0,    8 #30 data_in[4]=1; data_in[3]=1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[4]=0; data_in[3]=0; //  1-  #30 data_in[7] = 1; data_in[8] = 1; data_in[10] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[7] = 0; data_in[8] = 0; data_in[10] = 0; //     9 #30 data_in[6] = 1; data_in[3]=1; data_in[0]=1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[6] = 0; data_in[3]=0; data_in[0]=0; //   data_out #30 data_in[9] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[9] = 0; //     8 #30 data_in[6] = 1; data_in[3]=1; data_in[0]=0; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[6] = 0; data_in[3]=0; data_in[0]=0; // 2-  #30 data_in[7] = 1; data_in[8] = 1; data_in[10] = 1; data_in[0] = 1; #5 RAM1_button = 1; #5 RAM1_button = 0; data_in[7] = 0; data_in[8] = 0; data_in[10] = 0; data_in[0] = 0; #75 RAM1_button = 1; #5 RAM1_button = 0; #230 data_in[2]=1; data_in[0]=0; //  #80 data_in[2]=0; data_in[0]=1; //   end endmodule</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> zum Github mit Programmcodes. <br><br>  Die kostenlose Studentenversion von <b>ModelSim</b> f√ºr Windows kann von <b>www.model.com</b> heruntergeladen werden. <br>  Als N√§chstes m√ºssen Sie (durch Ausf√ºllen des Formulars) die Datei student_license.dat herunterladen und diese Datei im Hauptverzeichnis des <b>ModelSim-</b> Programms <b>ablegen</b> . <br><br>  Link zur <b>ModelSim-</b> Datei f√ºr Linux (Ubuntu) <a href="">hier</a> <br>  Installationsanleitung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de412379/">https://habr.com/ru/post/de412379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de412369/index.html">Testet einen selbstausgleichenden EduMip-Roboter basierend auf BeagleBone Blue. Teil 2</a></li>
<li><a href="../de412371/index.html">Astronomen haben die Entdeckung der zweiten von uns entferntesten Galaxie best√§tigt</a></li>
<li><a href="../de412373/index.html">Wie automatisierte Halbleiterfertigung</a></li>
<li><a href="../de412375/index.html">Kann das kabellose Laden schnell sein? Sprechen Sie √ºber Sony WCH20</a></li>
<li><a href="../de412377/index.html">Sentimentale Singularit√§t: Was ist das Spiel "Detroit: Mensch werden"</a></li>
<li><a href="../de412381/index.html">Testen von LED-Panels 60x60</a></li>
<li><a href="../de412383/index.html">Hirnsch√§den retteten seine Musik</a></li>
<li><a href="../de412385/index.html">Island: Sturminsel</a></li>
<li><a href="../de412387/index.html">NeoLAB bringt neuen Smart Pen auf den Markt - SmartPen M1</a></li>
<li><a href="../de412389/index.html">Red Hogwarts. Serie 6. Sch√ºtze</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>