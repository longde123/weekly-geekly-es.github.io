<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôêÔ∏è ü§öüèø üë®üèº‚Äç‚öïÔ∏è √çndices de bitmap no Go: velocidade de pesquisa inacredit√°vel üçù üë®üèø‚Äçü§ù‚Äçüë®üèª ‚è∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meu nome √© Marko e eu conversei na Gophercon Russia este ano sobre um tipo muito interessante de √≠ndices chamado "√≠ndices de bitmap". Eu queria compar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices de bitmap no Go: velocidade de pesquisa inacredit√°vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/455608/">  Meu nome √© Marko e eu conversei na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gophercon Russia</a> este ano sobre um tipo muito interessante de √≠ndices chamado "√≠ndices de bitmap".  Eu queria compartilh√°-lo com a comunidade, n√£o apenas no formato de v√≠deo, mas tamb√©m como um artigo.  √â uma vers√£o em ingl√™s e voc√™ pode ler russo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Por favor, aproveite! <br><br><img src="https://habrastorage.org/webt/of/40/tp/of40tpvu9c7ammhkuygwa6x0eos.jpeg"><br><a name="habracut"></a><br>  Materiais adicionais, slides e todo o c√≥digo-fonte podem ser encontrados aqui: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://bit.ly/bitmapindexes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/mkevac/gopherconrussia2019</a> <br><br>  Grava√ß√£o de v√≠deo original: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WvlUH6MjUuI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Vamos come√ßar! <br><br><h2>  1. Introdu√ß√£o </h2><br><img src="https://habrastorage.org/webt/tz/mg/ae/tzmgaeevcgq_d8x8boqjdgqxnew.png"><br>  Hoje eu vou falar sobre <br><br><ul><li>  O que s√£o √≠ndices. <br></li><li>  O que √© um √≠ndice de bitmap; <br></li><li>  Onde √© usado.  Por que n√£o √© usado onde n√£o √© usado. <br></li><li>  Vamos ver uma implementa√ß√£o simples no Go e depois tentar no compilador. <br></li><li>  Em seguida, veremos uma implementa√ß√£o um pouco menos simples, mas visivelmente mais r√°pida, no assembly Go. <br></li><li>  E depois disso, vou abordar os "problemas" dos √≠ndices de bitmap, um por um. <br></li><li>  E, finalmente, veremos quais s√£o as solu√ß√µes existentes. <br></li></ul><br><h2>  Ent√£o, o que s√£o √≠ndices? </h2><br><img src="https://habrastorage.org/webt/ig/uh/ii/iguhiixwichncqrv6gdszecwgzg.png"><br><br>  Um √≠ndice √© uma estrutura de dados distinta que √© mantida atualizada al√©m dos dados principais, usada para acelerar solicita√ß√µes de pesquisa.  Sem √≠ndices, a pesquisa envolveria passar por todos os dados (em um processo tamb√©m conhecido como "verifica√ß√£o completa") e esse processo possui complexidade algor√≠tmica linear.  Mas os bancos de dados geralmente cont√™m grandes quantidades de dados, portanto a complexidade linear √© muito lenta.  Idealmente, gostar√≠amos de atingir velocidades de complexidade logar√≠tmica ou mesmo constante. <br><br>  Esse √© um t√≥pico enorme e complexo que envolve muitas trocas, mas olhando para tr√°s ao longo de d√©cadas de implementa√ß√µes e pesquisas de banco de dados, eu argumentaria que existem apenas algumas abordagens que s√£o comumente usadas: <br><br><img src="https://habrastorage.org/webt/aa/yv/wn/aayvwnmn7tbaucc39k3x7ejolsa.png"><br><br>  Primeiro, √© reduzir a √°rea de pesquisa cortando toda a √°rea em partes menores, hierarquicamente. <br><br>  Geralmente, isso √© conseguido usando √°rvores.  √â semelhante a ter caixas de caixas em seu guarda-roupa.  Cada caixa cont√©m materiais que s√£o posteriormente classificados em caixas menores, cada uma para um uso espec√≠fico.  Se precisarmos de materiais, √© melhor procurar a caixa "material" em vez de uma caixa "cookies". <br><br><img src="https://habrastorage.org/webt/zk/oq/_3/zkoq_3s8yr3izbnqvgd9nxmtvyi.png"><br><br>  O segundo √© identificar instantaneamente um elemento ou grupo espec√≠fico de elementos, como em mapas de hash ou √≠ndices reversos.  O uso de mapas de hash √© semelhante ao exemplo anterior, mas voc√™ usa muitas caixas menores que n√£o cont√™m caixas, mas itens finais. <br><br><img src="https://habrastorage.org/webt/kv/zh/0q/kvzh0qp0teoe7h1_ixbeum9jdne.png"><br><br>  A terceira abordagem √© remover a necessidade de pesquisar, como nos filtros bloom ou cuco.  Os filtros Bloom podem fornecer uma resposta imediata e economizar o tempo gasto na pesquisa. <br><br><img src="https://habrastorage.org/webt/r2/kk/cn/r2kkcn0uvtidikhqucutgigmvey.png"><br><br>  O √∫ltimo est√° acelerando a pesquisa, utilizando melhor nossos recursos de hardware, como nos √≠ndices de bitmap.  √Äs vezes, os √≠ndices de bitmap envolvem passar por todo o √≠ndice, sim, mas isso √© feito de uma maneira muito eficiente. <br><br>  Como eu j√° disse, a pesquisa tem muitas vantagens e desvantagens, e muitas vezes usamos v√°rias abordagens para melhorar ainda mais a velocidade ou para cobrir todos os nossos poss√≠veis tipos de pesquisa. <br><br>  Hoje eu gostaria de falar sobre uma dessas abordagens menos conhecidas: √≠ndices de bitmap. <br><br><h2>  Mas quem sou eu para falar sobre esse assunto? </h2><br><img src="https://habrastorage.org/webt/dh/i9/-r/dhi9-rzto3wlple4rympbmrdhx4.png"><br><br>  Sou l√≠der de equipe no Badoo (talvez voc√™ conhe√ßa outra de nossas marcas: Bumble).  Temos mais de 400 milh√µes de usu√°rios em todo o mundo e muitos dos recursos que envolvemos na busca da melhor correspond√™ncia para voc√™!  Para essas tarefas, usamos servi√ßos personalizados que usam √≠ndices de bitmap, entre outros. <br><br><h2>  Agora, o que √© um √≠ndice de bitmap? </h2><br><img src="https://habrastorage.org/webt/iz/ty/tu/iztytuxzo4kzx7vyc7vwrwwslze.png"><br><br>  Como o nome sugere, os √≠ndices de bitmap usam bitmaps, tamb√©m conhecidos como bitsets, para implementar o √≠ndice de pesquisa.  Do ponto de vista de um p√°ssaro, esse √≠ndice consiste em um ou v√°rios bitmaps que representam entidades (por exemplo, pessoas) e seus par√¢metros (por exemplo, idade ou cor dos olhos) e um algoritmo para responder a consultas de pesquisa usando opera√ß√µes bit a bit como AND, OR, NOT, etc. . <br><br><img src="https://habrastorage.org/webt/am/ws/tt/amwsttf4ru8rv7vjrrpwncxtamm.png"><br><br>  Os √≠ndices de bitmap s√£o considerados muito √∫teis e de alto desempenho se voc√™ tiver uma pesquisa que precise combinar consultas de v√°rias colunas com baixa cardinalidade (talvez cor dos olhos ou estado civil) versus algo como a dist√¢ncia do centro da cidade que possui cardinalidade infinita. <br><br>  Por√©m, mais adiante neste artigo, mostrarei que os √≠ndices de bitmap funcionam mesmo com colunas de alta cardinalidade. <br><br>  Vejamos o exemplo mais simples de um √≠ndice de bitmap ... <br><br><img src="https://habrastorage.org/webt/mp/av/0r/mpav0rhqmrsmaker8gzyzydwdry.png"><br><br>  Imagine que temos uma lista de restaurantes em Moscou com caracter√≠sticas bin√°rias: <br><br><ul><li>  perto do metro <br></li><li>  tem estacionamento privado <br></li><li>  tem terra√ßo <br></li><li>  aceita reservas <br></li><li>  vegan-friendly <br></li><li>  caro <br></li></ul><br><img src="https://habrastorage.org/webt/sg/oq/db/sgoqdbv90ujmnpkajxcc-8eg0eg.jpeg"><br>  Vamos atribuir a cada restaurante um √≠ndice a partir de 0 e alocar 6 bitmaps (um para cada caracter√≠stica).  Em seguida, preencher√≠amos esses bitmaps de acordo com o fato de o restaurante ter uma caracter√≠stica espec√≠fica ou n√£o.  Se o n√∫mero do restaurante 4 tiver o terra√ßo, o bit n√∫mero 4 no bitmap "terra√ßo" ser√° definido como 1 (0 se n√£o houver). <br><br><img src="https://habrastorage.org/webt/qo/-k/oo/qo-kooibnag790shhatr6q6nucy.png"><br><br>  Agora temos o √≠ndice de bitmap mais simples poss√≠vel que podemos usar para responder perguntas como <br><br><ul><li>  D√™-me restaurantes que s√£o veganos <br></li><li>  D√™-me restaurantes com terra√ßo que aceitam reservas, mas n√£o s√£o caros <br></li></ul><br><img src="https://habrastorage.org/webt/qq/76/fv/qq76fv2-j68ou8hvryi9t8jjoog.png"><br><br><img src="https://habrastorage.org/webt/tf/om/e8/tfome8xr_th8yazqnavjfajocwq.png"><br><br>  Como  Vamos ver  A primeira pergunta √© simples.  N√≥s apenas pegamos o bitmap "amig√°vel ao vegano" e retornamos todos os √≠ndices que definiram o bit. <br><br><img src="https://habrastorage.org/webt/9p/fq/j2/9pfqj2djha0-ca4vmpjfpgyogbk.png"><br><br><img src="https://habrastorage.org/webt/en/3r/co/en3rcomfemoy-arkj9qx3fqmveu.jpeg"><br><br>  A segunda pergunta √© um pouco mais complicada.  Usaremos a opera√ß√£o bit a bit, N√ÉO no bitmap "caro" para obter restaurantes n√£o caros, E com o bitmap "aceitar reserva" e "com bitmap no terra√ßo".  O bitmap resultante ser√° composto por restaurantes com todas essas caracter√≠sticas que desej√°vamos.  Aqui vemos que apenas Yunost tem todas essas caracter√≠sticas. <br><br><img src="https://habrastorage.org/webt/wm/jr/f5/wmjrf5nhch2k9zriz_sfuxzqfec.jpeg"><br><br><img src="https://habrastorage.org/webt/si/sf/c2/sisfc2h6lro8nu4yctf96absj_u.jpeg"><br><br>  Isso pode parecer um pouco te√≥rico, mas n√£o se preocupe, chegaremos ao c√≥digo em breve. <br><br><h2>  Onde os √≠ndices de bitmap s√£o usados </h2><br><img src="https://habrastorage.org/webt/zu/sd/up/zusdupegzydvhacdl-wzmwytrbq.jpeg"><br><br>  Se voc√™ pesquisar no ‚Äú√≠ndice de bitmap‚Äù, 90% dos resultados apontar√£o para o Oracle DB, que possui √≠ndices b√°sicos de bitmap.  Mas, certamente, outros DBMS tamb√©m usam √≠ndices de bitmap, n√£o √©?  N√£o, na verdade eles n√£o.  Vamos examinar os suspeitos do costume, um por um. <br><br><img src="https://habrastorage.org/webt/eg/of/z2/egofz23p1miavmonz6oeb4xhqiw.png"><br><br><ul><li>  O MySQL ainda n√£o possui √≠ndices de bitmap, mas existe uma proposta para adicion√°-los ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://dev.mysql.com/worklog/task/?id=1524</a> ) <br></li><li>  O PostgreSQL n√£o possui √≠ndices de bitmap, mas eles usam bitmaps simples e opera√ß√µes bit a bit para combinar os resultados de v√°rios √≠ndices diferentes. <br></li><li>  O Tarantool possui √≠ndices de bits e permite pesquisas muito simples com eles. <br></li><li>  Redis possui campos de bits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://redis.io/commands/bitfiel</a> d sem capacidade de pesquisa <br></li><li>  O MongoDB ainda n√£o os possui, mas tamb√©m h√° uma proposta para adicion√°-los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(https://jira.mongodb.org/browse/SERVER-1723)</a> <br></li><li>  O Elasticsearch usa bitmaps <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.elastic.co/blog/frame-of-reference-and-roaring-bitmaps</a> internamente <br></li></ul><br><img src="https://habrastorage.org/webt/4l/ng/4b/4lng4bvs5rnrd5qcnxyhsharkmg.png"><br><ul><li>  Mas h√° um novo garoto no quarteir√£o: Pilosa.  Pilosa √© um novo DBMS escrito em Go (observe que n√£o h√° R, n√£o √© relacional) que baseia tudo em √≠ndices de bitmap.  E falaremos sobre Pilosa mais tarde. <br></li></ul><br><h2>  Implementa√ß√£o em movimento </h2><br>  Mas porque?  Por que os √≠ndices de bitmap s√£o t√£o raramente usados?  Antes de responder a essa pergunta, gostaria de orient√°-lo na implementa√ß√£o b√°sica do √≠ndice de bitmap no Go. <br><br><img src="https://habrastorage.org/webt/db/ua/jt/dbuajtkgolu346p22gzcufwsll4.jpeg"><br><br>  O bitmap √© representado como um peda√ßo de mem√≥ria.  No Go, vamos usar uma fatia de bytes para isso. <br><br>  Temos um bitmap por caracter√≠stica do restaurante.  Cada bit em um bitmap representa se um restaurante espec√≠fico tem essa caracter√≠stica ou n√£o. <br><br><img src="https://habrastorage.org/webt/j2/az/1i/j2az1inrzzj0rcdg9dajst7afhc.jpeg"><br><br>  N√≥s precisar√≠amos de duas fun√ß√µes auxiliares.  Um √© usado para preencher o bitmap aleatoriamente, mas com uma probabilidade especificada de ter a caracter√≠stica.  Por exemplo, acho que existem muito poucos restaurantes que n√£o aceitam reservas e aproximadamente 20% s√£o veganos. <br><br>  Outra fun√ß√£o nos dar√° a lista de restaurantes de um bitmap. <br><br><img src="https://habrastorage.org/webt/aj/d7/vg/ajd7vgvjt7_2ssgiw7hh2jue9vu.jpeg"><img src="https://habrastorage.org/webt/gl/nv/wv/glnvwvokatnkyd08nxslinseoyc.jpeg"><br><br>  Para responder √† pergunta "d√™-me restaurantes com um terra√ßo que aceita reservas, mas n√£o √© caro", precisar√≠amos de duas opera√ß√µes: NOT e AND. <br><br>  Podemos simplificar levemente o c√≥digo introduzindo opera√ß√µes complexas AND NOT. <br><br>  Temos as fun√ß√µes para cada um deles.  Ambas as fun√ß√µes passam por nossas fatias, pegando os elementos correspondentes de cada uma, executando a opera√ß√£o e gravando o resultado na fatia resultante. <br><br><img src="https://habrastorage.org/webt/_f/-m/wa/_f-mwakzpgavqkr_a6m3lzzo_gy.jpeg"><br><br>  E agora podemos usar nossos bitmaps e nossas fun√ß√µes para obter a resposta. <br><br><img src="https://habrastorage.org/webt/rp/tn/uq/rptnuqmitwu5f-ag2w4tquglhca.jpeg"><br><br>  O desempenho n√£o √© t√£o bom aqui, embora nossas fun√ß√µes sejam realmente simples e economizamos muito em aloca√ß√µes ao n√£o retornar uma nova fatia em cada chamada de fun√ß√£o. <br><br>  Ap√≥s alguns perfis com o pprof, notei que o compilador go perdeu uma das otimiza√ß√µes b√°sicas: a fun√ß√£o inlining. <br><br><img src="https://habrastorage.org/webt/4s/6j/vs/4s6jvsys1nnmrpxnzpyfed8myq8.jpeg"><br><br>  Veja bem, o compilador Go tem medo patol√≥gico de loops atrav√©s de fatias e se recusa a alinhar qualquer fun√ß√£o que as possua. <br><br><img src="https://habrastorage.org/webt/ok/e_/th/oke_thx54xevzrxjqc6fmqx8w5y.jpeg"><br><br>  Mas n√£o tenho medo deles e posso enganar o compilador usando goto para o meu loop. <br><br><img src="https://habrastorage.org/webt/bx/xo/ea/bxxoeatd8s3mby2jyemkac3jyfg.jpeg"><br><br><img src="https://habrastorage.org/webt/5k/fm/2l/5kfm2let9qh2ynkerqdkkd1thao.jpeg"><br><br>  Como voc√™ pode ver, o inlining nos salvou em cerca de 2 microssegundos.  Nada mal! <br><br><img src="https://habrastorage.org/webt/or/tx/lw/ortxlwhbagw4oafvij-sngkxbsm.jpeg"><br><br>  Outro gargalo √© f√°cil de detectar quando voc√™ olha mais de perto a sa√≠da da montagem.  O compilador Go inclui verifica√ß√µes de faixa em nosso loop.  Go √© uma linguagem segura e o compilador tem medo de que meus tr√™s bitmaps possam ter comprimentos diferentes e que haja um estouro de buffer. <br><br>  Vamos acalmar o compilador e mostrar que todos os meus bitmaps t√™m o mesmo comprimento.  Para fazer isso, podemos adicionar uma verifica√ß√£o simples no in√≠cio da fun√ß√£o. <br><br><img src="https://habrastorage.org/webt/rq/v7/en/rqv7enj1mgqnsrgwnlkwscks0ri.jpeg"><br><br>  Com esta verifica√ß√£o, o compilador go ignora as verifica√ß√µes de alcance e economizaremos alguns nanossegundos. <br><br><h2>  Implementa√ß√£o em montagem </h2><br>  Tudo bem, ent√£o conseguimos reduzir um pouco mais o desempenho com nossa implementa√ß√£o simples, mas esse resultado √© muito pior do que √© poss√≠vel com o hardware atual. <br><br>  Veja bem, o que estamos fazendo s√£o opera√ß√µes bit a bit muito b√°sicas e nossas CPUs s√£o muito eficazes com elas. <br><br>  Infelizmente, estamos alimentando nossa CPU com muito pequenos peda√ßos de trabalho.  Nossa fun√ß√£o realiza opera√ß√µes byte a byte.  Podemos facilmente ajustar nossa implementa√ß√£o para trabalhar com blocos de 8 bytes usando fatias de uint64. <br><br><img src="https://habrastorage.org/webt/-w/vl/rd/-wvlrdx24mrcvy_vovvjeouaxjs.jpeg"><br><br>  Como voc√™ pode ver aqui, ganhamos cerca de 8x de desempenho para o tamanho de lote de 8x, portanto os ganhos de desempenho s√£o praticamente lineares. <br><br><img src="https://habrastorage.org/webt/tf/ej/nk/tfejnkdoftg8gs7vfpgrmbxfejq.jpeg"><img src="https://habrastorage.org/webt/ii/3d/du/ii3ddup__yc_-dhzsuivs6fcpeu.jpeg"><br><br>  Mas este n√£o √© o fim do caminho.  Nossas CPUs t√™m a capacidade de trabalhar com peda√ßos de 16 bytes, 32 bytes e at√© mesmo com peda√ßos de 64 bytes.  Essas opera√ß√µes s√£o chamadas SIMD (dados m√∫ltiplos de instru√ß√£o √∫nica) e o processo de uso dessas opera√ß√µes da CPU √© chamado de vetoriza√ß√£o. <br><br>  Infelizmente, o compilador Go n√£o √© muito bom com a vetoriza√ß√£o.  E a √∫nica coisa que podemos fazer hoje para vetorizar nosso c√≥digo √© usar o assembly Go e adicionar essas instru√ß√µes SIMD. <br><br><img src="https://habrastorage.org/webt/rs/si/_o/rssi_opod7oxo-e-jk_qepjfvic.png"><br><br>  Ir montagem √© uma besta estranha.  Voc√™ pensaria que o assembly √© algo ligado √† arquitetura para a qual est√° escrevendo, mas o assembly do Go √© mais parecido com o IRL (linguagem de representa√ß√£o intermedi√°ria): √© independente da plataforma.  Rob Pike deu uma palestra incr√≠vel sobre isso h√° alguns anos atr√°s. <br><br>  Al√©m disso, o Go usa um formato incomum plan9, diferente dos formatos AT&amp;T e Intel. <br><br><img src="https://habrastorage.org/webt/g4/aq/k5/g4aqk5lflo_4rgmsktoawvsiiuw.png"><br><br>  √â seguro dizer que escrever c√≥digo de montagem Go n√£o √© divertido. <br><br>  Felizmente para n√≥s, j√° existem duas ferramentas de n√≠vel superior para ajudar na escrita da montagem Go: PeachPy e avo.  Ambos geram o assembly go a partir de um c√≥digo de n√≠vel superior escrito em Python e Go, respectivamente. <br><br><img src="https://habrastorage.org/webt/mf/qz/zb/mfqzzbyuqtrdk06iiiw4ufe5eou.jpeg"><br><br>  Essas ferramentas simplificam coisas como aloca√ß√£o e loops de registro e, no fim das contas, reduzem a complexidade de entrar no dom√≠nio da programa√ß√£o de montagem do Go. <br><br>  Usaremos evitar esse post para que nossos programas se pare√ßam quase com o c√≥digo Go comum. <br><br><img src="https://habrastorage.org/webt/qd/ij/l2/qdijl2s77ub_c1om5budqbudjx4.jpeg"><br><br>  Este √© o exemplo mais simples de um programa avo.  Temos uma fun√ß√£o main () que define uma fun√ß√£o chamada Add () que adiciona dois n√∫meros.  Existem fun√ß√µes auxiliares para obter par√¢metros por nome e obter um dos registros gerais dispon√≠veis.  Existem fun√ß√µes para cada opera√ß√£o de montagem como ADDQ aqui e existem fun√ß√µes auxiliares para salvar o resultado de um registro no valor resultante. <br><br><img src="https://habrastorage.org/webt/8q/ze/6_/8qze6_requgfy9fimtn5tiirtn8.jpeg"><br><br>  A chamada go generate ir√° executar este programa avo e dois arquivos ser√£o criados <br><br><ul><li>  add.s com c√≥digo de montagem gerado <br></li><li>  stub.go com cabe√ßalhos de fun√ß√£o necess√°rios para conectar nosso c√≥digo go e assembly <br></li></ul><br><img src="https://habrastorage.org/webt/mz/bk/pi/mzbkpixqbe5kygtl9vphoeak39w.jpeg"><br><br>  Agora que vimos o que o avo faz, vejamos nossas fun√ß√µes.  Implementei as vers√µes escalar e SIMD (vetor) de nossas fun√ß√µes. <br><br>  Vamos ver como √© a vers√£o escalar primeiro. <br><br><img src="https://habrastorage.org/webt/9v/1a/gj/9v1agjswpb-wnfoyqbb1x0rb6vo.jpeg"><br><br>  Como no exemplo anterior, podemos solicitar um registro geral e evitar fornecer o correto.  N√£o precisamos rastrear compensa√ß√µes em bytes para nossos argumentos, evitando isso para n√≥s. <br><br><img src="https://habrastorage.org/webt/rt/yj/ju/rtyjjuzuc4ycx2au4tqohzaxsby.jpeg"><br><br>  Anteriormente, passamos de loops para usar goto por raz√µes de desempenho e para enganar o compilador.  Aqui, estamos usando goto (saltos) e r√≥tulos desde o in√≠cio, porque os loops s√£o constru√ß√µes de n√≠vel superior.  Na montagem, s√≥ temos saltos. <br><br><img src="https://habrastorage.org/webt/c4/gk/ww/c4gkwwdt0to9yorwoya2jurfrj8.jpeg"><br><br>  Outro c√≥digo deve ser bem claro.  Emulamos o loop com saltos e etiquetas, pegamos uma pequena parte de nossos dados de nossos dois bitmaps, combinamos usando uma das opera√ß√µes bit a bit e inserimos o resultado no bitmap resultante. <br><br><img src="https://habrastorage.org/webt/vw/gj/fg/vwgjfg2tkeaxec2n7qkvgneqpve.jpeg"><br><br>  Este √© um c√≥digo ASM resultante que obtemos.  N√£o tivemos que calcular deslocamentos e tamanhos (em verde), n√£o tivemos que lidar com registros espec√≠ficos (em vermelho). <br><br><img src="https://habrastorage.org/webt/of/sc/4v/ofsc4vbjkv2imcihypew4_japuo.jpeg"><br><br>  Se compararmos essa implementa√ß√£o em assembly com a melhor anterior escrita em go, veremos que o desempenho √© o mesmo que o esperado.  N√£o fizemos nada de diferente. <br><br>  Infelizmente, n√£o podemos for√ßar o compilador Go a incorporar nossas fun√ß√µes escritas em asm.  Falta completamente suporte e a solicita√ß√£o para esse recurso j√° existe h√° algum tempo.  √â por isso que as pequenas fun√ß√µes asm n√£o d√£o nenhum benef√≠cio.  Voc√™ precisa escrever fun√ß√µes maiores, usar o novo pacote math / bits ou ignorar asm completamente. <br><br>  Vamos escrever a vers√£o vetorial de nossas fun√ß√µes agora. <br><br><img src="https://habrastorage.org/webt/ac/qe/bs/acqebsweofbwzmvcwt-vro9yx4m.jpeg"><br><br>  Eu escolhi usar o AVX2, ent√£o vamos usar peda√ßos de 32 bytes.  √â muito semelhante ao escalar na estrutura.  Carregamos par√¢metros, solicitamos registros gerais, etc. <br><br><img src="https://habrastorage.org/webt/ef/5g/wa/ef5gwafb0stn7wunw8ryjcjyt_k.jpeg"><br><br>  Uma das mudan√ßas tem a ver com o fato de que as opera√ß√µes vetoriais usam registros amplos espec√≠ficos.  Para 32 bytes eles t√™m o prefixo Y, √© por isso que voc√™ v√™ YMM () l√°.  Para 64 bytes, eles teriam o prefixo Z. <br><br>  Outra diferen√ßa tem a ver com a otimiza√ß√£o que realizei chamada desenrolamento ou desenrolamento de loop.  Eu escolhi desenrolar parcialmente nosso loop e executar 8 opera√ß√µes de loop em sequ√™ncia antes de retornar.  Essa t√©cnica acelera o c√≥digo reduzindo as ramifica√ß√µes que temos e √© praticamente limitada pelo n√∫mero de registros que temos dispon√≠veis. <br><br><img src="https://habrastorage.org/webt/vj/1c/nd/vj1cndpc9uqyrzgfqrld4vfda5o.jpeg"><br><br>  Quanto ao desempenho ... √© incr√≠vel.  Obtivemos cerca de 7x de melhoria em compara√ß√£o com o melhor anterior.  Muito impressionante, certo? <br><br><img src="https://habrastorage.org/webt/d_/9b/ag/d_9bag_w0set74ryc4j5oqm5slm.jpeg"><br><br>  Deve ser poss√≠vel melhorar ainda mais esses resultados usando o AVX512, pr√©-busca e talvez at√© usando a compila√ß√£o JIT (just in time) em vez do construtor "manual" do plano de consulta, mas isso seria assunto para uma postagem totalmente diferente. <br><br><h2>  Problemas no √≠ndice de bitmap </h2><br>  Agora que vimos a implementa√ß√£o b√°sica e a velocidade impressionante da implementa√ß√£o do asm, vamos falar sobre o fato de que os √≠ndices de bitmap n√£o s√£o muito amplamente utilizados.  Por que isso? <br><br><img src="https://habrastorage.org/webt/bp/mr/mw/bpmrmwhfel_gbjklekgwywrj67c.png"><br><br>  Publica√ß√µes mais antigas nos d√£o essas tr√™s raz√µes.  Mas os mais recentes e eu argumentamos que estes foram "consertados" ou tratados at√© agora.  N√£o vou entrar em muitos detalhes aqui porque n√£o temos muito tempo, mas certamente vale a pena dar uma olhada r√°pida. <br><br><h2>  Problema de alta cardinalidade </h2><br>  Assim, nos disseram que os √≠ndices de bitmap s√£o vi√°veis ‚Äã‚Äãapenas para campos de baixa cardinalidade.  ou seja, campos com poucos valores distintos, como sexo ou cor dos olhos.  O motivo √© que a representa√ß√£o comum (um bit por valor distinto) pode ficar muito grande para valores de alta cardinalidade.  E, como resultado, o bitmap pode se tornar enorme, mesmo que seja escassamente preenchido. <br><br><img src="https://habrastorage.org/webt/zf/na/lt/zfnaltbokwrnweeiwtighgvq5cm.jpeg"><br><img src="https://habrastorage.org/webt/sa/p4/mw/sap4mwjq8sslx6_zgdanmn8fcwu.jpeg"><br><br>  √Äs vezes, uma representa√ß√£o diferente pode ser usada para esses campos, como uma representa√ß√£o de n√∫mero bin√°rio, como mostrado aqui, mas a maior mudan√ßa de jogo √© uma compacta√ß√£o.  Os cientistas criaram algoritmos de compress√£o surpreendentes.  Quase todos s√£o baseados em algoritmos de dura√ß√£o de execu√ß√£o generalizados, mas o mais surpreendente √© que n√£o precisamos descomprimir bitmaps para realizar opera√ß√µes bit a bit neles.  As opera√ß√µes bit a bit normais funcionam em bitmaps compactados. <br><br><img src="https://habrastorage.org/webt/mv/56/bt/mv56btwi703wsb0nya7ofor5lew.jpeg"><br><br>  Recentemente, vimos abordagens h√≠bridas aparecerem como "rugidos bitmaps".  Os bitmaps ruidosos usam tr√™s representa√ß√µes separadas para bitmaps: bitmaps, matrizes e "bit runs" e equilibram o uso dessas tr√™s representa√ß√µes para maximizar a velocidade e minimizar o uso de mem√≥ria. <br><br>  Os bitmaps ruidosos podem ser encontrados em alguns dos aplicativos mais usados ‚Äã‚Äãpor a√≠ e existem implementa√ß√µes para muitos idiomas, incluindo v√°rias implementa√ß√µes do Go. <br><br><img src="https://habrastorage.org/webt/af/xy/wy/afxywyhipsvsfla4tuot6ir0tei.jpeg"><br><br>  Outra abordagem que pode ajudar com campos de alta cardinalidade √© chamada binning.  Imagine que temos um campo que representa a altura de uma pessoa.  A altura √© uma b√≥ia, mas n√£o pensamos dessa maneira.  Ningu√©m se importa se a sua altura √© 185,2 ou 185,3 cm.  Portanto, podemos usar "caixas virtuais" para espremer alturas semelhantes na mesma bandeja: a bandeja de 1 cm, neste caso.  E se voc√™ assumir que existem muito poucas pessoas com uma altura inferior a 50 cm ou superior a 250 cm, podemos converter nossa altura no campo com aproximadamente cardinalidade de 200 elementos, em vez de uma cardinalidade quase infinita.  Se necess√°rio, poder√≠amos fazer uma filtragem adicional nos resultados posteriormente. <br><br><h2>  Problema de alto rendimento </h2><br>  Outra raz√£o pela qual os √≠ndices de bitmap s√£o ruins √© que pode ser caro atualizar bitmaps. <br>  Os bancos de dados fazem atualiza√ß√µes e pesquisas em paralelo, portanto, voc√™ deve poder atualizar os dados enquanto houver centenas de threads passando por bitmaps fazendo uma pesquisa.  Bloqueios seriam necess√°rios bloqueios para evitar corridas de dados ou problemas de consist√™ncia de dados.  E onde h√° uma grande trava, h√° conten√ß√£o de trava. <br><br><img src="https://habrastorage.org/webt/xg/ju/xl/xgjuxll8jn3btfxhniispsepbmw.jpeg"><br><br>  Esse problema, se voc√™ o tiver, pode ser corrigido compartilhando seus √≠ndices ou tendo vers√µes de √≠ndice, se apropriado. <br><br>  O sharding √© direto.  Voc√™ os fragmenta como faria com os usu√°rios em um banco de dados e agora, em vez de um bloqueio, voc√™ tem v√°rios bloqueios, o que reduz bastante sua conten√ß√£o de bloqueios. <br><br>  Outra abordagem que √†s vezes √© poss√≠vel √© ter √≠ndices com vers√£o.  Voc√™ tem o √≠ndice usado para pesquisa e um √≠ndice usado para grava√ß√µes, atualiza√ß√µes.  E voc√™ copia e troca com baixa frequ√™ncia, por exemplo, 100 ou 500 ms. <br><br>  Mas essa abordagem s√≥ √© vi√°vel se seu aplicativo puder tolerar √≠ndices de pesquisa obsoletos um pouco obsoletos. <br>  Obviamente, essas duas abordagens tamb√©m podem ser usadas juntas.  Voc√™ pode ter √≠ndices versionados divididos. <br><br><h2>  Consultas n√£o triviais </h2><br>  Outro problema do √≠ndice de bitmap tem a ver com o uso de √≠ndices de bitmap com consultas de intervalo.  E, √† primeira vista, opera√ß√µes bit a bit como AND e OR n√£o parecem ser muito √∫teis para consultas de intervalo como "me d√™ quartos de hotel que custam de 200 a 300 d√≥lares por noite". <br><br><img src="https://habrastorage.org/webt/fq/qy/en/fqqyeneeggnmx0iccptaz8eygmm.jpeg"><br><br>  Uma solu√ß√£o ing√™nua e muito ineficiente seria obter resultados para cada ponto de pre√ßo de 200 a 300 e OU os resultados. <br><br><img src="https://habrastorage.org/webt/jr/du/ey/jrdueypemf_a69m1wikbjpialze.jpeg"><br><br>  Uma abordagem um pouco melhor seria usar binning e colocar nossos hot√©is em faixas de pre√ßo com larguras de faixa de, digamos, 50 d√≥lares.  Essa abordagem reduziria nossas despesas de pesquisa em aproximadamente 50x. <br><br>  Mas esse problema tamb√©m pode ser resolvido com muita facilidade usando uma codifica√ß√£o especial que torna as consultas de intervalo poss√≠veis e r√°pidas.  Na literatura, esses bitmaps s√£o chamados de bitmaps codificados por intervalo. <br><br><img src="https://habrastorage.org/webt/vq/hx/a5/vqhxa5jyy4w9_e5lurbjhntabie.jpeg"><br><br>  Nos bitmaps codificados por intervalo, n√£o definimos apenas um bit espec√≠fico, digamos, para o valor 200, mas definimos todos os bits em 200 ou mais.  O mesmo para 300. <br><br>  Portanto, usando essa consulta de intervalo de representa√ß√£o de bitmap codificada por intervalo, a resposta pode ser respondida com apenas duas passagens pelo bitmap.  Obtemos todos os hot√©is que custam menos que ou igual a 300 d√≥lares e removemos do resultado todos os hot√©is que custam menos que ou iguais a 199 d√≥lares.  Conclu√≠do <br><br><img src="https://habrastorage.org/webt/wh/bc/hs/whbchsdcr0qrupa6jhu9fcpufke.jpeg"><br><br>  Voc√™ ficaria surpreso, mas mesmo as consultas geogr√°ficas s√£o poss√≠veis usando bitmaps.  O truque √© usar uma representa√ß√£o como o Google S2 ou similar que inclua uma coordenada em uma figura geom√©trica que possa ser representada como tr√™s ou mais linhas indexadas.  Se voc√™ usar essa representa√ß√£o, poder√° representar a consulta geogr√°fica como v√°rias consultas de intervalo nesses √≠ndices de linha. <br><br><h2>  Solu√ß√µes prontas </h2><br>  Bem, espero ter despertado um pouco o seu interesse.  Agora voc√™ tem mais uma ferramenta e se precisar implementar algo assim em seu servi√ßo, saber√° onde procurar. <br><br>  Tudo bem, mas nem todo mundo tem tempo, paci√™ncia e recursos para implementar o √≠ndice de bitmap, especialmente quando se trata de coisas mais avan√ßadas, como instru√ß√µes SIMD. <br><br>  N√£o tema, existem dois produtos de c√≥digo aberto que podem ajud√°-lo em seu esfor√ßo. <br><br><img src="https://habrastorage.org/webt/em/cg/km/emcgkmutgbpdj_arrdnfoub6lt0.jpeg"><br><br><h2>  Rugindo </h2><br>  Primeiro, h√° uma biblioteca que eu j√° mencionei chamada "bitmaps rujir".  Esta biblioteca implementa o "cont√™iner" rujir e todas as opera√ß√µes bit a bit que voc√™ precisaria para implementar um √≠ndice de bitmap completo. <br><br><img src="https://habrastorage.org/webt/k3/mv/yh/k3mvyhvcdb8sh7g-aejhgqeob6c.jpeg"><br><br>  Infelizmente, as implementa√ß√µes go n√£o usam SIMD, portanto, elas apresentam um desempenho um pouco menor do que, digamos, a implementa√ß√£o C. <br><br><h2>  Pilosa </h2><br>  Outro produto √© um DBMS chamado Pilosa que possui apenas √≠ndices de bitmap.  √â um projeto recente, mas ganhou muita for√ßa ultimamente. <br><br><img src="https://habrastorage.org/webt/uw/gs/56/uwgs563qvexzg27dd5x15zbzlto.jpeg">  E-d3BCvTn1CSSDr5Vj6W_9e5_GC1syQ9qSrwdS0 "&gt; <br><br>  A Pilosa usa bitmaps ruidosos por baixo e fornece, simplifica ou explica quase tudo o que eu tenho falado hoje: binning, bitmaps codificados por intervalo, a no√ß√£o de campos etc. <br><br>  Vamos ver brevemente um exemplo de Pilosa em uso ... <br><br><img src="https://habrastorage.org/webt/8d/jm/kn/8djmknf2jltazwrepy_ia4j7k_4.jpeg"><br><br>  O exemplo que voc√™ v√™ √© muito parecido com o que vimos anteriormente.  Criamos um cliente para o servidor pilosa, criamos um √≠ndice e campos para nossas caracter√≠sticas.  Preenchemos os campos com dados aleat√≥rios com algumas probabilidades, como fizemos anteriormente e, em seguida, executamos nossa consulta de pesquisa. <br>  Voc√™ v√™ o mesmo padr√£o b√°sico aqui.  N√ÉO √© caro cruzado ou com ed com terra√ßo e cruzado com reservas. <br><br>  O resultado √© o esperado. <br><br><img src="https://habrastorage.org/webt/bg/bu/oi/bgbuoi1v8n8vus4einuldy4u8zu.jpeg"><br><br>  E, finalmente, espero que em algum momento no futuro, bancos de dados como mysql e postgresql obtenham um novo tipo de √≠ndice: √≠ndice de bitmap. <br><br><img src="https://habrastorage.org/webt/ez/h4/g1/ezh4g1de2gpbozwi8-yubjvhpp4.jpeg"><br><br><h2>  Palavras finais </h2><br><img src="https://habrastorage.org/webt/tp/0f/3v/tp0f3vktlhcltdxbu7fatn7qqhq.jpeg"><br><br>  E se voc√™ ainda est√° acordado, agrade√ßo por isso.  A falta de tempo significou que eu tive que examinar muitas coisas neste post, mas espero que tenha sido √∫til e talvez at√© inspirador. <br><br>  Os √≠ndices de bitmap s√£o √∫teis para conhecer e entender, mesmo que voc√™ n√£o precise deles no momento.  Mantenha-os como mais uma ferramenta em seu portf√≥lio. <br><br>  Durante minha palestra, vimos v√°rios truques de desempenho que podemos usar e coisas com as quais o Go luta no momento.  Definitivamente, essas s√£o coisas que todo programador Go precisa saber. <br><br>  E isso √© tudo que tenho para voc√™ por enquanto.  Muito obrigado! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455608/">https://habr.com/ru/post/pt455608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455598/index.html">Atualize urgentemente o Exim para 4.92 - h√° uma infec√ß√£o ativa</a></li>
<li><a href="../pt455600/index.html">Plataforma 3DEXPERIENCE ajuda a criar transporte p√∫blico do futuro</a></li>
<li><a href="../pt455602/index.html">Provocando Falhas no Navegador com Fuzzing Comportamental</a></li>
<li><a href="../pt455604/index.html">Respons√°vel por gerenciar a configura√ß√£o do Windows. Hist√≥ria de sucesso</a></li>
<li><a href="../pt455606/index.html">Aprendizado de m√°quina e an√°lise de dados: programa de mestrado na Escola Superior de Economia de S√£o Petersburgo</a></li>
<li><a href="../pt455610/index.html">Lend√°rio Intel Core i7-2600K: testando Sandy Bridge em 2019 (parte 1)</a></li>
<li><a href="../pt455612/index.html">Pensamos nos personagens dos jogos e di√°logos, nos conselhos dos escritores e no exemplo dos apoiadores da teoria da Terra plana</a></li>
<li><a href="../pt455614/index.html">FFI: escrevendo em Rust em um programa PHP</a></li>
<li><a href="../pt455616/index.html">Por que ir para "Programa√ß√£o Industrial" no HSE de S√£o Petersburgo?</a></li>
<li><a href="../pt455618/index.html">DevOps LEGO: como estabelecemos um pipeline em cubos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>