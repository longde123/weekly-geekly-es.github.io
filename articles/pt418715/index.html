<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😥 👩🏻‍🤝‍👨🏼 👩🏽‍🤝‍👨🏾 Qual a eficiência do sistema de arquivos virtual procfs e é possível otimizá-lo 🤽🏽 🚉 👨🏿‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O sistema de arquivos proc (a seguir simplesmente procfs) é um sistema de arquivos virtual que fornece informações sobre processos. Ela é um exemplo "...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qual a eficiência do sistema de arquivos virtual procfs e é possível otimizá-lo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/virtuozzo/blog/418715/"><p>  O sistema de arquivos proc (a seguir simplesmente procfs) é um sistema de arquivos virtual que fornece informações sobre processos.  Ela é um exemplo "fino" de interfaces, seguindo o paradigma "tudo é um arquivo".  O Procfs foi desenvolvido há muito tempo: em um momento em que os servidores atendiam dezenas de processos em média, ao abrir um arquivo e ler as informações do processo não era um problema.  No entanto, o tempo não pára e agora os servidores atendem a centenas de milhares ou mais processos ao mesmo tempo.  Nesse contexto, a idéia de “abrir um arquivo para cada processo para subtrair os dados de interesse” não parece mais tão atraente, e a primeira coisa que vem à mente para acelerar a leitura é obter informações sobre um grupo de processos em uma iteração.  Neste artigo, tentaremos encontrar elementos procfs que podem ser otimizados. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7c7/55c/f6b/7c755cf6b80f5b20ab194e548c3c99be.jpg" alt="imagem"></p><a name="habracut"></a><br><p>  A própria idéia de melhorar o procfs surgiu quando descobrimos que o CRIU gasta uma quantidade considerável de tempo apenas lendo os arquivos procfs.  Vimos como um problema semelhante foi resolvido para soquetes e decidimos fazer algo semelhante à interface sock-diag, mas apenas para procfs.  É claro que assumimos o quão difícil seria mudar a interface antiga e bem estabelecida no kernel, convencer a comunidade de que o jogo valia a pena ... e ficamos agradavelmente surpreendidos com o número de pessoas que apoiaram a criação da nova interface.  A rigor, ninguém sabia como deveria ser a nova interface, mas não há dúvida de que o procfs não atende aos requisitos de desempenho atuais.  Por exemplo, este cenário: o servidor responde a solicitações por muito tempo, vmstat mostra que a memória entrou em uma troca e "ps ax" é iniciado a partir de 10 segundos ou mais, top não mostra nada.  Neste artigo, não consideraremos nenhuma nova interface específica; tentaremos descrever os problemas e suas soluções. </p><br><p> Cada processo procfs em execução é representado pelo diretório / proc / <code>&lt;pid&gt;</code> . <br>  Em cada diretório, existem muitos arquivos e subdiretórios que fornecem acesso a determinadas informações sobre o processo.  Os subdiretórios agrupam dados por recurso.  Por exemplo ( <code>$$</code> é uma variável de shell especial que é expandida em pid - o identificador do processo atual): </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> ls <span class="hljs-operator"><span class="hljs-operator">-F</span></span> /proc/<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span> attr/ exe<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span> mounts projid_map status autogroup fd/ mountstats root<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span> syscall auxv fdinfo/ net/ sched task/ cgroup gid_map ns/ schedstat timers clear_refs io numa_maps sessionid timerslack_ns cmdline limits oom_adj setgroups uid_map comm loginuid oom_score smaps wchan coredump_filter map_files/ oom_score_adj smaps_rollup cpuset maps pagemap stack cwd<span class="hljs-selector-tag"><span class="hljs-selector-tag">@</span></span> mem patch_state stat environ mountinfo personality statm</code> </pre> <br><p>  Todos esses arquivos geram dados em diferentes formatos.  A maioria está no formato de texto ASCII que é facilmente percebido pelos seres humanos.  Bem, quase fácil: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> cat /proc/<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span>/stat <span class="hljs-number"><span class="hljs-number">24293</span></span> (bash) S <span class="hljs-number"><span class="hljs-number">21811</span></span> <span class="hljs-number"><span class="hljs-number">24293</span></span> <span class="hljs-number"><span class="hljs-number">24293</span></span> <span class="hljs-number"><span class="hljs-number">34854</span></span> <span class="hljs-number"><span class="hljs-number">24876</span></span> <span class="hljs-number"><span class="hljs-number">4210688</span></span> <span class="hljs-number"><span class="hljs-number">6325</span></span> <span class="hljs-number"><span class="hljs-number">19702</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">33</span></span> <span class="hljs-number"><span class="hljs-number">35</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">47892016</span></span> <span class="hljs-number"><span class="hljs-number">135487488</span></span> <span class="hljs-number"><span class="hljs-number">3388</span></span> <span class="hljs-number"><span class="hljs-number">18446744073709551615</span></span> <span class="hljs-number"><span class="hljs-number">94447405350912</span></span> <span class="hljs-number"><span class="hljs-number">94447406416132</span></span> <span class="hljs-number"><span class="hljs-number">140729719486816</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">65536</span></span> <span class="hljs-number"><span class="hljs-number">3670020</span></span> <span class="hljs-number"><span class="hljs-number">1266777851</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">94447408516528</span></span> <span class="hljs-number"><span class="hljs-number">94447408563556</span></span> <span class="hljs-number"><span class="hljs-number">94447429677056</span></span> <span class="hljs-number"><span class="hljs-number">140729719494655</span></span> <span class="hljs-number"><span class="hljs-number">140729719494660</span></span> <span class="hljs-number"><span class="hljs-number">140729719494660</span></span> <span class="hljs-number"><span class="hljs-number">140729719496686</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Para entender o que cada elemento deste conjunto significa, o leitor terá que abrir o man proc (5) ou a documentação do kernel.  Por exemplo, o segundo elemento é o nome do arquivo executável entre colchetes, e o décimo nono elemento é o valor atual da prioridade de execução (nice). </p><br><p>  Alguns arquivos são bastante legíveis por eles mesmos: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> cat /proc/<span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span>/status | head <span class="hljs-literal"><span class="hljs-literal">-n</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> Name: bash Umask: <span class="hljs-number"><span class="hljs-number">0002</span></span> State: S (sleeping) Tgid: <span class="hljs-number"><span class="hljs-number">24293</span></span> Ngid: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Mas com que frequência os usuários leem informações diretamente dos arquivos procfs?  Quanto tempo o kernel precisa converter dados binários em formato de texto?  Qual é a sobrecarga dos procfs?  Qual é a conveniência dessa interface para os programas de monitoramento de status e quanto tempo eles gastam para processar esses dados de texto?  Quão crítica é uma implementação tão lenta em situações de emergência? </p><br><p>  Provavelmente, não será um erro dizer que os usuários preferem programas como top ou ps, em vez de ler dados diretamente do procfs. </p><br><p>  Para responder às perguntas restantes, realizaremos várias experiências.  Primeiro, encontre onde o kernel gasta tempo para gerar arquivos procfs. </p><br><p>  Para obter certas informações de todos os processos do sistema, teremos que passar pelo diretório / proc / e selecionar todos os subdiretórios cujo nome é representado por dígitos decimais.  Então, em cada um deles, precisamos abrir o arquivo, lê-lo e fechá-lo. </p><br><p>  No total, faremos três chamadas de sistema, uma das quais criará um descritor de arquivo (no kernel, um descritor de arquivo está associado a um conjunto de objetos internos para os quais a memória adicional é alocada).  As chamadas de sistema open () e close () não fornecem nenhuma informação, portanto podem ser atribuídas à sobrecarga da interface procfs. </p><br><p>  Vamos apenas tentar abrir () e fechar () para cada processo no sistema, mas não leremos o conteúdo dos arquivos: </p><br><pre> <code class="hljs go">$ time ./task_proc_all --noread stat tasks: <span class="hljs-number"><span class="hljs-number">50290</span></span> <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.177s</span></span> user <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.012s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.162s</span></span></code> </pre> <br><pre> <code class="hljs go">$ time ./task_proc_all --noread loginuid tasks: <span class="hljs-number"><span class="hljs-number">50289</span></span> <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.176s</span></span> user <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.026s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.145</span></span></code> </pre> <br><p>  <em>task-proc-all - um pequeno utilitário, cujo código pode ser encontrado no link abaixo</em> </p><br><p>  Não importa qual arquivo abrir, pois dados reais são gerados somente no momento da leitura (). </p><br><p>  Agora observe a saída do perf core profiler: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 92<span class="hljs-selector-class"><span class="hljs-selector-class">.18</span></span>% 0<span class="hljs-selector-class"><span class="hljs-selector-class">.00</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">task_proc_all</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[unknown]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x8000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 64<span class="hljs-selector-class"><span class="hljs-selector-class">.01</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">GI___libc_open</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 50<span class="hljs-selector-class"><span class="hljs-selector-class">.71</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">entry_SYSCALL_64_fastpath</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">do_sys_open</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 48<span class="hljs-selector-class"><span class="hljs-selector-class">.63</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">do_filp_open</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">path_openat</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 19<span class="hljs-selector-class"><span class="hljs-selector-class">.60</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">link_path_walk</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 14<span class="hljs-selector-class"><span class="hljs-selector-class">.23</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">walk_component</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 13<span class="hljs-selector-class"><span class="hljs-selector-class">.87</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">lookup_fast</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 7<span class="hljs-selector-class"><span class="hljs-selector-class">.55</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">pid_revalidate</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.13</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">get_pid_task</span></span> + 1<span class="hljs-selector-class"><span class="hljs-selector-class">.58</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">security_task_to_inode</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.10</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">task_dump_owner</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.63</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">d_lookup_rcu</span></span> + 3<span class="hljs-selector-class"><span class="hljs-selector-class">.42</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">security_inode_permission</span></span> + 14<span class="hljs-selector-class"><span class="hljs-selector-class">.76</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">proc_pident_lookup</span></span> + 4<span class="hljs-selector-class"><span class="hljs-selector-class">.39</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">d_alloc_parallel</span></span> + 2<span class="hljs-selector-class"><span class="hljs-selector-class">.93</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">get_empty_filp</span></span> + 2<span class="hljs-selector-class"><span class="hljs-selector-class">.43</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">lookup_fast</span></span> + 0<span class="hljs-selector-class"><span class="hljs-selector-class">.98</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">do_dentry_open</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.07</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">syscall_return_via_sysret</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.60</span></span>% 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xfffffe000008a01b</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.97</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">kmem_cache_alloc</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.61</span></span>% 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xfffffe000008a01e</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 16<span class="hljs-selector-class"><span class="hljs-selector-class">.45</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">getdents64</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 15<span class="hljs-selector-class"><span class="hljs-selector-class">.11</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">entry_SYSCALL_64_fastpath</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sys_getdents</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">iterate_dir</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">proc_pid_readdir</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 7<span class="hljs-selector-class"><span class="hljs-selector-class">.18</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">proc_fill_cache</span></span> + 3<span class="hljs-selector-class"><span class="hljs-selector-class">.53</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">d_lookup</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.59</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">filldir</span></span> + 6<span class="hljs-selector-class"><span class="hljs-selector-class">.82</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">next_tgid</span></span> + 0<span class="hljs-selector-class"><span class="hljs-selector-class">.61</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">snprintf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 9<span class="hljs-selector-class"><span class="hljs-selector-class">.89</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">close</span></span> + 4<span class="hljs-selector-class"><span class="hljs-selector-class">.03</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">entry_SYSCALL_64_fastpath</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.98</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">syscall_return_via_sysret</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.85</span></span>% 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xfffffe000008a01b</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.61</span></span>% 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xfffffe000008a01e</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.10</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">syscall_return_via_sysret</span></span></code> </pre> <br><p>  O kernel passa quase 75% do tempo apenas para criar e excluir o descritor de arquivo e cerca de 16% para listar os processos. </p><br><p>  Embora saibamos quanto tempo leva para as chamadas de abertura () e fechamento () de cada processo, ainda não podemos estimar quão significativo é.  Precisamos comparar os valores obtidos com alguma coisa.  Vamos tentar fazer o mesmo com os arquivos mais famosos.  Geralmente, quando você precisa listar os processos, o utilitário ps ou top é usado.  Ambos lêem / proc / <code>&lt;pid&gt;</code> / stat e / proc / <code>&lt;pid&gt;</code> / status para cada processo no sistema. </p><br><p>  Vamos começar com / proc / <code>&lt;pid&gt;</code> / status - este é um arquivo enorme com um número fixo de campos: </p><br><pre> <code class="hljs go">$ time ./task_proc_all status tasks: <span class="hljs-number"><span class="hljs-number">50283</span></span> <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.455s</span></span> user <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.033s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.417s</span></span></code> </pre> <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 93<span class="hljs-selector-class"><span class="hljs-selector-class">.84</span></span>% 0<span class="hljs-selector-class"><span class="hljs-selector-class">.00</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">task_proc_all</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[unknown]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[k]</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x0000000000008000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x8000</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 61<span class="hljs-selector-class"><span class="hljs-selector-class">.20</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 53<span class="hljs-selector-class"><span class="hljs-selector-class">.06</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">entry_SYSCALL_64_fastpath</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sys_read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 52<span class="hljs-selector-class"><span class="hljs-selector-class">.80</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">vfs_read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 52<span class="hljs-selector-class"><span class="hljs-selector-class">.22</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">vfs_read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq_read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 50<span class="hljs-selector-class"><span class="hljs-selector-class">.43</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">proc_single_show</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 50<span class="hljs-selector-class"><span class="hljs-selector-class">.38</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">proc_pid_status</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 11<span class="hljs-selector-class"><span class="hljs-selector-class">.34</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">task_mem</span></span> + <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq_printf</span></span> + 6<span class="hljs-selector-class"><span class="hljs-selector-class">.99</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq_printf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 5<span class="hljs-selector-class"><span class="hljs-selector-class">.77</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq_put_decimal_ull</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.94</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">strlen</span></span> + 1<span class="hljs-selector-class"><span class="hljs-selector-class">.42</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">num_to_str</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 5<span class="hljs-selector-class"><span class="hljs-selector-class">.73</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">cpuset_task_status_allowed</span></span> + <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq_printf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 5<span class="hljs-selector-class"><span class="hljs-selector-class">.37</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">render_cap_t</span></span> + 5<span class="hljs-selector-class"><span class="hljs-selector-class">.31</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq_printf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 5<span class="hljs-selector-class"><span class="hljs-selector-class">.25</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">render_sigset_t</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.84</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq_putc</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.73</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">task_pid_nr_ns</span></span> + 0<span class="hljs-selector-class"><span class="hljs-selector-class">.63</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">lock_task_sighand</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.53</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">hugetlb_report_usage</span></span> + 0<span class="hljs-selector-class"><span class="hljs-selector-class">.68</span></span>% _<span class="hljs-selector-tag"><span class="hljs-selector-tag">copy_to_user</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.10</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">number</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.05</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">seq_put_decimal_ull</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.84</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">vsnprintf</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.79</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">format_decode</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.73</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">syscall_return_via_sysret</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.52</span></span>% 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">xfffffe000003201b</span></span> + 20<span class="hljs-selector-class"><span class="hljs-selector-class">.95</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">GI___libc_open</span></span> + 6<span class="hljs-selector-class"><span class="hljs-selector-class">.44</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">getdents64</span></span> + 4<span class="hljs-selector-class"><span class="hljs-selector-class">.10</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">close</span></span></code> </pre> <br><p>  Pode-se observar que apenas cerca de 60% do tempo gasto na chamada do sistema read ().  Se você observar o perfil mais de perto, verifica-se que 45% do tempo é usado dentro das funções do kernel seq_printf, seq_put_decimal_ull.  Portanto, a conversão do formato binário para o texto é uma operação bastante cara.  O que suscita a pergunta bem fundamentada: realmente precisamos de uma interface de texto para extrair dados do kernel?  Com que frequência os usuários desejam trabalhar com dados brutos?  E por que os utilitários top e ps têm que converter esses dados de texto novamente em binários? </p><br><p>  Provavelmente seria interessante saber quanto mais rápido a saída seria se os dados binários fossem usados ​​diretamente e se três chamadas do sistema não fossem necessárias. </p><br><p>  Já houve tentativas de criar essa interface.  Em 2004, tentamos usar o mecanismo netlink. </p><br><pre> <code class="hljs markdown">[<span class="hljs-string"><span class="hljs-string">0/2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">ANNOUNCE</span></span>] nproc: netlink access to /proc information (https://lwn.net/Articles/99600/) nproc is an attempt to address the current problems with /proc. In short, it exposes the same information via netlink (implemented for a small subset).</code> </pre> <br><p>  Infelizmente, a comunidade não demonstrou muito interesse neste trabalho.  Uma das últimas tentativas de corrigir a situação ocorreu há dois anos. </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">PATCH 0/15</span></span>] task_diag: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">add</span></span></span><span class="hljs-function"> a new </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">interface</span></span></span><span class="hljs-function"> to </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> information about </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">https://lwn.net/Articles/</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">683371</span></span></span></span><span class="hljs-function"><span class="hljs-params">/</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  A interface task-diag é baseada nos seguintes princípios: </p><br><ul><li>  Transação: enviou uma solicitação, recebeu uma resposta; </li><li>  O formato das mensagens está na forma de netlink (o mesmo que a interface sock_diag: binária e extensível); </li><li>  A capacidade de solicitar informações sobre muitos processos em uma chamada; </li><li>  Agrupamento otimizado de atributos (qualquer atributo do grupo não deve aumentar o tempo de resposta). </li></ul><br><p>  Essa interface foi apresentada em várias conferências.  Foi integrado ao pstools, aos utilitários CRIU e David Ahern integrou task_diag ao perf como um experimento. </p><br><p>  A comunidade de desenvolvimento do kernel se interessou pela interface task_diag.  O assunto principal da discussão foi a escolha do transporte entre o kernel e o espaço do usuário.  A idéia inicial de usar soquetes netlink foi rejeitada.  Em parte devido a problemas não resolvidos no código do mecanismo netlink e em parte porque muitas pessoas pensam que a interface netlink foi projetada exclusivamente para o subsistema de rede.  Em seguida, foi proposto o uso de arquivos transacionais dentro do procfs, ou seja, o usuário abre o arquivo, grava a solicitação nele e, em seguida, simplesmente lê a resposta.  Como sempre, havia oponentes dessa abordagem.  Uma solução que todos gostariam até que fosse encontrada. </p><br><p>  Vamos comparar o desempenho de task_diag com procfs. </p><br><p>  O mecanismo task_diag possui um utilitário de teste adequado para nossos experimentos.  Suponha que desejemos solicitar identificadores de processo e seus direitos.  Abaixo está a saída para um processo: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> ./task_diag_all one <span class="hljs-literal"><span class="hljs-literal">-c</span></span> <span class="hljs-literal"><span class="hljs-literal">-p</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span><span class="hljs-variable"><span class="hljs-variable">$</span></span> pid <span class="hljs-number"><span class="hljs-number">2305</span></span> tgid <span class="hljs-number"><span class="hljs-number">2305</span></span> ppid <span class="hljs-number"><span class="hljs-number">2299</span></span> sid <span class="hljs-number"><span class="hljs-number">2305</span></span> pgid <span class="hljs-number"><span class="hljs-number">2305</span></span> comm bash uid: <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> gid: <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-number"><span class="hljs-number">1000</span></span> CapInh: <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> CapPrm: <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> CapEff: <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> CapBnd: <span class="hljs-number"><span class="hljs-number">0000003</span></span>fffffffff</code> </pre> <br><p>  E agora, para todos os processos no sistema, ou seja, a mesma coisa que fizemos no experimento procfs quando lemos o arquivo / proc / pid / status: </p><br><pre> <code class="hljs pgsql">$ <span class="hljs-type"><span class="hljs-type">time</span></span> ./task_diag_all <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> -c <span class="hljs-type"><span class="hljs-type">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.048</span></span>s <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.001</span></span>s sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.046</span></span>s</code> </pre> <br><p>  Foram necessários apenas 0,05 segundos para obter os dados para construir a árvore do processo.  E com o procfs, foram necessários 0,177 segundos para abrir um arquivo para cada processo e sem a leitura dos dados. </p><br><p>  Saída Perf para a interface task_diag: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 82<span class="hljs-selector-class"><span class="hljs-selector-class">.24</span></span>% 0<span class="hljs-selector-class"><span class="hljs-selector-class">.00</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">task_diag_all</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[kernel.vmlinux]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[k]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">entry_SYSCALL_64_fastpath</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">entry_SYSCALL_64_fastpath</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 81<span class="hljs-selector-class"><span class="hljs-selector-class">.84</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">sys_read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vfs_read</span></span> __<span class="hljs-selector-tag"><span class="hljs-selector-tag">vfs_read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">proc_reg_read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">task_diag_read</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">taskdiag_dumpit</span></span> + 33<span class="hljs-selector-class"><span class="hljs-selector-class">.84</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">next_tgid</span></span> 13<span class="hljs-selector-class"><span class="hljs-selector-class">.06</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">task_pid_nr_ns</span></span> + 6<span class="hljs-selector-class"><span class="hljs-selector-class">.63</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">ptrace_may_access</span></span> + 5<span class="hljs-selector-class"><span class="hljs-selector-class">.68</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">from_kuid_munged</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 4<span class="hljs-selector-class"><span class="hljs-selector-class">.19</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">get_task_comm</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.90</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">strncpy</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.29</span></span>% _<span class="hljs-selector-tag"><span class="hljs-selector-tag">raw_spin_lock</span></span> 3<span class="hljs-selector-class"><span class="hljs-selector-class">.03</span></span>% __<span class="hljs-selector-tag"><span class="hljs-selector-tag">nla_reserve</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.73</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">nla_reserve</span></span> + 1<span class="hljs-selector-class"><span class="hljs-selector-class">.30</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">skb_copy_datagram_iter</span></span> + 1<span class="hljs-selector-class"><span class="hljs-selector-class">.21</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">from_kgid_munged</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.12</span></span>% <span class="hljs-selector-tag"><span class="hljs-selector-tag">strncpy</span></span></code> </pre> <br><p>  Não há nada interessante na listagem em si, exceto pelo fato de não haver funções óbvias adequadas para otimização. </p><br><p>  Vejamos a saída perf ao ler informações sobre todos os processos no sistema: </p><br><pre> <code class="hljs pgsql"> $ perf trace -s ./task_diag_all <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> -c -q <span class="hljs-keyword"><span class="hljs-keyword">Summary</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> events: task_diag_all (<span class="hljs-number"><span class="hljs-number">54326</span></span>), <span class="hljs-number"><span class="hljs-number">185</span></span> events, <span class="hljs-number"><span class="hljs-number">95.4</span></span>% syscall calls total min avg max stddev (msec) (msec) (msec) (msec) (%) <span class="hljs-comment"><span class="hljs-comment">--------------- -------- --------- --------- --------- --------- ------ read 49 40.209 0.002 0.821 4.126 9.50% mmap 11 0.051 0.003 0.005 0.007 9.94% mprotect 8 0.047 0.003 0.006 0.009 10.42% openat 5 0.042 0.005 0.008 0.020 34.86% munmap 1 0.014 0.014 0.014 0.014 0.00% fstat 4 0.006 0.001 0.002 0.002 10.47% access 1 0.006 0.006 0.006 0.006 0.00% close 4 0.004 0.001 0.001 0.001 2.11% write 1 0.003 0.003 0.003 0.003 0.00% rt_sigaction 2 0.003 0.001 0.001 0.002 15.43% brk 1 0.002 0.002 0.002 0.002 0.00% prlimit64 1 0.001 0.001 0.001 0.001 0.00% arch_prctl 1 0.001 0.001 0.001 0.001 0.00% rt_sigprocmask 1 0.001 0.001 0.001 0.001 0.00% set_robust_list 1 0.001 0.001 0.001 0.001 0.00% set_tid_address 1 0.001 0.001 0.001 0.001 0.00%</span></span></code> </pre> <br><p>  Para procfs, precisamos fazer mais de 150.000 chamadas de sistema para obter informações sobre todos os processos e para task_diag - um pouco mais de 50. </p><br><p>  Vamos olhar para situações da vida real.  Por exemplo, queremos exibir uma árvore de processos junto com argumentos de linha de comando para cada um.  Para fazer isso, precisamos extrair o pid do processo, o pid de seu pai e os argumentos da linha de comando. </p><br><p>  Para a interface task_diag, o programa envia uma solicitação para obter todos os parâmetros de uma vez: </p><br><pre> <code class="hljs go">$ time ./task_diag_all all --cmdline -q <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.096s</span></span> user <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.006s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.090s</span></span></code> </pre> <br><p>  Para os procfs originais, precisamos ler / proc // status e / proc // cmdline para cada processo: <br></p><pre> <code class="hljs go">$ time ./task_proc_all status tasks: <span class="hljs-number"><span class="hljs-number">50278</span></span> <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.463s</span></span> user <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.030s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.427s</span></span></code> </pre> <br><pre> <code class="hljs go">$ time ./task_proc_all cmdline tasks: <span class="hljs-number"><span class="hljs-number">50281</span></span> <span class="hljs-built_in"><span class="hljs-built_in">real</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.270s</span></span> user <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.028s</span></span> sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.237s</span></span></code> </pre> <br><p>  É fácil notar que task_diag é 7 vezes mais rápido que procfs (0,096 contra 0,27 + 0,46).  Normalmente, uma melhoria de desempenho de vários por cento já é um bom resultado, mas aqui a velocidade aumentou quase uma ordem de magnitude. </p><br><p>  Também vale a pena mencionar que a criação de objetos internos do kernel também afeta muito o desempenho.  Especialmente quando o subsistema de memória está sob carga pesada.  Compare o número de objetos criados para procfs e task_diag: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> perf trace -<span class="hljs-literal"><span class="hljs-literal">-event</span></span> <span class="hljs-string"><span class="hljs-string">'kmem:*alloc*'</span></span> ./task_proc_all status <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> | grep kmem | wc <span class="hljs-literal"><span class="hljs-literal">-l</span></span> <span class="hljs-number"><span class="hljs-number">58184</span></span> <span class="hljs-variable"><span class="hljs-variable">$</span></span> perf trace -<span class="hljs-literal"><span class="hljs-literal">-event</span></span> <span class="hljs-string"><span class="hljs-string">'kmem:*alloc*'</span></span> ./task_diag_all all <span class="hljs-literal"><span class="hljs-literal">-q</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> | grep kmem | wc <span class="hljs-literal"><span class="hljs-literal">-l</span></span> <span class="hljs-number"><span class="hljs-number">188</span></span></code> </pre> <br><p>  E também é necessário descobrir quantos objetos são criados ao iniciar um processo simples, por exemplo, o verdadeiro utilitário: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> perf trace -<span class="hljs-literal"><span class="hljs-literal">-event</span></span> <span class="hljs-string"><span class="hljs-string">'kmem:*alloc*'</span></span> true <span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&amp;<span class="hljs-number"><span class="hljs-number">1</span></span> | wc <span class="hljs-literal"><span class="hljs-literal">-l</span></span> <span class="hljs-number"><span class="hljs-number">94</span></span></code> </pre> <br><p>  O Procfs cria 600 vezes mais objetos que task_diag.  Essa é uma das razões pelas quais o procfs funciona tão mal quando a carga da memória é pesada.  Pelo menos, portanto, vale a pena otimizá-lo. </p><br><p>  Esperamos que o artigo atraia mais desenvolvedores para otimizar o estado procfs do subsistema do kernel. </p><br><p>  Muito obrigado a David Ahern, Andy Lutomirski, Stephen Hemming, Oleg Nesterov, W. Trevor King, Arnd Bergmann, Eric W. Biederman e muitos outros que ajudaram a desenvolver e melhorar a interface task_diag. </p><br><p>  Agradecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">cromer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">k001</a> e Stanislav Kinsbursky pela ajuda na redação deste artigo. </p><br><h1 id="ssylki">  Referências </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/avagin/linux-task-diag/tree/v4.16-task-diag-20180427/tools/testing/selftests/task_diag</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://lwn.net/Articles/685791/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.slideshare.net/KirKolyshkin/time-to-rethink-proc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.slideshare.net/kolyshkin/speeding-up-ps-and-top</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://blog.linuxplumbersconf.org/2016/ocw/system/presentations/4599/original/Netlink-issues.pdf</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418715/">https://habr.com/ru/post/pt418715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418705/index.html">Futex Basics</a></li>
<li><a href="../pt418707/index.html">KDispatcher - Eventbus leve e conveniente para o uso diário</a></li>
<li><a href="../pt418709/index.html">Precisa se forçar: drivers e barreiras de interface</a></li>
<li><a href="../pt418711/index.html">Registros gerenciados por token 1.0</a></li>
<li><a href="../pt418713/index.html">Jogo para melhorar a qualidade da Wikipedia</a></li>
<li><a href="../pt418717/index.html">Fantasmas Unicode</a></li>
<li><a href="../pt418721/index.html">Lendas da engenharia de vírus: o começo da guerra</a></li>
<li><a href="../pt418723/index.html">Patch AndroidX</a></li>
<li><a href="../pt418725/index.html">Constante mágica</a></li>
<li><a href="../pt418727/index.html">Onde e como participar de incorporações gráficas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>