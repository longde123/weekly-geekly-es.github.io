<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👎🏿 🌥️ 👲🏻 Kotlin DSL: Theorie und Praxis ⏮️ 🤰🏼 🐆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Entwickeln von Anwendungstests ist keine angenehme Erfahrung. Dieser Prozess dauert lange, erfordert viel Konzentration und ist äußerst gefragt. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin DSL: Theorie und Praxis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/416725/">  Das Entwickeln von Anwendungstests ist keine angenehme Erfahrung.  Dieser Prozess dauert lange, erfordert viel Konzentration und ist äußerst gefragt.  Die Kotlin-Sprache bietet eine Reihe von Tools, mit denen Sie ganz einfach Ihre eigene problemorientierte Sprache (DSL) erstellen können.  Es gibt Erfahrung, als Kotlin DSL Builder und statische Methoden zum Testen des Ressourcenplanungsmoduls ersetzte, was das Hinzufügen neuer Tests und das Unterstützen alter Tests aus einer Routine zu einem unterhaltsamen Prozess machte. <br><br>  Im Verlauf des Artikels werden wir alle wichtigen Tools aus dem Entwicklerarsenal analysieren und analysieren, wie sie zur Lösung von Testproblemen kombiniert werden können.  Wir werden den gesamten Weg von der Entwicklung des idealen Tests bis zur Einführung des ungefährsten, saubersten und verständlichsten Tests für das auf Kotlin basierende Ressourcenplanungssystem gehen. <br><br>  Der Artikel ist nützlich für praktizierende Ingenieure, diejenigen, die Kotlin als eine Sprache zum bequemen Schreiben kompakter Tests betrachten, und diejenigen, die den Testprozess in ihrem Projekt verbessern möchten. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Dieser Artikel basiert auf einer Präsentation von Ivan Osipov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">i_osipov</a> ) auf der JPoint-Konferenz.  Weitere Erzählungen werden in seinem Namen durchgeführt.  Ivan arbeitet als Programmierer bei Haulmont.  Das Hauptprodukt des Unternehmens ist CUBA, eine Plattform für die Entwicklung von Unternehmens- und verschiedenen Webanwendungen.  Auf dieser Plattform werden insbesondere Outsourcing-Projekte durchgeführt, darunter kürzlich ein Projekt im Bildungsbereich, bei dem Ivan einen Zeitplan für eine Bildungseinrichtung aufstellte.  So kam es, dass Ivan in den letzten drei Jahren auf die eine oder andere Weise mit Planern zusammengearbeitet hat und speziell in Haulmont diesen Planer seit einem Jahr testet. <br><a name="habracut"></a><br>  Für diejenigen, die Beispiele ausführen möchten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">halten Sie einen Link zu GitHub</a> .  Unter dem Link finden Sie den gesamten Code, den wir heute analysieren, ausführen und schreiben werden.  Öffnen Sie den Code und gehen Sie! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec3/fa3/670/ec3fa3670fd1c8a3cf7222f7e746933c.jpg"><br><br>  Heute werden wir diskutieren: <br><br><ul><li>  Was sind problemorientierte Sprachen? <br></li><li>  eingebaute problemorientierte Sprachen; <br></li><li>  Aufbau eines Zeitplans für eine Bildungseinrichtung; <br></li><li>  wie alles mit Kotlin getestet wird. <br></li></ul><br>  Heute werde ich ausführlich über die Tools sprechen, die wir in der Sprache haben, Ihnen einige Demos zeigen und den gesamten Test von Anfang bis Ende schreiben.  Gleichzeitig möchte ich objektiver sein, daher werde ich auf einige der Nachteile eingehen, die ich während der Entwicklung für mich selbst festgestellt habe. <br><br>  Lassen Sie uns zunächst über das Modul zur Erstellung von Zeitplänen sprechen.  Die Erstellung des Zeitplans erfolgt also in mehreren Schritten.  Jeder dieser Schritte muss separat getestet werden.  Sie müssen verstehen, dass wir trotz der Tatsache, dass die Schritte unterschiedlich sind, ein gemeinsames Datenmodell haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/031/be4/27d/031be427d58c5073a3bc619cbed65792.jpg"><br><br>  Dieser Prozess kann wie folgt dargestellt werden: Am Eingang gibt es einige Daten mit einem gemeinsamen Modell, am Ausgang gibt es einen Zeitplan.  Die Daten werden validiert, gefiltert und anschließend Trainingsgruppen erstellt.  Dies bezieht sich auf den Themenbereich des Stundenplans für die Bildungseinrichtung.  Basierend auf den konstruierten Gruppen und auf der Grundlage einiger anderer Daten platzieren wir die Lektion.  Heute werden wir nur über die letzte Phase sprechen - über die Platzierung von Klassen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f64/032/4b1/f640324b1a2ff556a4da892822847a9c.jpg"><br><br>  Ein bisschen über das Testen des Schedulers. <br><br>  Zunächst müssen, wie Sie bereits verstanden haben, die verschiedenen Stufen separat getestet werden.  Man kann einen mehr oder weniger standardmäßigen Prozess zum Starten des Tests herausgreifen: Es gibt eine Dateninitialisierung, es gibt einen Scheduler-Start, es gibt eine Überprüfung der Ergebnisse dieses Schedulers selbst.  Es gibt eine große Anzahl unterschiedlicher Geschäftsfälle, die abgedeckt werden müssen, und verschiedene Situationen, die berücksichtigt werden müssen, damit diese Situationen beim Erstellen eines Zeitplans ebenfalls bestehen bleiben. <br><br>  Ein Modell kann manchmal gewichtig sein. Um eine einzelne Entität zu erstellen, müssen fünf oder mehr zusätzliche Entitäten initialisiert werden.  Insgesamt wird also eine große Menge an Code erhalten, die wir für jeden Test immer wieder schreiben.  Die Unterstützung solcher Tests nimmt viel Zeit in Anspruch.  Wenn Sie das Modell aktualisieren möchten und dies manchmal vorkommt, wirkt sich der Umfang der Änderungen auf die Tests aus. <br><br>  Schreiben wir einen Test: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fda/0f5/94d/fda0f594d14b8043054bcae7fe3315ad.jpg"><br><br>  Schreiben wir den einfachsten Test, damit Sie das Bild allgemein verstehen. <br>  Was fällt Ihnen zuerst ein, wenn Sie über das Testen nachdenken?  Vielleicht sind dies einige primitive Tests dieser Art: Sie erstellen eine Klasse, erstellen eine Methode darin und markieren sie mit dem Annotationstest.  Infolgedessen nutzen wir die Funktionen von JUnit und initialisieren einige Daten, Standardwerte und dann testspezifische Werte, machen dasselbe für den Rest des Modells und erstellen schließlich ein Scheduler-Objekt, übertragen unsere Daten darauf. Wir beginnen, wir erhalten Ergebnisse und wir überprüfen sie.  Mehr oder weniger Standardverfahren.  Aber es gibt offensichtlich eine Codeduplizierung.  Das erste, was mir in den Sinn kommt, ist die Fähigkeit, alles in statische Methoden umzuwandeln.  Da es eine Reihe von Standardwerten gibt, können Sie diese ausblenden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/521/543/590/521543590a00c6101abd4fcefd345e04.jpg"><br><br>  Dies ist ein guter erster Schritt zur Reduzierung von Doppelarbeit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7f/c57/11c/c7fc5711ccf2a4e9dfb626ea64cffb9b.jpg"><br><br>  Wenn Sie sich das ansehen, verstehen Sie, dass ich das Modell kompakter halten möchte.  Hier haben wir ein Builder-Muster, in dem irgendwo unter der Haube der Standardwert initialisiert wird und die testspezifischen Werte genau dort initialisiert werden.  Es wird besser, aber wir schreiben immer noch den Boilerplate-Code und wir schreiben ihn jedes Mal neu.  Stellen Sie sich 200 Tests vor - Sie müssen diese drei Zeilen 200 Mal schreiben.  Natürlich möchte ich das irgendwie loswerden.  Bei der Entwicklung der Idee stoßen wir an eine bestimmte Grenze.  So können wir beispielsweise generell für alles einen Pattern Builder erstellen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/259/e9b/7a3/259e9b7a39e84a41466572b38afc280d.jpg"><br><br>  Sie können einen Planer von Grund auf bis zum Ende erstellen, alle benötigten Werte festlegen, mit der Planung beginnen und alles ist großartig.  Wenn Sie sich dieses Beispiel genauer ansehen und es detailliert analysieren, stellt sich heraus, dass viel unnötiger Code geschrieben wird.  Ich möchte die Tests lesbarer machen, damit Sie einen Blick darauf werfen und sofort verstehen können, ohne sich mit den Mustern usw. zu befassen. <br><br>  Wir haben also unnötigen Code.  Einfache Mathematik legt nahe, dass es 55% mehr Buchstaben gibt, als wir brauchen, und ich würde gerne irgendwie davon wegkommen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d55/610/ef7/d55610ef71d368b8d16c1fdef35cd2c5.jpg"><br><br>  Nach einiger Zeit stellt sich heraus, dass die Unterstützung für unsere Tests teurer ist, da Sie mehr Code unterstützen müssen.  Wenn wir keine Anstrengungen unternehmen, lässt die Lesbarkeit manchmal zu wünschen übrig oder sie stellt sich als akzeptabel heraus, aber wir möchten noch besser.  Vielleicht werden wir später anfangen, eine Art Framework, Bibliotheken, hinzuzufügen, um das Schreiben von Tests zu vereinfachen.  Aus diesem Grund erhöhen wir den Einstieg in das Testen unserer Anwendung.  Hier haben wir eine bereits komplizierte Anwendung, der Einstieg in die Tests ist erheblich und wir erhöhen sie noch weiter. <br><br><h2>  Perfekter Test </h2><br>  Es ist toll zu sagen, wie schlecht alles ist, aber lassen Sie uns darüber nachdenken, wie gut es wäre.  Ein ideales Beispiel, das wir als Ergebnis erhalten möchten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/7c5/f48/e2b7c5f48dbd065e95b1617ad10622ba.jpg"><br><br>  Stellen Sie sich vor, es gibt eine Erklärung, in der wir sagen, dass dies ein Test mit einem bestimmten Namen ist, und wir möchten ein Leerzeichen verwenden, um die Wörter im Namen zu trennen, nicht CamelCase.  Wir erstellen einen Zeitplan, wir haben einige Daten und die Ergebnisse des Planers werden überprüft.  Da wir hauptsächlich mit Java arbeiten und der gesamte Code der Hauptanwendung in dieser Sprache geschrieben ist, möchte ich kompatible Testfunktionen haben.  Ich möchte die Daten für den Leser so offensichtlich wie möglich initialisieren.  Ich möchte einige allgemeine Daten und einen Teil des Modells initialisieren, die wir benötigen.  Erstellen Sie beispielsweise Schüler und Lehrer und beschreiben Sie, wann sie verfügbar sind.  Dies ist unser perfektes Beispiel. <br><br><h2>  Domänenspezifische Sprache </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f81/c79/0a9/f81c790a921e43d645fc7380607cf8ea.jpg"><br><br>  Wenn man alles betrachtet, scheint es wie eine Art problemorientierte Sprache.  Sie müssen verstehen, was es ist und was der Unterschied ist.  Sprachen können in zwei Typen unterteilt werden: Allzwecksprachen (was wir ständig schreiben, absolut alle Aufgaben lösen und absolut alles bewältigen) und problemorientierte Sprachen.  So hilft uns beispielsweise SQL, Daten perfekt aus der Datenbank abzurufen, und einige andere Sprachen helfen auch, andere spezifische Probleme zu lösen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f8/e45/2f6/2f8e452f62f39f0f56a2c73e355dddcb.jpg"><br><br>  Eine Möglichkeit, problemorientierte Sprachen zu implementieren, sind eingebettete oder interne Sprachen.  Solche Sprachen werden auf der Basis einer Allzwecksprache implementiert.  Das heißt, mehrere Konstruktionen unserer Allzwecksprache bilden so etwas wie eine Basis - das verwenden wir, wenn wir mit einer problemorientierten Sprache arbeiten.  In diesem Fall ergibt sich natürlich in einer problemorientierten Sprache die Möglichkeit, alle Merkmale und Merkmale einer Allzwecksprache zu nutzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07f/4cb/57f/07f4cb57f84ba884bd558ee8e97202a2.jpg"><br><br>  Schauen Sie sich noch einmal unser perfektes Beispiel an und überlegen Sie, welche Sprache Sie wählen sollen.  Wir haben drei Möglichkeiten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1d/b21/4b3/d1db214b39b5620875350b382622e662.jpg"><br><br>  Die erste Option ist Groovy.  Eine wunderbare, dynamische Sprache, die sich beim Aufbau problemorientierter Sprachen bewährt hat.  Auch hier können Sie ein Beispiel für eine Build-Datei in Gradle geben, die viele von uns verwenden.  Es gibt auch Scala, die eine Vielzahl von Möglichkeiten bietet, etwas Eigenes umzusetzen.  Und schließlich gibt es Kotlin, das uns auch beim Aufbau einer problemorientierten Sprache hilft, und heute wird darüber diskutiert.  Ich würde keine Kriege züchten und Kotlin mit etwas anderem vergleichen wollen, sondern es bleibt auf deinem Gewissen.  Heute werde ich Ihnen zeigen, was Kotlin für die Entwicklung problemorientierter Sprachen hat.  Wenn Sie dies vergleichen und sagen möchten, dass eine Sprache besser ist, können Sie zu diesem Artikel zurückkehren und den Unterschied leicht erkennen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/2e7/29e/0502e729ebf030ea5e4d9f038a4b7cc6.jpg"><br><br>  Was gibt uns Kotlin für die Entwicklung einer problemorientierten Sprache? <br><br>  Erstens handelt es sich um eine statische Typisierung, die sich daraus ergibt.  In der Kompilierungsphase wird eine große Anzahl von Problemen erkannt, was erheblich spart, insbesondere wenn Sie keine Probleme mit der Syntax und dem Schreiben in Tests haben möchten. <br>  Dann gibt es ein großartiges Typinferenzsystem, das von Kotlin stammt.  Das ist wunderbar, weil es nicht nötig ist, immer wieder Typen zu schreiben, alles wird vom Compiler mit einem Knall angezeigt. <br><br>  Drittens gibt es eine hervorragende Unterstützung für die Entwicklungsumgebung, und dies ist nicht überraschend, da dasselbe Unternehmen die Hauptentwicklungsumgebung für heute erstellt und Kotlin. <br>  Schließlich können wir in DSL natürlich Kotlin verwenden.  Meiner subjektiven Meinung nach ist die Unterstützung von DSL viel einfacher als die Unterstützung von Utility-Klassen.  Wie Sie später sehen werden, ist die Lesbarkeit etwas besser als bei Buildern.  Was ich unter „besser“ verstehe: Sie erhalten etwas weniger Syntax, die Sie schreiben müssen - jemand, der Ihre problemorientierte Sprache liest, wird es schneller verstehen.  Schließlich macht das Schreiben Ihres Fahrrads viel mehr Spaß!  Tatsächlich ist die Implementierung einer problemorientierten Sprache jedoch viel einfacher als das Erlernen eines neuen Rahmens. <br><br>  Ich werde noch einmal an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zu GitHub</a> erinnern. Wenn Sie weitere Demos schreiben möchten, können Sie den Code vom Link abholen. <br><br><h2>  Das Ideal auf Kotlin entwerfen </h2><br>  Fahren wir mit der Gestaltung unseres Ideals fort, aber bereits bei Kotlin.  Schauen Sie sich unser Beispiel an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e3/695/850/5e3695850435a204b9cbb3b94f6f7635.png"><br><br>  Und schrittweise werden wir beginnen, es wieder aufzubauen. <br><br>  Wir haben einen Test, der sich in Kotlin in eine Funktion verwandelt, die mit Leerzeichen benannt werden kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03d/699/a71/03d699a71ecf86e0e5c03b7a6de57995.png"><br><br>  Wir werden es mit der Testanmerkung markieren, die uns von JUnit zur Verfügung steht.  In Kotlin können Sie die verkürzte Form zum Schreiben von Funktionen verwenden und durch <i>=</i> zusätzliche geschweifte Klammern für die Funktion selbst entfernen. <br><br>  Zeitplan wir verwandeln uns in einen Block.  Das gleiche passiert mit vielen Designs, da wir immer noch bei Kotlin arbeiten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7b/db9/656/a7bdb965641ca434f1eba5e7781b9b53.png"><br><br>  Fahren wir mit dem Rest fort.  Geschweifte Klammern erscheinen wieder, wir werden sie nicht los, aber versuchen zumindest, unserem Beispiel näher zu kommen.  Durch das Konstruieren von Konstruktionen mit Leerzeichen könnten wir uns irgendwie verfeinern und irgendwie anders machen, aber es scheint mir, dass es besser ist, die üblichen Methoden zu erstellen, die die Verarbeitung kapseln, aber im Allgemeinen ist dies für den Benutzer offensichtlich . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/378/6e6/eaf/3786e6eafdb8ebd14c344af30698df56.png"><br><br>  Unser Schüler verwandelt sich in einen Block, in dem wir mit Eigenschaften und Methoden arbeiten, und wir werden dies weiterhin mit Ihnen analysieren. <br><br><img width="600" src="https://habrastorage.org/getpro/habr/post_images/76b/a76/554/76ba76554585689a4c2562167fd26833.png"><br><br>  Endlich die Lehrer.  Hier haben wir einige verschachtelte Blöcke. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/deb/a5d/f0a/deba5df0a67a08566e07370bf2f70bc0.png"><br><br>  Im folgenden Code fahren wir mit den Überprüfungen fort.  Wir müssen die Kompatibilität mit Java-Sprachen überprüfen - und ja, Kotlin ist mit Java kompatibel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/09d/a05/8aa09da05c7c48282e01b0ea409e0f3c.png"><br><br><h2>  Arsenal der DSL-Entwicklung bei Kotlin </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/5f6/113/6ef/5f61136ef41733e6fb88c5ff17d6975f.jpg"><br><br>  Fahren wir mit der Liste der Tools fort, die wir haben.  Hier habe ich ein Tablet mitgebracht, vielleicht listet es alles auf, was zur Entwicklung problemorientierter Sprachen in Kotlin benötigt wird.  Sie können von Zeit zu Zeit zu ihr zurückkehren und ihr Gedächtnis auffrischen. <br><br>  Die Tabelle zeigt einen Vergleich der problemorientierten Syntax mit der üblichen Syntax, die in der Sprache verfügbar ist. <br><br><h2>  Lambdas in Kotlin </h2><br> <code>val lambda: () -&gt; Unit = { }</code> <br> <br>  Beginnen wir mit dem grundlegendsten Ziegelstein, den wir in Kotlin haben - das sind Lambdas. <br>  Mit Lambda-Typ meine ich heute nur einen funktionalen Typ.  Lambdas werden wie folgt bezeichnet: <code>( ) -&gt;  </code> . <br><br>  Wir initialisieren das Lambda mit Hilfe von geschweiften Klammern, in die wir einen Code schreiben können, der aufgerufen wird.  Das heißt, ein Lambda verbirgt diesen Code tatsächlich nur in sich.  Das Ausführen eines solchen Lambda sieht aus wie ein Funktionsaufruf, nur in Klammern. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a48/f4d/d49/a48f4dd497c8aa6b93ab2043e014ca02.jpg"><br><br>  Wenn wir einen Parameter übergeben wollen, müssen wir ihn zunächst im Typ beschreiben. <br>  Zweitens haben wir Zugriff auf die Standardkennung, die wir verwenden können. Wenn dies jedoch nicht zu uns passt, können wir unseren eigenen Parameternamen festlegen und diese verwenden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/194/fab/626/194fab62612fb71e6a5f148193ec1ff9.jpg"><br><br>  Gleichzeitig können wir die Verwendung dieses Parameters überspringen und den Unterstrich verwenden, um keine Bezeichner zu erzeugen.  In diesem Fall wäre es zum Ignorieren des Bezeichners möglich, überhaupt nichts zu schreiben, aber im allgemeinen Fall gibt es für mehrere Parameter das erwähnte "_". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ff/80e/de2/1ff80ede232393839186b9345065700c.jpg"><br><br>  Wenn wir mehr als einen Parameter übergeben möchten, müssen wir deren Bezeichner explizit definieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8d/d2b/952/c8dd2b952caa82b67157f41dc79535b0.jpg"><br><br>  Was passiert schließlich, wenn wir versuchen, das Lambda an eine Funktion zu übergeben und dort auszuführen?  In der anfänglichen Annäherung sieht es wie folgt aus: Wir haben eine Funktion, an die wir Lambda in geschweiften Klammern übergeben, und wenn in Kotlin Lambda als letzter Parameter geschrieben wird, können wir es aus diesen Klammern heraussetzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b80/d7c/0d8/b80d7c0d814f3c51a91f2c224707a2d5.jpg"><br><br>  Wenn in den Klammern nichts mehr vorhanden ist, können wir die Klammern entfernen.  Diejenigen, die mit Groovy vertraut sind, sollten damit vertraut sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/5dd/a95/74b5dda953b1df973a8d893f7a615195.jpg"><br><br>  Wo gilt das?  Absolut überall.  Das heißt, die sehr lockigen Klammern, über die wir bereits gesprochen haben, verwenden wir, das sind genau die Lambdas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/4bd/781/69e4bd781897ef0515384f81367899cc.jpg"><br><br>  Schauen wir uns nun eine der Lambdasorten an, ich nenne sie Lambdas mit Kontext.  Sie werden einige andere Namen finden, zum Beispiel Lambda mit Empfänger, und sie unterscheiden sich von gewöhnlichen Lambdas, wenn Sie einen Typ wie folgt deklarieren: Links fügen wir eine Kontextklasse hinzu, es kann eine beliebige Klasse sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/375/5b1/8bd3755b1085f3049a7ea32c7cc41f79.jpg"><br><br>  Wofür ist das?  Dies ist notwendig, damit wir innerhalb des Lambda Zugriff auf das Schlüsselwort this haben - dies ist das Schlüsselwort selbst. Es gibt Auskunft über unseren Kontext, dh über ein Objekt, das wir mit unserem Lambda verknüpft haben.  So können wir beispielsweise ein Lambda erstellen, das einen String ausgibt. Natürlich verwenden wir die String-Klasse, um einen Kontext zu deklarieren, und der Aufruf eines solchen Lambda sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d80/552/181/d80552181518f155fc596c1bb3ddf2aa.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/788/63d/b17/78863db1732d9b92bff62bf82060771a.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/a1b/038/770a1b0388cd2380c491cdf5ca8c344c.jpg"><br><br>  Wenn Sie einen Kontext als Parameter übergeben möchten, können Sie dies genauso gut tun.  Wir können den Kontext jedoch nicht vollständig vermitteln, dh ein Lambda mit einem Kontext erfordert Aufmerksamkeit!  - Kontext, ja.  Was passiert, wenn wir ein Lambda mit einem Kontext an eine Methode übergeben?  Hier sehen wir uns noch einmal unsere exec-Methode an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15b/f36/3d9/15bf363d94919f7c73d775c5d28c6c53.jpg"><br><br>  Benennen Sie es in die Student-Methode um - nichts hat sich geändert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e12/4cc/e3b/e124cce3bd7bdb776c3e946edf8ec52c.jpg"><br><br>  Also bewegen wir uns allmählich zu unserer Konstruktion, der Studentenkonstruktion, die unter den Klammern jede Initialisierung verbirgt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/286/8b3/eba2868b306f476c35df51d8af500335.jpg"><br><br>  Lass es uns herausfinden.  Wir haben eine Art Studentenfunktion, die ein Lambda mit dem Studentenkontext verbindet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3f/954/e2a/d3f954e2a7016ecf31a081559674d01f.jpg"><br><br>  Natürlich brauchen wir Kontext. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/4d8/3be/3624d83be81ee01223ad758e9e81c94d.jpg"><br><br>  Hier erstellen wir ein Objekt und führen dieses Lambda darauf aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cab/d4a/940/cabd4a940deacfcdcb680c4916b29eae.jpg"><br><br>  Infolgedessen können wir auch einige Standardwerte initialisieren, bevor wir das Lambda starten, sodass wir alles kapseln, was wir für die Funktion benötigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b4/572/421/0b457242103fc70de806c9de62234135.jpg"><br><br>  Aus diesem Grund erhalten wir im Lambda Zugriff auf das Schlüsselwort this. Deshalb gibt es wahrscheinlich Lambdas mit Kontext. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1b/819/fdb/b1b819fdb7488092550b2ac72265cd72.jpg"><br><br>  Natürlich können wir dieses Schlüsselwort loswerden und haben die Möglichkeit, solche Konstruktionen zu schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50d/dbc/492/50ddbc4920ffb871918ce7c063a874a2.jpg"><br><br>  Auch wenn wir nicht nur proprietäre, sondern auch einige Methoden haben, die wir auch nennen können, sieht es ziemlich natürlich aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b72/155/316/b72155316d99a7e4816d1234644b761b.jpg"><br><br><h2>  Anwendung </h2><br>  Alle diese Lambdas im Code sind Kontext-Lambdas.  Es gibt eine Vielzahl von Kontexten, die sich auf die eine oder andere Weise überschneiden und es uns ermöglichen, unsere problemorientierte Sprache aufzubauen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/83a/f30/2ff/83af302ff3c0a85db220c70f0d567743.jpg"><br><br>  Zusammenfassend die Lambdas - wir haben gewöhnliche Lambdas, die es mit dem Kontext gibt, und diese und andere können verwendet werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcc/1ac/dfc/fcc1acdfc43284500c38884d88212877.jpg"><br><br><h2>  Betreiber </h2><br>  Kotlin verfügt über eine begrenzte Anzahl von Operatoren, die Sie mithilfe von Konventionen und dem Schlüsselwort operator überschreiben können. <br><br>  Schauen wir uns den Lehrer und seine Zugänglichkeit an.  Nehmen wir an, der Lehrer arbeitet montags ab 8 Uhr für 1 Stunde.  Wir möchten auch sagen, dass es zusätzlich zu dieser einen Stunde ab 13.00 Uhr für 1 Stunde funktioniert.  Ich möchte dies mit dem Operator <b>+</b> ausdrücken.  Wie kann das gemacht werden? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17b/360/9ab/17b3609ab2ebd28cf27f906934536e05.jpg"><br><br>  Es gibt eine Verfügbarkeitsmethode, die ein Lambda mit einem <code>AvailabilityTable</code> Kontext akzeptiert.  Dies bedeutet, dass es eine Klasse gibt, die so heißt, und die Montag-Methode wird in dieser Klasse deklariert.  Diese Methode gibt <code>DayPointer</code> seitdem zurück  Sie müssen unseren Operator an etwas anhängen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/721/aea/73d/721aea73d36a41cf3dbecd328b1f5ab5.jpg"><br><br>  Lassen Sie uns herausfinden, was DayPointer ist.  Dies ist ein Hinweis auf die Verfügbarkeitstabelle eines Lehrers, und der Tag steht auf seinem Zeitplan.  Wir haben auch eine Zeitfunktion, die einige Zeilen irgendwie in ganzzahlige Indizes verwandelt: In Kotlin haben wir dafür eine <code>IntRange</code> Klasse. <br><br>  Links ist <code>DayPointer</code> , rechts ist Zeit, und wir möchten sie mit dem Operator <b>+</b> kombinieren.  Dazu können Sie unseren Operator in der <code>DayPointer</code> Klasse <code>DayPointer</code> .  Es werden verschiedene Werte vom Typ Int benötigt und <code>DayPointer</code> damit wir unser DSL immer wieder <code>DayPointer</code> können. <br>  Schauen wir uns nun das Schlüsseldesign an, mit dem alles beginnt und mit dem unser DSL beginnt.  Die Implementierung ist etwas anders, und jetzt werden wir es herausfinden. <br>  Kotlin hat ein Singleton-Konzept, das direkt in die Sprache integriert ist.  Zu diesem <code>object</code> wird anstelle des Schlüsselworts class das Schlüsselwort <code>object</code> verwendet.  Wenn wir eine Methode in einem Singleton erstellen, können wir so darauf zugreifen, dass keine Instanz dieser Klasse erneut erstellt werden muss.  Wir bezeichnen es einfach als statische Methode in einer Klasse. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3d/226/065/d3d2260651fc4049ec8d3e6878a0cc51.jpg"><br><br>  Wenn Sie sich das Ergebnis der Dekompilierung ansehen (dh in der Entwicklungsumgebung auf Extras -&gt; Kotlin -&gt; Kotlin-Bytecode anzeigen -&gt; Dekompilieren klicken), sehen Sie die folgende Singleton-Implementierung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c6/8c9/577/3c68c957760612b06a5b008c734ddb33.jpg"><br><br>  Dies ist nur eine gewöhnliche Klasse, und hier passiert nichts Übernatürliches. <br>  Ein weiteres interessantes Tool ist die <code>invoke</code> Anweisung.  Stellen Sie sich vor, wir haben eine Klasse A, wir haben ihre Instanz, und wir möchten diese Instanz ausführen, dh Klammern für ein Objekt dieser Klasse aufrufen, und dies können wir dank des <code>invoke</code> tun. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25f/3a1/f95/25f3a1f95c8c61dcb4937822bd9578e6.jpg"><br><br>  In Klammern können wir die Aufrufmethode aufrufen und haben einen Operator-Modifikator.  Wenn wir diesem Operator ein Lambda mit Kontext übergeben, erhalten wir eine solche Konstruktion. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6b/61d/675/b6b61d67518cb1dc730bce8e309ae0dc.jpg"><br><br>  Jedes Mal Instanzen zu erstellen ist eine andere Aktivität, sodass wir vorheriges und aktuelles Wissen kombinieren können. <br><br>  Lassen Sie uns einen Singleton erstellen, ihn als Zeitplan bezeichnen, innerhalb dessen wir den Aufrufoperator deklarieren, innerhalb einen Kontext erstellen und ein Lambda mit dem hier erstellten Kontext akzeptieren.  Es stellt sich heraus, dass es sich um einen einzelnen Einstiegspunkt in unser DSL handelt, und als Ergebnis erhalten wir den gleichen Konstruktionsplan mit geschweiften Klammern. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53a/41f/7d8/53a41f7d8e9067b6ce850045e745fb4f.jpg"><br><br>  Nun, wir haben über den Zeitplan gesprochen. Schauen wir uns unsere Schecks an. <br>  Wir haben Lehrer, wir haben eine Art Zeitplan erstellt, und wir möchten überprüfen, ob im Zeitplan dieses Lehrers an einem bestimmten Tag in einer bestimmten Lektion ein Objekt vorhanden ist, mit dem wir arbeiten werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22d/0e3/9ef/22d0e39ef38ceb43fd60654de876691b.jpg"><br><br>  Ich möchte eckige Klammern verwenden und auf unseren Zeitplan so zugreifen, dass er optisch wie der Zugriff auf Arrays aussieht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e6/895/b9e/1e6895b9ed089ed99d4c2639e6e1f578.jpg"><br><br>  Dies kann mit dem Operator erfolgen: get / set: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/815/9f5/a86/8159f5a8628b6c5bb21d219e395ea32b.jpg"><br><br>  Hier machen wir nichts Neues, folgen Sie einfach den Konventionen.  Im Fall des Set-Operators müssen wir die Werte zusätzlich an unsere Methode übergeben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c8/03d/2f2/4c803d2f20ed8b7f79e308d47b734bd9.jpg"><br><br>  Die eckigen Klammern zum Lesen werden also zu get, und die eckigen Klammern, durch die wir sie zuweisen, werden zu set. <br><br><h2>  Demo: Objekt, Operatoren </h2><br>  Sie können entweder weiteren Text lesen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Video hier ansehen</a> .  Das Video hat eine eindeutige Startzeit, es ist jedoch keine Endzeit angegeben. Grundsätzlich können Sie es nach dem Start vor dem Ende des Artikels ansehen. <br><br>  Der Einfachheit halber werde ich kurz auf die Essenz des Videos direkt im Text eingehen. <br><br>  Schreiben wir einen Test.  Wir haben ein Zeitplanobjekt, und wenn wir über Strg + b zu dessen Implementierung gehen, werden wir alles sehen, worüber ich zuvor gesprochen habe. <br><br><img src="https://habrastorage.org/webt/uk/pg/0d/ukpg0djbwn_hfyq4a7g9usa65aa.png"><br><br>  Innerhalb des Zeitplanobjekts möchten wir die Daten initialisieren, dann einige Überprüfungen durchführen, und innerhalb der Daten möchten wir Folgendes sagen: <br><br><ul><li>  Unsere Schule ist ab 8 Uhr morgens geöffnet. <br></li><li>  Es gibt eine Reihe von Elementen, für die wir einen Zeitplan erstellen werden. <br></li><li>  Es gibt einige Lehrer, die eine Art Zugänglichkeit beschrieben haben. <br></li><li>  einen Studenten haben; <br></li><li>  Grundsätzlich müssen wir für einen Studenten nur sagen, dass er ein bestimmtes Fach studiert. <br></li></ul><br><img src="https://habrastorage.org/webt/v_/mq/ia/v_mqia50010hyrqza7zubejj62e.png"><br><br>  Und hier zeigt sich einer der Nachteile von Kotlin und problemorientierten Sprachen im Prinzip: Es ist ziemlich schwierig, einige Objekte zu adressieren, die wir zuvor erstellt haben.  In dieser Demo werde ich alles als Indizes angeben, dh Rus ist Index 0, Mathe ist Index 2. Und der Lehrer führt natürlich auch etwas.  Er geht nicht nur zur Arbeit, sondern beschäftigt sich mit etwas.  Für Leser dieses Artikels möchte ich eine weitere Option für die Adressierung anbieten. Sie können eindeutige Tags erstellen und Entitäten in Map speichern. Wenn Sie auf eines davon zugreifen müssen, können Sie es immer nach Tag suchen.  Zerlegen Sie das DSL weiter. <br><br>  Hier ist Folgendes zu beachten: Erstens haben wir den Operator +, zu dessen Implementierung wir auch sehen können, dass wir tatsächlich die DayPointer-Klasse haben, die uns hilft, all dies mit Hilfe des Operators zu binden. <br><br>  Und dank der Tatsache, dass wir Zugriff auf den Kontext haben, sagt uns die Entwicklungsumgebung, dass wir in unserem Kontext über dieses Schlüsselwort Zugriff auf eine Sammlung haben und diese verwenden werden. <br><br><img src="https://habrastorage.org/webt/l_/3q/uw/l_3quwu2xaqlxikn71jhpnnero4.png"><br><br>  Das heißt, wir haben eine Sammlung von Ereignissen.  Das Ereignis enthält eine Reihe von Eigenschaften, zum Beispiel: Es gibt einen Schüler, einen Lehrer, an welchem ​​Tag sie sich in welcher Lektion treffen. <br><br><img src="https://habrastorage.org/webt/fn/1f/xa/fn1fxa5legi4mwszf5xbudchoi0.png"><br><br>  Wir schreiben den Test weiter. <br><br><img src="https://habrastorage.org/webt/vj/bt/s9/vjbts9wb6fely-atqa-kr88i9qm.png"><br><br>  Auch hier verwenden wir den get-Operator. Es ist nicht so einfach, zu seiner Implementierung zu gelangen, aber wir können es tun. <br><br><img src="https://habrastorage.org/webt/iz/gd/dv/izgddvy3bomaqjp_6yvbfrbcgpe.png"><br><br>  Tatsächlich folgen wir einfach der Vereinbarung, damit wir Zugriff auf dieses Design erhalten. <br>  Kehren wir zur Präsentation zurück und setzen das Gespräch über Kotlin fort.  Wir wollten, dass die Überprüfungen bei Kotlin durchgeführt werden, und haben diese Ereignisse durchlaufen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/f23/a77/b4ff23a77974a299ecac5c1c3b5d984f.jpg"><br><br>  Ein Ereignis ist im Wesentlichen eine gekapselte Menge von 4 Eigenschaften.  Ich möchte dieses Ereignis in eine Reihe von Eigenschaften wie ein Tupel zerlegen.  Im Russischen wird eine solche Konstruktion als <i>Mehrfachdeklaration</i> (ich habe nur eine solche Übersetzung gefunden) oder als <i>Strukturierungsdeklaration</i> bezeichnet und funktioniert wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2c/185/5f1/f2c1855f1ee98b51a4bda6ce9cc0b0a8.jpg"><br><br>  Wenn einer von Ihnen mit dieser Funktion nicht vertraut ist, funktioniert sie folgendermaßen: Sie können das Ereignis aufnehmen und an der Stelle, an der es verwendet wird, mithilfe von Klammern in eine Reihe von Eigenschaften zerlegen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/95f/0a3/44495f0a381b71a20578736f0cb491af.jpg"><br><br>  Dies funktioniert, weil wir eine componentN-Methode haben, dh eine Methode, die vom Compiler dank des Datenmodifikators generiert wird, den wir vor der Klasse schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/126/db9/d78/126db9d789acf9b3482f314d5a53261f.jpg"><br><br>  Gleichzeitig fliegen eine Vielzahl anderer Methoden zu uns.  Wir interessieren uns für die componentN-Methode, die basierend auf den in der Parameterliste des Primärkonstruktors aufgeführten Eigenschaften generiert wird. <br><br><img src="https://habrastorage.org/webt/hd/nf/ou/hdnfoutg14046a351gjyhodfprc.png"><br><br>  Wenn wir keinen Datenmodifikator hätten, müsste manuell ein Operator geschrieben werden, der dasselbe tut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/37f/a2f/e2b37fa2fad7cd8e201987c32fbf572b.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e59/bc7/479/e59bc7479e66cd96c4d0d5093ef33608.jpg"><br><br>  Wir haben also einige componentN-Methoden, die sich in einen solchen Aufruf zerlegen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96a/cae/aa9/96acaeaa91222d55c4a77b70c9b02903.jpg"><br><br>  Im Wesentlichen ist es syntaktischer Zucker über den Aufruf mehrerer Methoden. <br><br>  Wir haben bereits über eine Verfügbarkeitstabelle gesprochen, und tatsächlich habe ich Sie getäuscht.  Es passiert.  Es gibt keine <code>avaiabilityTable</code> , sie liegt nicht in der Natur, aber es gibt eine Matrix von Booleschen Werten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/393/d7d/5d7/393d7d5d739ea9cecedadff695ca6874.jpg"><br><br>  Es ist keine zusätzliche Klasse erforderlich: Sie können die Matrix der Booleschen Werte zur besseren Übersichtlichkeit umbenennen.  Dies kann mit den sogenannten <i>Typealias</i> oder <i>Type Alias ​​erfolgen</i> .  Leider erhalten wir keine zusätzlichen Boni, es ist nur eine Umbenennung.  Wenn Sie die Verfügbarkeit übernehmen und sie wieder in die Matrix der Booleschen Werte umbenennen, ändert sich überhaupt nichts.  Der Code hat funktioniert und wird funktionieren. <br><br>  Werfen wir einen Blick auf den Lehrer, genau diese Zugänglichkeit, und sprechen über ihn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/521/031/f59/521031f59a8e7b222c2614b32ba88abd.jpg"><br><br>  Wir haben einen Lehrer, und die Verfügbarkeitsmethode wird aufgerufen (haben Sie den Faden der Argumentation noch nicht verloren? :-).  Woher kam er?  Das heißt, ein Lehrer ist eine Art Entität, die eine Klasse hat, und dies ist ein Geschäftscode.  Und es kann keine zusätzliche Methode geben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54e/044/683/54e0446838b2360d695b45e5bacec69d.jpg"><br><br>  Diese Methode wird aufgrund von Erweiterungsfunktionen angezeigt.  Wir übernehmen eine andere Funktion, die wir für Objekte dieser Klasse ausführen können, und befestigen sie an unserer Klasse. <br>  Wenn wir dieser Funktion etwas Lambda übergeben und es dann für eine vorhandene Eigenschaft ausführen, ist alles in Ordnung - die Verfügbarkeitsmethode in ihrer Implementierung initialisiert die Verfügbarkeitseigenschaft.  Sie können dies loswerden.  Wir kennen bereits den Aufrufoperator, der an einen Typ angehängt werden kann und gleichzeitig eine Erweiterungsfunktion ist.  Wenn Sie diesem Operator ein Lambda übergeben, können wir dieses Lambda genau dort mit dem Schlüsselwort this ausführen.  Wenn wir mit einem Lehrer arbeiten, ist die Barrierefreiheit daher eine Eigenschaft des Lehrers und keine zusätzliche Methode, und hier findet keine Rassynchronisation statt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d6/1af/f71/4d61aff7169c403c75493790720c0e6e.jpg"><br><br>  Als Bonus können Erweiterungsfunktionen für nullbare Typen erstellt werden.  Dies ist gut, denn wenn es eine Variable mit einem nullbaren Typ gibt, die einen Nullwert enthält, ist unsere Funktion bereits dafür bereit und fällt nicht von NullPointer ab.  Innerhalb dieser Funktion kann dies null sein, und dies muss behandelt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59a/e33/1c5/59ae331c58bcd16003f51f870b89549e.jpg"><br><br>  Zusammenfassung der Erweiterungsfunktionen: Sie müssen verstehen, dass nur auf die öffentliche API der Klasse zugegriffen werden kann und die Klasse selbst in keiner Weise geändert wird.  Eine Erweiterungsfunktion wird durch den Typ der Variablen und nicht durch den tatsächlichen Typ bestimmt.  Darüber hinaus wird ein Mitglied der Klasse mit derselben Signatur priorisiert.  Sie können eine Erweiterungsfunktion für eine Klasse erstellen, diese jedoch in eine völlig andere Klasse schreiben. Innerhalb dieser Erweiterungsfunktion können Sie gleichzeitig auf zwei Kontexte zugreifen.  Es stellt sich die Schnittstelle von Kontexten heraus.  Und schließlich ist dies eine großartige Gelegenheit, die Bediener im Allgemeinen an jedem Ort zu befestigen, an dem wir wollen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/1e8/610/a041e86102be21acf2c3170cf941d064.jpg"><br><br>  Das nächste Tool sind Infix-Funktionen.  Ein weiterer gefährlicher Hammer in den Händen des Entwicklers.  Warum gefährlich?  Was Sie sehen, ist Code.  Ein solcher Code kann in Kotlin geschrieben werden, und tun Sie es nicht!  Bitte nicht.  Trotzdem ist der Ansatz gut.  Dank dessen ist es möglich, Punkte und Klammern zu entfernen - von all der lauten Syntax, von der wir versuchen, so weit wie möglich wegzukommen und unseren Code ein wenig sauberer zu machen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/909/8c3/4a0/9098c34a06b09bac0597004c6fbf6b1a.jpg"><br><br>  Wie funktioniert es  Nehmen wir ein einfacheres Beispiel - eine ganzzahlige Variable.  Lassen Sie uns eine Erweiterungsfunktion dafür erstellen, nennen wir es shouldBeEqual, es wird etwas tun, aber das ist nicht interessant.  Wenn wir den Infix-Modifikator links davon hinzufügen, ist das genug.  Sie können Punkte und Klammern entfernen, aber es gibt ein paar Nuancen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39e/fc2/31f/39efc231fb88cee1ef014a36fcb6cc73.jpg"><br><br>  Auf dieser Grundlage wird nur das Daten- und Assertionskonstrukt implementiert und zusammengefügt. <br><img src="https://habrastorage.org/getpro/habr/post_images/80f/6dd/126/80f6dd126255196fc538026ea28656c1.jpg"><br><br>  Lass es uns herausfinden.  Wir haben einen SchedulingContext - den allgemeinen Kontext für die Planung des Starts.  Es gibt eine Datenfunktion, die das Ergebnis dieser Planung zurückgibt.  Gleichzeitig erstellen wir eine Erweiterungsfunktion und gleichzeitig die Zusicherungen der Infixfunktion, die ein Lambda starten, das unsere Werte überprüft. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/449/74c/fe5/44974cfe559d94d17e6435557757af80.jpg"><br><br>  Es gibt ein Subjekt, ein Objekt und eine Handlung, und Sie müssen sie irgendwie verbinden.  In diesem Fall ist das Ergebnis der Ausführung von Daten mit geschweiften Klammern das Thema.  Das Lambda, das wir an die Assertions-Methode übergeben, ist ein Objekt, und die Assertions-Methode selbst ist eine Aktion.  All dies scheint zusammenzuhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/518/aac/4e9/518aac4e9d92ca84a79e6cdb09fea773.jpg"><br><br>  Apropos Funktionsinfix: Es ist wichtig zu verstehen, dass dies ein Schritt ist, um verrauschte Syntax zu beseitigen.  Wir müssen jedoch ein Subjekt und ein Objekt dieser Aktion haben und den Infix-Modifikator verwenden.  Es kann genau einen Parameter geben - das heißt, Nullparameter können nicht sein, zwei können nicht sein, drei - nun, Sie verstehen.  Sie können beispielsweise Lambdas an diese Funktion übergeben und auf diese Weise Konstrukte erhalten, die Sie zuvor noch nicht gesehen haben. <br><br>  Fahren wir mit der nächsten Demo fort.  Es ist besser, das Video anzuschauen und den Text nicht zu lesen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Jetzt sieht alles fertig aus: Das Funktionsinfix, das Sie gesehen haben, die Erweiterung der Funktion, die Sie gesehen haben, die Destrukturierungsdeklaration ist fertig. <br><br>  Kehren wir zu unserer Präsentation zurück, und hier kommen wir zu einem ziemlich wichtigen Punkt beim Aufbau problemorientierter Sprachen - Sie sollten über Kontextkontrolle nachdenken. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ff/0d3/57a/9ff0d357a3e39d01bcb3d5d07d81d71e.jpg"><br><br>  Es gibt Situationen, in denen wir DSL verwenden und direkt darin wiederverwenden können, aber wir möchten dies nicht tun.  Unser Benutzer (möglicherweise ein unerfahrener Benutzer) schreibt Daten in Daten, und das macht keinen Sinn.  Wir möchten ihm das irgendwie verbieten. <br><br>  Vor Kotlin Version 1.1 mussten wir Folgendes tun: Als Reaktion auf die Tatsache, dass wir eine Datenmethode in <code>SchedulingContext</code> , mussten wir eine andere <code>DataContext</code> in <code>DataContext</code> erstellen, in die wir ein Lambda akzeptieren (wenn auch ohne Implementierung), sollten wir diese Methode markieren Anmerkung <code>@Deprecated</code> und <code>@Deprecated</code> Sie den Compiler an, dies nicht zu kompilieren.  Sie sehen, dass diese Methode startet - nicht kompilieren.  Mit diesem Ansatz erhalten wir sogar eine aussagekräftige Nachricht, wenn wir bedeutungslosen Code schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfb/7a7/0b4/dfb7a70b4fba1c5cb0bf37715a4fe1bd.jpg"><br><br>  Nach der Version Kotlin 1.1 erschien eine wundervolle Anmerkung <code>@DslMarker</code> .  Diese Anmerkung wird benötigt, um abgeleitete Anmerkungen zu kennzeichnen.  Mit ihnen werden wir wiederum problemorientierte Sprachen markieren.  Für jede problemorientierte Sprache können Sie eine Anmerkung erstellen, die Sie als <code>@DslMarker</code> markieren, und sie an jeden benötigten Kontext hängen.  Es besteht keine Notwendigkeit mehr, zusätzliche Methoden zu schreiben, deren Kompilieren verboten werden muss - alles funktioniert einfach.  Nicht kompiliert. <br><br>  Es gibt jedoch einen solchen Sonderfall, wenn wir mit unserem Geschäftsmodell arbeiten.  Es ist normalerweise in Java geschrieben.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einen Kontext, es gibt eine Anmerkung, die als Kontext markiert werden muss. </font><font style="vertical-align: inherit;">Was ist Ihrer Meinung nach der Kontext des Schülers innerhalb der Methode? </font><font style="vertical-align: inherit;">Klasse </font></font><code>Student</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein Teil unseres Geschäftsmodells, Kotlin ist nicht da. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c6/111/c5c/4c6111c5c80ab5c4856e68c06880ed4a.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc3/572/a05/cc3572a054dabbe4e32362d845b30cf8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir möchten diese Situation auch irgendwie kontrollieren, da in diesem Fall Zugriff auf das folgende Design besteht: Erstellen Sie einen Schüler innerhalb der Schüler. </font><font style="vertical-align: inherit;">Ich möchte Sie nicht dazu bringen, falsche Assoziationen herzustellen, aber wir möchten es verbieten, es ist falsch. </font></font><br><br><img width="100%" src="https://habrastorage.org/getpro/habr/post_images/2fd/77d/125/2fd77d1250c0677a24c1c9c358f11663.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben drei Möglichkeiten.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen ganzen Kontext, der für unseren Schüler verantwortlich ist. </font><font style="vertical-align: inherit;">Nennen wir es StudentContext. </font><font style="vertical-align: inherit;">Wir beschreiben dort alle Eigenschaften und erstellen darauf basierend einen Schüler. </font><font style="vertical-align: inherit;">Eine Art Wahnsinn - eine Menge Code wird geschrieben, wahrscheinlich mehr als für die Produktion.</font></font><br></li><li>   –      ,    ,     .        .  StudentContext  ,      IStudent       .  ,       Student,        IStudent  StudentContext.   DslMarker  ,  . <br></li><li>  :   deprecated     .   ,   .       ,   .       extension-,     .       . <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/9ea/10d/d6a/9ea10dd6af4495be38653339010e0a46.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst auf dieser Ebene können Sie den Kontext steuern, jedoch mit einigen Einschränkungen, die umgangen werden müssen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d7/9f9/53f/1d79f953fc755000013d44d15f56fb73.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung der Kontextsteuerung. </font><font style="vertical-align: inherit;">Schützen Sie Ihre Benutzer vor Fehlern. </font><font style="vertical-align: inherit;">Es ist klar, dass Benutzer keine Fehler machen werden, da dies offensichtlich ist, aber es immer noch wünschenswert ist, dies zu kontrollieren. </font><font style="vertical-align: inherit;">Darüber hinaus kostet die Implementierung einer solchen Kontrolle nicht so viel Geld und Zeit. </font><font style="vertical-align: inherit;">Verwenden Sie die Annotation @DslMarker, mit der Sie Ihre eigenen Annotationen versehen. </font><font style="vertical-align: inherit;">In Situationen, in denen Sie die Annotation @DslMarker nicht verwenden können, verwenden Sie die Annotation @Deprecated. Auf diese Weise können Sie die Fälle umgehen, die noch nicht funktionieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, die Kontextkontroll-Demo:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><img src="https://habrastorage.org/getpro/habr/post_images/16c/690/f58/16c690f589bf90cc1547edc1ee985ae0.jpg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachteile und Probleme </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens die Wiederverwendung von DSL-Teilen. Sie haben bereits heute gesehen, dass das Adressieren von mit DSL erstellten Entitäten problematisch sein kann. Es gibt Möglichkeiten, dies zu umgehen, aber es ist ratsam, im Voraus darüber nachzudenken, um einen Plan dafür zu haben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor, Sie haben einen Code und möchten ihn beispielsweise nur in einem Zyklus wiederholen, um Schüler, viele, viele Male dieselben Schüler oder eine andere Entität erstellen zu können. Wie kann man das machen? Sie können die for-Schleife verwenden - nicht die beste Option. Sie können eine zusätzliche Methode in Ihrem DSL erstellen. Dies ist eine bessere Lösung. Sie müssen diese Probleme jedoch direkt auf DSL-Ebene lösen. Achten Sie auf das Schlüsselwort this und die Standardbenennung des Parameters it. Glücklicherweise haben wir mit der Kotlin-Version des Plugins 1.2.20 Hinweise, die direkt in der Entwicklungsumgebung sichtbar sind. Der graue Code sagt uns, mit welchem ​​Kontext wir arbeiten oder was es ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschachtelung kann ein Problem sein. Sie haben eine schöne DSL-Datei erstellt, aber die Initialisierung des Modells geht tiefer, tiefer, tiefer. Daher verwenden Sie häufig eher einen horizontalen als einen vertikalen Bildlauf. Es ist ratsam, Standardwerte unter der Standardimplementierung auszublenden. Ein Benutzer, der nur einen Schüler benötigt, möchte nichts über ein Schulungsprogramm oder etwas anderes wissen. Er möchte nur einen Schüler ohne Details erstellen und nicht einmal einen Namen angeben. Versuchen Sie, die Syntax zu verkürzen. Geben Sie beispielsweise einige Standardwerte an, übergeben Sie ein leeres Lambda usw.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Schluss die Dokumentation. Meiner subjektiven Meinung nach ist die beste Dokumentation für Ihre problemorientierte Sprache mehr als die Anzahl der Beispiele für dieses DSL. Großartig, wenn Sie Kotlin-Docks haben. Dies ist ein guter Bonus. Wenn der DSL-Benutzer jedoch keine Ahnung hat, welche Designs verfügbar sind, können er und die Kotlin-Docks nirgendwo suchen. Hast du das jemals gefühlt? Wenn Sie gleich zu Beginn eine Gradle-Datei schreiben, verstehen Sie nicht, was darin enthalten ist, und benötigen einige Beispiele. Sie kümmern sich nicht um Kontexte, Sie möchten Beispiele, und dies ist die beste Dokumentation, die von neuen Benutzern Ihres DSL verwendet werden kann.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/13e/4e0/05a/13e4e005af12def0ee687b008ffc41ac.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie DSLs bitte nicht in alle Ritzen. Ich möchte das wirklich tun, wenn Sie dieses Tool besitzen. Ich möchte sagen, lassen Sie uns hier, vielleicht hier und hier, ein DSL erstellen. Erstens ist dies ein undankbarer Job. Zweitens ist es immer noch wünschenswert, dies am Zielort anzuwenden. Wo es Ihnen wirklich hilft, ein Problem zu lösen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich lernen Kotlin. Entdecken Sie die Möglichkeiten, die diese Sprache bietet, neue Funktionen, damit Ihr Code sauberer, kürzer und kompakter wird und viel einfacher zu lesen ist. Und wenn Sie wieder zum Testen zurückkehren (z. B. wenn Sie etwas hinzugefügt haben, müssen Sie einen Test dafür durchführen), werden Sie dies viel mehr tun, da DSL so kompakt und komfortabel wie möglich ist und Sie kein Problem damit haben, ein Dutzend zu erstellen Studenten. Nur in ein paar Zeilen ist dies erledigt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trainiere "Katzen" als Held eines berühmten Films. Meiner Meinung nach ist es zunächst einfacher, Kotlin als Test in Ihr Projekt einzubeziehen. Dies ist eine gute Gelegenheit, die Sprache zu überprüfen, auszuprobieren und sich die Funktionen anzusehen. Dies ist so ein Schlachtfeld, auf dem man es auch dann benutzen kann, wenn nichts funktioniert.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließlich entwerfen Sie das DSL vor. Heute habe ich ein perfektes Beispiel gezeigt, und wir sind schrittweise gegangen, um eine problemorientierte Sprache aufzubauen. Wenn Sie das DSL vorab entwerfen, wird es letztendlich viel einfacher. Sie werden es nicht zehnmal umgestalten. Sie müssen sich keine Sorgen machen, dass sich die Kontexte irgendwie überschneiden und logisch stark miteinander verbunden sind. Entwerfen Sie das DSL einfach vorab - es ist ziemlich einfach, es auf einem Blatt Papier zu tun, wenn Sie die Entwürfe kennen, die ich Ihnen heute erzählt habe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schließlich Kontakte für die Kommunikation. Mein Name ist Ivan Osipov, Telegramm: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ivan_osipov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Twitter: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@_osipov_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Habr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i_osipov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich werde auf Ihre Kommentare warten.</font></font><br><br><blockquote>  Minute der Werbung.        <b>JPoint</b> —  ,  19-20   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Joker 2018</a> —    Java-.       .    ,         . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416725/">https://habr.com/ru/post/de416725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416711/index.html">Seiten der Intel-Geschichte. Fabrikfeuer in Penang</a></li>
<li><a href="../de416713/index.html">Bericht des Club of Rome 2018, Kapitel 3.14: „Kein einziges BIP ...“</a></li>
<li><a href="../de416719/index.html">Erweiterung PHP und Kotlin Native. Teil Zwei, bewusst</a></li>
<li><a href="../de416721/index.html">DIY House: Puppenhäuser für Erwachsene</a></li>
<li><a href="../de416723/index.html">API-Barrierefreiheit: Schnittstellen in natürlicher Sprache</a></li>
<li><a href="../de416727/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 2: „Kontrolle von Hackerangriffen“, Teil 3</a></li>
<li><a href="../de416729/index.html">Das Programm von PYCON RUSSIA ist fertig: 25 Berichte und 3 Workshops von Rednern von Google, Red Hat, Yelp und Yandex</a></li>
<li><a href="../de416731/index.html">Frost auf Glas: Wie man Hochleistungskunststoff aus Metall herstellt</a></li>
<li><a href="../de416737/index.html">A * Pfadfindungsalgorithmus in einem Voxel 3d Unity-Spiel</a></li>
<li><a href="../de416739/index.html">Neues ASUS auf der Computex 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>