<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèø üå•Ô∏è üë≤üèª Kotlin DSL: Theorie und Praxis ‚èÆÔ∏è ü§∞üèº üêÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Entwickeln von Anwendungstests ist keine angenehme Erfahrung. Dieser Prozess dauert lange, erfordert viel Konzentration und ist √§u√üerst gefragt. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kotlin DSL: Theorie und Praxis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/416725/">  Das Entwickeln von Anwendungstests ist keine angenehme Erfahrung.  Dieser Prozess dauert lange, erfordert viel Konzentration und ist √§u√üerst gefragt.  Die Kotlin-Sprache bietet eine Reihe von Tools, mit denen Sie ganz einfach Ihre eigene problemorientierte Sprache (DSL) erstellen k√∂nnen.  Es gibt Erfahrung, als Kotlin DSL Builder und statische Methoden zum Testen des Ressourcenplanungsmoduls ersetzte, was das Hinzuf√ºgen neuer Tests und das Unterst√ºtzen alter Tests aus einer Routine zu einem unterhaltsamen Prozess machte. <br><br>  Im Verlauf des Artikels werden wir alle wichtigen Tools aus dem Entwicklerarsenal analysieren und analysieren, wie sie zur L√∂sung von Testproblemen kombiniert werden k√∂nnen.  Wir werden den gesamten Weg von der Entwicklung des idealen Tests bis zur Einf√ºhrung des ungef√§hrsten, saubersten und verst√§ndlichsten Tests f√ºr das auf Kotlin basierende Ressourcenplanungssystem gehen. <br><br>  Der Artikel ist n√ºtzlich f√ºr praktizierende Ingenieure, diejenigen, die Kotlin als eine Sprache zum bequemen Schreiben kompakter Tests betrachten, und diejenigen, die den Testprozess in ihrem Projekt verbessern m√∂chten. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Dieser Artikel basiert auf einer Pr√§sentation von Ivan Osipov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">i_osipov</a> ) auf der JPoint-Konferenz.  Weitere Erz√§hlungen werden in seinem Namen durchgef√ºhrt.  Ivan arbeitet als Programmierer bei Haulmont.  Das Hauptprodukt des Unternehmens ist CUBA, eine Plattform f√ºr die Entwicklung von Unternehmens- und verschiedenen Webanwendungen.  Auf dieser Plattform werden insbesondere Outsourcing-Projekte durchgef√ºhrt, darunter k√ºrzlich ein Projekt im Bildungsbereich, bei dem Ivan einen Zeitplan f√ºr eine Bildungseinrichtung aufstellte.  So kam es, dass Ivan in den letzten drei Jahren auf die eine oder andere Weise mit Planern zusammengearbeitet hat und speziell in Haulmont diesen Planer seit einem Jahr testet. <br><a name="habracut"></a><br>  F√ºr diejenigen, die Beispiele ausf√ºhren m√∂chten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">halten Sie einen Link zu GitHub</a> .  Unter dem Link finden Sie den gesamten Code, den wir heute analysieren, ausf√ºhren und schreiben werden.  √ñffnen Sie den Code und gehen Sie! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec3/fa3/670/ec3fa3670fd1c8a3cf7222f7e746933c.jpg"><br><br>  Heute werden wir diskutieren: <br><br><ul><li>  Was sind problemorientierte Sprachen? <br></li><li>  eingebaute problemorientierte Sprachen; <br></li><li>  Aufbau eines Zeitplans f√ºr eine Bildungseinrichtung; <br></li><li>  wie alles mit Kotlin getestet wird. <br></li></ul><br>  Heute werde ich ausf√ºhrlich √ºber die Tools sprechen, die wir in der Sprache haben, Ihnen einige Demos zeigen und den gesamten Test von Anfang bis Ende schreiben.  Gleichzeitig m√∂chte ich objektiver sein, daher werde ich auf einige der Nachteile eingehen, die ich w√§hrend der Entwicklung f√ºr mich selbst festgestellt habe. <br><br>  Lassen Sie uns zun√§chst √ºber das Modul zur Erstellung von Zeitpl√§nen sprechen.  Die Erstellung des Zeitplans erfolgt also in mehreren Schritten.  Jeder dieser Schritte muss separat getestet werden.  Sie m√ºssen verstehen, dass wir trotz der Tatsache, dass die Schritte unterschiedlich sind, ein gemeinsames Datenmodell haben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/031/be4/27d/031be427d58c5073a3bc619cbed65792.jpg"><br><br>  Dieser Prozess kann wie folgt dargestellt werden: Am Eingang gibt es einige Daten mit einem gemeinsamen Modell, am Ausgang gibt es einen Zeitplan.  Die Daten werden validiert, gefiltert und anschlie√üend Trainingsgruppen erstellt.  Dies bezieht sich auf den Themenbereich des Stundenplans f√ºr die Bildungseinrichtung.  Basierend auf den konstruierten Gruppen und auf der Grundlage einiger anderer Daten platzieren wir die Lektion.  Heute werden wir nur √ºber die letzte Phase sprechen - √ºber die Platzierung von Klassen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f64/032/4b1/f640324b1a2ff556a4da892822847a9c.jpg"><br><br>  Ein bisschen √ºber das Testen des Schedulers. <br><br>  Zun√§chst m√ºssen, wie Sie bereits verstanden haben, die verschiedenen Stufen separat getestet werden.  Man kann einen mehr oder weniger standardm√§√üigen Prozess zum Starten des Tests herausgreifen: Es gibt eine Dateninitialisierung, es gibt einen Scheduler-Start, es gibt eine √úberpr√ºfung der Ergebnisse dieses Schedulers selbst.  Es gibt eine gro√üe Anzahl unterschiedlicher Gesch√§ftsf√§lle, die abgedeckt werden m√ºssen, und verschiedene Situationen, die ber√ºcksichtigt werden m√ºssen, damit diese Situationen beim Erstellen eines Zeitplans ebenfalls bestehen bleiben. <br><br>  Ein Modell kann manchmal gewichtig sein. Um eine einzelne Entit√§t zu erstellen, m√ºssen f√ºnf oder mehr zus√§tzliche Entit√§ten initialisiert werden.  Insgesamt wird also eine gro√üe Menge an Code erhalten, die wir f√ºr jeden Test immer wieder schreiben.  Die Unterst√ºtzung solcher Tests nimmt viel Zeit in Anspruch.  Wenn Sie das Modell aktualisieren m√∂chten und dies manchmal vorkommt, wirkt sich der Umfang der √Ñnderungen auf die Tests aus. <br><br>  Schreiben wir einen Test: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fda/0f5/94d/fda0f594d14b8043054bcae7fe3315ad.jpg"><br><br>  Schreiben wir den einfachsten Test, damit Sie das Bild allgemein verstehen. <br>  Was f√§llt Ihnen zuerst ein, wenn Sie √ºber das Testen nachdenken?  Vielleicht sind dies einige primitive Tests dieser Art: Sie erstellen eine Klasse, erstellen eine Methode darin und markieren sie mit dem Annotationstest.  Infolgedessen nutzen wir die Funktionen von JUnit und initialisieren einige Daten, Standardwerte und dann testspezifische Werte, machen dasselbe f√ºr den Rest des Modells und erstellen schlie√ülich ein Scheduler-Objekt, √ºbertragen unsere Daten darauf. Wir beginnen, wir erhalten Ergebnisse und wir √ºberpr√ºfen sie.  Mehr oder weniger Standardverfahren.  Aber es gibt offensichtlich eine Codeduplizierung.  Das erste, was mir in den Sinn kommt, ist die F√§higkeit, alles in statische Methoden umzuwandeln.  Da es eine Reihe von Standardwerten gibt, k√∂nnen Sie diese ausblenden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/521/543/590/521543590a00c6101abd4fcefd345e04.jpg"><br><br>  Dies ist ein guter erster Schritt zur Reduzierung von Doppelarbeit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7f/c57/11c/c7fc5711ccf2a4e9dfb626ea64cffb9b.jpg"><br><br>  Wenn Sie sich das ansehen, verstehen Sie, dass ich das Modell kompakter halten m√∂chte.  Hier haben wir ein Builder-Muster, in dem irgendwo unter der Haube der Standardwert initialisiert wird und die testspezifischen Werte genau dort initialisiert werden.  Es wird besser, aber wir schreiben immer noch den Boilerplate-Code und wir schreiben ihn jedes Mal neu.  Stellen Sie sich 200 Tests vor - Sie m√ºssen diese drei Zeilen 200 Mal schreiben.  Nat√ºrlich m√∂chte ich das irgendwie loswerden.  Bei der Entwicklung der Idee sto√üen wir an eine bestimmte Grenze.  So k√∂nnen wir beispielsweise generell f√ºr alles einen Pattern Builder erstellen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/259/e9b/7a3/259e9b7a39e84a41466572b38afc280d.jpg"><br><br>  Sie k√∂nnen einen Planer von Grund auf bis zum Ende erstellen, alle ben√∂tigten Werte festlegen, mit der Planung beginnen und alles ist gro√üartig.  Wenn Sie sich dieses Beispiel genauer ansehen und es detailliert analysieren, stellt sich heraus, dass viel unn√∂tiger Code geschrieben wird.  Ich m√∂chte die Tests lesbarer machen, damit Sie einen Blick darauf werfen und sofort verstehen k√∂nnen, ohne sich mit den Mustern usw. zu befassen. <br><br>  Wir haben also unn√∂tigen Code.  Einfache Mathematik legt nahe, dass es 55% mehr Buchstaben gibt, als wir brauchen, und ich w√ºrde gerne irgendwie davon wegkommen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d55/610/ef7/d55610ef71d368b8d16c1fdef35cd2c5.jpg"><br><br>  Nach einiger Zeit stellt sich heraus, dass die Unterst√ºtzung f√ºr unsere Tests teurer ist, da Sie mehr Code unterst√ºtzen m√ºssen.  Wenn wir keine Anstrengungen unternehmen, l√§sst die Lesbarkeit manchmal zu w√ºnschen √ºbrig oder sie stellt sich als akzeptabel heraus, aber wir m√∂chten noch besser.  Vielleicht werden wir sp√§ter anfangen, eine Art Framework, Bibliotheken, hinzuzuf√ºgen, um das Schreiben von Tests zu vereinfachen.  Aus diesem Grund erh√∂hen wir den Einstieg in das Testen unserer Anwendung.  Hier haben wir eine bereits komplizierte Anwendung, der Einstieg in die Tests ist erheblich und wir erh√∂hen sie noch weiter. <br><br><h2>  Perfekter Test </h2><br>  Es ist toll zu sagen, wie schlecht alles ist, aber lassen Sie uns dar√ºber nachdenken, wie gut es w√§re.  Ein ideales Beispiel, das wir als Ergebnis erhalten m√∂chten: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/7c5/f48/e2b7c5f48dbd065e95b1617ad10622ba.jpg"><br><br>  Stellen Sie sich vor, es gibt eine Erkl√§rung, in der wir sagen, dass dies ein Test mit einem bestimmten Namen ist, und wir m√∂chten ein Leerzeichen verwenden, um die W√∂rter im Namen zu trennen, nicht CamelCase.  Wir erstellen einen Zeitplan, wir haben einige Daten und die Ergebnisse des Planers werden √ºberpr√ºft.  Da wir haupts√§chlich mit Java arbeiten und der gesamte Code der Hauptanwendung in dieser Sprache geschrieben ist, m√∂chte ich kompatible Testfunktionen haben.  Ich m√∂chte die Daten f√ºr den Leser so offensichtlich wie m√∂glich initialisieren.  Ich m√∂chte einige allgemeine Daten und einen Teil des Modells initialisieren, die wir ben√∂tigen.  Erstellen Sie beispielsweise Sch√ºler und Lehrer und beschreiben Sie, wann sie verf√ºgbar sind.  Dies ist unser perfektes Beispiel. <br><br><h2>  Dom√§nenspezifische Sprache </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f81/c79/0a9/f81c790a921e43d645fc7380607cf8ea.jpg"><br><br>  Wenn man alles betrachtet, scheint es wie eine Art problemorientierte Sprache.  Sie m√ºssen verstehen, was es ist und was der Unterschied ist.  Sprachen k√∂nnen in zwei Typen unterteilt werden: Allzwecksprachen (was wir st√§ndig schreiben, absolut alle Aufgaben l√∂sen und absolut alles bew√§ltigen) und problemorientierte Sprachen.  So hilft uns beispielsweise SQL, Daten perfekt aus der Datenbank abzurufen, und einige andere Sprachen helfen auch, andere spezifische Probleme zu l√∂sen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f8/e45/2f6/2f8e452f62f39f0f56a2c73e355dddcb.jpg"><br><br>  Eine M√∂glichkeit, problemorientierte Sprachen zu implementieren, sind eingebettete oder interne Sprachen.  Solche Sprachen werden auf der Basis einer Allzwecksprache implementiert.  Das hei√üt, mehrere Konstruktionen unserer Allzwecksprache bilden so etwas wie eine Basis - das verwenden wir, wenn wir mit einer problemorientierten Sprache arbeiten.  In diesem Fall ergibt sich nat√ºrlich in einer problemorientierten Sprache die M√∂glichkeit, alle Merkmale und Merkmale einer Allzwecksprache zu nutzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07f/4cb/57f/07f4cb57f84ba884bd558ee8e97202a2.jpg"><br><br>  Schauen Sie sich noch einmal unser perfektes Beispiel an und √ºberlegen Sie, welche Sprache Sie w√§hlen sollen.  Wir haben drei M√∂glichkeiten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d1d/b21/4b3/d1db214b39b5620875350b382622e662.jpg"><br><br>  Die erste Option ist Groovy.  Eine wunderbare, dynamische Sprache, die sich beim Aufbau problemorientierter Sprachen bew√§hrt hat.  Auch hier k√∂nnen Sie ein Beispiel f√ºr eine Build-Datei in Gradle geben, die viele von uns verwenden.  Es gibt auch Scala, die eine Vielzahl von M√∂glichkeiten bietet, etwas Eigenes umzusetzen.  Und schlie√ülich gibt es Kotlin, das uns auch beim Aufbau einer problemorientierten Sprache hilft, und heute wird dar√ºber diskutiert.  Ich w√ºrde keine Kriege z√ºchten und Kotlin mit etwas anderem vergleichen wollen, sondern es bleibt auf deinem Gewissen.  Heute werde ich Ihnen zeigen, was Kotlin f√ºr die Entwicklung problemorientierter Sprachen hat.  Wenn Sie dies vergleichen und sagen m√∂chten, dass eine Sprache besser ist, k√∂nnen Sie zu diesem Artikel zur√ºckkehren und den Unterschied leicht erkennen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/2e7/29e/0502e729ebf030ea5e4d9f038a4b7cc6.jpg"><br><br>  Was gibt uns Kotlin f√ºr die Entwicklung einer problemorientierten Sprache? <br><br>  Erstens handelt es sich um eine statische Typisierung, die sich daraus ergibt.  In der Kompilierungsphase wird eine gro√üe Anzahl von Problemen erkannt, was erheblich spart, insbesondere wenn Sie keine Probleme mit der Syntax und dem Schreiben in Tests haben m√∂chten. <br>  Dann gibt es ein gro√üartiges Typinferenzsystem, das von Kotlin stammt.  Das ist wunderbar, weil es nicht n√∂tig ist, immer wieder Typen zu schreiben, alles wird vom Compiler mit einem Knall angezeigt. <br><br>  Drittens gibt es eine hervorragende Unterst√ºtzung f√ºr die Entwicklungsumgebung, und dies ist nicht √ºberraschend, da dasselbe Unternehmen die Hauptentwicklungsumgebung f√ºr heute erstellt und Kotlin. <br>  Schlie√ülich k√∂nnen wir in DSL nat√ºrlich Kotlin verwenden.  Meiner subjektiven Meinung nach ist die Unterst√ºtzung von DSL viel einfacher als die Unterst√ºtzung von Utility-Klassen.  Wie Sie sp√§ter sehen werden, ist die Lesbarkeit etwas besser als bei Buildern.  Was ich unter ‚Äûbesser‚Äú verstehe: Sie erhalten etwas weniger Syntax, die Sie schreiben m√ºssen - jemand, der Ihre problemorientierte Sprache liest, wird es schneller verstehen.  Schlie√ülich macht das Schreiben Ihres Fahrrads viel mehr Spa√ü!  Tats√§chlich ist die Implementierung einer problemorientierten Sprache jedoch viel einfacher als das Erlernen eines neuen Rahmens. <br><br>  Ich werde noch einmal an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zu GitHub</a> erinnern. Wenn Sie weitere Demos schreiben m√∂chten, k√∂nnen Sie den Code vom Link abholen. <br><br><h2>  Das Ideal auf Kotlin entwerfen </h2><br>  Fahren wir mit der Gestaltung unseres Ideals fort, aber bereits bei Kotlin.  Schauen Sie sich unser Beispiel an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e3/695/850/5e3695850435a204b9cbb3b94f6f7635.png"><br><br>  Und schrittweise werden wir beginnen, es wieder aufzubauen. <br><br>  Wir haben einen Test, der sich in Kotlin in eine Funktion verwandelt, die mit Leerzeichen benannt werden kann. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/03d/699/a71/03d699a71ecf86e0e5c03b7a6de57995.png"><br><br>  Wir werden es mit der Testanmerkung markieren, die uns von JUnit zur Verf√ºgung steht.  In Kotlin k√∂nnen Sie die verk√ºrzte Form zum Schreiben von Funktionen verwenden und durch <i>=</i> zus√§tzliche geschweifte Klammern f√ºr die Funktion selbst entfernen. <br><br>  Zeitplan wir verwandeln uns in einen Block.  Das gleiche passiert mit vielen Designs, da wir immer noch bei Kotlin arbeiten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7b/db9/656/a7bdb965641ca434f1eba5e7781b9b53.png"><br><br>  Fahren wir mit dem Rest fort.  Geschweifte Klammern erscheinen wieder, wir werden sie nicht los, aber versuchen zumindest, unserem Beispiel n√§her zu kommen.  Durch das Konstruieren von Konstruktionen mit Leerzeichen k√∂nnten wir uns irgendwie verfeinern und irgendwie anders machen, aber es scheint mir, dass es besser ist, die √ºblichen Methoden zu erstellen, die die Verarbeitung kapseln, aber im Allgemeinen ist dies f√ºr den Benutzer offensichtlich . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/378/6e6/eaf/3786e6eafdb8ebd14c344af30698df56.png"><br><br>  Unser Sch√ºler verwandelt sich in einen Block, in dem wir mit Eigenschaften und Methoden arbeiten, und wir werden dies weiterhin mit Ihnen analysieren. <br><br><img width="600" src="https://habrastorage.org/getpro/habr/post_images/76b/a76/554/76ba76554585689a4c2562167fd26833.png"><br><br>  Endlich die Lehrer.  Hier haben wir einige verschachtelte Bl√∂cke. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/deb/a5d/f0a/deba5df0a67a08566e07370bf2f70bc0.png"><br><br>  Im folgenden Code fahren wir mit den √úberpr√ºfungen fort.  Wir m√ºssen die Kompatibilit√§t mit Java-Sprachen √ºberpr√ºfen - und ja, Kotlin ist mit Java kompatibel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/09d/a05/8aa09da05c7c48282e01b0ea409e0f3c.png"><br><br><h2>  Arsenal der DSL-Entwicklung bei Kotlin </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/5f6/113/6ef/5f61136ef41733e6fb88c5ff17d6975f.jpg"><br><br>  Fahren wir mit der Liste der Tools fort, die wir haben.  Hier habe ich ein Tablet mitgebracht, vielleicht listet es alles auf, was zur Entwicklung problemorientierter Sprachen in Kotlin ben√∂tigt wird.  Sie k√∂nnen von Zeit zu Zeit zu ihr zur√ºckkehren und ihr Ged√§chtnis auffrischen. <br><br>  Die Tabelle zeigt einen Vergleich der problemorientierten Syntax mit der √ºblichen Syntax, die in der Sprache verf√ºgbar ist. <br><br><h2>  Lambdas in Kotlin </h2><br> <code>val lambda: () -&gt; Unit = { }</code> <br> <br>  Beginnen wir mit dem grundlegendsten Ziegelstein, den wir in Kotlin haben - das sind Lambdas. <br>  Mit Lambda-Typ meine ich heute nur einen funktionalen Typ.  Lambdas werden wie folgt bezeichnet: <code>( ) -&gt;  </code> . <br><br>  Wir initialisieren das Lambda mit Hilfe von geschweiften Klammern, in die wir einen Code schreiben k√∂nnen, der aufgerufen wird.  Das hei√üt, ein Lambda verbirgt diesen Code tats√§chlich nur in sich.  Das Ausf√ºhren eines solchen Lambda sieht aus wie ein Funktionsaufruf, nur in Klammern. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a48/f4d/d49/a48f4dd497c8aa6b93ab2043e014ca02.jpg"><br><br>  Wenn wir einen Parameter √ºbergeben wollen, m√ºssen wir ihn zun√§chst im Typ beschreiben. <br>  Zweitens haben wir Zugriff auf die Standardkennung, die wir verwenden k√∂nnen. Wenn dies jedoch nicht zu uns passt, k√∂nnen wir unseren eigenen Parameternamen festlegen und diese verwenden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/194/fab/626/194fab62612fb71e6a5f148193ec1ff9.jpg"><br><br>  Gleichzeitig k√∂nnen wir die Verwendung dieses Parameters √ºberspringen und den Unterstrich verwenden, um keine Bezeichner zu erzeugen.  In diesem Fall w√§re es zum Ignorieren des Bezeichners m√∂glich, √ºberhaupt nichts zu schreiben, aber im allgemeinen Fall gibt es f√ºr mehrere Parameter das erw√§hnte "_". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ff/80e/de2/1ff80ede232393839186b9345065700c.jpg"><br><br>  Wenn wir mehr als einen Parameter √ºbergeben m√∂chten, m√ºssen wir deren Bezeichner explizit definieren. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8d/d2b/952/c8dd2b952caa82b67157f41dc79535b0.jpg"><br><br>  Was passiert schlie√ülich, wenn wir versuchen, das Lambda an eine Funktion zu √ºbergeben und dort auszuf√ºhren?  In der anf√§nglichen Ann√§herung sieht es wie folgt aus: Wir haben eine Funktion, an die wir Lambda in geschweiften Klammern √ºbergeben, und wenn in Kotlin Lambda als letzter Parameter geschrieben wird, k√∂nnen wir es aus diesen Klammern heraussetzen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b80/d7c/0d8/b80d7c0d814f3c51a91f2c224707a2d5.jpg"><br><br>  Wenn in den Klammern nichts mehr vorhanden ist, k√∂nnen wir die Klammern entfernen.  Diejenigen, die mit Groovy vertraut sind, sollten damit vertraut sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/74b/5dd/a95/74b5dda953b1df973a8d893f7a615195.jpg"><br><br>  Wo gilt das?  Absolut √ºberall.  Das hei√üt, die sehr lockigen Klammern, √ºber die wir bereits gesprochen haben, verwenden wir, das sind genau die Lambdas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69e/4bd/781/69e4bd781897ef0515384f81367899cc.jpg"><br><br>  Schauen wir uns nun eine der Lambdasorten an, ich nenne sie Lambdas mit Kontext.  Sie werden einige andere Namen finden, zum Beispiel Lambda mit Empf√§nger, und sie unterscheiden sich von gew√∂hnlichen Lambdas, wenn Sie einen Typ wie folgt deklarieren: Links f√ºgen wir eine Kontextklasse hinzu, es kann eine beliebige Klasse sein. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/375/5b1/8bd3755b1085f3049a7ea32c7cc41f79.jpg"><br><br>  Wof√ºr ist das?  Dies ist notwendig, damit wir innerhalb des Lambda Zugriff auf das Schl√ºsselwort this haben - dies ist das Schl√ºsselwort selbst. Es gibt Auskunft √ºber unseren Kontext, dh √ºber ein Objekt, das wir mit unserem Lambda verkn√ºpft haben.  So k√∂nnen wir beispielsweise ein Lambda erstellen, das einen String ausgibt. Nat√ºrlich verwenden wir die String-Klasse, um einen Kontext zu deklarieren, und der Aufruf eines solchen Lambda sieht folgenderma√üen aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d80/552/181/d80552181518f155fc596c1bb3ddf2aa.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/788/63d/b17/78863db1732d9b92bff62bf82060771a.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/770/a1b/038/770a1b0388cd2380c491cdf5ca8c344c.jpg"><br><br>  Wenn Sie einen Kontext als Parameter √ºbergeben m√∂chten, k√∂nnen Sie dies genauso gut tun.  Wir k√∂nnen den Kontext jedoch nicht vollst√§ndig vermitteln, dh ein Lambda mit einem Kontext erfordert Aufmerksamkeit!  - Kontext, ja.  Was passiert, wenn wir ein Lambda mit einem Kontext an eine Methode √ºbergeben?  Hier sehen wir uns noch einmal unsere exec-Methode an: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/15b/f36/3d9/15bf363d94919f7c73d775c5d28c6c53.jpg"><br><br>  Benennen Sie es in die Student-Methode um - nichts hat sich ge√§ndert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e12/4cc/e3b/e124cce3bd7bdb776c3e946edf8ec52c.jpg"><br><br>  Also bewegen wir uns allm√§hlich zu unserer Konstruktion, der Studentenkonstruktion, die unter den Klammern jede Initialisierung verbirgt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/286/8b3/eba2868b306f476c35df51d8af500335.jpg"><br><br>  Lass es uns herausfinden.  Wir haben eine Art Studentenfunktion, die ein Lambda mit dem Studentenkontext verbindet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3f/954/e2a/d3f954e2a7016ecf31a081559674d01f.jpg"><br><br>  Nat√ºrlich brauchen wir Kontext. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/362/4d8/3be/3624d83be81ee01223ad758e9e81c94d.jpg"><br><br>  Hier erstellen wir ein Objekt und f√ºhren dieses Lambda darauf aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cab/d4a/940/cabd4a940deacfcdcb680c4916b29eae.jpg"><br><br>  Infolgedessen k√∂nnen wir auch einige Standardwerte initialisieren, bevor wir das Lambda starten, sodass wir alles kapseln, was wir f√ºr die Funktion ben√∂tigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b4/572/421/0b457242103fc70de806c9de62234135.jpg"><br><br>  Aus diesem Grund erhalten wir im Lambda Zugriff auf das Schl√ºsselwort this. Deshalb gibt es wahrscheinlich Lambdas mit Kontext. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1b/819/fdb/b1b819fdb7488092550b2ac72265cd72.jpg"><br><br>  Nat√ºrlich k√∂nnen wir dieses Schl√ºsselwort loswerden und haben die M√∂glichkeit, solche Konstruktionen zu schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50d/dbc/492/50ddbc4920ffb871918ce7c063a874a2.jpg"><br><br>  Auch wenn wir nicht nur propriet√§re, sondern auch einige Methoden haben, die wir auch nennen k√∂nnen, sieht es ziemlich nat√ºrlich aus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b72/155/316/b72155316d99a7e4816d1234644b761b.jpg"><br><br><h2>  Anwendung </h2><br>  Alle diese Lambdas im Code sind Kontext-Lambdas.  Es gibt eine Vielzahl von Kontexten, die sich auf die eine oder andere Weise √ºberschneiden und es uns erm√∂glichen, unsere problemorientierte Sprache aufzubauen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/83a/f30/2ff/83af302ff3c0a85db220c70f0d567743.jpg"><br><br>  Zusammenfassend die Lambdas - wir haben gew√∂hnliche Lambdas, die es mit dem Kontext gibt, und diese und andere k√∂nnen verwendet werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fcc/1ac/dfc/fcc1acdfc43284500c38884d88212877.jpg"><br><br><h2>  Betreiber </h2><br>  Kotlin verf√ºgt √ºber eine begrenzte Anzahl von Operatoren, die Sie mithilfe von Konventionen und dem Schl√ºsselwort operator √ºberschreiben k√∂nnen. <br><br>  Schauen wir uns den Lehrer und seine Zug√§nglichkeit an.  Nehmen wir an, der Lehrer arbeitet montags ab 8 Uhr f√ºr 1 Stunde.  Wir m√∂chten auch sagen, dass es zus√§tzlich zu dieser einen Stunde ab 13.00 Uhr f√ºr 1 Stunde funktioniert.  Ich m√∂chte dies mit dem Operator <b>+</b> ausdr√ºcken.  Wie kann das gemacht werden? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17b/360/9ab/17b3609ab2ebd28cf27f906934536e05.jpg"><br><br>  Es gibt eine Verf√ºgbarkeitsmethode, die ein Lambda mit einem <code>AvailabilityTable</code> Kontext akzeptiert.  Dies bedeutet, dass es eine Klasse gibt, die so hei√üt, und die Montag-Methode wird in dieser Klasse deklariert.  Diese Methode gibt <code>DayPointer</code> seitdem zur√ºck  Sie m√ºssen unseren Operator an etwas anh√§ngen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/721/aea/73d/721aea73d36a41cf3dbecd328b1f5ab5.jpg"><br><br>  Lassen Sie uns herausfinden, was DayPointer ist.  Dies ist ein Hinweis auf die Verf√ºgbarkeitstabelle eines Lehrers, und der Tag steht auf seinem Zeitplan.  Wir haben auch eine Zeitfunktion, die einige Zeilen irgendwie in ganzzahlige Indizes verwandelt: In Kotlin haben wir daf√ºr eine <code>IntRange</code> Klasse. <br><br>  Links ist <code>DayPointer</code> , rechts ist Zeit, und wir m√∂chten sie mit dem Operator <b>+</b> kombinieren.  Dazu k√∂nnen Sie unseren Operator in der <code>DayPointer</code> Klasse <code>DayPointer</code> .  Es werden verschiedene Werte vom Typ Int ben√∂tigt und <code>DayPointer</code> damit wir unser DSL immer wieder <code>DayPointer</code> k√∂nnen. <br>  Schauen wir uns nun das Schl√ºsseldesign an, mit dem alles beginnt und mit dem unser DSL beginnt.  Die Implementierung ist etwas anders, und jetzt werden wir es herausfinden. <br>  Kotlin hat ein Singleton-Konzept, das direkt in die Sprache integriert ist.  Zu diesem <code>object</code> wird anstelle des Schl√ºsselworts class das Schl√ºsselwort <code>object</code> verwendet.  Wenn wir eine Methode in einem Singleton erstellen, k√∂nnen wir so darauf zugreifen, dass keine Instanz dieser Klasse erneut erstellt werden muss.  Wir bezeichnen es einfach als statische Methode in einer Klasse. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3d/226/065/d3d2260651fc4049ec8d3e6878a0cc51.jpg"><br><br>  Wenn Sie sich das Ergebnis der Dekompilierung ansehen (dh in der Entwicklungsumgebung auf Extras -&gt; Kotlin -&gt; Kotlin-Bytecode anzeigen -&gt; Dekompilieren klicken), sehen Sie die folgende Singleton-Implementierung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c6/8c9/577/3c68c957760612b06a5b008c734ddb33.jpg"><br><br>  Dies ist nur eine gew√∂hnliche Klasse, und hier passiert nichts √úbernat√ºrliches. <br>  Ein weiteres interessantes Tool ist die <code>invoke</code> Anweisung.  Stellen Sie sich vor, wir haben eine Klasse A, wir haben ihre Instanz, und wir m√∂chten diese Instanz ausf√ºhren, dh Klammern f√ºr ein Objekt dieser Klasse aufrufen, und dies k√∂nnen wir dank des <code>invoke</code> tun. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25f/3a1/f95/25f3a1f95c8c61dcb4937822bd9578e6.jpg"><br><br>  In Klammern k√∂nnen wir die Aufrufmethode aufrufen und haben einen Operator-Modifikator.  Wenn wir diesem Operator ein Lambda mit Kontext √ºbergeben, erhalten wir eine solche Konstruktion. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6b/61d/675/b6b61d67518cb1dc730bce8e309ae0dc.jpg"><br><br>  Jedes Mal Instanzen zu erstellen ist eine andere Aktivit√§t, sodass wir vorheriges und aktuelles Wissen kombinieren k√∂nnen. <br><br>  Lassen Sie uns einen Singleton erstellen, ihn als Zeitplan bezeichnen, innerhalb dessen wir den Aufrufoperator deklarieren, innerhalb einen Kontext erstellen und ein Lambda mit dem hier erstellten Kontext akzeptieren.  Es stellt sich heraus, dass es sich um einen einzelnen Einstiegspunkt in unser DSL handelt, und als Ergebnis erhalten wir den gleichen Konstruktionsplan mit geschweiften Klammern. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53a/41f/7d8/53a41f7d8e9067b6ce850045e745fb4f.jpg"><br><br>  Nun, wir haben √ºber den Zeitplan gesprochen. Schauen wir uns unsere Schecks an. <br>  Wir haben Lehrer, wir haben eine Art Zeitplan erstellt, und wir m√∂chten √ºberpr√ºfen, ob im Zeitplan dieses Lehrers an einem bestimmten Tag in einer bestimmten Lektion ein Objekt vorhanden ist, mit dem wir arbeiten werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22d/0e3/9ef/22d0e39ef38ceb43fd60654de876691b.jpg"><br><br>  Ich m√∂chte eckige Klammern verwenden und auf unseren Zeitplan so zugreifen, dass er optisch wie der Zugriff auf Arrays aussieht. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e6/895/b9e/1e6895b9ed089ed99d4c2639e6e1f578.jpg"><br><br>  Dies kann mit dem Operator erfolgen: get / set: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/815/9f5/a86/8159f5a8628b6c5bb21d219e395ea32b.jpg"><br><br>  Hier machen wir nichts Neues, folgen Sie einfach den Konventionen.  Im Fall des Set-Operators m√ºssen wir die Werte zus√§tzlich an unsere Methode √ºbergeben: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c8/03d/2f2/4c803d2f20ed8b7f79e308d47b734bd9.jpg"><br><br>  Die eckigen Klammern zum Lesen werden also zu get, und die eckigen Klammern, durch die wir sie zuweisen, werden zu set. <br><br><h2>  Demo: Objekt, Operatoren </h2><br>  Sie k√∂nnen entweder weiteren Text lesen oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Video hier ansehen</a> .  Das Video hat eine eindeutige Startzeit, es ist jedoch keine Endzeit angegeben. Grunds√§tzlich k√∂nnen Sie es nach dem Start vor dem Ende des Artikels ansehen. <br><br>  Der Einfachheit halber werde ich kurz auf die Essenz des Videos direkt im Text eingehen. <br><br>  Schreiben wir einen Test.  Wir haben ein Zeitplanobjekt, und wenn wir √ºber Strg + b zu dessen Implementierung gehen, werden wir alles sehen, wor√ºber ich zuvor gesprochen habe. <br><br><img src="https://habrastorage.org/webt/uk/pg/0d/ukpg0djbwn_hfyq4a7g9usa65aa.png"><br><br>  Innerhalb des Zeitplanobjekts m√∂chten wir die Daten initialisieren, dann einige √úberpr√ºfungen durchf√ºhren, und innerhalb der Daten m√∂chten wir Folgendes sagen: <br><br><ul><li>  Unsere Schule ist ab 8 Uhr morgens ge√∂ffnet. <br></li><li>  Es gibt eine Reihe von Elementen, f√ºr die wir einen Zeitplan erstellen werden. <br></li><li>  Es gibt einige Lehrer, die eine Art Zug√§nglichkeit beschrieben haben. <br></li><li>  einen Studenten haben; <br></li><li>  Grunds√§tzlich m√ºssen wir f√ºr einen Studenten nur sagen, dass er ein bestimmtes Fach studiert. <br></li></ul><br><img src="https://habrastorage.org/webt/v_/mq/ia/v_mqia50010hyrqza7zubejj62e.png"><br><br>  Und hier zeigt sich einer der Nachteile von Kotlin und problemorientierten Sprachen im Prinzip: Es ist ziemlich schwierig, einige Objekte zu adressieren, die wir zuvor erstellt haben.  In dieser Demo werde ich alles als Indizes angeben, dh Rus ist Index 0, Mathe ist Index 2. Und der Lehrer f√ºhrt nat√ºrlich auch etwas.  Er geht nicht nur zur Arbeit, sondern besch√§ftigt sich mit etwas.  F√ºr Leser dieses Artikels m√∂chte ich eine weitere Option f√ºr die Adressierung anbieten. Sie k√∂nnen eindeutige Tags erstellen und Entit√§ten in Map speichern. Wenn Sie auf eines davon zugreifen m√ºssen, k√∂nnen Sie es immer nach Tag suchen.  Zerlegen Sie das DSL weiter. <br><br>  Hier ist Folgendes zu beachten: Erstens haben wir den Operator +, zu dessen Implementierung wir auch sehen k√∂nnen, dass wir tats√§chlich die DayPointer-Klasse haben, die uns hilft, all dies mit Hilfe des Operators zu binden. <br><br>  Und dank der Tatsache, dass wir Zugriff auf den Kontext haben, sagt uns die Entwicklungsumgebung, dass wir in unserem Kontext √ºber dieses Schl√ºsselwort Zugriff auf eine Sammlung haben und diese verwenden werden. <br><br><img src="https://habrastorage.org/webt/l_/3q/uw/l_3quwu2xaqlxikn71jhpnnero4.png"><br><br>  Das hei√üt, wir haben eine Sammlung von Ereignissen.  Das Ereignis enth√§lt eine Reihe von Eigenschaften, zum Beispiel: Es gibt einen Sch√ºler, einen Lehrer, an welchem ‚Äã‚ÄãTag sie sich in welcher Lektion treffen. <br><br><img src="https://habrastorage.org/webt/fn/1f/xa/fn1fxa5legi4mwszf5xbudchoi0.png"><br><br>  Wir schreiben den Test weiter. <br><br><img src="https://habrastorage.org/webt/vj/bt/s9/vjbts9wb6fely-atqa-kr88i9qm.png"><br><br>  Auch hier verwenden wir den get-Operator. Es ist nicht so einfach, zu seiner Implementierung zu gelangen, aber wir k√∂nnen es tun. <br><br><img src="https://habrastorage.org/webt/iz/gd/dv/izgddvy3bomaqjp_6yvbfrbcgpe.png"><br><br>  Tats√§chlich folgen wir einfach der Vereinbarung, damit wir Zugriff auf dieses Design erhalten. <br>  Kehren wir zur Pr√§sentation zur√ºck und setzen das Gespr√§ch √ºber Kotlin fort.  Wir wollten, dass die √úberpr√ºfungen bei Kotlin durchgef√ºhrt werden, und haben diese Ereignisse durchlaufen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/f23/a77/b4ff23a77974a299ecac5c1c3b5d984f.jpg"><br><br>  Ein Ereignis ist im Wesentlichen eine gekapselte Menge von 4 Eigenschaften.  Ich m√∂chte dieses Ereignis in eine Reihe von Eigenschaften wie ein Tupel zerlegen.  Im Russischen wird eine solche Konstruktion als <i>Mehrfachdeklaration</i> (ich habe nur eine solche √úbersetzung gefunden) oder als <i>Strukturierungsdeklaration</i> bezeichnet und funktioniert wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2c/185/5f1/f2c1855f1ee98b51a4bda6ce9cc0b0a8.jpg"><br><br>  Wenn einer von Ihnen mit dieser Funktion nicht vertraut ist, funktioniert sie folgenderma√üen: Sie k√∂nnen das Ereignis aufnehmen und an der Stelle, an der es verwendet wird, mithilfe von Klammern in eine Reihe von Eigenschaften zerlegen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/444/95f/0a3/44495f0a381b71a20578736f0cb491af.jpg"><br><br>  Dies funktioniert, weil wir eine componentN-Methode haben, dh eine Methode, die vom Compiler dank des Datenmodifikators generiert wird, den wir vor der Klasse schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/126/db9/d78/126db9d789acf9b3482f314d5a53261f.jpg"><br><br>  Gleichzeitig fliegen eine Vielzahl anderer Methoden zu uns.  Wir interessieren uns f√ºr die componentN-Methode, die basierend auf den in der Parameterliste des Prim√§rkonstruktors aufgef√ºhrten Eigenschaften generiert wird. <br><br><img src="https://habrastorage.org/webt/hd/nf/ou/hdnfoutg14046a351gjyhodfprc.png"><br><br>  Wenn wir keinen Datenmodifikator h√§tten, m√ºsste manuell ein Operator geschrieben werden, der dasselbe tut. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e2b/37f/a2f/e2b37fa2fad7cd8e201987c32fbf572b.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e59/bc7/479/e59bc7479e66cd96c4d0d5093ef33608.jpg"><br><br>  Wir haben also einige componentN-Methoden, die sich in einen solchen Aufruf zerlegen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96a/cae/aa9/96acaeaa91222d55c4a77b70c9b02903.jpg"><br><br>  Im Wesentlichen ist es syntaktischer Zucker √ºber den Aufruf mehrerer Methoden. <br><br>  Wir haben bereits √ºber eine Verf√ºgbarkeitstabelle gesprochen, und tats√§chlich habe ich Sie get√§uscht.  Es passiert.  Es gibt keine <code>avaiabilityTable</code> , sie liegt nicht in der Natur, aber es gibt eine Matrix von Booleschen Werten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/393/d7d/5d7/393d7d5d739ea9cecedadff695ca6874.jpg"><br><br>  Es ist keine zus√§tzliche Klasse erforderlich: Sie k√∂nnen die Matrix der Booleschen Werte zur besseren √úbersichtlichkeit umbenennen.  Dies kann mit den sogenannten <i>Typealias</i> oder <i>Type Alias ‚Äã‚Äãerfolgen</i> .  Leider erhalten wir keine zus√§tzlichen Boni, es ist nur eine Umbenennung.  Wenn Sie die Verf√ºgbarkeit √ºbernehmen und sie wieder in die Matrix der Booleschen Werte umbenennen, √§ndert sich √ºberhaupt nichts.  Der Code hat funktioniert und wird funktionieren. <br><br>  Werfen wir einen Blick auf den Lehrer, genau diese Zug√§nglichkeit, und sprechen √ºber ihn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/521/031/f59/521031f59a8e7b222c2614b32ba88abd.jpg"><br><br>  Wir haben einen Lehrer, und die Verf√ºgbarkeitsmethode wird aufgerufen (haben Sie den Faden der Argumentation noch nicht verloren? :-).  Woher kam er?  Das hei√üt, ein Lehrer ist eine Art Entit√§t, die eine Klasse hat, und dies ist ein Gesch√§ftscode.  Und es kann keine zus√§tzliche Methode geben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54e/044/683/54e0446838b2360d695b45e5bacec69d.jpg"><br><br>  Diese Methode wird aufgrund von Erweiterungsfunktionen angezeigt.  Wir √ºbernehmen eine andere Funktion, die wir f√ºr Objekte dieser Klasse ausf√ºhren k√∂nnen, und befestigen sie an unserer Klasse. <br>  Wenn wir dieser Funktion etwas Lambda √ºbergeben und es dann f√ºr eine vorhandene Eigenschaft ausf√ºhren, ist alles in Ordnung - die Verf√ºgbarkeitsmethode in ihrer Implementierung initialisiert die Verf√ºgbarkeitseigenschaft.  Sie k√∂nnen dies loswerden.  Wir kennen bereits den Aufrufoperator, der an einen Typ angeh√§ngt werden kann und gleichzeitig eine Erweiterungsfunktion ist.  Wenn Sie diesem Operator ein Lambda √ºbergeben, k√∂nnen wir dieses Lambda genau dort mit dem Schl√ºsselwort this ausf√ºhren.  Wenn wir mit einem Lehrer arbeiten, ist die Barrierefreiheit daher eine Eigenschaft des Lehrers und keine zus√§tzliche Methode, und hier findet keine Rassynchronisation statt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d6/1af/f71/4d61aff7169c403c75493790720c0e6e.jpg"><br><br>  Als Bonus k√∂nnen Erweiterungsfunktionen f√ºr nullbare Typen erstellt werden.  Dies ist gut, denn wenn es eine Variable mit einem nullbaren Typ gibt, die einen Nullwert enth√§lt, ist unsere Funktion bereits daf√ºr bereit und f√§llt nicht von NullPointer ab.  Innerhalb dieser Funktion kann dies null sein, und dies muss behandelt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59a/e33/1c5/59ae331c58bcd16003f51f870b89549e.jpg"><br><br>  Zusammenfassung der Erweiterungsfunktionen: Sie m√ºssen verstehen, dass nur auf die √∂ffentliche API der Klasse zugegriffen werden kann und die Klasse selbst in keiner Weise ge√§ndert wird.  Eine Erweiterungsfunktion wird durch den Typ der Variablen und nicht durch den tats√§chlichen Typ bestimmt.  Dar√ºber hinaus wird ein Mitglied der Klasse mit derselben Signatur priorisiert.  Sie k√∂nnen eine Erweiterungsfunktion f√ºr eine Klasse erstellen, diese jedoch in eine v√∂llig andere Klasse schreiben. Innerhalb dieser Erweiterungsfunktion k√∂nnen Sie gleichzeitig auf zwei Kontexte zugreifen.  Es stellt sich die Schnittstelle von Kontexten heraus.  Und schlie√ülich ist dies eine gro√üartige Gelegenheit, die Bediener im Allgemeinen an jedem Ort zu befestigen, an dem wir wollen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/1e8/610/a041e86102be21acf2c3170cf941d064.jpg"><br><br>  Das n√§chste Tool sind Infix-Funktionen.  Ein weiterer gef√§hrlicher Hammer in den H√§nden des Entwicklers.  Warum gef√§hrlich?  Was Sie sehen, ist Code.  Ein solcher Code kann in Kotlin geschrieben werden, und tun Sie es nicht!  Bitte nicht.  Trotzdem ist der Ansatz gut.  Dank dessen ist es m√∂glich, Punkte und Klammern zu entfernen - von all der lauten Syntax, von der wir versuchen, so weit wie m√∂glich wegzukommen und unseren Code ein wenig sauberer zu machen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/909/8c3/4a0/9098c34a06b09bac0597004c6fbf6b1a.jpg"><br><br>  Wie funktioniert es  Nehmen wir ein einfacheres Beispiel - eine ganzzahlige Variable.  Lassen Sie uns eine Erweiterungsfunktion daf√ºr erstellen, nennen wir es shouldBeEqual, es wird etwas tun, aber das ist nicht interessant.  Wenn wir den Infix-Modifikator links davon hinzuf√ºgen, ist das genug.  Sie k√∂nnen Punkte und Klammern entfernen, aber es gibt ein paar Nuancen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/39e/fc2/31f/39efc231fb88cee1ef014a36fcb6cc73.jpg"><br><br>  Auf dieser Grundlage wird nur das Daten- und Assertionskonstrukt implementiert und zusammengef√ºgt. <br><img src="https://habrastorage.org/getpro/habr/post_images/80f/6dd/126/80f6dd126255196fc538026ea28656c1.jpg"><br><br>  Lass es uns herausfinden.  Wir haben einen SchedulingContext - den allgemeinen Kontext f√ºr die Planung des Starts.  Es gibt eine Datenfunktion, die das Ergebnis dieser Planung zur√ºckgibt.  Gleichzeitig erstellen wir eine Erweiterungsfunktion und gleichzeitig die Zusicherungen der Infixfunktion, die ein Lambda starten, das unsere Werte √ºberpr√ºft. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/449/74c/fe5/44974cfe559d94d17e6435557757af80.jpg"><br><br>  Es gibt ein Subjekt, ein Objekt und eine Handlung, und Sie m√ºssen sie irgendwie verbinden.  In diesem Fall ist das Ergebnis der Ausf√ºhrung von Daten mit geschweiften Klammern das Thema.  Das Lambda, das wir an die Assertions-Methode √ºbergeben, ist ein Objekt, und die Assertions-Methode selbst ist eine Aktion.  All dies scheint zusammenzuhalten. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/518/aac/4e9/518aac4e9d92ca84a79e6cdb09fea773.jpg"><br><br>  Apropos Funktionsinfix: Es ist wichtig zu verstehen, dass dies ein Schritt ist, um verrauschte Syntax zu beseitigen.  Wir m√ºssen jedoch ein Subjekt und ein Objekt dieser Aktion haben und den Infix-Modifikator verwenden.  Es kann genau einen Parameter geben - das hei√üt, Nullparameter k√∂nnen nicht sein, zwei k√∂nnen nicht sein, drei - nun, Sie verstehen.  Sie k√∂nnen beispielsweise Lambdas an diese Funktion √ºbergeben und auf diese Weise Konstrukte erhalten, die Sie zuvor noch nicht gesehen haben. <br><br>  Fahren wir mit der n√§chsten Demo fort.  Es ist besser, das Video anzuschauen und den Text nicht zu lesen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Jetzt sieht alles fertig aus: Das Funktionsinfix, das Sie gesehen haben, die Erweiterung der Funktion, die Sie gesehen haben, die Destrukturierungsdeklaration ist fertig. <br><br>  Kehren wir zu unserer Pr√§sentation zur√ºck, und hier kommen wir zu einem ziemlich wichtigen Punkt beim Aufbau problemorientierter Sprachen - Sie sollten √ºber Kontextkontrolle nachdenken. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ff/0d3/57a/9ff0d357a3e39d01bcb3d5d07d81d71e.jpg"><br><br>  Es gibt Situationen, in denen wir DSL verwenden und direkt darin wiederverwenden k√∂nnen, aber wir m√∂chten dies nicht tun.  Unser Benutzer (m√∂glicherweise ein unerfahrener Benutzer) schreibt Daten in Daten, und das macht keinen Sinn.  Wir m√∂chten ihm das irgendwie verbieten. <br><br>  Vor Kotlin Version 1.1 mussten wir Folgendes tun: Als Reaktion auf die Tatsache, dass wir eine Datenmethode in <code>SchedulingContext</code> , mussten wir eine andere <code>DataContext</code> in <code>DataContext</code> erstellen, in die wir ein Lambda akzeptieren (wenn auch ohne Implementierung), sollten wir diese Methode markieren Anmerkung <code>@Deprecated</code> und <code>@Deprecated</code> Sie den Compiler an, dies nicht zu kompilieren.  Sie sehen, dass diese Methode startet - nicht kompilieren.  Mit diesem Ansatz erhalten wir sogar eine aussagekr√§ftige Nachricht, wenn wir bedeutungslosen Code schreiben. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dfb/7a7/0b4/dfb7a70b4fba1c5cb0bf37715a4fe1bd.jpg"><br><br>  Nach der Version Kotlin 1.1 erschien eine wundervolle Anmerkung <code>@DslMarker</code> .  Diese Anmerkung wird ben√∂tigt, um abgeleitete Anmerkungen zu kennzeichnen.  Mit ihnen werden wir wiederum problemorientierte Sprachen markieren.  F√ºr jede problemorientierte Sprache k√∂nnen Sie eine Anmerkung erstellen, die Sie als <code>@DslMarker</code> markieren, und sie an jeden ben√∂tigten Kontext h√§ngen.  Es besteht keine Notwendigkeit mehr, zus√§tzliche Methoden zu schreiben, deren Kompilieren verboten werden muss - alles funktioniert einfach.  Nicht kompiliert. <br><br>  Es gibt jedoch einen solchen Sonderfall, wenn wir mit unserem Gesch√§ftsmodell arbeiten.  Es ist normalerweise in Java geschrieben.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt einen Kontext, es gibt eine Anmerkung, die als Kontext markiert werden muss. </font><font style="vertical-align: inherit;">Was ist Ihrer Meinung nach der Kontext des Sch√ºlers innerhalb der Methode? </font><font style="vertical-align: inherit;">Klasse </font></font><code>Student</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies ist ein Teil unseres Gesch√§ftsmodells, Kotlin ist nicht da. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c6/111/c5c/4c6111c5c80ab5c4856e68c06880ed4a.jpg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cc3/572/a05/cc3572a054dabbe4e32362d845b30cf8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√∂chten diese Situation auch irgendwie kontrollieren, da in diesem Fall Zugriff auf das folgende Design besteht: Erstellen Sie einen Sch√ºler innerhalb der Sch√ºler. </font><font style="vertical-align: inherit;">Ich m√∂chte Sie nicht dazu bringen, falsche Assoziationen herzustellen, aber wir m√∂chten es verbieten, es ist falsch. </font></font><br><br><img width="100%" src="https://habrastorage.org/getpro/habr/post_images/2fd/77d/125/2fd77d1250c0677a24c1c9c358f11663.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben drei M√∂glichkeiten.</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie einen ganzen Kontext, der f√ºr unseren Sch√ºler verantwortlich ist. </font><font style="vertical-align: inherit;">Nennen wir es StudentContext. </font><font style="vertical-align: inherit;">Wir beschreiben dort alle Eigenschaften und erstellen darauf basierend einen Sch√ºler. </font><font style="vertical-align: inherit;">Eine Art Wahnsinn - eine Menge Code wird geschrieben, wahrscheinlich mehr als f√ºr die Produktion.</font></font><br></li><li>   ‚Äì      ,    ,     .        .  StudentContext  ,      IStudent       .  ,       Student,        IStudent  StudentContext.   DslMarker  ,  . <br></li><li>  :   deprecated     .   ,   .       ,   .       extension-,     .       . <br></li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/9ea/10d/d6a/9ea10dd6af4495be38653339010e0a46.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selbst auf dieser Ebene k√∂nnen Sie den Kontext steuern, jedoch mit einigen Einschr√§nkungen, die umgangen werden m√ºssen. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d7/9f9/53f/1d79f953fc755000013d44d15f56fb73.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung der Kontextsteuerung. </font><font style="vertical-align: inherit;">Sch√ºtzen Sie Ihre Benutzer vor Fehlern. </font><font style="vertical-align: inherit;">Es ist klar, dass Benutzer keine Fehler machen werden, da dies offensichtlich ist, aber es immer noch w√ºnschenswert ist, dies zu kontrollieren. </font><font style="vertical-align: inherit;">Dar√ºber hinaus kostet die Implementierung einer solchen Kontrolle nicht so viel Geld und Zeit. </font><font style="vertical-align: inherit;">Verwenden Sie die Annotation @DslMarker, mit der Sie Ihre eigenen Annotationen versehen. </font><font style="vertical-align: inherit;">In Situationen, in denen Sie die Annotation @DslMarker nicht verwenden k√∂nnen, verwenden Sie die Annotation @Deprecated. Auf diese Weise k√∂nnen Sie die F√§lle umgehen, die noch nicht funktionieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, die Kontextkontroll-Demo:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q_UM1EY2S5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><img src="https://habrastorage.org/getpro/habr/post_images/16c/690/f58/16c690f589bf90cc1547edc1ee985ae0.jpg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nachteile und Probleme </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstens die Wiederverwendung von DSL-Teilen. Sie haben bereits heute gesehen, dass das Adressieren von mit DSL erstellten Entit√§ten problematisch sein kann. Es gibt M√∂glichkeiten, dies zu umgehen, aber es ist ratsam, im Voraus dar√ºber nachzudenken, um einen Plan daf√ºr zu haben.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stellen Sie sich vor, Sie haben einen Code und m√∂chten ihn beispielsweise nur in einem Zyklus wiederholen, um Sch√ºler, viele, viele Male dieselben Sch√ºler oder eine andere Entit√§t erstellen zu k√∂nnen. Wie kann man das machen? Sie k√∂nnen die for-Schleife verwenden - nicht die beste Option. Sie k√∂nnen eine zus√§tzliche Methode in Ihrem DSL erstellen. Dies ist eine bessere L√∂sung. Sie m√ºssen diese Probleme jedoch direkt auf DSL-Ebene l√∂sen. Achten Sie auf das Schl√ºsselwort this und die Standardbenennung des Parameters it. Gl√ºcklicherweise haben wir mit der Kotlin-Version des Plugins 1.2.20 Hinweise, die direkt in der Entwicklungsumgebung sichtbar sind. Der graue Code sagt uns, mit welchem ‚Äã‚ÄãKontext wir arbeiten oder was es ist.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschachtelung kann ein Problem sein. Sie haben eine sch√∂ne DSL-Datei erstellt, aber die Initialisierung des Modells geht tiefer, tiefer, tiefer. Daher verwenden Sie h√§ufig eher einen horizontalen als einen vertikalen Bildlauf. Es ist ratsam, Standardwerte unter der Standardimplementierung auszublenden. Ein Benutzer, der nur einen Sch√ºler ben√∂tigt, m√∂chte nichts √ºber ein Schulungsprogramm oder etwas anderes wissen. Er m√∂chte nur einen Sch√ºler ohne Details erstellen und nicht einmal einen Namen angeben. Versuchen Sie, die Syntax zu verk√ºrzen. Geben Sie beispielsweise einige Standardwerte an, √ºbergeben Sie ein leeres Lambda usw.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Schluss die Dokumentation. Meiner subjektiven Meinung nach ist die beste Dokumentation f√ºr Ihre problemorientierte Sprache mehr als die Anzahl der Beispiele f√ºr dieses DSL. Gro√üartig, wenn Sie Kotlin-Docks haben. Dies ist ein guter Bonus. Wenn der DSL-Benutzer jedoch keine Ahnung hat, welche Designs verf√ºgbar sind, k√∂nnen er und die Kotlin-Docks nirgendwo suchen. Hast du das jemals gef√ºhlt? Wenn Sie gleich zu Beginn eine Gradle-Datei schreiben, verstehen Sie nicht, was darin enthalten ist, und ben√∂tigen einige Beispiele. Sie k√ºmmern sich nicht um Kontexte, Sie m√∂chten Beispiele, und dies ist die beste Dokumentation, die von neuen Benutzern Ihres DSL verwendet werden kann.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/13e/4e0/05a/13e4e005af12def0ee687b008ffc41ac.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setzen Sie DSLs bitte nicht in alle Ritzen. Ich m√∂chte das wirklich tun, wenn Sie dieses Tool besitzen. Ich m√∂chte sagen, lassen Sie uns hier, vielleicht hier und hier, ein DSL erstellen. Erstens ist dies ein undankbarer Job. Zweitens ist es immer noch w√ºnschenswert, dies am Zielort anzuwenden. Wo es Ihnen wirklich hilft, ein Problem zu l√∂sen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich lernen Kotlin. Entdecken Sie die M√∂glichkeiten, die diese Sprache bietet, neue Funktionen, damit Ihr Code sauberer, k√ºrzer und kompakter wird und viel einfacher zu lesen ist. Und wenn Sie wieder zum Testen zur√ºckkehren (z. B. wenn Sie etwas hinzugef√ºgt haben, m√ºssen Sie einen Test daf√ºr durchf√ºhren), werden Sie dies viel mehr tun, da DSL so kompakt und komfortabel wie m√∂glich ist und Sie kein Problem damit haben, ein Dutzend zu erstellen Studenten. Nur in ein paar Zeilen ist dies erledigt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trainiere "Katzen" als Held eines ber√ºhmten Films. Meiner Meinung nach ist es zun√§chst einfacher, Kotlin als Test in Ihr Projekt einzubeziehen. Dies ist eine gute Gelegenheit, die Sprache zu √ºberpr√ºfen, auszuprobieren und sich die Funktionen anzusehen. Dies ist so ein Schlachtfeld, auf dem man es auch dann benutzen kann, wenn nichts funktioniert.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√ülich entwerfen Sie das DSL vor. Heute habe ich ein perfektes Beispiel gezeigt, und wir sind schrittweise gegangen, um eine problemorientierte Sprache aufzubauen. Wenn Sie das DSL vorab entwerfen, wird es letztendlich viel einfacher. Sie werden es nicht zehnmal umgestalten. Sie m√ºssen sich keine Sorgen machen, dass sich die Kontexte irgendwie √ºberschneiden und logisch stark miteinander verbunden sind. Entwerfen Sie das DSL einfach vorab - es ist ziemlich einfach, es auf einem Blatt Papier zu tun, wenn Sie die Entw√ºrfe kennen, die ich Ihnen heute erz√§hlt habe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und schlie√ülich Kontakte f√ºr die Kommunikation. Mein Name ist Ivan Osipov, Telegramm: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@ivan_osipov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Twitter: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@_osipov_</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Habr: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i_osipov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich werde auf Ihre Kommentare warten.</font></font><br><br><blockquote>  Minute der Werbung.        <b>JPoint</b> ‚Äî  ,  19-20   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Joker 2018</a> ‚Äî    Java-.       .    ,         . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416725/">https://habr.com/ru/post/de416725/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416711/index.html">Seiten der Intel-Geschichte. Fabrikfeuer in Penang</a></li>
<li><a href="../de416713/index.html">Bericht des Club of Rome 2018, Kapitel 3.14: ‚ÄûKein einziges BIP ...‚Äú</a></li>
<li><a href="../de416719/index.html">Erweiterung PHP und Kotlin Native. Teil Zwei, bewusst</a></li>
<li><a href="../de416721/index.html">DIY House: Puppenh√§user f√ºr Erwachsene</a></li>
<li><a href="../de416723/index.html">API-Barrierefreiheit: Schnittstellen in nat√ºrlicher Sprache</a></li>
<li><a href="../de416727/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 2: ‚ÄûKontrolle von Hackerangriffen‚Äú, Teil 3</a></li>
<li><a href="../de416729/index.html">Das Programm von PYCON RUSSIA ist fertig: 25 Berichte und 3 Workshops von Rednern von Google, Red Hat, Yelp und Yandex</a></li>
<li><a href="../de416731/index.html">Frost auf Glas: Wie man Hochleistungskunststoff aus Metall herstellt</a></li>
<li><a href="../de416737/index.html">A * Pfadfindungsalgorithmus in einem Voxel 3d Unity-Spiel</a></li>
<li><a href="../de416739/index.html">Neues ASUS auf der Computex 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>