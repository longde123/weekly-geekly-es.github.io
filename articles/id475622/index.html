<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥓 💜 👩🏻‍🔧 Memperluas UObject di Unreal Engine 4 👨🏻‍🚒 😱 🙅🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Nama saya Alexander, saya telah bekerja dengan Unreal Engine selama lebih dari 5 tahun, dan hampir selama ini - dengan proyek jaringan....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memperluas UObject di Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/475622/"><p>  Halo semuanya!  Nama saya Alexander, saya telah bekerja dengan Unreal Engine selama lebih dari 5 tahun, dan hampir selama ini - dengan proyek jaringan. <br><br>  Karena proyek jaringan berbeda dalam persyaratan pengembangan dan kinerjanya, seringkali perlu untuk bekerja dengan objek yang lebih sederhana, seperti kelas UObject, tetapi fungsinya pada awalnya terpotong, yang dapat menciptakan kerangka kerja yang kuat.  Pada artikel ini, saya akan berbicara tentang cara mengaktifkan berbagai fungsi di kelas dasar UObject di Unreal Engine 4. <br><br><img src="https://habrastorage.org/webt/fe/7o/ui/fe7ouisyxz09hjfen72lsdvx5ae.png"><br><br></p><p>  Padahal, saya lebih banyak menulis artikel sebagai referensi.  Sebagian besar informasi sangat sulit ditemukan dalam dokumentasi atau komunitas, dan di sini Anda dapat dengan cepat membuka tautan dan menyalin kode yang diinginkan.  Saya memutuskan pada saat yang sama untuk berbagi dengan Anda!  Artikel ini ditujukan untuk mereka yang sudah sedikit terbiasa dengan UE4.  Kode C ++ akan dipertimbangkan, meskipun tidak perlu mengetahuinya.  Anda cukup mengikuti petunjuk jika Anda perlu sesuatu untuk dibicarakan.  Selain itu, tidak perlu menyalin semuanya, Anda dapat menempelkan kode dari bagian dengan properti yang diperlukan dan itu harus bekerja. <a name="habracut"></a></p><br><br><h2>  Sedikit tentang UObject </h2><br>  <b>UObject</b> adalah kelas dasar untuk hampir semua yang ada di Unreal Engine 4. Mayoritas objek yang dibuat di dunia Anda atau hanya di memori diwarisi darinya: objek di atas panggung (AActor), komponen (UActorComponent), berbagai jenis untuk bekerja dengan data dan lainnya. <br><br>  Kelas itu sendiri, meskipun lebih mudah daripada turunannya, pada saat yang sama cukup fungsional.  Misalnya, ini berisi banyak peristiwa bermanfaat, seperti mengubah nilai variabel dalam editor dan fungsi dasar untuk jaringan, yang tidak aktif secara default. <br><br>  Objek yang dibuat oleh kelas ini tidak bisa di atas panggung dan ada secara eksklusif di memori.  Mereka tidak dapat ditambahkan sebagai komponen ke Aktor, meskipun itu bisa menjadi semacam komponen jika Anda menerapkan sendiri fungsionalitas yang diperlukan. <br><br><p>  Mengapa saya perlu UObject jika AActor sudah mendukung semua yang saya butuhkan?  Secara umum, ada banyak contoh penggunaan.  Paling mudah adalah barang inventaris.  Di atas panggung, di suatu tempat di langit, tidak praktis untuk menyimpannya, sehingga Anda dapat menyimpannya di memori tanpa memuat render dan tanpa membuat properti yang tidak perlu.  Bagi mereka yang menyukai perbandingan teknis, AActor mengambil satu kilobyte (1016 bytes), dan sebuah UObject kosong hanya 56 byte. </p><br><br><h2>  Apa itu masalah UObject? </h2><br>  Tidak ada masalah secara umum, atau saya tidak menemukan mereka.  Semua yang mengganggu UObject adalah kurangnya berbagai fitur yang tersedia secara default di AActor atau komponen.  Berikut adalah masalah yang telah saya identifikasi untuk praktik saya: <br><br><ul><li>  UObjects tidak direplikasi melalui jaringan; </li><li>  karena poin pertama, kami tidak dapat memicu peristiwa RPC; </li><li>  Anda tidak dapat menggunakan serangkaian fungsi luas yang membutuhkan tautan ke dunia dalam Cetak Biru; </li><li>  mereka tidak memiliki acara standar seperti BeginPlay dan Centang; </li><li>  Anda tidak dapat menambahkan komponen dari UObjects ke AActor di Blueprints. </li></ul><br><p>  Sebagian besar hal dapat dengan mudah diselesaikan.  Tetapi beberapa harus mengotak-atik. </p><br><br><h2>  Membuat UObject </h2><br>  Sebelum memperluas kelas kami dengan fitur, kami harus membuatnya.  Mari kita gunakan editor sehingga generator secara otomatis menulis semua yang diperlukan untuk bekerja ke header (.h). <br><br>  Kita dapat membuat kelas baru di editor Browser Konten dengan mengklik tombol <i>Baru</i> dan memilih <i>Kelas C ++ Baru</i> . <br><br><img src="https://habrastorage.org/webt/x3/7r/8d/x37r8d1ahvstuxtpdnafshrnp9m.png"><br><br>  Selanjutnya, kita perlu memilih kelas itu sendiri.  Mungkin tidak ada dalam daftar umum, oleh karena itu, buka dan pilih UObject. <br><br><img src="https://habrastorage.org/webt/p2/7d/dh/p27ddhbtq9bxgmjzobmozoa1tlk.png"><br><br>  Beri nama kelas Anda dan pilih di folder mana itu akan disimpan.  Ketika kami membuat kelas, Anda dapat masuk ke studio, menemukannya di sana dan mulai menanamkan semua fungsi yang diperlukan. <br><br>  <i>Pemula, perhatikan bahwa dua file dibuat: .h dan .ccp.</i>  <i>Di .h, Anda akan mendeklarasikan variabel dan fungsi, dan dalam .cpp Anda akan mendefinisikan logikanya.</i>  <i>Temukan kedua file di proyek Anda.</i>  <i>Jika Anda tidak mengubah jalur, maka mereka harus di Project / Source / Project /.</i> <br><br>  Sampai kita melanjutkan, mari kita menulis parameter <i>Blueprintable</i> di makro UCLASS () di atas deklarasi kelas.  Anda harus mendapatkan sesuatu seperti ini: <br><br>  <b>.h</b> <br><br><pre><code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() }</code> </pre> <br><p>  Berkat ini, Anda dapat membuat Cetak Biru yang akan mewarisi semua yang kami lakukan dengan objek ini. </p><br><br><h2>  Replikasi UObject </h2><br>  Secara default, UObjects tidak direplikasi melalui jaringan.  Seperti yang saya jelaskan di atas, sejumlah pembatasan dibuat ketika Anda perlu menyinkronkan data atau logika antara para pihak, tetapi jangan menyimpan sampah di dunia. <br><br>  Di Unreal Engine 4, replikasi terjadi justru karena benda-benda dunia.  Ini berarti bahwa hanya membuat objek dalam memori dan mereplikasi akan gagal.  Bagaimanapun, Anda akan memerlukan pemilik yang akan mengelola transfer data objek antara server dan klien.  Misalnya, jika objek Anda adalah keterampilan karakter, maka karakter itu sendiri harus menjadi pemilik.  Dia juga akan menjadi konduktor untuk mengirimkan informasi melalui jaringan. <br><br>  Persiapkan objek kita untuk replikasi.  Sejauh ini di header kita hanya perlu menetapkan satu fungsi: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }</code> </pre><br>  <i>IsSupportedForNetworking ()</i> akan menentukan bahwa objek mendukung jaringan dan dapat direplikasi. <br><br>  Namun, tidak semuanya begitu sederhana.  Seperti yang saya tulis di atas, Anda memerlukan pemilik yang mengontrol transfer objek.  Untuk kemurnian percobaan, buat AActor yang akan mereplikasi itu.  Ini dapat dilakukan dengan cara yang persis sama dengan UObject, hanya kelas induk, tentu saja, AActor. <br><br>  <i>Pemula, jika Anda perlu mereplikasi objek dalam karakter, controller, atau di tempat lain, buat kelas dasar yang sesuai melalui editor, tambahkan logika yang diperlukan untuk itu, dan sudah mewarisi dari kelas ini dalam Cetak Biru.</i> <br><br>  Di dalam kita memerlukan 3 fungsi: konstruktor, fungsi untuk mereplikasi sub-objek, fungsi yang menentukan apa yang direplikasi di dalam AActor ini (variabel, referensi objek, dll.) Dan tempat di mana kita membuat objek kita. <br><br>  Jangan lupa untuk membuat variabel yang dengannya objek kita akan disimpan: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AMyActor(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplicateSubobjects</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginPlay</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; UPROPERTY(Replicated, BlueprintReadOnly, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObject</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br>  Di dalam file sumber kita harus menulis semuanya: <br><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyActor.h" #include "Net/UnrealNetwork.h" #include "Engine/World.h" #include "Engine/ActorChannel.h" #include "   UObject/MyObject.h" AMyActor::AMyActor() { //  Actor  . bReplicates = true // . NetCullDistanceSquared = 99999; //  (  ). NetUpdateFrequency = 1.f; } void AMyActor::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //       .           . DOREPLIFETIME(AMyActor, MyObject); } bool AMyActor::ReplicateSubobjects(UActorChannel * Channel, FOutBunch * Bunch, FReplicationFlags * RepFlags) { bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags); //   . if (MyObject ) WroteSomething |= Channel-&gt;ReplicateSubobject(MyObject , *Bunch, *RepFlags); return WroteSomething; } AMyActor::BeginPlay() { /*       (  )  .    this.        . ,       ,     . */ if(HasAuthority()) { MyObject = NewObject&lt;UMyObject&gt;(this); //       if(MyObject) UE_LOG(LogTemp, Log, TEXT("%s created"), *MyObject-&gt;GetName()); } }</span></span></code> </pre><br><p>  Sekarang objek Anda akan direplikasi dengan Aktor ini.  Anda dapat menampilkan namanya pada centang, tetapi sudah pada klien.  Harap dicatat bahwa pada Mulai Mainkan suatu objek tidak mungkin tiba sebelum klien, jadi tidak ada gunanya menulis log di atasnya. </p><br><br><h2>  Replikasi variabel dalam UObject </h2><br>  Dalam kebanyakan kasus, tidak masuk akal untuk mereplikasi objek jika tidak mengandung informasi yang juga akan disinkronkan antara server dan klien.  Karena objek kita sudah direplikasi, meneruskan variabel tidak sulit.  Ini dilakukan dengan cara yang sama seperti di dalam Aktor kami: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; UPROPERTY(Replicated, BlueprintReadWrite, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MyInteger; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyObject.h" #include "Net/UnrealNetwork.h" UMyObject ::UMyObject () { //  Object  .     . bReplicates = true //       ,     . } void UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //   Integer  . DOREPLIFETIME(UMyObject, MyInteger); } }</span></span></code> </pre><br>  Dengan menambahkan variabel dan menandai untuk replikasi, kita dapat mereplikasi.  Semuanya sederhana dan sama seperti di AActor. <br><br>  Namun, ada jebakan kecil yang tidak langsung terlihat, tetapi bisa menyesatkan.  Ini akan sangat terlihat jika Anda membuat UObject bukan untuk bekerja di C ++, tetapi mempersiapkannya untuk warisan dan bekerja di Cetak Biru. <br><br>  Intinya adalah bahwa variabel yang dibuat dalam pewaris Blueprints tidak akan direplikasi.  Mesin tidak secara otomatis menandai mereka dan mengubah parameter pada server di BP tidak mengubah apa pun dalam nilai pada klien.  Tetapi ada obat untuk ini.  Untuk replikasi variabel BP yang benar, Anda harus menandainya terlebih dahulu.  Tambahkan beberapa baris ke GetLifetimeReplicatedProps (): <br><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); <span class="hljs-comment"><span class="hljs-comment">//   Integer  . DOREPLIFETIME(UMyObject, MyInteger); //       UBlueprintGeneratedClass* BPClass = Cast&lt;UBlueprintGeneratedClass&gt;(GetClass()); if (BPClass) BPClass-&gt;GetLifetimeBlueprintReplicationList(OutLifetimeProps); }</span></span></code> </pre><br><p>  Variabel dalam kelas cetak biru anak sekarang akan mereplikasi seperti yang diharapkan. </p><br><br><h2>  Peristiwa RPC di UObject </h2><br>  Peristiwa RPC (Remote Procedure Call) adalah fungsi khusus yang dipanggil di sisi lain dari interaksi jaringan proyek.  Menggunakannya, Anda dapat memanggil fungsi dari server di klien lain dan dari klien di server.  Sangat berguna dan sering digunakan ketika menulis proyek jaringan. <br><br>  <i>Jika Anda tidak terbiasa dengan mereka, saya sarankan membaca satu artikel.</i>  <i>Ini menjelaskan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan dalam C ++ dan dalam Cetak Biru</a> .</i> <br><br>  Meskipun tidak ada masalah dalam Aktor atau dalam komponen dengan panggilan mereka, dalam peristiwa UObject menembak pada sisi yang sama di mana mereka dipanggil, yang membuat tidak mungkin untuk membuat panggilan jarak jauh ketika dibutuhkan. <br><br>  Melihat kode komponen (UActorComponent), kami dapat menemukan beberapa fungsi yang memungkinkan Anda untuk mentransfer panggilan melalui jaringan.  Karena UActorComponent diwarisi dari UObject, kita dapat dengan mudah menyalin bagian kode yang diperlukan dan menempel ke objek kita sehingga berfungsi seperti seharusnya: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/EngineTypes.h" UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() public: virtual bool CallRemoteFunction (UFunction * Function, void * Parms, struct FOutParmRec * OutParms, FFrame * Stack) override; virtual int32 GetFunctionCallspace (UFunction* Function, void* Parameters, FFrame* Stack) override; //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/NetDriver.h" //       . bool UMyObject::CallRemoteFunction(UFunction * Function, void * Parms, FOutParmRec * OutParms, FFrame * Stack) { if (!GetOuter()) return false; UNetDriver* NetDriver = GetOuter()-&gt;GetNetDriver(); if (!NetDriver) return false; NetDriver-&gt;ProcessRemoteFunction(GetOuter(), Function, Parms, OutParms, Stack, this); return true; } int32 UMyObject::GetFunctionCallspace(UFunction * Function, void * Parameters, FFrame * Stack) { return (GetOuter() ? GetOuter()-&gt;GetFunctionCallspace(Function, Parameters, Stack) : FunctionCallspace::Local); }</span></span></code> </pre><br>  Dengan fungsi-fungsi ini, kita akan dapat memicu peristiwa RPC tidak hanya dalam kode, tetapi juga dalam cetak biru. <br><br><p>  Harap dicatat bahwa untuk memicu peristiwa Klien atau Server, Anda memerlukan pemilik yang Pemiliknya adalah pemain kami.  Misalnya, objek dimiliki oleh karakter pengguna atau objek di mana Pemilik adalah Pengontrol Pemain pemain. </p><br><br><h2>  Fitur Global dalam Cetak Biru </h2><br>  Jika Anda pernah membuat Cetak Biru Object, Anda mungkin telah memperhatikan bahwa Anda tidak dapat memanggil fungsi global (statis, tetapi demi kejelasan kami menyebutnya) yang tersedia di kelas lain, misalnya, GetGamemode ().  Tampaknya Anda tidak bisa melakukan kelas di kelas Object, karena itu Anda harus melewati semua tautan saat membuat, atau entah bagaimana memutarbalikkan, dan kadang-kadang pilihannya sepenuhnya jatuh pada kelas Aktor yang dibuat di atas panggung dan mendukung semuanya. <br><br>  Tetapi dalam C ++, tentu saja, tidak ada masalah seperti itu.  Namun, perancang permainan, yang bermain dengan pengaturan dan menambahkan hal-hal kecil yang berbeda, tidak bisa mengatakan bahwa Anda perlu membuka Visual Studio, menemukan kelas yang sesuai dan mendapatkan mode permainan dalam fungsi doSomething () dengan mengubah titik di dalamnya.  Oleh karena itu, sangat penting bahwa perancang dapat masuk ke Bluprint dan dengan dua klik melakukan pekerjaannya.  Hemat waktu dan miliknya.  Namun, Cetak Biru diciptakan untuk ini. <br><br>  Intinya adalah bahwa ketika Anda mencari atau memanggil fungsi dalam menu konteks di Bluprint, fungsi-fungsi global yang sama yang memerlukan referensi ke dunia mencoba memanggil fungsi di dalam objek Anda yang merujuk padanya.  Dan jika editor melihat bahwa tidak ada fungsi, dia mengerti bahwa dia tidak dapat menggunakannya dan tidak menunjukkannya dalam daftar. <br><br><img src="https://habrastorage.org/webt/bb/mj/gu/bbmjguakea7gkb-roirojnwnrsg.png"><br><br>  Namun, ada obatnya untuk ini.  Bahkan dua. <br><br>  Pertama-tama mari kita pertimbangkan opsi untuk penggunaan yang lebih nyaman di editor.  Kami perlu mendefinisikan kembali fungsi yang mengembalikan tautan ke dunia dan kemudian editor akan memahami bahwa dalam permainan itu sendiri ia dapat bekerja: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//  GetWorld()    . virtual UWorld* GetWorld() const override; //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs">UWorld* UMyObject::GetWorld() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       ,    . if (GIsEditor &amp;&amp; !GIsPlayInEditorWorld) return nullptr; else if (GetOuter()) return GetOuter()-&gt;GetWorld(); else return nullptr; }</span></span></code> </pre><br>  Sekarang didefinisikan dan editor akan mengerti bahwa secara umum objek dapat memperoleh pointer yang diinginkan (meskipun tidak valid) dan menggunakan fungsi global di BP. <br><br>  <i>Harap perhatikan bahwa pemilik (GetOuter ()) juga harus memiliki akses ke dunia.</i>  <i>Ini bisa berupa UObject lain dengan GetWorld (), komponen, atau objek Aktor tertentu di TKP.</i> <br><br><img src="https://habrastorage.org/webt/7x/wu/w3/7xwuw3u7qkekz9m6-bnhdfd0o10.png"><br><br>  Ada cara lain.  Cukup menambahkan label ke makro UCLASS () ketika mendeklarasikan kelas bahwa parameter WorldContextObject akan ditambahkan ke fungsi statis di BP, di mana objek apa pun yang berfungsi sebagai konduktor ke "dunia" dan fungsi global engine diumpankan.  Opsi ini cocok untuk mereka yang dalam proyek dapat memiliki beberapa dunia pada saat yang sama (misalnya, dunia game dan dunia untuk penonton): <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   WorldContext      UCLASS(Blueprintable, meta=(ShowWorldContextPin)) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() //   }</span></span></code> </pre><br>  Jika Anda memasukkan GetGamemode ke dalam pencarian di BP, itu akan muncul dalam daftar, seperti fungsi serupa lainnya, dan parameternya adalah WorldContextObject, di mana Anda harus meneruskan tautan ke Aktor. <br><br><img src="https://habrastorage.org/webt/nn/uo/xg/nnuoxgsfj912bnoa5fheedsz3yk.png"><br><br>  Ngomong-ngomong, Anda bisa mengajukan pemilik properti kami di sana.  Saya merekomendasikan membuat fungsi pada Aktor, itu akan selalu berguna untuk objek: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable, meta=(ShowWorldContextPin)) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      ,     . public: UFUNCTION(BlueprintPure) AActor* GetOwner() const {return Cast&lt;AActor&gt;(GetOuter());}; //   }</span></span></code> </pre><br>  Sekarang Anda cukup menggunakan fungsi global dalam kombinasi dengan fungsi Murni kami untuk mendapatkan pemiliknya. <br><br><img src="https://habrastorage.org/webt/ux/22/7w/ux227wpx_b6yp8l8vnlutwxywu8.png"><br><br>  Jika Anda juga mendeklarasikan GetWorld () dalam varian kedua seperti pada varian pertama, Anda dapat mengirimkan referensi kepada diri sendiri (Cukup atau Ini) dalam parameter WorldContextObject. <br><br><p><img src="https://habrastorage.org/webt/op/jh/mb/opjhmbcmm5jsktm_gtxk-jkgzyy.png"></p><br><br><h2>  Acara BeginPlay dan Centang </h2><br>  Masalah lain yang mungkin dihadapi pengembang Blueprint adalah tidak ada acara BeginPlay dan Centang di kelas Object.  Tentu saja, Anda dapat membuatnya sendiri dan menelepon dari kelas lain.  Tetapi Anda harus mengakui bahwa itu jauh lebih nyaman ketika semuanya bekerja di luar kotak. <br><br>  Mari kita mulai dengan memahami cara membuat Begin Play.  Kami dapat membuat fungsi yang tersedia untuk menulis ulang di BP dan menyebutnya di konstruktor kelas, tetapi ada sejumlah masalah, karena pada saat konstruktor objek Anda belum sepenuhnya diinisialisasi. <br><br>  Di semua kelas, ada fungsi PostInitProperties (), yang dipanggil setelah menginisialisasi sebagian besar parameter dan mendaftarkan objek di berbagai sistem internal, misalnya, untuk pengumpul sampah.  Di dalamnya, Anda bisa menghubungi acara kami, yang akan digunakan dalam Cetak Biru: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      . virtual void PostInitProperties() override; // ,      . UFUNCTION(BlueprintImplementableEvent) void BeginPlay(); //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::PostInitProperties() { Super::PostInitProperties(); <span class="hljs-comment"><span class="hljs-comment">//   ,   .   BeginPlay    if(GetOuter() &amp;&amp; GetOuter()-&gt;GetWorld()) BeginPlay(); }</span></span></code> </pre><br>  <i>Alih-alih if (GetOuter () &amp;&amp; GetOuter () -&gt; GetWorld ()) Anda dapat dengan mudah meletakkan if (GetWorld ()) jika Anda telah mendefinisikannya kembali.</i> <i><br><br></i>  <i>Berhati-hatilah!</i>  <i>Secara default, PostInitProperties () juga dipanggil di editor.</i> <i><br></i> <br>  Sekarang kita bisa masuk ke objek BP kita dan memanggil acara BeginPlay.  Ini akan dipanggil saat objek dibuat. <br><br>  Mari kita beralih ke Event Tick.  Tidak ada fungsi sederhana untuk kami.  Centang objek di engine memanggil manajer khusus, yang Anda perlukan untuk mengambilnya.  Namun, ada trik yang sangat nyaman di sini - pewarisan tambahan dari FTickableGameObject.  Ini akan memungkinkan Anda untuk secara otomatis melakukan semua yang Anda butuhkan, dan itu sudah cukup hanya untuk mengambil fungsi yang diperlukan: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Tickable.h" //   c FTickableGameObject UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject, public FTickableGameObject { GENERATED_BODY() public: //   virtual void Tick(float DeltaTime) override; virtual bool IsTickable() const override; virtual TStatId GetStatId() const override; protected: //     UFUNCTION(BlueprintImplementableEvent) void EventTick(float DeltaTime); //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::Tick(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime) { <span class="hljs-comment"><span class="hljs-comment">//       . EventTick(DeltaTime); //     . } //     bool UMyObject::IsTickable() const { return true; } TStatId UMyObject::GetStatId() const { return TStatId(); }</span></span></code> </pre><br><p>  Jika Anda mewarisi dari objek Anda dan membuat kelas BP, acara EventTick akan tersedia, yang akan menyebabkan logika untuk setiap frame. </p><br><br><h2>  Menambahkan Komponen dari UObjects </h2><br>  Dalam Cetak Biru UObject, Anda tidak dapat menelurkan komponen untuk Aktor.  Masalah yang sama melekat pada Cetak Biru ActorComponent.  Logika Epic Games tidak terlalu jelas, karena di C ++ ini bisa dilakukan.  Selain itu, Anda dapat menambahkan komponen dari Aktor ke objek Aktor lain hanya dengan menentukan tautan.  Tetapi ini tidak bisa dilakukan. <br><br>  Sayangnya, saya tidak dapat menemukan item ini.  Jika ada yang punya petunjuk tentang cara melakukan ini, saya akan senang mempostingnya di sini. <br><br><p>  Satu-satunya pilihan yang dapat saya tawarkan saat ini adalah membuat pembungkus di kelas UObject, memberikan akses ke penambahan komponen yang sederhana.  Dengan demikian, dimungkinkan untuk menambahkan komponen ke Aktor, tetapi Anda tidak akan secara dinamis membuat parameter input dari spawn.  Seringkali, ini dapat diabaikan. </p><br><br><h2>  Menyiapkan instance melalui editor </h2><br>  Di UE4, ada "fitur" lain yang nyaman untuk bekerja dengan objek - ini adalah kemampuan untuk membuat instance selama inisialisasi dan mengubah parameternya melalui editor, dengan demikian mengatur propertinya, tanpa membuat kelas anak hanya untuk kepentingan pengaturan.  Sangat berguna untuk desainer game. <br><br>  Misalkan Anda memiliki manajer pengubah untuk karakter dan pengubah sendiri diwakili oleh kelas yang menggambarkan efek yang ditumpangkan.  Perancang permainan menciptakan sepasang pengubah dan menunjukkan pada manajer yang mana yang digunakan. <br><br>  Dalam situasi normal, akan terlihat seperti ini: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere) TSubclassOf&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObjectClass</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br><img src="https://habrastorage.org/webt/hd/rx/zc/hdrxzc1qsu2d9htiydsmgfy1t-0.png"><br><br>  Namun, ada masalah karena itu tidak dapat mengkonfigurasi pengubah dan Anda harus membuat kelas tambahan untuk nilai-nilai lain.  Setuju, tidak mudah untuk memiliki puluhan kelas di Browser Konten yang hanya berbeda dalam nilainya.  Memperbaiki ini mudah.  Anda dapat menambahkan beberapa bidang di dalam USTRUCT (), dan juga menunjukkan dalam objek kontainer bahwa objek kita akan menjadi instance, dan bukan hanya referensi ke objek atau kelas yang tidak ada: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable, DefaultToInstanced, EditInlineNew) <span class="hljs-comment"><span class="hljs-comment">//  -        class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() UPROPERTY(EditAnywhere) //       uint8 MyValue; // ,    //   }</span></span></code> </pre><br>  Ini saja tidak cukup, sekarang perlu untuk menunjukkan bahwa variabel yang sama dengan kelas akan menjadi instance.  Ini sudah dilakukan ketika Anda menyimpan objek, misalnya, di manajer pengubah karakter: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere, Instanced) <span class="hljs-comment"><span class="hljs-comment">//   Instanced    class UMyObject* MyObject; //    }</span></span></code> </pre><br>  Harap dicatat bahwa kami menggunakan referensi ke objek, dan bukan ke kelas, karena instance akan dibuat segera setelah inisialisasi.  Sekarang kita bisa masuk ke jendela editor untuk memilih kelas dan menyesuaikan nilai di dalam instance.  Itu jauh lebih nyaman dan lebih fleksibel. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ee4/1cd/e76/ee41cde76aed943c03f0a15ff2e903f6.png" alt="gambar"></p><br><br><h2>  Info </h2><br>  Ada kelas lain yang menarik di Unreal Engine.  Ini adalah AInfo.  Kelas yang diwarisi dari AActor yang tidak memiliki representasi visual di dunia.  Info menggunakan kelas-kelas seperti: mode permainan, GameState, PlayerState, dan lainnya.  Yaitu, kelas yang mendukung chip yang berbeda dari AActor, misalnya, replikasi, tetapi tidak ditempatkan di tempat kejadian. <br><br>  Jika Anda perlu membuat manajer global tambahan yang harus mendukung jaringan dan semua kelas Aktor yang dihasilkan, maka Anda dapat menggunakannya.  Anda tidak perlu memanipulasi kelas UObject seperti yang dijelaskan di atas untuk memaksanya, misalnya, untuk mereplikasi data. <br><br><p>  Namun, perlu diingat bahwa meskipun objek tidak memiliki koordinat, tidak ada komponen visual, dan tidak ditampilkan di layar, objek tersebut masih merupakan turunan dari kelas Aktor, yang berarti ia seberat induknya.  Cukup digunakan dalam jumlah kecil dan untuk kenyamanan. </p><br><br><h2>  Kesimpulan </h2><br>  UObject sangat dibutuhkan, dan saya menyarankan Anda untuk menggunakannya kapan pun Aktor tidak benar-benar diperlukan.  Sangat disayangkan bahwa itu sedikit terbatas, tetapi juga merupakan nilai tambah.  Terkadang Anda harus mengotak-atik saat Anda perlu menggunakan templat khusus, tetapi yang paling penting, semua batasan utama dapat dihapus. <br><br>  Jika Anda sering bekerja dengan objek dari Cetak Biru, tetapi tidak ingin terus-menerus membuat kelas dan menambahkan fitur ini ke mereka, Anda cukup membuat satu kelas UObject, dengan dukungan untuk semua yang mungkin Anda butuhkan dalam proyek, dan kemudian membuat cetakan anak dari itu dan bekerja  . <br><br> ,    ,      Unreal Engine 4.   -   ,          .    ,  -    ,   UObject. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475622/">https://habr.com/ru/post/id475622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475600/index.html">Bagaimana kami menghubungkan Prometheus</a></li>
<li><a href="../id475604/index.html">Mengkonfigurasi templat PostgreSQL resmi di Zabbix 4.4</a></li>
<li><a href="../id475608/index.html">Google Pengelola Tag: Pengaturan Pemicu yang Tidak Jelas dan Berguna</a></li>
<li><a href="../id475612/index.html">Diberikan, kapan, pernyataan dan keyakinan dalam implementasi</a></li>
<li><a href="../id475618/index.html">Cara menulis kontrak Python yang cerdas di jaringan Ontology. Bagian 2: API Penyimpanan</a></li>
<li><a href="../id475624/index.html">PHP-Watcher: alat yang menyederhanakan pengembangan aplikasi berumur panjang</a></li>
<li><a href="../id475626/index.html">Bisakah autotests menggantikan seseorang dalam mencari kerentanan: wawancara dengan Alexandra Svatikova</a></li>
<li><a href="../id475630/index.html">Knative - platform berbasis k8s sebagai layanan dengan dukungan serverless</a></li>
<li><a href="../id475636/index.html">Elemen Vektor Bertambah</a></li>
<li><a href="../id475640/index.html">Jika Anda membuat sesuatu, hindari jadwal manajer.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>