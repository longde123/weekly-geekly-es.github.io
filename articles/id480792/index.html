<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🔬 🌇 🚶🏼 Rekayasa Hadiah 🛑 🏀 🐱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di luar jendela sedang hujan, Desember ada di kalender. Waktu untuk liburan sudah dekat, dan oleh karena itu waktu untuk hadiah. Rekan Pavel mengingin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rekayasa Hadiah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/480792/"><img src="https://habrastorage.org/webt/md/lw/ph/mdlwpht7vhixr2jkxrftetb8hv4.jpeg"><br><br>  Di luar jendela sedang hujan, Desember ada di kalender.  Waktu untuk liburan sudah dekat, dan oleh karena itu waktu untuk hadiah.  Rekan Pavel menginginkan laptop baru untuk dirinya sendiri, dan pacar Masha menginginkan sebuah rumah di tepi laut.  Dan terlepas dari gaji yang layak dari profesi tyzhprogrammer, kami tidak hidup di dunia dengan kemungkinan tak terbatas, yang berarti saya tidak bisa memberi orang-orang ini persis apa yang paling mereka inginkan (meskipun Pasha mungkin adalah Pavel terbaik saya, yang Aku tahu, tapi Masha baik-baik saja). <br><br>  Di sinilah masalah "hadiah murah" muncul.  Tidak ada gunanya memberikan hadiah mahal kepada semua orang, tetapi saya tidak ingin memberikan sekotak coklat, lilin atau patung lain yang tidak jelas.  Jadi, Anda perlu menggabungkan bisnis dengan kesenangan - Saya suka melakukan sesuatu dengan tangan saya sendiri, dan hasilnya hebat sebagai hadiah.  Ini adalah kisah tentang bagaimana saya sekali lagi berpura-pura menjadi insinyur dan membuat beberapa hadiah. <br><a name="habracut"></a><br><h2>  Penyimpangan kecil dari topik utama </h2><br>  Saya tidak bisa langsung pergi ke topik utama, jadi saya akan mulai dari jauh.  Beberapa tahun yang lalu, game "The Witcher 3" dirilis.  Teman saya menyarankan saya untuk bermain, dan secara umum saya sangat mengagumi permainannya.  Lalu saya memutuskan apa yang harus dilakukan dan memberinya sesuatu yang terkait dengan permainan ... saya tidak akan terlalu jauh ke dalam deskripsi permainan (Google akan membantu semua orang) atau mengatakan bahwa tidak banyak hal muncul di pikiran saya untuk kata kunci "The Witcher, Engineer, Gift." <br><br>  Karakter utama dari permainan ini memiliki seekor kuda bernama "Roach" (dalam akting suara Rusia), pahlawan dari waktu ke waktu mendorongnya dengan ungkapan "Move, Roach".  Saya memutuskan untuk membuat mainan mekanis dengan tema "mengaduk kecoak". <br><br>  Tentu saja, hadiah itu dianggap sebagai hal yang sama sekali tidak berguna, bodoh, tetapi lucu, jadi rencananya adalah sebagai berikut: <br><br><ol><li>  Ada kotak yang menyembunyikan mekanisme itu sendiri. </li><li>  Mekanismenya adalah poros, berputar dimana kuda itu bergerak. </li><li>  "Kegigihan" maksimum dari gerakan kuda ini disambut baik.  Awalnya, ia bahkan berpikir bahwa kuda itu harus bergerak seperti ikan, dan tidak seperti kuda (setelah semua, kecoak), tetapi hasilnya adalah "sesuatu di antara". </li><li>  Semua ini akan dilakukan dari kayu lapis, yang menurut gambar dapat dipotong sesuai pesanan dengan laser. </li></ol><br>  Kerugian utama dari pemilihan material dan fakta bahwa pemotongan akan dilakukan sesuai pesanan adalah kenyataan bahwa saya kehilangan kesempatan untuk membuat prototipe, yang berarti bahwa semua masalah tangan yang bengkok dan ketidakpatuhan terhadap aturan "tujuh kali pengukuran" membuat diri mereka merasa cukup cepat: <br><br><img src="https://habrastorage.org/webt/bq/9h/e2/bq9he2doyiixrvhr47zha5frml0.jpeg"><br><br>  Meskipun pada akhirnya, fakta bahwa banyak detail dari mekanisme serangan balik karena celah terlalu besar membantu untuk mengimbangi fakta bahwa saya menghubungkan bagian-bagian dan poros cukup bengkok.  Di sini, seperti yang mereka katakan, "minus minus memberi plus" dan mekanisme secara keseluruhan bekerja, seperti yang dimaksudkan: <br><br><img src="https://habrastorage.org/webt/cn/x2/gf/cnx2gfjjm2rasl3jtcd3oah-ors.gif"><br><br>  Setelah hanya ada sedikit lukisan dan hasilnya adalah kotak seperti itu: <br><br><img src="https://habrastorage.org/webt/fe/x9/uf/fex9ufxoprduhzobingucsoinm4.jpeg"><br><br>  Kemudian seseorang akan mengatakan bahwa itu perlu untuk membuat kotak transparan sehingga memungkinkan untuk mengamati pekerjaan bagian dalam, tetapi pada kenyataannya saya awalnya menduga bahwa saya tidak dapat mengumpulkan seluruh mekanisme dan kotak begitu bersih dan rapi dari dalam sehingga tidak ada salahnya lihat melalui dinding transparan kotak.  Oleh karena itu, kotak buram adalah ukuran yang diperlukan. <br><br>  Yang tersisa hanya mengemasnya, mengikat busur pada sebuah kotak dan hadiah sudah siap: <br><br><img src="https://habrastorage.org/webt/k9/47/k_/k947k_nkfln04gnb6adkqda9vs4.jpeg"><br><br>  Tetapi agar tidak mengecewakan anak batin, yang ingin merasa seperti seorang insinyur dalam situasi di mana sebenarnya saya menempelkan beberapa potong kayu lapis, saya memutuskan untuk membuat "gambar".  Maafkan saya semua yang mengerti sesuatu dalam gambar teknis, karena  Saya mengerti bahwa ini lebih merupakan parodi dari gambar daripada gambar yang nyata, tetapi menurut saya, dia menambahkan nilai pada mainan sederhana: <br><br><img src="https://habrastorage.org/webt/pk/t2/ms/pkt2msf9f2s496bchyrmdi6fs0w.png"><br><br><h2>  Hari ini aku ... </h2><br>  Terkadang nasib bermain dengan kita dan entah bagaimana mengisyaratkan bahwa sesuatu akan segera terjadi.  Kisah salah satu perangkat saya dimulai persis sama.  Saya memesan beberapa barang elektronik kecil bernilai sekitar $ 5, yang, seperti biasa, menghabiskan waktu satu bulan di jalan, setelah itu saya menerima SMS bahwa paket itu menunggu saya di kantor pos setempat.  Kotak itu ternyata jauh lebih besar dari yang saya harapkan dan segera menimbulkan keraguan tentang isinya.  Keraguan dikonfirmasi - di dalam, selain hal-hal kecil yang saya pesan, ada juga layar e-ink tiga warna dengan diagonal 4,2 inci.  Saya menghubungi penjual, dia mengkonfirmasi bahwa dia telah mengacaukan sesuatu ketika berkemas, tetapi mengatakan bahwa saya dapat menganggap ini hadiah dan menggunakannya sesuai keinginan saya. <br><br>  Fate mengisyaratkan kepada saya bahwa saatnya telah tiba untuk memulai proyek baru dan proyek ini akan menjadi sesuatu dengan tampilan e-ink.  Setelah secara singkat membiasakan diri dengan spesifikasi perangkat dan menghubungkan layar ke controller, saya memastikan bahwa spesifikasi tidak berbohong kepada saya tentang waktu pembaruan.  Layar telah diperbarui selama lebih dari 10 detik, berkedip dan mencoba membuat saya kejang epilepsi: <br><br><img src="https://habrastorage.org/webt/ni/w1/h5/niw1h5wpnfczyud_2593yvxq-mg.gif"><br>  (Saya tidak punya foto awal untuk menghubungkan layar, jadi di sini perangkat sudah memiliki tampilan yang lebih bermakna) <br><br>  Menjadi jelas bahwa Anda memerlukan perangkat sederhana yang tidak memerlukan animasi yang rumit (dan animasi pada umumnya).  Dan kemudian saya menemukan kalender suasana hati: <br><img src="https://habrastorage.org/webt/zm/a0/dg/zma0dglgpkea9lkxbnqlndawc-o.jpeg"><br><br>  Kalender mood adalah serangkaian gambar sederhana dan tanda tangan ironis bagi mereka.  Saya memutuskan bahwa saya akan membuat kalender (yang sebenarnya bukan kalender sama sekali) dengan nama "Hari ini saya" ... Ini akan menjadi perangkat sederhana yang setiap hari menampilkan beberapa gambar yang mencirikan "keadaan pikiran" hari ini dan deskripsi tentangnya.  Selain itu, kalender bisa memiliki beberapa fungsi lain juga, tetapi kalender utama akan tepatnya "kalender" - gambar sendiri untuk setiap hari. <br><br>  Modul kertas elektronik memungkinkan untuk menampilkan tiga warna (hitam, merah dan putih), yang harus dikirim ke modul, seperti dua gambar - hitam dan putih dan merah dan putih.  Bahkan, akan lebih tepat untuk mengatakan bahwa layar hanya mengharapkan bitmap monokrom, di mana setiap bit menentukan warna satu piksel (saya tidak yakin bahwa istilah ini berlaku untuk kertas elektronik, tapi saya harap idenya jelas).  Bitmap terpisah dapat diatur untuk saluran hitam atau merah.  Dengan demikian, ada satu set byte di mana setiap bit yang diatur ke 1 akan sesuai dengan piksel warna, dan semua bit yang tetap 0 akan menjadi piksel putih pada layar.  Resolusi layar adalah 400 x 300 piksel, mis.  untuk gambar hitam putih, diperlukan 15.000 byte (8 piksel dikodekan dalam satu byte).  Untuk tiga warna, ini akan membutuhkan 30.000 byte, jika Anda tidak mencoba mengemas gambar dengan lebih kompak.  Dari sudut pandang implementasi, pencipta layar dapat dengan mudah memilih dua bit per piksel dan menyimpan keadaan sebenarnya (di mana merah, di mana hitam, dan di mana putih), tetapi ini akan membutuhkan 30.000 byte yang sama, tetapi bahkan untuk gambar monokrom akan membutuhkan transfer 30.000 byte. <br><br>  Seperti dalam "kerajinan" saya yang lain, saya mulai menciptakan tugas untuk diri saya sendiri sehingga semuanya tidak akan berubah menjadi "pasang kabel dan unduh perpustakaan".  Bahkan jika kita mempertimbangkan kemampuan untuk menerapkan semacam algoritma kompresi gambar pada sisi pengontrol, menjadi jelas bahwa tanpa penyimpanan eksternal untuk file gambar, pengontrol akan sangat tertekan.  Diputuskan untuk mengambil kartu SD dan menulis pembungkus kode sederhana untuk bekerja dengan FAT32.  Tentu saja, akan mungkin dilakukan tanpa sistem file dan menulis data ke kartu memori secara langsung, tetapi bagi saya tampaknya kurang nyaman untuk menambahkan file baru, dan menarik bagi saya untuk mengimplementasikan operasi dasar untuk bekerja dengan FAT32 dengan tangan saya sendiri. <br><br>  Penting untuk mengklarifikasi bahwa saya memiliki kebiasaan menulis sendiri (Anda tidak harus memberi tahu saya bahwa ada lautan perpustakaan, saya tahu tentang hal itu dan dengan Google) ketika saya melakukan hal-hal seperti itu, tetapi karena  Sebelumnya saya tidak merasa senang bekerja dengan FAT32 di level rendah, itu adalah proses yang agak menghibur. <br><br>  Saya tidak akan membahas detail bekerja dengan FAT32 dan kartu SD secara keseluruhan, seperti  Internet penuh dengan artikel tentang topik ini (dan saya tidak ingin mengubah cerita saya menjadi menceritakan kembali spesifikasi), tetapi saya akan berbicara tentang beberapa hal yang perlu diterapkan.  Penting untuk mengimplementasikan tidak hanya fungsi membaca dari file dan menulis ke file (saya memutuskan untuk menyimpan beberapa pengaturan dan menyatakan pada kartu SD yang sama, dan tidak di EEPROM), tetapi juga fungsi mencari file dalam sistem file jika Anda perlu bekerja dengan dengan cara yang biasa. <br><br>  Semua data pada kartu memori dibagi menjadi cluster (unit utama yang dapat dialamatkan dalam sistem file FAT32), dan cluster sudah dibagi menjadi beberapa sektor.  Untuk membaca file “habr.txt” dari kartu SD di FAT32, Anda perlu: <br><br><ol><li>  Inisialisasi kartu memori. </li><li>  Baca sektor di alamat nol dan periksa apakah sistem file FAT32 memiliki header tertentu (Anda dapat melewati langkah ini jika kami percaya pada keberuntungan). </li><li>  Baca sektor ini di alamat nol dan dapatkan “Logical Block Addressing” (LBA). </li><li>  Baca sektor di alamat yang diterima (LBA) dan dapatkan data yang diperlukan dari itu (cluster mana yang merupakan root - direktori root, berapa banyak sektor dalam cluster, dll.). </li><li>  Baca "Root Directory" cluster (pada kenyataannya, membaca dilakukan oleh sektor, Anda hanya perlu membaca sektor sebanyak ada sektor dalam cluster) dengan nomornya.  Ini memiliki formula sendiri untuk mengubah nomor seri cluster menjadi alamat fisik.  Informasi file disimpan di sini, jadi kami membaca data untuk mencari file yang diinginkan.  Ada satu hal lagi tentang nama file: nama bisa pendek atau panjang, tergantung pada ini, data disimpan di satu tempat (dalam struktur yang sama) atau dalam catatan tambahan, yang juga harus dibaca secara terpisah.  Ketika file dengan nama yang diinginkan ditemukan, kami mendapatkan cluster di mana awalnya terletak (atau mungkin seluruh file jika cocok dengan ukuran cluster), serta ukuran file.  Jika file tidak ditemukan di cluster ini, maka kami mencari cluster berikutnya dan ulangi proses pencarian file. </li><li>  Baca cluster di alamat yang ditemukan.  Dan terus membaca cluster lebih lanjut dan mencari cluster berikutnya sampai semua data telah dibaca. </li></ol><br>  Tampak bagi saya bahwa lebih mudah untuk memberi tahu prinsip sistem file kepada mereka yang telah menerapkan daftar tertaut setidaknya sekali, karena  sebenarnya, sistem file FAT32 adalah seperangkat blok data dan sejenis tabel yang mengatakan di mana harus mencari blok data berikutnya.  Membaca data apa pun dari FAT32 adalah proses di mana kami membaca data, mencari alamat blok berikutnya, membaca data, mencari alamat blok berikutnya, dll. <br><br>  Saya tidak menerapkan semua skenario yang mungkin dan menyederhanakan beberapa hal: <br><br><ul><li>  Semua file pada akar kartu memori dan penelusuran direktori tidak digunakan. </li><li>  Semua file memiliki nama pendek. </li><li>  Pengontrol saat startup membaca daftar file dan menyimpannya dalam memori agar tidak mencari setiap file lagi. </li><li>  Jumlah maksimum file dibatasi oleh konstanta (dan sebenarnya saya hanya menggambar beberapa lusin gambar). </li></ul><br>  Singkatnya, semua hal di atas adalah alasan yang meyakinkan untuk mengambil perpustakaan yang sudah jadi dan tidak menghabiskan banyak waktu membaca dokumentasi, pengembangan dan debugging.  Saya akan menyarankan diri saya untuk menerapkan hal-hal seperti itu hanya untuk tujuan pendidikan atau "untuk bersenang-senang". <br><br>  Layar juga memberlakukan beberapa batasan, seperti  gambar apa pun yang ditampilkan dengan cara ini: <br><br><ol><li>  Kami bangun dan menginisialisasi layar (untuk memperpanjang umurnya dan menghemat energi, tampilan pada dasarnya tidur). </li><li>  Kami membuka saluran yang diperlukan (misalnya, hitam). </li><li>  Kami meneruskan 15000 byte gambar. </li><li>  Kami membuka saluran yang diperlukan (misalnya, merah). </li><li>  Kami meneruskan 15000 byte gambar. </li><li>  Kami memberi tahu tampilan untuk mengambil data dari buffer. </li><li>  Kami menunggu sampai layar selesai menggambar. </li><li>  Kami memberitahu layar untuk tidur. </li></ol><br>  Untuk gambar monokrom, Anda dapat melewati langkah 4 dan 5. Untuk gambar tiga warna, urutan transmisi gambar hitam putih dan merah putih tidak penting, karena  merah selalu dicat hitam, hitam hanya di atas putih, dan hanya piksel tetap putih, yang putih dan hitam dan putih dan merah dan putih. <br><br>  Untuk kesederhanaan (agar tidak menambah jumlah total file), saya memutuskan untuk menyimpan gambar hitam putih dan merah putih sebagai satu file, di mana gambar hitam putih segera diikuti oleh merah putih: <br><br><img src="https://habrastorage.org/webt/qo/p-/4j/qop-4jlidhtf82tthoxxspebl2o.png"><br><br>  Hasil membandingkan gambar-gambar ini adalah sesuatu seperti ini (menurut saya masing-masing dari kita setidaknya sekali dalam hidup kita merasa seperti rusa dengan tanduk - kaki): <br><br><img src="https://habrastorage.org/webt/7o/tb/cs/7otbcsv6yqjrqivfjutep87b1am.png"><br><br>  Bahkan, kedua gambar itu diikuti oleh gambar lain yang berisi deskripsi keadaan (dengan mengklik tombol, Anda bisa mendapatkan deskripsi yang cocok dengan gambar yang ditampilkan hari ini). <br><br>  Karena keterbatasan memori pengontrol, data dari kartu memori tidak pernah sepenuhnya dibaca ke dalam memori pengontrol.  Gambar dari kartu memori dibaca dalam fragmen yang ditentukan oleh ukuran sektor (untuk kesederhanaan, kami menganggap bahwa ukuran ini selalu statis dan tidak dapat berubah dari kartu ke kartu) dan jatuh ke dalam proses pemrosesan data dari kartu.  Dalam implementasi saya, fungsi membaca file sebagai input nomor cluster, ukuran file, dan panggilan balik untuk "ditarik" untuk setiap sektor membaca.  Pendekatan ini memungkinkan kami untuk menggunakan beberapa fungsi pemrosesan file yang berbeda untuk membaca dan menampilkan gambar itu sendiri atau deskripsinya. <br><br>  Jadi, logika berikut jatuh pada fungsi panggilan balik untuk membaca gambar dari kartu memori: <br><br><ol><li>  Atur saluran yang diperlukan (saluran ditentukan secara acak) sebelum mengirim data ke tampilan. </li><li>  Melacak data yang dikirimkan untuk beralih saluran ketika pengiriman data untuk saluran sebelumnya selesai. </li><li>  Kirim data yang diterima dari kartu. </li><li>  Tentukan bahwa data yang diperlukan telah dikirim dan sisa data (gambar dengan deskripsi) dapat diabaikan. </li></ol><br>  Itu rumit oleh kenyataan bahwa saya memutuskan untuk memasukkan gambar yang berisi lebih banyak data daripada yang seharusnya ditampilkan di layar.  Yaitu  ada beberapa gambar, yang merupakan latar belakang dan selalu statis dan sesuai dengan ukuran layar, dan ada gambar yang jauh lebih besar dari mana Anda perlu mengambil area acak (ukuran layar) dan tampilan. <br><br>  Gambar seperti itu memberlakukan persyaratan tambahan pada pawang - perlu untuk menghitung berapa byte dari garis layar saat ini ditransfer, berapa banyak lagi yang perlu ditambahkan pada panggilan berikutnya (jika garis jatuh di perbatasan ukuran sektor) dan berapa banyak yang harus dilewati. <br><br>  Secara visual, situasi ini dapat ditampilkan seperti ini: <br><br><img src="https://habrastorage.org/webt/22/iy/sr/22iysrbf7x-8n4ptpq4mtbq6kjc.png"><br><br>  Ada buffer tertentu di mana ada "jendela" dari ukuran yang diperlukan (bagian hijau) dan Anda hanya perlu membaca data dari jendela ini, membaca data dari buffer dalam fragmen N byte.  Dimungkinkan untuk memvisualisasikan proses membaca seperti ini: <br><br><img src="https://habrastorage.org/webt/cp/me/qo/cpmeqoznzfnhkflphfxdhscxhq0.gif"><br><br>  Secara umum, untuk menambahkan logika bekerja dengan layar ke dalam fungsi yang selalu menerima buffer 512-byte dan yang harus menentukan mana dari 512 byte ini yang diperlukan (jika ada sesuatu yang diperlukan sama sekali) ternyata bukan tugas yang mudah untuk diselesaikan "Di dahi".  Lebih tepatnya, tugas itu tidak begitu rumit sebagai non-standar dibandingkan dengan solusi sehari-hari, oleh karena itu, sangat mengejutkan, itu sangat menarik untuk menyelesaikannya.  Bagi saya itu seperti "tugas olimpiade", di mana perlu untuk menghitung jumlah listrik yang diperlukan untuk berkontraksi otot untuk mentransfer air dari satu ember ke ember lain dengan dua sendok (satu sendok di masing-masing tangan). <br><br>  Untuk lebih memahami apa kesulitannya di sini, saya akan menambahkan animasi lain di sini, hanya "dalam hal" isi cluster, dan bukan seluruh file (semua informasi lain perlu disimpan secara terpisah): <br><br><img src="https://habrastorage.org/webt/ba/vk/zg/bavkzgmfovjycovxj1uasy7kwae.gif"><br><br>  Seperti yang direncanakan, kalender harus menampilkan gambar baru setiap hari, mis.  itu harus dapat memonitor waktu (bahkan ketika dimatikan), yang berarti bahwa modul jam waktu nyata (RTC) juga diperlukan.  Dan terlepas dari kenyataan bahwa controller saya memiliki jam real-time built-in, hampir tidak mungkin untuk mengambil baterai untuk itu, karena  kontak tidak terhubung ke papan.  Saya memutuskan untuk tidak memperkosa kaki pengontrol dalam upaya menyoldernya dan mengambil RTC Cina eksternal.  Bekerja dengan RTC seharusnya sangat sederhana: <br><br><ul><li>  Ketika dihidupkan, dapatkan waktu dari RTC Cina. </li><li>  Atur waktu dalam RTC internal. </li><li>  Gunakan RTC internal untuk menghitung waktu dan lupakan orang Cina sampai penutupan berikutnya. </li></ul><br>  Tapi di sini, semuanya ternyata tidak begitu sederhana, karena RTC internal dari pengontrol bekerja dengan waktu dalam format yang biasa (timestamp UNIX), dan teman Cina-nya menggunakan Binary Coded Decimal (BCD).  Sebelum ini, saya tidak menemukan format ini dan sangat terkejut bahwa bahkan modul modern untuk Arduino menggunakannya.  Inti dari format ini cukup sederhana - ada satu byte, yang, misalnya, menyimpan jumlah detik.  Empat bit orde tinggi menyimpan puluhan, dan empat unit orde rendah menyimpan unit.  Ternyata representasi heksadesimal dari byte ini sendiri berisi waktu yang dapat dibaca manusia - byte 0x49 sesuai dengan 49 detik (walaupun dalam sistem desimal nilai ini sesuai dengan 72). <br><br>  Seperti yang saya pahami, itu hanya terjadi secara historis sehingga lebih mudah untuk menggunakan RTC secara langsung dengan pembuat enkode layar untuk membuat jam, tetapi saya harus mengubah stempel waktu BDC ke UNIX dengan pena. <br><br>  Selain tampilan, modul jam waktu nyata, kartu memori, dan sistem file untuk itu, perlu untuk membungkus semua kelenjar ini ke dalam case, yang juga harus diproduksi, mis.  "Gambar".  Anda dapat membaca lebih detail tentang semua rasa sakit yang saya temui dalam publikasi terakhir saya, semuanya persis sama di sini: <br><br><img src="https://habrastorage.org/webt/f_/6i/jh/f_6ijh7_nag2fpzyjwzkdkapips.jpeg"><br>  (Saya tidak merencanakan produksi massal, semua detail di sekitar adalah hasil pengukuran yang salah atau solusi yang dipikirkan dengan buruk) <br><br>  Akibatnya, kasing dan detail yang diperlukan ditarik (tidak ada sampul depan pada gambar): <br><br><img src="https://habrastorage.org/webt/pg/k9/w-/pgk9w-ajyangtju3ianmi1dm9jo.jpeg"><br><br>          (,   - -     ): <br><br><img src="https://habrastorage.org/webt/lp/c_/i8/lpc_i8kkwazohmmz2ujiynl2lea.jpeg"><br><br>   (     )    : <br><br><img src="https://habrastorage.org/webt/ah/yq/un/ahyqun2x2cwbvpn2hk5o59dupbw.jpeg"><br><br>     .      ,    . <br><br>       (    ): <br><br><img src="https://habrastorage.org/webt/tv/kh/pz/tvkhpznwutzclmhqaf_0q1abk_a.jpeg"><br><br>      ,       — : <br><br><img src="https://habrastorage.org/webt/cw/s0/y9/cws0y9bk4nre9kwyjwjar2cvsui.jpeg"><br><br>    ,    ,       : <br><br><img src="https://habrastorage.org/webt/ec/dj/d6/ecdjd6m9-d85udrkqee-vphi1qe.jpeg"><br><br><h2>       ! </h2><br>   -,      : “    ?!      100500   ,    !”.       ,  ,              —              (        - ),     ,       ,        ,   . <br><br> ,      ,     ,      . <br><br>         3 .       ,        ,       . <br><br><h2>    </h2><br>        ,    ,      -   .   ,    ,         ,         , ,  -  . <br><br> ,   ,                    .      “--”,     “MP3 Music Player Module for Arduino”,   Arduino Nano,  ,   mp3    . <br><br> ,   ,         , ,   ,   ,         / ,      .   “”  ,      . <br><br>      3 ,               .      : <br><br><ol><li>    ,     . </li><li>  “”      (, , ,  ). </li></ol><br>     (        ): <br><br><img src="https://habrastorage.org/webt/r7/nz/9_/r7nz9_z7qibv9mqtowdvp038dki.jpeg"><br><br>   ,      , ..   ,               ( : playSound(rand() &amp; 3);). <br><br>          .     “” (   ,    ),    USB        ,  “  ”: <br><br><img src="https://habrastorage.org/webt/ec/xg/ts/ecxgtsytg7czrd89196s2bwm8de.jpeg"><br><br><h2>  ? </h2><br>    ,    ,    .    3      : <br><br><img src="https://habrastorage.org/webt/kg/zz/jv/kgzzjvkhncuwiektwjpkjqciv54.jpeg"><br><br>     — .      ,     : <br><br><img src="https://habrastorage.org/webt/ce/vm/k5/cevmk5j74alm2qbuzodzsk5uplc.jpeg"><br><br><h2>  ! </h2><br> ,   : <br><br><ol><li>        . </li><li>    3  2 ,     ~0.4. </li><li>     — . </li><li> 3  (     ). </li><li>  . </li></ol><br>    …  : <br><br><img src="https://habrastorage.org/webt/l6/z_/uv/l6z_uvppvank9lg9tnt00clmeeq.png"><br><br>   : <br><br><img src="https://habrastorage.org/webt/aa/xi/yd/aaxiydolfoszxdnh8duxmhk3io0.jpeg"><br><br>            “”: <br><br><img src="https://habrastorage.org/webt/ux/up/w9/uxupw9tma7hqfuhatlg6n2loies.jpeg"><br><br><h2>     ? </h2><br> “      -   ,   -  .”        ,    ,   -.       “”,        ,  ,         FAT32,      BCD ,    RTC. <br><br> , -    (   )  : “ ,     ,     !”      - . <br><br>   ,   .   ,     .     ,     ,    __! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id480792/">https://habr.com/ru/post/id480792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id480780/index.html">Cara menyusun ilustrasi dari kubus dan piktogram</a></li>
<li><a href="../id480782/index.html">5 hal yang ingin saya ketahui ketika saya mulai menggunakan Angular</a></li>
<li><a href="../id480786/index.html">Kloning objek independen dalam JavaScript</a></li>
<li><a href="../id480788/index.html">Pohon Natal di baris perintah</a></li>
<li><a href="../id480790/index.html">"Efisiensi pabrik". Menemukan hambatan dan menerapkan sistem tarikan untuk meningkatkan produktivitas</a></li>
<li><a href="../id480794/index.html">Sedikit tentang kasus khusus implementasi algoritma pencarian pintu terbuka</a></li>
<li><a href="../id480796/index.html">Pemrogram Schrodinger, devops dan kucing</a></li>
<li><a href="../id480798/index.html">C ++ Russia Piter 2019 melaporkan ulasan</a></li>
<li><a href="../id480800/index.html">Mencari penguji pekerjaan? Bersiaplah untuk menunjukkan keterampilan pengembang</a></li>
<li><a href="../id480802/index.html">Rekayasa Kekacauan, Bagian 3: Metode dan Alat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>