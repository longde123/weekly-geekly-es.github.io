<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüé§ üëàüèΩ ü•™ Wie man nicht in Java wegwirft üë©üèø‚Äçüöí ü§úüèΩ ü§õüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt ein weit verbreitetes Missverst√§ndnis, dass Sie, wenn Ihnen die Garbage Collection nicht gef√§llt, nicht in Java, sondern in C / C ++ schreiben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man nicht in Java wegwirft</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436024/"><p> Es gibt ein weit verbreitetes Missverst√§ndnis, dass Sie, wenn Ihnen die Garbage Collection nicht gef√§llt, nicht in Java, sondern in C / C ++ schreiben m√ºssen.  In den letzten drei Jahren habe ich Java-Code mit geringer Latenz f√ºr den Devisenhandel geschrieben und musste vermeiden, unn√∂tige Objekte in jeder Hinsicht zu erstellen.  Als Ergebnis formulierte ich ein paar einfache Regeln f√ºr mich selbst, wie man Zuweisungen in Java, wenn nicht auf Null, dann auf ein vern√ºnftiges Minimum reduziert, ohne auf manuelle Speicherverwaltung zur√ºckzugreifen.  Vielleicht ist es auch f√ºr jemanden aus der Community n√ºtzlich. </p><a name="habracut"></a><br><h2>  Warum √ºberhaupt M√ºll vermeiden? </h2><br><p>  √úber das, was GC ist und wie man sie konfiguriert, wurde viel gesagt und geschrieben.  Aber letztendlich funktioniert der Code, egal wie Sie den GC einrichten, suboptimal.  Es gibt immer einen Kompromiss zwischen Durchsatz und Latenz.  Es wird unm√∂glich, eines zu verbessern, ohne das andere zu verschlechtern.  In der Regel wird der GC-Overhead durch Studieren der Protokolle gemessen. Sie k√∂nnen anhand dieser Protokolle nachvollziehen, zu welchen Zeitpunkten Pausen aufgetreten sind und wie viel Zeit sie in Anspruch genommen haben.  Die GC-Protokolle enthalten jedoch nicht alle Informationen zu diesem Overhead.  Das vom Thread erstellte Objekt wird automatisch in den L1-Cache des Prozessorkerns gestellt, auf dem der Thread ausgef√ºhrt wird.  Dies f√ºhrt dazu, dass andere potenziell n√ºtzliche Daten verdr√§ngt werden.  Mit einer gro√üen Anzahl von Zuordnungen k√∂nnen n√ºtzliche Daten auch aus dem L3-Cache verschoben werden.  Wenn der Thread das n√§chste Mal auf diese Daten zugreift, tritt ein Fehlcache auf, der zu Verz√∂gerungen bei der Ausf√ºhrung des Programms f√ºhrt.  Da der L3-Cache f√ºr alle Kerne innerhalb desselben Prozessors gleich ist, werden durch einen Garbage Stream Daten und andere Threads / Anwendungen aus dem L3-Cache √ºbertragen, und es treten bereits besonders teure Cache-Fehler auf, selbst wenn sie in Bare C geschrieben sind und keinen M√ºll anlegen.  Keine Einstellungen, keine Garbage Collectors (weder C4 noch ZGC) helfen, dieses Problem zu l√∂sen.  Die einzige M√∂glichkeit, die Situation insgesamt zu verbessern, besteht darin, nicht unn√∂tig unn√∂tige Objekte zu erstellen.  Java verf√ºgt im Gegensatz zu C ++ nicht √ºber ein umfangreiches Arsenal an Mechanismen f√ºr die Arbeit mit Speicher, es gibt jedoch eine Reihe von M√∂glichkeiten, die Zuweisungen zu minimieren.  Sie werden diskutiert. </p><br><div class="spoiler">  <b class="spoiler_title">Lyrischer Exkurs</b> <div class="spoiler_text"><p>  Nat√ºrlich m√ºssen Sie nicht den gesamten m√ºllfreien Code schreiben.  Die Sache mit der Java-Sprache ist, dass Sie Ihr Leben erheblich vereinfachen k√∂nnen, indem Sie nur die Hauptm√ºllquellen entfernen.  Sie k√∂nnen sich auch nicht mit der sicheren Speicherwiederherstellung befassen, wenn Sie sperrfreie Algorithmen schreiben.  Wenn ein Code beim Start der Anwendung nur einmal ausgef√ºhrt wird, kann er so viel zuweisen, wie Sie m√∂chten, und das ist keine gro√üe Sache.  Das wichtigste Arbeitsinstrument, um √ºbersch√ºssigen M√ºll loszuwerden, ist nat√ºrlich der Zuordnungsprofiler. </p></div></div><br><h2>  Primitive Typen verwenden </h2><br><p> In vielen F√§llen ist es am einfachsten, primitive Typen anstelle von Objekttypen zu verwenden.  Die JVM verf√ºgt √ºber eine Reihe von Optimierungen, um den Overhead von Objekttypen zu minimieren, z. B. das Zwischenspeichern kleiner Werte von Ganzzahltypen und das Inlinen einfacher Klassen.  Es lohnt sich jedoch nicht immer, sich auf diese Optimierungen zu verlassen, da sie m√∂glicherweise nicht funktionieren: Der ganzzahlige Wert wird m√∂glicherweise nicht zwischengespeichert, und Inlining tritt m√∂glicherweise nicht auf.  Wenn wir mit einer bedingten Ganzzahl arbeiten, m√ºssen wir au√üerdem dem Link folgen, was m√∂glicherweise zu einem Cache-Fehler f√ºhrt.  Au√üerdem verf√ºgen alle Objekte √ºber Header, die zus√§tzlichen Speicherplatz im Cache beanspruchen und andere Daten von dort verdr√§ngen.  Nehmen wir an: Ein primitives int ben√∂tigt 4 Bytes.  Object <code>Integer</code> belegt 16 Bytes + Linkgr√∂√üe f√ºr dieses Minimum von 4 Bytes (im Fall von komprimierten Oops).  Insgesamt stellt sich heraus, dass <code>Integer</code> f√ºnf (!) Mal mehr Platz einnimmt als <code>int</code> .  Daher ist es besser, primitive Typen selbst zu verwenden.  Ich werde einige Beispiele geben. </p><br><h3>  Beispiel 1. Konventionelle Berechnungen </h3><br><p>  Nehmen wir an, wir haben eine regul√§re Funktion, die nur etwas z√§hlt. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer a, Integer b, Integer c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><p>  Ein solcher Code wird wahrscheinlich inline (sowohl die Methode als auch die Klassen) und f√ºhrt nicht zu unn√∂tigen Zuweisungen, aber Sie k√∂nnen sich dessen nicht sicher sein.  Selbst wenn dies passiert, gibt es ein Problem mit der Tatsache, dass eine <code>NullPointerException</code> hier <code>NullPointerException</code> k√∂nnte.  Auf die eine oder andere Weise muss die JVM entweder Nullpr√ºfungen unter die Haube einf√ºgen oder aus dem Kontext heraus verstehen, dass <code>null</code> kein Argument sein kann.  Auf jeden Fall ist es besser, nur den gleichen Code auf Grundelemente zu schreiben. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><h3>  Beispiel 2. Lambdas </h3><br><p>  Manchmal werden Objekte ohne unser Wissen erstellt.  Zum Beispiel, wenn wir primitive Typen an Orte √ºbergeben, an denen Objekttypen erwartet werden.  Dies passiert h√§ufig bei der Verwendung von Lambda-Ausdr√ºcken. <br>  Stellen Sie sich vor, wir haben diesen Code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;Integer&gt; calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p>  Trotz der Tatsache, dass die Variable x ein Grundelement ist, wird ein Objekt vom Typ Integer erstellt, das an den Taschenrechner √ºbergeben wird.  Um dies zu vermeiden, verwenden Sie <code>IntConsumer</code> anstelle von <code>Consumer&lt;Integer&gt;</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IntConsumer calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p>  Ein solcher Code f√ºhrt nicht mehr zur Erstellung eines zus√§tzlichen Objekts.  Java.util.function verf√ºgt √ºber eine ganze Reihe von Standardschnittstellen, die f√ºr die Verwendung primitiver Typen angepasst sind: <code>DoubleSupplier</code> , <code>LongFunction</code> usw.  Wenn etwas fehlt, k√∂nnen Sie jederzeit die gew√ºnschte Schnittstelle mit Grundelementen hinzuf√ºgen.  Beispielsweise k√∂nnen Sie anstelle von <code>BiConsumer&lt;Integer, Double&gt;</code> eine selbst erstellte Schnittstelle verwenden. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntDoubleConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>; }</code> </pre> <br><h3>  Beispiel 3. Sammlungen </h3><br><p>  Die Verwendung eines primitiven Typs kann schwierig sein, da sich eine Variable dieses Typs in einer Sammlung befindet.  Angenommen, wir haben eine <code>List&lt;Integer&gt;</code> und m√∂chten herausfinden, welche Zahlen darin enthalten sind, und berechnen, wie oft jede der Zahlen wiederholt wird.  Daf√ºr verwenden wir <code>HashMap&lt;Integer, Integer&gt;</code> .  Der Code sieht folgenderma√üen aus: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Map&lt;Integer, Integer&gt; counters = new HashMap&lt;&gt;(); for (Integer x : numbers) { counters.compute(x, (k, v) -&gt; v == null ? 1 : v + 1); }</span></span></code> </pre> <br><p>  Dieser Code ist in mehrfacher Hinsicht gleichzeitig schlecht.  Erstens wird eine Zwischendatenstruktur verwendet, auf die wahrscheinlich verzichtet werden k√∂nnte.  Okay, der Einfachheit halber nehmen wir an, dass diese Liste sp√§ter ben√∂tigt wird, d. H.  Sie k√∂nnen es nicht vollst√§ndig entfernen.  Zweitens wird das Objekt <code>Integer</code> an beiden Stellen anstelle des primitiven <code>int</code> .  Drittens gibt es viele Zuordnungen in der <code>compute</code> .  Viertens wird ein Iterator zugewiesen.  Diese Zuweisung wird wahrscheinlich inline, aber dennoch.  Wie verwandle ich diesen Code in m√ºllfreien Code?  Sie m√ºssen die Sammlung nur f√ºr die Grundelemente einer Bibliothek eines Drittanbieters verwenden.  Es gibt eine Reihe von Bibliotheken, die solche Sammlungen enthalten.  Der folgende Code verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Agrona-</a> Bibliothek. </p><br><pre> <code class="java hljs">IntArrayList numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntArrayList(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Int2IntCounterMap counters = new Int2IntCounterMap(0); for (int i = 0; i &lt; numbers.size(); i++) { counters.incrementAndGet(numbers.getInt(i)); }</span></span></code> </pre> <br><p>  Die hier erstellten Objekte sind zwei Sammlungen und zwei <code>int[]</code> , die sich in diesen Sammlungen befinden.  Beide Sammlungen k√∂nnen durch Aufrufen der <code>clear()</code> -Methode wiederverwendet werden.  Durch die Verwendung von Sammlungen f√ºr Grundelemente haben wir unseren Code nicht kompliziert (und sogar vereinfacht, indem wir die Berechnungsmethode mit einem komplexen Lambda darin entfernt haben) und im Vergleich zur Verwendung von Standardsammlungen die folgenden zus√§tzlichen Boni erhalten: </p><br><ol><li>  Fast v√∂lliges Fehlen von Zuweisungen.  Wenn die Sammlungen wiederverwendet werden, gibt es √ºberhaupt keine Zuordnungen. </li><li>  Erhebliche Speicherersparnis ( <code>IntArrayList</code> ben√∂tigt etwa f√ºnfmal weniger Speicherplatz als <code>ArrayList&lt;Integer&gt;</code> . Wie bereits erw√§hnt, <code>IntArrayList</code> wir <code>IntArrayList</code> die wirtschaftliche Verwendung von Prozessor-Caches und nicht von RAM. </li><li>  Serieller Zugriff auf den Speicher.  Es wurde viel dar√ºber geschrieben, warum dies wichtig ist, deshalb werde ich hier nicht aufh√∂ren.  Hier einige Artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Martin Thompson</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ulrich Drepper</a> . </li></ol><br><p>  Ein weiterer kleiner Kommentar zu Sammlungen.  Es kann sich herausstellen, dass die Sammlung Werte unterschiedlichen Typs enth√§lt und es daher nicht m√∂glich ist, sie durch eine Sammlung mit Grundelementen zu ersetzen.  Meiner Meinung nach ist dies ein Zeichen f√ºr ein schlechtes Design der Datenstruktur oder des Algorithmus als Ganzes.  In diesem Fall ist die Zuweisung zus√§tzlicher Objekte h√∂chstwahrscheinlich nicht das Hauptproblem. </p><br><h2>  Ver√§nderbare Objekte </h2><br><p>  Was aber, wenn auf Primitive nicht verzichtet werden kann?  Zum Beispiel f√ºr den Fall, dass die von uns ben√∂tigte Methode mehrere Werte zur√ºckgeben sollte.  Die Antwort ist einfach: Verwenden Sie ver√§nderbare Objekte. </p><br><div class="spoiler">  <b class="spoiler_title">Kleiner Exkurs</b> <div class="spoiler_text"><p>  Einige Sprachen betonen die Verwendung unver√§nderlicher Objekte, beispielsweise in Scala.  Das Hauptargument f√ºr sie ist, dass das Schreiben von Multithread-Code stark vereinfacht wird.  Es gibt jedoch auch Gemeinkosten, die mit einer √ºberm√§√üigen Zuweisung von M√ºll verbunden sind.  Wenn wir sie vermeiden wollen, sollten wir keine kurzlebigen unver√§nderlichen Objekte erstellen. </p></div></div><br><p>  Wie sieht es in der Praxis aus?  Angenommen, wir m√ºssen den Quotienten und den Rest der Division berechnen.  Und daf√ºr verwenden wir den folgenden Code. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } <span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Wie kann man in diesem Fall die Zuordnung loswerden?  <code>IntPair</code> , √ºbergeben Sie <code>IntPair</code> als Argument und schreiben Sie das Ergebnis dort.  In diesem Fall m√ºssen Sie ein detailliertes Javadoc schreiben und noch besser eine Konvention f√ºr Variablennamen verwenden, in die das Ergebnis geschrieben wird.  Sie k√∂nnen beispielsweise mit dem Pr√§fix out beginnen.  M√ºllfreier Code sieht in diesem Fall folgenderma√üen aus: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor, IntPair outResult)</span></span></span><span class="hljs-function"> </span></span>{ outResult.x = value / divisor; outResult.y = value % divisor; }</code> </pre> <br><p>  Ich m√∂chte darauf hinweisen, dass die <code>divide</code> Methode keinen Link speichern sollte, um ihn irgendwo zu koppeln, oder ihn an Methoden √ºbergeben sollte, die dies k√∂nnen, da wir sonst gro√üe Probleme haben k√∂nnten.  Wie wir sehen k√∂nnen, sind ver√§nderbare Objekte schwieriger zu verwenden als primitive Typen. Wenn Sie also primitive Objekte verwenden k√∂nnen, ist es besser, dies zu tun.  In unserem Beispiel haben wir das Problem der Zuordnung von innerhalb der Teilungsmethode nach au√üen √ºbertragen.  An allen Stellen, an denen wir diese Methode aufrufen, ben√∂tigen wir einen <code>IntPair</code> Dummy, den wir zum <code>divide</code> .  Oft genug, um diesen Dummy im <code>final</code> Feld des Objekts zu speichern, von wo aus wir die <code>divide</code> Methode aufrufen.  Lassen Sie mich ein weit hergeholtes Beispiel geben: Nehmen wir an, unser Programm behandelt nur den Empfang eines Zahlenstroms √ºber das Netzwerk, teilt diese auf und sendet das Ergebnis an denselben Socket. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SocketListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IntPair pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BufferedReader in; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PrintWriter out; SocketListener(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Socket socket) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> IOException { in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(socket.getInputStream())); out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(socket.getOutputStream(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); divide(value, divisor, pair); out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p>  Der K√ºrze halber habe ich keinen zus√§tzlichen Code f√ºr die Fehlerbehandlung, die korrekte Programmbeendigung usw. geschrieben.  Die Hauptidee dieses Codes ist, dass das <code>IntPair</code> uns <code>IntPair</code> Objekt einmal erstellt und im <code>final</code> Feld gespeichert wird. </p><br><h2>  Objektpools </h2><br><p>  Wenn wir ver√§nderbare Objekte verwenden, m√ºssen wir zuerst ein leeres Objekt von irgendwoher nehmen, dann die ben√∂tigten Daten in das Objekt schreiben, es irgendwo verwenden und dann das Objekt "an Ort und Stelle" zur√ºckgeben.  Im obigen Beispiel war das Objekt immer "an Ort und Stelle", d.h.  im <code>final</code> Feld.  Leider ist dies nicht immer auf einfache Weise m√∂glich.  Beispielsweise wissen wir m√∂glicherweise nicht im Voraus genau, wie viele Objekte wir ben√∂tigen.  In diesem Fall helfen uns Objektpools.  Wenn wir ein leeres Objekt ben√∂tigen, erhalten wir es aus dem Objektpool, und wenn es nicht mehr ben√∂tigt wird, geben wir es dorthin zur√ºck.  Befindet sich kein freies Objekt im Pool, erstellt der Pool ein neues Objekt.  Dies ist in der Tat eine manuelle Speicherverwaltung mit allen sich daraus ergebenden Konsequenzen.  Es ist ratsam, nicht auf diese Methode zur√ºckzugreifen, wenn die vorherigen Methoden verwendet werden k√∂nnen.  Was k√∂nnte schief gehen? </p><br><ul><li>  Wir k√∂nnen vergessen, das Objekt in den Pool zur√ºckzugeben, und dann wird M√ºll ("Speicherverlust") erzeugt.  Dies ist ein kleines Problem - die Leistung wird leicht abnehmen, aber der GC wird funktionieren und das Programm wird weiter funktionieren. </li><li>  Wir k√∂nnen das Objekt in den Pool zur√ºckgeben, aber den Link dazu irgendwo speichern.  Dann wird jemand anderes das Objekt aus dem Pool holen, und zu diesem Zeitpunkt in unserem Programm gibt es bereits zwei Links zu demselben Objekt.  Dies ist ein klassisches Problem nach dem Gebrauch.  Es ist schwer zu deb√ºtieren, weil  Im Gegensatz zu C ++ st√ºrzt das Programm nicht ab und funktioniert weiterhin <em>fehlerhaft</em> . </li></ul><br><p>  Um die Wahrscheinlichkeit zu verringern, dass die oben genannten Fehler auftreten, k√∂nnen Sie das Standardkonstrukt "Try-with-Resources" verwenden.  Es kann so aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T object)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STORAGE.get(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  Die Divide-Methode k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = IntPair.create(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Und die <code>listenSocket</code> Methode <code>listenSocket</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IntPair pair = divide(value, divisor)) { out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p>  In der IDE k√∂nnen Sie normalerweise die Hervorhebung aller F√§lle konfigurieren, in denen <code>AutoCloseable</code> Objekte au√üerhalb des Try-with-Resources-Blocks verwendet werden.  Dies ist jedoch keine absolute Option, da  Das Hervorheben in der IDE kann einfach deaktiviert werden.  Daher gibt es eine andere M√∂glichkeit, die R√ºckgabe des Objekts an die Pool-Control-Inversion zu gew√§hrleisten.  Ich werde ein Beispiel geben: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;IntPair&gt; consumer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>(IntPair pair = STORAGE.get()) { consumer.accept(pair); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  In diesem Fall k√∂nnen wir grunds√§tzlich nicht <code>IntPair</code> au√üen auf das Objekt der <code>IntPair</code> Klasse <code>IntPair</code> .  Leider funktioniert diese Methode auch nicht immer.  Beispielsweise funktioniert es nicht, wenn ein Thread Objekte aus dem Pool abruft und in eine Warteschlange stellt und ein anderer Thread sie aus der Warteschlange entfernt und in den Pool zur√ºckgibt. </p><br><p>  Wenn wir keine generischen Objekte im Pool speichern, sondern einige Bibliotheksobjekte, die <code>AutoCloseable</code> nicht implementieren, <code>AutoCloseable</code> die Option "Mit Ressourcen versuchen" <code>AutoCloseable</code> auch nicht. </p><br><p>  Ein weiteres Problem ist hier das Multithreading.  Die Implementierung des Objektpools muss sehr schnell erfolgen, was sehr schwer zu erreichen ist.  Ein langsamer Pool kann der Leistung mehr schaden als n√ºtzen.  Die Zuweisung neuer Objekte in TLAB ist wiederum sehr schnell, viel schneller als bei malloc in C. Das Schreiben eines schnellen Objektpools ist ein separates Thema, das ich jetzt nicht entwickeln m√∂chte.  Ich kann nur sagen, dass ich keine guten ‚Äûvorgefertigten‚Äú Implementierungen gesehen habe. </p><br><h2>  Anstelle einer Schlussfolgerung </h2><br><p>  Kurz gesagt, die Wiederverwendung von Objekten mit Objektpools ist eine schwerwiegende H√§morrhoiden.  Gl√ºcklicherweise kann man fast immer darauf verzichten.  Meine pers√∂nliche Erfahrung ist, dass eine √ºberm√§√üige Verwendung von Objektpools Probleme mit der Anwendungsarchitektur signalisiert.  In der Regel reicht uns eine Instanz des im <code>final</code> Feld zwischengespeicherten Objekts aus.  Aber auch das ist √ºbertrieben, wenn es m√∂glich ist, primitive Typen zu verwenden. </p><br><h2>  Update: </h2><br><p>  Ja, ich erinnerte mich an einen anderen Weg f√ºr diejenigen, die keine Angst vor bitweisen Verschiebungen haben: mehrere kleine primitive Typen in einen gro√üen zu packen.  Angenommen, wir m√ºssen zwei <code>int</code> .  In diesem speziellen Fall k√∂nnen Sie das <code>IntPair</code> Objekt nicht verwenden, sondern ein <code>long</code> Objekt zur√ºckgeben, wobei die ersten 4 Bytes dem ersten <code>int</code> 'y und die zweiten 4 Bytes dem zweiten entsprechen.  Der Code k√∂nnte folgenderma√üen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)left &lt;&lt; Integer.SIZE) | (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)right &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFFL</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLeft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(value &gt;&gt;&gt; Integer.SIZE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = value / divisor; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> combine(left, right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> xy = divide(value, divisor); out.print(getLeft(xy)); out.print(getRight(xy)); } }</code> </pre> <br><p>  Solche Methoden m√ºssen nat√ºrlich gr√ºndlich getestet werden, da es ziemlich einfach ist, sie aufzuschreiben.  Aber dann benutze es einfach. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436024/">https://habr.com/ru/post/de436024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436012/index.html">Ich bin ein nutzloser Idiot, deshalb m√∂chte ich meinen Job k√ºndigen: 10 Fragen an einen Softwareentwickler, eine Pilotfolge</a></li>
<li><a href="../de436014/index.html">Mathematische Modelle des Chaos</a></li>
<li><a href="../de436016/index.html">Asterisk Voice Recognition IVR - schnell, einfach, kostenlos</a></li>
<li><a href="../de436020/index.html">Magento 2: Importieren von Produkten aus externen Quellen</a></li>
<li><a href="../de436022/index.html">Wie wir Librem 5 DevKit vollst√§ndig in freier Software entwickelt haben</a></li>
<li><a href="../de436026/index.html">Info Desk: ‚ÄûInternet Archive‚Äú - Geschichte, Mission und Nebenprojekte</a></li>
<li><a href="../de436028/index.html">Eine Einf√ºhrung in Kubernetes f√ºr VMware-Benutzer. Teil 1. Theorie</a></li>
<li><a href="../de436032/index.html">React Tutorial Teil 9: Komponenteneigenschaften</a></li>
<li><a href="../de436036/index.html">K√∂nnen Forscher der k√ºnstlichen Intelligenz ihm einen Test ihrer Arbeit anvertrauen?</a></li>
<li><a href="../de436038/index.html">Der Klang der Stille: Wie viele verr√ºckte Ger√§te sind erforderlich, um eine Umgebung zu erreichen, die f√ºr den Schlaf optimal ist?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>