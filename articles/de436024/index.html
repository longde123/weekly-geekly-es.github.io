<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎤 👈🏽 🥪 Wie man nicht in Java wegwirft 👩🏿‍🚒 🤜🏽 🤛🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es gibt ein weit verbreitetes Missverständnis, dass Sie, wenn Ihnen die Garbage Collection nicht gefällt, nicht in Java, sondern in C / C ++ schreiben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man nicht in Java wegwirft</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436024/"><p> Es gibt ein weit verbreitetes Missverständnis, dass Sie, wenn Ihnen die Garbage Collection nicht gefällt, nicht in Java, sondern in C / C ++ schreiben müssen.  In den letzten drei Jahren habe ich Java-Code mit geringer Latenz für den Devisenhandel geschrieben und musste vermeiden, unnötige Objekte in jeder Hinsicht zu erstellen.  Als Ergebnis formulierte ich ein paar einfache Regeln für mich selbst, wie man Zuweisungen in Java, wenn nicht auf Null, dann auf ein vernünftiges Minimum reduziert, ohne auf manuelle Speicherverwaltung zurückzugreifen.  Vielleicht ist es auch für jemanden aus der Community nützlich. </p><a name="habracut"></a><br><h2>  Warum überhaupt Müll vermeiden? </h2><br><p>  Über das, was GC ist und wie man sie konfiguriert, wurde viel gesagt und geschrieben.  Aber letztendlich funktioniert der Code, egal wie Sie den GC einrichten, suboptimal.  Es gibt immer einen Kompromiss zwischen Durchsatz und Latenz.  Es wird unmöglich, eines zu verbessern, ohne das andere zu verschlechtern.  In der Regel wird der GC-Overhead durch Studieren der Protokolle gemessen. Sie können anhand dieser Protokolle nachvollziehen, zu welchen Zeitpunkten Pausen aufgetreten sind und wie viel Zeit sie in Anspruch genommen haben.  Die GC-Protokolle enthalten jedoch nicht alle Informationen zu diesem Overhead.  Das vom Thread erstellte Objekt wird automatisch in den L1-Cache des Prozessorkerns gestellt, auf dem der Thread ausgeführt wird.  Dies führt dazu, dass andere potenziell nützliche Daten verdrängt werden.  Mit einer großen Anzahl von Zuordnungen können nützliche Daten auch aus dem L3-Cache verschoben werden.  Wenn der Thread das nächste Mal auf diese Daten zugreift, tritt ein Fehlcache auf, der zu Verzögerungen bei der Ausführung des Programms führt.  Da der L3-Cache für alle Kerne innerhalb desselben Prozessors gleich ist, werden durch einen Garbage Stream Daten und andere Threads / Anwendungen aus dem L3-Cache übertragen, und es treten bereits besonders teure Cache-Fehler auf, selbst wenn sie in Bare C geschrieben sind und keinen Müll anlegen.  Keine Einstellungen, keine Garbage Collectors (weder C4 noch ZGC) helfen, dieses Problem zu lösen.  Die einzige Möglichkeit, die Situation insgesamt zu verbessern, besteht darin, nicht unnötig unnötige Objekte zu erstellen.  Java verfügt im Gegensatz zu C ++ nicht über ein umfangreiches Arsenal an Mechanismen für die Arbeit mit Speicher, es gibt jedoch eine Reihe von Möglichkeiten, die Zuweisungen zu minimieren.  Sie werden diskutiert. </p><br><div class="spoiler">  <b class="spoiler_title">Lyrischer Exkurs</b> <div class="spoiler_text"><p>  Natürlich müssen Sie nicht den gesamten müllfreien Code schreiben.  Die Sache mit der Java-Sprache ist, dass Sie Ihr Leben erheblich vereinfachen können, indem Sie nur die Hauptmüllquellen entfernen.  Sie können sich auch nicht mit der sicheren Speicherwiederherstellung befassen, wenn Sie sperrfreie Algorithmen schreiben.  Wenn ein Code beim Start der Anwendung nur einmal ausgeführt wird, kann er so viel zuweisen, wie Sie möchten, und das ist keine große Sache.  Das wichtigste Arbeitsinstrument, um überschüssigen Müll loszuwerden, ist natürlich der Zuordnungsprofiler. </p></div></div><br><h2>  Primitive Typen verwenden </h2><br><p> In vielen Fällen ist es am einfachsten, primitive Typen anstelle von Objekttypen zu verwenden.  Die JVM verfügt über eine Reihe von Optimierungen, um den Overhead von Objekttypen zu minimieren, z. B. das Zwischenspeichern kleiner Werte von Ganzzahltypen und das Inlinen einfacher Klassen.  Es lohnt sich jedoch nicht immer, sich auf diese Optimierungen zu verlassen, da sie möglicherweise nicht funktionieren: Der ganzzahlige Wert wird möglicherweise nicht zwischengespeichert, und Inlining tritt möglicherweise nicht auf.  Wenn wir mit einer bedingten Ganzzahl arbeiten, müssen wir außerdem dem Link folgen, was möglicherweise zu einem Cache-Fehler führt.  Außerdem verfügen alle Objekte über Header, die zusätzlichen Speicherplatz im Cache beanspruchen und andere Daten von dort verdrängen.  Nehmen wir an: Ein primitives int benötigt 4 Bytes.  Object <code>Integer</code> belegt 16 Bytes + Linkgröße für dieses Minimum von 4 Bytes (im Fall von komprimierten Oops).  Insgesamt stellt sich heraus, dass <code>Integer</code> fünf (!) Mal mehr Platz einnimmt als <code>int</code> .  Daher ist es besser, primitive Typen selbst zu verwenden.  Ich werde einige Beispiele geben. </p><br><h3>  Beispiel 1. Konventionelle Berechnungen </h3><br><p>  Nehmen wir an, wir haben eine reguläre Funktion, die nur etwas zählt. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer a, Integer b, Integer c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><p>  Ein solcher Code wird wahrscheinlich inline (sowohl die Methode als auch die Klassen) und führt nicht zu unnötigen Zuweisungen, aber Sie können sich dessen nicht sicher sein.  Selbst wenn dies passiert, gibt es ein Problem mit der Tatsache, dass eine <code>NullPointerException</code> hier <code>NullPointerException</code> könnte.  Auf die eine oder andere Weise muss die JVM entweder Nullprüfungen unter die Haube einfügen oder aus dem Kontext heraus verstehen, dass <code>null</code> kein Argument sein kann.  Auf jeden Fall ist es besser, nur den gleichen Code auf Grundelemente zu schreiben. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (a + b) / c; }</code> </pre> <br><h3>  Beispiel 2. Lambdas </h3><br><p>  Manchmal werden Objekte ohne unser Wissen erstellt.  Zum Beispiel, wenn wir primitive Typen an Orte übergeben, an denen Objekttypen erwartet werden.  Dies passiert häufig bei der Verwendung von Lambda-Ausdrücken. <br>  Stellen Sie sich vor, wir haben diesen Code: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;Integer&gt; calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p>  Trotz der Tatsache, dass die Variable x ein Grundelement ist, wird ein Objekt vom Typ Integer erstellt, das an den Taschenrechner übergeben wird.  Um dies zu vermeiden, verwenden Sie <code>IntConsumer</code> anstelle von <code>Consumer&lt;Integer&gt;</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IntConsumer calculator)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = System.currentTimeMillis(); calculator.accept(x); }</code> </pre> <br><p>  Ein solcher Code führt nicht mehr zur Erstellung eines zusätzlichen Objekts.  Java.util.function verfügt über eine ganze Reihe von Standardschnittstellen, die für die Verwendung primitiver Typen angepasst sind: <code>DoubleSupplier</code> , <code>LongFunction</code> usw.  Wenn etwas fehlt, können Sie jederzeit die gewünschte Schnittstelle mit Grundelementen hinzufügen.  Beispielsweise können Sie anstelle von <code>BiConsumer&lt;Integer, Double&gt;</code> eine selbst erstellte Schnittstelle verwenden. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntDoubleConsumer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span></span>; }</code> </pre> <br><h3>  Beispiel 3. Sammlungen </h3><br><p>  Die Verwendung eines primitiven Typs kann schwierig sein, da sich eine Variable dieses Typs in einer Sammlung befindet.  Angenommen, wir haben eine <code>List&lt;Integer&gt;</code> und möchten herausfinden, welche Zahlen darin enthalten sind, und berechnen, wie oft jede der Zahlen wiederholt wird.  Dafür verwenden wir <code>HashMap&lt;Integer, Integer&gt;</code> .  Der Code sieht folgendermaßen aus: </p><br><pre> <code class="java hljs">List&lt;Integer&gt; numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Map&lt;Integer, Integer&gt; counters = new HashMap&lt;&gt;(); for (Integer x : numbers) { counters.compute(x, (k, v) -&gt; v == null ? 1 : v + 1); }</span></span></code> </pre> <br><p>  Dieser Code ist in mehrfacher Hinsicht gleichzeitig schlecht.  Erstens wird eine Zwischendatenstruktur verwendet, auf die wahrscheinlich verzichtet werden könnte.  Okay, der Einfachheit halber nehmen wir an, dass diese Liste später benötigt wird, d. H.  Sie können es nicht vollständig entfernen.  Zweitens wird das Objekt <code>Integer</code> an beiden Stellen anstelle des primitiven <code>int</code> .  Drittens gibt es viele Zuordnungen in der <code>compute</code> .  Viertens wird ein Iterator zugewiesen.  Diese Zuweisung wird wahrscheinlich inline, aber dennoch.  Wie verwandle ich diesen Code in müllfreien Code?  Sie müssen die Sammlung nur für die Grundelemente einer Bibliothek eines Drittanbieters verwenden.  Es gibt eine Reihe von Bibliotheken, die solche Sammlungen enthalten.  Der folgende Code verwendet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Agrona-</a> Bibliothek. </p><br><pre> <code class="java hljs">IntArrayList numbers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntArrayList(); <span class="hljs-comment"><span class="hljs-comment">// fill numbers somehow Int2IntCounterMap counters = new Int2IntCounterMap(0); for (int i = 0; i &lt; numbers.size(); i++) { counters.incrementAndGet(numbers.getInt(i)); }</span></span></code> </pre> <br><p>  Die hier erstellten Objekte sind zwei Sammlungen und zwei <code>int[]</code> , die sich in diesen Sammlungen befinden.  Beide Sammlungen können durch Aufrufen der <code>clear()</code> -Methode wiederverwendet werden.  Durch die Verwendung von Sammlungen für Grundelemente haben wir unseren Code nicht kompliziert (und sogar vereinfacht, indem wir die Berechnungsmethode mit einem komplexen Lambda darin entfernt haben) und im Vergleich zur Verwendung von Standardsammlungen die folgenden zusätzlichen Boni erhalten: </p><br><ol><li>  Fast völliges Fehlen von Zuweisungen.  Wenn die Sammlungen wiederverwendet werden, gibt es überhaupt keine Zuordnungen. </li><li>  Erhebliche Speicherersparnis ( <code>IntArrayList</code> benötigt etwa fünfmal weniger Speicherplatz als <code>ArrayList&lt;Integer&gt;</code> . Wie bereits erwähnt, <code>IntArrayList</code> wir <code>IntArrayList</code> die wirtschaftliche Verwendung von Prozessor-Caches und nicht von RAM. </li><li>  Serieller Zugriff auf den Speicher.  Es wurde viel darüber geschrieben, warum dies wichtig ist, deshalb werde ich hier nicht aufhören.  Hier einige Artikel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Martin Thompson</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ulrich Drepper</a> . </li></ol><br><p>  Ein weiterer kleiner Kommentar zu Sammlungen.  Es kann sich herausstellen, dass die Sammlung Werte unterschiedlichen Typs enthält und es daher nicht möglich ist, sie durch eine Sammlung mit Grundelementen zu ersetzen.  Meiner Meinung nach ist dies ein Zeichen für ein schlechtes Design der Datenstruktur oder des Algorithmus als Ganzes.  In diesem Fall ist die Zuweisung zusätzlicher Objekte höchstwahrscheinlich nicht das Hauptproblem. </p><br><h2>  Veränderbare Objekte </h2><br><p>  Was aber, wenn auf Primitive nicht verzichtet werden kann?  Zum Beispiel für den Fall, dass die von uns benötigte Methode mehrere Werte zurückgeben sollte.  Die Antwort ist einfach: Verwenden Sie veränderbare Objekte. </p><br><div class="spoiler">  <b class="spoiler_title">Kleiner Exkurs</b> <div class="spoiler_text"><p>  Einige Sprachen betonen die Verwendung unveränderlicher Objekte, beispielsweise in Scala.  Das Hauptargument für sie ist, dass das Schreiben von Multithread-Code stark vereinfacht wird.  Es gibt jedoch auch Gemeinkosten, die mit einer übermäßigen Zuweisung von Müll verbunden sind.  Wenn wir sie vermeiden wollen, sollten wir keine kurzlebigen unveränderlichen Objekte erstellen. </p></div></div><br><p>  Wie sieht es in der Praxis aus?  Angenommen, wir müssen den Quotienten und den Rest der Division berechnen.  Und dafür verwenden wir den folgenden Code. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } <span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Wie kann man in diesem Fall die Zuordnung loswerden?  <code>IntPair</code> , übergeben Sie <code>IntPair</code> als Argument und schreiben Sie das Ergebnis dort.  In diesem Fall müssen Sie ein detailliertes Javadoc schreiben und noch besser eine Konvention für Variablennamen verwenden, in die das Ergebnis geschrieben wird.  Sie können beispielsweise mit dem Präfix out beginnen.  Müllfreier Code sieht in diesem Fall folgendermaßen aus: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor, IntPair outResult)</span></span></span><span class="hljs-function"> </span></span>{ outResult.x = value / divisor; outResult.y = value % divisor; }</code> </pre> <br><p>  Ich möchte darauf hinweisen, dass die <code>divide</code> Methode keinen Link speichern sollte, um ihn irgendwo zu koppeln, oder ihn an Methoden übergeben sollte, die dies können, da wir sonst große Probleme haben könnten.  Wie wir sehen können, sind veränderbare Objekte schwieriger zu verwenden als primitive Typen. Wenn Sie also primitive Objekte verwenden können, ist es besser, dies zu tun.  In unserem Beispiel haben wir das Problem der Zuordnung von innerhalb der Teilungsmethode nach außen übertragen.  An allen Stellen, an denen wir diese Methode aufrufen, benötigen wir einen <code>IntPair</code> Dummy, den wir zum <code>divide</code> .  Oft genug, um diesen Dummy im <code>final</code> Feld des Objekts zu speichern, von wo aus wir die <code>divide</code> Methode aufrufen.  Lassen Sie mich ein weit hergeholtes Beispiel geben: Nehmen wir an, unser Programm behandelt nur den Empfang eines Zahlenstroms über das Netzwerk, teilt diese auf und sendet das Ergebnis an denselben Socket. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SocketListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> IntPair pair = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntPair(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BufferedReader in; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PrintWriter out; SocketListener(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Socket socket) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> IOException { in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(socket.getInputStream())); out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PrintWriter(socket.getOutputStream(), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); divide(value, divisor, pair); out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p>  Der Kürze halber habe ich keinen zusätzlichen Code für die Fehlerbehandlung, die korrekte Programmbeendigung usw. geschrieben.  Die Hauptidee dieses Codes ist, dass das <code>IntPair</code> uns <code>IntPair</code> Objekt einmal erstellt und im <code>final</code> Feld gespeichert wird. </p><br><h2>  Objektpools </h2><br><p>  Wenn wir veränderbare Objekte verwenden, müssen wir zuerst ein leeres Objekt von irgendwoher nehmen, dann die benötigten Daten in das Objekt schreiben, es irgendwo verwenden und dann das Objekt "an Ort und Stelle" zurückgeben.  Im obigen Beispiel war das Objekt immer "an Ort und Stelle", d.h.  im <code>final</code> Feld.  Leider ist dies nicht immer auf einfache Weise möglich.  Beispielsweise wissen wir möglicherweise nicht im Voraus genau, wie viele Objekte wir benötigen.  In diesem Fall helfen uns Objektpools.  Wenn wir ein leeres Objekt benötigen, erhalten wir es aus dem Objektpool, und wenn es nicht mehr benötigt wird, geben wir es dorthin zurück.  Befindet sich kein freies Objekt im Pool, erstellt der Pool ein neues Objekt.  Dies ist in der Tat eine manuelle Speicherverwaltung mit allen sich daraus ergebenden Konsequenzen.  Es ist ratsam, nicht auf diese Methode zurückzugreifen, wenn die vorherigen Methoden verwendet werden können.  Was könnte schief gehen? </p><br><ul><li>  Wir können vergessen, das Objekt in den Pool zurückzugeben, und dann wird Müll ("Speicherverlust") erzeugt.  Dies ist ein kleines Problem - die Leistung wird leicht abnehmen, aber der GC wird funktionieren und das Programm wird weiter funktionieren. </li><li>  Wir können das Objekt in den Pool zurückgeben, aber den Link dazu irgendwo speichern.  Dann wird jemand anderes das Objekt aus dem Pool holen, und zu diesem Zeitpunkt in unserem Programm gibt es bereits zwei Links zu demselben Objekt.  Dies ist ein klassisches Problem nach dem Gebrauch.  Es ist schwer zu debütieren, weil  Im Gegensatz zu C ++ stürzt das Programm nicht ab und funktioniert weiterhin <em>fehlerhaft</em> . </li></ul><br><p>  Um die Wahrscheinlichkeit zu verringern, dass die oben genannten Fehler auftreten, können Sie das Standardkonstrukt "Try-with-Resources" verwenden.  Es kann so aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T object)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STORAGE.get(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  Die Divide-Methode könnte folgendermaßen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">IntPair </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ IntPair result = IntPair.create(); result.x = value / divisor; result.y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Und die <code>listenSocket</code> Methode <code>listenSocket</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (IntPair pair = divide(value, divisor)) { out.print(pair.x); out.print(pair.y); } } }</code> </pre> <br><p>  In der IDE können Sie normalerweise die Hervorhebung aller Fälle konfigurieren, in denen <code>AutoCloseable</code> Objekte außerhalb des Try-with-Resources-Blocks verwendet werden.  Dies ist jedoch keine absolute Option, da  Das Hervorheben in der IDE kann einfach deaktiviert werden.  Daher gibt es eine andere Möglichkeit, die Rückgabe des Objekts an die Pool-Control-Inversion zu gewährleisten.  Ich werde ein Beispiel geben: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntPair</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Storage&lt;IntPair&gt; STORAGE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StorageImpl(IntPair::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IntPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;IntPair&gt; consumer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>(IntPair pair = STORAGE.get()) { consumer.accept(pair); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ STORAGE.dispose(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  In diesem Fall können wir grundsätzlich nicht <code>IntPair</code> außen auf das Objekt der <code>IntPair</code> Klasse <code>IntPair</code> .  Leider funktioniert diese Methode auch nicht immer.  Beispielsweise funktioniert es nicht, wenn ein Thread Objekte aus dem Pool abruft und in eine Warteschlange stellt und ein anderer Thread sie aus der Warteschlange entfernt und in den Pool zurückgibt. </p><br><p>  Wenn wir keine generischen Objekte im Pool speichern, sondern einige Bibliotheksobjekte, die <code>AutoCloseable</code> nicht implementieren, <code>AutoCloseable</code> die Option "Mit Ressourcen versuchen" <code>AutoCloseable</code> auch nicht. </p><br><p>  Ein weiteres Problem ist hier das Multithreading.  Die Implementierung des Objektpools muss sehr schnell erfolgen, was sehr schwer zu erreichen ist.  Ein langsamer Pool kann der Leistung mehr schaden als nützen.  Die Zuweisung neuer Objekte in TLAB ist wiederum sehr schnell, viel schneller als bei malloc in C. Das Schreiben eines schnellen Objektpools ist ein separates Thema, das ich jetzt nicht entwickeln möchte.  Ich kann nur sagen, dass ich keine guten „vorgefertigten“ Implementierungen gesehen habe. </p><br><h2>  Anstelle einer Schlussfolgerung </h2><br><p>  Kurz gesagt, die Wiederverwendung von Objekten mit Objektpools ist eine schwerwiegende Hämorrhoiden.  Glücklicherweise kann man fast immer darauf verzichten.  Meine persönliche Erfahrung ist, dass eine übermäßige Verwendung von Objektpools Probleme mit der Anwendungsarchitektur signalisiert.  In der Regel reicht uns eine Instanz des im <code>final</code> Feld zwischengespeicherten Objekts aus.  Aber auch das ist übertrieben, wenn es möglich ist, primitive Typen zu verwenden. </p><br><h2>  Update: </h2><br><p>  Ja, ich erinnerte mich an einen anderen Weg für diejenigen, die keine Angst vor bitweisen Verschiebungen haben: mehrere kleine primitive Typen in einen großen zu packen.  Angenommen, wir müssen zwei <code>int</code> .  In diesem speziellen Fall können Sie das <code>IntPair</code> Objekt nicht verwenden, sondern ein <code>long</code> Objekt zurückgeben, wobei die ersten 4 Bytes dem ersten <code>int</code> 'y und die zweiten 4 Bytes dem zweiten entsprechen.  Der Code könnte folgendermaßen aussehen: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)left &lt;&lt; Integer.SIZE) | (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)right &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFFFFL</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLeft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(value &gt;&gt;&gt; Integer.SIZE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)value; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> divisor)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = value / divisor; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = value % divisor; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> combine(left, right); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> divisor = in.read(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> xy = divide(value, divisor); out.print(getLeft(xy)); out.print(getRight(xy)); } }</code> </pre> <br><p>  Solche Methoden müssen natürlich gründlich getestet werden, da es ziemlich einfach ist, sie aufzuschreiben.  Aber dann benutze es einfach. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436024/">https://habr.com/ru/post/de436024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436012/index.html">Ich bin ein nutzloser Idiot, deshalb möchte ich meinen Job kündigen: 10 Fragen an einen Softwareentwickler, eine Pilotfolge</a></li>
<li><a href="../de436014/index.html">Mathematische Modelle des Chaos</a></li>
<li><a href="../de436016/index.html">Asterisk Voice Recognition IVR - schnell, einfach, kostenlos</a></li>
<li><a href="../de436020/index.html">Magento 2: Importieren von Produkten aus externen Quellen</a></li>
<li><a href="../de436022/index.html">Wie wir Librem 5 DevKit vollständig in freier Software entwickelt haben</a></li>
<li><a href="../de436026/index.html">Info Desk: „Internet Archive“ - Geschichte, Mission und Nebenprojekte</a></li>
<li><a href="../de436028/index.html">Eine Einführung in Kubernetes für VMware-Benutzer. Teil 1. Theorie</a></li>
<li><a href="../de436032/index.html">React Tutorial Teil 9: Komponenteneigenschaften</a></li>
<li><a href="../de436036/index.html">Können Forscher der künstlichen Intelligenz ihm einen Test ihrer Arbeit anvertrauen?</a></li>
<li><a href="../de436038/index.html">Der Klang der Stille: Wie viele verrückte Geräte sind erforderlich, um eine Umgebung zu erreichen, die für den Schlaf optimal ist?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>