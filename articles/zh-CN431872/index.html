<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌇 👦🏼 ✴️ JavaScript指南第9部分：ES7，ES8和ES9标准概述 🙍🏿 🔦 💃🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，在JavaScript手册翻译的第九部分中，将概述由于ES7，ES8和ES9标准而在语言中出现的功能。 

 → 第1部分：第一个程序，语言功能，标准 
 → 第2部分：代码样式和程序结构 
 → 第3部分：变量，数据类型，表达式，对象 
 → 第4部分：功能 
 → 第5部分：数组和循环 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript指南第9部分：ES7，ES8和ES9标准概述</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/431872/"> 今天，在JavaScript手册翻译的第九部分中，将概述由于ES7，ES8和ES9标准而在语言中出现的功能。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：第一个程序，语言功能，标准</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：代码样式和程序结构</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：变量，数据类型，表达式，对象</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：功能</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分：数组和循环</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分：异常，分号，通配符文字</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7部分：严格模式，此关键字，事件，模块，数学计算</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8部分：ES6功能概述</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9部分：ES7，ES8和ES9标准概述</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">ES7标准</font> </h2><br> 根据官方术语，称为ES2016的ES7标准于2016年夏天发布。 与ES6相比，他带来的语言并不新鲜。 特别是，我们在谈论以下内容： <br><br><ul><li> <code>Array.prototype.includes()</code>方法。 </li><li> 求幂运算符。 </li></ul><br><h3>  <font color="#3AC1EF">▍方法Array.prototype.includes（）</font> </h3><br>  <code>Array.prototype.includes()</code>方法旨在检查数组中是否存在元素。 在数组中找到所需的对象，它返回<code>true</code> ，而不是find- <code>false</code> 。 在ES7之前， <code>indexOf()</code>方法用于执行相同的操作，如果找到元素，则该方法返回在数组中可以找到该元素的第一个索引。 如果<code>indexOf()</code>找不到元素，则返回数字<code>-1</code> 。 <br><br> 根据JavaScript类型转换规则，数字<code>-1</code>转换为<code>true</code> 。 结果，要检查<code>indexOf()</code>的运算结果<code>indexOf()</code>应该使用以下形式的不太方便的构造。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>) === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br> 如果在类似情况下，假设没有找到任何元素的<code>indexOf()</code>返回<code>false</code> ，则使用如下所示的代码，则代码将无法正常工作。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].indexOf(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// console.log('Not found') }</span></span></code> </pre> <br> 在这种情况下，事实证明<code>![1,2].indexOf(3)</code>的构造为<code>false</code> 。 <br><br> 使用<code>includes()</code>方法，这种比较看起来更加合乎逻辑。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>].includes(<span class="hljs-number"><span class="hljs-number">3</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Not found'</span></span>) }</code> </pre> <br> 在这种情况下，构造<code>[1,2].includes(3)</code>返回<code>false</code> ，此值是一个运算符<code>!</code> 变为<code>true</code> ，控制台将收到一条消息，指出未找到阵列中的项目。 <br><br><h3>  <font color="#3AC1EF">▍求幂运算符</font> </h3><br> 幂运算符执行与<code>Math.pow()</code>方法相同的功能，但是比起库函数使用它更方便，因为它是语言的一部分。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">4</span></span> ** <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">//true</span></span></code> </pre> <br> 该运算符可以被视为JS的一个令人愉快的添加，它在执行某些计算的应用程序中很有用。 其他编程语言中也存在类似的运算符。 <br><br><h2>  <font color="#3AC1EF">ES8标准</font> </h2><br>  ES8标准（ES2017）于2017年发布。 像ES7一样，他并没有给语言带来太多帮助。 即，我们正在谈论以下功能： <br><br><ul><li> 将字符串添加到给定的长度。 </li><li> 方法<code>Object.values()</code> 。 </li><li> 方法<code>Object.entries()</code> 。 </li><li> 方法<code>Object.getOwnPropertyDescriptors()</code> 。 </li><li> 函数参数中的尾部逗号。 </li><li> 异步功能。 </li><li> 使用共享内存和原子操作。 </li></ul><br><h3>  <font color="#3AC1EF">lines将线添加到给定的长度</font> </h3><br>  ES8引入了两个新的<code>String</code>对象方法<code>padStart()</code>和<code>padEnd()</code> 。 <br><br>  <code>padStart()</code>方法用另一行填充当前行，直到最后一行达到所需的长度。 填充发生在行的开头（左）。 这是使用此方法的方法。 <br><br><pre> <code class="javascript hljs">str.padStart(targetLength [, padString])</code> </pre> <br> 这里的<code>str</code>是当前行， <code>targetLength</code>是最后一行的长度（如果小于当前行的长度，则将返回此行而不会更改）， <code>padString</code>是一个可选参数-用于填充当前行的行。 如果未指定<code>padString</code> ，则使用空格字符<code>padString</code>当前行<code>padString</code>到指定的长度。 <br><br>  <code>padEnd()</code>方法类似于<code>padStart()</code> ，但该行在右侧填充。 <br><br> 考虑使用这些方法的示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padStart(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str1 = <span class="hljs-string"><span class="hljs-string">'test'</span></span>.padEnd(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'*'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">'`</span></span>) <span class="hljs-comment"><span class="hljs-comment">//'      test' console.log(`'${str1}'`) //'test******'</span></span></code> </pre> <br> 在这里，当仅使用<code>padStart()</code>并使用所需长度的结果字符串时， <code>padStart()</code>空格添加到原始字符串的开头。 当使用<code>padEnd()</code>以及最后一行的长度和要填充它的行时， <code>*</code>字符被添加到原始行的末尾。 <br><br><h3>  <font color="#3AC1EF">▍方法Object.values（）</font> </h3><br> 此方法返回一个数组，其中包含对象自己的属性的值，即对象本身包含的那些属性，而不是可通过原型链访问的那些属性。 <br><br> 这是使用方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.values(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// ['Fred', 87]</span></span></code> </pre> <br> 此方法也适用于数组。 <br><br><h3>  <font color="#3AC1EF">▍方法Object.entries（）</font> </h3><br> 此方法返回一个数组，该数组的每个元素也是一个数组，该数组包含<code>[key, value]</code>格式的对象自身属性的键和值。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> personValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.entries(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(personValues) <span class="hljs-comment"><span class="hljs-comment">// [['name', 'Fred'], ['age', 87]]</span></span></code> </pre> <br> 将这种方法应用于数组时，元素的索引显示为键，而数组中对应索引处存储的内容则显示为值。 <br><br><h3>  <font color="#3AC1EF">▍getOwnPropertyDescriptors（）方法</font> </h3><br> 此方法返回有关对象自身所有属性的信息。 属性集（描述符）与对象属性相关联。 特别是，我们在谈论以下属性： <br><br><ul><li>  <code>value</code>对象属性的值。 </li><li>  <code>writable</code> -如果可以更改属性，则包含<code>true</code> 。 </li><li>  <code>get</code>包含与属性关联的getter函数，或者，如果没有这样的函数，则为<code>undefined</code> 。 </li><li>  set-包含属性的setter函数或<code>undefined</code> 。 </li><li>  <code>configurable</code> -如果为<code>false</code>无法删除该属性，除了值之外，不能更改其属性。 </li><li>  <code>enumerable</code> -如果此属性包含true，则该属性可枚举。 </li></ul><br> 这是使用此方法的方法。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(obj)</code> </pre> <br> 它获取需要查找其属性信息的对象，然后返回包含此信息的对象。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fred'</span></span>, <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">87</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> propDescr = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(propDescr) <span class="hljs-comment"><span class="hljs-comment">/* { name:  { value: 'Fred',    writable: true,    enumerable: true,    configurable: true }, age:  { value: 87,    writable: true,    enumerable: true,    configurable: true } } */</span></span></code> </pre> <br> 为什么需要这种方法？ 事实是，除了其他属性，getter和setter之外，它还允许您创建对象的小型副本，进行复制。 无法使用ES6标准中出现的<code>Object.assign()</code>方法来复制对象。 <br><br> 下面的示例包含一个带有setter的对象，该对象使用<code>console.log()</code>显示其试图写入其相应属性的内容。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person1 = { set name(newName) {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(newName) } } person1.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">// x</span></span></code> </pre> <br> 让我们尝试使用<code>assign()</code>方法复制该对象。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person2 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign(person2, person1) person2.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//     ,   </span></span></code> </pre> <br> 如您所见，这种方法行不通。  <code>name</code>属性（它是原始对象中的设置器）现在表示为常规属性。 <br><br> 现在，我们将使用<code>Object.defineProperties()</code> （在ES5.1中出现）和<code>Object.getOwnPropertyDescriptors()</code>方法复制对象。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> person3 = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(person3, <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptors(person1)) person3.name = <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-comment"><span class="hljs-comment">//x</span></span></code> </pre> <br> 在此，设置器保留在对象的副本中。 <br><br> 应该注意的是，当用于克隆对象时，特定于<code>Object.assign()</code>的限制也是<code>Object.create()</code>方法的特征。 <br><br><h3>  <font color="#3AC1EF">function功能参数的补逗号</font> </h3><br> 此功能使您可以在声明和调用函数时在参数或参数列表的末尾留下逗号。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> var1, var2, </span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } doSomething( 'test1', 'test2', )</span></span></code> </pre> <br> 这提高了版本控制系统的可用性。 即，我们正在谈论的事实是，在向函数添加新参数时，不必为了插入逗号而更改现有代码。 <br><br><h3>  <font color="#3AC1EF">▍异步功能</font> </h3><br>  <code>async/await</code>构造已出现在ES2017标准中，可以认为是该版本语言的最重要创新。 <br><br> 异步功能是promise和生成器的组合；它们简化了以前需要大量模板代码和不方便描述promise链的构造。 实际上，我们正在谈论对承诺的高级抽象。 <br><br> 当诺言出现在ES2015标准中时，它们旨在解决异步代码存在的问题。 但是在共享ES2015和ES2017标准的两年中，很明显，不能将承诺视为解决这些问题的最终解决方案。 <br><br> 特别是，这些承诺旨在解决“回调地狱”问题，但是，解决了这个问题后，由于使用它们的代码的复杂性，它们本身并没有表现出最好的一面。 实际上， <code>async/await</code>构造解决了promise问题并提高了异步代码的可用性。 <br><br> 考虑一个例子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br> 此代码会将以下内容输出到控制台。 <br><br><pre> <code class="javascript hljs">Before After I did something</code> </pre> <br> 如您所见，在调用<code>doSomething()</code>程序继续运行，在控制台中显示<code>Before</code> ， <code>After</code> ，并且经过三秒钟之后， <code>I did something</code> 。 <br><br><h4> 串行异步函数调用 </h4><br> 如有必要，异步函数可以形成类似于调用链的内容。 仅基于承诺，此类设计的可读性优于类似设计。 在下面的示例中可以看到。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">promiseToDoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)=&gt;</span></span>{     setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>) }) } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchOverSomeoneWatchingSomeoneDoingSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">// I did something and I watched and I watched as well })</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍共享内存和原子操作</font> </h3><br> 在这里，我们谈论的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SharedArrayBuffer</a>对象，它允许您描述共享内存区域；还有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Atomics</a>对象，它包含一组以静态方法形式进行的原子操作。 有关这些对象为程序员提供可能性的详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a> 。 <br><br><h2>  <font color="#3AC1EF">ES9标准</font> </h2><br>  ES9（ES2018）是发布此材料时该标准的最新版本。 其主要功能如下： <br><br><ul><li> 将传播和休息声明应用于对象。 </li><li> 异步迭代器。 </li><li> 方法<code>Promise.prototype.finally()</code> 。 </li><li> 正则表达式增强。 </li></ul><br><h3>  <font color="#3AC1EF">spread散布和休息操作员在对象上的应用</font> </h3><br> 我们已经讨论过ES6中出现的其余和散布运算符，这些运算符可用于处理数组。 他们看起来都像三个点。 在下面的解构数组示例中，rest运算符使您可以将其第一个和第二个元素放在常量<code>first</code>和<code>second</code> ，并将所有其余元素放在常量<code>others</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [first, second, ...others] = numbers <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //[ 3, 4, 5 ]</span></span></code> </pre> <br>  <code>spread</code>运算符使您可以将数组传递给需要常规参数列表的函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> numbers = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sum = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c, d, e</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b + c + d + e <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res = sum(...numbers) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) <span class="hljs-comment"><span class="hljs-comment">//15</span></span></code> </pre> <br> 现在，使用相同的方法，您可以处理对象。 这是在破坏性分配操作中使用rest语句的示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { first, second, ...others } = { <span class="hljs-attr"><span class="hljs-attr">first</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">second</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">third</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">fourth</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-attr"><span class="hljs-attr">fifth</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(first) <span class="hljs-comment"><span class="hljs-comment">//1 console.log(second) //2 console.log(others) //{ third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br> 这是在基于现有对象创建新对象时使用的传播语句。 本示例继续上一个示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> items = { first, second, ...others } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(items) <span class="hljs-comment"><span class="hljs-comment">//{ first: 1, second: 2, third: 3, fourth: 4, fifth: 5 }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">▍异步迭代器</font> </h3><br> 新的<code>for-await-of</code>构造允许您调用异步函数，这些异步函数在循环中返回promise。 这样的循环等待承诺的解决，然后再进行下一步。 这是它的外观。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> readLines(filePath)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(line) }</code> </pre> <br> 同时，应注意，此类循环应在异步函数中使用-与使用<code>async/await</code>构造时相同的方式。 <br><br><h3>  <font color="#3AC1EF">▍Promise.prototype.finally（）方法</font> </h3><br> 如果成功解决了诺言，则调用下一个<code>then()</code>方法。 如果出现问题，将调用<code>catch()</code>方法。  <code>finally()</code>方法允许您执行某些代码，而不管之前发生了什么。 <br><br><pre> <code class="javascript hljs">fetch(<span class="hljs-string"><span class="hljs-string">'file.json'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.json()) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error)) .finally(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'finished'</span></span>))</code> </pre> <br><h3>  <font color="#3AC1EF">▍正则表达式的改进</font> </h3><br> 正则表达式具有追溯检查字符串（ <code>?&lt;=</code> ）的能力。 这使您可以在行中搜索某些构造之前，还有其他一些构造。 <br><br> 在ES2018标准之前，使用JavaScript实现的正则表达式具有使用<code>?=</code>构造进行检查的能力。 通过此类检查，您可以知道另一个片段是否跟随一行的某个片段。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?= Waters)/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br> 施工<code>?!</code> 执行相反的操作-仅当另一行不在给定行之后，才会找到匹配项。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/Roger(?! Waters)/g</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br> 在回顾性验证中，如前所述，使用结构<code>?&lt;=</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;=Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//false console.log(res2) //true</span></span></code> </pre> <br> 与所述相反的操作可以使用结构<code>?&lt;!</code>  。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;!Roger) Waters/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res1 = r.test(<span class="hljs-string"><span class="hljs-string">'Pink Waters is my dog'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> res2 = r.test(<span class="hljs-string"><span class="hljs-string">'Roger is my dog and Roger Waters is a famous musician'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res1) <span class="hljs-comment"><span class="hljs-comment">//true console.log(res2) //false</span></span></code> </pre> <br><h4>  Unicode正则转义序列 </h4><br> 在正则表达式中，可以使用与任何数字匹配的<code>\d</code>类，与任何空格字符匹配的<code>\s</code>类，与任何字母数字字符匹配的<code>\w</code>类，等等。 有问题的功能扩展了可在正则表达式中使用的类集，从而使您可以处理Unicode序列。 我们正在谈论类<code>\p{}</code>和类<code>\P{}</code>的逆。 <br><br> 在Unicode中，每个字符都有一组属性。 这些属性显示在<code>\p{}</code>组的花括号中。 因此，例如，“ <code>Script</code>属性确定字符所属的语言家族，“ <code>ASCII</code>属性为逻辑，ASCII字符为<code>true</code> ，依此类推。 例如，我们将找出某些行是否仅包含ASCII字符。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'abc'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('ABC@')) //true console.log(r.test('ABC')) //false</span></span></code> </pre> <br>  <code>ASCII_Hex_Digit</code>属性仅对于可用于写入十六进制数字的字符为<code>true</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{ASCII_Hex_Digit}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'0123456789ABCDEF'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('H')) //false</span></span></code> </pre> <br> 如上所述，还有许多其他类似的属性以相同的方式使用。 其中包括<code>Uppercase</code> ， <code>Lowercase</code> ， <code>White_Space</code> ， <code>Alphabetic</code> ， <code>Emoji</code> 。 <br><br> 例如，这是使用<code>Script</code>属性确定字符串中使用哪个字母的方法。 在这里，我们检查字符串是否使用希腊字母。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> r = <span class="hljs-regexp"><span class="hljs-regexp">/^\p{Script=Greek}+$/u</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r.test(<span class="hljs-string"><span class="hljs-string">'ελληνικά'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//true console.log(r.test('hey')) //false</span></span></code> </pre> <br> 这些属性的详细信息可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>找到。 <br><br><h4> 命名组 </h4><br> 可以为ES2018中捕获的字符组命名。 这是它的外观。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: { year: '2015', month: '01', day: '02' } ] */</span></span></code> </pre> <br> 如果不使用命名组，则相同的数据仅可用作数组元素。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> re = <span class="hljs-regexp"><span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = re.exec(<span class="hljs-string"><span class="hljs-string">'2015-01-02'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">/* [ '2015-01-02', '2015', '01', '02', index: 0, input: '2015-01-02', groups: undefined ] */</span></span></code> </pre> <br><h4> 正则表达式标志 </h4><br> 使用<code>s</code>标志生成一个字符<code>.</code>  （点）将与换行符匹配。 没有此标志，句点匹配换行符以外的任何字符。 <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/hi.welcome/</span></span>.test(<span class="hljs-string"><span class="hljs-string">'hi\nwelcome'</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// false console.log(/hi.welcome/s.test('hi\nwelcome')) // true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 借助这些材料，我们将完成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本</a> JavaScript手册的翻译版本。 我们希望这些出版物能帮助那些以前没有使用JavaScript的人迈出用这种语言编程的第一步。 <br><br>  <b>亲爱的读者们！</b> 如果您以前没有用JS编写过并且在本指南中已经熟练掌握了该语言，请分享您的印象。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431872/">https://habr.com/ru/post/zh-CN431872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431862/index.html">叶卡捷琳堡的Mitap Sbertekh</a></li>
<li><a href="../zh-CN431864/index.html">PVS-Studio ROI：如何不损失数百万美元（本文草稿版）</a></li>
<li><a href="../zh-CN431866/index.html">程序员对名称的误解-带有示例</a></li>
<li><a href="../zh-CN431868/index.html">气体放电灯（GRI）的小时数，它们是数字时钟</a></li>
<li><a href="../zh-CN431870/index.html">带有LED的交互式书籍的开发者抱怨Google员工盗用创意</a></li>
<li><a href="../zh-CN431874/index.html">Imba：JavaScript兼容语言，可快速使用DOM</a></li>
<li><a href="../zh-CN431876/index.html">优化Angular应用</a></li>
<li><a href="../zh-CN431878/index.html">鲜为人知的JavaScript功能</a></li>
<li><a href="../zh-CN431880/index.html">SceneKit的厄运。 Yandex在iOS中使用3D图形的经验</a></li>
<li><a href="../zh-CN431884/index.html">微软的市值超过了苹果：这是怎么发生的？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>