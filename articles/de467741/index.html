<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🎤 👩🏽‍🚒 🙌 Einführung in deterministische Assemblys in C / C ++. Teil 1 🎱 🐳 🎻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Übersetzung des Artikels wurde speziell für Studenten des Kurses "C ++ Developer" vorbereitet. 



 Was ist eine deterministische Versammlung? 
 E...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in deterministische Assemblys in C / C ++. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/467741/">  <i>Die Übersetzung des Artikels wurde speziell für Studenten des Kurses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"C ++ Developer"</a> vorbereitet.</i> <br><br><img src="https://habrastorage.org/webt/pe/j0/5e/pej05eo-w-5tdwrp0yrlv7lbedy.png"><br><hr><br><h3>  Was ist eine deterministische Versammlung? </h3><br>  Eine deterministische Assemblierung ist der Prozess des Assemblierens desselben Quellcodes mit derselben Umgebung und derselben Assembleranweisung, in dem auf jeden Fall dieselben Binärdateien erstellt werden, selbst wenn sie auf verschiedenen Computern, in verschiedenen Verzeichnissen und mit unterschiedlichen Namen erstellt werden .  Solche Assemblys werden manchmal auch als abspielbare oder versiegelte Assemblys bezeichnet, wenn garantiert ist, dass sie auch beim Kompilieren aus verschiedenen Ordnern dieselben Binärdateien erstellen. <a name="habracut"></a><br><br>  Deterministische Versammlungen passieren nicht von alleine.  Sie werden nicht in normalen Projekten erstellt, und die Gründe, warum dies nicht geschieht, können für jedes Betriebssystem oder jeden Compiler unterschiedlich sein. <br><br>  Deterministische Baugruppen müssen für eine bestimmte <i>Baugruppenumgebung</i> garantiert werden.  Dies bedeutet, dass einige Variablen, wie z. B. <i>Betriebssystem, Build-Systemversionen und Zielarchitektur</i> , in verschiedenen Builds vermutlich gleich bleiben. <br><br>  In den letzten Jahren haben verschiedene Organisationen wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chromium</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reproducible Builds</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Yocto</a> große Anstrengungen unternommen, um deterministische Baugruppen zu erreichen. <br><br><h3>  Die Bedeutung deterministischer Versammlungen </h3><br>  Es gibt zwei Hauptgründe, warum deterministische Versammlungen so wichtig sind: <br><br><ul><li>  <b>Sicherheit</b>  Das Ändern von Binärdateien anstelle von Quellcode kann die Änderungen für die ursprünglichen Autoren unsichtbar machen.  Dies kann in sicherheitskritischen Umgebungen wie Medizin, Luftfahrt und Weltraum tödlich sein.  Potenziell identische Ergebnisse für diese Materialien ermöglichen es Dritten, einen Konsens über das richtige Ergebnis zu erzielen. </li><li>  <b>Rückverfolgbarkeit und binäre Kontrolle</b> .  Wenn Sie ein Repository zum Speichern Ihrer Binärdateien haben möchten, möchten Sie höchstwahrscheinlich keine Binärdateien mit zufälligen Prüfsummen aus Quellen in derselben Revision erstellen.  Dies kann dazu führen, dass das Repository-System verschiedene Binärdateien als unterschiedliche Versionen speichert, wenn sie identisch sein sollten.  Wenn Sie beispielsweise unter Windows oder MacOS arbeiten, enthält die Bibliothek Felder zum Zeitpunkt der Erstellung / Änderung der darin enthaltenen Objektdateien, was zu Unterschieden bei Binärdateien führt. </li></ul><br><h3>  Binärdateien, die am Erstellungsprozess in C / C ++ beteiligt sind </h3><br>  Abhängig vom Betriebssystem gibt es verschiedene Arten von Binärdateien, die während des Erstellungsprozesses in C / C ++ erstellt werden. <br><br>  <b>Microsoft Windows</b>  Am wichtigsten sind die Dateien mit den Erweiterungen <code>.obj</code> , <code>.lib</code> <code>.obj</code>  <code>dll</code> und <code>.exe</code> .  Sie alle entsprechen der PE-Formatspezifikation (Portable Executable).  Diese Dateien können mit Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dumpbin</a> analysiert werden. <br>  <b>Linux</b>  Dateien mit den Erweiterungen <code>.o</code> , <code>.a</code> , <code>.so</code> und ohne Erweiterungen (für ausführbare Binärdateien) entsprechen dem Format ausführbarer und zusammensetzbarer Dateien (ausführbares und verknüpfbares Format, ELF).  Der Inhalt von ELF-Dateien kann mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">readelf</a> analysiert werden. <br>  <b>Mac OS</b>  Dateien mit den Erweiterungen <code>.o</code> , <code>.a</code> , <code>.dylib</code> und ohne Erweiterungen (für ausführbare Binärdateien) entsprechen der Mach-O- <code>.dylib</code> .  Diese Dateien können mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">otool-</a> Anwendung überprüft werden, die Teil des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Xcode-</a> Toolkits unter MacOS ist. <br><br><h3>  Variationsquellen </h3><br>  Viele verschiedene Faktoren können Ihre Baugruppen <i>nicht deterministisch machen</i> .  Die Faktoren variieren für verschiedene Betriebssysteme und Compiler.  Jeder Compiler verfügt über bestimmte Parameter, um die Variationsquellen zu korrigieren.  Bisher sind <code>gcc</code> und <code>clang</code> die Compiler, die mehr Optionen zum Reparieren enthalten.  Es gibt einige undokumentierte Optionen für <code>msvc</code> , die Sie ausprobieren können, aber am Ende müssen Sie wahrscheinlich die Binärdateien reparieren, um deterministische Assemblys zu erhalten. <br><br><h4>  Vom Compiler / Linker hinzugefügte Zeitstempel </h4><br>  Es gibt zwei Hauptgründe, warum unsere Binärdateien Zeitinformationen enthalten können, die sie unspielbar machen: <br><br><ul><li>  Verwenden der <code>__TIME__</code> <code>__DATE__</code> oder <code>__TIME__</code> in der Quelle. </li><li>  Wenn ein Dateiformat Sie zwingt, Zeitinformationen in Objektdateien zu speichern.  Dies ist der Fall beim Portable Executable-Format unter Windows und bei Mach-O unter MacOS.  Unter Linux codieren ELF-Dateien keine Zeitstempel. </li></ul><br>  Schauen wir uns ein Beispiel an, in dem diese Informationen mit dem Kompilieren einer statischen Bibliothek des Hello World Base-Projekts unter MacOS enden. <br><br><pre> <code class="cpp hljs">. ├── CMakeLists.txt ├── hello_world.cpp ├── hello_world.hpp ├── main.cpp └── run_build.sh</code> </pre> <br>  Die Bibliothek zeigt im Terminal eine Meldung an: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"hello_world.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; void HelloWorld::PrintMessage(const std::string &amp; message) { std::cout &lt;&lt; message &lt;&lt; std::endl; }</span></span></span></span></code> </pre> <br>  Und die Anwendung wird dies verwenden, um die Meldung "Hallo Welt!" Anzuzeigen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "hello_world.hpp" int main(int argc, char** argv) { HelloWorld hello; hello.PrintMessage("Hello World!"); return 0; }</span></span></span></span></code> </pre> <br>  Wir werden CMake verwenden, um das Projekt zu erstellen: <br><br><pre> <code class="cpp hljs">cmake_minimum_required(VERSION <span class="hljs-number"><span class="hljs-number">3.0</span></span>) project(HelloWorld) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(CMAKE_CXX_STANDARD <span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>(CMAKE_CXX_STANDARD_REQUIRED ON) add_library(HelloLibA hello_world.cpp) add_library(HelloLibB hello_world.cpp) add_executable(helloA main.cpp) add_executable(helloB main.cpp) target_link_libraries(helloA HelloLibA) target_link_libraries(helloB HelloLibB)</code> </pre> <br>  Wir werden zwei verschiedene Bibliotheken mit demselben Quellcode sowie zwei Binärdateien mit denselben Quellen erstellen.  Erstellen Sie das Projekt und führen Sie <code>md5sum</code> , um die Prüfsummen aller Binärdateien <code>md5sum</code> : <br><br><pre> <code class="cpp hljs">mkdir build &amp;&amp; cd build cmake .. make md5sum helloA md5sum helloB md5sum CMakeFiles/HelloLibA.dir/hello_world.cpp.o md5sum CMakeFiles/HelloLibB.dir/hello_world.cpp.o md5sum libHelloLibA.a md5sum libHelloLibB.a</code> </pre> <br>  Wir bekommen eine Schlussfolgerung wie folgt: <br><br><pre> <code class="cpp hljs">b5dce09c593658ee348fd0f7fae22c94 helloA b5dce09c593658ee348fd0f7fae22c94 helloB <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibA.dir/hello_world.cpp.o <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibB.dir/hello_world.cpp.o adb80234a61bb66bdc5a3b4b7191eac7 libHelloLibA.a <span class="hljs-number"><span class="hljs-number">5</span></span>ac3c70d28d9fdd9c6571e077131545e libHelloLibB.a</code> </pre> <br>  Dies ist interessant, da die <code>helloA</code> <code>helloB</code> <code>helloA</code> und <code>helloB</code> dieselben Prüfsummen sowie die Mach-O-Zwischenobjektdateien <code>hello_world.cpp.o</code> haben. Dies gilt jedoch nicht für Dateien mit der Erweiterung <code>.a</code> .  Dies liegt daran, dass sie Informationen zu Zwischenobjektdateien in einem Archivformat speichern.  Der Header dieses Formats enthält ein Feld namens <code>st_time</code> das vom <code>stat</code> -Systemaufruf festgelegt wurde.  Überprüfen Sie <code>libHelloLibA.a</code> und <code>libHelloLibB.a</code> mit <code>otool</code> , um die Header <code>otool</code> : <br><br><pre> <code class="cpp hljs">&gt; otool -a libHelloLibA.a Archive : libHelloLibA.a <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">612</span></span> <span class="hljs-number"><span class="hljs-number">1566927276</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">13036</span></span> <span class="hljs-number"><span class="hljs-number">1566927271</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">28</span></span> &gt; otool -a libHelloLibB.a Archive : libHelloLibB.a <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">612</span></span> <span class="hljs-number"><span class="hljs-number">1566927277</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">13036</span></span> <span class="hljs-number"><span class="hljs-number">1566927272</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">28</span></span></code> </pre> <br>  Wir sehen, dass die Datei mehrere temporäre Felder enthält, die unsere Assembly nicht deterministisch machen.  Beachten Sie, dass diese Felder nicht für die endgültige ausführbare Datei gelten, da sie dieselbe Prüfsumme haben.  Dieses Problem kann auch beim Erstellen unter Windows mit Visual Studio auftreten, jedoch mit einer PE-Datei anstelle von Mach-O. <br><br>  An diesem Punkt können wir versuchen, die Dinge noch schlimmer zu machen und unsere Binärdateien auch nicht deterministisch zu machen.  Ändern Sie die Datei <code>__TIME__</code> so, dass sie das Makro <code>__TIME__</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "hello_world.hpp" int main(int argc, char** argv) { HelloWorld hello; hello.PrintMessage("Hello World!"); std::cout &lt;&lt; "At time: " &lt;&lt; __TIME__ &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre> <br>  Überprüfen Sie die Prüfsummen der Dateien erneut: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">625</span></span>ecc7296e15d41e292f67b57b04f15 helloA <span class="hljs-number"><span class="hljs-number">20f</span></span>92d2771a7d2f9866c002de918c4da helloB <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibA.dir/hello_world.cpp.o <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibB.dir/hello_world.cpp.o b7801c60d3bc4f83640cadc1183f43b3 libHelloLibA.a <span class="hljs-number"><span class="hljs-number">4</span></span>ef6cae3657f2a13ed77830953b0aee8 libHelloLibB.a</code> </pre> <br>  Wir sehen, dass wir jetzt verschiedene Binärdateien haben.  Wir könnten die ausführbare Datei mit einem Werkzeug wie einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diffoskop analysieren</a> , das den Unterschied zwischen zwei Binärdateien zeigt: <br><br><pre> <code class="cpp hljs">&gt; diffoscope helloA helloB --- helloA +++ helloB ├── otool -arch x86_64 -tdvV {} │┄ Code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> architecture x86_64 │ @@ <span class="hljs-number"><span class="hljs-number">-16</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span> +<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span> @@ │ <span class="hljs-number"><span class="hljs-number">00000001000018</span></span>da jmp <span class="hljs-number"><span class="hljs-number">0x1000018df</span></span> │ <span class="hljs-number"><span class="hljs-number">00000001000018</span></span>df leaq <span class="hljs-number"><span class="hljs-number">-0x30</span></span>(%rbp), %rdi │ <span class="hljs-number"><span class="hljs-number">00000001000018e3</span></span> callq <span class="hljs-number"><span class="hljs-number">0x100002d54</span></span> #<span class="hljs-meta"><span class="hljs-meta"># symbol stub for: __ZNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED1Ev │ 00000001000018e8 movq 0x1721(%rip), %rdi ## literal pool symbol address: __ZNSt3__14coutE │ 00000001000018ef leaq 0x162f(%rip), %rsi ## literal pool for: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"At time: "</span></span></span><span class="hljs-meta"> │ 00000001000018f6 callq 0x100002d8a ## symbol stub for: __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc │ 00000001000018fb movq %rax, %rdi │ -00000001000018fe leaq 0x162a(%rip), %rsi ## literal pool for: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"19:40:47"</span></span></span><span class="hljs-meta"> │ +00000001000018fe leaq 0x162a(%rip), %rsi ## literal pool for: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"19:40:48"</span></span></span><span class="hljs-meta"> │ 0000000100001905 callq 0x100002d8a ## symbol stub for: __ZNSt3__1lsINS_11char_traitsIcEEEERNS_13basic_ostreamIcT_EES6_PKc │ 000000010000190a movq %rax, %rdi │ 000000010000190d leaq __ZNSt3__1L4endlIcNS_11char_traitsIcEEEERNS_13basic_ostreamIT_T0_EES7_(%rip), %rsi #</span></span></code> </pre> <br>  Es zeigt, dass <code>__TIME__</code> -Informationen in die Binärdatei eingefügt wurden, wodurch sie nicht deterministisch sind.  Mal sehen, was getan werden kann, um dies zu vermeiden. <br><br><h4>  Mögliche Lösungen für Microsoft Visual Studio </h4><br>  Microsoft Visual Studio verfügt über ein Linker / Brepro-Flag, das nicht von Microsoft dokumentiert ist.  Dieses Flag setzt die Zeitstempel aus dem Portable Executable-Format auf -1 (siehe Abbildung unten). <br><br><img src="https://habrastorage.org/webt/oh/ds/ca/ohdsca2wvgdmv_j4zdfgbyc5xmq.png"><br><br>  Um dieses Flag mit CMake zu aktivieren, müssen wir beim Erstellen der <code>.exe</code> Datei die folgenden Zeilen hinzufügen: <br><br><pre> <code class="cpp hljs">add_link_options(<span class="hljs-string"><span class="hljs-string">"/Brepro"</span></span>)</code> </pre> <br>  oder diese Zeilen für <code>.lib</code> <br><br><pre> <code class="cpp hljs">set_target_properties( TARGET PROPERTIES STATIC_LIBRARY_OPTIONS <span class="hljs-string"><span class="hljs-string">"/Brepro"</span></span> )</code> </pre> <br>  Das Problem ist, dass dieses Flag die Binärdateien (relativ zu den Zeitstempeln im Dateiformat) in unserer endgültigen binären EXE-Datei abspielbar macht, jedoch nicht alle Zeitstempel aus der LIB entfernt (dasselbe Problem wie bei den Mach-O-Objektdateien). worüber wir oben gesprochen haben).  Das TimeDateStamp-Feld aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der COFF-Headerdatei</a> für <code>.lib</code> Dateien bleibt erhalten.  Die einzige Möglichkeit, diese Informationen aus der binären <code>.lib</code> Datei zu entfernen, besteht darin, die <code>.lib</code> zu reparieren, indem die dem TimeDateStamp-Feld entsprechenden Bytes durch einen bekannten Wert ersetzt werden. <br><br><h4>  Mögliche Lösungen für GCC und CLANG </h4><br><ul><li>  gcc erkennt das Vorhandensein der Umgebungsvariablen SOURCE_DATE_EPOCH.  Wenn diese Variable festgelegt ist, gibt ihr Wert den UNIX-Zeitstempel an, der verwendet wird, um das aktuelle Datum und die aktuelle Uhrzeit in den Makros <code>__DATE__</code> und <code>__TIME__</code> zu ersetzen, damit die integrierten Zeitstempel reproduzierbar werden.  Der Wert kann auf einen bekannten Zeitstempel festgelegt werden, z. B. den Zeitpunkt der letzten Änderung an den Quelldateien oder dem Paket. </li><li>  clang verwendet <code>ZERO_AR_DATE</code> , das, falls festgelegt, den in den Archivdateien angegebenen <code>ZERO_AR_DATE</code> auf 0 zurücksetzt. Beachten Sie, dass dadurch die <code>__TIME__</code> <code>__DATE__</code> oder <code>__TIME__</code> nicht repariert werden.  Wenn wir den Effekt dieses Makros korrigieren möchten, müssen wir entweder die Binärdateien korrigieren oder die Systemzeit vortäuschen. </li></ul><br>  <code>ZERO_AR_DATE</code> wir mit unserem Beispielprojekt für MacOS fort und sehen, welche Ergebnisse beim Festlegen der Umgebungsvariablen <code>ZERO_AR_DATE</code> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> ZERO_AR_DATE=<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Wenn wir nun unsere ausführbaren Dateien und Bibliotheken kompilieren (das Makro <code>__DATE__</code> in den Quellen entfernen), erhalten wir: <br><br><pre> <code class="cpp hljs">b5dce09c593658ee348fd0f7fae22c94 helloA b5dce09c593658ee348fd0f7fae22c94 helloB <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibA.dir/hello_world.cpp.o <span class="hljs-number"><span class="hljs-number">0</span></span>a4a0de3df8cc7f053f2fcb6d8b75e6d CMakeFiles/HelloLibB.dir/hello_world.cpp.o <span class="hljs-number"><span class="hljs-number">9f</span></span>9a9af4bb3e220e7a22fb58d708e1e5 libHelloLibA.a <span class="hljs-number"><span class="hljs-number">9f</span></span>9a9af4bb3e220e7a22fb58d708e1e5 libHelloLibB.a</code> </pre> <br>  Alle Prüfsummen sind jetzt gleich.  <code>.a</code> die Dateikopfzeilen mit der Erweiterung <code>.a</code> : <br><br><pre> <code class="cpp hljs">&gt; otool -a libHelloLibA.a Archive : libHelloLibA.a <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">612</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">13036</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">28</span></span> &gt; otool -a libHelloLibB.a Archive : libHelloLibB.a <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">612</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">0100644</span></span> <span class="hljs-number"><span class="hljs-number">503</span></span>/<span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">13036</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> #<span class="hljs-number"><span class="hljs-number">1</span></span>/<span class="hljs-number"><span class="hljs-number">28</span></span></code> </pre> <br>  Wir können sehen, dass das <code>timestamp</code> des Bibliotheksheaders auf Null gesetzt wurde. <br><br>  <i>Wir sind reibungslos zum Ende des ersten Teils des Artikels gekommen.</i>  <i>Die Fortsetzung des Materials kann hier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gelesen werden</a> .</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467741/">https://habr.com/ru/post/de467741/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467729/index.html">Chips oder fahren? Einzigartige Kleinigkeiten in Smartphones</a></li>
<li><a href="../de467733/index.html">Als Entwickler kenne ich nie meinen eigenen Wert, weil es keinen gibt. Aber das ganze System ist so aufgebaut, als ob es so wäre</a></li>
<li><a href="../de467735/index.html">Erwachsene Posit Herausforderungen</a></li>
<li><a href="../de467737/index.html">Bot VS-Anwendungen: Vor- und Nachteile. Fall des Bot-Buchhalters</a></li>
<li><a href="../de467739/index.html">Ein Geschäft ohne Technologie. Geld, das dich verloren hat</a></li>
<li><a href="../de467743/index.html">SamsPcbGuide, Teil 11: Technologie - BGA-Gehäuse, Kunststoff und Raum</a></li>
<li><a href="../de467745/index.html">Cluster besser als die "Ellbogenmethode"</a></li>
<li><a href="../de467747/index.html">Psychologische Tests: Wie man von einem zertifizierten Psychologen zu einem Tester kommt</a></li>
<li><a href="../de467749/index.html">GCP: Analysieren des Google Cloud Platform Computing Stack</a></li>
<li><a href="../de467751/index.html">Wie funktioniert ein dezentraler Messenger in der Blockchain?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>