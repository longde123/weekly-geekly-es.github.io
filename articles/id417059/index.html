<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëé üçò ‚úäüèΩ Meningkatkan unduhan konten tanpa segel üëÜüèΩ ü•£ ü§∏üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengiriman konten yang cepat dan berkualitas tinggi kepada pengguna adalah tugas paling penting yang terus kami kerjakan saat bekerja pada aplikasi iF...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meningkatkan unduhan konten tanpa segel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/funcorp/blog/417059/"><img src="https://habrastorage.org/webt/0v/on/2o/0von2ovek2gt2hkj_-rqefiia54.jpeg"><br><br>  Pengiriman konten yang cepat dan berkualitas tinggi kepada pengguna adalah tugas paling penting yang terus kami kerjakan saat bekerja pada aplikasi iFunny.  Tidak adanya elemen tunggu bahkan dengan koneksi yang buruk - inilah yang ingin dilakukan oleh layanan apa pun untuk melihat konten media. <br><br>  Kami memiliki beberapa iterasi untuk bekerja dengan prefetch konten.  Di setiap versi utama baru, kami menemukan sesuatu yang baru dan menyaksikan cara kerjanya untuk pengguna.  Dalam iterasi berikutnya dari bekerja dengan prefetching, diputuskan untuk terlebih dahulu men-debug metrik yang mempengaruhi di stand lokal, dan hanya kemudian memberikan hasilnya kepada pengguna. <br><br>  Pada artikel ini saya akan berbicara tentang apa yang tampak seperti prefetching di iFunny sekarang dan bagaimana proses penelitian terotomatisasi untuk lebih lanjut menyetel pengaturannya. <br><a name="habracut"></a><br><h3>  Pengambilan standar </h3><br>  Di iOS 10, Apple memberikan kemampuan untuk menjalankan prefetching out of the box.  Untuk melakukan ini, kelas UICollectionView memiliki bidang: <br><br><pre><code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">nullable</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">UICollectionViewDataSourcePrefetching</span></span>&gt; prefetchDataSource; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">getter</span></span>=isPrefetchingEnabled) <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> prefetchingEnabled;</code> </pre> <br>  Untuk mengaktifkan prefetching asli, tetapkan saja bidang prefetchDataSource objek yang mengimplementasikan protokol UICollectionViewDatasourcePrefetching dan setel bidang kedua dalam YES. <br><br>  Untuk mengimplementasikan protokol prefetching, dua metode harus dijelaskan: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)collectionView:(<span class="hljs-built_in"><span class="hljs-built_in">UICollectionView</span></span> *)collectionView prefetchItemsAtIndexPaths:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *&gt; *)indexPaths; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)collectionView:(<span class="hljs-built_in"><span class="hljs-built_in">UICollectionView</span></span> *)collectionView cancelPrefetchingForItemsAtIndexPaths:(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *&gt; *)indexPaths;</code> </pre> <br>  Pada metode pertama, Anda dapat melakukan pekerjaan apa pun yang bermanfaat pada persiapan konten. <br><br>  Dalam kasus iFunny, tampilannya seperti ini: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *&gt; *urls = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableArray</span></span> new]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> *indexPath <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indexPaths) { <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>&lt;IFFeedItemProtocol&gt; *item = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.model itemAtIndex:indexPath.row]; <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *downloadURL = item.downloadURL; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (downloadURL) { [urls addObject:downloadURL]; } } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.downloadManager updateActiveURLs:urls]; [urls enumerateObjectsUsingBlock:^(<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> *_Nonnull url, <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> idx, <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> *_Nonnull stop) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.downloadManager downloadContentWithURL:url.absoluteString forView:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> withOptions:<span class="hljs-number"><span class="hljs-number">0</span></span>]; }];</code> </pre> <br>  Metode kedua adalah opsional, tetapi dalam kasus rekaman iFunny itu tidak dipanggil oleh sistem sama sekali. <br><br>  Prefetching berfungsi, tetapi kami hanya menyebut metode untuk konten mengikuti konten aktif. <br>  Secara umum, pekerjaan prefetching standar untuk UICollectionView sangat tergantung pada bagaimana tampilan koleksi diimplementasikan.  Selain itu, karena kita tidak tahu sama sekali penerapan prefetching standar, tidak mungkin menjamin operasi yang stabil.  Karena itu, kami menerapkan mekanisme prefetching kami, yang selalu berfungsi sesuai kebutuhan. <br><br><h3>  Algoritma prefetching kami </h3><br>  Sebelum mengembangkan algoritma pengambilan awal, kami menuliskan semua fitur umpan iFunny: <br><br><ol><li>  Umpan dapat terdiri dari berbagai jenis konten: gambar, video, aplikasi web, iklan asli. </li><li>  Rekaman itu berfungsi dengan pagination. </li><li>  Sebagian besar pengguna membalik umpan hanya maju. </li><li>  Di iFunny, 20% sesi pengguna terjadi melalui LTE. </li></ol><br>  Berdasarkan kondisi ini, kami telah memperoleh algoritma sederhana: <br><br><ol><li>  Ada 1 elemen aktif dalam rekaman itu, sisanya tidak aktif. </li><li>  Elemen aktif selalu perlu mengunduh konten hingga akhir. </li><li>  Setiap item konten dalam umpan memiliki bobotnya sendiri. </li><li>  Pada koneksi Internet saat ini, Anda dapat memuat item dalam jumlah N. </li><li>  Setiap kali Anda menggulir rekaman, kami mengubah elemen aktif dan menghitung elemen mana yang dimuat, dan membatalkan sisa pemuatan. </li></ol><br>  Arsitektur dalam kode algoritma ini berisi beberapa kelas dasar dan protokol: <br><br><ul><li>  IFPrefetchedCollectionProtocol </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFPrefetchedCollectionProtocol</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSUInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prefetchItemsCount</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFFeedItemProtocol</span></span></span><span class="hljs-class">&gt; *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">itemAtIndex</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSInteger</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Protokol ini diperlukan untuk mendapatkan parameter koleksi dan konten di objek kelas: <br><br><ul><li>  IFContentPrefetcher </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFContentPrefetcher</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">weak</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFPrefetchedCollectionProtocol</span></span></span><span class="hljs-class">&gt; *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">collection</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">assign</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">activeIndex</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Kelas mengimplementasikan logika algoritma untuk pengambilan konten awal: <br><br><ul><li>  IFPrefetchOperation </li></ul><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFPrefetchOperation</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSUInteger</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cost</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fetchMinumumBuffer</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fetchEntireBuffer</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pause</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancel</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BOOL</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isEqualOperation</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IFPrefetchOperation</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br>  Ini adalah kelas dasar dari operasi atom, yang menggambarkan pekerjaan yang berguna untuk mengambil konten tertentu dan menunjukkan parameternya - berat. <br><br>  Untuk menjalankan algoritme, kami menggambarkan dua operasi: <br><br><ol><li>  Gambar.  Ini memiliki berat 1. Selalu terisi penuh; </li><li>  Video  Ini memiliki berat 2. Memuat sepenuhnya hanya saat aktif.  Dalam keadaan tidak aktif, 200 KB pertama dimuat. </li></ol><br>  Sebagai metrik untuk mengevaluasi operasi algoritma, kami memilih jumlah klik dari elemen UI loader per 1000 elemen konten yang dilihat. <br><br>  Pada prefetching standar metrik ini kami memiliki sekitar 30 tayangan / 1000 elemen.  Setelah pengenalan algoritma baru, metrik ini turun menjadi 25 tayangan / 1000 elemen. <br><br>  Dengan demikian, jumlah tayangan loader menurun sebesar 20% dan jumlah total konten yang dilihat oleh pengguna sedikit meningkat. <br><br>  Kemudian kami melanjutkan ke pemilihan parameter optimal untuk Featured - rekaman paling populer di iFunny. <br><br><h3>  Pemilihan parameter untuk prefetching </h3><br>  Algoritma prefetching yang dikembangkan memiliki parameter input: <br><br><ol><li>  Total biaya pengunduhan. </li><li>  Biaya pemuatan setiap item. </li></ol><br>  Kami akan terus mengukur jumlah loader. <br><br>  Sebagai alat bantu untuk menyederhanakan pengumpulan data, kami akan menggunakan: <br><br><ol><li>  Tes abu-abu dengan satu set kerangka kerja KIF, OHHTTPStubs. </li><li>  sh-scripts dan xcodebuild untuk menjalankan tes dengan parameter berbeda. </li><li>  Profil jaringan 3G tersedia di pengaturan Developer - Network Link Conditioner. </li></ol><br>  Mari kita lihat bagaimana masing-masing alat ini membantu kita. <br><br><h4>  Tes </h4><br>  Untuk meniru bagaimana pengguna melihat konten, kami memutuskan untuk menggunakan kerangka kerja KIF, yang akrab bagi pengembang iOS di Objective-C. <br><br>  KIF bekerja sangat baik untuk Objective-C dan Swift, setelah beberapa manipulasi mudah dijelaskan dalam dokumentasi KIF: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/kif-framework/KIF#use-with-swift</a> <br><br>  Untuk menguji rekaman itu, kami memilih Objective-C, termasuk untuk dapat mengganti metode yang kami butuhkan di layanan analitik. <br><br>  Mari kita lihat kode tes sederhana, yang kami dapatkan: <br><br><pre> <code class="objectivec hljs"> - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setUp { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> setUp]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> clearCache]; [[<span class="hljs-built_in"><span class="hljs-built_in">NSURLCache</span></span> sharedURLCache] removeAllCachedResponses]; [OHHTTPStubs stubRequestsPassingTest:^<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span> *_Nonnull request) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [request.URL.absoluteString isEqualToString:<span class="hljs-string"><span class="hljs-string">@"http://fun.co/rp/?feed=featured&amp;limit=30"</span></span>]; } withStubResponse:^OHHTTPStubsResponse *_Nonnull(<span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span> *_Nonnull request) { <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *path = OHPathForFile(<span class="hljs-string"><span class="hljs-string">@"featured.json"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.classForCoder); OHHTTPStubsResponse *response = [[OHHTTPStubsResponse alloc] initWithFileAtPath:path statusCode:<span class="hljs-number"><span class="hljs-number">200</span></span> headers:@{ <span class="hljs-string"><span class="hljs-string">@"Content-Type"</span></span> : <span class="hljs-string"><span class="hljs-string">@"application/json"</span></span> }]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; }]; }</code> </pre> <br>  Dalam metode pengaturan pengujian, kita harus menghapus cache sehingga pada setiap peluncuran konten dimuat dari jaringan dan benar-benar menghapus folder cache dalam aplikasi. <br><br>  Untuk memastikan kestabilan data di masing-masing tes, kami menggunakan pustaka OHHTTPStubs, yang memudahkan untuk mengganti respons terhadap permintaan jaringan dalam beberapa langkah sederhana: <br><br><ol><li>  Tentukan parameter kueri.  Bagi kami, ini adalah URL permintaan umpan Unggulan untuk API - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://fun.co/rp/?feed=featured&amp;limit=30</a> </li><li>  Catat jawaban yang diperlukan dan simpan ke file, lampirkan ke target dengan tes. </li><li>  Tentukan opsi respons.  Dalam kode di atas, ini adalah header tipe konten dan kode respons. </li><li>  Lihatlah instruksi untuk OHHTTPStubs. </li></ol><br>  Anda dapat membaca lebih lanjut tentang bekerja dengan OHHTTPStubs dalam dokumentasi: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://cocoadocs.org/docsets/OHHTTPSPSs/</a> <br><br>  Tes itu sendiri terlihat seperti ini: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)testFeed { KIFUIViewTestActor *feed = [viewTester usingLabel:<span class="hljs-string"><span class="hljs-string">@"ScrolledFeed"</span></span>]; [feed waitForView]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setupCustomPrefetchParams]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>; i++) { [feed waitForCellInCollectionViewAtIndexPath:[<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span> indexPathForRow:i inSection:<span class="hljs-number"><span class="hljs-number">0</span></span>]]; [viewTester waitForTimeInterval:<span class="hljs-number"><span class="hljs-number">1.0</span></span>f]; } [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> appendStatisticLine]; }</code> </pre> <br>  Dengan menggunakan KIF, kami mendapat umpan lalu menggulir melalui 1.000 elemen konten dengan menunggu 1 detik. <br><br>  Metode setupCustomPrefetchParams akan dibahas sedikit kemudian. <br><br>  Untuk menentukan jumlah loader yang ditampilkan, kami akan menggunakan runtime Objective-C dan mengganti metode dari layanan analitik dengan metode pengujian: <br><br><pre> <code class="objectivec hljs">+ (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)load { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> swizzleSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(trackEventLoaderViewedVideo:) ofClass:[IFAnalyticService <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]]; } + (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)swizzleSelector:(SEL)originalSelector ofClass:(Class) <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { Method originalMethod = class_getInstanceMethod(<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, originalSelector); Method swizzledMethod = class_getInstanceMethod([<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>], originalSelector); <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> didAddMethod = class_addMethod(<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (didAddMethod) { class_replaceMethod(<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, originalSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { method_exchangeImplementations(originalMethod, swizzledMethod); } } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)trackEventLoaderViewedVideo : (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)onVideo { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onVideo) { [IFTestFeed trackLoaderOnVideo]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [IFTestFeed trackLoaderOnImage]; } }</code> </pre> <br>  Sekarang kami memiliki tes otomatis di mana aplikasi selalu menerima konten yang sama dan menggulir jumlah elemen yang sama.  Dan menurut hasilnya, ia menulis baris dengan statistik eksekusi ke log. <br><br>  Karena koneksi Internet terutama mempengaruhi pengunduhan konten, pengujian dengan satu set parameter perlu diulang lebih dari satu kali. <br><br><h4>  Otomatisasi startup </h4><br>  Untuk mengotomatisasi dan membuat parameter pengujian, kami memutuskan untuk menggunakan peluncuran melalui xcodebuild dengan transfer parameter yang diperlukan. <br><br>  Untuk meneruskan parameter ke kode, kita perlu menulis nama argumen di pengaturan target untuk tes di Prepocessor Macros: <br><br><img src="https://habrastorage.org/webt/bu/hc/6z/buhc6zn1ff3hj_2m6bdccsg45ym.png"><br><br>  Untuk mengakses parameter dari kode Objective-C, dua makro harus dideklarasikan: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define STRINGIZE(x) #x #define BUILD_PARAM(x) STRINGIZE(x)</span></span></code> </pre> <br>  Sekarang ketika mulai dari terminal menggunakan xcodebuild: <br><br><pre> <code class="bash hljs">xcodebuild <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -workspace iFunny.xcworkspace -scheme iFunnyUITests -destination <span class="hljs-string"><span class="hljs-string">'platform=iOS,id=DEVICE_ID'</span></span> MAX_PREFETCH_COST=<span class="hljs-string"><span class="hljs-string">"5"</span></span> VIDEO_COST=<span class="hljs-string"><span class="hljs-string">"2"</span></span> IMAGE_COST=<span class="hljs-string"><span class="hljs-string">"2"</span></span></code> </pre> <br>  Dalam kode Anda dapat membaca parameter yang dikirimkan: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setupCustomPrefetchParams { <span class="hljs-built_in"><span class="hljs-built_in">NSNumberFormatter</span></span> *formatter = [[<span class="hljs-built_in"><span class="hljs-built_in">NSNumberFormatter</span></span> alloc] init]; formatter.numberStyle = <span class="hljs-built_in"><span class="hljs-built_in">NSNumberFormatterNoStyle</span></span>; [IFAppController instance].prefetchParams.goodNetMaxCost = [formatter numberFromString:@BUILD_PARAM(MAX_PREFETCH_COST)]; [IFAppController instance].prefetchParams.videoCost = [formatter numberFromString:@BUILD_PARAM(VIDEO_COST)]; [IFAppController instance].prefetchParams.imageCost = [formatter numberFromString:@BUILD_PARAM(IMAGE_COST)]; }</code> </pre> <br>  Sekarang semuanya siap untuk menjalankan tes ini secara offline menggunakan skrip shell. <br><br>  Menjalankan xcodebuild dengan serangkaian parameter 10 kali berturut-turut: <br><br><pre> <code class="bash hljs">max=10 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `seq 1 <span class="hljs-variable"><span class="hljs-variable">$max</span></span>` <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> xcodebuild <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -workspace iFunny.xcworkspace -scheme iFunnyUITests -destination <span class="hljs-string"><span class="hljs-string">'platform=iOS,id=DEVICE_ID'</span></span> MAX_PREFETCH_COST=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$1</span></span></span><span class="hljs-string">"</span></span> VIDEO_COST=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$2</span></span></span><span class="hljs-string">"</span></span> IMAGE_COST=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$3</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre> <br>  Kami juga membuat skrip dengan peluncuran berbagai set parameter.  Semua pengujian berlangsung beberapa hari.  Data yang diperoleh dirangkum dalam satu tabel, dan kami membandingkannya dengan versi kerja saat ini. <br><br>  Alhasil, prefetching paling sederhana dari lima elemen ternyata menjadi yang terbaik untuk pita Featured iFunny, tanpa memperhatikan format konten (video atau gambar). <br><br><h3>  Menurut hasilnya </h3><br>  Artikel ini menjelaskan pendekatan yang akan memungkinkan Anda untuk menjelajahi dan memantau setiap bagian penting dari aplikasi, tanpa mengubah kode proyek utama. <br><br>  Inilah yang akan membantu untuk melakukan studi tersebut: <br><br><ul><li>  Penggunaan kerangka kerja uji untuk tindakan monoton. </li><li>  Otomatisasi melalui xcodebuild untuk membuat parameter startup. </li><li>  Runtime Objective-C untuk mengubah logika yang diperlukan, jika memungkinkan. </li></ul><br>  Berdasarkan pendekatan ini untuk menguji aplikasi, kami mulai menambahkan pemantauan modul penting di stand lokal dan telah menyiapkan beberapa tes yang kami jalankan secara berkala untuk memeriksa kualitas aplikasi. <br><br>  PS: Menurut hasil pengujian kami, pengaturan prefetching baru relatif terhadap opsi produksi menang sekitar 8%, pada kenyataannya, mereka menerima penurunan tampilan loader sebesar 3%, yang berarti bahwa kami mulai mengirimkan senyum ke iFunny 3% lebih sering :) <br><br>  PPS: Kami tidak akan berhenti di situ, kami akan terus meningkatkan prefetch konten lebih lanjut. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417059/">https://habr.com/ru/post/id417059/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417047/index.html">Python Creator: Saya lelah, saya akan pergi</a></li>
<li><a href="../id417049/index.html">Standar pendahuluan untuk aplikasi seluler dengan 87 persyaratan untuk fungsi mereka telah muncul di Federasi Rusia</a></li>
<li><a href="../id417051/index.html">Apple memperbarui MacBook Pro</a></li>
<li><a href="../id417053/index.html">Pencetakan matriks, cetakan</a></li>
<li><a href="../id417055/index.html">SAP Leonardo TV Show - Langsung di Internet of Things, Blockchain, Pembelajaran Mesin dan Big Data</a></li>
<li><a href="../id417063/index.html">Jaringan saraf untuk yang terkecil</a></li>
<li><a href="../id417065/index.html">Splunk How-to, atau How dan Where to Learn Splunk</a></li>
<li><a href="../id417069/index.html">Sekali lagi tentang OpenSSL</a></li>
<li><a href="../id417071/index.html">Jumat PHP: Webinar Skillbox Gratis</a></li>
<li><a href="../id417073/index.html">Hari Pengembang Seluler Uber</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>