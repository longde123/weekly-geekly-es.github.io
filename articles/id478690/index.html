<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ¿â€ğŸ“ ğŸ¦— ğŸ“  Perakitan dinamis dan penyebaran gambar Docker dengan werf menggunakan contoh situs dokumentasi versi ğŸ•´ğŸ¿ ğŸ†• ğŸ—‚ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami telah berbicara tentang alat GitOps werf kami lebih dari sekali , tetapi kali ini kami ingin berbagi pengalaman membangun situs dengan dokumentas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Perakitan dinamis dan penyebaran gambar Docker dengan werf menggunakan contoh situs dokumentasi versi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/478690/">  Kami telah berbicara tentang alat GitOps werf kami lebih <a href="https://github.com/flant/werf">dari sekali</a> , tetapi kali ini kami ingin berbagi pengalaman membangun situs dengan dokumentasi proyek - <a href="https://werf.io/">werf.io</a> (versi Rusia-nya adalah <a href="https://ru.werf.io/">ru.werf.io</a> ).  Ini adalah situs statis biasa, tetapi rakitannya menarik karena dibangun menggunakan sejumlah artefak yang dinamis. <br><br><img src="https://habrastorage.org/webt/m_/ox/od/m_oxod8ckyfsipscttspcn5opd8.png"><br><br>  Pergilah ke nuansa struktur situs: menghasilkan menu umum untuk semua versi, halaman dengan informasi tentang rilis, dll.  - kami tidak akan.  Sebagai gantinya, kami fokus pada masalah dan fitur perakitan dinamis dan sedikit pada proses CI / CD yang menyertainya. <a name="habracut"></a><br><br><h2>  Pendahuluan: bagaimana situs diatur </h2><br>  Untuk mulai dengan, dokumentasi werf disimpan bersama dengan kodenya.  Ini membuat persyaratan pengembangan tertentu yang umumnya melampaui ruang lingkup artikel ini, tetapi setidaknya kita dapat mengatakan bahwa: <br><br><ul><li>  Fungsi werf baru tidak boleh dirilis tanpa memperbarui dokumentasi dan, sebaliknya, setiap perubahan dalam dokumentasi menyiratkan rilis versi werf baru; </li><li>  Proyek ini memiliki pengembangan yang agak intensif: versi baru mungkin keluar beberapa kali sehari; </li><li>  Setiap penyebaran manual situs dengan versi baru dari dokumentasi setidaknya membosankan; </li><li>  Proyek ini mengadopsi pendekatan <a href="https://ru.werf.io/releases.html">versi</a> semantik, dengan 5 saluran stabilitas.  Proses rilis melibatkan bagian berurutan versi melalui saluran untuk meningkatkan stabilitas: dari alpha ke rock-solid; </li><li>  Situs ini memiliki versi bahasa Rusia, yang "hidup dan berkembang" (yaitu, konten yang diperbarui) secara paralel dengan versi utama (yaitu bahasa Inggris). </li></ul><br>  Untuk menyembunyikan dari semua pengguna "dapur dalam" ini, menawarkan apa yang "hanya berfungsi", kami membuat alat <b>instalasi dan pembaruan werf yang terpisah</b> - ini adalah <a href="https://github.com/flant/multiwerf">multiwerf</a> .  Cukup untuk menunjukkan nomor rilis dan saluran stabilitas yang siap Anda gunakan, dan multiwerf akan memeriksa apakah ada versi baru pada saluran dan mengunduhnya jika perlu. <br><br>  Versi werf terbaru di setiap saluran tersedia di menu pilihan versi di situs.  Secara default, versi saluran paling stabil untuk rilis terbaru terbuka di <a href="https://werf.io/documentation/">werf.io/documentation</a> - ini juga diindeks oleh mesin pencari.  Dokumentasi untuk saluran tersedia di masing-masing alamat (misalnya, <a href="https://werf.io/v1.0-beta/documentation/">werf.io/v1.0-beta/documentation</a> untuk rilis beta 1.0). <br><br>  Total, situs ini memiliki versi berikut: <br><br><ol><li>  root (terbuka secara default) </li><li>  untuk setiap saluran pembaruan aktif dari setiap rilis (misalnya, <a href="https://werf.io/v1.0-beta/">werf.io/v1.0-beta</a> ). </li></ol><br>  Untuk menghasilkan versi tertentu dari situs dalam kasus umum, cukup mengkompilasinya menggunakan alat <a href="https://jekyllrb.com/">Jekyll</a> dengan menjalankan perintah yang sesuai ( <code>jekyll build</code> ) di direktori <code>/docs</code> dari repositori werf, setelah beralih ke tag Git dari versi yang diperlukan. <br><br>  Tinggal menambahkan saja: <br><br><ul><li>  utilitas itu sendiri (werf) digunakan untuk perakitan; </li><li>  Proses CI / CD didasarkan pada GitLab CI; </li><li>  dan semua ini, tentu saja, berfungsi di Kubernetes. </li></ul><br><h2>  Tugasnya </h2><br>  Sekarang kami merumuskan tugas yang memperhitungkan semua spesifik yang dijelaskan: <br><br><ol><li>  Setelah mengubah versi werf pada saluran pembaruan apa pun, <b>dokumentasi di situs harus diperbarui secara otomatis</b> . </li><li>  Untuk pengembangan, Anda harus dapat <b>melihat pratinjau versi awal situs</b> . </li></ol><br>  Rekompilasi situs harus dilakukan setelah mengubah versi pada saluran apa pun dari tag Git yang sesuai, tetapi dalam proses membangun gambar kita akan mendapatkan fitur berikut: <br><br><ul><li>  Karena daftar versi di saluran berubah, Anda hanya perlu memasang kembali dokumentasi untuk saluran di mana versi telah berubah.  Lagi pula, merakit kembali semuanya tidak terlalu indah. </li><li>  Serangkaian saluran untuk rilis dapat bervariasi.  Di beberapa titik waktu, misalnya, versi pada saluran mungkin tidak lebih stabil daripada rilis awal akses 1.1, tetapi seiring waktu mereka akan muncul - jangan mengubah perakitan dengan tangan dalam kasus ini? </li></ul><br>  Ternyata <b>perakitan tergantung pada perubahan data eksternal</b> . <br><br><h2>  Implementasi </h2><br><h3>  Pilihan pendekatan </h3><br>  Atau, Anda dapat menjalankan setiap versi yang diperlukan dengan pod terpisah di Kubernetes.  Opsi ini menyiratkan jumlah objek yang lebih besar di cluster, yang akan tumbuh dengan peningkatan jumlah rilis werf yang stabil.  Dan ini pada gilirannya menyiratkan layanan yang lebih kompleks: setiap versi memiliki server HTTP sendiri, dan dengan beban kecil.  Tentu saja, ini memerlukan biaya yang lebih tinggi untuk sumber daya. <br><br>  Kami menyusuri jalur <b>perakitan semua versi yang diperlukan dalam satu gambar</b> .  Statika yang dikompilasi dari semua versi situs berada dalam wadah dengan NGINX, dan lalu lintas ke Penyebaran yang sesuai datang melalui NGINX Ingress.  Struktur sederhana - aplikasi tanpa kewarganegaraan - membuatnya mudah untuk skala Penempatan (tergantung pada beban) menggunakan Kubernetes itu sendiri. <br><br>  Untuk lebih tepatnya, kami mengumpulkan dua gambar: satu untuk sirkuit produksi, yang lain untuk sirkuit dev.  Gambar tambahan digunakan (diluncurkan) hanya pada sirkuit dev bersama-sama dengan yang utama dan berisi versi situs dari komit ulasan, dan routing di antara mereka dilakukan menggunakan sumber daya Ingress. <br><br><h3>  werf vs git clone dan artefak </h3><br>  Seperti yang telah disebutkan, untuk menghasilkan statika situs untuk versi dokumentasi tertentu, Anda perlu membangun dengan beralih ke tag repositori yang sesuai.  Kita juga bisa melakukan ini dengan mengkloning repositori setiap kali selama perakitan, memilih tag yang sesuai dari daftar.  Namun, ini adalah operasi yang menghabiskan banyak sumber daya dan, terlebih lagi, membutuhkan penulisan instruksi non-sepele ... minus serius lainnya - dengan pendekatan ini tidak ada cara untuk cache sesuatu selama perakitan. <br><br>  Di sini utilitas werf datang ke bantuan kami, yang mengimplementasikan <b>caching cerdas</b> dan memungkinkan penggunaan <a href="https://ru.werf.io/documentation/configuration/stapel_image/git_directive.html"><b>repositori eksternal</b></a> .  Menggunakan werf untuk menambahkan kode dari repositori akan secara signifikan mempercepat pembangunan, seperti  werf pada dasarnya melakukan repositori sekali, dan kemudian <i>hanya</i> <code>fetch</code> jika perlu.  Selain itu, ketika menambahkan data dari repositori, kita hanya dapat memilih direktori yang diperlukan (dalam kasus kami, ini adalah direktori <code>docs</code> ), yang secara signifikan akan mengurangi jumlah data yang ditambahkan. <br><br>  Karena Jekyll adalah alat yang dirancang untuk mengkompilasi statika dan tidak diperlukan dalam gambar akhir, akan logis untuk mengkompilasi dalam <a href="https://ru.werf.io/documentation/configuration/stapel_artifact.html">artefak werf</a> , dan <b>hanya mengimpor hasil kompilasi</b> ke dalam gambar akhir. <br><br><h3>  Menulis werf.yaml </h3><br>  Jadi, kami memutuskan bahwa kami akan mengkompilasi setiap versi dalam artefak werf yang terpisah.  Namun, kami <b>tidak tahu berapa banyak artefak ini akan terjadi selama perakitan</b> , oleh karena itu kami tidak dapat menulis konfigurasi perakitan tetap (secara tegas, kami masih bisa, tetapi itu tidak akan sepenuhnya efektif). <br><br>  werf memungkinkan Anda untuk menggunakan <a href="https://ru.werf.io/documentation/configuration/introduction.html">templat Go</a> dalam file konfigurasi Anda ( <code>werf.yaml</code> ), dan ini memungkinkan untuk <b>membuat konfigurasi "on the fly"</b> tergantung pada data eksternal (apa yang Anda butuhkan!).  Data eksternal dalam kasus kami adalah informasi tentang versi dan rilis, atas dasar di mana kami mengumpulkan jumlah artefak yang diperlukan dan mendapatkan dua gambar sebagai hasilnya: <code>werf-doc</code> dan <code>werf-dev</code> untuk meluncurkan di jalur yang berbeda. <br><br>  Data eksternal dilewatkan melalui variabel lingkungan.  Berikut komposisinya: <br><br><ul><li>  <code>RELEASES</code> - sebuah baris dengan daftar rilis dan versi terkini dari werf, dalam bentuk daftar, dipisahkan oleh spasi, dalam format <code>&lt;_&gt;%&lt;_&gt;</code> .  Contoh: <code>1.0%v1.0.4-beta.20</code> </li><li>  <code>CHANNELS</code> - baris dengan daftar saluran dan versi werf saat ini, dalam bentuk daftar dengan ruang nilai dalam format <code>&lt;&gt;%&lt;_&gt;</code> .  Contoh: <code>1.0-beta%v1.0.4-beta.20 1.0-alpha%v1.0.5-alpha.22</code> </li><li>  <code>ROOT_VERSION</code> - Versi rilis werf untuk ditampilkan secara default di situs (tidak selalu diperlukan untuk menampilkan dokumentasi untuk nomor rilis tertinggi).  Contoh: <code>v1.0.4-beta.20</code> </li><li>  <code>REVIEW_SHA</code> - hash dari ulasan komit yang darinya Anda perlu mengumpulkan versi untuk loop tes. </li></ul><br>  Variabel-variabel ini akan diisi dalam pipa GitLab CI, dan bagaimana tepatnya dijelaskan di bawah ini. <br><br>  Pertama-tama, untuk kenyamanan, kami mendefinisikan variabel Go-templat di <code>werf.yaml</code> menetapkan nilai dari variabel lingkungan: <br><br><pre> <code class="go hljs">{{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfVersions"</span></span> (cat (env <span class="hljs-string"><span class="hljs-string">"CHANNELS"</span></span>) (env <span class="hljs-string"><span class="hljs-string">"RELEASES"</span></span>) | splitList <span class="hljs-string"><span class="hljs-string">" "</span></span>) }} {{ $Root := . }} {{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfRootVersion"</span></span> (env <span class="hljs-string"><span class="hljs-string">"ROOT_VERSION"</span></span>) }} {{ $_ := set . <span class="hljs-string"><span class="hljs-string">"WerfReviewCommit"</span></span> (env <span class="hljs-string"><span class="hljs-string">"REVIEW_SHA"</span></span>) }}</code> </pre> <br>  Deskripsi artefak untuk mengkompilasi statika versi situs umumnya sama untuk semua kasus yang kita butuhkan (termasuk generasi versi root, serta versi untuk rangkaian dev).  Oleh karena itu, kami akan menempatkannya di blok terpisah menggunakan fungsi <code>define</code> - untuk digunakan kembali selanjutnya dengan <code>include</code> .  Kami akan meneruskan argumen berikut ke templat: <br><br><ul><li>  <code>Version</code> - versi yang dihasilkan (nama tag); </li><li>  <code>Channel</code> - nama saluran pembaruan yang menghasilkan artefak; </li><li>  <code>Commit</code> - komit hash jika artifak dihasilkan untuk ulasan komit; </li><li>  konteks. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Deskripsi Template Artefak</b> <div class="spoiler_text"><pre> <code class="go hljs">{{- define <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> -}} {{- $Root := index . <span class="hljs-string"><span class="hljs-string">"Root"</span></span> -}} artifact: doc-{{ .Channel }} from: jekyll/builder:<span class="hljs-number"><span class="hljs-number">3</span></span> mount: - from: build_dir to: /usr/local/bundle ansible: install: - shell: | export PATH=/usr/jekyll/bin/:$PATH - name: <span class="hljs-string"><span class="hljs-string">"Install Dependencies"</span></span> shell: bundle install args: executable: /bin/bash chdir: /app/docs beforeSetup: {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .Commit }} - shell: echo <span class="hljs-string"><span class="hljs-string">"Review SHA - {{ .Commit }}."</span></span> {{- end }} {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> eq .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span> }} - name: <span class="hljs-string"><span class="hljs-string">"releases.yml HASH: {{ $Root.Files.Get "</span></span>releases.yml<span class="hljs-string"><span class="hljs-string">" | sha256sum }}"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>: content: | {{ $Root.Files.Get <span class="hljs-string"><span class="hljs-string">"releases.yml"</span></span> | indent <span class="hljs-number"><span class="hljs-number">8</span></span> }} dest: /app/docs/_data/releases.yml {{- <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> }} - file: path: /app/docs/_data/releases.yml state: touch {{- end }} - file: path: <span class="hljs-string"><span class="hljs-string">"{{`{{ item }}`}}"</span></span> state: directory mode: <span class="hljs-number"><span class="hljs-number">0777</span></span> with_items: - /app/main_site/ - /app/ru_site/ - file: dest: /app/docs/pages_ru/cli state: link src: /app/docs/pages/cli - shell: | echo -e <span class="hljs-string"><span class="hljs-string">"werfVersion: {{ .Version }}\nwerfChannel: {{ .Channel }}"</span></span> &gt; /tmp/_config_additional.yml export PATH=/usr/jekyll/bin/:$PATH {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> and (ne .Version <span class="hljs-string"><span class="hljs-string">"review"</span></span>) (ne .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span>) }} {{- $_ := set . <span class="hljs-string"><span class="hljs-string">"BaseURL"</span></span> ( printf <span class="hljs-string"><span class="hljs-string">"v%s"</span></span> .Channel ) }} {{- <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ne .Channel <span class="hljs-string"><span class="hljs-string">"root"</span></span> }} {{- $_ := set . <span class="hljs-string"><span class="hljs-string">"BaseURL"</span></span> .Channel }} {{- end }} jekyll build -s /app/docs -d /app/_main_site/{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .BaseURL }} --baseurl /{{ .BaseURL }}{{ end }} --config /app/docs/_config.yml,/tmp/_config_additional.yml jekyll build -s /app/docs -d /app/_ru_site/{{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .BaseURL }} --baseurl /{{ .BaseURL }}{{ end }} --config /app/docs/_config.yml,/app/docs/_config_ru.yml,/tmp/_config_additional.yml args: executable: /bin/bash chdir: /app/docs git: - url: https:<span class="hljs-comment"><span class="hljs-comment">//github.com/flant/werf.git to: /app/ owner: jekyll group: jekyll {{- if .Commit }} commit: {{ .Commit }} {{- else }} tag: {{ .Version }} {{- end }} stageDependencies: install: ['docs/Gemfile','docs/Gemfile.lock'] beforeSetup: '**/*' includePaths: 'docs' excludePaths: '**/*.sh' {{- end }}</span></span></code> </pre> </div></div><br>  Nama artefak harus unik.  Kita dapat mencapai ini, misalnya, dengan menambahkan nama saluran (nilai variabel <code>.Channel</code> ) sebagai akhiran untuk nama artifact: <code>artifact: doc-{{ .Channel }}</code> .  Tetapi Anda perlu memahami bahwa saat mengimpor dari artefak, Anda harus merujuk nama yang sama. <br><br>  Saat menggambarkan artefak, fitur werf seperti <a href="https://ru.werf.io/documentation/configuration/stapel_image/mount_directive.html">mount digunakan</a> .  Pemasangan dengan direktori layanan <code>build_dir</code> memungkinkan Anda untuk menyimpan cache Jekyll di antara mulai pipa, yang <b>sangat mempercepat pembangunan kembali</b> . <br><br>  Anda mungkin juga telah memperhatikan penggunaan file <code>releases.yml</code> - ini adalah file YAML dengan data rilis yang diminta dari <a href="https://github.com/flant/werf">github.com</a> (artefak yang diperoleh dengan mengeksekusi pipa).  Hal ini diperlukan saat menyusun situs, tetapi dalam konteks artikel kami tertarik pada fakta bahwa <b>hanya satu artefak</b> , <b>artefak</b> versi situs root <b>,</b> yang tergantung pada kondisinya (pada artefak lain tidak diperlukan). <br><br>  Ini diimplementasikan menggunakan operator kondisional untuk templat <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code> go dan <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code>  <code>{{ $Root.Files.Get "releases.yml" | sha256sum }}</code> di panggung <a href="https://ru.werf.io/documentation/reference/stages_and_images.html">panggung</a> .  Ini berfungsi sebagai berikut: ketika merakit artefak untuk versi root (variabel <code>.Channel</code> adalah <code>root</code> ), hash dari file <code>releases.yml</code> mempengaruhi tanda tangan dari seluruh tahapan, karena itu adalah komponen dari nama pekerjaan yang dimungkinkan (parameter <code>name</code> ).  Dengan demikian, ketika mengubah <b>isi</b> file <code>releases.yml</code> , artefak yang sesuai akan dibangun kembali. <br><br>  Perhatikan juga untuk bekerja dengan repositori eksternal.  Hanya direktori <code>/docs</code> yang ditambahkan ke gambar artefak dari <a href="">repositori werf</a> , dan tergantung pada parameter yang dikirimkan, data dari tag yang diperlukan atau komit peninjauan ditambahkan segera. <br><br>  Untuk menggunakan templat artefak untuk menghasilkan deskripsi artefak dari versi saluran dan rilis yang ditransfer, kami mengatur loop pada variabel <code>.WerfVersions</code> di <code>werf.yaml</code> : <br><br><pre> <code class="go hljs">{{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> $VersionsDict._1 <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> $VersionsDict._0 <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} --- {{ end -}}</code> </pre> <br>  Karena  loop akan menghasilkan beberapa artefak (kami harap demikian), perlu untuk mempertimbangkan pemisah di antara mereka - urutan <code>---</code> (untuk informasi lebih lanjut tentang sintaks dari file konfigurasi, lihat <a href="https://ru.werf.io/documentation/configuration/introduction.html">dokumentasi</a> ).  Seperti yang ditentukan sebelumnya, saat Anda memanggil templat dalam satu lingkaran, kami meneruskan parameter versi, URL, dan konteks root. <br><br>  Demikian pula, tetapi sudah tanpa loop, kami memanggil template artefak untuk "kasus khusus": untuk versi root, serta versi dari komit ulasan: <br><br><pre> <code class="go hljs">{{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> .WerfRootVersion <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> <span class="hljs-string"><span class="hljs-string">"root"</span></span> <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} --- {{- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> .WerfReviewCommit }} {{ dict <span class="hljs-string"><span class="hljs-string">"Version"</span></span> <span class="hljs-string"><span class="hljs-string">"review"</span></span> <span class="hljs-string"><span class="hljs-string">"Channel"</span></span> <span class="hljs-string"><span class="hljs-string">"review"</span></span> <span class="hljs-string"><span class="hljs-string">"Commit"</span></span> .WerfReviewCommit <span class="hljs-string"><span class="hljs-string">"Root"</span></span> $Root | include <span class="hljs-string"><span class="hljs-string">"doc_artifact"</span></span> }} {{- end }}</code> </pre> <br>  Harap perhatikan bahwa artefak untuk komit ulasan hanya akan dikumpulkan jika variabel <code>.WerfReviewCommit</code> . <br><br>  Artefak sudah siap - saatnya untuk mengimpor! <br><br>  Gambar terakhir, yang dirancang untuk dijalankan di Kubernetes, adalah NGINX biasa, di mana file konfigurasi server <code>nginx.conf</code> dan statika dari artefak ditambahkan.  Selain artefak versi root situs, kita perlu mengulangi loop pada variabel <code>.WerfVersions</code> untuk mengimpor artefak dari versi saluran dan rilis + perhatikan aturan penamaan artefak yang kita adopsi sebelumnya.  Karena setiap artefak menyimpan versi situs untuk dua bahasa, kami mengimpornya ke tempat-tempat yang disediakan oleh konfigurasi. <br><br><div class="spoiler">  <b class="spoiler_title">Deskripsi gambar werf-doc akhir</b> <div class="spoiler_text"><pre> <code class="go hljs">image: werf-doc from: nginx:stable-alpine ansible: setup: - name: <span class="hljs-string"><span class="hljs-string">"Setup /etc/nginx/nginx.conf"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>: content: | {{ .Files.Get <span class="hljs-string"><span class="hljs-string">".werf/nginx.conf"</span></span> | indent <span class="hljs-number"><span class="hljs-number">8</span></span> }} dest: /etc/nginx/nginx.conf - file: path: <span class="hljs-string"><span class="hljs-string">"{{`{{ item }}`}}"</span></span> state: directory mode: <span class="hljs-number"><span class="hljs-number">0777</span></span> with_items: - /app/main_site/assets - /app/ru_site/assets <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>: - artifact: doc-root add: /app/_main_site to: /app/main_site before: setup - artifact: doc-root add: /app/_ru_site to: /app/ru_site before: setup {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ $Channel := $VersionsDict._0 -}} {{ $Version := $VersionsDict._1 -}} - artifact: doc-{{ $Channel }} add: /app/_main_site to: /app/main_site/v{{ $Channel }} before: setup {{ end -}} {{ <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> .WerfVersions -}} {{ $VersionsDict := splitn <span class="hljs-string"><span class="hljs-string">"%"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> . -}} {{ $Channel := $VersionsDict._0 -}} {{ $Version := $VersionsDict._1 -}} - artifact: doc-{{ $Channel }} add: /app/_ru_site to: /app/ru_site/v{{ $Channel }} before: setup {{ end -}}</code> </pre> </div></div><br>  Gambar tambahan, yang, bersama dengan gambar utama, diluncurkan di sirkuit dev, hanya berisi dua versi situs: versi dari komit ulasan dan versi root situs (ada aset umum dan, jika Anda ingat, lepaskan data).  Dengan demikian, gambar tambahan dari gambar utama hanya akan berbeda di bagian impor (dan, tentu saja, dalam nama): <br><br><pre> <code class="plaintext hljs">image: werf-dev ... import: - artifact: doc-root add: /app/_main_site to: /app/main_site before: setup - artifact: doc-root add: /app/_ru_site to: /app/ru_site before: setup {{- if .WerfReviewCommit }} - artifact: doc-review add: /app/_main_site to: /app/main_site/review before: setup - artifact: doc-review add: /app/_ru_site to: /app/ru_site/review before: setup {{- end }}</code> </pre> <br>  Seperti yang sudah disebutkan di atas, artefak untuk komit peninjauan hanya akan dihasilkan ketika werf mulai dengan variabel lingkungan yang <code>REVIEW_SHA</code> .  Mungkin untuk tidak menghasilkan gambar werf-dev sama sekali jika tidak ada <code>REVIEW_SHA</code> lingkungan <code>REVIEW_SHA</code> , tetapi agar <a href="https://ru.werf.io/documentation/reference/cleaning_process.html">pembersihan kebijakan</a> berbasis-werf-dev <a href="https://ru.werf.io/documentation/reference/cleaning_process.html">untuk</a> gambar Docker berfungsi untuk gambar werf-dev, kami membiarkannya dikumpulkan hanya dengan artefak versi root (lagi pula, itu sudah terpasang), untuk menyederhanakan struktur pipa. <br><br>  Majelis sudah siap!  Kami beralih ke CI / CD dan nuansa penting. <br><br><h3>  Pipeline di GitLab CI dan fitur perakitan dinamis </h3><br>  Saat memulai perakitan, kita perlu mengatur variabel lingkungan yang digunakan di <code>werf.yaml</code> .  Ini tidak berlaku untuk variabel REVIEW_SHA, yang akan kami atur saat pipa dipanggil dari kait GitHub. <br><br>  Kami akan menghasilkan data eksternal yang diperlukan dalam skrip Bash <code>generate_artifacts</code> , yang akan menghasilkan dua artefak pipa GitLab: <br><br><ul><li>  file <code>releases.yml</code> dengan data rilis, </li><li>  file <code>common_envs.sh</code> mengandung variabel lingkungan untuk diekspor. </li></ul><br>  Anda akan menemukan konten file <code>generate_artifacts</code> di <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">repositori contoh</a> kami.  Memperoleh data bukan subjek artikel, tetapi file <code>common_envs.sh</code> penting bagi kami, karena  pekerjaan werf tergantung padanya.  Contoh isinya: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> RELEASES=<span class="hljs-string"><span class="hljs-string">'1.0%v1.0.6-4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> CHANNELS=<span class="hljs-string"><span class="hljs-string">'1.0-alpha%v1.0.7-1 1.0-beta%v1.0.7-1 1.0-ea%v1.0.6-4 1.0-stable%v1.0.6-4 1.0-rock-solid%v1.0.6-4'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ROOT_VERSION=<span class="hljs-string"><span class="hljs-string">'v1.0.6-4'</span></span></code> </pre> <br>  Anda dapat menggunakan output dari skrip tersebut, misalnya, menggunakan fungsi Bash <code>source</code> . <br><br>  Dan sekarang untuk bagian yang menyenangkan.  Agar aplikasi build dan deploy berfungsi dengan baik, Anda harus membuat <code>werf.yaml</code> <b>sama</b> untuk setidaknya <b>satu pipeline</b> .  Jika kondisi ini tidak terpenuhi, maka tanda tangan dari tahapan yang tidak dihitung selama perakitan dan, misalnya, penyebaran, akan berbeda.  Ini akan menyebabkan kesalahan penggunaan, seperti  gambar yang diperlukan untuk penempatan tidak ada. <br><br>  Dengan kata lain, jika selama perakitan gambar situs, informasi tentang rilis dan versi adalah satu, dan pada saat rilis versi baru dirilis dan variabel lingkungan memiliki nilai yang berbeda, maka penyebaran akan gagal dengan kesalahan: artefak versi baru belum dikumpulkan. <br><br>  Jika generasi <code>werf.yaml</code> tergantung pada data eksternal (misalnya, daftar versi saat ini, seperti dalam kasus kami), maka komposisi dan nilai data tersebut harus dicatat dalam pipa.  Ini sangat penting jika parameter eksternal berubah cukup sering. <br><br>  Kami akan <b>menerima dan menangkap data eksternal</b> pada tahap pertama pipeline di GitLab ( <i>Prebuild</i> ) dan mentransfernya lebih jauh sebagai <b>artefak GitLab CI</b> .  Ini akan memungkinkan Anda untuk memulai dan memulai kembali tugas-tugas pipa (build, deploy, cleanup) dengan konfigurasi yang sama di <code>werf.yaml</code> . <br><br>  Isi tahap <i>Prebuild</i> dari file <i>.gitlab</i> - <i>ci.yml</i> : <br><br><pre> <code class="plaintext hljs">Prebuild: stage: prebuild script: - bash ./generate_artifacts 1&gt; common_envs.sh - cat ./common_envs.sh artifacts: paths: - releases.yml - common_envs.sh expire_in: 2 week</code> </pre> <br>  Dengan mengambil data eksternal dalam sebuah artefak, Anda dapat membangun dan menggunakan menggunakan tahapan pipa GitLab CI standar: Build and Deploy.  Kami meluncurkan pipa dengan kait dari wer repositori gerHub (mis. Ketika mengubah repositori di GitHub).  Data untuk mereka dapat diambil di properti proyek GitLab di <i>Pengaturan CI / CD -&gt; Bagian pemicu Pipa</i> , dan kemudian buat Webhook yang sesuai ( <i>Pengaturan -&gt; Webhooks</i> ) di GitHub. <br><br>  Tahap pembuatan akan terlihat seperti ini: <br><br><pre> <code class="plaintext hljs">Build: stage: build script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - werf build-and-publish --stages-storage :local except: refs: - schedules dependencies: - Prebuild</code> </pre> <br>  GitLab akan menambahkan dua artefak dari tahap <i>Prebuild</i> ke fase build, jadi kami mengekspor variabel dengan input yang disiapkan menggunakan <code>source common_envs.sh</code> .  Kami memulai tahap perakitan dalam semua kasus, kecuali untuk peluncuran pipa sesuai jadwal.  Sesuai dengan jadwal, pipa akan diluncurkan untuk pembersihan - kita tidak perlu membangun dalam hal ini. <br><br>  Pada tahap penerapan, kami menjelaskan dua tugas - secara terpisah untuk penempatan ke sirkuit produksi dan dev, menggunakan templat YAML: <br><br><pre> <code class="plaintext hljs">.base_deploy: &amp;base_deploy stage: deploy script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - werf deploy --stages-storage :local dependencies: - Prebuild except: refs: - schedules Deploy to Production: &lt;&lt;: *base_deploy variables: WERF_KUBE_CONTEXT: prod environment: name: production url: werf.io only: refs: - master except: variables: - $REVIEW_SHA refs: - schedules Deploy to Test: &lt;&lt;: *base_deploy variables: WERF_KUBE_CONTEXT: dev environment: name: test url: werf.test.flant.com except: refs: - schedules only: variables: - $REVIEW_SHA</code> </pre> <br>  Tugas-tugas pada dasarnya berbeda hanya dengan menunjukkan konteks cluster yang werf harus melaksanakan penyebaran ( <code>WERF_KUBE_CONTEXT</code> ) dan mengatur variabel lingkungan dari kontur ( <code>environment.name</code> dan <code>environment.url</code> ), yang kemudian digunakan dalam templat grafik Helm.  Konten template tidak akan diberikan, karena  tidak ada yang menarik untuk topik ini, tetapi Anda dapat menemukannya di <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">repositori artikel</a> . <br><br><h3>  Sentuhan terakhir </h3><br>  Karena versi werf dirilis cukup sering, gambar baru akan sering dikumpulkan, dan Docker Registry akan terus tumbuh.  Oleh karena itu, perlu untuk mengkonfigurasi pembersihan otomatis gambar oleh kebijakan.  Sangat mudah dilakukan. <br><br>  Untuk implementasi Anda perlu: <br><br><ul><li>  Tambahkan langkah pemurnian ke <code>.gitlab-ci.yml</code> ; </li><li>  Tambahkan tugas pembersihan berkala; </li><li>  Setel variabel lingkungan dengan token akses tulis. </li></ul><br>  Tambahkan tahap pembersihan ke <code>.gitlab-ci.yml</code> : <br><br><pre> <code class="plaintext hljs">Cleanup: stage: cleanup script: - type multiwerf &amp;&amp; . $(multiwerf use 1.0 alpha --as-file) - type werf &amp;&amp; source &lt;(werf ci-env gitlab --tagging-strategy tag-or-branch --verbose) - source common_envs.sh - docker login -u nobody -p ${WERF_IMAGES_CLEANUP_PASSWORD} ${WERF_IMAGES_REPO} - werf cleanup --stages-storage :local only: refs: - schedules</code> </pre><br>  Hampir semua dari kita telah melihat ini sedikit lebih tinggi - hanya untuk pembersihan Anda harus terlebih dahulu masuk ke Docker Registry dengan token yang memiliki hak untuk menghapus gambar di Docker Registry (token tugas GitLab CI yang dikeluarkan secara otomatis tidak memiliki hak seperti itu).  Token harus dimasukkan ke GitLab terlebih dahulu dan nilainya harus ditentukan dalam variabel lingkungan <code>WERF_IMAGES_CLEANUP_PASSWORD</code> proyek <i>(Pengaturan CI / CD -&gt; Variabel)</i> . <br><br>  Menambahkan tugas pembersihan dengan jadwal yang diperlukan dilakukan dalam <i>CI / CD -&gt;</i> <i><br></i>  <i>Jadwal</i> <br><br>  Itu dia: proyek di Docker Registry tidak akan lagi tumbuh terus-menerus dari gambar yang tidak digunakan. <br><br>  Di akhir bagian praktis, saya ingat bahwa daftar lengkap dari artikel tersebut tersedia di <a href="https://github.com/flant/examples/tree/master/2020/01-dynamic-build">Git</a> : <br><br><ul><li>  <a href="">.gitlab-ci.yml</a> ; </li><li>  <a href="">werf.yaml</a> . </li></ul><br><h2>  Hasil </h2><br><ol><li>  Kami mendapat struktur build logis: satu artefak per versi. </li><li>  Perakitan bersifat universal dan tidak memerlukan perubahan manual ketika versi baru werf dirilis: dokumentasi di situs diperbarui secara otomatis. </li><li>  Dua gambar dikumpulkan untuk kontur yang berbeda. </li><li>  Ini bekerja cepat karena  caching digunakan secara maksimal - ketika versi baru werf dilepaskan atau kait GitHub dipanggil untuk komit ulasan, hanya artefak yang sesuai dengan versi yang dimodifikasi yang dibangun kembali. </li><li>  Tidak perlu berpikir tentang menghapus gambar yang tidak digunakan: pembersihan kebijakan werf akan menjaga ketertiban di Docker Registry. </li></ol><br><h2>  Kesimpulan </h2><br><ul><li>  Menggunakan werf memungkinkan perakitan bekerja dengan cepat berkat caching baik perakitan itu sendiri maupun caching ketika bekerja dengan repositori eksternal. </li><li>    Git-               . werf        ,    <code>fetch</code>    . </li><li>   Go-     <code>werf.yaml</code>   ,      . </li><li>    werf     â€”   ,     pipeline. </li><li> werf    ,      . </li></ul><br><h2>  PS </h2><br>     : <br><br><ul><li> Â« <a href="https://habr.com/ru/company/flant/blog/476320/">         Kubernetes</a> Â»; </li><li> Â« <a href="https://habr.com/ru/company/flant/blog/469541/">      werf  GitLab CI</a> Â»; </li><li> Â« <a href="https://habr.com/ru/company/flant/blog/468049/"> werf    Helm-</a> Â»; </li><li> Â« <a href="https://habr.com/ru/company/flant/blog/481306/"> werf 1.0 stable:    GitOps,   </a> Â». </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478690/">https://habr.com/ru/post/id478690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478666/index.html">Kartu Suara USB pada YM3812</a></li>
<li><a href="../id478672/index.html">Pengujian dan Startup AI: Wawancara dengan Adam Carmi (Applitools)</a></li>
<li><a href="../id478680/index.html">Mengapa, dan yang paling penting, kemana orang pergi dari IT?</a></li>
<li><a href="../id478684/index.html">Pengantar SSD. Bagian 2. Antarmuka</a></li>
<li><a href="../id478688/index.html">Bagaimana rasanya belajar Ilmu Data pada tahun 2019</a></li>
<li><a href="../id478692/index.html">Bagaimana Java 8 didukung di Android</a></li>
<li><a href="../id478694/index.html">Karena kami merekomendasikan katalog terbaru di bioskop online ivi (+ kode Python)</a></li>
<li><a href="../id478696/index.html">Bagaimana Saya Mengunjungi Urban Tech 2019. Laporan Acara</a></li>
<li><a href="../id478698/index.html">Kami membuat rencana medan interaktif dalam 15 menit</a></li>
<li><a href="../id478702/index.html">Trik Pemrosesan Metrik di Kapacitor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>