<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ï üßìüèΩ ü§πüèæ Comment les machines analysent le Big Data: une introduction aux algorithmes de clustering ‚ú≥Ô∏è üê≠ üôÜüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traduction de la fa√ßon dont les machines donnent un sens aux m√©gadonn√©es: une introduction aux algorithmes de clustering . 

 Jetez un oeil √† l'image ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment les machines analysent le Big Data: une introduction aux algorithmes de clustering</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>Traduction de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fa√ßon dont les machines donnent un sens aux m√©gadonn√©es: une introduction aux algorithmes de clustering</a> .</i> <br><br>  Jetez un oeil √† l'image ci-dessous.  Il s'agit d'une collection d'insectes (les escargots ne sont pas des insectes, mais nous ne trouverons rien √† redire) de diff√©rentes formes et tailles.  Maintenant, divisez-les en plusieurs groupes selon le degr√© de similitude.  Pas de prise.  Commencez par regrouper les araign√©es. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Termin√©?  Bien qu'il n'y ait pas de ¬´bonne¬ª solution ici, vous devez avoir divis√© ces cr√©atures en quatre <b>groupes</b> .  Dans un groupe, il y a des araign√©es, dans le second - une paire d'escargots, dans le troisi√®me - des papillons et dans le quatri√®me - un trio d'abeilles et de gu√™pes. <br><br>  Bien jou√©, non?  Vous pourriez probablement faire de m√™me s'il y avait deux fois plus d'insectes dans l'image.  Et si vous aviez eu beaucoup de temps - ou une envie d'entomologie - alors vous auriez probablement regroup√© des centaines d'insectes. <br><br>  Cependant, pour une machine, le regroupement de dix objets en grappes significatives n'est pas une t√¢che facile.  Gr√¢ce √† une branche des math√©matiques aussi complexe que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combinatoire</a> , nous savons que 10 insectes sont regroup√©s de 115 975 fa√ßons.  Et s'il y a 20 insectes, le nombre d'options de regroupement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©passera 50 billions</a> . <br><br>  Avec une centaine d'insectes, le nombre de solutions possibles sera sup√©rieur au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombre de particules √©l√©mentaires dans l'Univers connu</a> .  Combien plus?  Selon mes estimations, environ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cinq cent millions de milliards de milliards de fois plus</a> .  Il s'av√®re que plus de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quatre millions de milliards de</a></b> solutions <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">google</a></b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qu'est-ce que google?</a> ).  Et ce n'est que pour des centaines d'objets. <br><br>  Presque toutes ces combinaisons n'auront aucun sens.  Malgr√© le nombre inimaginable de solutions, vous avez vous-m√™me trouv√© tr√®s rapidement l'un des rares moyens utiles de clustering. <br><br>  Nous, les humains, tenons pour acquis notre excellente capacit√© √† cataloguer et √† comprendre de grandes quantit√©s de donn√©es.  Peu importe qu'il s'agisse de texte, d'images √† l'√©cran ou d'une s√©quence d'objets - les gens, en g√©n√©ral, comprennent efficacement les donn√©es provenant du monde environnant. <br><br>  √âtant donn√© qu'un aspect cl√© du d√©veloppement de l'IA et de l'apprentissage automatique est que les machines peuvent comprendre rapidement de grands volumes de donn√©es d'entr√©e, comment puis-je am√©liorer l'efficacit√© du travail?  Dans cet article, nous consid√©rerons trois algorithmes de clustering avec lesquels les machines peuvent rapidement comprendre de grandes quantit√©s de donn√©es.  Cette liste est loin d'√™tre compl√®te - il existe d'autres algorithmes - mais il est d√©j√† tout √† fait possible de commencer par elle. <br><br>  Pour chaque algorithme, je d√©crirai quand il peut √™tre utilis√©, comment il fonctionne, et je donnerai √©galement un exemple avec une analyse pas √† pas.  Je crois que pour une r√©elle compr√©hension de l'algorithme, vous devez r√©p√©ter son travail vous-m√™me.  Si vous √™tes <b>vraiment int√©ress√©</b> , vous vous rendrez compte qu'il est pr√©f√©rable d'ex√©cuter des algorithmes sur papier.  Agissez, personne ne vous en voudra! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Trois grappes √©trangement soign√©es avec k = 3</i> <br><br><h2>  Clustering K-means </h2><br><h5>  Utilis√© par: </h5><br>  Lorsque vous comprenez combien de groupes peuvent √™tre obtenus pour trouver <b>un pr√©d√©termin√©</b> (a priori). <br><br><h5>  Comment √ßa marche: </h5><br>  L'algorithme attribue al√©atoirement chaque observation √† l'une des <b>k</b> cat√©gories, puis calcule la <b>moyenne</b> pour chaque cat√©gorie.  Il r√©affecte ensuite chaque observation √† la cat√©gorie ayant la moyenne la plus proche, puis calcule √† nouveau les moyennes.  Le processus est r√©p√©t√© jusqu'√† ce que des r√©affectations soient n√©cessaires. <br><br><h5>  Exemple de travail: </h5><br>  Prenez un groupe de 12 joueurs et le nombre de buts marqu√©s par chacun d'eux au cours de la saison en cours (par exemple, entre 3 et 30).  Nous divisons les joueurs, disons, en trois groupes. <br><br>  <b>√âtape 1</b> : vous devez diviser au hasard les joueurs en trois groupes et calculer la moyenne pour chacun d'eux. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>√âtape 2</b> : r√©affectez chaque joueur au groupe avec la moyenne la plus proche.  Par exemple, le joueur A (5 buts) va dans le groupe 2 (moyenne = 9).  L√† encore, nous calculons les moyennes de groupe. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>R√©p√©tez l'</b> √©tape 2 encore et encore jusqu'√† ce que les joueurs arr√™tent de changer de groupe.  Dans cet exemple artificiel, cela se produira √† la prochaine it√©ration.  <b>Arr√™te √ßa!</b>  Vous avez form√© trois clusters √† partir d'un ensemble de donn√©es! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Les groupes doivent correspondre √† la position des joueurs sur le terrain - d√©fenseurs, d√©fenseurs centraux et attaquants.  K-means fonctionne dans cet exemple car il y a des raisons de croire que les donn√©es seront divis√©es en ces trois cat√©gories. <br><br>  Ainsi, sur la base de la variation statistique des performances, la machine peut justifier la localisation des joueurs sur le terrain pour tout sport d'√©quipe.  Ceci est utile pour l'analyse sportive, ainsi que pour toute autre t√¢che dans laquelle la division de l'ensemble de donn√©es en groupes pr√©d√©finis permet de tirer les conclusions appropri√©es. <br><br>  Il existe plusieurs variantes de l'algorithme d√©crit.  La formation initiale de clusters peut √™tre effectu√©e de diff√©rentes mani√®res.  Nous avons examin√© la classification al√©atoire des joueurs en groupes, suivie du calcul des moyennes.  Par cons√©quent, les moyennes de groupe initiales sont proches les unes des autres, ce qui augmente la r√©p√©tabilit√©. <br><br>  Une autre approche consiste √† former des clusters compos√©s d'un seul joueur, puis √† regrouper les joueurs dans les clusters les plus proches.  Les grappes r√©sultantes d√©pendent davantage du stade initial de formation et la r√©p√©tabilit√© dans les ensembles de donn√©es √† forte variabilit√© diminue.  Mais avec cette approche, il peut prendre moins d'it√©rations pour terminer l'algorithme, car moins de temps sera consacr√© √† la division des groupes. <br><br>  L'inconv√©nient √©vident du clustering k-means est que vous devez deviner <b>√† l'avance</b> le nombre de clusters dont vous disposez.  Il existe des m√©thodes pour √©valuer la conformit√© d'un ensemble particulier de clusters.  Par exemple, la somme des carr√©s intra-cluster est une mesure de la variabilit√© au sein de chaque cluster.  Plus les grappes sont ¬´meilleures¬ª, plus la somme totale des carr√©s intracluster est faible. <br><br><h2>  Regroupement hi√©rarchique </h2><br><h5>  Utilis√© par: </h5><br>  Lorsque vous devez r√©v√©ler la relation entre les valeurs (observations). <br><br><h5>  Comment √ßa marche: </h5><br>  La matrice de distance est calcul√©e dans laquelle la valeur de la cellule ( <i>i, j</i> ) est la m√©trique de la distance entre les valeurs de <i>i</i> et <i>j</i> .  Ensuite, une paire des valeurs les plus proches est prise et la moyenne est calcul√©e.  Une nouvelle matrice de distance est cr√©√©e, les valeurs appari√©es sont combin√©es en un seul objet.  Ensuite, une paire des valeurs les plus proches est extraite de cette nouvelle matrice et une nouvelle valeur moyenne est calcul√©e.  Le cycle se r√©p√®te jusqu'√† ce que toutes les valeurs soient regroup√©es. <br><br><h5>  Exemple de travail: </h5><br>  Prenez un ensemble de donn√©es extr√™mement simplifi√© avec plusieurs esp√®ces de baleines et de dauphins.  Je suis biologiste et je peux vous assurer que beaucoup plus de propri√©t√©s sont utilis√©es pour construire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des arbres phylog√©n√©tiques</a> .  Mais pour notre exemple, nous nous limitons √† la longueur caract√©ristique du corps de six esp√®ces de mammif√®res marins.  Il y aura deux √©tapes de calcul. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>√âtape 1</b> : la matrice des distances entre toutes les vues est calcul√©e.  Nous utiliserons la m√©trique euclidienne qui d√©crit dans quelle mesure nos donn√©es sont √©loign√©es les unes des autres, comme les colonies sur la carte.  Vous pouvez obtenir la diff√©rence de longueur des corps de chaque paire en lisant la valeur √† l'intersection de la colonne et de la ligne correspondantes. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>√âtape 2</b> : Prenez une paire de deux esp√®ces les plus proches l'une de l'autre.  Dans ce cas, il s'agit d'un grand dauphin et d'un dauphin gris, dont la longueur moyenne du corps est de 3,3 m. <br><br>  Nous r√©p√©tons l'√©tape 1, calculant √† nouveau la matrice de distance, mais cette fois, nous combinons le dauphin √† gros nez et le dauphin gris en un seul objet avec une longueur corporelle de 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Maintenant, nous r√©p√©tons l'√©tape 2, mais avec une nouvelle matrice de distance.  Cette fois, la mue et l'√©paulard seront les plus proches, alors mettons-les en couple et calculons la moyenne - 7 m. <br><br>  Ensuite, r√©p√©tez l'√©tape 1: encore une fois, calculez la matrice de distance, mais avec la mouture et l'√©paulard sous la forme d'un seul objet avec une longueur de corps de 7 m. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  R√©p√©tez l'√©tape 2 avec cette matrice.  La plus petite distance (3,7 m) sera entre les deux objets combin√©s, nous allons donc les combiner en un objet encore plus grand et calculer la valeur moyenne - 5,2 m. <br><br>  R√©p√©tez ensuite l'√©tape 1 et calculez une nouvelle matrice en combinant le gros dauphin / dauphin gris avec la mouture / l'√©paulard. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  R√©p√©tez l'√©tape 2. La plus petite distance (5 m) sera entre le rorqual √† bosse et le nageoire, alors nous les combinons et calculons la moyenne - 17,5 m. <br><br>  Encore une fois, √©tape 1: calculez la matrice. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Enfin, r√©p√©tez l'√©tape 2 - il ne reste qu'une distance (12,3 m), nous allons donc r√©unir tout le monde en un seul objet et nous arr√™ter.  Voici ce qui s'est pass√©: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  L'objet a une structure hi√©rarchique (rappelez-vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSON</a> ), il peut donc √™tre affich√© sous forme d'arbre graphique ou de dendrogramme.  Le r√©sultat est similaire √† un arbre g√©n√©alogique.  Plus deux valeurs sont proches sur un arbre, plus elles sont similaires ou plus √©troitement li√©es. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Un dendrogramme simple g√©n√©r√© √† l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R-Fiddle.org</a></i> <br><br>  La structure du dendrogramme vous permet de comprendre la structure de l'ensemble de donn√©es lui-m√™me.  Dans notre exemple, nous avons eu deux branches principales - l'une avec un bossu et un nageoire, l'autre avec un grand dauphin / dauphin gris et une mouture / orque. <br><br>  En biologie √©volutive, des ensembles de donn√©es beaucoup plus grands avec de nombreuses esp√®ces et une abondance de caract√®res sont utilis√©s pour identifier les relations taxonomiques.  En dehors de la biologie, le clustering hi√©rarchique est appliqu√© dans les domaines de l'exploration de donn√©es et de l'apprentissage automatique. <br><br>  Cette approche ne n√©cessite pas de pr√©diction du nombre requis de clusters.  Vous pouvez diviser le dendrogramme r√©sultant en grappes, ¬´couper¬ª l'arbre √† la hauteur souhait√©e.  Vous pouvez choisir la hauteur de diff√©rentes mani√®res, en fonction de la r√©solution souhait√©e du clustering de donn√©es. <br>  Par exemple, si le dendrogramme ci-dessus est coup√© √† une hauteur de 10, nous coupons alors les deux branches principales, divisant ainsi le dendrogramme en deux colonnes.  S'il est coup√© √† une hauteur de 2, divisez le dendrogramme en trois groupes. <br><br>  D'autres algorithmes de clustering hi√©rarchiques peuvent diff√©rer sous trois aspects de ceux d√©crits dans cet article. <br><br>  La chose la plus importante est l'approche.  Ici, nous avons utilis√© la m√©thode <b>agglom√©rative</b> : nous avons commenc√© avec des valeurs individuelles et les avons regroup√©es cycliquement jusqu'√† obtenir un gros cluster.  Une approche alternative (et plus complexe sur le plan des calculs) implique la s√©quence inverse: d'abord un √©norme cluster est cr√©√©, puis il est s√©quentiellement divis√© en clusters de plus en plus petits jusqu'√† ce qu'il reste des valeurs distinctes. <br><br>  Il existe √©galement plusieurs m√©thodes de calcul des matrices de distance.  Les m√©triques euclidiennes sont suffisantes pour la plupart des t√¢ches, mais d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres m√©triques</a> conviennent mieux dans certaines situations. <br><br>  Enfin, le crit√®re de liaison peut varier.  La relation entre les clusters d√©pend de leur proximit√© les uns des autres, mais la d√©finition de la ¬´proximit√©¬ª peut √™tre diff√©rente.  Dans notre exemple, nous avons mesur√© la distance entre les valeurs moyennes (ou ¬´centro√Ødes¬ª) de chaque groupe et combin√© les groupes les plus proches par paires.  Mais vous pouvez utiliser une autre d√©finition. <br><br>  Supposons que chaque cluster se compose de plusieurs valeurs discr√®tes.  La distance entre deux clusters peut √™tre d√©finie comme la distance minimale (ou maximale) entre l'une de leurs valeurs, comme indiqu√© ci-dessous.  Pour diff√©rents contextes, il est pratique d'utiliser diff√©rentes d√©finitions du crit√®re de jointure. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Rouge / bleu: pool centro√Øde;</i>  <i>rouge / vert: combinaison bas√©e sur des minima;</i>  <i>vert / bleu: fusion bas√©e sur des aigus.</i> <br><br><h2>  D√©finition des communaut√©s dans les graphiques (Graph Community Detection) </h2><br><h5>  Utilis√© par: </h5><br>  Lorsque vos donn√©es peuvent √™tre pr√©sent√©es sous la forme d'un r√©seau, ou "graphique". <br><br><h5>  Comment √ßa marche: </h5><br>  <b>Une communaut√© dans un graphique</b> peut √™tre grossi√®rement d√©finie comme un sous-ensemble de sommets qui sont plus connect√©s les uns aux autres qu'au reste du r√©seau.  Il existe diff√©rents algorithmes de d√©finition de communaut√© bas√©s sur des d√©finitions plus sp√©cifiques, tels que Edge Betweenness, Modularity-Maximsation, Walktrap, Clique Percolation, Leading Eigenvector ... <br><br><h5>  Exemple de travail: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La th√©orie des graphes</a> est une branche tr√®s int√©ressante des math√©matiques qui nous permet de mod√©liser des syst√®mes complexes sous la forme d'ensembles abstraits de ¬´points¬ª (sommets, n≈ìuds) reli√©s par des ¬´lignes¬ª (ar√™tes). <br><br>  Peut-√™tre la premi√®re application des graphiques qui me vient √† l'esprit est l'√©tude des r√©seaux sociaux.  Dans ce cas, les pics repr√©sentent des personnes qui sont reli√©es par des c√¥tes √† des amis / abonn√©s.  Mais vous pouvez imaginer n'importe quel syst√®me sous la forme d'un r√©seau si vous pouvez justifier la m√©thode de connexion significative des composants.  Les applications innovantes du clustering utilisant la th√©orie des graphes incluent l'extraction de propri√©t√©s √† partir de donn√©es visuelles et l'analyse de r√©seaux de r√©gulation g√©n√©tique. <br><br>  √Ä titre d'exemple simple, regardons le graphique ci-dessous.  Cela montre les huit sites que je visite le plus souvent.  Les liens entre eux sont bas√©s sur des liens dans des articles Wikipedia.  Ces donn√©es peuvent √™tre collect√©es manuellement, mais pour les grands projets, il est beaucoup plus rapide d'√©crire un script Python.  Par exemple, ceci: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>Le graphique est construit en utilisant le paquet igraph pour R 3.3.3</i> <br><br>  La couleur des pics d√©pend de la participation aux communaut√©s et la taille d√©pend de la centralit√©.  Veuillez noter que Google et Twitter sont les plus centraux. <br><br>  De plus, les grappes r√©sultantes refl√®tent tr√®s pr√©cis√©ment les t√¢ches r√©elles (c'est toujours un indicateur important de performance).  Les sommets repr√©sentant les liens / sites de recherche sont surlign√©s en jaune;  sites surlign√©s en bleu pour les publications en ligne (articles, tweets ou code);  en rouge sont PayPal et YouTube, fond√©s par d'anciens employ√©s de PayPal.  Bonne d√©duction pour l'ordinateur! <br><br>  En plus de visualiser de grands syst√®mes, la v√©ritable puissance des r√©seaux r√©side dans l'analyse math√©matique.  Commen√ßons par convertir l'image r√©seau en un format math√©matique.  Ce qui suit <b>est la</b> matrice d' <b>adjacence</b> du r√©seau. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Les valeurs aux intersections des colonnes et des lignes indiquent s'il existe un bord entre cette paire de sommets.  Par exemple, entre Medium et Twitter, c'est donc √† l'intersection de cette ligne et de la colonne se trouve 1. Et entre Medium et PayPal, il n'y a pas de bord, donc dans la cellule correspondante, il y a 0. <br><br>  Si nous repr√©sentons toutes les propri√©t√©s du r√©seau sous la forme d'une matrice d'adjacence, cela nous permettra de tirer toutes sortes de conclusions utiles.  Par exemple, la somme des valeurs de n'importe quelle colonne ou ligne caract√©rise le <b>degr√© de</b> chaque sommet, c'est-√†-dire le nombre d'objets connect√©s √† ce sommet.  Habituellement indiqu√© par la lettre <i>k</i> . <br><br>  Si nous additionnons les degr√©s de tous les sommets et divisons par deux, nous obtenons L - le nombre d'ar√™tes dans le r√©seau.  Et le nombre de lignes et de colonnes est √©gal √† N - le nombre de sommets dans le r√©seau. <br><br>  Connaissant uniquement k, L, N et les valeurs dans toutes les cellules de la matrice d'adjacence A, nous pouvons calculer la modularit√© de tout clustering. <br><br>  Supposons que nous ayons regroup√© un r√©seau en plusieurs communaut√©s.  Ensuite, vous pouvez utiliser la valeur de modularit√© pour pr√©dire la ¬´qualit√©¬ª du clustering.  Une modularit√© plus √©lev√©e indique que nous avons divis√© le r√©seau en communaut√©s ¬´exactes¬ª et une modularit√© plus faible sugg√®re que les clusters sont form√©s plus par hasard que raisonnablement.  Pour plus de clart√©: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  La modularit√© sert de mesure de la ¬´qualit√©¬ª des groupes. <br><br>  La modularit√© peut √™tre calcul√©e √† l'aide de la formule suivante: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Regardons cette formule √† la recherche assez impressionnante. <br><br>  <b>M</b> , comme vous le savez, c'est la modularit√©. <br><br>  Le coefficient <b>1 / 2L</b> signifie que nous divisons le reste du "corps" de la formule par 2L, c'est-√†-dire par le double nombre d'ar√™tes du r√©seau.  En Python, on pourrait √©crire: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  Qu'est-ce que <code>#stuff with i and j</code> ?  Le bit entre parenth√®ses nous dit de soustraire (k_i k_j) / 2L de A_ij, o√π A_ij est la valeur dans la matrice √† l'intersection de la ligne i et de la colonne j. <br><br>  Les valeurs k_i et k_j sont les degr√©s de chaque sommet.  Ils peuvent √™tre trouv√©s en additionnant les valeurs de la ligne i et de la colonne j, respectivement.  Si nous les multiplions et divisons par 2L, alors nous obtenons le nombre attendu d'ar√™tes entre les sommets i et j si le r√©seau √©tait m√©lang√© au hasard. <br><br>  Le contenu des parenth√®ses refl√®te la diff√©rence entre la structure r√©elle du r√©seau et celle attendue si le r√©seau √©tait reconstruit au hasard.  Si vous jouez avec les valeurs, alors la modularit√© la plus √©lev√©e sera √† A_ij = 1 et faible (k_i k_j) / 2L.  C'est-√†-dire que la modularit√© augmente s'il y a un bord ¬´inattendu¬ª entre les sommets i et j. <br><br>  Enfin, nous multiplions le contenu des parenth√®ses par ce qui est indiqu√© dans la formule comme Œ¥c_i, c_j.  Il s'agit de la fonction Kronecker-delta.  Voici son impl√©mentation en Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Oui, si simple.  La fonction prend deux arguments, et s'ils sont identiques, elle renvoie 1, sinon, 0. <br><br>  En d'autres termes, si les sommets i et j tombent dans un cluster, alors Œ¥c_i, c_j = 1. Et s'ils sont dans des clusters diff√©rents, la fonction renverra 0. <br><br>  Puisque nous multiplions le contenu des parenth√®ses par le symbole de Kronecker, le r√©sultat de la somme investie <b>Œ£</b> sera le plus √©lev√© lorsque les sommets √† l'int√©rieur d'un cluster sont connect√©s par un grand nombre d'ar√™tes ¬´inattendues¬ª.  Ainsi, la modularit√© est un indicateur de la fa√ßon dont un graphique est regroup√© en communaut√©s individuelles. <br><br>  La division par 2L limite la modularit√© sup√©rieure √† l'unit√©.  Si la modularit√© est proche de 0 ou n√©gative, cela signifie que le clustering actuel du r√©seau n'a pas de sens.  En augmentant la modularit√©, nous pouvons trouver un meilleur moyen de regrouper le r√©seau. <br><br>  Veuillez noter que pour √©valuer la ¬´qualit√©¬ª du regroupement d'un graphique, nous devons d√©terminer √† l'avance comment il sera regroup√©.  Malheureusement, √† moins que l'√©chantillon ne soit tr√®s petit, en raison de la complexit√© de calcul, il est tout simplement physiquement impossible de parcourir stupidement toutes les m√©thodes de clustering d'un graphique en comparant leur modularit√©. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La combinatoire</a> sugg√®re que pour un r√©seau √† 8 sommets, il existe 4 140 m√©thodes de regroupement.  Pour un r√©seau √† 16 sommets, il y aura d√©j√† plus de 10 milliards de voies, pour un r√©seau √† 32 sommets, 128 septillions, et pour un r√©seau √† 80 sommets, le nombre de m√©thodes de clustering d√©passera le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombre d'atomes dans l'Univers observable</a> . <br><br>  Par cons√©quent, au lieu d'√©num√©rer, nous utilisons la m√©thode heuristique, qui aidera √† calculer relativement facilement des clusters avec une modularit√© maximale.  Il s'agit d'un algorithme appel√© <i>Fast-Greedy Modularity-Maximization</i> , une sorte d'analogue de l'algorithme de regroupement hi√©rarchique agglom√©r√© d√©crit ci-dessus.  Au lieu de se combiner sur la base de la proximit√©, Mod-Max unit les communaut√©s en fonction des changements de modularit√©.  Comment √ßa marche: <br><br>  <b>Tout d'abord,</b> chaque sommet est affect√© √† sa propre communaut√© et la modularit√© de l'ensemble du r√©seau est calcul√©e - M. <br><br>  <b>Etape 1</b> : pour chaque paire de communaut√©s connect√©es par au moins un front, l'algorithme calcule le changement r√©sultant de la modularit√© ŒîM dans le cas de la combinaison de ces paires de communaut√©s. <br><br>  <b>√âtape 2</b> : alors une paire est prise, lorsqu'elle est combin√©e, ŒîM sera maximale et combin√©e.  Pour ce clustering, une nouvelle modularit√© est calcul√©e et stock√©e. <br><br>  Les √©tapes 1 et 2 sont <b>r√©p√©t√©es</b> : chaque fois qu'une paire de communaut√©s se joint, ce qui donne le plus grand ŒîM, un nouveau sch√©ma de clustering et son M. <br><br>  Les it√©rations <b>s'arr√™tent</b> lorsque tous les sommets sont regroup√©s en un √©norme cluster.  Maintenant, l'algorithme v√©rifie les enregistrements stock√©s et trouve le sch√©ma de clustering avec la modularit√© la plus √©lev√©e.  C'est elle qui revient en tant que structure communautaire. <br><br>  C'√©tait difficile √† calculer, du moins pour les gens.  La th√©orie des graphes est une riche source de probl√®mes de calcul difficiles et de probl√®mes NP-difficiles.  √Ä l'aide de graphiques, nous pouvons tirer de nombreuses conclusions utiles sur les syst√®mes et ensembles de donn√©es complexes.  Demandez √† Larry Page, dont l'algorithme PageRank - qui a aid√© Google √† passer d'une startup √† une dominante mondiale en moins d'une g√©n√©ration - est enti√®rement bas√© sur la th√©orie des graphes. <br><br>  Les √©tudes sur la th√©orie des graphes se concentrent aujourd'hui sur l'identification des communaut√©s.  Il existe de nombreuses alternatives √† l'algorithme Modularity-Maximization, qui, bien qu'utile, n'est pas sans inconv√©nients. <br><br>  Premi√®rement, avec une approche agglom√©rative, de petites communaut√©s bien d√©finies sont souvent combin√©es en de plus grandes.  C'est ce qu'on appelle <b>une</b> limite de r√©solution - l'algorithme n'alloue pas les communaut√©s plus petites qu'une certaine taille.  Un autre inconv√©nient est qu'au lieu d'un pic global prononc√© et facilement r√©alisable, l'algorithme Mod-Max cherche √† g√©n√©rer un large "plateau" √† partir de nombreuses valeurs de modularit√© proches.  Par cons√©quent, il est difficile d'identifier le gagnant. <br><br>  D'autres algorithmes utilisent diff√©rentes m√©thodes pour d√©finir les communaut√©s.  Par exemple, Edge-Betweenness est un algorithme de division (division) qui commence par regrouper tous les sommets en un seul cluster √©norme.  Ensuite, les ar√™tes les moins ¬´importantes¬ª sont supprim√©es de mani√®re it√©rative jusqu'√† ce que tous les sommets soient isol√©s.  Le r√©sultat est une structure hi√©rarchique dans laquelle les sommets sont plus proches les uns des autres, plus ils sont similaires. <br><br>  L'algorithme, Clique Percolation, prend en compte les intersections possibles entre les communaut√©s.  Il existe un groupe d'algorithmes bas√©s sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une marche al√©atoire</a> sur un graphique, et il existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des</a> m√©thodes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regroupement spectral</a> qui traitent de la d√©composition spectrale (composition par eigende) de la matrice d'adjacence et d'autres matrices qui en d√©rivent.  Toutes ces id√©es sont utilis√©es pour mettre en √©vidence des fonctionnalit√©s, par exemple, en vision industrielle. <br><br>  Nous n'analyserons pas en d√©tail des exemples de travail pour chaque algorithme.  ,              ,     20    . <br><br><h2>  Conclusion </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   ‚Äî    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413269/">https://habr.com/ru/post/fr413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413253/index.html">Richard Hamming: Chapitre 21. Fibre optique</a></li>
<li><a href="../fr413255/index.html">Richard Hamming: Chapitre 27. Donn√©es invalides</a></li>
<li><a href="../fr413261/index.html">Comment fonctionne la recherche</a></li>
<li><a href="../fr413265/index.html">Vers les bains avec IT</a></li>
<li><a href="../fr413267/index.html">10 qualit√©s incontournables √† noter pour un chef de produit d√©butant</a></li>
<li><a href="../fr413271/index.html">Pas de mots de passe: comment fonctionne le syst√®me d'authentification sur un registre distribu√©</a></li>
<li><a href="../fr413273/index.html">Gestion des besoins en produits informatiques au sein de l'entreprise</a></li>
<li><a href="../fr413275/index.html">Test comparatif des grils pour obtenir le r√©sultat le plus d√©licieux</a></li>
<li><a href="../fr413277/index.html">JSFiddle - nouvelle version</a></li>
<li><a href="../fr413279/index.html">L'application mobile calcule la teneur en calories des plats dans les restaurants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>