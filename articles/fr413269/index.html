<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤕 🧓🏽 🤹🏾 Comment les machines analysent le Big Data: une introduction aux algorithmes de clustering ✳️ 🐭 🙆🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Traduction de la façon dont les machines donnent un sens aux mégadonnées: une introduction aux algorithmes de clustering . 

 Jetez un oeil à l'image ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment les machines analysent le Big Data: une introduction aux algorithmes de clustering</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/nix/blog/413269/"><img src="https://habrastorage.org/webt/1t/cz/rt/1tczrtuly-qxcq8pwrfwgdubvqm.jpeg"><br><br>  <i>Traduction de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">façon dont les machines donnent un sens aux mégadonnées: une introduction aux algorithmes de clustering</a> .</i> <br><br>  Jetez un oeil à l'image ci-dessous.  Il s'agit d'une collection d'insectes (les escargots ne sont pas des insectes, mais nous ne trouverons rien à redire) de différentes formes et tailles.  Maintenant, divisez-les en plusieurs groupes selon le degré de similitude.  Pas de prise.  Commencez par regrouper les araignées. <br><br><img src="https://habrastorage.org/webt/yh/jr/c_/yhjrc_z9obxthw3uymiywxkyehq.png"><br><a name="habracut"></a><br>  Terminé?  Bien qu'il n'y ait pas de «bonne» solution ici, vous devez avoir divisé ces créatures en quatre <b>groupes</b> .  Dans un groupe, il y a des araignées, dans le second - une paire d'escargots, dans le troisième - des papillons et dans le quatrième - un trio d'abeilles et de guêpes. <br><br>  Bien joué, non?  Vous pourriez probablement faire de même s'il y avait deux fois plus d'insectes dans l'image.  Et si vous aviez eu beaucoup de temps - ou une envie d'entomologie - alors vous auriez probablement regroupé des centaines d'insectes. <br><br>  Cependant, pour une machine, le regroupement de dix objets en grappes significatives n'est pas une tâche facile.  Grâce à une branche des mathématiques aussi complexe que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">combinatoire</a> , nous savons que 10 insectes sont regroupés de 115 975 façons.  Et s'il y a 20 insectes, le nombre d'options de regroupement <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dépassera 50 billions</a> . <br><br>  Avec une centaine d'insectes, le nombre de solutions possibles sera supérieur au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombre de particules élémentaires dans l'Univers connu</a> .  Combien plus?  Selon mes estimations, environ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cinq cent millions de milliards de milliards de fois plus</a> .  Il s'avère que plus de <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quatre millions de milliards de</a></b> solutions <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">google</a></b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">qu'est-ce que google?</a> ).  Et ce n'est que pour des centaines d'objets. <br><br>  Presque toutes ces combinaisons n'auront aucun sens.  Malgré le nombre inimaginable de solutions, vous avez vous-même trouvé très rapidement l'un des rares moyens utiles de clustering. <br><br>  Nous, les humains, tenons pour acquis notre excellente capacité à cataloguer et à comprendre de grandes quantités de données.  Peu importe qu'il s'agisse de texte, d'images à l'écran ou d'une séquence d'objets - les gens, en général, comprennent efficacement les données provenant du monde environnant. <br><br>  Étant donné qu'un aspect clé du développement de l'IA et de l'apprentissage automatique est que les machines peuvent comprendre rapidement de grands volumes de données d'entrée, comment puis-je améliorer l'efficacité du travail?  Dans cet article, nous considérerons trois algorithmes de clustering avec lesquels les machines peuvent rapidement comprendre de grandes quantités de données.  Cette liste est loin d'être complète - il existe d'autres algorithmes - mais il est déjà tout à fait possible de commencer par elle. <br><br>  Pour chaque algorithme, je décrirai quand il peut être utilisé, comment il fonctionne, et je donnerai également un exemple avec une analyse pas à pas.  Je crois que pour une réelle compréhension de l'algorithme, vous devez répéter son travail vous-même.  Si vous êtes <b>vraiment intéressé</b> , vous vous rendrez compte qu'il est préférable d'exécuter des algorithmes sur papier.  Agissez, personne ne vous en voudra! <br><br><img src="https://habrastorage.org/webt/6g/yv/nu/6gyvnuxigsioglh_xamfblafeua.png"><br>  <i>Trois grappes étrangement soignées avec k = 3</i> <br><br><h2>  Clustering K-means </h2><br><h5>  Utilisé par: </h5><br>  Lorsque vous comprenez combien de groupes peuvent être obtenus pour trouver <b>un prédéterminé</b> (a priori). <br><br><h5>  Comment ça marche: </h5><br>  L'algorithme attribue aléatoirement chaque observation à l'une des <b>k</b> catégories, puis calcule la <b>moyenne</b> pour chaque catégorie.  Il réaffecte ensuite chaque observation à la catégorie ayant la moyenne la plus proche, puis calcule à nouveau les moyennes.  Le processus est répété jusqu'à ce que des réaffectations soient nécessaires. <br><br><h5>  Exemple de travail: </h5><br>  Prenez un groupe de 12 joueurs et le nombre de buts marqués par chacun d'eux au cours de la saison en cours (par exemple, entre 3 et 30).  Nous divisons les joueurs, disons, en trois groupes. <br><br>  <b>Étape 1</b> : vous devez diviser au hasard les joueurs en trois groupes et calculer la moyenne pour chacun d'eux. <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = (<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">20</span></span> + <span class="hljs-number"><span class="hljs-number">11</span></span>) / <span class="hljs-number"><span class="hljs-number">3</span></span> = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span></code> </pre> <br>  <b>Étape 2</b> : réaffectez chaque joueur au groupe avec la moyenne la plus proche.  Par exemple, le joueur A (5 buts) va dans le groupe 2 (moyenne = 9).  Là encore, nous calculons les moyennes de groupe. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">12</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">9</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">16</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) <span class="hljs-built_in"><span class="hljs-built_in">New</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span></code> </pre> <br>  <b>Répétez l'</b> étape 2 encore et encore jusqu'à ce que les joueurs arrêtent de changer de groupe.  Dans cet exemple artificiel, cela se produira à la prochaine itération.  <b>Arrête ça!</b>  Vous avez formé trois clusters à partir d'un ensemble de données! <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">11</span></span>) Player C (<span class="hljs-number"><span class="hljs-number">11</span></span> goals), Player I (<span class="hljs-number"><span class="hljs-number">15</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">4</span></span>) Player A (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player D (<span class="hljs-number"><span class="hljs-number">5</span></span> goals), Player E (<span class="hljs-number"><span class="hljs-number">3</span></span> goals), Player H (<span class="hljs-number"><span class="hljs-number">3</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Group</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Old</span></span> Mean = <span class="hljs-number"><span class="hljs-number">21</span></span>) Player G (<span class="hljs-number"><span class="hljs-number">30</span></span> goals), Player B (<span class="hljs-number"><span class="hljs-number">20</span></span> goals), Player F (<span class="hljs-number"><span class="hljs-number">19</span></span> goals) Final Mean = <span class="hljs-number"><span class="hljs-number">23</span></span></code> </pre> <br>  Les groupes doivent correspondre à la position des joueurs sur le terrain - défenseurs, défenseurs centraux et attaquants.  K-means fonctionne dans cet exemple car il y a des raisons de croire que les données seront divisées en ces trois catégories. <br><br>  Ainsi, sur la base de la variation statistique des performances, la machine peut justifier la localisation des joueurs sur le terrain pour tout sport d'équipe.  Ceci est utile pour l'analyse sportive, ainsi que pour toute autre tâche dans laquelle la division de l'ensemble de données en groupes prédéfinis permet de tirer les conclusions appropriées. <br><br>  Il existe plusieurs variantes de l'algorithme décrit.  La formation initiale de clusters peut être effectuée de différentes manières.  Nous avons examiné la classification aléatoire des joueurs en groupes, suivie du calcul des moyennes.  Par conséquent, les moyennes de groupe initiales sont proches les unes des autres, ce qui augmente la répétabilité. <br><br>  Une autre approche consiste à former des clusters composés d'un seul joueur, puis à regrouper les joueurs dans les clusters les plus proches.  Les grappes résultantes dépendent davantage du stade initial de formation et la répétabilité dans les ensembles de données à forte variabilité diminue.  Mais avec cette approche, il peut prendre moins d'itérations pour terminer l'algorithme, car moins de temps sera consacré à la division des groupes. <br><br>  L'inconvénient évident du clustering k-means est que vous devez deviner <b>à l'avance</b> le nombre de clusters dont vous disposez.  Il existe des méthodes pour évaluer la conformité d'un ensemble particulier de clusters.  Par exemple, la somme des carrés intra-cluster est une mesure de la variabilité au sein de chaque cluster.  Plus les grappes sont «meilleures», plus la somme totale des carrés intracluster est faible. <br><br><h2>  Regroupement hiérarchique </h2><br><h5>  Utilisé par: </h5><br>  Lorsque vous devez révéler la relation entre les valeurs (observations). <br><br><h5>  Comment ça marche: </h5><br>  La matrice de distance est calculée dans laquelle la valeur de la cellule ( <i>i, j</i> ) est la métrique de la distance entre les valeurs de <i>i</i> et <i>j</i> .  Ensuite, une paire des valeurs les plus proches est prise et la moyenne est calculée.  Une nouvelle matrice de distance est créée, les valeurs appariées sont combinées en un seul objet.  Ensuite, une paire des valeurs les plus proches est extraite de cette nouvelle matrice et une nouvelle valeur moyenne est calculée.  Le cycle se répète jusqu'à ce que toutes les valeurs soient regroupées. <br><br><h5>  Exemple de travail: </h5><br>  Prenez un ensemble de données extrêmement simplifié avec plusieurs espèces de baleines et de dauphins.  Je suis biologiste et je peux vous assurer que beaucoup plus de propriétés sont utilisées pour construire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des arbres phylogénétiques</a> .  Mais pour notre exemple, nous nous limitons à la longueur caractéristique du corps de six espèces de mammifères marins.  Il y aura deux étapes de calcul. <br><br><img src="https://habrastorage.org/webt/ho/im/do/hoimdoymetxkqlurmxoqutbochi.jpeg" width="628"><br><br>  <b>Étape 1</b> : la matrice des distances entre toutes les vues est calculée.  Nous utiliserons la métrique euclidienne qui décrit dans quelle mesure nos données sont éloignées les unes des autres, comme les colonies sur la carte.  Vous pouvez obtenir la différence de longueur des corps de chaque paire en lisant la valeur à l'intersection de la colonne et de la ligne correspondantes. <br><br><img src="https://habrastorage.org/webt/yy/eb/uo/yyebuo8b9stsem9pzjqic7noofg.jpeg" width="469"><br><br>  <b>Étape 2</b> : Prenez une paire de deux espèces les plus proches l'une de l'autre.  Dans ce cas, il s'agit d'un grand dauphin et d'un dauphin gris, dont la longueur moyenne du corps est de 3,3 m. <br><br>  Nous répétons l'étape 1, calculant à nouveau la matrice de distance, mais cette fois, nous combinons le dauphin à gros nez et le dauphin gris en un seul objet avec une longueur corporelle de 3,3 m. <br><br><img src="https://habrastorage.org/webt/ty/rr/tq/tyrrtqpqet7se07snsamey6sk5m.jpeg" width="484"><br><br>  Maintenant, nous répétons l'étape 2, mais avec une nouvelle matrice de distance.  Cette fois, la mue et l'épaulard seront les plus proches, alors mettons-les en couple et calculons la moyenne - 7 m. <br><br>  Ensuite, répétez l'étape 1: encore une fois, calculez la matrice de distance, mais avec la mouture et l'épaulard sous la forme d'un seul objet avec une longueur de corps de 7 m. <br><br><img src="https://habrastorage.org/webt/0u/yi/ok/0uyioklconrrjskxp-jujhqpdhg.jpeg" width="551"><br><br>  Répétez l'étape 2 avec cette matrice.  La plus petite distance (3,7 m) sera entre les deux objets combinés, nous allons donc les combiner en un objet encore plus grand et calculer la valeur moyenne - 5,2 m. <br><br>  Répétez ensuite l'étape 1 et calculez une nouvelle matrice en combinant le gros dauphin / dauphin gris avec la mouture / l'épaulard. <br><br><img src="https://habrastorage.org/webt/15/uq/5s/15uq5ssub0h3yhz7omxjcucy6lc.jpeg" width="503"><br><br>  Répétez l'étape 2. La plus petite distance (5 m) sera entre le rorqual à bosse et le nageoire, alors nous les combinons et calculons la moyenne - 17,5 m. <br><br>  Encore une fois, étape 1: calculez la matrice. <br><br><img src="https://habrastorage.org/webt/wq/6h/x2/wq6hx2vppdkd41tyx9fp3tf_ksk.jpeg" width="506"><br><br>  Enfin, répétez l'étape 2 - il ne reste qu'une distance (12,3 m), nous allons donc réunir tout le monde en un seul objet et nous arrêter.  Voici ce qui s'est passé: <br><br><pre> <code class="hljs json">[[[BD, RD],[PW, KW]],[HW, FW]]</code> </pre> <br>  L'objet a une structure hiérarchique (rappelez-vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JSON</a> ), il peut donc être affiché sous forme d'arbre graphique ou de dendrogramme.  Le résultat est similaire à un arbre généalogique.  Plus deux valeurs sont proches sur un arbre, plus elles sont similaires ou plus étroitement liées. <br><br><img src="https://habrastorage.org/webt/o-/ax/kv/o-axkvnp3rdgbt843ej8dsodneq.png"><br>  <i>Un dendrogramme simple généré à l'aide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R-Fiddle.org</a></i> <br><br>  La structure du dendrogramme vous permet de comprendre la structure de l'ensemble de données lui-même.  Dans notre exemple, nous avons eu deux branches principales - l'une avec un bossu et un nageoire, l'autre avec un grand dauphin / dauphin gris et une mouture / orque. <br><br>  En biologie évolutive, des ensembles de données beaucoup plus grands avec de nombreuses espèces et une abondance de caractères sont utilisés pour identifier les relations taxonomiques.  En dehors de la biologie, le clustering hiérarchique est appliqué dans les domaines de l'exploration de données et de l'apprentissage automatique. <br><br>  Cette approche ne nécessite pas de prédiction du nombre requis de clusters.  Vous pouvez diviser le dendrogramme résultant en grappes, «couper» l'arbre à la hauteur souhaitée.  Vous pouvez choisir la hauteur de différentes manières, en fonction de la résolution souhaitée du clustering de données. <br>  Par exemple, si le dendrogramme ci-dessus est coupé à une hauteur de 10, nous coupons alors les deux branches principales, divisant ainsi le dendrogramme en deux colonnes.  S'il est coupé à une hauteur de 2, divisez le dendrogramme en trois groupes. <br><br>  D'autres algorithmes de clustering hiérarchiques peuvent différer sous trois aspects de ceux décrits dans cet article. <br><br>  La chose la plus importante est l'approche.  Ici, nous avons utilisé la méthode <b>agglomérative</b> : nous avons commencé avec des valeurs individuelles et les avons regroupées cycliquement jusqu'à obtenir un gros cluster.  Une approche alternative (et plus complexe sur le plan des calculs) implique la séquence inverse: d'abord un énorme cluster est créé, puis il est séquentiellement divisé en clusters de plus en plus petits jusqu'à ce qu'il reste des valeurs distinctes. <br><br>  Il existe également plusieurs méthodes de calcul des matrices de distance.  Les métriques euclidiennes sont suffisantes pour la plupart des tâches, mais d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autres métriques</a> conviennent mieux dans certaines situations. <br><br>  Enfin, le critère de liaison peut varier.  La relation entre les clusters dépend de leur proximité les uns des autres, mais la définition de la «proximité» peut être différente.  Dans notre exemple, nous avons mesuré la distance entre les valeurs moyennes (ou «centroïdes») de chaque groupe et combiné les groupes les plus proches par paires.  Mais vous pouvez utiliser une autre définition. <br><br>  Supposons que chaque cluster se compose de plusieurs valeurs discrètes.  La distance entre deux clusters peut être définie comme la distance minimale (ou maximale) entre l'une de leurs valeurs, comme indiqué ci-dessous.  Pour différents contextes, il est pratique d'utiliser différentes définitions du critère de jointure. <br><br><img src="https://habrastorage.org/webt/mi/rm/em/mirmemzgr_pbyyumzxolhgftfoa.png"><br>  <i>Rouge / bleu: pool centroïde;</i>  <i>rouge / vert: combinaison basée sur des minima;</i>  <i>vert / bleu: fusion basée sur des aigus.</i> <br><br><h2>  Définition des communautés dans les graphiques (Graph Community Detection) </h2><br><h5>  Utilisé par: </h5><br>  Lorsque vos données peuvent être présentées sous la forme d'un réseau, ou "graphique". <br><br><h5>  Comment ça marche: </h5><br>  <b>Une communauté dans un graphique</b> peut être grossièrement définie comme un sous-ensemble de sommets qui sont plus connectés les uns aux autres qu'au reste du réseau.  Il existe différents algorithmes de définition de communauté basés sur des définitions plus spécifiques, tels que Edge Betweenness, Modularity-Maximsation, Walktrap, Clique Percolation, Leading Eigenvector ... <br><br><h5>  Exemple de travail: </h5><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La théorie des graphes</a> est une branche très intéressante des mathématiques qui nous permet de modéliser des systèmes complexes sous la forme d'ensembles abstraits de «points» (sommets, nœuds) reliés par des «lignes» (arêtes). <br><br>  Peut-être la première application des graphiques qui me vient à l'esprit est l'étude des réseaux sociaux.  Dans ce cas, les pics représentent des personnes qui sont reliées par des côtes à des amis / abonnés.  Mais vous pouvez imaginer n'importe quel système sous la forme d'un réseau si vous pouvez justifier la méthode de connexion significative des composants.  Les applications innovantes du clustering utilisant la théorie des graphes incluent l'extraction de propriétés à partir de données visuelles et l'analyse de réseaux de régulation génétique. <br><br>  À titre d'exemple simple, regardons le graphique ci-dessous.  Cela montre les huit sites que je visite le plus souvent.  Les liens entre eux sont basés sur des liens dans des articles Wikipedia.  Ces données peuvent être collectées manuellement, mais pour les grands projets, il est beaucoup plus rapide d'écrire un script Python.  Par exemple, ceci: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://raw.githubusercontent.com/pg0408/Medium-articles/master/graph_maker.py</a> . <br><br><img src="https://habrastorage.org/webt/qi/nh/7l/qinh7l-i5pblst_uwrknqda6w6k.png"><br>  <i>Le graphique est construit en utilisant le paquet igraph pour R 3.3.3</i> <br><br>  La couleur des pics dépend de la participation aux communautés et la taille dépend de la centralité.  Veuillez noter que Google et Twitter sont les plus centraux. <br><br>  De plus, les grappes résultantes reflètent très précisément les tâches réelles (c'est toujours un indicateur important de performance).  Les sommets représentant les liens / sites de recherche sont surlignés en jaune;  sites surlignés en bleu pour les publications en ligne (articles, tweets ou code);  en rouge sont PayPal et YouTube, fondés par d'anciens employés de PayPal.  Bonne déduction pour l'ordinateur! <br><br>  En plus de visualiser de grands systèmes, la véritable puissance des réseaux réside dans l'analyse mathématique.  Commençons par convertir l'image réseau en un format mathématique.  Ce qui suit <b>est la</b> matrice d' <b>adjacence</b> du réseau. <br><br><img src="https://habrastorage.org/webt/yx/gx/_x/yxgx_xezjyqcvpnsimmblg0by2a.jpeg" width="523"><br><br>  Les valeurs aux intersections des colonnes et des lignes indiquent s'il existe un bord entre cette paire de sommets.  Par exemple, entre Medium et Twitter, c'est donc à l'intersection de cette ligne et de la colonne se trouve 1. Et entre Medium et PayPal, il n'y a pas de bord, donc dans la cellule correspondante, il y a 0. <br><br>  Si nous représentons toutes les propriétés du réseau sous la forme d'une matrice d'adjacence, cela nous permettra de tirer toutes sortes de conclusions utiles.  Par exemple, la somme des valeurs de n'importe quelle colonne ou ligne caractérise le <b>degré de</b> chaque sommet, c'est-à-dire le nombre d'objets connectés à ce sommet.  Habituellement indiqué par la lettre <i>k</i> . <br><br>  Si nous additionnons les degrés de tous les sommets et divisons par deux, nous obtenons L - le nombre d'arêtes dans le réseau.  Et le nombre de lignes et de colonnes est égal à N - le nombre de sommets dans le réseau. <br><br>  Connaissant uniquement k, L, N et les valeurs dans toutes les cellules de la matrice d'adjacence A, nous pouvons calculer la modularité de tout clustering. <br><br>  Supposons que nous ayons regroupé un réseau en plusieurs communautés.  Ensuite, vous pouvez utiliser la valeur de modularité pour prédire la «qualité» du clustering.  Une modularité plus élevée indique que nous avons divisé le réseau en communautés «exactes» et une modularité plus faible suggère que les clusters sont formés plus par hasard que raisonnablement.  Pour plus de clarté: <br><br><img src="https://habrastorage.org/webt/hg/le/gj/hglegjtps3qnirey4nn01lxp-lu.png"><br>  La modularité sert de mesure de la «qualité» des groupes. <br><br>  La modularité peut être calculée à l'aide de la formule suivante: <br><br><img src="https://habrastorage.org/webt/n7/04/sb/n704sbaigjz6d9l35ovo40o1avq.png"><br><br>  Regardons cette formule à la recherche assez impressionnante. <br><br>  <b>M</b> , comme vous le savez, c'est la modularité. <br><br>  Le coefficient <b>1 / 2L</b> signifie que nous divisons le reste du "corps" de la formule par 2L, c'est-à-dire par le double nombre d'arêtes du réseau.  En Python, on pourrait écrire: <br><br><pre> <code class="python hljs">sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>,N): ans = <span class="hljs-comment"><span class="hljs-comment">#stuff with i and j as indices sum += ans</span></span></code> </pre> <br>  Qu'est-ce que <code>#stuff with i and j</code> ?  Le bit entre parenthèses nous dit de soustraire (k_i k_j) / 2L de A_ij, où A_ij est la valeur dans la matrice à l'intersection de la ligne i et de la colonne j. <br><br>  Les valeurs k_i et k_j sont les degrés de chaque sommet.  Ils peuvent être trouvés en additionnant les valeurs de la ligne i et de la colonne j, respectivement.  Si nous les multiplions et divisons par 2L, alors nous obtenons le nombre attendu d'arêtes entre les sommets i et j si le réseau était mélangé au hasard. <br><br>  Le contenu des parenthèses reflète la différence entre la structure réelle du réseau et celle attendue si le réseau était reconstruit au hasard.  Si vous jouez avec les valeurs, alors la modularité la plus élevée sera à A_ij = 1 et faible (k_i k_j) / 2L.  C'est-à-dire que la modularité augmente s'il y a un bord «inattendu» entre les sommets i et j. <br><br>  Enfin, nous multiplions le contenu des parenthèses par ce qui est indiqué dans la formule comme δc_i, c_j.  Il s'agit de la fonction Kronecker-delta.  Voici son implémentation en Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kronecker_Delta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ci, cj)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ci == cj: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> Kronecker_Delta(<span class="hljs-string"><span class="hljs-string">"A"</span></span>,<span class="hljs-string"><span class="hljs-string">"A"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#returns 1 Kronecker_Delta("A","B") #returns 0</span></span></code> </pre> <br>  Oui, si simple.  La fonction prend deux arguments, et s'ils sont identiques, elle renvoie 1, sinon, 0. <br><br>  En d'autres termes, si les sommets i et j tombent dans un cluster, alors δc_i, c_j = 1. Et s'ils sont dans des clusters différents, la fonction renverra 0. <br><br>  Puisque nous multiplions le contenu des parenthèses par le symbole de Kronecker, le résultat de la somme investie <b>Σ</b> sera le plus élevé lorsque les sommets à l'intérieur d'un cluster sont connectés par un grand nombre d'arêtes «inattendues».  Ainsi, la modularité est un indicateur de la façon dont un graphique est regroupé en communautés individuelles. <br><br>  La division par 2L limite la modularité supérieure à l'unité.  Si la modularité est proche de 0 ou négative, cela signifie que le clustering actuel du réseau n'a pas de sens.  En augmentant la modularité, nous pouvons trouver un meilleur moyen de regrouper le réseau. <br><br>  Veuillez noter que pour évaluer la «qualité» du regroupement d'un graphique, nous devons déterminer à l'avance comment il sera regroupé.  Malheureusement, à moins que l'échantillon ne soit très petit, en raison de la complexité de calcul, il est tout simplement physiquement impossible de parcourir stupidement toutes les méthodes de clustering d'un graphique en comparant leur modularité. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La combinatoire</a> suggère que pour un réseau à 8 sommets, il existe 4 140 méthodes de regroupement.  Pour un réseau à 16 sommets, il y aura déjà plus de 10 milliards de voies, pour un réseau à 32 sommets, 128 septillions, et pour un réseau à 80 sommets, le nombre de méthodes de clustering dépassera le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nombre d'atomes dans l'Univers observable</a> . <br><br>  Par conséquent, au lieu d'énumérer, nous utilisons la méthode heuristique, qui aidera à calculer relativement facilement des clusters avec une modularité maximale.  Il s'agit d'un algorithme appelé <i>Fast-Greedy Modularity-Maximization</i> , une sorte d'analogue de l'algorithme de regroupement hiérarchique aggloméré décrit ci-dessus.  Au lieu de se combiner sur la base de la proximité, Mod-Max unit les communautés en fonction des changements de modularité.  Comment ça marche: <br><br>  <b>Tout d'abord,</b> chaque sommet est affecté à sa propre communauté et la modularité de l'ensemble du réseau est calculée - M. <br><br>  <b>Etape 1</b> : pour chaque paire de communautés connectées par au moins un front, l'algorithme calcule le changement résultant de la modularité ΔM dans le cas de la combinaison de ces paires de communautés. <br><br>  <b>Étape 2</b> : alors une paire est prise, lorsqu'elle est combinée, ΔM sera maximale et combinée.  Pour ce clustering, une nouvelle modularité est calculée et stockée. <br><br>  Les étapes 1 et 2 sont <b>répétées</b> : chaque fois qu'une paire de communautés se joint, ce qui donne le plus grand ΔM, un nouveau schéma de clustering et son M. <br><br>  Les itérations <b>s'arrêtent</b> lorsque tous les sommets sont regroupés en un énorme cluster.  Maintenant, l'algorithme vérifie les enregistrements stockés et trouve le schéma de clustering avec la modularité la plus élevée.  C'est elle qui revient en tant que structure communautaire. <br><br>  C'était difficile à calculer, du moins pour les gens.  La théorie des graphes est une riche source de problèmes de calcul difficiles et de problèmes NP-difficiles.  À l'aide de graphiques, nous pouvons tirer de nombreuses conclusions utiles sur les systèmes et ensembles de données complexes.  Demandez à Larry Page, dont l'algorithme PageRank - qui a aidé Google à passer d'une startup à une dominante mondiale en moins d'une génération - est entièrement basé sur la théorie des graphes. <br><br>  Les études sur la théorie des graphes se concentrent aujourd'hui sur l'identification des communautés.  Il existe de nombreuses alternatives à l'algorithme Modularity-Maximization, qui, bien qu'utile, n'est pas sans inconvénients. <br><br>  Premièrement, avec une approche agglomérative, de petites communautés bien définies sont souvent combinées en de plus grandes.  C'est ce qu'on appelle <b>une</b> limite de résolution - l'algorithme n'alloue pas les communautés plus petites qu'une certaine taille.  Un autre inconvénient est qu'au lieu d'un pic global prononcé et facilement réalisable, l'algorithme Mod-Max cherche à générer un large "plateau" à partir de nombreuses valeurs de modularité proches.  Par conséquent, il est difficile d'identifier le gagnant. <br><br>  D'autres algorithmes utilisent différentes méthodes pour définir les communautés.  Par exemple, Edge-Betweenness est un algorithme de division (division) qui commence par regrouper tous les sommets en un seul cluster énorme.  Ensuite, les arêtes les moins «importantes» sont supprimées de manière itérative jusqu'à ce que tous les sommets soient isolés.  Le résultat est une structure hiérarchique dans laquelle les sommets sont plus proches les uns des autres, plus ils sont similaires. <br><br>  L'algorithme, Clique Percolation, prend en compte les intersections possibles entre les communautés.  Il existe un groupe d'algorithmes basés sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une marche aléatoire</a> sur un graphique, et il existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des</a> méthodes de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">regroupement spectral</a> qui traitent de la décomposition spectrale (composition par eigende) de la matrice d'adjacence et d'autres matrices qui en dérivent.  Toutes ces idées sont utilisées pour mettre en évidence des fonctionnalités, par exemple, en vision industrielle. <br><br>  Nous n'analyserons pas en détail des exemples de travail pour chaque algorithme.  ,              ,     20    . <br><br><h2>  Conclusion </h2><br> ,     - ,   ,         .   ,       ,       20-40 . <br><br>     ,   —    ,            . ,     ,       . <br><br>    ,  ,     ,   ,   . , -  , ,    ?     - ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413269/">https://habr.com/ru/post/fr413269/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413253/index.html">Richard Hamming: Chapitre 21. Fibre optique</a></li>
<li><a href="../fr413255/index.html">Richard Hamming: Chapitre 27. Données invalides</a></li>
<li><a href="../fr413261/index.html">Comment fonctionne la recherche</a></li>
<li><a href="../fr413265/index.html">Vers les bains avec IT</a></li>
<li><a href="../fr413267/index.html">10 qualités incontournables à noter pour un chef de produit débutant</a></li>
<li><a href="../fr413271/index.html">Pas de mots de passe: comment fonctionne le système d'authentification sur un registre distribué</a></li>
<li><a href="../fr413273/index.html">Gestion des besoins en produits informatiques au sein de l'entreprise</a></li>
<li><a href="../fr413275/index.html">Test comparatif des grils pour obtenir le résultat le plus délicieux</a></li>
<li><a href="../fr413277/index.html">JSFiddle - nouvelle version</a></li>
<li><a href="../fr413279/index.html">L'application mobile calcule la teneur en calories des plats dans les restaurants</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>