<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòΩ ü•ß üë©üèª‚Äçüöí Los rompecabezas de Kotlin, vol. 2: un nuevo lote de rompecabezas ‚òÇÔ∏è üë©üèΩ‚Äç‚öïÔ∏è ‚ÄºÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬øPuedes predecir c√≥mo se comportar√° ese c√≥digo de Kotlin? ¬øCompilar√° lo que saldr√° y por qu√©? 

 No importa cu√°n bueno sea el lenguaje de programaci√≥n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los rompecabezas de Kotlin, vol. 2: un nuevo lote de rompecabezas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/440974/"><img src="https://habrastorage.org/webt/bj/9x/wi/bj9xwicnsccegyu2fo2xvbvglr0.png"><br><br>  ¬øPuedes predecir c√≥mo se comportar√° ese c√≥digo de Kotlin?  ¬øCompilar√° lo que saldr√° y por qu√©? <br><br>  No importa cu√°n bueno sea el lenguaje de programaci√≥n, puede arrojarse de manera tal que solo se rasque la parte posterior de la cabeza.  Kotlin no es una excepci√≥n: tambi√©n contiene acertijos cuando incluso un c√≥digo muy corto tiene un comportamiento inesperado. <br><br>  En 2017, publicamos en Habr√© una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">selecci√≥n de</a> tales rompecabezas de <b>Anton</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Keks antonkeks</a> .  Y luego actu√≥ con nosotros en Mobius con la segunda selecci√≥n, y ahora tambi√©n lo tradujimos para Habr en una vista de texto, ocultando las respuestas correctas debajo de los spoilers. <br><br>  Tambi√©n adjuntamos la grabaci√≥n de video del discurso, si algo parece incomprensible en el texto, tambi√©n puede contactarla. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/t387acWEK3o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La primera mitad de los rompecabezas est√°n dirigidos a aquellos que no est√°n muy familiarizados con Kotlin;  la segunda mitad es para desarrolladores hardcore de Kotlin.  Comenzaremos todo en Kotlin 1.3, incluso con el modo progresivo habilitado.  Los c√≥digos fuente de Puzzler est√°n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en GitHub</a> .  Quien tenga nuevas ideas, env√≠e solicitudes de extracci√≥n. <br><br><h2>  Pazzler numero 1 </h2><br><pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { println(print(‚Ä≥Hello‚Ä≥) == print(‚Ä≥World‚Ä≥) == <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } hello()</code> </pre> <br>  Ante nosotros hay una simple funci√≥n de saludo, ejecuta varias impresiones.  Y lanzamos esta funci√≥n en s√≠.  Una simple pregunta de overclocking: ¬øqu√© deber√≠a imprimir? <br><br>  a) HelloWorld <br>  b) HelloWorldfalse <br>  c) HelloWorldtrue <br>  d) No compilado <br><br><div class="spoiler">  <b class="spoiler_title">Respuesta correcta</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ce/uc/rg/ceucrgqimyvojaud8llfktt0l1s.png"><br><br>  La primera opci√≥n era correcta.  La comparaci√≥n se activa despu√©s de que ambas impresiones ya hayan comenzado, no puede comenzar antes.  ¬øPor qu√© se compila ese c√≥digo?  Cualquier funci√≥n distinta de devolver Nada devuelve algo.  Como todo en Kotlin es una expresi√≥n, incluso return tambi√©n es una expresi√≥n.  El tipo de retorno de return es Nothing, se convierte a cualquier tipo, por lo que puede comparar de esta manera.  E print devuelve Unit, por lo que Unit se puede comparar con Nothing varias veces, y todo funciona muy bien. <br></div></div><br><h2>  Pazzler n√∫mero 2 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { println(n) } printInt(-<span class="hljs-number"><span class="hljs-number">2_147_483_648</span></span>.inc())</code> </pre><br>  Sugerencia que no adivina: un n√∫mero aterrador es realmente el menor entero con signo de 32 bits posible. <br><br>  Todo parece simple aqu√≠.  Kotlin tiene excelentes funciones de extensi√≥n como .inc () para incrementar.  Podemos llamarlo en Int, y podemos imprimir el resultado.  Que va a pasar <br><br>  a) -2147483647 <br>  b) -2147483649 <br>  c) 2147483647 <br>  d) Ninguna de las anteriores <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamiento</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/se/sa/hy/sesahyqljf-z0kyeil35hpev4ho.png"><br><br>  Como puede ver en el mensaje de error, aqu√≠ est√° el problema con Long.  ¬øPero por qu√© tanto? <br><br>  Las funciones de extensi√≥n tienen prioridad, y el compilador primero ejecuta inc (), y luego el operador menos.  Si se elimina inc (), ser√° Int y todo funcionar√°.  Pero inc (), comenzando primero, convierte 2_147_483_648 en Long, porque este n√∫mero sin menos ya no es v√°lido Int.  Resulta largo, y solo entonces se llama menos.  Todo esto ya no se puede pasar a la funci√≥n printInt (), ya que requiere un Int. <br><br>  Si cambiamos la llamada printInt a una impresi√≥n normal, que puede aceptar Long, entonces la segunda opci√≥n ser√° correcta. <br><br><img src="https://habrastorage.org/webt/qf/vf/q3/qfvfq3njfzcubm6ax7uvda6g8b4.png"><br><br>  Vemos que esto es realmente largo.  Cuidado con esto: no todas las piezas del rompecabezas se pueden encontrar en c√≥digo real, pero este s√≠. <br></div></div><br><h2>  Pazzler n√∫mero 3 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x: UInt = <span class="hljs-number"><span class="hljs-number">0</span></span>u println(x--.toInt()) println(--x)</code> </pre><br>  En Kotlin 1.3 llegaron nuevas caracter√≠sticas excelentes.  Adem√°s de la versi√≥n final de corutina, nosotros <br>  ahora finalmente tienen n√∫meros sin signo.  Esto es necesario, especialmente si est√° escribiendo alg√∫n tipo de c√≥digo de red. <br><br>  Ahora, para literales, incluso hay una letra especial u, podemos definir constantes, podemos, como en el ejemplo, decrementar x y convertir a Int.  Les recuerdo que Int est√° familiarizado con nosotros. <br><br>  Que va a pasar <br><br>  a) -1 4294967294 <br>  b) 0 4294967294 <br>  c) 0 -2 <br>  d) No compilado <br><br>  4294967294 es el n√∫mero m√°ximo de 32 bits que se puede obtener. <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamiento</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/uj/up/ch/ujupchn07nkjmqfl8a9hnhbycha.png"><br><br>  Opci√≥n correcta b. <br><br>  Aqu√≠, como en la versi√≥n anterior: primero, toInt () se invoca en x, y solo luego disminuye.  Se muestra el resultado del decremento unsigned, y este es el m√°ximo de unsignedInt. <br><br>  Lo m√°s interesante es que si escribe as√≠, el c√≥digo no se compilar√°: <br><br><pre> <code class="kotlin hljs">println(x--.toInt()) println(--x.toInt())</code> </pre><br>  Y para m√≠ es muy extra√±o que la primera l√≠nea funcione y la segunda, no, esto es il√≥gico. <br><br>  Y en la versi√≥n preliminar, la opci√≥n correcta ser√≠a C, tan bien hecha en JetBrains que corrige los errores antes del lanzamiento de la versi√≥n final. <br></div></div><br><h2>  Pazzler n√∫mero 4 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cells = arrayOf(arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), arrayOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] + cells[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] print(neighbors)</code> </pre><br>  Nos encontramos con este caso en c√≥digo real.  Nosotros en Codeborne hicimos Coding Dojo, lo implementamos juntos en Kotlin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Game of Life</a> .  Como puede ver, no es muy conveniente trabajar con matrices de niveles m√∫ltiples en Kotlin. <br><br>  En Game of Life, una parte importante del algoritmo es determinar el n√∫mero de vecinos para una celda.  Todos los peque√±os alrededor son vecinos, y depende de si la c√©lula vive o muere.  En este c√≥digo, puede contarlos y asumir lo que sucede. <br><br>  a) 6 <br>  b) 3 <br>  c) 2 <br>  d) No compilado <br><br><div class="spoiler">  <b class="spoiler_title">Vamos a ver</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/m2/8_/j0/m28_j0aa1kg9j7aixnsj2trzsrg.png"><br><br>  La respuesta correcta es 3. <br><br>  El hecho es que la ventaja de la primera l√≠nea se mueve hacia abajo, y Kotlin piensa que esto es unaryPlus ().  Como resultado, solo se suman las tres primeras celdas.  Si queremos escribir este c√≥digo en varias l√≠neas, necesitamos mover el m√°s hacia arriba. <br><br>  Este es otro de los "malos acertijos".  Recuerde, en Kotlin no necesita transferir la declaraci√≥n a una nueva l√≠nea, de lo contrario, puede considerarla unaria. <br><br><img src="https://habrastorage.org/webt/f5/-9/ew/f5-9ewbhsw0ucybzsg-7xkeld1u.png"><br><br>  No he visto situaciones en las que se necesita unaryPlus en c√≥digo real, excepto DSL.  Este es un tema muy extra√±o. <br><br>  Este es el precio que pagamos por la ausencia de punto y coma.  Si lo fueran, estar√≠a claro cuando una expresi√≥n termina y comienza otra.  Y sin ellos, el compilador debe tomar la decisi√≥n.  Los avances de l√≠nea para el compilador a menudo significan que tiene sentido tratar de examinar las l√≠neas por separado. <br><br>  Pero hay un lenguaje JavaScript muy bueno en el que tampoco puedes escribir punto y coma, y ‚Äã‚Äãeste c√≥digo seguir√° funcionando correctamente. <br></div></div><br><h2>  Pazzler n√∫mero 5 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>? = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x?:<span class="hljs-number"><span class="hljs-number">0</span></span> + y println(sum)</code> </pre><br>  Este rompecabezas es presentado por el orador de KotlinConf Thomas Nild. <br><br>  Kotlin tiene una gran caracter√≠stica de tipos anulables.  Tenemos x anulable, y podemos convertirlo, si resulta ser nulo, a trav√©s del operador Elvis a alg√∫n valor normal. <br><br>  Que va a pasar <br><br>  a) 3 <br>  b) 5 <br>  c) 2 <br>  d) 0 <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamiento</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/1_/zg/-o/1_zg-ozj8sgftbrk2nswebclg30.png"><br><br>  El problema est√° nuevamente en el orden o prioridad de los operadores.  Si reformateamos esto, entonces el formato oficial lo har√°: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sum = x ?: <span class="hljs-number"><span class="hljs-number">0</span></span>+y</code> </pre><br>  El formato ya sugiere que 0 + y comienza primero, y solo entonces x?:.  Por lo tanto, por supuesto, queda 2, porque X es dos, no es nulo. <br></div></div><br><h2>  Pazzler n√∫mero 6 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hops: List&lt;Hops&gt; = emptyList() ) <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hops</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> kind: String? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> atMinute: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> grams: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Recipe</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = Recipe().apply(build) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Recipe.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(build: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Hops</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { hops += Hops().apply(build) } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> recipe = beer { name = ‚Ä≥Simple IPA‚Ä≥ hops { name = ‚Ä≥Cascade‚Ä≥ grams = <span class="hljs-number"><span class="hljs-number">100</span></span> atMinute = <span class="hljs-number"><span class="hljs-number">15</span></span> } }</code> </pre><br>  Cuando me llamaron aqu√≠, me prometieron elaborar cerveza.  Voy a buscarlo esta noche, a√∫n no lo he visto.  Kotlin tiene un gran tema: los constructores.  Con cuatro l√≠neas de c√≥digo, escribimos nuestro DSL y luego lo creamos a trav√©s de los constructores. <br><br>  En primer lugar, creamos IPA, agregamos l√∫pulos llamados Cascade, 100 gramos en el minuto 15 de cocci√≥n, y luego imprimimos esta receta.  Que hicimos <br><br>  a) Receta (nombre = IPA simple, l√∫pulo = [L√∫pulo (nombre = Cascada, al minuto = 15, gramos = 100)]) <br>  b) IllegalArgumentException <br>  c) No compilado <br>  d) Ninguna de las anteriores <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamiento</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ji/ci/8p/jici8p8px4kd4hnogzpvcufsrqi.png"><br><br>  Tenemos algo similar a la cerveza artesanal, pero no hay l√∫pulo, desapareci√≥.  Quer√≠an una IPA, pero obtuvieron Baltic 7. <br><br>  Aqu√≠ es donde ocurri√≥ el choque de nombres.  El campo en Hops en realidad se llama kind, y en la l√≠nea name = ‚Ä≥ Cascade ‚Ä≥ usamos name, que se almacena en cach√© con el nombre de la receta. <br><br>  Podemos crear nuestra propia anotaci√≥n BeerLang y registrarla como parte del DSL BeerLang.  Ahora estamos tratando de ejecutar este c√≥digo, y no deber√≠a compilarse con nosotros. <br><br><img src="https://habrastorage.org/webt/eq/i-/a3/eqi-a3r5hjxbpsy7z-rlzqlkqjg.png"><br><br>  Ahora se nos dice que, en principio, el nombre no puede usarse desde este contexto.  Para esto, se necesita DSLMarker porque el compilador dentro del constructor no nos permiti√≥ usar el campo externo, si tenemos el mismo dentro de √©l para que no haya conflicto de nombres.  El c√≥digo se arregla as√≠, y obtenemos nuestra receta. <br><br><img src="https://habrastorage.org/webt/rv/kn/8y/rvkn8ys1t9syngob9ikmtfbgij8.png"><br></div></div><br><h2>  Pazzler n√∫mero 7 </h2><br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  Este rompecabezas es uno de los empleados de JetBrains.  Kotlin tiene una funci√≥n cu√°ndo.  Es para todas las ocasiones, le permite escribir c√≥digo genial, a menudo se usa junto con clases selladas para el dise√±o de API. <br><br>  En este caso, tenemos una funci√≥n f () que toma un booleano e imprime algo dependiendo de verdadero y falso. <br><br>  Que va a pasar <br><br>  a) verdadero VERDADERO;  falso falso <br>  b) verdadero VERDADERO;  falso VERDADERO <br>  c) verdadero FALSO;  falso falso <br>  d) Ninguna de las anteriores <br><br><div class="spoiler">  <b class="spoiler_title">Vamos a ver</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/c6/g0/lo/c6g0loicys30gkbo0bf9cagvk20.png"><br><br>  Por qu√©  Primero, calculamos la expresi√≥n x == verdadero: por ejemplo, en el primer caso, ser√° verdadero == verdadero, lo que significa verdadero.  Y luego tambi√©n hay una comparaci√≥n con el patr√≥n que pasamos cuando. <br><br>  Y cuando x se establece en falso, evaluar x == verdadero nos dar√° falso, sin embargo, la muestra tambi√©n ser√° falsa, por lo que el ejemplo coincidir√° con la muestra. <br><br>  Hay dos formas de arreglar este c√≥digo, una es eliminar "x ==" en ambos casos: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (x) { <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br>  La segunda opci√≥n es eliminar (x) despu√©s de cu√°ndo.  Cuando funciona con cualquier condici√≥n, y luego no coincidir√° con la muestra. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { x == <span class="hljs-literal"><span class="hljs-literal">true</span></span> -&gt; println(‚Ä≥$x TRUE‚Ä≥) x == <span class="hljs-literal"><span class="hljs-literal">false</span></span> -&gt; println(‚Ä≥$x FALSE‚Ä≥) } } f(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) f(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br></div></div><br><h2>  Pazzler n√∫mero 8 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NullSafeLang</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> logo = name[<span class="hljs-number"><span class="hljs-number">0</span></span>].toUpperCase() } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = ‚Ä≥Kotlin‚Ä≥ } print(Kotlin().logo)</code> </pre><br>  Kotlin fue comercializado como un lenguaje "nulo seguro".  Imagine que tenemos una clase abstracta, tiene un nombre, as√≠ como una propiedad que devuelve el logotipo de este idioma: la primera letra del nombre, por si acaso, en may√∫scula (de repente se olvid√≥ de hacer la capital inicial). <br><br>  Dado que el idioma es nulo seguro, cambiaremos el nombre y probablemente deber√≠amos obtener el logotipo correcto, que es una letra.  ¬øQu√© es lo que realmente obtenemos? <br><br>  a) K <br>  b) NullPointerException <br>  c) IllegalStateException <br>  d) No compilado <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamiento</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/bb/et/sm/bbetsm3lj5eh356zwho6z4bhzjs.png"><br><br>  Tenemos una NullPointerException, que no deber√≠amos recibir.  El problema es que primero se llama al constructor de la superclase, el c√≥digo intenta inicializar el logotipo de la propiedad y tomar el nombre char de cero, y en este punto el nombre es nulo, por lo que se produce una NullPointerException. <br><br>  La mejor manera de solucionar esto es hacer esto: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kotlin</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NullSafeLang</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = ‚Ä≥Kotlin‚Ä≥ }</code> </pre><br>  Si ejecutamos dicho c√≥digo, obtenemos "K".  Ahora la clase base llamar√° al constructor de la clase base, en realidad llamar√° al nombre getter y obtendr√° Kotlin. <br><br>  La propiedad es una gran caracter√≠stica en Kotlin, pero debe ser muy cuidadoso cuando anula las propiedades, porque es muy f√°cil de olvidar, cometer un error o asegurar algo incorrecto. <br><br></div></div><br><h2>  Pazzler n√∫mero 9 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = mutableListOf&lt;() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">3</span></span>) { i++ result += { print(‚Ä≥$i, $j; ‚Ä≥) } } result.forEach { it() }</code> </pre><br>  Hay una lista mutable de algunas cosas aterradoras.  Si te recuerda a Scala, entonces no es en vano, porque realmente parece.  Hay una lista lambd, tomamos dos contadores: I y j, incrementamos y luego hacemos algo con ellos.  Que va a pasar <br><br>  a) 1 1;  2 2;  3 3 <br>  b) 1 3;  2 3;  3 3 <br>  c) 3 1;  3 2;  3 3 <br>  d) ninguno de los anteriores <br><br><div class="spoiler">  <b class="spoiler_title">Vamos a correr</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/y8/ap/9j/y8ap9j-cfyyuanfscsg_irflczy.png"><br><br>  Tenemos 3 1;  3 2;  3 3. Esto sucede porque i es una variable y conservar√° su valor hasta el final de la funci√≥n.  Y j se pasa por valor. <br><br>  Si en lugar de var i = 0 hubiera val i = 0, esto no funcionar√≠a, pero no podr√≠amos incrementar la variable. <br><br>  Aqu√≠ en Kotlin usamos el cierre, esta caracter√≠stica no est√° en Java.  Es genial, pero puede mordernos si no usamos inmediatamente el valor de i, sino que lo pasamos a la lambda, que comienza m√°s tarde y ve el √∫ltimo valor de esta variable.  Y j se pasa por valor, porque las variables en la condici√≥n de bucle: son las mismas que val, ya no cambian su valor. <br><br>  En JavaScript, la respuesta ser√≠a "3 3;  3 3;  3 3 ‚Äù, porque no hay nada transmitido por valor. <br><br></div></div><br><h2>  Pazzler n√∫mero 10 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">, b: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = print(‚Ä≥$a, $b‚Ä≥) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = <span class="hljs-number"><span class="hljs-number">4</span></span> foo(c &lt; a, b &gt; d)</code> </pre><br>  Tenemos una funci√≥n foo (), toma dos booleanos, los imprime, todo parece ser simple.  Y tenemos un mont√≥n de n√∫meros, queda por ver qu√© figura es m√°s grande que la otra, y decidir qu√© opci√≥n es la correcta. <br><br>  a) cierto, cierto <br>  b) falso, falso <br>  c) nulo, nulo <br>  d) no compilado <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/j6/m5/5c/j6m55cysqvltjnc9x67mxerzglq.png"><br><br>  No compilado <br><br>  El problema es que el compilador piensa que esto es similar a los par√°metros gen√©ricos: con &lt;a, b&gt;.  Aunque parece que "c" no es una clase, no est√° claro por qu√© deber√≠a tener par√°metros gen√©ricos. <br><br>  Si el c√≥digo fuera as√≠, funcionar√≠a bien: <br><br><pre> <code class="kotlin hljs">foo(c &gt; a, b &gt; d)</code> </pre><br>  Me parece que este es un error en el compilador.  Pero cuando me acerco a Andrei Breslav con tal enigma, dice: "Esto se debe a que el analizador es as√≠, no quer√≠an que fuera demasiado lento".  En general, siempre encuentra una explicaci√≥n de por qu√©. <br><br>  Lamentablemente, esto es as√≠.  Dijo que no lo arreglar√°n, porque el analizador en <br>  Kotlin a√∫n no conoce la sem√°ntica.  El an√°lisis ocurre primero y luego lo pasa a otro componente del compilador.  Desafortunadamente, esto probablemente seguir√° siendo as√≠.  ¬°As√≠ que no escriba dos par√©ntesis angulares y ning√∫n c√≥digo en el medio! <br></div></div><br><h2>  Pazzler n√∫mero 11 </h2><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Container</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: String, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> items: List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt;) : List&lt;<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> items <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (name, items) = Container(‚Ä≥Kotlin‚Ä≥, listOf(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) println(‚Ä≥Hello $name, $items‚Ä≥)</code> </pre><br>  Delegar es una gran caracter√≠stica en Kotlin.  Por cierto, Andrei Breslav dice que esta es una caracter√≠stica que con mucho gusto eliminar√≠a del idioma, ya no le gusta.  Ahora, tal vez, descubriremos por qu√©.  Y tambi√©n dijo que los objetos de compa√±√≠a son feos. <br><br>  Pero las clases de datos son definitivamente hermosas.  Tenemos un contenedor de clase de datos, toma un nombre y elementos para s√≠ mismo.  Al mismo tiempo, en el Contenedor, implementamos el tipo de elementos, esto es Lista, y delegamos todos sus m√©todos a los elementos. <br><br>  Luego usamos otra caracter√≠stica interesante: la desestructuraci√≥n.  "Destruimos" los elementos de nombre y elementos del Contenedor y los mostramos en la pantalla.  Todo parece ser simple y claro.  Que va a pasar <br><br>  a) Hola Kotlin, [1, 2, 3] <br>  b) Hola Kotlin, 1 <br>  c) Hola 1, 2 <br>  d) Hola Kotlin, 2 <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fn/jt/bb/fnjtbbmz1sikuctkwsxxkmih7vc.png"><br><br>  La opci√≥n m√°s oscura es d.  Resulta ser cierto.  Al final result√≥ que, los elementos simplemente desaparecen de la colecci√≥n de elementos, y no desde el principio o desde el final, sino solo en el medio.  Por qu√© <br><br>  El problema con la desestructuraci√≥n es que debido a la delegaci√≥n, todas las colecciones en Kotlin tambi√©n <br>  tienen su propia opci√≥n de desestructuraci√≥n.  Puedo escribir val (I, j) = listOf (1, 2), y obtener estos 1 y 2 en variables, es decir, List ha implementado las funciones componente1 () y <br>  componente2 (). <br><br>  La clase de datos tambi√©n tiene componente1 () y componente2 ().  Pero dado que el segundo componente en este caso es privado, el que es p√∫blico en List gana, por lo que el segundo elemento se toma de List, y llegamos aqu√≠ 2. La moraleja es muy simple: no hagas eso, no hagas eso. <br></div></div><br><h2>  Pazzler n√∫mero 12 </h2><br>  El siguiente rompecabezas es muy aterrador.  Esta es una persona sumisa que de alguna manera est√° conectada con Kotlin, por lo que sabe lo que est√° escribiendo. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> Any?.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asGeneric</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? T <span class="hljs-number"><span class="hljs-number">42</span></span>.asGeneric&lt;<span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span>&gt;()!!!! <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-number"><span class="hljs-number">87</span></span> println(a)</code> </pre><br>  Tenemos una funci√≥n de extensi√≥n en Anulable Any, es decir, se puede aplicar a cualquier cosa.  Esta es una caracter√≠stica muy √∫til.  Si a√∫n no est√° en su proyecto, vale la pena agregarlo, porque puede poner todo lo que desee en cualquier cosa.  Luego tomamos 42 y lo lanzamos a la nada. <br><br>  Bueno, si queremos estar seguros de que hemos hecho algo importante, ¬°podemos hacerlo!  escriba !!!!, el compilador de Kotlin le permite hacer esto: si le faltan dos signos de exclamaci√≥n, escriba al menos veintis√©is. <br><br>  Luego hacemos if (verdadero), y luego yo mismo no entiendo nada ... Elegimos inmediatamente lo que sucede. <br><br>  a) 87 <br>  b) Kotlin.Unit <br>  c) ClassCastException <br>  d) No compilado <br><br><div class="spoiler">  <b class="spoiler_title">Viendo</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/g7/l-/_tg7l-vw0wze-y2vu_dix7cnvni.png"><br><br>  Es muy dif√≠cil dar una explicaci√≥n l√≥gica.  Lo m√°s probable es que la Unidad aqu√≠ se deba al hecho de que no hay nada m√°s que empujar all√≠.  Este es un c√≥digo no v√°lido, pero funciona porque usamos Nothing.  Hemos subido algo a Nothing, y este es un tipo especial que le dice al compilador que nunca deber√≠a aparecer una instancia de este tipo.  El compilador sabe que si existe la posibilidad de la aparici√≥n de Nothing, lo cual es imposible por definici√≥n, entonces no puede verificar m√°s, esta es una situaci√≥n imposible. <br><br>  Lo m√°s probable es que este sea un error en el compilador, el equipo de JetBrains incluso dijo que tal vez este error se solucionar√° alg√∫n d√≠a, esto no es una prioridad.  El truco es que enga√±amos al compilador aqu√≠ debido a este elenco.  Si elimina la l√≠nea 42.asGeneric &lt;Nthing&gt; () !!!  y deje de hacer trampa, el c√≥digo dejar√° de compilarse.  Y si nos vamos, el compilador se vuelve loco, piensa que esta es una expresi√≥n imposible, y mete lo que sea que est√© all√≠. <br><br>  Entiendo eso  Quiz√°s alguien alg√∫n d√≠a lo explique mejor. <br><br></div></div><br><h2>  Pazzler n√∫mero 13 </h2><br>  Tenemos una caracter√≠stica muy interesante.  Puede usar la inyecci√≥n de dependencia, o puede prescindir de ella, hacer singletones a trav√©s del objeto y ejecutar su programa genial.  ¬øPor qu√© necesitas Koin, Dagger o algo as√≠?  Las pruebas, sin embargo, ser√°n dif√≠ciles. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = javaClass.simpleName } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> B : A(C) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> C : A(B) println(Bx) println(Cx)</code> </pre><br>  Tenemos la clase A abierta para la herencia, se necesita algo dentro de s√≠ misma, creamos dos objetos: a, singleton, B y C, ambos se heredan de A y se cruzan all√≠.  Es decir, se forma un excelente ciclo.  Luego imprimimos lo que obtuvieron B y C. <br><br>  a) nulo;  nulo <br>  b) C;  nulo <br>  c) ExceptionInInitializerError <br>  d) No compilado <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamos</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/lf/ic/tc/lfictczohzri2l2os2w5xpypbfw.png"><br><br>  La opci√≥n correcta es C;  nulo <br><br>  Uno podr√≠a pensar que cuando se inicializa el primer objeto, el segundo todav√≠a no est√° all√≠.  Pero, cuando deducimos esto, C carece de B. Es decir, se obtiene el orden inverso: por alguna raz√≥n, el compilador decidi√≥ inicializar C primero, y luego inicializ√≥ B junto con C. Parece il√≥gico, ser√≠a l√≥gico, por el contrario, nulo ;  B. <br><br>  Pero el compilador intent√≥ hacer algo, no tuvo √©xito, dej√≥ el nulo all√≠ y decidi√≥ no tirarnos nada.  Podr√≠a ser as√≠ tambi√©n. <br><br>  Si alguno?  en el tipo de par√°metro, ¬øeliminar ?, entonces no funcionar√°. <br><br><img src="https://habrastorage.org/webt/re/mh/6n/remh6n7bggwrm2ig962qbh1uvlu.png"><br><br>  Podemos decirle bien al compilador que cuando se resolvi√≥ nulo, lo intent√≥, pero fall√≥, pero ¬øqu√©?  no, nos lanza una excepci√≥n de que es imposible hacer un ciclo. <br></div></div><br><h2>  Pazzler ‚Ññ14 </h2><br>  La versi√≥n 1.3 lanz√≥ grandes nuevas rutinas en Kotlin.  Durante mucho tiempo pens√© en c√≥mo encontrar un enigma sobre la corutina, para que alguien pudiera entenderlo.  Creo que para algunas personas cualquier c√≥digo con corutinas es un enigma. <br><br>  En 1.3, algunos nombres de funciones cambiaron que estaban en 1.2 en la API experimental.  Por ejemplo, buildSequence () se renombra para simplemente secuenciar ().  Es decir, podemos hacer secuencias excelentes con la funci√≥n de rendimiento, bucles infinitos, y luego podemos intentar sacar algo de esta secuencia. <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> coroutines.yieldNoOne <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = sequence { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) yield(n++) } println(x.take(<span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre><br>  Dijeron con corutinas que todas las primitivas geniales que est√°n en otros idiomas, como el rendimiento, se pueden hacer como funciones de biblioteca, porque el rendimiento es una funci√≥n de suspensi√≥n que se puede interrumpir. <br><br>  Que va a pasar <br><br>  a) [1, 2, 3] <br>  b) [0, 1, 2] <br>  c) bucle infinito <br>  d) Ninguna de las anteriores <br><br><div class="spoiler">  <b class="spoiler_title">Lanzamiento</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/dh/p2/s3/dhp2s3ugmoll1vijctjtmlxgmtm.png"><br><br>  La opci√≥n correcta es la √∫ltima. <br><br>  La secuencia es un artilugio vago, y cuando nos aferramos a √©l, tambi√©n es vago.  Pero si agrega toList, realmente imprimir√° [0, 1, 2]. <br><br>  La respuesta correcta no est√° relacionada con las rutinas en absoluto.  Las corutinas realmente funcionan, son f√°ciles de usar.  Para la funci√≥n de secuencia y rendimiento, ni siquiera necesita conectar una biblioteca con corutinas, todo ya est√° en la biblioteca est√°ndar. <br></div></div><br><h2>  Pazzler ‚Ññ15 </h2><br>  Este rompecabezas tambi√©n est√° sometido por el desarrollador de JetBrains.  Hay un c√≥digo tan infernal: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> whatAmI = {-&gt;}.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}() println(whatAmI)</code> </pre><br>  Cuando lo vi por primera vez, durante KotlinConf, no pude dormir, intent√© entender de qu√© se trataba.  Tal c√≥digo cr√≠ptico se puede escribir en Kotlin, por lo que si alguien pens√≥ que Scalaz daba miedo, entonces en Kotlin tambi√©n es posible. <br><br>  Supongamos: <br><br>  a) Kotlin.Unit <br>  b) Kotlin.Nada <br>  c) No compilado <br>  d) Ninguna de las anteriores <br><br><div class="spoiler">  <b class="spoiler_title">Vamos a correr</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/fk/xy/o_/fkxyo_vljbjpo9gv1lak7ubr_1a.png"><br><br>  Tenemos una Unidad que vino de la nada. <br><br>  Por qu√©  Primero asignamos la variable lambda: {-&gt;} - este es un c√≥digo v√°lido, puede escribir un lambda vac√≠o.  No tiene par√°metros, no devuelve nada.  En consecuencia, devuelve Unidad. <br><br>  Asignamos un lambda a la variable e inmediatamente escribimos la extensi√≥n a este lambda, y luego lo ejecutamos.  De hecho, simplemente reservar√° Kotlin.Unit. <br><br>  Luego, en esta lambda, puede escribir una funci√≥n de extensi√≥n: <br><br><pre> <code class="kotlin hljs">.<span class="hljs-keyword"><span class="hljs-keyword">fun</span></span> Function&lt;*&gt;.(){}</code> </pre><br>  Se declara en el tipo Funci√≥n &lt;*&gt;, y lo que tenemos encima tambi√©n es adecuado para ello.  En realidad, es la Funci√≥n &lt;Unidad&gt;, pero no escrib√≠ Unidad que no estaba claro.  ¬øSabes c√≥mo funciona un asterisco en Kotlin?     ,    Java.    ,    . <br><br>     ,    Unit  {},      ,  void-. ,   ,  .  -,      ‚Äî   . <br></div></div><br>    .    ,  Kotlin ‚Äî  .   iOS-     ,    ,   Kotlin   ! <br><blockquote>       Mobius,  :  <b>Mobius</b>  <b>22-23   </b> .   Kotlin    ‚Äî <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ¬´Coroutining Android Apps¬ª        .        ( Android,   iOS),      ‚Äî  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,   <b>1 </b>   . <br><br>  :     ,            ‚Äî  <b>6 </b>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>  . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440974/">https://habr.com/ru/post/440974/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440958/index.html">C√≥mo intent√© arreglar un mapa de b√∫squeda de controladores. Parte 2</a></li>
<li><a href="../440960/index.html">Orange Pi 2G-IOT: mapa del campo minado</a></li>
<li><a href="../440962/index.html">Los proveedores de comunicaci√≥n van a obligar a celebrar contratos para la conexi√≥n de edificios residenciales.</a></li>
<li><a href="../440966/index.html">Conexi√≥n de sensores KELLER a MATLAB</a></li>
<li><a href="../440972/index.html">La Universidad de Innopolis tendr√° la primera escuela internacional de dise√±o de veh√≠culos aut√≥nomos de Rusia</a></li>
<li><a href="../440976/index.html">Escane√© toda Austria y encontr√© ...</a></li>
<li><a href="../440978/index.html">Termostato ambiental inal√°mbrico programable por Wi-Fi con monitor de calidad del aire y otras caracter√≠sticas √∫tiles</a></li>
<li><a href="../440980/index.html">¬øQu√© regalos esperan los hombres el 23 de febrero? Resultados de la encuesta</a></li>
<li><a href="../440984/index.html">C√≥mo nos afectar√° la reducci√≥n de la tasa de adquisici√≥n (tarjetahabientes) - 2</a></li>
<li><a href="../440986/index.html">Locomotoras: lo que sabemos sobre vagones autopropulsados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>