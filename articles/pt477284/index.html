<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèª üëèüèø üë®‚Äçüè´ Por que o JavaScript √© necess√°rio no modo estrito? ‚úãüèø üìé ‚öôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O modo estrito √© uma parte importante do JavaScript moderno. √â esse modo que permite que os desenvolvedores usem sintaxe mais limitada que a padr√£o. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por que o JavaScript √© necess√°rio no modo estrito?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/477284/">  O modo estrito √© uma parte importante do JavaScript moderno.  √â esse modo que permite que os desenvolvedores usem sintaxe mais limitada que a padr√£o. <br><br>  A sem√¢ntica do modo estrito √© diferente do modo n√£o estrito tradicional, que √†s vezes √© chamado de "modo superficial".  Nesse modo, as regras de sintaxe do idioma n√£o s√£o t√£o rigorosas e, quando ocorrem alguns erros, o sistema n√£o notifica o usu√°rio sobre eles.  Ou seja, os erros podem ser ignorados e o c√≥digo em que s√£o feitos pode ser executado ainda mais.  Isso pode levar a resultados inesperados de execu√ß√£o de c√≥digo. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/477284/"><img src="https://habrastorage.org/webt/cm/tk/0u/cmtk0u9w_n1ifbiykbgvswupxcm.jpeg"></a> <br><br>  O modo estrito introduz algumas altera√ß√µes na sem√¢ntica do JavaScript.  Impede que o sistema feche os olhos para erros, lan√ßando exce√ß√µes apropriadas.  Isso faz com que a execu√ß√£o do programa pare. <br><br>  Al√©m disso, o modo estrito ajuda a escrever programas nos quais n√£o h√° defici√™ncias que impedem que os mecanismos JS otimizem o c√≥digo.  Al√©m disso, neste modo, √© proibido o uso de elementos de sintaxe que possam obter um significado especial em vers√µes futuras do idioma. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Recursos do uso do modo estrito</font> </h2><br>  O modo estrito pode ser aplicado a fun√ß√µes individuais ou a um script inteiro.  Ele n√£o pode ser aplicado apenas a instru√ß√µes individuais ou a blocos de c√≥digo entre chaves.  Para usar o modo estrito no n√≠vel de todo o script, no in√≠cio do arquivo, antes de qualquer outro comando, voc√™ deve colocar o <code>"use strict"</code> ou <code>'use strict'</code> constru√ß√£o <code>'use strict'</code> . <br><br>  Se o projeto tiver alguns scripts que n√£o usam o modo estrito e outros que usam esse modo, pode acontecer que esses scripts sejam mesclados. <br><br>  Isso levar√° ao fato de que o c√≥digo que n√£o se destina a ser executado no modo estrito estar√° nesse estado quando o sistema tentar execut√°-lo no modo estrito.  O inverso tamb√©m √© poss√≠vel - o c√≥digo escrito para o modo estrito entrar√° no modo n√£o estrito.  Portanto, √© melhor n√£o misturar scripts "estritos" e "n√£o estritos". <br><br>  Como j√° mencionado, o modo estrito pode ser aplicado a fun√ß√µes individuais.  Para fazer isso - a constru√ß√£o <code>"use strict"</code> ou <code>'use strict'</code> deve ser colocada na parte superior do corpo da fun√ß√£o, antes de qualquer outro comando.  O modo estrito com essa abordagem se aplica a tudo que √© colocado no corpo da fun√ß√£o, incluindo fun√ß√µes aninhadas. <br><br>  Por exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> strictFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> nestedFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{    <span class="hljs-comment"><span class="hljs-comment">//        } }</span></span></code> </pre> <br>  Nos m√≥dulos JavaScript que apareceram no padr√£o ES2015, o modo estrito √© ativado por padr√£o.  Portanto, ao trabalhar com eles, voc√™ n√£o precisa inclu√≠-lo explicitamente. <br><br><h2>  <font color="#3AC1EF">Altera√ß√µes introduzidas no c√≥digo JS pelo modo estrito</font> </h2><br>  O modo estrito afeta a sintaxe do c√≥digo e a maneira como o c√≥digo se comporta durante a execu√ß√£o do programa.  Erros no c√≥digo s√£o convertidos em exce√ß√µes.  O fato de que no modo silencioso trava silenciosamente no modo estrito causa uma mensagem de erro.  √â semelhante √† maneira como o sistema responde aos erros de sintaxe no modo lax.  No modo estrito, o trabalho com vari√°veis ‚Äã‚Äã√© simplificado, o uso da fun√ß√£o <code>eval</code> e do objeto de <code>arguments</code> √© fortemente regulamentado, e o trabalho com constru√ß√µes que podem ser implementadas em vers√µes futuras da linguagem √© simplificado. <br><br><h3>  <font color="#3AC1EF">‚ñç Converter erros silenciosos em exce√ß√µes</font> </h3><br>  Erros silenciosos s√£o convertidos no modo estrito em exce√ß√µes.  No modo relaxado, o sistema n√£o responde explicitamente a esses erros.  No modo estrito, a presen√ßa de tais erros leva √† inoperabilidade do c√≥digo. <br><br>  Portanto, gra√ßas a isso, √© dif√≠cil cometer o erro de declarar acidentalmente uma vari√°vel global, pois vari√°veis ‚Äã‚Äãe constantes no modo estrito n√£o podem ser declaradas sem o uso das diretivas <code>var</code> , <code>let</code> ou <code>const</code> .  Como resultado, a cria√ß√£o de vari√°veis ‚Äã‚Äãsem essas diretivas levar√° √† inoperabilidade do programa.  Por exemplo, tentar executar o seguinte c√≥digo lan√ßar√° uma exce√ß√£o <code>ReferenceError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; badVariable = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Esse c√≥digo n√£o pode ser executado no modo estrito, pois se o modo estrito fosse desativado, criaria a vari√°vel global <code>badVariable</code> .  O modo estrito protege o programador de criar inadvertidamente vari√°veis ‚Äã‚Äãglobais. <br><br>  Uma tentativa de executar qualquer c√≥digo que, no modo normal, simplesmente n√£o funcione, agora gera uma exce√ß√£o.  Os erros s√£o considerados quaisquer constru√ß√µes sint√°ticas incorretas que foram simplesmente ignoradas no modo lax. <br><br>  Portanto, por exemplo, no modo estrito, voc√™ n√£o pode executar opera√ß√µes de atribui√ß√£o de valor em entidades somente leitura, como <code>arguments</code> , <code>NaN</code> ou <code>eval</code> . <br><br>  No modo estrito, uma exce√ß√£o, por exemplo, ser√° lan√ßada nos seguintes casos: <br><br><ul><li>  uma tentativa de atribuir um valor a uma propriedade somente leitura, como algum tipo de propriedade global regrav√°vel; </li><li>  uma tentativa de escrever um valor para uma propriedade que possui apenas um getter; </li><li>  Uma tentativa de escrever algo em uma propriedade de um objeto n√£o extens√≠vel. </li></ul><br>  Aqui est√£o exemplos de constru√ß√µes de sintaxe que levam a exce√ß√µes no modo estrito: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Infinity</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); obj.foo = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj2 = { get foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">17</span></span>; } }; obj2.foo = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fixedObj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(fixedObj); fixed.bar= <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Tentar executar esses fragmentos de c√≥digo no modo estrito lan√ßar√° uma exce√ß√£o <code>TypeError</code> .  Por exemplo, <code>undefined</code> e <code>Infinity</code> s√£o entidades globais cujos valores n√£o podem ser substitu√≠dos, e a propriedade <code>foo</code> do objeto <code>obj</code> n√£o suporta reescrita.  A propriedade <code>foo</code> do <code>obj2</code> tem apenas um getter.  O objeto <code>fixedObj</code> tornado n√£o extens√≠vel usando o m√©todo <code>Object.preventExtensions</code> . <br><br>  Uma tentativa de excluir uma <code>TypeError</code> n√£o <code>TypeError</code> tamb√©m resultar√° em <code>TypeError</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype</code> </pre> <br>  O modo estrito pro√≠be atribuir propriedades com o mesmo nome a um objeto.  Como resultado, uma tentativa de executar o seguinte c√≥digo resultar√° em um erro de sintaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> o = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> };</code> </pre> <br>  O modo estrito requer que os nomes dos par√¢metros das fun√ß√µes sejam exclusivos.  No modo n√£o estrito, se, por exemplo, dois par√¢metros de fun√ß√£o tiverem o mesmo nome, <code>one</code> , ao passar a fun√ß√£o de argumento, o valor do par√¢metro ser√° o que caiu no argumento declarado por √∫ltimo. <br><br>  No modo estrito, os par√¢metros de fun√ß√µes com o mesmo nome s√£o proibidos.  Como resultado, uma tentativa de executar o seguinte c√≥digo resultar√° em um erro de sintaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multiply = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, x, y</span></span></span><span class="hljs-function">) =&gt;</span></span> x*x*y;</code> </pre> <br>  No modo estrito, voc√™ n√£o pode usar a nota√ß√£o octal de n√∫meros, precedendo o n√∫mero com zero.  Isso n√£o est√° na especifica√ß√£o, mas esse recurso √© suportado pelos navegadores. <br><br>  Esse estado de coisas confunde os desenvolvedores, for√ßando-os a acreditar que o 0 que antecede o n√∫mero √© simplesmente ignorado, sem muito sentido.  No modo estrito, tentar usar um n√∫mero no in√≠cio igual a 0 resultar√° em um erro de sintaxe. <br><br>  O modo estrito tamb√©m pro√≠be o uso de constru√ß√µes que impedem a otimiza√ß√£o.  O int√©rprete, antes de executar a otimiza√ß√£o do c√≥digo, precisa saber que a vari√°vel √© armazenada exatamente onde, de acordo com o int√©rprete, √© armazenada.  No modo estrito, coisas que interferem nas otimiza√ß√µes s√£o proibidas. <br><br>  Um exemplo dessa proibi√ß√£o diz respeito √† declara√ß√£o <code>with</code> .  Se voc√™ usar esta instru√ß√£o, isso impedir√° que o interpretador JS descubra a qual vari√°vel ou a qual propriedade estamos nos referindo, pois √© poss√≠vel que uma entidade com o mesmo nome exista fora e dentro do bloco da instru√ß√£o <code>with</code> . <br><br>  Suponha que exista um c√≥digo como este: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (obj) {  x; }</code> </pre> <br>  O int√©rprete n√£o poder√° descobrir se a vari√°vel <code>x</code> localizada dentro do bloco <code>with</code> se refere √† vari√°vel externa <code>x</code> ou √† propriedade <code>obj.x</code> do objeto <code>obj</code> . <br><br>  Como resultado, n√£o est√° claro exatamente onde o valor <code>x</code> estar√° localizado na mem√≥ria.  Para se livrar de tais ambiguidades, no modo estrito √© proibido o uso da declara√ß√£o <code>with</code> .  Vamos ver o que acontece se voc√™ tentar executar o seguinte c√≥digo no modo estrito: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (obj) {  x; }</code> </pre> <br>  O resultado desta tentativa ser√° um erro de sintaxe. <br><br>  Mesmo no modo estrito, √© proibido declarar vari√°veis ‚Äã‚Äãno c√≥digo passado para o m√©todo <code>eval</code> . <br><br>  Por exemplo, no modo normal, um comando no formato <code>eval('let x')</code> resultar√° na declara√ß√£o da vari√°vel <code>x</code> .  Isso permite que os programadores ocultem declara√ß√µes de vari√°veis ‚Äã‚Äãem strings, o que pode levar √† substitui√ß√£o das defini√ß√µes das mesmas vari√°veis ‚Äã‚Äãfora de <code>eval</code> . <br><br>  Para evitar isso, no modo estrito, √© proibido declarar vari√°veis ‚Äã‚Äãno c√≥digo passadas como uma string para o m√©todo <code>eval</code> . <br><br>  O modo estrito tamb√©m pro√≠be a exclus√£o de vari√°veis ‚Äã‚Äãregulares.  Como resultado, a tentativa de executar o seguinte c√≥digo resultar√° em um erro de sintaxe: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> x;</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Proibindo constru√ß√µes de sintaxe incorretas</font> </h3><br>  No modo estrito, <code>arguments</code> proibido o uso incorreto de avalia√ß√£o e <code>arguments</code> .  Esta √© uma proibi√ß√£o de todos os tipos de manipula√ß√£o com eles.  Por exemplo, isso √© algo como atribuir novos valores a eles, usando seus nomes como nomes de vari√°veis, fun√ß√µes e par√¢metros de fun√ß√µes. <br><br>  Aqui est√£o exemplos de uso indevido de avalia√ß√£o e <code>arguments</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>++; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>--; ++<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>--; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = { set p(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) { } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">eval</span></span></span><span class="hljs-function">) </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arguments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eval</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">=&gt;</span></span>{ }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>(<span class="hljs-string"><span class="hljs-string">'arguments'</span></span>, <span class="hljs-string"><span class="hljs-string">"'use strict'; return 1;"</span></span>);</code> </pre> <br>  No modo estrito, voc√™ n√£o pode criar aliases para o objeto de <code>arguments</code> e definir novos valores de <code>arguments</code> por meio desses aliases. <br><br>  No modo normal, se o primeiro par√¢metro da fun√ß√£o for <code>a</code> , a configura√ß√£o do valor de <code>a</code> no c√≥digo da fun√ß√£o tamb√©m levar√° a uma altera√ß√£o no valor nos <code>arguments[0]</code> .  No modo estrito, os <code>arguments</code> sempre conter√£o a lista de argumentos com os quais a fun√ß√£o foi chamada. <br><br>  Suponha que voc√™ tenha o seguinte c√≥digo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fn = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  a = <span class="hljs-number"><span class="hljs-number">2</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [a, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]]; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br>  O console receber√° <code>[2,1]</code> .  Isso ocorre porque escrever um valor de 2 em <code>a</code> n√£o escreve um valor de 2 em <code>arguments[0]</code> . <br><br><h3>  <font color="#3AC1EF">PtOtimize o desempenho</font> </h3><br>  No modo estrito, a propriedade <code>arguments.callee</code> n√£o √© suportada.  No modo normal, ele retorna o nome da fun√ß√£o pai da fun√ß√£o cuja propriedade <code>callee</code> dos objetos de <code>arguments</code> que estamos examinando. <br><br>  O suporte a essa propriedade interfere nas otimiza√ß√µes, como fun√ß√µes embutidas, uma vez que o uso de <code>arguments.callee</code> requer a disponibilidade de uma refer√™ncia a uma fun√ß√£o n√£o incorporada ao acessar esta propriedade.  No modo estrito, o uso de <code>arguments.callee</code> gera uma exce√ß√£o <code>TypeError</code> . <br><br>  No modo estrito, a <code>this</code> nem sempre precisa ser um objeto.  Em circunst√¢ncias normais, se <code>this</code> fun√ß√£o estiver vinculada, usando <code>call</code> , <code>apply</code> ou <code>bind</code> , a algo que n√£o seja um objeto, a um valor de um tipo primitivo como <code>undefined</code> , <code>null</code> , <code>number</code> ou <code>boolean</code> , esse valor dever√° ser um objeto. <br><br>  Se o contexto <code>this</code> mudar para algo que n√£o √© um objeto, um objeto global substituir√°.  Por exemplo, <code>window</code> .  Isso significa que, se voc√™ chamar uma fun√ß√£o, definindo <code>this</code> como um valor que n√£o √© um objeto, em vez desse valor, uma refer√™ncia ao objeto global ser√° inclu√≠da. <br><br>  Considere um exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">'use strict'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn() === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.call(<span class="hljs-number"><span class="hljs-number">2</span></span>) === <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) === <span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.call(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn.bind(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)() === <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Todos os comandos <code>console.log</code> ser√£o emitidos como <code>true</code> , porque no modo estrito o valor <code>this</code> na fun√ß√£o n√£o √© automaticamente substitu√≠do por uma refer√™ncia ao objeto global se <code>this</code> definido como um valor que n√£o √© um objeto. <br><br><h3>  <font color="#3AC1EF">Changes Altera√ß√µes relacionadas √† seguran√ßa</font> </h3><br>  No modo estrito, voc√™ n√£o pode tornar p√∫blicas as propriedades da fun√ß√£o de <code>caller</code> e <code>arguments</code> .  O fato √© que o <code>caller</code> , por exemplo, pode dar acesso √† fun√ß√£o que chamou a fun√ß√£o cuja propriedade do <code>caller</code> estamos acessando. <br><br>  O objeto <code>arguments</code> armazena os argumentos passados ‚Äã‚Äãpara a fun√ß√£o quando ela foi chamada.  Por exemplo, se tivermos uma fun√ß√£o <code>fn</code> , isso significa que, por meio de <code>fn.caller</code> voc√™ pode acessar a fun√ß√£o que chamou a fun√ß√£o e, usando <code>fn.arguments</code> pode ver os argumentos passados ‚Äã‚Äãpara <code>fn</code> quando foi chamado. <br><br>  Esses recursos representam um risco potencial √† seguran√ßa.  Como resultado, o acesso a essas propriedades √© proibido no modo estrito. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">secretFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>;  secretFunction.caller;  secretFunction.arguments; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restrictedRunner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> secretFunction(); } restrictedRunner();</code> </pre> <br>  No exemplo anterior, n√£o podemos, no modo estrito, acessar <code>secretFunction.caller</code> e <code>secretFunction.arguments</code> .  O fato √© que essas propriedades podem ser usadas para obter uma pilha de chamadas de fun√ß√£o.  Se voc√™ tentar executar esse c√≥digo, uma exce√ß√£o <code>TypeError</code> ser√° <code>TypeError</code> . <br><br>  No modo estrito, identificadores que podem ser usados ‚Äã‚Äãem vers√µes futuras do JavaScript n√£o podem ser usados ‚Äã‚Äãpara nomear vari√°veis ‚Äã‚Äãou propriedades de objetos.  Por exemplo, estamos falando dos seguintes identificadores: <code>implements</code> , <code>interface</code> , <code>let</code> , <code>package</code> , <code>private</code> , <code>protected</code> , <code>public</code> , <code>static</code> e <code>yield</code> . <br><br>  No ES2015 e em vers√µes posteriores do padr√£o, esses identificadores se tornaram palavras reservadas.  E eles n√£o podem ser usados ‚Äã‚Äãpara nomear vari√°veis ‚Äã‚Äãou propriedades no modo estrito. <br><br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  O modo estrito √© um padr√£o que existe h√° muitos anos.  Goza de suporte extremamente amplo ao navegador.  Problemas com o c√≥digo de modo estrito podem ocorrer apenas em navegadores mais antigos, como o Internet Explorer. <br><br>  Navegadores modernos n√£o devem ter dificuldades com o modo JavaScript estrito.  Como resultado, podemos dizer que esse modo deve ser usado para evitar erros "silenciosos" e aumentar a seguran√ßa do aplicativo.  Erros silenciosos s√£o convertidos em exce√ß√µes que impedem a execu√ß√£o de programas e, em termos de melhoria da seguran√ßa, por exemplo, podem ser observados mecanismos de modo estrito que restringem a avalia√ß√£o e impedem o acesso √† pilha de chamadas de fun√ß√£o.  Al√©m disso, o uso do modo estrito facilita a otimiza√ß√£o do c√≥digo do mecanismo JS e for√ßa o programador a manipular cuidadosamente palavras reservadas que podem ser usadas em vers√µes futuras do JavaScript. <br><br>  <b>Caros leitores!</b>  Voc√™ usa o modo estrito ao escrever o c√≥digo JS para seus projetos? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477284/">https://habr.com/ru/post/pt477284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477272/index.html">Primeira introdu√ß√£o ao AssemblyScript</a></li>
<li><a href="../pt477274/index.html">Como voc√™ se livra do c√≥digo CSS n√£o utilizado? Parte 1</a></li>
<li><a href="../pt477276/index.html">Como voc√™ se livra do c√≥digo CSS n√£o utilizado? Parte 2</a></li>
<li><a href="../pt477278/index.html">Teste de front-end</a></li>
<li><a href="../pt477282/index.html">Cria√ß√£o de perfil do c√≥digo do projeto Go e resolu√ß√£o de problemas de aloca√ß√£o de mem√≥ria</a></li>
<li><a href="../pt477286/index.html">Axios ou Fetch: o que usar em 2019?</a></li>
<li><a href="../pt477288/index.html">John Lewis na confer√™ncia Undoing Aging 2018</a></li>
<li><a href="../pt477290/index.html">Eventos digitais em Moscou, de 25 de novembro a 1 de dezembro</a></li>
<li><a href="../pt477292/index.html">Eventos digitais em S√£o Petersburgo, de 25 de novembro a 1 de dezembro</a></li>
<li><a href="../pt477294/index.html">Python para IA: uma partida feita no c√©u</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>