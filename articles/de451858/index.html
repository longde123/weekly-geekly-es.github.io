<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👩‍👧‍👦 👨🏾‍🍳 👨🏻‍💼 Erstellen eines einfachen Cache-basierten Leistungsschalters im Frühjahr 👨‍👨‍👧‍👦 🥑 ⭐️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel richtet sich an Benutzer, die einen effektiven Cache in ihrer Anwendung verwenden und nicht nur der Anwendung, sondern der gesamten Umg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines einfachen Cache-basierten Leistungsschalters im Frühjahr</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451858/">  Dieser Artikel richtet sich an Benutzer, die einen effektiven Cache in ihrer Anwendung verwenden und nicht nur der Anwendung, sondern der gesamten Umgebung Stabilität verleihen möchten, indem sie dem Projekt einfach eine Klasse hinzufügen. <br><br>  Wenn Sie sich selbst erkennen, lesen Sie weiter. <br><br><h2>  Was ist ein Leistungsschalter? </h2><br><img src="https://habrastorage.org/webt/w-/bn/xj/w-bnxjrhl9n7nnjby9grw571koa.png" alt="Rahmen aus dem Film Zurück in die Zukunft"><br><a name="habracut"></a><br>  Das Thema ist abgedroschen wie die Welt, und ich werde Sie nicht langweilen, die Entropie erhöhen und dasselbe wiederholen.  Aus meiner Sicht hat Martin Fowler hier am besten gesprochen, aber ich werde versuchen, die Definition in einen Satz zu fassen: <br>  <i>Funktionalität, die wissentlich zum Scheitern verurteilte Anfragen an einen nicht verfügbaren Dienst verhindert und es ihm ermöglicht, „auf die Knie zu gehen“ und den normalen Betrieb fortzusetzen</i> . <br><br>  Im Idealfall sollte der Leistungsschalter (im Folgenden: CB) Ihre Anwendung nicht beschädigen, um zum Scheitern verurteilte Anforderungen zu verhindern.  Stattdessen empfiehlt es sich, wenn nicht die aktuellsten Daten, aber immer noch relevant („nicht schlecht“) oder, falls dies nicht möglich ist, einen Standardwert zurückzugeben. <br><br><h2>  Ziele </h2><br>  Wir heben die Hauptsache hervor: <br><br><ol><li>  Es ist erforderlich, die Wiederherstellung der Datenquelle zuzulassen und die Abfragen für eine Weile anzuhalten </li><li>  Wenn Sie Anforderungen an den Zieldienst stoppen möchten, müssen Sie, wenn nicht die neuesten, aber dennoch relevanten Daten angeben </li><li>  Wenn der Zieldienst nicht verfügbar ist und keine relevanten Daten vorhanden sind, geben Sie eine Verhaltensstrategie an (Rückgabe des Standardwerts oder einer anderen für einen bestimmten Fall geeigneten Strategie). </li></ol><br><h2>  Implementierungsmechanismus </h2><br><h3>  Fall: Service ist verfügbar (erste Anfrage) </h3><br><ol><li>  Gehen wir zum Cache.  Per Schlüssel (CRT siehe unten).  Wir sehen, dass sich nichts im Cache befindet </li><li>  Wir gehen zum Zieldienst.  Wir bekommen den Wert </li><li>  Wir speichern den Wert im Cache und setzen ihn auf eine solche TTL, die die maximal mögliche Zeit abdeckt, in der der Zieldienst nicht verfügbar ist. Gleichzeitig sollte er jedoch den Zeitraum der Relevanz der Daten nicht überschreiten, die Sie dem Client im Falle eines Verbindungsverlusts mit dem Zieldienst bereitstellen möchten </li><li>  Die Cache-Aktualisierungszeit (CRT) wird im Cache für den Wert aus Abschnitt 3 gespeichert - die Zeit, nach der Sie versuchen müssen, zum Zieldienst zu wechseln und den Wert zu aktualisieren </li><li>  Geben Sie den Wert von Punkt 2 an den Benutzer zurück </li></ol><br><h3>  Fall: CRT ist nicht abgelaufen </h3><br><ol><li>  Gehen wir zum Cache.  Durch den Schlüssel finden wir CRT.  Wir sehen, dass es relevant ist </li><li>  Holen Sie sich den Wert dafür aus dem Cache. </li><li>  Geben Sie den Wert an den Benutzer zurück. </li></ol><br><h3>  Fall: CRT abgelaufen, Zieldienst verfügbar </h3><br><ol><li>  Gehen wir zum Cache.  Durch den Schlüssel finden wir CRT.  Wir sehen, dass es irrelevant ist </li><li>  Wir gehen zum Zieldienst.  Wir bekommen den Wert </li><li>  Aktualisieren des Werts im Cache und seiner TTL </li><li>  Aktualisieren Sie die CRT dafür, indem Sie Cache Refresh Period (CRP) hinzufügen. Dies ist der Wert, der der CRT hinzugefügt werden muss, um die nächste CRT zu erhalten </li><li>  Geben Sie den Wert an den Benutzer zurück. </li></ol><br><h3>  Fall: CRT abgelaufen, Zieldienst nicht verfügbar </h3><br><ol><li>  Gehen wir zum Cache.  Durch den Schlüssel finden wir CRT.  Wir sehen, dass es irrelevant ist </li><li>  Wir gehen zum Zieldienst.  Er ist nicht verfügbar </li><li>  Holen Sie sich den Wert aus dem Cache.  Nicht die frischeste (mit einer faulen CRT), aber immer noch relevant, da die TTL noch nicht abgelaufen ist </li><li>  Wir geben es an den Benutzer zurück </li></ol><br><h3>  Fall: CRT abgelaufen, Zieldienst nicht verfügbar, nichts im Cache </h3><br><ol><li>  Gehen wir zum Cache.  Durch den Schlüssel finden wir CRT.  Wir sehen, dass es irrelevant ist </li><li>  Wir gehen zum Zieldienst.  Er ist nicht verfügbar </li><li>  Holen Sie sich den Wert aus dem Cache.  Er ist nicht da </li><li>  Wir versuchen, für solche Fälle eine spezielle Strategie anzuwenden.  Geben Sie beispielsweise einen Standardwert für ein angegebenes Feld oder einen speziellen Wert vom Typ "Diese Informationen sind derzeit nicht verfügbar" zurück.  Wenn dies möglich ist, ist es im Allgemeinen besser, etwas zurückzugeben und die Anwendung nicht zu beschädigen.  Wenn dies nicht möglich ist, müssen Sie die Ausnahmestrategie und die schnelle Antwort auf den Ausnahmebenutzer anwenden. </li></ol><br><h2>  Was wir verwenden werden </h2><br>  Ich verwende Spring Boot 1.5 in meinem Projekt und habe noch keine Zeit gefunden, auf die zweite Version zu aktualisieren. <br><br>  Daß der Artikel nicht zweimal länger ausfiel, werde ich Lombok verwenden. <br><br>  Als Schlüsselwertspeicher (im Folgenden einfach als KV bezeichnet) verwende ich Redis 5.0.3, bin mir aber sicher, dass Hazelcast oder ein Analogon dies tun wird.  Die Hauptsache ist, dass es eine Implementierung der CacheManager-Schnittstelle gibt.  In meinem Fall ist dies RedisCacheManager von Spring-Boot-Starter-Data-Redis. <br><br><h2>  Implementierung </h2><br>  Oben wurden im Abschnitt „Implementierungsmechanismus“ zwei wichtige Definitionen vorgenommen: CRT und CRP.  Ich werde sie noch einmal ausführlicher schreiben, weil  Sie sind sehr wichtig für das Verständnis des folgenden Codes: <br><br>  Cache Refresh Time ( <b>CRT</b> ) ist ein separater Eintrag in KV (Schlüssel + Postfix „_crt“), der die Zeit anzeigt, zu der es Zeit ist, zum Zieldienst zu gehen, um neue Daten zu erhalten.  Im Gegensatz zu TTL bedeutet das Einsetzen der CRT nicht, dass Ihre Daten „faul“ sind, sondern nur, dass sie im Zieldienst wahrscheinlich aktueller werden.  Wurde frisch - na ja, wenn nicht, und der Strom wird sinken. <br><br>  Cache Refresh Period ( <b>CRP</b> ) ist ein Wert, der der CRT nach dem Abrufen des Zieldienstes hinzugefügt wird (es spielt keine Rolle, ob er erfolgreich ist oder nicht).  Dank ihr hat ein Ferndienst die Möglichkeit, im Falle eines Sturzes „zu Atem zu kommen“ und seine Arbeit wiederherzustellen. <br><br>  Daher beginnen wir traditionell mit dem Entwurf der Hauptschnittstelle.  Dadurch müssen Sie mit dem Cache arbeiten, wenn Sie CB-Logik benötigen.  Es sollte so einfach wie möglich sein: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CircuitBreakerService</span></span></span><span class="hljs-class"> </span></span>{ &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStableValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StableValueParameter parameter)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evictValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EvictValueParameter parameter)</span></span></span></span>; }</code> </pre> <br>  Schnittstellenparameter: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StableValueParameter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String cachePrefix; <span class="hljs-comment"><span class="hljs-comment">//    private String objectCacheKey; private long crpInSeconds; // Cache Refresh Period private Supplier&lt;T&gt; targetServiceAction; //      private DisasterStrategy disasterStrategy; //   : CRT ,   ,     public StableValueParameter( String cachePrefix, String objectCacheKey, long crpInSeconds, Supplier&lt;T&gt; targetServiceAction ) { this.cachePrefix = cachePrefix; this.objectCacheKey = objectCacheKey; this.crpInSeconds = crpInSeconds; this.targetServiceAction = targetServiceAction; this.disasterStrategy = new ThrowExceptionDisasterStrategy(); } }</span></span></code> </pre><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Getter</span></span> <span class="hljs-meta"><span class="hljs-meta">@AllArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EvictValueParameter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String cachePrefix; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String objectCacheKey; }</code> </pre><br>  So werden wir es verwenden: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AccountDataResponse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String accountId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> StableValueParameter&lt;?&gt; parameter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StableValueParameter&lt;&gt;( ACCOUNT_CACHE_PREFIX, accountId, properties.getCrpInSeconds(), () -&gt; bankClient.findById(accountId) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> circuitBreakerService.getStableValue(parameter); }</code> </pre><br>  Wenn Sie den Cache leeren müssen, dann: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evictAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String accountId)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> EvictValueParameter parameter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EvictValueParameter( ACCOUNT_CACHE_PREFIX, accountId ); circuitBreakerService.evictValue(parameter); }</code> </pre><br>  Das Interessanteste ist nun die Implementierung (erklärt in den Kommentaren im Code): <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStableValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StableValueParameter parameter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cache cache = cacheManager.getCache(parameter.getCachePrefix()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> logAndThrowUnexpectedCacheMissing(parameter.getCachePrefix(), parameter.getObjectCacheKey()); } <span class="hljs-comment"><span class="hljs-comment">//   .   CRT final String crtKey = parameter.getObjectCacheKey() + CRT_CACHE_POSTFIX; //  CRT  ,    final LocalDateTime crt = Optional.ofNullable(cache.get(crtKey, LocalDateTime.class)) .orElseGet(() -&gt; DateTimeUtils.now().minusSeconds(1)); if (DateTimeUtils.now().isBefore(crt)) { //  CRT   ,     final Optional&lt;T&gt; valueFromCache = getFromCache(parameter, cache); if (valueFromCache.isPresent()) { return valueFromCache.get(); } } //  CRT  ,        return getFromTargetServiceAndUpdateCache(parameter, cache, crtKey, crt); } private static &lt;T&gt; Optional&lt;T&gt; getFromCache(StableValueParameter parameter, Cache cache) { return (Optional&lt;T&gt;) Optional.ofNullable(cache.get(parameter.getObjectCacheKey())) .map(Cache.ValueWrapper::get); }</span></span></code> </pre><br>  Wenn der Zieldienst nicht verfügbar ist, versuchen Sie, die noch relevanten Daten aus dem Cache abzurufen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromTargetServiceAndUpdateCache</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( StableValueParameter parameter, Cache cache, String crtKey, LocalDateTime crt )</span></span></span><span class="hljs-function"> </span></span>{ T result; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = getFromTargetService(parameter); } <span class="hljs-comment"><span class="hljs-comment">/* Circuit breaker exceptions */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (WebServiceIOException ex) { log.warn( <span class="hljs-string"><span class="hljs-string">"[CircuitBreaker] Service responded with error: {}. Try get from cache {}: {}"</span></span>, ex.getMessage(), parameter.getCachePrefix(), parameter.getObjectCacheKey()); result = getFromCacheOrDisasterStrategy(parameter, cache); } cache.put(parameter.getObjectCacheKey(), result); cache.put(crtKey, crt.plusSeconds(parameter.getCrpInSeconds())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromTargetService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StableValueParameter parameter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) parameter.getTargetServiceAction().get(); }</code> </pre><br>  Wenn sich keine tatsächlichen Daten im Cache befanden (sie wurden von TTL gelöscht und der Zieldienst ist immer noch nicht verfügbar), verwenden wir DisasterStrategy: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromCacheOrDisasterStrategy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StableValueParameter parameter, Cache cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) getFromCache(parameter, cache).orElseGet(() -&gt; parameter.getDisasterStrategy().getValue()); }</code> </pre><br>  Das Entfernen aus dem Cache ist nichts Interessantes, ich werde es hier nur der Vollständigkeit halber geben: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFromCacheOrDisasterStrategy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StableValueParameter parameter, Cache cache)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T) getFromCache(parameter, cache).orElseGet(() -&gt; parameter.getDisasterStrategy().getValue()); }</code> </pre><br>  Das Entfernen aus dem Cache ist nichts Interessantes, ich werde es hier nur der Vollständigkeit halber geben: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evictValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EvictValueParameter parameter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Cache cache = cacheManager.getCache(parameter.getCachePrefix()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { logAndThrowUnexpectedCacheMissing(parameter.getCachePrefix(), parameter.getObjectCacheKey()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String crtKey = parameter.getObjectCacheKey() + CRT_CACHE_POSTFIX; cache.evict(crtKey); }</code> </pre><br><h2>  Katastrophenstrategie </h2><br><img src="https://habrastorage.org/webt/ka/fw/_0/kafw_0jvueyuguwcdbjz4eksnz8.png" alt="Rahmen aus dem Film Zurück in die Zukunft"><br><br>  Dies ist in der Tat die Logik, die auftritt, wenn die CRT abläuft, der Zieldienst nicht verfügbar ist und sich nichts im Cache befindet. <br><br>  Ich wollte diese Logik separat beschreiben, weil  Viele denken nicht darüber nach, wie sie es umsetzen sollen.  Aber genau das macht unser System wirklich stabil. <br><br>  Wollen Sie nicht das Gefühl des Stolzes auf Ihre Idee verspüren, wenn alles, was nur scheitern kann, abgelehnt wird und Ihr System immer noch funktioniert?  Auch wenn zum Beispiel im Feld "Preis" nicht die tatsächlichen Kosten der Ware angezeigt werden, sondern die Aufschrift "aktuell spezifiziert", aber wie viel besser ist dies als die Antwort "500 Service ist nicht verfügbar".  Immerhin zum Beispiel die restlichen 10 Felder: Produktbeschreibung usw.  Du bist zurückgekehrt.  Inwieweit ändert sich die Qualität eines solchen Dienstes? .. Mein Aufruf ist es, mehr auf Details zu achten, um sie besser zu machen. <br><br>  Den lyrischen Exkurs beenden.  Die Strategie-Schnittstelle sieht also wie folgt aus: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisasterStrategy</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Sie sollten die Implementierung je nach Einzelfall auswählen.  Wenn Sie beispielsweise einen Standardwert zurückgeben können, können Sie Folgendes tun: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultValueDisasterStrategy</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisasterStrategy</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"   "</span></span>; } }</code> </pre><br>  Wenn Sie in einem bestimmten Fall überhaupt nichts zurückgeben müssen, können Sie eine Ausnahme auslösen: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThrowExceptionDisasterStrategy</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DisasterStrategy</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Object</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CircuitBreakerNullValueException(<span class="hljs-string"><span class="hljs-string">"Ops! Service is down and there's null value in cache"</span></span>); } }</code> </pre><br>  In diesem Fall wird die CRT nicht inkrementiert und die nächste Anforderung folgt erneut dem Zieldienst. <br><br><h2>  Fazit </h2><br>  Ich halte mich an den folgenden Standpunkt: Wenn Sie die Möglichkeit haben, eine vorgefertigte Lösung zu verwenden und keine Aufregung zu machen, obwohl dies in diesem Artikel einfach ist, aber dennoch Fahrrad fährt, tun Sie dies.  Verwenden Sie diesen Artikel, um zu verstehen, wie es funktioniert, und nicht als Leitfaden für Maßnahmen. <br><br>  Es gibt so viele vorgefertigte Lösungen, insbesondere wenn Sie Spring Boot 2 wie Hystrix verwenden. <br><br>  Das Wichtigste zu verstehen ist, dass diese Lösung auf dem Cache basiert und ihre Effektivität der Effektivität des Caches entspricht.  Wenn der Cache unwirksam ist (wenige Treffer, viele Fehler), ist dieser Leistungsschalter gleichermaßen unwirksam: Jeder Cache-Fehler wird von einer Reise zum Zieldienst begleitet, der möglicherweise in diesem Moment in Qual und Qual ist und versucht, zu steigen. <br><br>  Stellen Sie sicher, dass Sie die Effektivität Ihres Caches messen, bevor Sie diesen Ansatz anwenden.  Dies kann durch "Cache-Trefferquote" = Treffer / (Treffer + Fehlschläge) erfolgen, es sollte zu 1 tendieren, nicht zu 0. <br><br>  Und ja, niemand stört Sie daran, mehrere CB-Sorten gleichzeitig in Ihrem Projekt zu behalten und diejenige zu verwenden, die das spezifische Problem am besten löst. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de451858/">https://habr.com/ru/post/de451858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de451842/index.html">Sich selbst zu finden</a></li>
<li><a href="../de451848/index.html">Automatisierung Verschlüsseln Sie die Verwaltung von SSL-Zertifikaten mithilfe der DNS-01-Challenge und AWS</a></li>
<li><a href="../de451852/index.html">Remote-Ausführung von beliebigem Code in RDP</a></li>
<li><a href="../de451854/index.html">Interview - 10 Fragen zu Swift. Teil 1</a></li>
<li><a href="../de451856/index.html">Installieren Sie openmeetings 5.0.0-M1. WEB-Konferenzen ohne Flash</a></li>
<li><a href="../de451860/index.html">Mathematiker haben den perfekten Weg gefunden, um Zahlen zu multiplizieren</a></li>
<li><a href="../de451862/index.html">Joe Diprims musikalischer Blitz: Ein Autodidakt stellt Tesla-Spulen zur Unterhaltung und zum Verdienen her</a></li>
<li><a href="../de451864/index.html">Kritische RCE-Sicherheitsanfälligkeit der EternalBlue-Ebene unter Windows erkannt</a></li>
<li><a href="../de451866/index.html">Wählen Sie die nächsten Knoten im Netzwerk</a></li>
<li><a href="../de451870/index.html">Moderne C ++ - Funktionen, die alle Programmierer kennen müssen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>