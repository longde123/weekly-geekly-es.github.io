<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍🤝‍👨🏽 👩🏽‍🎤 😹 Down the Rabbit Hole: A Story of One varnishreload Error - partie 1 👩‍👩‍👧 📝 🆚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Après avoir appuyé sur les boutons du clavier pendant les 20 dernières minutes, comme s'il tapait pour sa vie, ghostinushanka se tourne vers moi avec ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Down the Rabbit Hole: A Story of One varnishreload Error - partie 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475698/"><p> Après avoir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">appuyé</a> sur les boutons du clavier pendant les 20 dernières minutes, comme s'il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">tapait</a> pour sa vie, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ghostinushanka</a> se tourne vers moi avec un regard à moitié fou dans les yeux et un sourire malicieux: «Mec, je pense que je l'ai. </p><br><p> Regardez ça »- comme il pointe vers l'un des personnages à l'écran -« Je parie mon chapeau rouge que si nous ajoutons ce que je viens de vous envoyer ici »- comme il pointe vers un autre endroit dans le code -« il y aura plus d'erreur. " <br>  Légèrement perplexe et fatigué, je modifie l'expression sed que nous essayons de comprendre depuis un certain temps maintenant, enregistre le fichier et <code>systemctl varnish reload</code> .  Message d'erreur disparu ... </p><br><p>  "Ces e-mails que j'ai échangés avec le candidat", poursuit mon collègue, alors que son sourire se transforme en un sourire large et authentique, "Cela m'a soudainement frappé que c'est exactement le même problème!" </p><a name="habracut"></a><br><h3 id="how-it-all-began">  Comment tout a commencé </h3><br><p>  <em>Cet article suppose une certaine familiarité avec bash, awk et systemd.</em>  <em>Une certaine connaissance du vernis est bénéfique, mais pas obligatoire.</em> <em><br></em>  <em>Les horodatages des exemples de fragments ont été supprimés.</em> <em><br></em>  <em>Co-écrit avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">ghostinushanka</a> .</em> </p><br><p>  Le soleil brille à travers les fenêtres murales sur une autre chaude matinée d'automne, une tasse de liquide caféiné fraîchement moulu se trouve sur le côté du clavier, des écouteurs vocalisent la symphonie bien-aimée des sons couvrant le bruissement des claviers mécaniques autour et la première entrée dans le carnet de commandes sur le tableau kanban affiche de façon ludique le titre du ticket fatidique «Enquêter sur le vernis de rechargement <code>sh: echo: I/O error</code> lors de la mise en scène».  Chaque fois que le vernis est concerné, il n'y a pas de place pour l'erreur (s), même si celui-ci en particulier ne semble pas causer de problèmes réels. </p><br><p>  Pour ceux d'entre vous qui ne connaissent pas le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rechargement</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vernis</a> , il s'agit simplement d'un script shell utilisé pour recharger la configuration - également appelée VCL - du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">serveur de mise en cache Varnish</a> . </p><br><p>  Comme l'indique le titre du ticket, l'erreur a été rencontrée sur l'une des machines de transfert et j'étais presque sûr que le routage Varnish fonctionne dans l'environnement de transfert, donc je suppose que cela doit être un problème mineur.  Juste un message de sortie convivial écrit dans un flux fermé.  J'attrape le ticket, croyant fermement que je pourrai le marquer résolu en moins de 30 minutes, me tapoter dans le dos pour effacer une autre tâche banale et revenir à des choses plus importantes. </p><br><h3 id="hitting-the-wall-at-200kph">  Frapper le mur à 200 km / h </h3><br><p>  En ouvrant le fichier <code>varnishreload</code> sur l'un des serveurs affectés fonctionnant sur Debian Stretch, je trouve un script shell de moins de 200 lignes.  En le lisant brièvement, je ne vois rien de dangereux qui m'empêcherait d'exécuter le script depuis le terminal encore et encore.  Après tout, c'est de la mise en scène, même si ça casse, personne ne va se plaindre, enfin ... pas trop, c'est.  Je lance le script et observe, seulement pour découvrir qu'il n'y a pas d'erreurs à voir.  Quelques exécutions répétées supplémentaires pour m'assurer raisonnablement que je ne peux pas reproduire l'erreur sans effort supplémentaire et je commence à concevoir des plans pour modifier et plier l'environnement du script.  La fermeture de STDOUT pour le script (avec <code>&gt; &amp;-</code> ) aide-t-elle quelque chose?  Ou stderr?  Ni l'un ni l'autre. </p><br><p>  De toute évidence, systemd perturbe l'environnement d'une manière ou d'une autre, mais comment et ... pourquoi?  Je <code>varnishreload</code> vim et <code>varnishreload</code> le <code>varnishreload</code> du système, en ajoutant <code>set -x</code> juste sous le shebang, en espérant que la sortie détaillée de l'exécution du script éclairera la lumière. </p><br><p>  Le fichier est corrigé, donc je recharge le vernis, seulement pour voir que le changement avait complètement cassé le script ... La sortie est un désordre complet affichant des tonnes de code de style C et le tampon de défilement par défaut ne suffit pas pour trouver d'où il vient.  Je me sens confus.  La définition de l'option de débogage pour le script shell peut-elle interrompre le programme qu'il appelle?  Non, c'est impossible.  Un bug dans le shell?  Plusieurs scénarios possibles fonctionnant de manière extravagante dans différentes directions dans mon esprit.  Une tasse de boisson caféinée est finie instantanément, voyage rapide à la cuisine pour une recharge et c'est reparti.  J'ouvre le fichier et regarde attentivement le shebang: <code>#!/bin/sh</code> . </p><br><p>  Mais <code>/bin/sh</code> n'est sûrement qu'un lien symbolique vers bash, de sorte que le script est interprété en mode compatible POSIX, non?  Faux!  Le shell non interactif par défaut sur Debian est dash, et c'est exactement ce vers quoi <code>/bin/sh</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pointe</a> . </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ls -l /bin/sh lrwxrwxrwx 1 root root 4 Jan 24 2017 /bin/sh -&gt; dash</span></span></code> </pre> <br><p>  Ne serait-ce que pour le débogage, j'ai changé le shebang en <code>#!/bin/bash</code> , supprimé l' <code>set -x</code> et réessayé.  Enfin, une erreur de sortie raisonnable de la prochaine recharge de vernis: </p><br><pre> <code class="bash hljs">Jan 01 12:00:00 hostname varnishreload[32604]: /usr/sbin/varnishreload: line 124: <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span>: write error: Broken pipe Jan 01 12:00:00 hostname varnishreload[32604]: VCL <span class="hljs-string"><span class="hljs-string">'reload_20190101_120000_32604'</span></span> compiled</code> </pre> <br><p>  Ligne 124, maintenant nous parlons! </p><br><pre> <code class="bash hljs">114 <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_vcl_file</span></span></span></span>() { 115 VCL_SHOW=$(varnishadm vcl.show -v <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_NAME</span></span></span><span class="hljs-string">"</span></span> 2&gt;&amp;1) || : 116 VCL_FILE=$( 117 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_SHOW</span></span></span><span class="hljs-string">"</span></span> | 118 awk <span class="hljs-string"><span class="hljs-string">'$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</span></span> | { 119 <span class="hljs-comment"><span class="hljs-comment"># all this ceremony to handle blanks in FILE 120 read -r DELIM VCL_SHOW INDEX SIZE FILE 121 echo "$FILE" 122 } 123 ) || : 124 125 if [ -z "$VCL_FILE" ] 126 then 127 echo "$VCL_SHOW" &gt;&amp;2 128 fail "failed to get the VCL file name" 129 fi 130 131 echo "$VCL_FILE" 132 }</span></span></code> </pre> <br><p>  Mais il s'avère que la ligne 124 est assez calme.  Je ne pouvais que supposer que l'erreur avait été produite dans le cadre de la commande multiligne exécutée à la ligne 116. </p><br><p>  Alors, que produit le sous-shell ci-dessus pour stocker dans la variable <code>VCL_FILE</code> ?  Dans la première partie, il envoie le contenu de la variable <code>VCL_SHOW</code> créée sur la ligne 115 dans le tube.  Que se passe-t-il alors? </p><br><p>  Tout d'abord, il utilise <code>varnishadm</code> , qui est une partie standard d'une installation de Varnish utilisée pour configurer Varnish sans avoir à le redémarrer.  La sous-commande <code>vcl.show -v</code> est utilisée pour imprimer la totalité de la configuration VCL spécifiée par <code>${VCL_NAME}</code> sur STDOUT. </p><br><p>  Pour afficher la configuration VCL active actuelle ainsi que plusieurs versions précédentes du routage de vernis qui sont toujours en mémoire, vous pouvez utiliser une autre commande <code>varnishadm vcl.list</code> , dont la sortie serait similaire à la suivante: </p><br><pre> <code class="plaintext hljs">discarded cold/busy 1 reload_20190101_120000_11903 discarded cold/busy 2 reload_20190101_120000_12068 discarded cold/busy 16 reload_20190101_120000_12259 discarded cold/busy 16 reload_20190101_120000_12299 discarded cold/busy 28 reload_20190101_120000_12357 active auto/warm 32 reload_20190101_120000_12397 available auto/warm 0 reload_20190101_120000_12587</code> </pre> <br><p>  La variable <code>${VCL_NAME}</code> est définie ailleurs dans le script <code>varnishreload</code> au nom de la VCL actuellement active, le cas échéant.  Dans ce cas, ce serait "reload_20190101_120000_12397". </p><br><p>  Génial, donc <code>${VCL_SHOW}</code> contient maintenant une configuration complète pour Varnish, assez facile jusqu'à présent.  Maintenant, j'ai finalement compris pourquoi la sortie du tableau de bord avec <code>set -x</code> semblait être si cassée - elle comprenait le contenu de la configuration de vernis résultante. </p><br><p>  L'important ici est que la configuration VCL complète peut souvent être épissée à partir de plusieurs fichiers.  Les commentaires de style C sont utilisés pour délimiter où les fichiers de configuration ont été inclus dans d'autres fichiers de configuration, ce qui correspond exactement à la ligne suivante de l'extrait de code. </p><br><p>  La syntaxe des commentaires dénotant un fichier a le format suivant </p><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// VCL.SHOW &lt;NUM&gt; &lt;NUM&gt; &lt;FILENAME&gt;</span></span></code> </pre> <br><p>  Les chiffres ne sont pas importants ici, ce qui nous intéresse, c'est le nom du fichier. </p><br><p>  Alors, que se passe-t-il dans le monde des commandes commençant à la ligne 116? <br>  Choisissons-le à part. <br>  La commande comprend quatre parties: </p><br><ol><li>  Un <code>echo</code> simple qui <code>${VCL_SHOW}</code> la valeur de <code>${VCL_SHOW}</code> <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$VCL_SHOW</span></span></span><span class="hljs-string">"</span></span></code> </pre> </li><li>  <code>awk</code> qui recherche une ligne (enregistrement) où le premier champ est '//' et le second est "VCL.SHOW". <br>  Awk est invité à imprimer la première ligne correspondant à ces modèles, puis à arrêter immédiatement le traitement. <br><pre> <code class="bash hljs">awk <span class="hljs-string"><span class="hljs-string">'$1 == "//" &amp;&amp; $2 == "VCL.SHOW" {print; exit}'</span></span></code> </pre> </li><li>  Un bloc de code qui lit dans les champs délimités par des espaces en cinq variables.  La cinquième variable FILE obtient le reste de la ligne.  Enfin, un dernier écho imprime le contenu de la variable <code>${FILE}</code> . <br><pre> <code class="bash hljs">{ <span class="hljs-built_in"><span class="hljs-built_in">read</span></span> -r DELIM VCL_SHOW INDEX SIZE FILE; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$FILE</span></span></span><span class="hljs-string">"</span></span> }.</code> </pre> </li><li>  Comme les étapes 1 à 3 sont toutes enfermées dans un sous-shell, la sortie de <code>$FILE</code> se retrouvera dans la variable <code>VCL_FILE</code> . </li></ol><br><p>  Comme le commentaire de la ligne 119 le suggère, cette façon de faire sert un seul objectif: gérer de manière fiable le cas où VCL ferait référence à des noms de fichiers avec des espaces. </p><br><p>  J'ai commenté la logique de traitement d'origine pour le <code>${VCL_FILE}</code> et essayé de modifier la chaîne de commandes mais sans fin raisonnable.  Tout fonctionnait dans ma coquille mais jamais lorsqu'il était exécuté en tant que service. </p><br><p>  Il semble que l'erreur ne soit pas du tout reproductible lorsqu'elle est exécutée par moi - pendant ce temps, les 30 minutes estimées se sont écoulées six fois et une nouvelle tâche hautement prioritaire a tout mis de côté.  Le reste de la semaine a été assez chargé avec différentes tâches, les deux exceptions étant un entretien interne que notre équipe a eu sur l'utilisation de <code>sed</code> et un entretien avec un candidat prometteur.  Le problème de la disparition de l'erreur de <code>varnishreload</code> été complètement perdu dans le temps. </p><br><h3 id="your-so-called-sed-fu-is-really-quite-pathetic">  Votre soi-disant sed-fu ... est vraiment ... assez pathétique </h3><br><p>  L'un des jours de la semaine qui a suivi était assez libre, j'ai donc repris la tâche.  J'avais espéré que peut-être un processus d'arrière-plan dans mon cerveau réduisait encore le problème et je serais enfin en mesure de le résoudre. </p><br><p>  Étant donné que le fait de plier le code la dernière fois n'a pas aidé, j'ai simplement opté pour une réécriture de la ligne 116. Le code existant était fou, de toute façon.  Il n'est absolument pas nécessaire d'utiliser <code>read</code> ici. </p><br><p>  En regardant à nouveau l'erreur: <br>  <code>sh: echo: broken pipe</code> - l'écho est à deux endroits dans cette commande, mais je soupçonne que le tout premier est un coupable plus probable (ou un complice).  Awk n'inspire pas non plus confiance.  Eh bien, au cas où ce serait vraiment l' <code>awk | {read; echo}</code> <code>awk | {read; echo}</code>  construction <code>awk | {read; echo}</code> causant tous ces problèmes, pourquoi ne pas utiliser autre chose?  Awk n'est pas vraiment utilisé à ses pleines capacités sur ce one-liner et puis il y a ce surplus de <code>read</code> . </p><br><p>  Voyant que nous avons eu une discussion interne sur <code>sed</code> l'autre semaine, j'ai voulu essayer mes compétences nouvellement acquises et optimiser l' <code>echo | awk | { read; echo }</code> <code>echo | awk | { read; echo }</code>  <code>echo | awk | { read; echo }</code> en un <code>echo | sed</code> plus simple <code>echo | sed</code>  <code>echo | sed</code> .  Bien que ce ne soit certainement pas la bonne façon d'aborder le débogage, j'ai pensé au moins essayer mon sed-fu et peut-être apprendre quelque chose de nouveau sur le problème dans le processus.  Dans le processus, j'ai demandé à mon collègue - l'auteur de la conférence sed - de m'aider à trouver une commande sed plus efficace. </p><br><p>  J'ai vidé le <code>varnishadm vcl.show -v "$VCL_NAME"</code> dans un fichier, afin que je puisse me concentrer sur l'écriture de sed sans tous les tracas liés aux rechargements de service. </p><br><p>  Une brève introduction sur la façon exacte dont sed traite les entrées peut être trouvée dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">son manuel GNU</a> .  Dans les sources sed, le caractère <code>\n</code> est explicitement spécifié comme séparateur de ligne. </p><br><p>  Après plusieurs itérations et contributions de mon collègue, nous avons créé une expression sed qui a produit exactement le même résultat que la ligne 116 d'origine. </p><br><p>  Créons ici un exemple de fichier d'entrée, </p><br><pre> <code class="bash hljs">&gt; cat vcl-example.vcl Text // VCL.SHOW 0 1578 file with 3 spaces.vcl More text // VCL.SHOW 0 1578 file.vcl Even more text // VCL.SHOW 0 1578 file with TWOspaces.vcl Final text</code> </pre> <br><p>  Cela peut ne pas être apparent à partir de la description ci-dessus, mais nous ne sommes intéressés que par le premier commentaire <code>// VCL.SHOW</code> , et il peut y en avoir plusieurs en entrée.  C'est exactement pourquoi awk se ferme après le premier match. </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># step 1, capture just the comment lines # using sed capability to specify delimiter character with '\#' instead of the commonly used '/' so there is no need to escape slashes themselves # and the “address” capability defined as regex “// VCL.SHOW” to search for lines with specific pattern # -n flag makes sure that the sed does not print all as it does by default (see above link) # -E switches to the extended regex &gt; cat vcl-processor-1.sed \#// VCL.SHOW#p &gt; sed -En -f vcl-processor-1.sed vcl-example.vcl // VCL.SHOW 0 1578 file with 3 spaces.vcl // VCL.SHOW 0 1578 file.vcl // VCL.SHOW 0 1578 file with TWOspaces.vcl # step 2, only print out the file name # using the “substitute” command with regex capture groups to print just that group # and this is done only for the matches of the previous search &gt; cat vcl-processor-2.sed \#// VCL.SHOW# { s#.* [0-9]+ [0-9]+ (.*)$#\1# p } &gt; sed -En -f vcl-processor-2.sed vcl-example.vcl file with 3 spaces.vcl file.vcl file with TWOspaces.vcl # step 3, make sure to only get the first result # same as with the awk before, add an immediate exit after the first processed match is printed &gt; cat vcl-processor-3.sed \#// VCL.SHOW# { s#.* [0-9]+ [0-9]+ (.*)$#\1# p q } &gt; sed -En -f vcl-processor-3.sed vcl-example.vcl file with 3 spaces.vcl # step 4, wrap it up into a one-liner using the colon to separate commands &gt; sed -En -e '\#// VCL.SHOW#{s#.* [0-9]+ [0-9]+ (.*)$#\1#p;q;}' vcl-example.vcl file with 3 spaces.vcl</span></span></code> </pre> <br><p>  Ainsi, le contenu du script varnishreload ressemblerait à ceci: </p><br><pre> <code class="bash hljs">VCL_FILE=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(echo "$VCL_SHOW" | sed -En '\#// VCL.SHOW#{s#.*[0-9]+ [0-9]+ (.*)</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$#</span></span></span><span class="hljs-string">\1#p;q;};')"</span></span></code> </pre> <br><p>  La logique ci-dessus peut s'exprimer succinctement par: <br>  si une ligne correspond à l'expression <code>// VCL.SHOW</code> , alors <code>// VCL.SHOW</code> correspondre avec avidité le texte, y compris les deux nombres sur cette ligne et capturez tout ce qui vient après.  Emettez la capture et quittez. </p><br><p>  C'est simple, non? </p><br><p>  Nous étions satisfaits du script sed et du fait que le code d'origine qu'il remplace, tous les tests que j'ai effectués ont produit les résultats souhaités.J'ai donc modifié le <code>varnishreload</code> de <code>varnishreload</code> sur le serveur et tiré à nouveau le <code>systemctl reload varnish</code> .  L' <code>echo: write error: Broken pipe</code> redouté <code>echo: write error: Broken pipe</code> souriait au visage.  Le curseur clignotant attendait une nouvelle entrée de commande dans le vide sombre du terminal ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr475698/">https://habr.com/ru/post/fr475698/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr475684/index.html">@Pythonetc compilation, octobre 2019</a></li>
<li><a href="../fr475686/index.html">Trucs et astuces de ma chaîne Telegram @pythonetc, octobre 2019</a></li>
<li><a href="../fr475688/index.html">Qui est qui en informatique?</a></li>
<li><a href="../fr475694/index.html">Bévues de manuels et curiosités d'étude</a></li>
<li><a href="../fr475696/index.html">Samodelkin - géorgien ou russe?</a></li>
<li><a href="../fr475702/index.html">Enregistrements de rapports environ Tech: Explication des données # 3</a></li>
<li><a href="../fr475708/index.html">Intelligence artificielle - Interprète de langue</a></li>
<li><a href="../fr475712/index.html">Livraison zéro clic et SEO SERP: comment arriver à la position zéro dans Yandex et Google</a></li>
<li><a href="../fr475720/index.html">8 meilleures tendances de la Conférence internationale sur les représentations d'apprentissage (ICLR) 2019</a></li>
<li><a href="../fr475728/index.html">Quel est le prochain membre ...? - Nous recherchons une formule pour le nième terme de la séquence, générant des fonctions et Z-transformation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>