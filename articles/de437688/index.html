<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí© ü§ì ‚ú® OpenSceneGraph: Grundlegende Programmiertechniken üëú üß§ ü§±üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Dieser Artikel konzentriert sich weniger auf die Grafiken als vielmehr darauf, wie die Anwendung, die sie verwendet, unter Ber√ºcksichtigu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Grundlegende Programmiertechniken</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437688/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg" alt="Bild"><br><h1>  Einf√ºhrung </h1><br>  Dieser Artikel konzentriert sich weniger auf die Grafiken als vielmehr darauf, wie die Anwendung, die sie verwendet, unter Ber√ºcksichtigung der Besonderheiten der OpenSceneGraph-Engine und der von ihr bereitgestellten Software organisiert werden sollte. <br><br>  Es ist kein Geheimnis, dass der Schl√ºssel zum Erfolg eines Softwareprodukts eine gut gestaltete Architektur ist, die die M√∂glichkeit bietet, den geschriebenen Code zu pflegen und zu erweitern.  In diesem Sinne befindet sich die Engine, die wir in Betracht ziehen, auf einem ziemlich hohen Niveau und bietet dem Entwickler ein sehr breites Toolkit, mit dem eine flexible modulare Architektur aufgebaut werden kann. <br><br>  Dieser Artikel ist ziemlich lang und enth√§lt eine √úbersicht √ºber die verschiedenen Tools und Techniken (Entwurfsmuster, falls gew√ºnscht), die von der Entwickler-Engine bereitgestellt werden.  Alle Abschnitte des Artikels enthalten Beispiele, deren Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem Repository gespeichert werden kann</a> . <br><a name="habracut"></a><br><h1>  1. Analysieren der Befehlszeilenoptionen </h1><br>  In C / C ++ werden Befehlszeilenparameter √ºber die Argumente an die Funktion main () √ºbergeben.  In fr√ºheren Beispielen haben wir diese Parameter sorgf√§ltig als nicht verwendet markiert. Jetzt werden wir sie verwenden, um unserem Programm beim Start einige Daten mitzuteilen. <br><br>  OSG verf√ºgt √ºber integrierte Befehlszeilen-Parsing-Tools. <br><br>  Erstellen Sie das folgende Beispiel <br><br><div class="spoiler">  <b class="spoiler_title">Befehlszeilenbeispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif // MAIN_H</span></span></span></span></code> </pre> <br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); std::string filename; args.read(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"--model"</span></span></span><span class="hljs-meta">, filename); osg::ref_ptr</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Stellen Sie die Programmstartparameter in QtCreator ein <br><br><img src="https://habrastorage.org/webt/41/le/8p/41le8pjjdv2q-in3idhgnpe6-ao.png"><br><br>  Wenn wir das Programm zur Ausf√ºhrung ausf√ºhren, erhalten wir das Ergebnis (LKW-Modell <a href="">aus denselben OpenSceneGraph-Daten</a> ) <br><br><img src="https://habrastorage.org/webt/t-/_o/bb/t-_obbiwlzwuax1e336kqd6tosy.png"><br><br>  Schauen wir uns nun ein Beispiel Zeile f√ºr Zeile an <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>;</code> </pre><br>  Erstellt eine Instanz der Befehlszeilen-Parser-Klasse osg :: ArgumentParser.  Beim Erstellen werden dem Klassenkonstruktor die Argumente √ºbergeben, die von der Funktion main () vom Betriebssystem akzeptiert werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> filename; args.read(<span class="hljs-string"><span class="hljs-string">"--model"</span></span>, filename);</code> </pre><br>  Wir analysieren die Argumente, suchen nach dem Schl√ºssel ‚Äû‚Äìmodel‚Äú und setzen seinen Wert in den Dateinamen der Zeichenfolge.  Mit diesem Schl√ºssel √ºbertragen wir den Dateinamen mit einem dreidimensionalen Modell an das Programm.  Als n√§chstes laden wir dieses Modell und zeigen es an <br><br><pre> <code class="cpp hljs">osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFile(filename); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  Die read () -Methode der osg :: ArgumentParser-Klasse weist viele √úberladungen auf, sodass Sie nicht nur Zeichenfolgenwerte aus der Befehlszeile lesen k√∂nnen, sondern auch Ganzzahlen, Gleitkommazahlen, Vektoren usw.  Sie k√∂nnen beispielsweise einen bestimmten Parameter vom Typ float lesen <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> size = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; args.read(<span class="hljs-string"><span class="hljs-string">"--size"</span></span>, size);</code> </pre><br>  Wenn dieser Parameter nicht in der Befehlszeile angezeigt wird, bleibt sein Wert unver√§ndert, nachdem die Gr√∂√üenvariable initialisiert wurde. <br><br><h1>  2. Benachrichtigungs- und Protokollierungsmechanismus </h1><br>  OpenSceneGraph verf√ºgt √ºber einen Benachrichtigungsmechanismus, mit dem Sie Debugging-Meldungen w√§hrend des Rendervorgangs anzeigen und vom Entwickler initiieren k√∂nnen.  Dies ist eine gro√üe Hilfe beim Verfolgen und Debuggen eines Programms.  Das OSG-Benachrichtigungssystem unterst√ºtzt die Ausgabe von Diagnoseinformationen (Fehler, Warnungen, Benachrichtigungen) auf Motorkernebene und deren Plug-Ins.  Der Entwickler kann w√§hrend des Programmvorgangs mithilfe der Funktion osg :: notify () eine Diagnosemeldung anzeigen. <br><br>  Diese Funktion arbeitet als Standardausgabestream der Standard-C ++ - Bibliothek durch √úberladen des Operators &lt;&lt;.  Es wird die Nachrichtenebene als Argument verwendet: IMMER, FATAL, WARN, NOTICE, INFO, DEBUG_INFO und DEBUG_FP.  Zum Beispiel <br><br><pre> <code class="cpp hljs">osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some warning message"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Zeigt eine Warnung mit benutzerdefiniertem Text an. <br><br>  OSG-Benachrichtigungen k√∂nnen wichtige Informationen √ºber den Status des Programms, Erweiterungen des Grafiksubsystems des Computers und m√∂gliche Probleme mit der Engine enthalten. <br><br>  In einigen F√§llen ist es erforderlich, diese Daten nicht an die Konsole auszugeben, sondern diese Ausgabe in eine Datei (in Form eines Protokolls) oder eine andere Schnittstelle, einschlie√ülich eines Grafik-Widgets, umzuleiten.  Die Engine enth√§lt eine spezielle Klasse osg :: NotifyHandler, die die Umleitung von Benachrichtigungen an den vom Entwickler ben√∂tigten Ausgabestream erm√∂glicht. <br><br>  √úberlegen Sie anhand eines einfachen Beispiels, wie Sie die Ausgabe von Benachrichtigungen beispielsweise in eine Textprotokolldatei umleiten k√∂nnen.  Schreiben Sie den folgenden Code <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel benachrichtigen</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;fstream&gt; #endif // MAIN_H</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> class LogFileHandler : public osg::NotifyHandler { public: LogFileHandler(const std::string &amp;file) { _log.open(file.c_str()); } virtual ~LogFileHandler() { _log.close(); } virtual void notify(osg::NotifySeverity severity, const char *msg) { _log </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; msg; } protected: std::ofstream _log; }; int main(int argc, char *argv[]) { osg::setNotifyLevel(osg::INFO); osg::setNotifyHandler(new LogFileHandler("../logs/log.txt")); osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data loaded." &lt;&lt; std::endl; return -1; } osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Um die Ausgabe umzuleiten, schreiben wir die LogFileHandler-Klasse, die der Nachfolger von osg :: NotifyHandler ist.  Der Konstruktor und Destruktor dieser Klasse steuern das √ñffnen und Schlie√üen des _log-Ausgabestreams, dem die Textdatei zugeordnet ist.  Die notify () -Methode ist eine √§hnliche Basisklassenmethode, die wir neu definiert haben, um sie an die von OSG w√§hrend des Betriebs √ºber den Parameter msg gesendeten Dateibenachrichtigungen auszugeben. <br><br>  <strong>Klasse LogFileHandler</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogFileHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NotifyHandler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: LogFileHandler(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;file) { _log.open(file.c_str()); } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~LogFileHandler() { _log.close(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NotifySeverity severity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg)</span></span></span><span class="hljs-function"> </span></span>{ _log &lt;&lt; msg; } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ofstream _log; };</code> </pre><br>  Nehmen Sie als n√§chstes im Hauptprogramm die erforderlichen Einstellungen vor <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::INFO);</code> </pre><br>  Stellen Sie den Pegel der INFO-Benachrichtigungen ein, dh die Ausgabe aller Informationen √ºber den Betrieb des Motors, einschlie√ülich der aktuellen Benachrichtigungen √ºber den normalen Betrieb, im Protokoll. <br><br><pre> <code class="cpp hljs">osg::setNotifyHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LogFileHandler(<span class="hljs-string"><span class="hljs-string">"../logs/log.txt"</span></span>));</code> </pre><br>  Installieren Sie den Benachrichtigungshandler.  Als N√§chstes verarbeiten wir Befehlszeilenargumente, in denen die Pfade zu den geladenen Modellen √ºbergeben werden <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data loaded."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Gleichzeitig behandeln wir die Situation des Datenmangels in der Befehlszeile und zeigen eine Meldung im manuellen Protokollmodus mit dem Makro OSG_FATAL an.  F√ºhren Sie das Programm mit den folgenden Argumenten aus <br><br><img src="https://habrastorage.org/webt/mc/h4/so/mch4sot5pfjjpq9vb2dlolnjllm.png"><br><br>  Ausgabe in eine Protokolldatei wie diese <br><br><div class="spoiler">  <b class="spoiler_title">OSG-Protokollbeispiel</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() Opened DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll OSGReaderWriter wrappers loaded OK CullSettings::readEnvironmentalVariables() void StateSet::setGlobalDefaults() void StateSet::setGlobalDefaults() ShaderPipeline disabled. StateSet::setGlobalDefaults() Setting up GL2 compatible shaders CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce8f0 CullSettings::readEnvironmentalVariables() ShaderComposer::ShaderComposer() 0xa5ce330 View::setSceneData() Reusing existing scene0xa514220 CameraManipulator::computeHomePosition(0, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 CameraManipulator::computeHomePosition(0xa52f138, 0) boundingSphere.center() = (-6.40034 1.96225 0.000795364) boundingSphere.radius() = 16.6002 Viewer::realize() - No valid contexts found, setting up view across all screens. Applying osgViewer::ViewConfig : AcrossAllScreens . . . . ShaderComposer::~ShaderComposer() 0xa5ce330 ShaderComposer::~ShaderComposer() 0xa5ce8f0 ShaderComposer::~ShaderComposer() 0xa5d6228 close(0x1)0xa5d3e50 close(0)0xa5d3e50 ContextData::unregisterGraphicsContext 0xa5d3e50 DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. ShaderComposer::~ShaderComposer() 0xa5de4e0 close(0x1)0xa5ddba0 close(0)0xa5ddba0 ContextData::unregisterGraphicsContext 0xa5ddba0 Done destructing osg::View DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. DatabasePager::RequestQueue::~RequestQueue() Destructing queue. Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_osgd.dll Closing DynamicLibrary osgPlugins-3.7.0/mingw_osgdb_deprecated_osgd.dll</code> </pre><br></div></div><br>  Es spielt keine Rolle, dass Ihnen diese Informationen im Moment m√∂glicherweise sinnlos erscheinen. In Zukunft kann eine solche Schlussfolgerung dazu beitragen, Fehler in Ihrem Programm zu beheben. <br><br>  Standardm√§√üig sendet OSG Nachrichten an die Standardausgabe von std :: cout und Fehlermeldungen an den Stream std :: cerr.  Durch √úberschreiben des Benachrichtigungshandlers, wie im Beispiel gezeigt, kann diese Ausgabe jedoch an einen beliebigen Ausgabestream einschlie√ülich GUI-Elementen umgeleitet werden. <br><br>  Beachten Sie, dass das System beim Festlegen einer hohen Benachrichtigungsstufe (z. B. FATAL) alle Benachrichtigungen einer niedrigeren Stufe ignoriert.  Zum Beispiel in einem √§hnlichen Fall <br><br><pre> <code class="cpp hljs">osg::setNotifyLevel(osg::FATAL); . . . osg::notify(osg::WARN) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Some message."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Eine benutzerdefinierte Nachricht wird einfach nicht angezeigt. <br><br><h1>  3. Abfangen von geometrischen Attributen </h1><br>  Die Klasse osg :: Geometry verwaltet einen Datensatz, der Scheitelpunkte beschreibt, und zeigt ein Polygonnetz unter Verwendung eines geordneten Satzes von Grundelementen an.  Diese Klasse hat jedoch keine Ahnung von Elementen der Topologie des Modells wie Fl√§chen, Kanten und der Beziehung zwischen ihnen.  Diese Nuance verhindert die Implementierung von Dingen wie dem Verschieben bestimmter Gesichter, beispielsweise beim Animieren von Modellen.  OSG unterst√ºtzt diese Funktionalit√§t derzeit nicht. <br><br>  Die Engine implementiert jedoch eine Reihe von Funktoren, mit denen Sie die Geometrieattribute eines Objekts erneut lesen und zum Modellieren der Topologie des polygonalen Netzes verwenden k√∂nnen.  In C ++ ist ein Funktor ein Konstrukt, mit dem Sie ein Objekt als Funktion verwenden k√∂nnen. <br><br>  Die Klasse osg :: Drawable bietet dem Entwickler vier Arten von Funktoren: <br><br><ol><li>  osg :: Drawable :: AttributeFunctor - Liest die Attribute von Scheitelpunkten als Array von Zeigern.  Es verf√ºgt √ºber eine Reihe virtueller Methoden zum Anwenden von Scheitelpunktattributen verschiedener Datentypen.  Um diesen Funktor verwenden zu k√∂nnen, m√ºssen Sie die Klasse beschreiben und eine oder mehrere ihrer Methoden √ºberschreiben, in denen die vom Entwickler geforderten Aktionen ausgef√ºhrt werden <br></li></ol><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Drawable::AttributeType type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size, osg::Vec3* ptr )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  3-     ptr. //      }</span></span></code> </pre><br><ol><li>  osg :: Drawable :: ConstAttributeFunctor - schreibgesch√ºtzte Version des vorherigen Funktors: Ein Zeiger auf ein Array von Vektoren wird als konstanter Parameter √ºbergeben <br></li><li>  osg :: PrimitiveFunctor - imitiert den Prozess des Renderns von OpenGL-Objekten.  Unter dem Deckmantel des Renderns eines Objekts werden vom Entwickler √ºberschriebene Funktormethoden aufgerufen.  Dieser Funktor hat zwei wichtige Vorlagenunterklassen: osg :: TemplatePrimitiveFunctor &lt;&gt; und osg :: TriangleFunctor &lt;&gt;.  Diese Klassen empfangen primitive Eckpunkte als Parameter und √ºbergeben sie mit dem Operator operator () an Benutzermethoden. <br></li><li>  osg :: PrimitiveIndexFunctor - f√ºhrt dieselben Aktionen wie der vorherige Funktor aus, akzeptiert jedoch die Scheitelpunktindizes des Grundelements als Parameter. <br></li></ol><br>  Von osg :: Drawable abgeleitete Klassen wie osg :: ShapeDrawable und osg :: Geometry verf√ºgen √ºber eine accept () -Methode zum Anwenden verschiedener Funktoren. <br><br><h1>  4. Beispiel f√ºr die Verwendung des primitiven Funktors </h1><br>  Wir veranschaulichen die beschriebene Funktionalit√§t am Beispiel des Sammelns von Informationen √ºber dreieckige Fl√§chen und Punkte einer zuvor bestimmten Geometrie. <br><br><div class="spoiler">  <b class="spoiler_title">Funktor Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Geode&gt; #include &lt;osg/Geometry&gt; #include &lt;osg/TriangleFunctor&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> std::string vec2str(const osg::Vec3 &amp;v) { std::string tmp = std::to_string(vx()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vy()); tmp += </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" "</span></span></span><span class="hljs-meta">; tmp += std::to_string(vz()); return tmp; } struct FaceCollector { void operator()(const osg::Vec3 &amp;v1, const osg::Vec3 &amp;v2, const osg::Vec3 &amp;v3) { std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; "Face vertices: " &lt;&lt; vec2str(v1) &lt;&lt; "; " &lt;&lt; vec2str(v2) &lt;&lt; "; " &lt;&lt; vec2str(v3) &lt;&lt; std::endl; } }; int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Vec3Array&gt; vertices = new osg::Vec3Array; vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(0.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(1.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(2.0f, 0.0f, 1.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(3.0f, 0.0f, 1.5f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 0.0f) ); vertices-&gt;push_back( osg::Vec3(4.0f, 0.0f, 1.0f) ); osg::ref_ptr&lt;osg::Vec3Array&gt; normals = new osg::Vec3Array; normals-&gt;push_back( osg::Vec3(0.0f, -1.0f, 0.0f) ); osg::ref_ptr&lt;osg::Geometry&gt; geom = new osg::Geometry; geom-&gt;setVertexArray(vertices.get()); geom-&gt;setNormalArray(normals.get()); geom-&gt;setNormalBinding(osg::Geometry::BIND_OVERALL); geom-&gt;addPrimitiveSet(new osg::DrawArrays(GL_QUAD_STRIP, 0, 10)); osg::ref_ptr&lt;osg::Geode&gt; root = new osg::Geode; root-&gt;addDrawable(geom.get()); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Lassen Sie uns Folgendes beachten, indem wir den von uns oft ber√ºcksichtigten Prozess der Erstellung von Geometrie weglassen.  Wir definieren eine FaceCollector-Struktur, f√ºr die wir operator () wie folgt neu definieren <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FaceCollector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> osg::Vec3 &amp;v3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Face vertices: "</span></span> &lt;&lt; vec2str(v1) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v2) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"; "</span></span> &lt;&lt; vec2str(v3) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } };</code> </pre><br>  Wenn dieser Operator aufgerufen wird, zeigt er die Koordinaten der drei Eckpunkte an, die von der Engine an ihn √ºbertragen werden.  Die Funktion vec2str ist erforderlich, um die Komponenten des Vektors osg :: Vec3 in std :: string zu √ºbersetzen.  Um den Funktor aufzurufen, erstellen Sie eine Instanz davon und √ºbergeben Sie sie √ºber die Methode accept () an das Geometrieobjekt <br><br><pre> <code class="cpp hljs">osg::TriangleFunctor&lt;FaceCollector&gt; functor; geom-&gt;accept(functor);</code> </pre><br>  Wie oben erw√§hnt, ahmt dieser Aufruf das Rendern der Geometrie nach und ersetzt die Zeichnung selbst durch Aufrufen einer √ºberschriebenen Funktormethode.  In diesem Fall wird es w√§hrend des "Zeichnens" jedes der Dreiecke aufgerufen, aus denen die Geometrie des Beispiels besteht. <br><br>  Auf dem Bildschirm erhalten wir eine solche Geometrie <br><br><img src="https://habrastorage.org/webt/ai/-a/6v/ai-a6vj4eeubetgk0bpicmjbgfm.png"><br><br>  und so ein Auspuff zur Konsole <br><br><pre> <code class="plaintext hljs">Face vertices: 0.000000 0.000000 0.000000; 0.000000 0.000000 1.000000; 1.000000 0.000000 0.000000 Face vertices: 0.000000 0.000000 1.000000; 1.000000 0.000000 1.500000; 1.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 0.000000; 1.000000 0.000000 1.500000; 2.000000 0.000000 0.000000 Face vertices: 1.000000 0.000000 1.500000; 2.000000 0.000000 1.000000; 2.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 0.000000; 2.000000 0.000000 1.000000; 3.000000 0.000000 0.000000 Face vertices: 2.000000 0.000000 1.000000; 3.000000 0.000000 1.500000; 3.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 0.000000; 3.000000 0.000000 1.500000; 4.000000 0.000000 0.000000 Face vertices: 3.000000 0.000000 1.500000; 4.000000 0.000000 1.000000; 4.000000 0.000000 0.000000</code> </pre><br>  Tats√§chlich werden beim Aufrufen von geom-&gt; accept (...) keine Dreiecke gerendert, OpenGL-Aufrufe simuliert und stattdessen Daten √ºber die Eckpunkte des Dreiecks, deren Wiedergabe simuliert wird <br><br><img src="https://habrastorage.org/webt/gx/gp/il/gxgpilewn7pw26w9tdy-e28ypds.png"><br><br>  Die Klasse osg :: TemplatePrimitiveFunctor sammelt nicht nur Daten zu Dreiecken, sondern auch zu anderen OpenGL-Grundelementen.  Um die Verarbeitung dieser Daten zu implementieren, m√ºssen Sie die folgenden Operatoren im Vorlagenargument √ºberschreiben <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   void operator()( const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool ); //   void operator()( const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, const osg::Vec3&amp;, bool );</span></span></code> </pre><br><br><h1>  5. Das Besuchermuster </h1><br>  Das Besuchermuster wird verwendet, um auf Vorg√§nge zuzugreifen, um die Elemente des Szenendiagramms zu √§ndern, ohne die Klassen dieser Elemente zu √§ndern.  Die Besucherklasse implementiert alle relevanten virtuellen Funktionen, um sie √ºber einen doppelten Versandmechanismus auf verschiedene Arten von Elementen anzuwenden.  Mit diesem Mechanismus kann der Entwickler seine eigene Besucherinstanz erstellen, indem er die von ihm ben√∂tigten Funktionen mithilfe spezieller Operatoren implementiert und den Besucher im laufenden Betrieb an verschiedene Arten von Szenendiagrammelementen bindet, ohne die Funktionalit√§t der Elemente selbst zu √§ndern.  Dies ist eine gro√üartige M√∂glichkeit, die Funktionalit√§t eines Elements zu erweitern, ohne Unterklassen dieser Elemente zu definieren. <br><br>  Um diesen Mechanismus in OSG zu implementieren, wird die Klasse osg :: NodeVisitor definiert.  Die von osg :: NodeVisitor geerbte Klasse bewegt sich im Szenendiagramm, besucht jeden Knoten und wendet die vom Entwickler definierten Operationen darauf an.  Dies ist die Hauptklasse, die verwendet wird, um in den Prozess des Aktualisierens von Knoten und des Abschneidens unsichtbarer Knoten einzugreifen und einige andere Operationen zum √Ñndern der Geometrie von Knoten in der Szene anzuwenden, z. B. osgUtil :: SmoothingVisitor, osgUtil :: Simplifier und osgUtil :: TriStripVisitor. <br><br>  Um den Besucher zu unterklassifizieren, m√ºssen wir eine oder mehrere virtuell √ºberladene apply () -Methoden √ºberschreiben, die von der Basisklasse osg :: NodeVisitor bereitgestellt werden.  Die meisten der wichtigsten OSG-Knotentypen verf√ºgen √ºber diese Methoden.  Der Besucher ruft automatisch die apply () -Methode f√ºr jeden der besuchten Knoten auf, wenn er das Diagramm der Szenenszene durchl√§uft.  Der Entwickler √ºberschreibt die apply () -Methode f√ºr jeden der von ihm ben√∂tigten Knotentypen. <br><br>  Bei der Implementierung der Methode apply () muss der Entwickler zum geeigneten Zeitpunkt die Methode traverse () der Basisklasse osg :: NodeVisitor aufrufen.  Dies initiiert den √úbergang des Besuchers zum n√§chsten Knoten, entweder zu einem untergeordneten Knoten oder zu einem Nachbarn auf Hierarchieebene, wenn der aktuelle Knoten keine untergeordneten Knoten hat, zu denen der √úbergang erfolgen kann.  Das Fehlen eines Aufrufs von traverse () bedeutet, dass das Durchlaufen des Szenendiagramms gestoppt wird und der Rest des Szenendiagramms ignoriert wird. <br><br>  √úberladungen der Methode apply () haben einheitliche Formate <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Node&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Geode&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Group&amp; )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( osg::Transform&amp; )</span></span></span></span>;</code> </pre><br>  Um den Untergraphen des aktuellen Knotens f√ºr das Besucherobjekt zu umgehen, m√ºssen Sie den Crawling-Modus festlegen, z. <br><br><pre> <code class="cpp hljs">ExampleVisitor visitor; visitor-&gt;setTraversalMode( osg::NodeVisitor::TRAVERSE_ALL_CHILDREN ); node-&gt;accept( visitor );</code> </pre><br>  Der Bypass-Modus wird von mehreren Enumeratoren festgelegt <br><br><ol><li>  TRAVERSE_ALL_CHILDREN - Durchlaufen aller untergeordneten Knoten. <br></li><li>  TRAVERSE_PARENTS - Vom aktuellen Knoten zur√ºckgeben und den Stammknoten nicht erreichen <br></li><li>  TRAVERSE_ACTIVE_CHILDREN - Umgeht ausschlie√ülich aktive Knoten, dh solche, deren Sichtbarkeit √ºber den Knoten osg :: Switch aktiviert wird. <br></li></ol><br><br><h1>  6. Analyse der Struktur der brennenden Cessna </h1><br>  Der Entwickler kann immer den Teil des Szenendiagramms analysieren, der von dem aus der Datei geladenen Modell generiert wird. <br><br><div class="spoiler">  <b class="spoiler_title">Funktor Beispiel</b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;iostream&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class InfoVisitor : public osg::NodeVisitor { public: InfoVisitor() : _level(0) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } std::string spaces() { return std::string(_level * 2, ' '); } virtual void apply(osg::Node &amp;node); virtual void apply(osg::Geode &amp;geode); protected: unsigned int _level; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Node &amp;node) { std::cout &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; "::" &lt;&lt; node.className() &lt;&lt; std::endl; _level++; traverse(node); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void InfoVisitor::apply(osg::Geode &amp;geode) { std::cout &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; "::" &lt;&lt; geode.className() &lt;&lt; std::endl; _level++; for (unsigned int i = 0; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); std::cout &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; "::" &lt;&lt; drawable-&gt;className() &lt;&lt; std::endl; } traverse(geode); _level--; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { osg::ArgumentParser args(&amp;argc, argv); osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); if (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; ": No data leaded. " &lt;&lt; std::endl; return -1; } InfoVisitor infoVisitor; root-&gt;accept(infoVisitor); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br>  Wir erstellen die InfoVisitor-Klasse und erben sie von osg :: NodeVisitor <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InfoVisitor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeVisitor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: InfoVisitor() : _level(<span class="hljs-number"><span class="hljs-number">0</span></span>) { setTraversalMode(osg::NodeVisitor::TRAVERSE_ALL_CHILDREN); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(_level * <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node &amp;node)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Geode &amp;geode)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _level; };</code> </pre><br>  Die Eigenschaft protected _level zeigt auf die Ebene des Szenendiagramms, auf der sich unsere Besucherklasse derzeit befindet.  Initialisieren Sie im Konstruktor den Ebenenz√§hler und legen Sie den Modus f√ºr die Knoten√ºberquerung fest, um alle untergeordneten Knoten zu umgehen. <br><br>  Definieren Sie nun die apply () -Methoden f√ºr Knoten neu <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Node &amp;node) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; traverse(node); _level--; }</code> </pre><br>  Hier geben wir den Typ des aktuellen Knotens aus.  Die Methode libraryName () f√ºr den Knoten zeigt den Namen der OSG-Bibliothek an, in der dieser Knoten implementiert ist, und die Methode className zeigt den Namen der Knotenklasse an.  Diese Methoden werden durch die Verwendung von Makros im Code von OSG-Bibliotheken implementiert. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; node.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; node.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  Danach erh√∂hen wir den Z√§hler auf Diagrammebene und rufen die Methode traverse () auf, die einen √úbergang zu einer h√∂heren Ebene zum untergeordneten Knoten initiiert.  Nach der R√ºckkehr von traverse () verringern wir erneut den Z√§hlerwert.  Es ist leicht zu erraten, dass traverse () einen wiederholten Aufruf der Methode apply () initiiert, wobei traverse () bereits f√ºr einen Untergraphen ab dem aktuellen Knoten wiederholt wird.  Wir erhalten eine rekursive Besucherausf√ºhrung, bis wir die Endknoten des Szenendiagramms erreichen. <br><br>  Bei einem Endknoten vom Typ osg :: Geode wird die √úberladung der Methode apply () √ºberschrieben <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> InfoVisitor::apply(osg::Geode &amp;geode) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; geode.libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; geode.className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; _level++; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } traverse(geode); _level--; }</code> </pre><br>  mit √§hnlich funktionierendem Code, au√üer dass wir Daten zu allen geometrischen Objekten anzeigen, die an den aktuellen geometrischen Knoten angeh√§ngt sind <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; geode.getNumDrawables(); ++i) { osg::Drawable *drawable = geode.getDrawable(i); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; spaces() &lt;&lt; drawable-&gt;libraryName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"::"</span></span> &lt;&lt; drawable-&gt;className() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  In der Funktion main () verarbeiten wir Befehlszeilenargumente, √ºber die wir eine Liste der in die Szene geladenen Modelle √ºbergeben und die Szene bilden <br><br><pre> <code class="cpp hljs">osg::<span class="hljs-function"><span class="hljs-function">ArgumentParser </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">args</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;argc, argv)</span></span></span></span>; osg::ref_ptr&lt;osg::Node&gt; root = osgDB::readNodeFiles(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!root.valid()) { OSG_FATAL &lt;&lt; args.getApplicationName() &lt;&lt; <span class="hljs-string"><span class="hljs-string">": No data leaded. "</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre><br>  Gleichzeitig verarbeiten wir Fehler im Zusammenhang mit dem Fehlen von Modelldateinamen in der Befehlszeile.  Jetzt erstellen wir eine Besucherklasse und √ºbergeben sie zur Ausf√ºhrung an das Szenendiagramm <br><br><pre> <code class="cpp hljs">InfoVisitor infoVisitor; root-&gt;accept(infoVisitor);</code> </pre><br>  Als n√§chstes folgen die Schritte zum Starten des Viewers, die wir bereits viele Male ausgef√ºhrt haben.  Nach dem Starten des Programms mit Parametern <br><br><pre> <code class="bash hljs">$ visitor ../data/cessnafire.osg</code> </pre><br>  Wir werden die folgende Ausgabe an die Konsole sehen <br><br><pre> <code class="plaintext hljs">osg::Group osg::MatrixTransform osg::Geode osg::Geometry osg::Geometry osg::MatrixTransform osgParticle::ModularEmitter osgParticle::ModularEmitter osgParticle::ParticleSystemUpdater osg::Geode osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem osgParticle::ParticleSystem</code> </pre><br>  Tats√§chlich haben wir einen vollst√§ndigen Baum der geladenen Szene erhalten.  Entschuldigung, wo sind so viele Knoten?  Alles ist sehr einfach - Modelle des * .osg-Formats selbst sind Container, in denen nicht nur Daten zur Modellgeometrie, sondern auch andere Informationen zu seiner Struktur in Form eines Teilgraphen der OSG-Szene gespeichert werden.  Die Geometrie des Modells, Transformationen und Partikeleffekte, die Rauch und Flammen realisieren, sind Knotenpunkte des OSG-Szenendiagramms.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Szene kann entweder von * .osg heruntergeladen oder vom Viewer in das * .osg-Format entladen werden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein einfaches Beispiel f√ºr die Anwendung der Besuchermechanik. </font><font style="vertical-align: inherit;">Tats√§chlich k√∂nnen Sie innerhalb von Besuchern viele Vorg√§nge ausf√ºhren, um die Knoten zu √§ndern, wenn das Programm ausgef√ºhrt wird.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7. Steuern des Verhaltens von Knoten im Szenendiagramm durch √úberschreiben der Methode traverse () </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine wichtige M√∂glichkeit, mit OSG zu arbeiten, besteht darin, die Methode traverse () zu √ºberschreiben. Diese Methode wird jedes Mal aufgerufen, wenn ein Frame gezeichnet wird. Sie akzeptieren einen Parameter vom Typ osg :: NodeVisitor &amp;, der angibt, welche Passage des Szenendiagramms gerade ausgef√ºhrt wird (Aktualisierung, Ereignisverarbeitung oder Clipping). Die meisten OSG-Hosts √ºberschreiben diese Methode, um ihre Funktionalit√§t zu implementieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist zu beachten, dass das √úberschreiben der Methode traverse () gef√§hrlich sein kann, da dies den Prozess des Durchlaufens des Szenendiagramms beeinflusst und zu einer falschen Anzeige der Szene f√ºhren kann. Es ist auch unpraktisch, wenn Sie mehreren Knotentypen neue Funktionen hinzuf√ºgen m√∂chten. In diesem Fall werden Knotenr√ºckrufe verwendet, deren Konversation etwas geringer ausf√§llt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir wissen bereits, dass der osg :: Switch-Knoten die Anzeige seiner untergeordneten Knoten steuern kann, einschlie√ülich der Anzeige einiger Knoten und des Ausschaltens der Anzeige anderer Knoten. </font><font style="vertical-align: inherit;">Da er jedoch nicht wei√ü, wie dies automatisch zu tun ist, erstellen wir einen neuen Knoten auf der Grundlage des alten Knotens, der entsprechend dem Wert des internen Z√§hlers zu unterschiedlichen Zeitpunkten zwischen untergeordneten Knoten wechselt.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animswitch Beispiel</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class AnimatingSwitch : public osg::Switch { public: AnimatingSwitch() : osg::Switch(), _count(0) {} AnimatingSwitch(const AnimatingSwitch &amp;copy, const osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); virtual void traverse(osg::NodeVisitor &amp;nv); protected: unsigned int _count; }; void AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { if (!((++_count) % 60) ) { setValue(0, !getValue(0)); setValue(1, !getValue(1)); } osg::Switch::traverse(nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;AnimatingSwitch&gt; root = new AnimatingSwitch; root-&gt;addChild(model1.get(), true); root-&gt;addChild(model2.get(), false); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns dieses Beispiel an. </font><font style="vertical-align: inherit;">Wir erstellen eine neue AnimatingSwitch-Klasse, die von osg :: Switch erbt.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnimatingSwitch</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::Switch { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {} META_Node(osg, AnimatingSwitch); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::NodeVisitor &amp;nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Diese Klasse enth√§lt den Standardkonstruktor. </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch() : osg::Switch(), _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und Konstruktor zum Kopieren, erstellt gem√§√ü den Anforderungen von OSG </font></font><br><br><pre> <code class="cpp hljs">AnimatingSwitch(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> AnimatingSwitch &amp;copy, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::CopyOp &amp;copyop = osg::CopyOp::SHALLOW_COPY) : osg::Switch(copy, copyop), _count(copy._count) {}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Konstruktor zum Kopieren sollte als Parameter enthalten: einen konstanten Verweis auf die zu kopierende Klasseninstanz und den Parameter osg :: CopyOp, der die Kopiereinstellungen der Klasse angibt. </font><font style="vertical-align: inherit;">Es folgen ziemlich seltsame Buchstaben</font></font><br><br><pre> <code class="cpp hljs">META_Node(osg, AnimatingSwitch);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies ist ein Makro, das die Struktur bildet, die f√ºr den Nachkommen einer von osg :: Node abgeleiteten Klasse erforderlich ist. </font><font style="vertical-align: inherit;">Bis wir diesem Makro Bedeutung beimessen, ist es wichtig, dass es beim Erben von osg :: Switch vorhanden ist, wenn alle untergeordneten Klassen definiert werden. </font><font style="vertical-align: inherit;">Die Klasse enth√§lt das gesch√ºtzte Feld _count - genau den Z√§hler, anhand dessen wir wechseln. </font><font style="vertical-align: inherit;">Wir implementieren das Umschalten beim √úberschreiben der traverse () -Methode</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimatingSwitch::traverse(osg::NodeVisitor &amp;nv) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) ) { setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !getValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } osg::Switch::traverse(nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Umschalten des Anzeigestatus von Knoten erfolgt jedes Mal, wenn der Wert des Z√§hlers (Inkrementieren jedes Methodenaufrufs) ein Vielfaches von 60 ist. Wir kompilieren das Beispiel und f√ºhren es aus </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die traverse () -Methode f√ºr verschiedene Knotentypen st√§ndig neu definiert wird, sollte sie einen Mechanismus zum Abrufen von Transformationsmatrizen und Renderzust√§nden zur weiteren Verwendung durch ihren √ºberladenen Algorithmus bereitstellen. </font><font style="vertical-align: inherit;">Der Eingabeparameter osg :: NodeVisitor ist der Schl√ºssel f√ºr verschiedene Operationen mit Knoten. </font><font style="vertical-align: inherit;">Insbesondere wird die Art der aktuellen Durchquerung des Szenendiagramms angegeben, z. B. Aktualisieren, Verarbeiten von Ereignissen und Abschneiden unsichtbarer Gesichter. </font><font style="vertical-align: inherit;">Die ersten beiden beziehen sich auf Knotenr√ºckrufe und werden beim Studium der Animation ber√ºcksichtigt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Beschneidungsdurchlauf kann identifiziert werden, indem das Objekt osg :: NodeVisitor in das Objekt osg :: CullVisitor konvertiert wird</font></font><br><br><pre> <code class="cpp hljs">osgUtil::CullVisitor *cv = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;osgUtil::CullVisitor *&gt;(&amp;nv); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cv) { <span class="hljs-comment"><span class="hljs-comment">///  - ,     }</span></span></code> </pre><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. R√ºckrufmechanismus </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir die Animation eines Szenenobjekts implementiert, indem wir die Parameter seiner Transformation innerhalb des Szenenwiedergabezyklus ge√§ndert haben. Wie bereits mehrfach erw√§hnt, enth√§lt dieser Ansatz potenziell gef√§hrliches Anwendungsverhalten beim Multithread-Rendering. Um dieses Problem zu l√∂sen, wird ein R√ºckrufmechanismus verwendet, der beim Durchlaufen des Szenendiagramms ausgef√ºhrt wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt verschiedene Arten von R√ºckrufen in der Engine. R√ºckrufe werden von speziellen Klassen implementiert, von denen osg :: NodeCallback f√ºr die Aktualisierung von Szenenknoten ausgelegt ist und osg :: Drawable :: UpdateCallback, osg :: Drawable :: EventCallback und osg :: Drawable: CullCallback - dieselben Funktionen ausf√ºhren, jedoch f√ºr Geometrieobjekte.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die osg :: NodeCallback-Klasse verf√ºgt √ºber einen √ºberschreibbaren virtuellen operator () -Operator, der vom Entwickler zur Implementierung ihrer eigenen Funktionalit√§t bereitgestellt wird. </font><font style="vertical-align: inherit;">Damit der R√ºckruf funktioniert, m√ºssen Sie eine Instanz der Aufrufklasse an den Knoten anh√§ngen, f√ºr den sie verarbeitet werden soll, indem Sie die Methode setUpdateCallback () oder addUpdateCallback () aufrufen. </font><font style="vertical-align: inherit;">Der Operator operator () wird beim Aktualisieren der Knoten im Szenendiagramm beim Rendern jedes Frames automatisch aufgerufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der folgenden Tabelle sind die R√ºckrufe aufgef√ºhrt, die dem Entwickler in OSG zur Verf√ºgung stehen.</font></font><br><br><table><thead><tr><th>  Vorname </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√ºckruf-Funktor </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Virtuelle Methode </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Methode zum Anh√§ngen an ein Objekt </font></font></th></tr></thead><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knotenaktualisierung </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setUpdateCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knotenereignis </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setEventCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Knotenausschnitt </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: NodeCallback </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator () </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> osg :: Node :: setCullCallback () </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Geometrie-Update </font></font></td><td> osg::Drawable::UpdateCallback </td><td> update() </td><td> osg::Drawable::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Drawable::EventCallback </td><td> event() </td><td> osg::Drawable::setEventCallback() </td></tr><tr><td>   </td><td> osg::Drawable::CullCallback </td><td> cull() </td><td> osg::Drawable::setCullCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::StateAttributeCallback </td><td> operator() </td><td> osg::StateAttribute::setEventCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setUpdateCallback() </td></tr><tr><td>   </td><td> osg::Uniform::Callback </td><td> operator() </td><td> osg::Uniform::setEvevtCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PreDrawCallback() </td></tr><tr><td>       </td><td> osg::Camera::DrawCallback </td><td> operator() </td><td> osg::Camera::PostDrawCallback() </td></tr></tbody></table><br><br><h1> 9.  osg::Switch     </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etwas h√∂her haben wir ein Beispiel f√ºr den Wechsel zweier Flugzeugmodelle geschrieben. </font><font style="vertical-align: inherit;">Jetzt werden wir dieses Beispiel wiederholen, aber mit dem OSG-R√ºckrufmechanismus alles richtig machen.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckrufe mit Beispiel</font></font></b> <div class="spoiler_text">  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osg/Switch&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;osgViewer/Viewer&gt; #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class SwitchingCallback : public osg::NodeCallback { public: SwitchingCallback() : _count(0) {} virtual void operator()(osg::Node *node, osg::NodeVisitor *nv); protected: unsigned int _count; }; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void SwitchingCallback::operator()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = static_cast&lt;osg::Switch *&gt;(node); if ( !((++_count) % 60) &amp;&amp; switchNode ) { switchNode-&gt;setValue(0, !switchNode-&gt;getValue(0)); switchNode-&gt;setValue(1, !switchNode-&gt;getValue(0)); } traverse(node, nv); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { (void) argc; (void) argv; osg::ref_ptr&lt;osg::Node&gt; model1 = osgDB::readNodeFile("../data/cessna.osg"); osg::ref_ptr&lt;osg::Node&gt; model2 = osgDB::readNodeFile("../data/cessnafire.osg"); osg::ref_ptr&lt;osg::Switch&gt; root = new osg::Switch; root-&gt;addChild(model1, true); root-&gt;addChild(model2, false); root-&gt;setUpdateCallback( new SwitchingCallback ); osgViewer::Viewer viewer; viewer.setSceneData(root.get()); return viewer.run(); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sie m√ºssen eine Klasse erstellen, die von osg :: NodeCallback erbt und den osg :: Switch-Knoten steuert </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SwitchingCallback</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> osg::NodeCallback { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SwitchingCallback() : _count(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(osg::Node *node, osg::NodeVisitor *nv)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _count; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der _count-Z√§hler steuert das Umschalten des osg :: Switch-Knotens von der Zuordnung eines untergeordneten Knotens zu einem anderen, abh√§ngig von seinem Wert. </font><font style="vertical-align: inherit;">Im Konstruktor initialisieren wir den Z√§hler und definieren die virtuelle operator () -Methode neu</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SwitchingCallback::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(osg::Node *node, osg::NodeVisitor *nv) { osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } traverse(node, nv); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Knoten, auf dem der Aufruf ausgef√ºhrt wurde, wird √ºber den Knotenparameter an ihn √ºbergeben. </font><font style="vertical-align: inherit;">Da wir sicher wissen, dass dies ein Knoten vom Typ osg :: Switch sein wird, f√ºhren wir eine statische Umwandlung des Zeigers auf den Knoten auf den Zeiger auf den Switch-Knoten durch</font></font><br><br><pre> <code class="cpp hljs">osg::Switch *switchNode = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osg::Switch *&gt;(node);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir werden die angezeigten untergeordneten Knoten mit dem g√ºltigen Wert dieses Zeigers und wenn der Z√§hlerwert ein Vielfaches von 60 ist, vertauschen </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !((++_count) % <span class="hljs-number"><span class="hljs-number">60</span></span>) &amp;&amp; switchNode ) { switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">0</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); switchNode-&gt;setValue(<span class="hljs-number"><span class="hljs-number">1</span></span>, !switchNode-&gt;getValue(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vergessen Sie nicht, die Methode traverse () aufzurufen, um die rekursive Durchquerung des Szenendiagramms fortzusetzen </font></font><br><br><pre> <code class="cpp hljs">traverse(node, nv);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Rest des Programmcodes ist bis auf die Zeile trivial </font></font><br><br><pre> <code class="cpp hljs">root-&gt;setUpdateCallback( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SwitchingCallback );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dort weisen wir den von uns erstellten R√ºckruf dem Stammknoten vom Typ osg :: Switch zu. </font><font style="vertical-align: inherit;">Das Programm funktioniert √§hnlich wie im vorherigen Beispiel</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z5/fl/2u/z5fl2uhbnzxafceoro_wbga-pk4.gif"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir die mysteri√∂se Methode traverse () f√ºr zwei Zwecke verwendet: √úberschreiben dieser Methode in Nachfolgeklassen und Aufrufen dieser Methode f√ºr die Klasse osg :: NodeVisitor, um das Durchlaufen des Szenendiagramms fortzusetzen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dem gerade untersuchten Beispiel verwenden wir die dritte Option zum Aufrufen von traverse (), wobei ein Zeiger auf den Knoten und ein Zeiger auf die Besucherinstanz als Parameter √ºbergeben werden. Wie in den ersten beiden F√§llen wird das Crawlen des Szenendiagramms gestoppt, wenn auf diesem Knoten kein Aufruf von traverse () erfolgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methoden addUpdateCallback () dienen auch dazu, dem Knoten einen R√ºckruf hinzuzuf√ºgen. Im Gegensatz zu setUpdateCallback () wird es verwendet, um vorhandenen R√ºckrufen einen weiteren hinzuzuf√ºgen. Somit kann es mehrere R√ºckrufe f√ºr denselben Knoten geben.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben die grundlegenden Techniken untersucht, die bei der Entwicklung von Anwendungen mithilfe der OpenSceneGraph-Grafik-Engine verwendet werden. </font><font style="vertical-align: inherit;">Dies ist jedoch weit entfernt von allen Punkten, die ich ansprechen m√∂chte (trotz der Tatsache, dass der Artikel ziemlich lang war)</font></font><br><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fortsetzung folgt...</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437688/">https://habr.com/ru/post/de437688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437676/index.html">Universit√§ten und Corporate Accelerators als Hebel f√ºr den Start eines B2B-Startups in den USA</a></li>
<li><a href="../de437680/index.html">Meine DIY-Sammlung auf Youtube</a></li>
<li><a href="../de437682/index.html">Schreiben eines weiteren Kubernetes-Template-Tools</a></li>
<li><a href="../de437684/index.html">Oberster Algorithmus - Voreingenommenes Kompendium</a></li>
<li><a href="../de437686/index.html">Learning go: Schreiben eines P2P-Messenger mit End-to-End-Verschl√ºsselung</a></li>
<li><a href="../de437694/index.html">Analyse des Dienstprogramms Files.walkFileTree ();</a></li>
<li><a href="../de437696/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 283 (vom 21. bis 27. Januar)</a></li>
<li><a href="../de437698/index.html">Patent√ºbersetzungsdienst der WIPO - meine Erfahrungen</a></li>
<li><a href="../de437702/index.html">Google Job Interview Parsing: Synonyme Abfragen</a></li>
<li><a href="../de437704/index.html">Hervorragende Kenntnis des Lehrplans als Indikator f√ºr nicht die h√∂chste Intelligenz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>