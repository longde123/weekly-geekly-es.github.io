<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ›· ğŸ•³ï¸ â™’ï¸ Execute systemd no contÃªiner ğŸ¤˜ğŸ¾ ğŸ§•ğŸ» ğŸ‘©ğŸ»â€ğŸ“</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Temos acompanhado o tÃ³pico do uso do systemd em contÃªineres hÃ¡ muito tempo. Em 2014, nosso engenheiro de seguranÃ§a Daniel Walsh escreveu um artigo cha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Execute systemd no contÃªiner</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/468931/">  Temos acompanhado o tÃ³pico do uso do systemd em contÃªineres hÃ¡ muito tempo.  Em 2014, nosso engenheiro de seguranÃ§a Daniel Walsh escreveu um artigo chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Running systemd</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dentro de um Docker Container</a> e, alguns anos depois, outro artigo chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Running systemd in a container nÃ£o privilegiado</a> , no qual afirmou que a situaÃ§Ã£o nÃ£o era muito melhorado.  Em particular, ele escreveu que â€œinfelizmente, e dois anos depois, se vocÃª pesquisar no sistema Docker, a primeira coisa que aparece Ã© o mesmo artigo antigo dele.  EntÃ£o Ã© hora de mudar alguma coisa. â€  AlÃ©m disso, jÃ¡ conversamos sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conflito entre os desenvolvedores do Docker e o systemd</a> . <br><br><img src="https://habrastorage.org/webt/jw/is/oz/jwisoz8445mav6kqiwqr7gwpjns.png" width="100%"><br><br>  Neste artigo, mostraremos o que mudou nos Ãºltimos tempos e como o Podman pode nos ajudar nesse assunto. <br><a name="habracut"></a><br>  Existem muitos motivos para executar o systemd dentro de um contÃªiner, como: <br><br><ol><li>  <b>ContÃªineres multisserviÃ§os</b> - muitas pessoas desejam obter seus aplicativos multisserviÃ§os de mÃ¡quinas virtuais e executÃ¡-los em contÃªineres.  Seria melhor, Ã© claro, dividir esses aplicativos em microsserviÃ§os, mas nem todos podem fazÃª-lo ainda ou simplesmente nÃ£o hÃ¡ tempo.  Portanto, iniciar esses aplicativos na forma de serviÃ§os lanÃ§ados pelo systemd a partir de arquivos de unidades faz todo o sentido. </li><li>  <b>Arquivos de unidade Systemd</b> - a maioria dos aplicativos em execuÃ§Ã£o dentro de contÃªineres Ã© compilada a partir de cÃ³digo executado anteriormente em mÃ¡quinas virtuais ou fÃ­sicas.  Esses aplicativos possuem um arquivo de unidade que foi gravado para esses aplicativos e compreende como executÃ¡-los.  Portanto, Ã© melhor iniciar os serviÃ§os usando os mÃ©todos suportados, em vez de invadir seu prÃ³prio serviÃ§o init. </li><li>  <b>Systemd Ã© um gerenciador de processos.</b>  Ele gerencia serviÃ§os (encerra, reinicia serviÃ§os ou rastreia processos zumbis) melhor do que qualquer outra ferramenta. </li></ol><br>  Existem muitos motivos para nÃ£o executar o systemd em contÃªineres.  O principal Ã© que systemd / journald controla a saÃ­da de contÃªineres, e ferramentas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenShift</a> esperam que contÃªineres gravem o log diretamente no stdout e stderr.  Portanto, se vocÃª pretende gerenciar contÃªineres por meio de ferramentas de orquestraÃ§Ã£o como as mencionadas acima, precisarÃ¡ considerar seriamente o uso de contÃªineres com base no systemd.  AlÃ©m disso, os desenvolvedores do Docker e Moby costumavam se opor fortemente ao uso do systemd em contÃªineres. <br><br><h3>  A vinda de Podman </h3><br>  Temos o prazer de anunciar que a situaÃ§Ã£o finalmente saiu do papel.  A equipe responsÃ¡vel pelo lanÃ§amento de contÃªineres na Red Hat decidiu desenvolver <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seu prÃ³prio mecanismo de contÃªiner</a> .  Ele recebeu o nome de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Podman</a> e oferece a mesma interface de linha de comando (CLI) do Docker.  E quase todos os comandos do Docker podem ser usados â€‹â€‹da mesma maneira no Podman.  FreqÃ¼entemente realizamos seminÃ¡rios, que agora sÃ£o chamados de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Change Docker para Podman</a> , e o primeiro slide incentiva vocÃª a se registrar: alias docker = podman. <br><br>  Muitos fazem isso. <br><br>  Meu Podman e eu nÃ£o somos de forma alguma contra contÃªineres baseados em systemd.  Afinal, o Systemd Ã© mais frequentemente usado como o subsistema init do Linux, e nÃ£o deixÃ¡-lo funcionar normalmente em contÃªineres significa ignorar a maneira como milhares de pessoas estÃ£o acostumadas a executar contÃªineres. <br><br>  Podman sabe o que fazer para que o systemd funcione corretamente no contÃªiner.  Ela precisa de coisas como montar tmpfs em / run e / tmp.  Ela gosta quando o ambiente â€œcontÃªinerâ€ estÃ¡ ativado e aguarda permissÃµes de gravaÃ§Ã£o para sua parte do diretÃ³rio cgroup e para a pasta / var / log / journald. <br><br>  Ao iniciar um contÃªiner no qual init ou systemd Ã© o primeiro comando, o Podman configura automaticamente tmpfs e Cgroups para que o systemd inicie sem problemas.  Para bloquear esse modo de inicializaÃ§Ã£o automÃ¡tica, use a opÃ§Ã£o --systemd = false.  Observe que o Podman usa o modo systemd somente quando considerar necessÃ¡rio executar o comando systemd ou init. <br><br>  Aqui estÃ¡ um trecho do manual: <br><br><blockquote>  homem podman correr <br>  ... <br><br>  â€“Systemd = true | false <br><br>  Executando o contÃªiner no modo systemd.  Ativado por padrÃ£o. <br><br>  Se um comando systemd ou init for executado dentro do contÃªiner, o Podman configurarÃ¡ os pontos de montagem tmpfs nos seguintes diretÃ³rios: <br><br>  / run, / run / lock, / tmp, / sys / fs / cgroup / systemd, / var / lib / journal <br><br>  AlÃ©m disso, o SIGRTMIN + 3 serÃ¡ usado como um sinal de parada por padrÃ£o. <br><br>  Tudo isso permite que o systemd trabalhe em um contÃªiner fechado sem nenhuma modificaÃ§Ã£o. <br><br>  NOTA: systemd estÃ¡ tentando gravar no sistema de arquivos cgroup.  No entanto, o SELinux, por padrÃ£o, impede que os contÃªineres faÃ§am isso.  Para ativar a gravaÃ§Ã£o, ative o parÃ¢metro em lote container_manage_cgroup: <br><br>  setsebool -P container_manage_cgroup true <br></blockquote><br>  Agora veja como Ã© o Dockerfile para executar o systemd no contÃªiner ao usar o Podman: <br><br><pre><code class="plaintext hljs"># cat Dockerfile FROM fedora RUN dnf -y install httpd; dnf clean all; systemctl enable httpd EXPOSE 80 CMD [ "/sbin/init" ]</code> </pre> <br>  Isso Ã© tudo. <br><br>  Agora colete o contÃªiner: <br><br><pre> <code class="plaintext hljs"># podman build -t systemd .</code> </pre><br>  Dizemos ao SELinux para permitir que o systemd modifique a configuraÃ§Ã£o do Cgroups: <br><br><pre> <code class="plaintext hljs"># setsebool -P container_manage_cgroup true</code> </pre><br>  Muitos, a propÃ³sito, esquecem esta etapa.  Felizmente, basta fazer isso apenas uma vez e a configuraÃ§Ã£o Ã© salva apÃ³s a reinicializaÃ§Ã£o do sistema. <br><br>  Agora basta executar o contÃªiner: <br><br><pre> <code class="plaintext hljs"># podman run -ti -p 80:80 systemd systemd 239 running in system mode. (+PAM +AUDIT +SELINUX +IMA -APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN2 -IDN +PCRE2 default-hierarchy=hybrid) Detected virtualization container-other. Detected architecture x86-64. Welcome to Fedora 29 (Container Image)! Set hostname to &lt;1b51b684bc99&gt;. Failed to install release agent, ignoring: Read-only file system File /usr/lib/systemd/system/systemd-journald.service:26 configures an IP firewall (IPAddressDeny=any), but the local system does not support BPF/cgroup based firewalling. Proceeding WITHOUT firewalling in effect! (This warning is only shown for the first loaded unit using IP firewalling.) [ OK ] Listening on initctl Compatibility Named Pipe. [ OK ] Listening on Journal Socket (/dev/log). [ OK ] Started Forward Password Requests to Wall Directory Watch. [ OK ] Started Dispatch Password Requests to Console Directory Watch. [ OK ] Reached target Slices. â€¦ [ OK ] Started The Apache HTTP Server.</code> </pre><br>  Tudo, o serviÃ§o comeÃ§ou e funciona: <br><br><pre> <code class="plaintext hljs">$ curl localhost &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt; â€¦ &lt;/html&gt;</code> </pre><br>  NOTA: NÃ£o tente repetir isso no Docker!  LÃ¡, ainda sÃ£o necessÃ¡rias danÃ§as com um pandeiro para lanÃ§ar esses recipientes atravÃ©s de um demÃ´nio.  (Campos e pacotes adicionais serÃ£o necessÃ¡rios para que isso funcione perfeitamente no Docker ou precisarÃ¡ ser executado em um contÃªiner privilegiado. Consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">obter detalhes</a> .) <br><br><h3>  Mais algumas coisas legais sobre Podman e systemd </h3><br><h4>  O Podman funciona melhor que o docker em arquivos de unidades systemd </h4><br>  Se os contÃªineres precisarem ser iniciados na inicializaÃ§Ã£o do sistema, vocÃª poderÃ¡ simplesmente inserir os comandos Podman apropriados no arquivo de unidade systemd, que iniciarÃ¡ o serviÃ§o e o monitorarÃ¡.  Podman usa o modelo fork-exec padrÃ£o.  Em outras palavras, os processos do contÃªiner sÃ£o afiliados ao processo do Podman, para que o systemd possa monitorÃ¡-los facilmente. <br><br>  O Docker usa o modelo cliente-servidor, e os comandos da CLI do Docker tambÃ©m podem ser colocados diretamente no arquivo da unidade.  No entanto, depois que o cliente do Docker se conecta ao daemon do Docker, ele (o cliente) se torna apenas outro processo que processa stdin e stdout.  Por sua vez, o systemd nÃ£o tem idÃ©ia sobre a conexÃ£o entre o cliente do Docker e o contÃªiner que estÃ¡ executando o daemon do Docker e, portanto, nesse modelo, o systemd nÃ£o pode monitorar fundamentalmente o serviÃ§o. <br><br><h4>  AtivaÃ§Ã£o do Systemd via soquete </h4><br>  Podman realiza corretamente a ativaÃ§Ã£o atravÃ©s de um soquete.  Como o Podman usa o modelo fork-exec, ele pode encaminhar um soquete para seus processos de contÃªiner filho.  O Docker nÃ£o sabe como, porque usa um modelo cliente-servidor. <br><br>  O serviÃ§o varlink que o Podman usa para interagir com clientes remotos com contÃªineres Ã© realmente ativado pelo soquete.  O pacote cockpit-podman, escrito em Node.js e parte do projeto do cockpit, permite que as pessoas interajam com os contÃªineres do Podman por meio de uma interface da web.  O daemon da web em que o cockpit-podman estÃ¡ executando envia mensagens para o soquete varlink em que o systemd estÃ¡ ouvindo.  Depois disso, o systemd ativa o programa Podman para receber mensagens e comeÃ§ar a gerenciar contÃªineres.  A ativaÃ§Ã£o do systemd por meio de um soquete permite que vocÃª fique sem um daemon em constante funcionamento ao implementar APIs remotas. <br><br>  AlÃ©m disso, estamos desenvolvendo outro cliente para o Podman, chamado podman-remote, que implementa a mesma CLI do Podman, mas chama o varlink para lanÃ§ar contÃªineres.  O Podman-remote pode funcionar em cima de sessÃµes SSH, o que permite que vocÃª interaja com seguranÃ§a com contÃªineres em mÃ¡quinas diferentes.  Com o tempo, planejamos usar o podman-remote para oferecer suporte ao MacOS e Windows junto ao Linux, para que os desenvolvedores nessas plataformas possam executar a mÃ¡quina virtual Linux com o Podman varlink em execuÃ§Ã£o e ter a sensaÃ§Ã£o total de que os contÃªineres estÃ£o em execuÃ§Ã£o na mÃ¡quina local. <br><br><h4>  SD_NOTIFY </h4><br>  O Systemd permite adiar o lanÃ§amento de serviÃ§os auxiliares atÃ© que o serviÃ§o em contÃªiner necessÃ¡rio seja iniciado.  Podman pode encaminhar o soquete SD_NOTIFY para o serviÃ§o em contÃªiner, para que o serviÃ§o notifique o sistema sobre sua disponibilidade para o trabalho.  E novamente, o Docker, usando o modelo cliente-servidor, nÃ£o sabe como. <br><br><h3>  Nos planos </h3><br>  Planejamos adicionar o comando podman generate systemd CONTAINERID, que gerarÃ¡ o arquivo de unidade systemd para gerenciar um contÃªiner especÃ­fico.  Isso deve funcionar nos modos raiz e sem raiz para contÃªineres sem privilÃ©gios.  AtÃ© vimos uma solicitaÃ§Ã£o para criar um tempo de execuÃ§Ã£o systemd-nspawn compatÃ­vel com OCI. <br><br><h3>  ConclusÃ£o </h3><br>  A execuÃ§Ã£o do systemd em um contÃªiner Ã© uma necessidade compreensÃ­vel.  E, graÃ§as ao Podman, finalmente temos um ambiente de lanÃ§ador de contÃªiner que nÃ£o Ã© hostil ao systemd, mas facilita o uso. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468931/">https://habr.com/ru/post/pt468931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468913/index.html">BotÃ£o Amazon Dash: Retrospectivo</a></li>
<li><a href="../pt468915/index.html">Como a Cisco monitora a seguranÃ§a das informaÃ§Ãµes das empresas absorvidas e fornece acesso a seus recursos?</a></li>
<li><a href="../pt468923/index.html">Eu ligo de volta</a></li>
<li><a href="../pt468927/index.html">Quinteto em vez de Byte - abordagem de armazenamento e recuperaÃ§Ã£o de dados</a></li>
<li><a href="../pt468929/index.html">O mini-manual de como instalar um hackintosh Ã© o mais simples e simples possÃ­vel</a></li>
<li><a href="../pt468933/index.html">Pontudo e afiado, onde quer que vocÃª olhe: o mecanismo de auto-afiaÃ§Ã£o dos dentes dos ouriÃ§os-do-mar</a></li>
<li><a href="../pt468935/index.html">Resumo de eventos para profissionais de RH na Ã¡rea de TI em outubro de 2019</a></li>
<li><a href="../pt468937/index.html">Ataques de cartÃ£o bancÃ¡rio sem contato</a></li>
<li><a href="../pt468943/index.html">this e ScopeChain no EcmaScript</a></li>
<li><a href="../pt468945/index.html">ITIL e ITSM sÃ£o uma histÃ³ria de grande decepÃ§Ã£o. Existe algum benefÃ­cio? Quanto custa e quem exatamente NÃƒO "implementa o ITIL"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>