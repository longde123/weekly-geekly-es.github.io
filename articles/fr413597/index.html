<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏼 👩🏽‍🤝‍👨🏾 🤰🏾 «Dernier recours» ou pourquoi la première conception de la base de données est nécessaire 🏪 ‼️ 🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article très récent, j'expliquerai pourquoi, à mon avis, dans la plupart des cas, lors du développement d'un modèle de données pour une appli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>«Dernier recours» ou pourquoi la première conception de la base de données est nécessaire</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413597/"><p>  Dans cet article très récent, j'expliquerai pourquoi, à mon avis, dans la plupart des cas, lors du développement d'un modèle de données pour une application, vous devez suivre la première approche de la base de données.  Au lieu de l'approche «Java [tout autre langage] d'abord», qui vous emmène sur une longue piste pleine de douleur et de souffrance, dès que le projet commence à grandir. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2ae/fcf/aaf/2aefcfaafbeb94adc7a73ec265b5feb1.png" alt="image"><br>  <em>"Trop occupé pour être meilleur" <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sous licence CC</a> par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Alan O'Rourke / Audience Stack</a> .</em>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Image originale</a></em> <em><br></em> </p><a name="habracut"></a><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cet article est inspiré d'une récente question sur StackOverflow</a> . </p><br><p>  Discussions reddit intéressantes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">/ r / java</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">/ r / programmation</a> . </p><br><h2 id="kodogeneraciya">  Génération de code </h2><br><p>  À ma grande surprise, un petit groupe d'utilisateurs semble avoir été choqué par le fait que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">jOOQ est</a> fortement lié à la génération de code source. </p><br><p>  Bien que vous puissiez utiliser jOOQ exactement comme vous le souhaitez, la manière préférée (selon la documentation) est de commencer avec le schéma de base de données existant, puis de générer les classes clientes nécessaires (correspondant à vos tables) à l'aide de jOOQ, et après cela, il est facile d'écrire en toute sécurité requêtes pour ces tables: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Record2&lt;String, String&gt; record : DSL.using(configuration) <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^^^^^^^^^^^^^^ Type information derived from the // generated code referenced from the below SELECT clause .select(ACTOR.FIRST_NAME, ACTOR.LAST_NAME) // vvvvv ^^^^^^^^^^^^ ^^^^^^^^^^^^^^^ Generated names .from(ACTOR) .orderBy(1, 2)) { // ... }</span></span></code> </pre> <br><p>  Le code peut être généré soit manuellement en dehors de l'assembly, soit automatiquement avec chaque assembly.  Par exemple, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">telle génération peut se produire immédiatement après l'installation des migrations Flyway</a> , qui peuvent également être démarrées manuellement ou automatiquement. </p><br><h3 id="generaciya-ishodnogo-koda">  Génération de code source </h3><br><p>  Il existe différentes philosophies, avantages et inconvénients concernant ces approches de génération de code que je ne veux pas aborder dans cet article.  Mais en substance, la signification du code généré est qu'il s'agit d'une représentation Java de ce que nous considérons comme une sorte de "standard" (à l'intérieur et à l'extérieur de notre système).  D'une certaine manière, les compilateurs font la même chose lorsqu'ils génèrent du bytecode, du code machine ou un autre code source à partir de la source - en conséquence, nous avons une idée de notre «standard» dans un autre langage spécifique. </p><br><p>  Il existe de nombreux générateurs de code.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">XJC peut générer du code Java à partir de fichiers XSD ou WSDL</a> .  Le principe est toujours le même: </p><br><ul><li>  Il existe des normes (externes ou internes), telles que les spécifications, le modèle de données, etc. </li><li>  Il est nécessaire de se faire une idée de cette norme dans notre langage de programmation habituel. </li></ul><br><p>  Et presque toujours, il est logique de <em>générer</em> cette vue afin d'éviter un travail inutile et des erreurs inutiles. </p><br><h3 id="type-providers-i-obrabotka-annotaciy">  Fournisseurs de type et traitement des annotations </h3><br><p>  Il est à noter qu'une autre approche, plus moderne, de la génération de code dans jOOQ est les fournisseurs de type ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comme cela se fait en F #</a> ), où le code est généré par le compilateur pendant la compilation et n'existe jamais sous sa forme originale.  Un outil similaire (mais moins sophistiqué) en Java est les processeurs d'annotation tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lombok</a> . </p><br><p>  Dans les deux cas, tout est identique à la génération de code normale, sauf: </p><br><ul><li>  Vous ne voyez pas le code généré (peut-être pour beaucoup, c'est un gros plus?) </li><li>  Vous devez vous assurer que votre «référence» est disponible à chaque compilation.  Cela ne pose aucun problème dans le cas de Lombok, qui annote directement le code source lui-même, qui est le "standard" dans ce cas.  Un peu plus compliqué avec les modèles de base de données qui reposent sur une connexion en direct toujours active. </li></ul><br><h2 id="v-chem-problema-s-generaciey-koda">  Quel est le problème avec la génération de code? </h2><br><p>  Outre la question délicate de savoir s'il faut générer le code manuellement ou automatiquement, certaines personnes pensent que le code n'a pas du tout besoin d'être généré.  La raison pour laquelle j'entends le plus souvent est qu'une telle génération est difficile à implémenter dans le pipeline CI / CD.  Et oui, c'est vrai, car  nous obtenons des frais généraux pour créer et prendre en charge une infrastructure supplémentaire, surtout si vous êtes nouveau dans les outils utilisés (jOOQ, JAXB, Hibernate, etc.). </p><br><p>  Si les frais généraux liés à l'étude du générateur de code sont trop élevés, il y aura vraiment peu d'avantages.  Mais c'est le seul argument contre.  Dans la plupart des autres cas, cela n'a absolument aucun sens d'écrire manuellement du code, qui est la représentation habituelle d'un modèle de quelque chose. </p><br><p>  Beaucoup de gens affirment qu’ils n’ont pas le temps pour cela, car  en ce moment, vous devez déployer un autre MVP dès que possible.  Et ils pourront finaliser leur pipeline CI / CD un peu plus tard.  Dans de tels cas, je dis généralement: "Vous êtes trop occupé pour aller mieux". </p><br><h2 id="no-ved-hibernatejpa-delaet-java-first-razrabotku-gorazdo-prosche">  "Mais Hibernate / JPA facilite beaucoup le premier développement Java." </h2><br><p>  Oui c'est vrai.  C'est à la fois une joie et une douleur pour les utilisateurs d'Hibernate.  Avec lui, vous pouvez simplement écrire plusieurs objets du formulaire: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; String title; }</code> </pre> <br><p>  Et c'est presque fini.  Ensuite, Hibernate se chargera de toute la routine sur la façon de définir cet objet en DDL et dans le dialecte SQL souhaité: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> book ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GENERATED</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALWAYS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>, title <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> pk_book PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> i_book_title <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> book (title);</code> </pre> <br><p>  C'est vraiment un excellent moyen de démarrer rapidement le développement - il vous suffit de démarrer l'application. </p><br><p>  Mais tout n'est pas si rose.  Il y a encore beaucoup de questions: </p><br><ul><li>  Hibernate générera-t-il le nom dont j'ai besoin pour la clé primaire? </li><li>  Vais-je créer l'index dont j'ai besoin dans le champ TITLE? </li><li>  Une valeur d'ID unique sera-t-elle générée pour chaque enregistrement? </li></ul><br><p>  Il semble que non.  Mais pendant que le projet est en cours de développement, vous pouvez toujours jeter votre base de données actuelle et tout générer à partir de zéro en ajoutant les annotations nécessaires au modèle. <br>  Ainsi, la classe de livre dans sa forme finale ressemblera à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"book"</span></span>, indexes = { <span class="hljs-meta"><span class="hljs-meta">@Index</span></span>(name = <span class="hljs-string"><span class="hljs-string">"i_book_title"</span></span>, columnList = <span class="hljs-string"><span class="hljs-string">"title"</span></span>) }) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Book</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span>(strategy = IDENTITY) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; String title; }</code> </pre> <br><h2 id="no-vy-zaplatite-za-eto-chut-pozzhe">  Mais tu paieras pour ça, un peu plus tard </h2><br><p>  Tôt ou tard, votre application entre en production et le schéma décrit cessera de fonctionner: </p><br><blockquote>  Dans un système vivant et réel, vous ne pouvez plus simplement récupérer et déposer votre base de données, car  les données y sont utilisées et peuvent coûter beaucoup d'argent. </blockquote><p>  À partir de maintenant, vous devez écrire des scripts de migration pour chaque changement dans le modèle de données, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">par exemple, en utilisant Flyway</a> .  Mais qu'advient-il de vos classes clientes?  Vous pouvez soit les adapter manuellement (ce qui entraînera un double travail), soit demander à Hibernate de les générer (mais quelle est la probabilité que les résultats d'une telle génération répondent aux attentes?).  En conséquence, vous pouvez vous attendre à de gros problèmes. </p><br><p>  Dès que le code entre en production, il est presque immédiatement nécessaire d'apporter des corrections, et le plus rapidement possible. </p><br><p>  Et parce que  l'installation des migrations de base de données n'est pas intégrée à votre chaîne de montage; vous devrez installer ces correctifs manuellement à vos risques et périls.  Il n'y aura pas assez de temps pour revenir en arrière et tout faire correctement.  Il suffit de blâmer Hibernate pour tous ses ennuis. </p><br><p>  Au lieu de cela, vous auriez pu agir différemment dès le départ.  À savoir, utilisez des roues rondes au lieu de celles carrées. </p><br><h2 id="vpered-k-database-first">  Allez d'abord à la base de données </h2><br><p>  La référence et le contrôle du schéma de données se trouvent dans le bureau de votre SGBD.  Une base de données est le seul endroit où un schéma est défini, et tous les clients ont une <em>copie de</em> ce schéma, mais pas l'inverse.  Les données sont dans votre base de données, et non dans votre client, il est donc logique de fournir un contrôle du schéma et de son intégrité exactement où les données se trouvent. </p><br><p>  C'est de la vieille sagesse, rien de nouveau.  Les clés primaires et uniques sont bonnes.  Les clés étrangères sont belles.  La vérification des contraintes côté base de données est formidable.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les assertions (quand elles sont finalement implémentées) sont</a> géniales. </p><br><p>  Et ce n'est pas tout.  Par exemple, si vous utilisez Oracle, vous pouvez spécifier: </p><br><ul><li>  Dans quel espace de table se trouve votre table? </li><li>  Quelle est la signification de PCTFREE qu'elle a </li><li>  Quelle est la taille du cache de séquence? </li></ul><br><p>  Peut-être que tout cela n'a pas d'importance sur les petits systèmes, mais sur les systèmes plus grands, vous n'avez pas à suivre le chemin du «big data» jusqu'à ce que vous extrayiez tous les jus de votre stockage actuel.  Pas un seul ORM que j'ai jamais vu (y compris jOOQ) ne vous permettra d'utiliser l'ensemble complet des paramètres DDL fournis par votre SGBD.  Les ORM ne proposent que quelques outils pour vous aider à écrire DDL. </p><br><p>  En fin de compte, un schéma bien conçu ne doit être écrit que manuellement à l'aide d'un DDL spécifique au SGBD.  Tous les DDL générés automatiquement ne sont qu'une approximation de cela. </p><br><h2 id="chto-naschet-klientskoy-modeli">  Et le modèle client? </h2><br><p>  Comme mentionné précédemment, vous aurez besoin d'une certaine représentation du schéma de base de données côté client.  Il va sans dire que cette vue doit être synchronisée avec le modèle réel.  Comment faire  Bien sûr, en utilisant des générateurs de code. </p><br><p>  Toutes les bases de données donnent accès à leurs méta-informations via le bon vieux SQL.  Ainsi, par exemple, vous pouvez obtenir une liste de toutes les tables de différentes bases de données: </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- H2, HSQLDB, MySQL, PostgreSQL, SQL Server SELECT table_schema, table_name FROM information_schema.tables -- DB2 SELECT tabschema, tabname FROM syscat.tables -- Oracle SELECT owner, table_name FROM all_tables -- SQLite SELECT name FROM sqlite_master -- Teradata SELECT databasename, tablename FROM dbc.tables</span></span></code> </pre> <br><p>  Ce sont ces requêtes (ainsi que les requêtes similaires pour les vues, les vues matérialisées et les fonctions de table) qui sont exécutées lorsque la méthode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DatabaseMetaData.getTables ()</a> d'un pilote JDBC spécifique est appelée, ou dans le module jOOQ-meta. </p><br><p>  À partir des résultats de ces requêtes, il est relativement facile de créer une représentation client du modèle de base de données, quelle que soit la technologie d'accès aux données utilisée. </p><br><ul><li>  Si vous utilisez JDBC ou Spring, vous pouvez créer un groupe de constantes String </li><li>  Si vous utilisez JPA, vous pouvez créer des objets vous-même </li><li>  Si vous utilisez jOOQ, vous pouvez créer des métamodèles jOOQ </li></ul><br><p>  Selon le nombre de fonctionnalités offertes par votre API d'accès aux données (jOOQ, JPA ou autre), le métamodèle généré peut être vraiment riche et complet.  Par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la fonction de jointure implicite dans jOOQ 3.11, qui repose sur des méta-informations sur les relations des clés étrangères entre vos tables</a> . </p><br><p>  Désormais, toute modification du schéma de base de données entraînera automatiquement une mise à jour du code client. </p><br><p>  Imaginez que vous deviez renommer une colonne dans un tableau: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> book <span class="hljs-keyword"><span class="hljs-keyword">RENAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> book_title;</code> </pre> <br><p>  Voulez-vous vraiment effectuer ce travail deux fois?  Pas question.  Validez simplement ce DDL, exécutez la génération et profitez de l'objet mis à jour: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Table</span></span>(name = <span class="hljs-string"><span class="hljs-string">"book"</span></span>, indexes = { <span class="hljs-comment"><span class="hljs-comment">// Would you have thought of this? @Index(name = "i_book_title", columnList = "book_title") }) class Book { @Id @GeneratedValue(strategy = IDENTITY) int id; @Column("book_title") String **bookTitle**; }</span></span></code> </pre> <br><p>  De plus, le client reçu n'a pas besoin d'être compilé à chaque fois (au moins jusqu'à la prochaine modification du schéma de base de données), ce qui peut déjà être un gros plus! <br>  La plupart des modifications DDL sont également des modifications sémantiques, pas seulement syntaxiques.  Ainsi, il est formidable de voir dans le code client généré quels sont exactement les derniers changements dans la base de données affectés. </p><br><h2 id="pravda-vsegda-odna">  La vérité est toujours seule </h2><br><p>  Quelle que soit la technologie que vous utilisez, il ne doit y avoir qu'un seul modèle, qui est la norme pour le sous-système.  Ou, du moins, nous devons nous efforcer de le faire et éviter la confusion dans les affaires, où la «norme» est partout et nulle part en même temps.  Cela rend tout beaucoup plus facile.  Par exemple, si vous partagez des fichiers XML avec un autre système, vous utilisez probablement XSD.  En tant que métamodèle INFORMATION_SCHEMA jOOQ au format XML: <a href="">https://www.jooq.org/xsd/jooq-meta-3.10.0.xsd</a> </p><br><ul><li>  XSD est bien compris </li><li>  XSD décrit parfaitement le contenu XML et permet la validation dans toutes les langues du client </li><li>  XSD rend la gestion des versions facile et rétrocompatible </li><li>  XSD peut être transformé en code Java à l'aide de XJC </li></ul><br><p>  Nous accordons une attention particulière au dernier point.  Lors de la communication avec un système externe via des messages XML, nous devons être sûrs de la validité des messages.  Et c'est vraiment très facile à faire avec des choses comme JAXB, XJC et XSD.  Il serait fou de penser à la pertinence de l'approche Java-first dans ce cas.  Le XML généré à partir des objets XML sera de mauvaise qualité, mal documenté et difficile à étendre.  Et s'il existe un SLA pour une telle interaction, vous serez déçu. </p><br><p>  Honnêtement, cela ressemble à ce qui se passe avec les différentes API JSON maintenant, mais c'est une histoire complètement différente ... </p><br><h3 id="chem-bazy-dannyh-huzhe">  Qu'est-ce qui aggrave les bases de données? </h3><br><p>  Lorsque vous travaillez avec une base de données, tout est identique ici.  La base de données est propriétaire des données et doit également être le maître du schéma de données.  Toutes les modifications de schéma doivent être effectuées directement via DDL pour mettre à jour la référence. </p><br><p>  Après avoir mis à jour la référence, tous les clients doivent mettre à jour leurs idées sur le modèle.  Certains clients peuvent être écrits en Java à l'aide de jOOQ et / ou Hibernate ou JDBC.  D'autres clients peuvent être écrits en Perl (bonne chance à eux) ou même en C #.  Ce n'est pas grave.  Le modèle principal est dans la base de données.  Bien que les modèles créés à l'aide d'ORM soient de mauvaise qualité, peu documentés et difficiles à étendre. </p><br><p>  Par conséquent, ne faites pas cela, et depuis le tout début du développement.  Commencez plutôt avec une base de données.  Créez un pipeline CI / CD automatisé.  Utilisez la génération de code pour générer automatiquement un modèle de base de données pour les clients pour chaque génération.  Et arrêtez de vous inquiéter, tout ira bien.  Tout ce qui est requis est un petit effort initial pour mettre en place l'infrastructure, mais vous obtiendrez ainsi un gain dans le processus de développement pour le reste de votre projet pour les années à venir. </p><br><p>  Non merci. </p><br><h2 id="poyasneniya">  Explications </h2><br><p>  Pour consolider: cet article ne prétend en aucun cas que le modèle de base de données doit s'appliquer à l'ensemble de votre système (domaine, logique métier, etc.).  Mes déclarations consistent uniquement dans le fait que le code client interagissant avec la base de données ne doit être qu'une <em>représentation</em> du schéma de la base de données, mais pas le définir et le former de quelque manière que ce soit. </p><br><p>  Dans les architectures à deux niveaux qui ont encore leur place, le schéma de base de données peut être la seule source d'informations sur le modèle de votre système.  Cependant, sur la plupart des systèmes, je vois le niveau d'accès aux données comme un «sous-système» qui encapsule un modèle de base de données.  Quelque chose comme ça. </p><br><h2 id="isklyucheniya">  Exceptions </h2><br><p>  Comme dans toute autre bonne règle, la nôtre a également ses exceptions (et j'ai déjà averti que la première approche de la base de données et la génération de code ne sont pas toujours le bon choix).  Ces exceptions (la liste n'est peut-être pas complète): </p><br><ul><li>  Lorsque le circuit n'est pas connu à l'avance et doit être étudié.  Par exemple, vous êtes un fournisseur d'un outil pour aider les utilisateurs à naviguer dans n'importe quel schéma.  Bien sûr, il ne peut y avoir de génération de code.  Mais dans tous les cas, vous devez gérer la base de données elle-même et son schéma. </li><li>  Lorsque pour une tâche, vous devez créer un schéma à la volée.  Cela peut être similaire à l'une des variantes du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">modèle Entité-attribut-valeur</a> , comme  vous n'avez pas de modèle clairement défini.  De plus, rien ne garantit que le SGBDR dans ce cas est le bon choix. </li></ul><br><p>  La particularité de ces exceptions est qu'elles se rencontrent rarement dans la faune.  Dans la plupart des cas, lors de l'utilisation de bases de données relationnelles, le schéma est connu à l'avance et constitue la «norme» de votre modèle, et les clients doivent travailler avec une copie de ce modèle générée à l'aide de générateurs de code. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413597/">https://habr.com/ru/post/fr413597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413585/index.html">Collaboration Hansen: bonne ou rien (partie 2)</a></li>
<li><a href="../fr413587/index.html">Évaluation de la couverture de test d'un projet Java en utilisant Apache Ignite comme exemple</a></li>
<li><a href="../fr413589/index.html">Revue de code: expérience réussie</a></li>
<li><a href="../fr413591/index.html">Robotique industrielle - 57 ans! Rappelez-vous d'où vient le décompte</a></li>
<li><a href="../fr413593/index.html">Continuer à conquérir le fond de la mer. Microsoft et son projet de centre de données sous-marin Natick 2</a></li>
<li><a href="../fr413599/index.html">Il y a S.L.O.N.a en plusieurs parties. Introduisez ITAM et ne vous étouffez pas</a></li>
<li><a href="../fr413601/index.html">Le centre de données de Microsoft chauffe-t-il la mer</a></li>
<li><a href="../fr413603/index.html">Génération de code dans Uber</a></li>
<li><a href="../fr413605/index.html">Demandez à Ethan: que se passe-t-il lorsqu'une étoile traverse le système solaire?</a></li>
<li><a href="../fr413607/index.html">Fintech digest: les monnaies numériques ne menacent pas le système financier de la Fédération de Russie; PayPal a découvert combien les joueurs dépensent pour les jeux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>