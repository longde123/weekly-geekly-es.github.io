<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💼 👜 🙅🏿 Unsafe.AsSpan: Span <T> comment remplacer les pointeurs? 🎒 👨🏾‍🤝‍👨🏼 🌤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C# est un langage incroyablement flexible. Sur celui-ci, vous pouvez écrire non seulement le backend ou les applications de bureau. J'utilise C# pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unsafe.AsSpan: Span <T> comment remplacer les pointeurs?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465077/"><p><img src="https://habrastorage.org/webt/3f/dh/ia/3fdhia5h25mpjbabeocnlygdd1c.png"></p><br><p> <code>C#</code> est un langage incroyablement flexible.  Sur celui-ci, vous pouvez écrire non seulement le backend ou les applications de bureau.  J'utilise <code>C#</code> pour travailler avec des données scientifiques, qui imposent certaines exigences aux outils disponibles dans le langage.  Bien que <code>netcore</code> l'agenda (étant donné qu'après <code>netstandard2.0</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plupart des</a> fonctionnalités des deux langues et du runtime ne sont pas <code>netframework</code> sur <code>netframework</code> ), je continue de travailler avec les projets hérités. </p><br><p>  Dans cet article, je considère une application non évidente (mais probablement souhaitée?) De <code>Span&lt;T&gt;</code> et la différence entre l'implémentation de <code>Span&lt;T&gt;</code> dans <code>netframework</code> et <code>netcore</code> raison des spécificités de <code>clr</code> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Clause de non-responsabilité 1</b> <div class="spoiler_text"><p>  Les extraits de code de cet article ne sont en aucun cas destinés à être utilisés dans des projets du monde réel. </p><br><p>  La solution proposée au problème (farfelu?) Est plutôt une preuve de concept. <br>  Dans tous les cas, en implémentant cela dans votre projet, vous le faites à vos risques et périls. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Clause de non-responsabilité 2</b> <div class="spoiler_text"><p>  Je suis absolument sûr que quelque part, dans certains cas, cela <strong>va certainement</strong> tirer sur quelqu'un dans le genou. </p><br><p>  Le contournement de sécurité de type en <code>C#</code> peu susceptible de conduire à quelque chose de bon. </p><br><p>  Pour des raisons évidentes, je n'ai pas testé ce code dans toutes les situations possibles, cependant, les résultats préliminaires semblent prometteurs. </p></div></div><br><h1 id="a-zachem-mne-voobsche-spant">  Pourquoi ai-je besoin de <code>Span&lt;T&gt;</code> ? </h1><br><p>  Spen vous permet de travailler avec des tableaux de types <code>unmanaged</code> sous une forme plus pratique, réduisant le nombre d'allocations nécessaires.  Malgré le fait que la prise en charge de l'intervalle dans le <code>netframework</code> <code>BCL</code> <code>netframework</code> presque totalement absente, plusieurs outils peuvent être obtenus à l'aide de <code>System.Memory</code> , <code>System.Buffers</code> et <code>System.Runtime.CompilerServices.Unsafe</code> . <br>  L'utilisation des travées dans mon projet hérité est limitée, cependant, je les ai trouvées une utilisation non évidente, tout en crachant sur la sécurité des types. <br>  Quelle est cette application?  Dans mon projet, je travaille avec des données obtenues à partir d'un outil scientifique.  Ce sont des images, qui, en général, sont un tableau de <code>T[]</code> , où <code>T</code> est l'un des types primitifs <code>unmanaged</code> , par exemple <code>Int32</code> (alias <code>int</code> ).  Pour sérialiser correctement ces images sur le disque, je dois prendre en charge le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">format hérité</a> incroyablement gênant, qui a été proposé en <a href="">1981</a> , et a depuis peu changé.  Le principal problème de ce format est qu'il est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BigEndian</a> .  Ainsi, pour écrire (ou lire) un tableau non compressé de <code>T[]</code> , vous devez changer l'endianess de chaque élément.  La tâche triviale. <br>  Quelles sont les solutions évidentes? </p><br><ol><li>  Nous parcourons le tableau <code>T[]</code> , appelons <code>BitConverter.GetBytes(T)</code> , développons ces quelques octets, copions dans le tableau cible. </li><li>  Nous parcourons le tableau <code>T[]</code> , effectuons des fraudes de la forme <code>new byte[] {(byte)((x &amp; 0xFF00) &gt;&gt; 8), (byte)(x &amp; 0x00FF)};</code>  (devrait fonctionner sur les types à deux octets), écrivez dans le tableau cible. </li><li>  <sup>*</sup> Mais <code>T[]</code> un tableau?  Les éléments sont alignés, non?  Vous pouvez donc aller jusqu'au bout, par exemple, <code>Buffer.BlockCopy(intArray, 0, byteArray, 0, intArray.Length * sizeof(int));</code>  .  La méthode copie le tableau dans le tableau en ignorant la vérification de type.  Il suffit seulement de ne pas manquer les limites et l'allocation.  Nous mélangons les octets en conséquence. </li><li>  <sup>*</sup> Ils disent que <code>C#</code> est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>(C++)++</code></a> .  Par conséquent, activez <code>/unsafe</code> , <code>fixed(int* p = &amp;intArr[0]) byte* bPtr = (byte*)p;</code>  et maintenant vous pouvez parcourir la représentation en octets du tableau source, modifier l'endianess à la volée et écrire des blocs sur le disque (en ajoutant <code>stackalloc byte[]</code> ou <code>ArrayPool&lt;byte&gt;.Shared</code> pour le tampon intermédiaire) sans allouer de mémoire pour un tout nouveau tableau d'octets. </li></ol><br><p>  Il semblerait que le point <strong>4</strong> vous permette de résoudre tous les problèmes, mais l'utilisation explicite d'un contexte <code>unsafe</code> et le travail avec des pointeurs sont en quelque sorte complètement différents.  Puis <code>Span&lt;T&gt;</code> vient à notre aide. </p><br><h1 id="spant"> <code>Span&lt;T&gt;</code> </h1> <br><p>  <code>Span&lt;T&gt;</code> devrait techniquement fournir des outils pour travailler avec des tracés de mémoire presque comme travailler avec des pointeurs, tout en éliminant la nécessité de «réparer» la matrice en mémoire.  Un tel pointeur compatible <code>GC</code> avec des limites de tableau.  Tout va bien et en sécurité. <br>  Une chose mais - malgré la richesse de <code>System.Runtime.CompilerServices.Unsafe</code> , <code>Span&lt;T&gt;</code> cloué sur le type <code>T</code>  Étant donné que le spen est essentiellement un pointeur de longueur <sup>1</sup> +, que se passe-t-il si vous retirez votre pointeur, le convertissez en un autre type, recalculez la longueur et créez un nouveau span?  Heureusement, nous avons <code>public Span&lt;T&gt;(void* pointer, int length)</code> . <br>  Écrivons un test simple: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Flip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> {<span class="hljs-comment"><span class="hljs-comment">/*   endianess */</span></span>} Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] {<span class="hljs-number"><span class="hljs-number">123</span></span>}; Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; y = DangerousCast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(x); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Flip(y); Assert.AreNotEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); Flip(y); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, x[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br><p>  Des développeurs plus avancés que je ne devrais immédiatement réaliser ce qui ne va pas ici.  Le test échouera-t-il?  La réponse, comme cela arrive généralement, <strong>dépend</strong> . <br>  Dans ce cas, cela dépend principalement de l'exécution.  Sur <code>netcore</code> test <em>devrait</em> fonctionner, mais sur <code>netframework</code> , comment ça se <code>netframework</code> . <br>  Fait intéressant, si vous supprimez certains des essais, le test commence à fonctionner correctement dans 100% des cas. <br>  Faisons les choses correctement. </p><br><p>  <sup>1</sup> J'avais <em>tort</em> . </p><br><h1 id="pravilnyy-otvet-zavisit">  Bonne réponse: dépend </h1><br><p>  Pourquoi le résultat <em>dépend-il</em> ? <br>  Supprimons tous les inutiles et écrivons ici un tel code: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Check(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Check</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-number"><span class="hljs-number">999</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">-100</span></span>}; Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; y = As&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">@"FRAMEWORK_NAME"</span></span>); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); Console.WriteLine(); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0]"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y, <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0]"</span></span>); Console.WriteLine(); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Offset&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0] offset by size_t"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Offset&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0] offset by size_t"</span></span>); Console.WriteLine(); GC.Collect(<span class="hljs-number"><span class="hljs-number">0</span></span>, GCCollectionMode.Forced, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x, <span class="hljs-string"><span class="hljs-string">"Span&lt;int&gt; [0] after GC"</span></span>); Write&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y, <span class="hljs-string"><span class="hljs-string">"Span&lt;byte&gt;[0] after GC"</span></span>); Console.WriteLine(); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> x); Write(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> y); }</code> </pre> <br><p>  La méthode <code>Write&lt;T, U&gt;</code> accepte une plage de type <code>T</code> , lit l'adresse du premier élément et lit à travers ce pointeur un élément de type <code>U</code>  En d'autres termes, <code>Write&lt;int, int&gt;(ref x)</code> affichera l'adresse en mémoire + le nombre 999. <br>  L' <code>Write</code> normale imprime un tableau. <br>  Maintenant sur la méthode <code>As&lt;,&gt;</code> : </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> Span&lt;U&gt; As&lt;T, U&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> U : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">fixed</span></span>(T* ptr = span) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Span&lt;U&gt;(ptr, span.Length * Unsafe.SizeOf&lt;T&gt;() / Unsafe.SizeOf&lt;U&gt;()); }</code> </pre> <br><p>  <code>C#</code> syntaxe <code>C#</code> prend désormais en charge cet enregistrement à état <code>fixed</code> en appelant implicitement la méthode <code>Span&lt;T&gt;.GetPinnableReference()</code> . <br>  Exécutez cette méthode sur <code>netframework4.8</code> en mode <code>x64</code> .  Nous regardons ce qui se passe: </p><br><pre> <code class="plaintext hljs">LEGACY [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ] 0x|00|00|02|8C|00|00|2F|B0 999 Span&lt;int&gt; [0] 0x|00|00|02|8C|00|00|2F|B0 999 Span&lt;byte&gt;[0] 0x|00|00|02|8C|00|00|2F|B8 11 Span&lt;int&gt; [0] offset by size_t 0x|00|00|02|8C|00|00|2F|B8 11 Span&lt;byte&gt;[0] offset by size_t 0x|00|00|02|8C|00|00|2B|18 999 Span&lt;int&gt; [0] after GC 0x|00|00|02|8C|00|00|2F|B0 6750318 Span&lt;byte&gt;[0] after GC [ 999, 123, 11, -100 ] [ 110, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]</code> </pre> <br><p>  Initialement, les deux travées (malgré un type différent) se comportent de manière identique, et la <code>Span&lt;byte&gt;</code> , en substance, représente une vue octet du tableau d'origine.  Ce dont vous avez besoin. <br>  D'accord, essayons de décaler le début de la plage à la taille d'un <code>IntPtr</code> (ou <code>2 X int</code> sur <code>x64</code> ) et lisons.  Nous obtenons le troisième élément du tableau et la bonne adresse.  Et puis nous ramasserons les ordures ... </p><br><pre> <code class="plaintext hljs">GC.Collect(0, GCCollectionMode.Forced, true, true);</code> </pre> <br><p>  Le dernier indicateur de cette méthode demande au <code>GC</code> compacter le tas.  Après avoir appelé <code>GC.Collect</code> <code>GC</code> déplace la baie locale d'origine.  <code>Span&lt;int&gt;</code> reflète ces changements, mais notre <code>Span&lt;byte&gt;</code> continue de pointer vers l'ancienne adresse, où maintenant il n'est pas clair quoi.  Une excellente façon de vous tirer tous les genoux à la fois! </p><br><p>  Examinons maintenant le résultat du même fragment de code appelé sur <code>netcore3.0.100-preview8</code> . </p><br><pre> <code class="plaintext hljs">CORE [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ] 0x|00|00|01|F2|8F|BD|C6|90 999 Span&lt;int&gt; [0] 0x|00|00|01|F2|8F|BD|C6|90 999 Span&lt;byte&gt;[0] 0x|00|00|01|F2|8F|BD|C6|98 11 Span&lt;int&gt; [0] offset by size_t 0x|00|00|01|F2|8F|BD|C6|98 11 Span&lt;byte&gt;[0] offset by size_t 0x|00|00|01|F2|8F|BD|BF|38 999 Span&lt;int&gt; [0] after GC 0x|00|00|01|F2|8F|BD|BF|38 999 Span&lt;byte&gt;[0] after GC [ 999, 123, 11, -100 ] [ 231, 3, 0, 0, 123, 0, 0, 0, 11, 0, 0, 0, 156, 255, 255, 255 ]</code> </pre> <br><p>  Tout fonctionne, et cela fonctionne de <em>manière stable</em> , pour autant que je puisse voir.  Après compactage, les deux espagne changent de pointeur.  Super!  Mais comment le faire fonctionner maintenant dans un projet hérité? </p><br><h1 id="jit-intrinsic">  Jit intrinsèque </h1><br><p>  J'ai absolument oublié que la prise en charge des portées est implémentée dans <code>netcore</code> via <a href="">intrinsik</a> .  En d'autres termes, <code>netcore</code> peut créer des pointeurs internes même vers un fragment de tableau et mettre à jour correctement les liens lorsque le <code>GC</code> déplace.  Dans le <code>netframework</code> , l'implémentation par <code>nuget</code> d'une travée est une béquille.  En fait, nous avons deux spen différents: l'un est créé à partir du tableau et suit ses liens, le second à partir du pointeur et n'a aucune idée de ce vers quoi il pointe.  Après avoir déplacé le tableau d'origine, le pointeur span continue de pointer vers l'endroit où le pointeur est passé dans son constructeur pointé.  À titre de comparaison, <code>netcore</code> un <em>exemple d'</em> implémentation de span dans <code>netcore</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> ByReference&lt;T&gt; _pointer; <span class="hljs-comment"><span class="hljs-comment">//  -   private readonly int _length; }</span></span></code> </pre> <br><p>  et en <code>netframework</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Span&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Pinnable&lt;T&gt; _pinnable; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IntPtr _byteOffset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; }</code> </pre> <br><p>  <code>_pinnable</code> contient une référence au tableau, si elle a été transmise au constructeur, <code>_byteOffset</code> contient un décalage (même l'étendue dans le tableau a un décalage non nul lié à la façon dont le tableau est représenté en mémoire, <em>probablement</em> ).  Si vous passez le pointeur <code>void*</code> au constructeur, il est simplement converti en <code>_byteOffset</code> absolu.  Span sera étroitement fixé à la zone mémoire, et toutes les méthodes d'instance regorgent de conditions comme <code>if(_pinnable is null) {/*    */} else {/*    _pinnable */}</code> .  Que faire dans une telle situation? </p><br><h1 id="kak-delat-ne-stoit-no-ya-vse-zhe-sdelal">  Comment le faire n'en vaut pas la peine, mais je l'ai quand même fait </h1><br><p>  Cette section est consacrée aux différentes implémentations prises en charge par <code>netframework</code> , qui permettent de <code>netframework</code> <code>Span&lt;T&gt; -&gt; Span&lt;U&gt;</code> , en conservant tous les liens nécessaires. <br>  <strong>Je vous préviens: il s'agit d'une zone de programmation anormale avec éventuellement des erreurs fondamentales et un comportement indéfini à la fin</strong> </p><br><h2 id="metod-1-naivnyy">  Méthode 1: naïve </h2><br><p>  Comme l'exemple l'a montré, la conversion des pointeurs ne donnera pas le résultat souhaité sur le <code>netframework</code> .  Nous avons besoin de la valeur <code>_pinnable</code> .  D'accord, nous découvrirons le reflet en retirant les champs privés (très mauvais et pas toujours possible), nous l'écrirons dans un nouveau spen, nous serons heureux.  Il n'y a qu'un <em>petit</em> problème: spen est une <code>ref struct</code> , elle ne peut être ni un argument générique, ni être compressée dans un <code>object</code> .  Les méthodes de réflexion standard nécessiteront, d'une manière ou d'une autre, de pousser la portée dans le type de référence.  Je n'ai pas trouvé de moyen simple (même en considérant la réflexion sur les domaines privés). </p><br><h2 id="metod-2-we-need-to-go-deeper">  Méthode 2: nous devons approfondir </h2><br><p>  Tout a déjà été fait avant moi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[1]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[2]</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[3]</a> ).  Spen est une structure, quel que soit <code>T</code> trois champs occupent la même quantité de mémoire ( <em>sur la même architecture</em> ).  Et si <code>[FieldOffset(0)]</code> ?  Aussitôt dit, aussitôt fait. </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange&lt;T, U&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> U : unmanaged { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;T&gt; Span_1; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;U&gt; Span_2; }</code> </pre> <br><p>  Mais lorsque vous démarrez le programme (ou plutôt, lorsque vous essayez d'utiliser un type), une <code>TypeLoadException</code> rencontre - un générique ne peut pas être <code>LayoutKind.Explicit</code> .  D'accord, cela n'a pas d'importance, allons sur le chemin difficile: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; ByteSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">sbyte</span></span>&gt; SByteSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>&gt; UShortSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt; ShortSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; UIntSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; IntSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">ulong</span></span>&gt; ULongSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>&gt; LongSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; FloatSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; DoubleSpan; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; CharSpan; }</code> </pre> <br><p>  Vous pouvez maintenant faire ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">As2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { IntSpan = span }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exchange.ByteSpan; }</code> </pre> <br><p>  La méthode fonctionne avec un seul problème - le champ <code>_length</code> copié tel <code>_length</code> , donc lors de la <code>_length</code> -&gt; <code>byte</code> la plage d'octets est 4 fois plus petite que le tableau réel. <br>  Pas de problème: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Sequential)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Raw { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Pinnable; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IntPtr Pointer; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Length; } [StructLayout(LayoutKind.Explicit)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Exchange { <span class="hljs-comment"><span class="hljs-comment">/* */</span></span> [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Raw RawView; }</code> </pre> <br><p>  Maintenant, grâce à <code>RawView</code> vous pouvez accéder à chaque champ de portée individuel. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Span&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">byte</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">As2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { IntSpan = span }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exchange2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exchange() { RawView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Raw() { Pinnable = exchange.RawView.Pinnable, Pointer = exchange.RawView.Pointer, Length = exchange.RawView.Length * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>&gt; } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exchange2.ByteSpan; }</code> </pre> <br><p>  Et cela fonctionne <strong>comme il se doit</strong> , si vous ignorez l'utilisation de trucs sales.  Moins - la version générique du convertisseur ne peut pas être créée, vous devez vous contenter de types prédéfinis. </p><br><h2 id="metod-3-bezumnyy">  Méthode 3: fou </h2><br><p>  Comme tout programmeur normal, j'aime automatiser les choses.  La nécessité d'écrire des convertisseurs pour n'importe quelle paire de types <code>unmanaged</code> ne m'a pas plu.  Quelle solution peut-on proposer?  C'est vrai, demandez au <code>CLR</code> d'écrire du code <em>pour vous</em> . </p><br><p>  Comment y parvenir?  Il y a différentes manières, il y a des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">articles</a> .  En bref, le processus ressemble à ceci: <br>  Créer un générateur de construction -&gt; créer un générateur de module -&gt; créer un type -&gt; {Champs, méthodes, etc.} -&gt; à la sortie, nous obtenons une instance de <code>Type</code> . <br>  Pour comprendre exactement à quoi le type devrait ressembler (c'est une <code>ref struct</code> ), nous utilisons n'importe quel outil comme <code>ildasm</code> .  Dans mon cas, c'était <strong>dotPeek</strong> . <br>  La création d'un générateur de type ressemble à ceci: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeBuilder = _mBuilder.DefineType(<span class="hljs-string"><span class="hljs-string">$"Generated_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-string"><span class="hljs-subst">(T).Name}</span></span></span><span class="hljs-string">"</span></span>, TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.ExplicitLayout <span class="hljs-comment"><span class="hljs-comment">// &lt;-    | TypeAttributes.AnsiClass | TypeAttributes.BeforeFieldInit, typeof(ValueType));</span></span></code> </pre> <br><p>  Maintenant les champs.  Comme nous ne pouvons pas copier directement <code>Span&lt;T&gt;</code> dans <code>Span&lt;U&gt;</code> raison de la différence de longueur, nous devons créer deux types de chaque distribution </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">StructLayout(LayoutKind.Explicit)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Generated_Int32 { [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Span&lt;Int32&gt; Span; [FieldOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Raw Raw; }</code> </pre> <br><p>  Ici <code>Raw</code> nous pouvons déclarer avec nos mains et réutiliser.  N'oubliez pas <code>IsByRefLikeAttribute</code> .  Avec les champs, tout est simple: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spanField = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">"Span"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Span&lt;T&gt;), FieldAttributes.Private); spanField.SetOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawField = typeBuilder.DefineField(<span class="hljs-string"><span class="hljs-string">"Raw"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Raw), FieldAttributes.Private); rawField.SetOffset(<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  C'est tout, le type le plus simple est prêt.  Cachez maintenant le module d'assemblage.  Les types personnalisés sont mis en cache, par exemple, dans le dictionnaire ( <code>T -&gt; Generated_{nameof(T)}</code> ).  Nous créons un wrapper qui, selon les deux types <code>TIn</code> et <code>TOut</code> génère deux types d'aides et effectue les opérations nécessaires sur les travées.  Il y en a un mais.  Comme dans le cas de la réflexion, il est presque impossible de l'utiliser sur des travées (ou sur d'autres <code>ref struct</code> ).  <em>Ou je n'ai pas trouvé de solution simple</em> .  Comment être? </p><br><h2 id="delegates-to-the-rescue">  Délégués à la rescousse </h2><br><p>  Les méthodes de réflexion ressemblent généralement à ceci: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MethodInfo mi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> @</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] otherArgs</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  Ils ne portent pas d'informations sur les types, donc si la boxe (= emballage) vous convient, il n'y a aucun problème. <br>  Dans notre cas, <code>@this</code> et <code>otherArgs</code> doivent contenir une <code>ref struct</code> , que je n'ai pas pu contourner. <br>  Cependant, il existe un moyen plus simple.  Imaginons qu'un type possède des méthodes getter et setter (pas des propriétés, mais des méthodes simples créées manuellement). <br>  Par exemple: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Generated_Int32.SetSpan(Span&lt;Int32&gt; span) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Span = span;</code> </pre> <br><p>  En plus de la méthode, nous pouvons déclarer un type délégué (explicitement dans le code): </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SpanSetterDelegate&lt;T&gt;(Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p>  Nous devons le faire car l'action standard devrait avoir une signature <code>Action&lt;Span&lt;T&gt;&gt;</code> , mais les séquences ne peuvent pas être utilisées comme arguments génériques.  <code>SpanSetterDelegate</code> , cependant, est un délégué absolument valide. <br>  Créez les délégués nécessaires.  Pour ce faire, effectuez des manipulations standard: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mi = type.GetMethod(<span class="hljs-string"><span class="hljs-string">"Method_Name"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,    public &amp; instance var spanSetter = (SpanSetterDelegate&lt;T&gt;) mi.CreateDelegate(typeof(SpanSetterDelegate&lt;T&gt;), @this);</span></span></code> </pre> <br><p>  Maintenant <code>spanSetter</code> peut être utilisé comme, par exemple, <code>spanSetter(Span&lt;T&gt;.Empty);</code>  .  Quant à <code>@this</code> <sup>2</sup> , il s'agit d'une instance de notre type dynamique, créée, bien sûr, via <code>Activator.CreateInstance(type)</code> , car la structure a un constructeur par défaut sans arguments. </p><br><p>  Donc, la dernière frontière - nous devons générer dynamiquement des méthodes. </p><br><p>  <sup>2</sup> Vous pouvez remarquer que quelque chose ne va pas ici - <code>Activator.CreateInstance()</code> compresse une instance de <code>ref struct</code> .  Voir la fin de la section suivante. </p><br><h2 id="znakomtes-reflectionemit">  Rencontrez <code>Reflection.Emit</code> </h2><br><p>  Je pense que les méthodes pourraient être générées en utilisant <code>Expression</code> , comme  les corps de nos getters / setters triviaux se composent littéralement de quelques expressions.  J'ai choisi une approche différente et plus directe. </p><br><p>  Si vous regardez le code <strong>IL</strong> d'un getter trivial, vous pouvez voir quelque chose comme ( <code>Debug</code> , <code>X86</code> , <code>netframework4.8</code> ) </p><br><pre> <code class="plaintext hljs">nop ldarg.0 ldfld /* - */ stloc.0 br.s /*  */ ldloc.0 ret</code> </pre> <br><p>  Il y a des tonnes d'endroits pour s'arrêter et déboguer. <br>  Dans la version finale, il ne reste que le plus important: </p><br><pre> <code class="plaintext hljs">ldarg.0 ldfld /* - */ ret</code> </pre> <br><p>  L'argument null de la méthode d'instance est ... <code>this</code> .  Ainsi, ce qui suit est écrit en <strong>IL</strong> : <br>  1) Téléchargez <code>this</code> <br>  2) Charger la valeur du champ <br>  3) Ramenez-le </p><br><p>  Juste hein?  <code>Reflection.Emit</code> a une surcharge spéciale qui prend, en plus du code op, également un paramètre de descripteur de champ.  Tout comme nous l'avons reçu précédemment, par exemple <code>spanField</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getSpan = type.DefineMethod(<span class="hljs-string"><span class="hljs-string">"GetSpan"</span></span>, MethodAttributes.Public | MethodAttributes.HideBySig, CallingConventions.Standard, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Span&lt;T&gt;), Array.Empty&lt;Type&gt;()); gen = getSpan.GetILGenerator(); gen.Emit(OpCodes.Ldarg_0); gen.Emit(OpCodes.Ldfld, spanField); gen.Emit(OpCodes.Ret);</code> </pre> <br><p>  Pour le setter, c'est un peu plus compliqué, vous devez le charger sur la pile, charger le premier argument de la fonction, puis appeler l'instruction d'écriture dans le champ et ne rien retourner: </p><br><pre> <code class="cs hljs">ldarg<span class="hljs-number"><span class="hljs-number">.0</span></span> ldarg<span class="hljs-number"><span class="hljs-number">.1</span></span> stfld <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ret</code> </pre> <br><p>  Après avoir effectué cette procédure pour le champ <code>Raw</code> , en déclarant les délégués nécessaires (ou en utilisant les délégués standard), nous obtenons un type dynamique et quatre méthodes d'accesseur, à partir desquelles les délégués génériques corrects sont générés. </p><br><p>  Nous écrivons une classe wrapper qui, à l'aide de deux paramètres génériques ( <code>TIn</code> , <code>TOut</code> ), reçoit des instances de type <code>Type</code> qui référencent les types dynamiques correspondants (mis en cache), après quoi elle crée un objet de chaque type et génère quatre délégués génériques, à savoir </p><br><ol><li>  <code>void SetSpan(Span&lt;TIn&gt; span)</code> pour écrire le span source dans la structure </li><li>  <code>Raw GetRaw()</code> pour lire le contenu d'un span comme une structure <code>Raw</code> </li><li>  <code>void SetRaw(Raw raw)</code> pour écrire la structure <code>Raw</code> modifiée dans le deuxième objet </li><li>  <code>Span&lt;TOut&gt; GetSpan()</code> pour renvoyer la plage du type souhaité avec des champs correctement définis et recalculés. </li></ol><br><p>  Fait intéressant, les instances de type dynamique doivent être créées une fois.  Lors de la création d'un délégué, une référence à ces objets est transmise en tant que paramètre <code>@this</code> .  <strong>Voici une violation des règles.</strong>  <strong><code>Activator.CreateInstance</code> renvoie un <code>object</code> .</strong>  <strong>Apparemment, cela est dû au fait que le type dynamique lui-même ne s'est pas avéré <code>ref</code></strong> <code>type.IsByRef</code> <strong>(</strong> <code>type.IsByRef</code> <s>Like</s> <code>== false</code> <strong>), mais il a été possible de créer des champs de type <code>ref</code> .</strong>  <strong>Apparemment, une telle restriction est présente dans la langue, mais le <code>CLR</code> digère.</strong>  <strong>C'est peut-être ici que les genoux seront abattus en cas d'utilisation non standard.</strong>  <sup>3</sup> </p><br><p>  Ainsi, nous obtenons une instance d'un type générique qui contient quatre délégués et deux références implicites aux instances de classes dynamiques.  Les délégués et les structures peuvent être réutilisés lors de l'exécution des mêmes castes d'affilée.  Pour améliorer les performances, nous mettons à nouveau en cache (déjà un convertisseur de type) une paire <code>(TIn, TOut) -&gt; Generator&lt;TIn, TOut&gt;</code> . </p><br><h2 id="shtrih-posledniy-privodim-tipy-spantin---spantout">  Le trait est le dernier: nous donnons des types, <code>Span&lt;TIn&gt; -&gt; Span&lt;TOut&gt;</code> </h2><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Span&lt;TOut&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Span&lt;TIn&gt; span</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      if (span.IsEmpty) return Span&lt;TOut&gt;.Empty; // Caller   ,       if (span.Length * Unsafe.SizeOf&lt;TIn&gt;() % Unsafe.SizeOf&lt;TOut&gt;() != 0) throw new InvalidOperationException(); //      // Span&lt;TIn&gt; _input.Span = span; _spanSetter(span); //  Raw // Raw raw = _input.Raw; var raw = _rawGetter(); var newRaw = new Raw() { Pinnable = raw.Pinnable, //    Pinnable Pointer = raw.Pointer, //   Length = raw.Length * Unsafe.SizeOf&lt;TIn&gt;() / Unsafe.SizeOf&lt;TOut&gt;() //   }; //   Raw    // Raw _output.Raw = newRaw; _rawSetter(newRaw); //     // Span&lt;TOut&gt; _output.Span return _spanGetter(); }</span></span></code> </pre> <br><h1 id="vyvod">  Conclusion </h1><br><p>  Parfois - pour des raisons sportives - vous pouvez contourner certaines limitations du langage et implémenter des fonctionnalités non standard.  Bien sûr, à vos risques et périls.  Il convient de noter que la méthode dynamique vous permet d'abandonner complètement les pointeurs et <code>unsafe / fixed</code> contextes <code>unsafe / fixed</code> , ce qui peut être un bonus.  L'inconvénient évident est le besoin de réflexion et de génération de type. </p><br><h1 id="dlya-teh-kto-dochital-do-konca">  Pour ceux qui ont lu jusqu'au bout. </h1><br><div class="spoiler">  <b class="spoiler_title">Résultats de référence naïfs</b> <div class="spoiler_text"><p>  Et à quelle vitesse est-ce tout? <br>  J'ai comparé la vitesse des castes dans un scénario stupide qui ne reflète pas l'utilisation réelle / potentielle de telles castes et étendues, mais donne au moins une idée de la vitesse. </p><br><ol><li> <code>Cast_Explicit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise la conversion via un type explicitement déclaré, comme dans la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode 2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Chaque caste nécessite l'attribution de deux petites structures et des accès aux champs;</font></font></li><li> <code>Cast_IL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implémente la </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode 3</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais à chaque fois crée une instance à nouveau </font></font><code>Generator&lt;TIn, TOut&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui conduit à des recherches constantes dans les dictionnaires, après la première passe génère tous les types;</font></font></li><li> <code>Cast_IL_Cached</code>     <code>Generator&lt;TIn, TOut&gt;</code> , -     , ..       ; </li><li> <code>Buffer</code>   ,       ,     .     . </li></ol><br><p>    —         <code>int[N]</code>   <code>N/2</code>   . </p><br><p>   ,        ,    .              ,             .    ,          ,            .  ,  <em></em> <em></em> <em>   </em>     <code>unmanaged</code>   <em>  </em> . </p><br><pre> <code class="plaintext hljs">BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 Intel Core i7-2700K CPU 3.50GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.3815.0 Clr : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.3815.0 Job=Clr Runtime=Clr InvocationCount=1 UnrollFactor=1</code> </pre><br><div class="scrollable-table"><table><thead><tr><th> Method </th><th> N </th><th> Mean </th><th>  Erreur </th><th> StdDev </th><th> Median </th><th> Ratio </th><th> RatioSD </th></tr></thead><tbody><tr><td> <strong>Cast_Explicit</strong> </td><td>  <strong>100</strong> </td><td> <strong>362.2 ns</strong> </td><td> <strong>18.0967 ns</strong> </td><td> <strong>52.7888 ns</strong> </td><td> <strong>400.0 ns</strong> </td><td> <strong>1.00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td> Cast_IL </td><td>  100 </td><td> 1,237.9 ns </td><td> 28.5954 ns </td><td> 67.4027 ns </td><td> 1,200.0 ns </td><td> 3.47 </td><td> 0.51 </td></tr><tr><td> Cast_IL_Cached </td><td>  100 </td><td> 522.8 ns </td><td> 25.2640 ns </td><td> 71.2576 ns </td><td> 500.0 ns </td><td> 1.46 </td><td> 0.27 </td></tr><tr><td> Buffer </td><td>  100 </td><td> 300.0 ns </td><td> 0.0000 ns </td><td> 0.0000 ns </td><td> 300.0 ns </td><td> 0.78 </td><td> 0.11 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>1000</strong> </td><td> <strong>2,628.6 ns</strong> </td><td> <strong>54.0688 ns</strong> </td><td> <strong>64.3650 ns</strong> </td><td> <strong>2,600.0 ns</strong> </td><td> <strong>1.00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td> Cast_IL </td><td>  1000 </td><td> 3,216.7 ns </td><td> 49.8568 ns </td><td> 38.9249 ns </td><td> 3,200.0 ns </td><td> 1.21 </td><td> 0.03 </td></tr><tr><td> Cast_IL_Cached </td><td>  1000 </td><td> 2,484.6 ns </td><td> 44.9717 ns </td><td> 37.5534 ns </td><td> 2,500.0 ns </td><td> 0.94 </td><td> 0.02 </td></tr><tr><td> Buffer </td><td>  1000 </td><td> 2,055.6 ns </td><td> 43.9695 ns </td><td> 73.4631 ns </td><td> 2,000.0 ns </td><td> 0.78 </td><td> 0.03 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>1000000</strong> </td><td> <strong>2,515,157.1 ns</strong> </td><td> <strong>11,809.8538 ns</strong> </td><td> <strong>10,469.1278 ns</strong> </td><td> <strong>2,516,050.0 ns</strong> </td><td> <strong>1.00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td> Cast_IL </td><td>  1 000 000 </td><td> 2,263,826.7 ns </td><td> 23,724.4930 ns </td><td> 22,191.9054 ns </td><td> 2,262,000.0 ns </td><td> 0.90 </td><td> 0.01 </td></tr><tr><td> Cast_IL_Cached </td><td>  1 000 000 </td><td> 2,265,186.7 ns </td><td> 19,505.5913 ns </td><td> 18,245.5422 ns </td><td> 2,266,300.0 ns </td><td> 0.90 </td><td> 0.01 </td></tr><tr><td> Buffer </td><td>  1 000 000 </td><td> 1,959,547.8 ns </td><td> 39,175.7435 ns </td><td> 49,544.7719 ns </td><td> 1,959,200.0 ns </td><td> 0.78 </td><td> 0.02 </td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td> <strong>Cast_Explicit</strong> </td><td> <strong>100000000</strong> </td><td> <strong>255,751,392.9 ns</strong> </td><td> <strong>2,595,107.7066 ns</strong> </td><td> <strong>2,300,495.3873 ns</strong> </td><td> <strong>255,298,950.0 ns</strong> </td><td> <strong>1.00</strong> </td><td>  <strong>0,00</strong> </td></tr><tr><td> Cast_IL </td><td> 100000000 </td><td> 228,709,457.1 ns </td><td> 527,430.9293 ns </td><td> 467,553.7809 ns </td><td> 228,864,100.0 ns </td><td> 0.89 </td><td> 0.01 </td></tr><tr><td> Cast_IL_Cached </td><td> 100000000 </td><td> 227,966,553.8 ns </td><td> 355,027.3545 ns </td><td> 296,463.9203 ns </td><td> 227,903,600.0 ns </td><td> 0.89 </td><td> 0.01 </td></tr><tr><td> Buffer </td><td> 100000000 </td><td> 213,216,776.9 ns </td><td> 1,198,565.1142 ns </td><td> 1,000,856.1536 ns </td><td> 213,517,800.0 ns </td><td> 0.83 </td><td> 0.01 </td></tr></tbody></table></div></div></div><br><div class="spoiler"> <b class="spoiler_title">Acknowledgements</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>JetBrains</strong></a> (      :-))   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>R#</strong></a>    <strong>VS</strong>  standalone- <strong>dotPeek</strong> ,     .  <code>BenchmarkDotNet</code>  BenchmarkDotNet, youtube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>NDC Conferences</strong></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>DotNext</strong></a>    ,  ,         . </p></div></div><br><h1 id="ps">  PS </h1><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><p> <sup>3</sup>         ,      <code>ref</code> ,      ,   .  <s></s>   (   )   .    <code>ref</code> structs,        </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Raw Generated_Int32.GetRaw(Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; span) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Generated_Int32() { Span = span }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inst.Raw; }</code> </pre> <br><p>     ,     <code>Reflection.Emit</code> .      ,   <em></em>  <code>ILGenerator.DeclareLocal</code> .     </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Span&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Generated_Int32.GetSpan(Raw raw);</code> </pre> <br><p>    </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> Raw GetRaw&lt;T&gt;(Span&lt;T&gt; span) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged; <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> Span&lt;T&gt; GetSpan&lt;T&gt;(Raw raw) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : unmanaged;</code> </pre> <br><p> , <em> </em> ,       <code>ref</code> — .  Parce que     ,      </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getter = type.GetMethod(<span class="hljs-string"><span class="hljs-string">@"GetRaw"</span></span>, BindingFlags.Static | BindingFlags.Public).CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(GetRaw&lt;T&gt;), <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> GetRaw&lt;T&gt;;</code> </pre> <br><p>   —  </p><br><pre> <code class="cs hljs">Raw raw = getter(Span&lt;TIn&gt;.Empty); Raw newRaw = convert(raw); Span&lt;TOut&gt; = setter(newRaw);</code> </pre> </div></div><br><p> <em>UPD01:   </em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr465077/">https://habr.com/ru/post/fr465077/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr465063/index.html">Les 10 erreurs les plus courantes lors de l'utilisation de la plate-forme Spring. 2e partie</a></li>
<li><a href="../fr465069/index.html">Nouveau dans Hadoop: découvrez les différents formats de fichiers dans Hadoop</a></li>
<li><a href="../fr465071/index.html">TechTrain 2019 IT festival: comment JUG.ru, JUGNsk et JUG.MSK y ont participé</a></li>
<li><a href="../fr465073/index.html">Ne sautez pas! Transitions interruptibles dans iOS</a></li>
<li><a href="../fr465075/index.html">Dans la cabine du conducteur du train</a></li>
<li><a href="../fr465081/index.html">CLRium # 6: Concurrence et parallélisme. Apprendre la magie de la parallélisation des tâches</a></li>
<li><a href="../fr465083/index.html">Surveillance de porte vigilante</a></li>
<li><a href="../fr465085/index.html">Liste de contrôle anti-hameçonnage</a></li>
<li><a href="../fr465087/index.html">Comment la NASA a embauché Snoopy et récupéré des vêtements Barbie</a></li>
<li><a href="../fr465089/index.html">Comment le hasard peut aider les mathématiciens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>