<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘» ğŸš´ğŸ» ğŸ¤¦ğŸ¾ Ketika kami menulis kode jaringan penembak PvP seluler: sinkronisasi pemain pada klien ğŸˆ¶ ğŸ§•ğŸ½ ğŸ•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam salah satu artikel sebelumnya , kami meninjau teknologi yang digunakan pada proyek baru kami - penembak serba cepat untuk perangkat seluler. Sek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ketika kami menulis kode jaringan penembak PvP seluler: sinkronisasi pemain pada klien</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/415959/">  Dalam salah satu artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> , kami meninjau teknologi yang digunakan pada proyek baru kami - penembak serba cepat untuk perangkat seluler.  Sekarang saya ingin berbagi bagaimana bagian klien dari kode jaringan dari game masa depan diatur, kesulitan apa yang kami temui dan bagaimana menyelesaikannya. <br><br><img src="https://habrastorage.org/webt/va/gz/nl/vagznl64ylol9qhxysj5ti1akpy.jpeg"><br><a name="habracut"></a><br><br>  Secara umum, pendekatan untuk membuat game multi-pemain cepat selama 20 tahun terakhir tidak banyak berubah.  Beberapa metode dapat dibedakan dalam arsitektur kode jaringan: <br><br><ol><li>  Kesalahan perhitungan keadaan dunia pada server, dan menampilkan hasil pada klien tanpa prediksi untuk pemain lokal dan dengan kemungkinan kehilangan input pemain (input).  Omong-omong, pendekatan ini digunakan pada proyek kami yang lain dalam pengembangan - Anda dapat membacanya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lockstep</a> </li><li>  Sinkronisasi keadaan dunia tanpa logika deterministik dengan prediksi untuk pemain lokal. </li><li>  Sinkronisasi input dengan logika dan prediksi sepenuhnya deterministik untuk pemain lokal. </li></ol><br>  Kekhasan terletak pada kenyataan bahwa dalam penembak yang paling penting adalah responsif kontrol - pemain menekan tombol (atau menggerakkan joystick) dan ingin segera melihat hasil aksinya.  Pertama-tama, karena keadaan dunia dalam permainan seperti itu berubah sangat cepat dan perlu untuk segera menanggapi situasi. <br><br>  Sebagai akibatnya, pendekatan tanpa mekanisme prediksi tindakan pemain lokal (prediksi) tidak cocok untuk proyek, dan kami memilih metode dengan menyinkronkan keadaan dunia, tanpa logika deterministik. <br><br>  <b>Keuntungan dari pendekatan:</b> lebih sedikit kompleksitas dalam implementasi dibandingkan dengan metode sinkronisasi ketika bertukar input. <br>  <b>Minus:</b> peningkatan lalu lintas saat mengirim seluruh negara di dunia ke klien.  Kami harus menerapkan beberapa teknik pengoptimalan lalu lintas yang berbeda untuk membuat game bekerja secara stabil di jaringan seluler. <br><br>  Di jantung arsitektur gameplay kami memiliki ECS, yang telah kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bicarakan</a> .  Arsitektur ini memungkinkan Anda menyimpan data tentang dunia game dengan mudah, membuat serial, menyalin, dan mentransfernya melalui jaringan.  Dan juga untuk mengeksekusi kode yang sama baik pada klien dan di server. <br><br>  Simulasi dunia game berlangsung pada frekuensi tetap 30 ticks per detik.  Ini memungkinkan Anda untuk mengurangi kelambatan pada input pemain dan hampir tidak menggunakan interpolasi untuk secara visual menampilkan kondisi dunia.  Tetapi ada satu kelemahan signifikan yang harus dipertimbangkan ketika mengembangkan sistem seperti itu: agar sistem prediksi pemain lokal berfungsi dengan benar, klien harus mensimulasikan dunia dengan frekuensi yang sama dengan server.  Dan kami menghabiskan banyak waktu untuk mengoptimalkan simulasi cukup untuk perangkat target. <br><br><h2>  Mekanisme prediksi aksi pemain lokal (prediksi) </h2><br>  Mekanisme prediksi klien diimplementasikan berdasarkan ECS karena eksekusi sistem yang sama pada klien dan server.  Namun, tidak semua sistem dijalankan pada klien, tetapi hanya yang bertanggung jawab untuk pemain lokal dan tidak memerlukan data yang relevan tentang pemain lain. <br><br>  Contoh daftar sistem yang berjalan di klien dan server: <br><br><img src="https://habrastorage.org/webt/sm/jl/wc/smjlwcvyu5mv2omhgnggu9zbbnc.png"><br><br>  Saat ini, kami memiliki sekitar 30 sistem yang berjalan di klien yang memberikan prediksi pemain dan sekitar 80 sistem yang berjalan di server.  Tetapi kami tidak memprediksi hal-hal seperti menangani kerusakan, menggunakan kemampuan, atau menyembuhkan sekutu.  Ada dua masalah dalam mekanika ini: <br><br><ol><li>  Klien tidak tahu apa-apa tentang memasukkan pemain lain dan memprediksi hal-hal seperti kerusakan atau penyembuhan hampir selalu berbeda dari data di server. </li><li>  Membuat entitas baru secara lokal (tembakan, cangkang, kemampuan unik) yang dihasilkan oleh satu pemain membawa masalah pencocokan dengan entitas yang dibuat di server. </li></ol><br>  Untuk mekanik seperti itu, lag bersembunyi dari pemain dengan cara lain. <br><br>  <i>Contoh: kami segera menggambar efek dari tembakan, dan kami memperbarui kehidupan musuh hanya setelah kami menerima konfirmasi mengenai serangan dari server.</i> <br><br><h2>  Skema umum kode jaringan dalam proyek </h2><br><br><img src="https://habrastorage.org/webt/so/vq/gw/sovqgwxy7gc2rxtsqedxdlkpdew.png"><br>  Klien dan server menyinkronkan waktu dengan nomor centang.  Karena kenyataan bahwa pengiriman data melalui jaringan membutuhkan waktu, klien selalu lebih unggul dari server sebesar setengah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTT</a> + ukuran buffer input pada server.  Diagram di atas menunjukkan bahwa klien mengirim input untuk centang 20 (a).  Pada saat yang sama, centang 15 (b) diproses di server.  Pada saat input klien mencapai server, centang 20 akan diproses di server. <br><br>  Seluruh proses terdiri dari langkah-langkah berikut: klien mengirim input pemain ke server (a) â†’ input ini diproses di server setelah ukuran buffer input HRTT + (b) â†’ server mengirim negara dunia yang dihasilkan kepada klien â†’ klien menerapkan negara dunia yang dikonfirmasi dengan waktu server RTT + ukuran buffer input + ukuran buffer interpolasi status permainan (d). <br><br>  Setelah klien menerima keadaan dunia baru yang dikonfirmasi dari server (d), ia perlu menyelesaikan proses rekonsiliasi.  Faktanya adalah bahwa klien melakukan prediksi dunia hanya berdasarkan pada input pemain lokal.  Input dari pemain lain tidak dikenalnya.  Dan ketika menghitung keadaan dunia di server, pemain mungkin berada dalam keadaan yang berbeda, berbeda dari apa yang diprediksi klien.  Ini bisa terjadi ketika seorang pemain tertegun atau terbunuh. <br><br>  Proses persetujuan terdiri dari dua bagian: <br><br><ol><li>  Perbandingan kondisi prediksi dunia untuk tick N yang diterima dari server.  Hanya data yang terkait dengan pemain lokal yang terlibat dalam perbandingan.  Data dunia lainnya selalu diambil dari status server dan tidak berpartisipasi dalam koordinasi. </li><li>  Selama perbandingan, dua kasus dapat terjadi: </li></ol><br>  - jika keadaan dunia yang diprediksi bertepatan dengan yang dipastikan dari server, maka klien, menggunakan data yang diprediksi untuk pemain lokal dan data baru untuk seluruh dunia, terus mensimulasikan dunia dalam mode normal; <br>  - jika kondisi prediksi tidak cocok, maka klien menggunakan seluruh kondisi server dunia dan sejarah input dari klien dan menceritakan kondisi prediksi baru dunia pemain. <br><br><div class="spoiler">  <b class="spoiler_title">Dalam kode, tampilannya seperti ini:</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">GameState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reconcile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentTick, ServerGameStateData serverStateData, GameState currentState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerID</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverState = serverStateData.GameState; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverTick = serverState.Time; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> predictedState = _localStateHistory.Get(serverTick); <span class="hljs-comment"><span class="hljs-comment">//if predicted state matches server last state use server predicted state with predicted player if (_gameStateComparer.IsSame(predictedState, serverState, playerID)) { _tempState.Copy(serverState); _gameStateCopier.CopyPlayerEntities(currentState, _tempState, playerID); return _localStateHistory.Put(_tempState); // replace predicted state with correct server state } //if predicted state doesn't match server state, reapply local inputs to server state var last = _localStateHistory.Put(serverState); // replace wrong predicted state with correct server state for (var i = serverTick; i &lt; currentTick; i++) { last = _prediction.Predict(last); // resimulate all wrong states } return last; }</span></span></code> </pre> <br></div></div><br>  Perbandingan dua negara dunia hanya terjadi untuk data yang terkait dengan pemain lokal dan berpartisipasi dalam sistem prediksi.  Data diambil berdasarkan ID pemain. <br><br><div class="spoiler">  <b class="spoiler_title">Metode perbandingan:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState s1, GameState s2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> || s1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity1 = s1.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity2 = s2.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Time != s2.Time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Weapon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s1.WorldState.Weapon) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value.Owner.Id != avatarId) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Weapon = s2.WorldState.Weapon[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value != s2Weapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Ammo = s1.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Ammo = s2.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Ammo != s2Ammo) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Reload = s1.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Reload = s2.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Reload != s2Reload) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.Aiming != entity2.Aiming) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.ChangeWeapon != entity2.ChangeWeapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Operator pembanding untuk komponen tertentu dihasilkan bersama dengan seluruh struktur EC, yang ditulis secara khusus oleh pembuat kode.  Sebagai contoh, saya akan memberikan kode yang dihasilkan dari operator perbandingan komponen Transform: <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Perlu dicatat bahwa nilai Float kami dibandingkan dengan kesalahan yang agak tinggi.  Ini dilakukan untuk mengurangi jumlah desync antara klien dan server.  Untuk pemain, kesalahan seperti itu tidak akan terlihat, tetapi ini secara signifikan menghemat sumber daya komputasi sistem. <br><br>  Kompleksitas mekanisme koordinasi adalah bahwa dalam hal terjadi kesalahan sinkronisasi klien dan kondisi server (misprediksi), perlu untuk berulang kali mensimulasikan semua kondisi klien yang diprediksi tentang yang tidak ada konfirmasi dari server, hingga centang saat ini dalam satu frame.  Bergantung pada ping pemain, ini bisa dari 5 hingga 20 kutu simulasi.  Kami harus mengoptimalkan kode simulasi secara signifikan agar sesuai dengan kerangka waktu: 30 fps. <br><br>  Untuk menyelesaikan proses persetujuan, dua jenis data harus disimpan pada klien: <br><br><ol><li>  Sejarah negara pemain yang diprediksi. </li><li>  Dan sejarah input. </li></ol><br>  Untuk tujuan ini, kami menggunakan buffer lingkaran.  Ukuran buffer adalah 32 ticks.  Bahwa pada frekuensi 30 HZ memberi sekitar 1 detik waktu nyata.  Klien dapat terus bekerja dengan aman pada mekanisme prediksi, tanpa menerima data baru dari server, hingga mengisi buffer ini.  Jika perbedaan antara waktu klien dan server mulai lebih dari satu detik, klien dipaksa untuk memutuskan sambungan dengan upaya untuk menghubungkan kembali.  Kami memiliki ukuran buffer seperti itu karena biaya proses koordinasi jika terjadi ketidaksesuaian antara negara-negara di dunia.  Tetapi jika perbedaan antara klien dan server lebih dari satu detik, lebih murah untuk melakukan koneksi ulang lengkap ke server. <br><br><h2>  Pengurangan waktu jeda </h2><br>  Diagram di atas menunjukkan bahwa dalam permainan ada dua buffer dalam skema transfer data: <br><br><ul><li>  masukan buffer di server; </li><li>  penyangga negara-negara dunia pada klien. </li></ul><br>  Tujuan dari buffer ini adalah sama - untuk mengkompensasi lompatan jaringan (jitter).  Faktanya adalah bahwa pengiriman paket melalui jaringan tidak merata.  Dan karena mesin jaringan beroperasi pada frekuensi tetap 30 HZ, data harus dipasok ke mesin pada frekuensi yang sama.  Kami tidak memiliki kesempatan untuk "menunggu" beberapa ms sampai paket berikutnya mencapai penerima.  Kami menggunakan buffer untuk memasukkan data dan negara-negara dunia agar memiliki batas waktu untuk kompensasi jitter.  Kami juga menggunakan buffer gamestate untuk interpolasi jika salah satu paket hilang. <br><br>  Di awal permainan, klien memulai sinkronisasi dengan server hanya setelah menerima beberapa status dunia dari server dan buffer gamestate penuh.  Biasanya, ukuran buffer ini adalah 3 ticks (100 ms). <br><br>  Pada saat yang sama, ketika klien menyinkronkan dengan server, itu "berjalan" di depan waktu server dengan nilai buffer input pada server.  Yaitu  klien itu sendiri mengontrol seberapa jauh dari server itu.  Ukuran awal buffer input juga sama dengan 3 ticks (100 ms). <br><br>  Awalnya, kami menerapkan ukuran buffer ini sebagai konstanta.  Yaitu  terlepas dari apakah jitter benar-benar ada di jaringan atau tidak, ada penundaan tetap sebesar 200 ms (ukuran buffer input + ukuran buffer status permainan) untuk memperbarui data.  Jika kita menambahkan ini perkiraan ping rata-rata pada perangkat seluler sekitar 200 ms, maka penundaan nyata antara menggunakan input pada klien dan mengonfirmasi aplikasi dari server adalah 400 ms! <br><br>  Ini tidak cocok untuk kita. <br><br>  Faktanya adalah bahwa beberapa sistem hanya berjalan di server - seperti, misalnya, menghitung HP pemain.  Dengan penundaan ini, pemain menembak dan hanya setelah 400 ms melihat bagaimana ia membunuh lawan.  Jika ini terjadi dalam gerakan, maka biasanya pemain berhasil berlari di belakang dinding atau ke penutup dan sudah sekarat di sana.  Playtests dalam tim menunjukkan bahwa penundaan seperti itu benar-benar menghancurkan seluruh gameplay. <br><br>  Solusi untuk masalah ini adalah penerapan ukuran dinamis buffer input dan gamestate: <br><ul><li>  untuk buffer gamestate, klien selalu tahu konten buffer saat ini.  Pada saat menghitung centang selanjutnya, klien memeriksa berapa banyak status yang sudah ada dalam buffer; </li><li>  untuk buffer input - server, selain status permainan, mulai mengirim nilai kepada klien untuk mengisi input buffer saat ini untuk klien tertentu.  Klien pada gilirannya menganalisis kedua nilai ini. </li></ul><br>  Algoritma pengubah ukuran bufferest gamestate kira-kira sebagai berikut: <br><br><ol><li>  Klien mempertimbangkan nilai rata-rata ukuran buffer selama periode waktu dan varians. </li><li>  Jika varians berada dalam batas normal (mis., Untuk periode waktu tertentu tidak ada lompatan besar dalam mengisi dan membaca dari buffer), klien memeriksa nilai ukuran buffer rata-rata untuk periode waktu ini. </li><li>  Jika pengisian buffer rata-rata lebih besar dari kondisi batas atas (yaitu, buffer akan diisi lebih dari yang diperlukan), klien "mengurangi" ukuran buffer dengan melakukan centang simulasi tambahan. </li><li>  Jika rata-rata pengisian buffer kurang dari kondisi batas bawah (yaitu, buffer tidak punya waktu untuk mengisi sebelum klien mulai membaca dari itu) - dalam hal ini, klien "meningkatkan" ukuran buffer dengan melewatkan satu centang simulasi. </li><li>  Dalam kasus ketika varians di atas normal, kami tidak dapat mengandalkan data ini, karena  lonjakan jaringan untuk jangka waktu tertentu terlalu besar.  Kemudian klien membuang semua data saat ini dan mulai mengumpulkan statistik lagi. </li></ol><br><h2>  Kompensasi keterlambatan server </h2><br>  Karena kenyataan bahwa klien menerima pembaruan dunia dari server dengan penundaan (lag), pemain melihat dunia sedikit berbeda dari yang ada di server.  Pemain melihat dirinya di masa kini, dan seluruh dunia - di masa lalu.  Di server, seluruh dunia ada dalam satu waktu. <br><br><img src="https://habrastorage.org/webt/jo/ca/5d/joca5d_dhigvw1i9gjlpcd-tgqa.png"><br>  Karena itu, situasinya adalah bahwa pemain menembak secara lokal pada target yang terletak di server di tempat lain. <br><br>  Untuk mengkompensasi kelambatan, kami menggunakan waktu mundur di server.  Algoritma operasi kira-kira sebagai berikut: <br><br><ol><li>  Klien dengan setiap input juga mengirim ke server waktu centang di mana ia melihat seluruh dunia. </li><li>  Server memvalidasi waktu ini: adalah perbedaan antara waktu saat ini dan waktu yang terlihat dari dunia klien dalam interval kepercayaan. </li><li>  Jika waktu berlaku, server meninggalkan pemain dalam waktu saat ini, dan seluruh dunia kembali ke keadaan bahwa pemain melihat dan menghitung hasil tembakan. </li><li>  Jika seorang pemain memukul, maka kerusakan dilakukan pada waktu server saat ini. </li></ol><br>  Waktu rewinding pada server berfungsi sebagai berikut: sejarah dunia (dalam ECS) dan sejarah fisika (didukung oleh mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fisika Volatile</a> ) disimpan di utara.  Pada saat tembakan dihitung, data pemain diambil dari keadaan dunia saat ini, dan sisa pemain dari sejarah. <br><br><div class="spoiler">  <b class="spoiler_title">Kode untuk sistem validasi gambar terlihat seperti ini:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shotPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Shot) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shot = shotPair.Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooter = gs.WorldState[shotPair.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooterTransform = shooter.Transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weaponStats = gs.WorldState.WeaponStats[shot.WeaponId]; <span class="hljs-comment"><span class="hljs-comment">// DeltaTime shouldn't exceed physics history size var shootDeltaTime = (int) (gs.Time - shot.ShotPlayerWorldTime); if (shootDeltaTime &gt; PhysicsWorld.HistoryLength) { continue; } // Get the world at the time of shooting. var oldState = _immutableHistory.Get(shot.ShotPlayerWorldTime); var potentialTarget = oldState.WorldState[shot.Target.Id]; var hitTargetId = _singleShotValidator.ValidateTargetAvailabilityInLine(oldState, potentialTarget, shooter, shootDeltaTime, weaponStats.ShotDistance, shooter.Transform.Angle.GetDirection()); if (hitTargetId != 0) { gs.WorldState.CreateEntity().AddDamage(gs.WorldState[hitTargetId], shooter, weaponStats.ShotDamage); } } }</span></span></code> </pre> <br></div></div><br>  Salah satu kelemahan signifikan dalam pendekatan ini adalah bahwa kami mempercayai klien dalam data tentang waktu centang yang dia lihat.  Berpotensi, pemain dapat memperoleh keuntungan dengan meningkatkan ping secara artifisial.  Karena  semakin banyak ping yang dimiliki pemain, semakin jauh dia menembak di masa lalu. <br><br><h2>  Beberapa masalah kami temui </h2><br>  Selama implementasi mesin jaringan ini, kami menemui banyak masalah, beberapa di antaranya layak untuk artikel terpisah, tetapi di sini saya hanya akan menyentuh beberapa di antaranya. <br><br><h4>  Simulasi seluruh dunia dalam sistem prediksi dan penyalinan </h4><br>  Awalnya, semua sistem di ECS kami hanya memiliki satu metode: void Execute (GameState gs).  Dalam metode ini, komponen yang terkait dengan semua pemain biasanya diproses. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh sistem gerak dalam implementasi awal:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[movementPair.Key]; transform.Position += movementPair.Value.Velocity * GameState.TickDuration; } } }</code> </pre> <br></div></div><br>  Namun dalam sistem prediksi pemain lokal, kami hanya perlu memproses komponen yang terkait dengan pemain tertentu.  Awalnya, kami menerapkan ini menggunakan salinan. <br><br>  Proses prediksi adalah sebagai berikut: <br><br><ol><li>  Salinan keadaan permainan telah dibuat. </li><li>  Salinan diberikan ke input ECS. </li><li>  Ada simulasi seluruh dunia di ECS. </li><li>  Semua data yang terkait dengan pemain lokal disalin dari gamestate yang baru diterima. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Metode prediksi terlihat seperti ini:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _tempGameState.Copy(state); _ecsExecutor.Execute(_tempGameState, input); _playerEntitiesCopier.Copy(_tempGameState, newState); }</code> </pre> <br></div></div><br>  Ada dua masalah dalam implementasi ini: <br><br><ol><li>  Karena  kami menggunakan kelas, bukan struktur - menyalin adalah operasi yang cukup mahal bagi kami (sekitar 0,1-0,15 ms pada iPhone 5S). </li><li>  Simulasi seluruh dunia juga membutuhkan banyak waktu (sekitar 1,5-2 ms pada iPhone 5S). </li></ol><br>  Jika kita memperhitungkan bahwa selama proses koordinasi perlu untuk menghitung ulang dari 5 hingga 15 negara di dunia dalam satu kerangka, maka dengan implementasi seperti itu semuanya berjalan sangat lambat. <br><br>  Solusinya cukup sederhana: belajar mensimulasikan dunia dalam bagian-bagian, yaitu hanya mensimulasikan pemain tertentu.  Kami menulis ulang semua sistem sehingga Anda dapat mentransfer ID pemain dan hanya mensimulasikannya. <br><br><div class="spoiler">  <b class="spoiler_title">Contoh sistem pergerakan setelah perubahan:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { Move(gs.WorldState.Transform[movementPair.Key], movementPair.Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[playerId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Move(gs.WorldState.Transform[playerId], movement); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform, Movement movement</span></span></span><span class="hljs-function">)</span></span> { transform.Position += movement.Velocity * GameState.TickDuration; } }</code> </pre> <br></div></div><br>  Setelah perubahan, kami dapat menyingkirkan salinan yang tidak perlu dalam sistem prediksi dan mengurangi beban pada sistem yang cocok. <br><br><div class="spoiler">  <b class="spoiler_title">Kode:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _ecsExecutor.Execute(newState, input, playerId); }</code> </pre> <br></div></div><br><h4>  Membuat dan menghapus entitas dalam sistem prediksi </h4><br>  Dalam sistem kami, pencocokan entitas pada server dan klien terjadi oleh pengenal integer (id).  Untuk semua entitas, kami menggunakan penomoran ujung ke ujung, setiap entitas baru memiliki nilai id = oldID + 1. <br><br>  Pendekatan ini sangat mudah diterapkan, tetapi memiliki satu kelemahan signifikan: urutan pembuatan entitas baru pada klien dan server mungkin berbeda, dan sebagai hasilnya, pengidentifikasi entitas akan berbeda. <br><br>  Masalah ini memanifestasikan dirinya ketika kami menerapkan sistem untuk memprediksi tembakan pemain.  Setiap tembakan dengan kami adalah entitas yang terpisah dengan komponen tembakan.  Untuk setiap klien, id dari entitas shot dalam sistem prediksi berurutan.  Tetapi jika pada saat yang sama tembakan pemain lain, maka di server id semua tembakan berbeda dari klien. <br><br>  Tembakan di server dibuat dalam urutan yang berbeda: <br><br><img src="https://habrastorage.org/webt/gl/dg/fy/gldgfykw7m30fuwspkra-xytgqe.png"><br><br>  Untuk bidikan, kami menghindari batasan ini, berdasarkan pada fitur gameplay dari game.  Bidikan adalah entitas yang hidup cepat yang dihancurkan dalam sistem, sepersekian detik setelah penciptaan.  Pada klien, kami menyoroti rentang ID yang terpisah yang tidak berpotongan dengan ID server dan tidak lagi mengambil gambar akun dalam sistem koordinasi.  Yaitu  Tembakan pemain lokal selalu ditarik dalam permainan hanya sesuai dengan sistem prediksi dan tidak memperhitungkan data akun dari server. <br><br>  Dengan pendekatan ini, pemain tidak melihat artefak di layar (menghapus, menciptakan kembali, mengembalikan gambar), dan perbedaan dengan server bersifat minor dan tidak mempengaruhi gameplay secara keseluruhan. <br><br>  Metode ini memungkinkan untuk memecahkan masalah dengan tembakan, tetapi tidak seluruh masalah menciptakan entitas pada klien secara keseluruhan.  Kami masih bekerja pada metode yang mungkin untuk menyelesaikan perbandingan objek yang dibuat pada klien dan server. <br><br>  Perlu juga dicatat bahwa masalah ini hanya menyangkut penciptaan entitas baru (dengan ID baru).  Menambah dan menghapus komponen pada entitas yang sudah dibuat dilakukan tanpa masalah: komponen tidak memiliki pengidentifikasi dan masing-masing entitas hanya dapat memiliki satu komponen dari tipe tertentu.  Oleh karena itu, kami biasanya membuat entitas di server, dan dalam sistem prediksi kami hanya menambah / menghapus komponen. <br><br>  Sebagai kesimpulan, saya ingin mengatakan bahwa tugas menerapkan multi-pemain bukanlah yang termudah dan tercepat, tetapi ada banyak informasi tentang cara melakukan ini. <br><br><h2>  Apa yang harus dibaca </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Multiplayer dalam game cepat</a> - terjemahan artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Multiplayer Cepat (Bagian I): Pendahuluan</a> (menurut saya, ini adalah artikel terbaik tentang HabrÃ© tentang interaksi jaringan dalam game). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Arsitektur Gameplay Overwatch GDC Vault dan Netcode</a> - kuliah dengan GDC 17, tentang ECS â€‹â€‹dan kode jaringan dalam Overwatch (sayangnya, akses dibayar). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GDC Vault: 8 Frame dalam 16ms: Rollback Networking di Mortal Kombat dan Injustice 2</a> - bagaimana hal ini dilakukan dalam permainan pertempuran. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Source Multiplayer Networking</a> - Bagaimana cara kerja multi-pemain di Counter Strike. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gaffer pada Game</a> umumnya tentang kode jaringan dalam game. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UDP di Mesin Game</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GDC Vault: I Shot you first networking</a> - bagaimana multipemain bekerja di Halo: Reach. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415959/">https://habr.com/ru/post/id415959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415947/index.html">Sistem kompensasi kesalahan pemasangan serat optik selama pemrosesan dengan radiasi laser selama rotasi</a></li>
<li><a href="../id415949/index.html">Penambangan tinggi: opsi terbaru untuk melindungi blockchain PoW dari â€œserangan 51%â€</a></li>
<li><a href="../id415951/index.html">Mitap Sberbank dan IBM di HyperLedger Fabric</a></li>
<li><a href="../id415953/index.html">Bagaimana perusahaan berdarah memenangkan sumber terbuka: pertempuran untuk BPMS</a></li>
<li><a href="../id415957/index.html">Kami membutuhkan lebih banyak ransel: Bobby XL dari XD Design</a></li>
<li><a href="../id415961/index.html">Penyimpanan terdistribusi Rusia. Bagaimana cara kerjanya</a></li>
<li><a href="../id415963/index.html">Naif Bayes, atau bagaimana matematika memungkinkan Anda untuk memfilter spam</a></li>
<li><a href="../id415965/index.html">Apa yang harus dibaca pada bulan Juli: 19 buku baru untuk para profesional digital</a></li>
<li><a href="../id415967/index.html">SolidFire - Penyimpanan untuk penyimpanan ** cking hate</a></li>
<li><a href="../id415969/index.html">HyperX Pulsefire Surge RGB - pembunuh alami</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>