<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ© â™¥ï¸ â— Parameterisasi tidak pasti sebagai metode universal untuk membangun arsitektur aplikasi di C ++ dan Java untuk minimum. harga âœï¸ ğŸ˜ ğŸ¤Ÿ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ adalah bahasa yang membingungkan, dan kelemahan utamanya adalah sulitnya membuat blok kode yang terisolasi. Dalam proyek tipikal, semuanya tergan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parameterisasi tidak pasti sebagai metode universal untuk membangun arsitektur aplikasi di C ++ dan Java untuk minimum. harga</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475268/">  C ++ adalah bahasa yang membingungkan, dan kelemahan utamanya adalah sulitnya membuat blok kode yang terisolasi.  Dalam proyek tipikal, semuanya tergantung pada segalanya.  Artikel ini menunjukkan cara menulis kode yang sangat terisolasi yang minimal tergantung pada perpustakaan tertentu (termasuk yang standar), implementasi, mengurangi ketergantungan setiap potongan kode ke satu set antarmuka.  Selain itu, solusi arsitektur untuk parameterisasi kode akan diusulkan, yang mungkin menarik tidak hanya programmer C ++, tetapi juga programmer Java.  Dan yang penting, solusi yang diusulkan sangat ekonomis dalam hal waktu pengembangan. <br><a name="habracut"></a><br>  <i><b>Penafian</b></i> : Dalam artikel ini saya telah mengumpulkan ide-ide saya tentang arsitektur ideal.  Beberapa ide bukan milik saya (tetapi saya tidak ingat yang mana), beberapa ide adalah hal biasa dan diketahui oleh semua orang - ini tidak penting, karena saya tidak menawarkan ide-ide saya tentang arsitektur yang baik, tetapi kode khusus yang memungkinkan arsitektur ini didekati dengan harga minimum. <br><br>  <i><b>Penafian N2</b></i> : Saya akan senang dengan umpan balik konstruktif yang diungkapkan dalam kata-kata.  Jika Anda mengerti lebih buruk dari saya, dan memarahi saya, itu berarti bahwa di suatu tempat saya belum cukup jelas menjelaskan, dan masuk akal untuk mengerjakan ulang teks.  Jika Anda mengerti lebih baik dari saya, itu berarti saya akan mendapatkan pengalaman berharga.  Terima kasih sebelumnya. <br><br>  <i><b>Penafian N3</b></i> : Saya menulis aplikasi besar dari awal, tetapi tidak menulis aplikasi server dan klien perusahaan.  Semuanya berbeda di sana dan, mungkin, pengalaman saya akan terasa aneh bagi spesialis di bidang ini.  Dan artikelnya bukan tentang itu, masalah skalabilitas yang sama tidak dipertimbangkan di sini sama sekali. <br>  <i><b>Penafian N4</b></i> ( <b>Pembaruan.</b> Berdasarkan komentar): Beberapa komentator telah menyarankan agar saya menemukan kembali Fowler dan menawarkan pola desain yang sudah lama dikenal.  Ini jelas bukan masalahnya.  Saya mengusulkan alat parameterisasi yang sangat kecil yang memungkinkan Anda untuk menerapkan pola-pola ini dengan minimum coretan.  Termasuk Fowler's Dependency Injection dan Service Locator, tetapi tidak hanya - menggunakan kelas TypedSet Anda juga dapat menerapkan serangkaian strategi secara ekonomis.  Dalam hal ini, Fowler diakses melalui jalur, yang mahal - alat nol biaya saya, nol biaya (jika benar-benar ketat, maka log (N), bukan 2M * log (N), di mana M adalah panjang dari string parameter untuk Locator Layanan. setelah kemunculan constexpr typeid di c ++ 20, harga seharusnya menjadi nol sama sekali).  Karena itu, saya meminta Anda untuk tidak memperluas arti artikel ke pola desain.  Di sini Anda hanya akan menemukan <b><i>metode untuk</i></b> penerapan pola-pola ini secara murah. <br><br>  Contohnya akan di C ++, tetapi semua hal di atas cukup dapat diterapkan di Jawa.  Mungkin, seiring waktu, saya akan memberikan kode kerja untuk Java jika permintaan ini ada di komentar dari Anda. <br><br><h2>  Bagian 1. Arsitektur bulat dalam ruang hampa </h2><br>  Sebelum menyelesaikan semua kesulitan dengan cerdas, Anda harus membuatnya dengan benar.  Dengan mahir menciptakan kesulitan untuk diri Anda di tempat yang tepat, Anda dapat sangat memfasilitasi solusi mereka.  Untuk ini, kami merumuskan tujuan untuk solusi yang kami akan datang dengan metode - prinsip minimum arsitektur yang baik. <br><br>  Faktanya, keajaiban arsitektur yang baik hanyalah dua prinsip, dan apa yang tertulis di bawah ini hanyalah sebuah decoding.  Prinsip pertama adalah uji kode.  Testabilitas seperti benang Ariadne yang mengarahkan Anda ke arsitektur yang baik.  Jika Anda tidak tahu cara menulis tes untuk fungsionalitas, maka Anda telah merusak arsitekturnya.  Jika Anda tidak tahu cara membuat arsitektur yang baik, pikirkan tes apa yang akan dilakukan untuk fungsionalitas yang Anda rencanakan - dan Anda akan secara otomatis membuat batang kualitas arsitektur untuk diri sendiri, dan cukup tinggi.  Pikiran pada tes secara otomatis meningkatkan modularitas, konektivitas yang lebih rendah, dan membuat arsitektur lebih logis. <br><br>  Dan maksud saya bukan TDD.  Penyakit khas banyak pemrogram adalah penyembahan teknologi keagamaan yang dibaca di suatu tempat tanpa memahami batas efektivitasnya.  TDD bagus ketika beberapa programmer mengerjakan kode, ketika ada departemen pengujian dan pihak berwenang memiliki pemahaman tentang mengapa praktik pengkodean yang baik diperlukan dan bersedia membayar tidak hanya untuk beberapa kode yang memecahkan masalah, tetapi juga untuk keandalannya.  Jika atasan Anda tidak siap membayar, Anda harus bekerja lebih ekonomis.  Meskipun demikian, Anda masih harus menguji kode tersebut - kecuali, tentu saja, Anda memiliki rasa percaya diri. <br><br>  Prinsip kedua adalah modularitas.  Lebih tepatnya, modularitas yang sangat terisolasi tanpa menggunakan perpustakaan / hardcode yang tidak terkait dengan modul itu sendiri.  Sekarang ketika mendesain arsitektur server, adalah modis untuk membagi monolith menjadi layanan microser.  Saya akan memberi tahu Anda rahasia yang mengerikan - setiap modul di monolith harus seperti layanan mikro.  Dalam arti bahwa itu harus mudah menonjol dari kode umum dengan minimal header yang terhubung di lingkungan pengujian.  Belum jelas, tetapi saya akan menjelaskan dengan sebuah contoh: Apakah Anda pernah mencoba mengalokasikan shared_ptr dari peningkatan?  Jika pada saat yang sama Anda berhasil menyeret tidak hanya seluruh dorongan, tetapi hanya setengah dari bahan bakunya, maka ini berarti Anda membunuh tiga hingga lima hari untuk memotong kecanduan yang tidak perlu !!!  Pada saat yang sama, Anda menyeret sepanjang fakta bahwa shared_ptr pasti tidak ada hubungannya !!! <br><br>  Dan ini lebih buruk daripada kesalahan - ini adalah kejahatan arsitektur. <br><br>  Dengan arsitektur yang baik, Anda harus dapat menghapus shared_ptr, tanpa rasa sakit dan cepat mengganti segala sesuatu yang tidak terkait dengan shared_ptr dengan versi uji.  Misalnya, versi uji pengalokasi.  Atau lupakan dorongannya.  Katakanlah Anda menulis parser xml / html.  Anda perlu bekerja dengan string dan bekerja dengan file untuk parser.  Dan jika kita berbicara tentang arsitektur ideal yang tidak terikat dengan kebutuhan perusahaan produksi / perangkat lunak tertentu, maka untuk parser dengan arsitektur ideal kita tidak memiliki hak untuk menggunakan std :: istream, std :: file_system, std :: string dan operasi pencarian hardcode dengan string di parser.  Kita harus menyediakan antarmuka aliran, antarmuka untuk operasi file (mungkin dibagi menjadi sub-antarmuka, tetapi akses ke sub-antarmuka masih harus dilakukan melalui antarmuka modul operasi file), antarmuka untuk bekerja dengan string, antarmuka pengalokasi, dan idealnya juga antarmuka untuk baris itu sendiri.  Sebagai hasilnya, kami tanpa kesulitan dapat mengganti segala sesuatu yang tidak terkait dengan penguraian dengan test blank, atau menyisipkan versi uji pengalokasi / bekerja dengan pencarian file / string dengan pemeriksaan tambahan.  Dan fleksibilitas solusi akan meningkat - besok, di bawah antarmuka aliran, tidak akan ada file, tetapi sebuah situs di suatu tempat di Internet, dan tidak ada yang akan melihatnya.  Anda dapat mengganti perpustakaan standar dengan Qt, dan kemudian beralih ke visual c ++, dan kemudian mulai menggunakan hanya hal-hal Linux - dan perubahannya akan minimal.  Sebagai spoiler, saya akan mengatakan bahwa dengan pendekatan ini, pertanyaan harga muncul dalam pertumbuhan penuh - untuk menutupi segala sesuatu dengan antarmuka, termasuk elemen dari perpustakaan standar, mahal, tetapi ini bukan tujuan, tetapi solusi. <br><br>  Secara umum, prinsip radikal module-as-microservice yang dicanangkan dalam artikel ini adalah titik lemah dalam C ++ dan umumnya ditambah kode.  Jika Anda membuat file deklarasi dan memisahkan antarmuka secara terpisah dari implementasinya, Anda masih dapat membuat independensi / isolasi file cpp dari satu sama lain, dan kemudian, relatif, bukan 100%, maka tajuk biasanya ditenun menjadi monolit padat, yang darinya tidak ada yang dapat dihancurkan tanpa daging.  Dan meskipun ini memiliki efek buruk pada waktu kompilasi, itu benar.  Selain itu, bahkan jika kemandirian judul tercapai, ini secara otomatis berarti ketidakmampuan untuk menggabungkan kelas.  Sebenarnya, satu-satunya cara untuk mencapai independensi baik file .cpp dan header di c ++ adalah dengan mendeklarasikan kelas yang sudah digunakan (tanpa mendefinisikannya), dan kemudian hanya menggunakan pointer ke mereka.  segera setelah Anda menggunakan kelas itu sendiri dan bukan penunjuk kelas di file header (yaitu, agregat), Anda akan membuat banyak semua .cpp-shnik yang menyertakan tajuk ini, dan .cpp-shnik yang berisi definisi kelas.  Masih ada fastpimpl, tetapi hanya dijamin untuk membuat dependensi pada level cpp. <br><br>  Jadi, untuk arsitektur yang baik, isolasi modul adalah penting - kemampuan untuk menarik satu modul dengan makro penghubung pertama dan jenis perpustakaan utama, dengan judul kedua untuk deklarasi dan beberapa inklusi yang menghubungkan satu set antarmuka.  Dan hanya apa yang berhubungan dengan fungsi ini, dan segala sesuatu yang lain harus disimpan dalam modul lain dan hanya dapat diakses melalui antarmuka. <br><br>  Kami menyatakan fitur utama arsitektur yang baik, termasuk poin yang ditunjukkan di atas, poin demi poin. <br><br>  Mari kita mendefinisikan istilah "Modul".  Modul adalah jumlah fungsi yang berhubungan secara logis.  Misalnya, bekerja dengan aliran atau kerja file, atau parser html. <br><br>  Modul "File Work" dapat menggabungkan banyak fungsi - buka file, tutup, posisi, baca properti, baca ukuran file.  Pada saat yang sama, pemindai folder dapat dirancang sebagai bagian dari antarmuka "File Work", atau sebagai modul terpisah, dan bekerja dengan stream dapat ditempatkan dalam modul terpisah tentunya.  Namun, yang tidak mengganggu pengorganisasian akses ke semua modul lain ke stream dan pemindai folder secara tidak langsung, melalui "File Work".  Ini tidak perlu, tetapi cukup logis. <br><br><ol><li>  Modularitas.  Imperative "Module-as-microservice". </li><li>  Alokasi 20% dari kode dieksekusi 80% dari waktu di perpustakaan terpisah - inti dari program </li><li>  Testabilitas masing-masing fungsionalitas dari setiap modul </li><li>  Antarmuka, tidak ada hardcode.  Anda hanya dapat memanggil hardcode yang secara langsung terkait dengan fungsionalitas modul, dan Anda harus membuat panggilan perpustakaan langsung lainnya ke modul terpisah dan mengaksesnya melalui antarmuka. </li><li>  Isolasi lengkap modul oleh antarmuka dari lingkungan eksternal.  Larangan implementasi "memaku" yang tidak terkait dengan fungsionalitas kelas.  Dan yang lebih radikal, mengisolasi perpustakaan (termasuk yang standar) dengan antarmuka / adaptor / dekorator </li><li>  Agregasi kelas atau membuat variabel kelas atau fastpimpl hanya digunakan ketika sangat penting untuk kinerja. </li></ol><br>  Tentu saja, kami akan mencari cara untuk dengan cepat mencapai semua ini dengan harga yang lebih rendah, tetapi saya ingin menarik perhatian ke masalah lain, solusi yang akan menjadi bonus bagi kami - transfer parameter yang tergantung pada platform.  Misalnya, jika Anda perlu membuat kode yang berfungsi sama di Android dan Windows, maka logis untuk mengalokasikan algoritma yang tergantung platform ke dalam modul terpisah.  Dalam hal ini, mungkin, implementasi untuk android mungkin memerlukan referensi ke lingkungan Java (jni), JNIEnv *, dan mungkin beberapa objek Java.  Dan implementasi pada Windows mungkin memerlukan folder kerja program (yang pada android dapat diminta dari sistem, memiliki JNIEnv *).  Kuncinya adalah bahwa JNIEnv * yang sama tidak ada dalam konteks Windows, sehingga bahkan serikat yang diketik atau alternatif c ++ untuk std :: varian tidak mungkin.  Anda dapat, tentu saja, menggunakan vektor * void atau std :: any vector sebagai parameter, tetapi jujur, ini adalah kruk atipikal.  Atypical - karena menolak keunggulan utama c ++, pengetikan yang kuat.  Dan ini lebih berbahaya daripada SARS. <br><br>  Lebih lanjut kami akan menganalisis bagaimana menyelesaikan masalah ini dengan cara yang sangat spesifik. <br><br><h2>  Bagian 2. Peluru ajaib dan label harganya </h2><br>  Jadi, katakanlah kita memiliki sejumlah besar kode yang perlu ditulis dari awal, dan hasilnya akan menjadi proyek yang sangat besar. <br><br>  Bagaimana bisa dirakit sesuai dengan prinsip yang telah kita tentukan? <br><br>  Cara klasik, yang disetujui oleh semua manual, adalah untuk membagi semuanya menjadi antarmuka dan strategi.  Dengan bantuan antarmuka dan strategi, jika ada banyak dari mereka, subproblem proyek kami dapat diisolasi sedemikian rupa sehingga prinsip "module-as-microservice" akan mulai bekerja di sana.  Tetapi pengalaman pribadi saya adalah bahwa jika Anda membagi proyek menjadi 20-30 bagian, yang akan diisolasi ke tingkat "modul-as-microservice", maka Anda akan berhasil.  Tetapi fitur utama dari arsitektur yang baik adalah kemampuan untuk menguji setiap kelas di luar konteks proyek.  Dan jika Anda sudah mengisolasi masing-masing kelas, maka sudah ada lebih dari 500 modul, dan dalam pengalaman saya, ini meningkatkan waktu pengembangan sebanyak 3-5 kali, yang berarti bahwa dalam "kondisi pertempuran" Anda tidak akan melakukan ini dan akan berkompromi antara harga dan kualitas. <br><br>  Seseorang mungkin ragu, dan akan menjadi haknya sendiri.  Mari kita membuat perkiraan kasar.  Biarkan kelas menengah memiliki 3-5 anggota dan 20 fungsi dan 3 konstruktor.  Ditambah 6-10 getter dan setter (mutator) untuk akses ke anggota kami.  Total sekitar 40 unit di kelas.  Dalam proyek tipikal, setiap kelas "pusat" membutuhkan akses ke rata-rata lima fungsi, bukan pusat ke 3. Sebagai contoh, sangat banyak kelas membutuhkan pengalokasi, sistem file, bekerja dengan string, bekerja dengan stream, dan akses ke database. <br><br>  Setiap strategi / antarmuka akan memerlukan satu anggota tipe <code>std::shared_ptr&lt;CreateStreamStrategy&gt; m_create_stream;</code>  .  Dua mutator, plus inisialisasi di masing-masing dari tiga konstruktor.  plus di suatu tempat dalam inisialisasi kelas kami, Anda perlu memanggil sesuatu seperti <code>myclass-&gt;SetCreateStreamStrategy( my_create_stream_strategy )</code> beberapa kali, dengan total 8 unit per antarmuka / strategi, dan karena kami memiliki sekitar lima unit, akan ada 40 unit.  Artinya, kami membuat kelas sumber dua kali lebih rumit.  Dan hilangnya kesederhanaan pasti akan mempengaruhi keterbacaan, dan di tempat lain dalam proses debugging, dan setengah kali, terlepas dari kenyataan bahwa tidak ada yang tampaknya pada dasarnya berubah. <br><br>  Jadi pertanyaannya adalah.  Bagaimana melakukan hal yang sama, tetapi dengan harga minimum?  Hal pertama yang terlintas dalam pikiran adalah parameterisasi statis pada templat, dengan gaya Alexandrescu dan perpustakaan Loki. <br><br>  Kami menulis kelas dengan gaya <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Traits</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoMainTaskFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... MyStream stream = Traits::streamwork::Open( stream_name ); ... } };</code> </pre> <br>  Keputusan ini memiliki semua keunggulan arsitektur yang kami identifikasi pada bagian pertama.  Namun ada juga banyak kerugiannya. <br><br>  Saya sendiri suka shabble, tapi saya menyesal untuk diri sendiri saya akui: templat dalam kode biasa hanya dicintai oleh penyihir templat.  Sejumlah besar programmer dengan kata "templat" sedikit mengernyit.  Selain itu, di industri, sebagian besar plus sebenarnya tidak plus, tetapi sedikit dilatih kembali dalam c ++ syshnik yang tidak memiliki pengetahuan yang mendalam tentang plus, tetapi jatuh di bawah kata "templat" dan berpura-pura mati. <br><br>  Jika kita menerjemahkan ini ke dalam bahasa produksi, maka mempertahankan kode pada parameterisasi statis lebih mahal dan lebih rumit. <br><br>  Pada saat yang sama, jika kita ingin, untuk tujuan keterbacaan yang lebih besar, untuk dengan hati-hati menghapus tubuh fungsi di luar kelas, maka kita mendapatkan banyak coretan dengan nama templat dan parameter templat.  Dan jika terjadi kesalahan kompilasi, kami mendapatkan rak panjang yang dapat dibaca oleh manusia dan area bermasalah dengan sekelompok templat bersarang yang kompleks. <br><br>  Tapi, ada jalan keluar sederhana.  Sebagai penyihir templat, saya menyatakan bahwa hampir semua yang dapat dilakukan menggunakan parameterisasi statis / polimorfisme statis dapat ditransfer ke polimorfisme dinamis.  Tidak, tentu saja, kami tidak akan membasmi kejahatan templat sampai akhir - tetapi kami tidak akan menyebarkannya dengan tangan yang murah hati untuk parameterisasi di setiap kelas, tetapi akan membatasinya pada beberapa kelas instrumental. <br><br><h2>  Bagian tiga.  Solusi yang diusulkan dan kode yang dikodekan untuk solusi ini </h2><br>  Jadi disana !!!  Memenuhi kelas templat TypedSet.  Ia mengaitkan satu penunjuk pintar tipe ini dengan satu tipe tunggal.  Selain itu, untuk tipe yang ditentukan mungkin memiliki objek, tetapi mungkin tidak.  Saya tidak suka namanya - jadi saya akan berterima kasih jika di komentar memberi tahu saya opsi yang lebih sukses. <br><br>  Satu tipe - satu objek.  Tetapi jumlah jenisnya tidak terbatas!  Oleh karena itu, Anda dapat melewati kelas seperti itu sebagai parameterizer. <br><br>  Saya ingin menarik perhatian Anda ke satu titik.  Tampaknya pada titik tertentu Anda mungkin memerlukan dua objek di bawah satu antarmuka.  Bahkan, jika kebutuhan seperti itu muncul, maka (menurut saya) ini berarti kesalahan arsitektur.  Artinya, jika Anda memiliki dua objek di bawah satu antarmuka, maka mereka bukan lagi antarmuka akses fungsional: ini adalah variabel input untuk fungsi tersebut, atau Anda tidak memiliki satu tetapi dua fungsionalitas yang perlu Anda akses, maka lebih baik untuk membagi antarmuka menjadi dua . <br><br>  Kami akan membuat tiga fungsi dasar: Buat, Dapatkan dan Miliki.  Dengan demikian, pembuatan, penerimaan, dan verifikasi keberadaan elemen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// @brief    .      ,    ///           /// class TypedSet { public: template &lt;class TypedElement&gt; void Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ); template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; Get() const; template &lt;class TypedElement&gt; bool Has() const; size_t GetSize() const { return storage_.size(); } protected: typedef std::map&lt; size_t, std::shared_ptr&lt;void&gt; &gt; Storage; Storage const &amp; storage() const { return storage_; } Storage &amp; get_storage() { return storage_; } private: Storage storage_; }; template &lt;class TypedElement&gt; void TypedSet::Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ) { size_t hash = typeid(TypedElement).hash_code(); if ( storage().count( hash ) &gt; 0 ) { LogError( "Access Violation" ); return; } std::shared_ptr&lt;void&gt; to_add ( value ); get_storage().insert( std::pair( typeid(TypedElement).hash_code(), to_add ) ); } template &lt;class TypedElement&gt; bool TypedSet::Has() const { size_t hash = typeid(TypedElement).hash_code(); return storage().count( hash ) &gt; 0; } template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; TypedSet::Get() const { size_t hash = typeid(TypedElement).hash_code(); if ( storage().count( hash ) &gt; 0 ) { std::shared_ptr&lt;void&gt; ret( storage().at(hash) ); return std::static_pointer_cast&lt;TypedElement&gt;( ret ); } else { LogError( "Access Violation" ); return std::shared_ptr&lt;TypedElement&gt; (); } }</span></span></code> </pre> <br>  Ngomong-ngomong, saya melihat solusi alternatif dari rekan-rekan menulis di Qt.  Di sana, akses ke antarmuka yang diinginkan dilakukan melalui singleton, yang "memetakan" antarmuka yang diinginkan, dikemas ke Varaint, melalui baris teks (!!!), dan setelah casting opsi ini, hasilnya dapat digunakan. <br><br><pre> <code class="cpp hljs">GlobalConfigurator()[<span class="hljs-string"><span class="hljs-string">"FileSystem"</span></span>].Get().As&lt;FileSystem&gt;()</code> </pre> <br>  Tentu saja berhasil, tetapi overhead menghitung panjang dan lebih lanjut hashing string agak menakutkan bagi jiwa optimis saya.  Di sini, biaya overhead adalah nol, karena  pilihan antarmuka yang diinginkan dilakukan pada waktu kompilasi. <br><br>  Berdasarkan pada TypedSet, kita dapat membuat kelas StrategiesSet, yang sudah lebih maju.  Di dalamnya kita akan menyimpan tidak hanya satu objek per antarmuka akses untuk setiap fungsional, tetapi juga untuk setiap antarmuka (selanjutnya disebut sebagai strategi) sebuah TypedSet tambahan dengan parameter untuk strategi ini.  Saya mengklarifikasi: parameter, tidak seperti variabel fungsi, adalah apa yang ditetapkan sekali selama inisialisasi program atau sekali untuk menjalankan program besar.  Parameter memungkinkan Anda untuk membuat kode benar-benar lintas platform.  Di sanalah kita menggerakkan seluruh dapur yang bergantung pada platform. <br><br>  Di sini kita akan memiliki lebih banyak fungsi dasar: Buat, Dapatkan, CreateParamsSet dan GetParamsSet.  Belum diletakkan, karena secara arsitektur berlebihan: jika kode Anda merujuk pada fungsionalitas bekerja dengan sistem file, tetapi kode panggilan tidak menyediakannya, Anda hanya dapat melempar pengecualian atau menegaskan, atau <s>membuat program sebukka</s> memanggil fungsi abort () berfungsi. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Create</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; &amp; value ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; Get(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateParamsSet</span></span></span><span class="hljs-class">();</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; GetParamsSet(); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CreateParam</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; &amp; value ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; GetParam(); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-function">TypedSet </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strategies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strategies_; } <span class="hljs-function"><span class="hljs-function">TypedSet &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_strategies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> strategies_; } <span class="hljs-function"><span class="hljs-function">TypedSet </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params_; } <span class="hljs-function"><span class="hljs-function">TypedSet &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> params_; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamHolder</span></span></span><span class="hljs-class"> {</span></span> ParamHolder( ) : param_ptr( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;TypedSet&gt;() ) {} <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; param_ptr; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TypedSet strategies_; TypedSet params_; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:Create( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; &amp; value ) { get_strategies().Create&lt;Strategy&gt;( value ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Strategy&gt; StrategiesSet::Get() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_strategies().Get&lt;Strategy&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:CreateParamsSet( ) { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Holder &gt; ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; Holder &gt;( ); ptr-&gt;param_ptr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; TypedSet &gt;(); get_params().Create&lt; Holder &gt;( ptr ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; StrategiesSet::GetParamsSet() { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( get_params().Has&lt; Holder &gt;() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_params().Get&lt; Holder &gt;()-&gt;param_ptr; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LogError(<span class="hljs-string"><span class="hljs-string">"StrategiesSet::GetParamsSet : get unexisting!!!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt;(); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategiesSet</span></span></span><span class="hljs-class">:</span></span>:CreateParam( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; &amp; value ) { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !params().Has&lt;Holder&gt;() ) CreateParamsSet&lt;Strategy&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( params().Has&lt;Holder&gt;() ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TypedSet&gt; params_set = GetParamsSet&lt;Strategy&gt;(); params_set-&gt;Create&lt;ParamType&gt;( value ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { LogError( <span class="hljs-string"><span class="hljs-string">"Param creating error: Access Violation"</span></span> ); } } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParamType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ParamType&gt; StrategiesSet::GetParam() { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> ParamHolder&lt;Strategy&gt; Holder; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( params().Has&lt;Holder&gt;() ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> GetParamsSet&lt;Strategy&gt;()-&gt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> Get&lt;ParamType&gt;(); <span class="hljs-comment"><span class="hljs-comment">//   template          .    . } else { LogError( "Access Violation" ); return std::shared_ptr&lt;ParamType&gt; (); } }</span></span></code> </pre> <br>  Nilai tambah tambahan adalah bahwa pada tahap prototyping Anda dapat membuat satu kelas pengetikan super besar, menjejalkan akses ke semua modul ke dalamnya, dan meneruskannya ke semua modul sebagai parameter, dengan cepat menjadi kecil, dan kemudian diam-diam memecahnya menjadi potongan-potongan yang minimal diperlukan untuk setiap modul. <br><br>  Yah, dan kasus penggunaan yang kecil dan (belum) terlalu disederhanakan.  Saya harap Anda di komentar menyarankan saya apa yang ingin Anda lihat sebagai contoh sederhana, dan saya akan membuat artikel ini menjadi upgrade kecil.  Seperti yang dikatakan oleh kebijaksanaan pemrograman populer, "Rilis sedini mungkin dan tingkatkan penggunaan umpan balik setelah rilis." <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface1\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface1() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface2\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface2() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Interface3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\niface3\n"</span></span>);} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Interface3() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Implementation1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Interface1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nimpl1\n"</span></span>);} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Implementation2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Interface2 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Fun</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nimpl2\n"</span></span>);} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParams</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PrintParams() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParamsUbuntu</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintParams { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Ubuntu"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintParamsWindows</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintParams { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Windows"</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintStrategy</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~PrintStrategy() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TypedSet&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; str )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintWithOsStrategy</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> PrintStrategy { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TypedSet&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; str )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> os = params.Get&lt; PrintParams &gt;()-&gt;GetOs(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" Printing: %s (OS=%s)"</span></span>, str.c_str(), os.c_str() ); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestTypedSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; TypedSet a; a.Create&lt;Interface1&gt;( make_shared&lt;Implementation1&gt;() ); a.Create&lt;Interface2&gt;( make_shared&lt;Implementation2&gt;() ); a.Get&lt;Interface1&gt;()-&gt;Fun(); a.Get&lt;Interface2&gt;()-&gt;Fun(); Log(<span class="hljs-string"><span class="hljs-string">"Double creation:"</span></span>); a.Create&lt;Interface1&gt;( make_shared&lt;Implementation1&gt;() ); Log(<span class="hljs-string"><span class="hljs-string">"Get unexisting:"</span></span>); a.Get&lt;Interface3&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestStrategiesSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>; StrategiesSet printing; printing.Create&lt; PrintStrategy &gt;( make_shared&lt;PrintWithOsStrategy&gt;() ); printing.CreateParam&lt; PrintStrategy, PrintParams &gt;( make_shared&lt;PrintParamsWindows&gt;() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> print_strategy_ptr = printing.Get&lt; PrintStrategy &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; print_strategy = *print_strategy_ptr; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; print_params = *printing.GetParamsSet&lt; PrintStrategy &gt;(); print_strategy( print_params, <span class="hljs-string"><span class="hljs-string">"Done!"</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TestTypedSet(); TestStrategiesSet(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  Ringkasan </h2><br>  Jadi, kami memecahkan masalah penting: kami hanya meninggalkan antarmuka yang berhubungan langsung dengan fungsi kelas.  Sisanya "didorong" ke dalam StrategiesSet, sambil menghindari keduanya mengacaukan kelas dengan elemen yang tidak perlu, dan "memaku" fungsi tertentu yang kami butuhkan untuk algoritme.  Ini akan memungkinkan kita tidak hanya untuk menulis kode yang sangat terisolasi, dengan nol ketergantungan pada implementasi dan perpustakaan, tetapi juga untuk menghemat banyak waktu. <br><br>  Kode untuk kelas contoh dan alat dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br>  <b>Pembaruan.</b>  <b>dari 11/13/2019</b> <br>  Sebenarnya, kode yang ditampilkan di sini hanyalah contoh sederhana untuk keterbacaan.  Faktanya adalah typeid (). Hash_code diimplementasikan dalam kompiler modern secara perlahan dan tidak efisien.  Penggunaannya membunuh banyak artinya.  Selain itu, seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">disarankan 0xd34df00d</a> dihormati, standar tidak menjamin kemampuan untuk membedakan jenis dengan kode hash (dalam prakteknya, pendekatan ini berfungsi).  Tetapi contohnya dibaca dengan baik.  Saya menulis ulang TypedSet tanpa typeid (). Hash_code (), apalagi, diganti peta dengan array (tetapi dengan kemampuan untuk dengan cepat beralih dari peta ke array dan sebaliknya dengan mengubah satu digit di #jika).  Ternyata lebih sulit, tetapi lebih menarik untuk penggunaan praktis. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di coliru</a> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> metatype { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetAndIncrease() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter_++; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> counter_ = <span class="hljs-number"><span class="hljs-number">1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashGetterBody</span></span></span><span class="hljs-class"> {</span></span> HashGetterBody() : hash_( counter_.GetAndIncrease() ) { } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetHash() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash_; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Counter counter_; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> hash_; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Type&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashGetter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> GetHash() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hasher_.GetHash(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> HashGetterBody&lt;Type&gt; hasher_; }; } <span class="hljs-comment"><span class="hljs-comment">// namespace metatype template &lt;typename Type&gt; size_t GetTypeHash() { return metatype::HashGetter&lt;Type&gt;().GetHash(); } namespace details { #if 1 //   ,        () class TypedSetStorage { public: static inline const constexpr size_t kMaxTypes = 100; typedef std::array&lt; std::shared_ptr&lt;void&gt;, kMaxTypes &gt; Storage; void Set( size_t hash_index, const std::shared_ptr&lt;void&gt; &amp; value ) { ++size_; assert( hash_index &lt; kMaxTypes ); // too many types data_[hash_index] = value; } std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) { assert( hash_index &lt; kMaxTypes ); return data_[hash_index]; } const std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) const { if ( hash_index &gt;= kMaxTypes ) return empty_ptr_; return data_[hash_index]; } bool Has( size_t hash_index ) const { if ( hash_index &gt;= kMaxTypes ) return 0; return (bool)data_[hash_index]; } size_t GetSize() const { return size_; } private: Storage data_; size_t size_ = 0; static const inline std::shared_ptr&lt;void&gt; empty_ptr_; }; #else //    ,        (std::map) class TypedSetStorage { public: typedef std::map&lt; size_t, std::shared_ptr&lt;void&gt; &gt; Storage; void Set( size_t hash_index, const std::shared_ptr&lt;void&gt; &amp; value ) { data_[hash_index] = value; } std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) { return data_[hash_index]; } const std::shared_ptr&lt;void&gt; &amp; Get( size_t hash_index ) const { return data_.at(hash_index); } bool Has( size_t hash_index ) const { return data_.count(hash_index) &gt; 0; } size_t GetSize() const { return data_.size(); } private: Storage data_; }; #endif } // namespace details /// @brief    .      ,    ///           /// class TypedSet { public: template &lt;class TypedElement&gt; void Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ); template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; Get() const; template &lt;class TypedElement&gt; bool Has() const; size_t GetSize() const { return storage_.GetSize(); } protected: typedef details::TypedSetStorage Storage; Storage const &amp; storage() const { return storage_; } Storage &amp; get_storage() { return storage_; } private: Storage storage_; }; template &lt;class TypedElement&gt; void TypedSet::Create( const std::shared_ptr&lt;TypedElement&gt; &amp; value ) { size_t hash = GetTypeHash&lt;TypedElement&gt;(); if ( storage().Has( hash ) ) { LogError( "Access Violation" ); return; } std::shared_ptr&lt;void&gt; to_add ( value ); get_storage().Set( hash, to_add ); } template &lt;class TypedElement&gt; bool TypedSet::Has() const { size_t hash = GetTypeHash&lt;TypedElement&gt;(); return storage().Has( hash ); } template &lt;class TypedElement&gt; std::shared_ptr&lt;TypedElement&gt; TypedSet::Get() const { size_t hash = GetTypeHash&lt;TypedElement&gt;(); if ( storage().Has( hash ) ) { std::shared_ptr&lt;void&gt; ret( storage().Get( hash ) ); return std::static_pointer_cast&lt;TypedElement&gt;( ret ); } else { LogError( "Access Violation" ); return std::shared_ptr&lt;TypedElement&gt; (); } }</span></span></code> </pre><br>  Di sini akses dilakukan dalam waktu linier, jenis hash dihitung sebelum main () diluncurkan, kerugian hanya untuk pemeriksaan validasi, yang dapat dibuang jika diinginkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id475268/">https://habr.com/ru/post/id475268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id475254/index.html">AERODISK vAIR arsitektur atau fitur bangunan cluster nasional</a></li>
<li><a href="../id475258/index.html">Representasi visual dari pemilihan di St. Petersburg - keajaiban pembungkus suara</a></li>
<li><a href="../id475260/index.html">Perbedaan antara fungsi asinkron dan fungsi yang mengembalikan janji</a></li>
<li><a href="../id475262/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 388 (4 - 10 November, 2019)</a></li>
<li><a href="../id475264/index.html">Sniffer yang bisa: bagaimana keluarga FakeSecurity menginfeksi toko online</a></li>
<li><a href="../id475270/index.html">SwiftUI: Membuat Bagian yang Dapat Diperluas / Dilipat dalam Tampilan Daftar</a></li>
<li><a href="../id475272/index.html">Bermigrasi ke infrastruktur menunggu async di Rust</a></li>
<li><a href="../id475276/index.html">Cara menulis menegaskan dengan benar</a></li>
<li><a href="../id475278/index.html">Cara mengintip peretas sementara peretas mengintip Anda</a></li>
<li><a href="../id475280/index.html">Kata sandi Cisco, migrasi zona DNS, nol permintaan LDAP, kami kumpulkan paket Ethernet. Memecahkan masalah pada jaringan dengan r0ot-mi. Bagian 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>