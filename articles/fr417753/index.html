<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí™üèæ üßëüèø‚Äçü§ù‚Äçüßëüèº ü§≠ Compression de grands tableaux de nombres premiers ü¶í üëí üëáüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les propri√©t√©s des nombres premiers vous permettent rarement de travailler avec eux diff√©remment que sous la forme d'un tableau pr√©-calcul√© - et de pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Compression de grands tableaux de nombres premiers</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417753/"><img src="https://habrastorage.org/webt/sr/yf/y8/sryfy8c2vpyfx-euoq7v_v3p_sa.jpeg" alt="bac √† sable" align="left"><br><p>  Les propri√©t√©s des nombres premiers vous permettent rarement de travailler avec eux diff√©remment que sous la forme d'un tableau pr√©-calcul√© - et de pr√©f√©rence aussi volumineux que possible.  Le format de stockage naturel sous la forme d'entiers de l'une ou l'autre capacit√© num√©rique souffre en m√™me temps de certains inconv√©nients qui deviennent importants avec la croissance du volume de donn√©es. <br></p><p></p><p>  Ainsi, le format des entiers non sign√©s 16 bits avec la taille d'une telle table est d'environ 13 kilo-octets, il ne contient que 6542 nombres premiers: suivi du nombre 65531 sont les valeurs de la profondeur de bits la plus √©lev√©e.  Une telle table ne convient que comme jouet. <br></p><p></p><p>  Le format entier 32 bits le plus populaire en programmation semble beaucoup plus solide - il vous permet d'en stocker environ 203 millions de simples.  Mais une telle table occupe d√©j√† environ 775 m√©gaoctets. <br></p><p></p><p>  Le format 64 bits a encore plus de perspectives.  Cependant, avec une puissance th√©orique de l'ordre de 1e + 19 valeurs, la table aurait une taille de 64 exaoctets. <br></p><br><a name="habracut"></a><br><p></p><p>  On ne croit pas vraiment que notre humanit√© progressiste calculera jamais dans un avenir pr√©visible un tableau des nombres premiers d'un tel volume.  Et le point ici n'est pas tant dans les volumes que dans le temps de comptage des algorithmes disponibles.  Disons que si le tableau de tous les simples 32 bits peut encore √™tre calcul√© ind√©pendamment en quelques heures (Fig.1), alors pour le tableau au moins un ordre de grandeur plus grand, cela prendra plusieurs jours.  Mais de tels volumes aujourd'hui - ce n'est que le niveau initial. <br></p><br><br><img src="https://habrastorage.org/webt/ut/qn/gq/utqngqsvjfyolxj1afp9n--6jxw.jpeg" alt="fig.1"><br><br><p>  Comme le montre le diagramme, le temps de calcul sp√©cifique apr√®s la secousse de d√©but passe en douceur √† une croissance asymptotique.  Il est plut√¥t lent.  mais c'est la croissance, ce qui signifie que l'extraction de chaque prochaine donn√©e au fil du temps sera de plus en plus difficile.  Si vous voulez faire une perc√©e importante, vous devrez parall√©liser le travail √† travers les c≈ìurs (et il se parall√©lise bien) et l'accrocher sur des superordinateurs.  Avec la perspective d'obtenir les 10 premiers milliards simples en une semaine, et 100 milliards - seulement en un an.  Bien s√ªr, il existe des algorithmes plus rapides pour le calcul simple que le buste trivial utilis√© dans mes devoirs, mais, en substance, cela ne change rien: apr√®s deux ou trois ordres de grandeur, la situation devient similaire. <br></p><p></p><p>  Par cons√©quent, il serait bon d'avoir effectu√© une fois le travail de comptage, de stocker son r√©sultat sous forme de tableau pr√™t √† l'emploi et de l'utiliser au besoin. <br></p><p></p><p>  En raison de l'√©vidence de l'id√©e, le r√©seau rencontre de nombreux liens vers des listes pr√©d√©finies de nombres premiers d√©j√† calcul√©s par quelqu'un.  H√©las, dans la plupart des cas, ils ne conviennent qu'√† l'artisanat √©tudiant: l'un d'eux, par exemple, se prom√®ne de site en site et comprend 50 millions de simples.  Ce montant ne peut qu'√©tonner les non-initi√©s: il a d√©j√† √©t√© mentionn√© ci-dessus que sur un ordinateur personnel, en quelques heures, vous pouvez calculer ind√©pendamment le tableau de tous les simples 32 bits, et il est quatre fois plus grand.  Il y a environ 15 √† 20 ans, une telle liste √©tait en effet une r√©alisation h√©ro√Øque pour la communaut√© la√Øque.  Aujourd'hui, √† l'√®re des appareils multi-c≈ìurs multi-gigahertz et multi-gigaoctets, ce n'est plus impressionnant. <br></p><p></p><p>  J'ai eu la chance de me familiariser avec l'acc√®s √† un tableau beaucoup plus repr√©sentatif de tableaux simples, que j'utiliserai plus loin comme illustration et sacrifice pour mes exp√©riences sur le terrain.  Aux fins de complot, je l'appellerai <b>1TPrimo</b> .  Il contient tous les nombres premiers inf√©rieurs √† un billion. <br></p><p></p><p>  En utilisant 1TPrimo comme exemple, il est facile de voir quels volumes vous devez g√©rer.  Avec une capacit√© d'environ 37,6 milliards de valeurs au format entier 64 bits, cette liste est de 280 gigaoctets.  Soit dit en passant - la partie de celui-ci qui pourrait tenir sur 32 chiffres ne repr√©sente que 0,5% du nombre de chiffres qui y sont repr√©sent√©s.  Cela rend absolument clair que tout travail s√©rieux avec des nombres premiers tend in√©vitablement √† des profondeurs de bits de 64 bits (ou plus). <br></p><p></p><p>  Ainsi, la tendance sombre est √©vidente: une table de nombres premiers en quelque sorte s√©rieuse a in√©vitablement un volume titanesque.  Et nous devons en quelque sorte lutter contre cela. <br></p><p></p><p>  La premi√®re chose qui vient √† l'esprit lorsque l'on regarde un tableau (Fig.2) est qu'il se compose de valeurs cons√©cutives presque identiques qui ne diff√®rent que par une ou deux des derni√®res d√©cimales: <br></p><br><p><br><img src="https://habrastorage.org/webt/y7/hk/f5/y7hkf5s75ii-jdujarftwhpd14i.jpeg" alt="fig.2"><br><br></p><br><p>  Simplement, √† partir des consid√©rations abstraites les plus g√©n√©rales: si le fichier contient beaucoup de donn√©es en double, il doit √™tre bien compress√© par l'archiveur.  En effet, la compression de la table 1TPrimo avec l'utilitaire 7-zip populaire aux param√®tres standard a donn√© un taux de compression assez √©lev√©: 8,5.  Certes, le temps de traitement - avec l'√©norme taille de la table source - sur un serveur √† 8 c≈ìurs, avec une charge moyenne de tous les c≈ìurs d'environ 80 √† 90%, √©tait de 14 heures 12 minutes.  Les algorithmes de compression universels sont con√ßus pour des id√©es abstraites et g√©n√©ralis√©es sur les donn√©es.  Dans certains cas particuliers, des algorithmes de compression sp√©cialis√©s bas√©s sur les caract√©ristiques bien connues de l'ensemble de donn√©es entrantes peuvent d√©montrer des indicateurs beaucoup plus efficaces, auxquels ce travail est consacr√©.  Et son efficacit√© deviendra claire ci-dessous. <br></p><p></p><p>  Les valeurs num√©riques proches des nombres premiers voisins demandent la d√©cision de ne pas stocker ces valeurs elles-m√™mes, mais les intervalles (diff√©rences) entre elles.  Dans ce cas, des √©conomies importantes peuvent √™tre r√©alis√©es du fait que la profondeur de bits des intervalles est bien inf√©rieure √† la profondeur de bits des donn√©es initiales (Fig. 3). <br></p><br><p><br><img src="https://habrastorage.org/webt/7-/lk/ka/7-lkkafdhzaus8yglobx1t5t25w.jpeg" alt="fig.3"><br><br></p><br><p>  Et il semble que cela ne d√©pende pas de la profondeur de bits des simples g√©n√©rant l'intervalle.  Une recherche exhaustive montre que les valeurs typiques des intervalles pour les nombres premiers pris √† divers endroits dans la table 1TPrimo se situent dans les unit√©s, les dizaines, parfois les centaines, et - comme premi√®re phrase de travail - ils pourraient probablement s'inscrire dans la plage de 8 bits entiers non sign√©s, c'est-√†-dire octets.  Ce serait tr√®s pratique, et en comparaison avec le format 64 bits, cela conduirait imm√©diatement √† une compression de donn√©es 8 fois - quelque part au niveau d√©montr√© par l'archiveur 7-zip.  De plus, la simplicit√© des algorithmes de compression et de d√©compression devrait en principe avoir un impact majeur sur la vitesse de compression et d'acc√®s aux donn√©es par rapport au 7-zip.  Cela semble tentant. <br></p><p></p><p>  Il est absolument clair que les donn√©es converties de leurs valeurs absolues en intervalles relatifs entre elles ne conviennent que pour restaurer une s√©rie de valeurs venant dans une rang√©e depuis le tout d√©but de la table principale.  Mais si nous ajoutons une structure d'index de bloc minimale √† une telle table d'intervalles, alors avec des frais g√©n√©raux suppl√©mentaires insignifiants, cela nous permettra de restaurer - mais d√©j√† bloc par bloc - √† la fois l'√©l√©ment de table par son num√©ro et l'√©l√©ment le plus proche par une valeur d√©finie arbitrairement, et ces op√©rations, ainsi que l'op√©ration principale √©chantillons de s√©quence - en g√©n√©ral, il √©puise la part du lion des requ√™tes possibles sur ces donn√©es.  Le traitement statistique, bien s√ªr, deviendra plus compliqu√©, mais il restera tout de m√™me assez transparent, car  il n'y a aucune astuce particuli√®re pour le r√©cup√©rer "√† la vol√©e" √† partir des intervalles disponibles lors de l'acc√®s au bloc de donn√©es requis. <br></p><p></p><p>  Mais h√©las.  Une simple exp√©rience num√©rique sur les donn√©es 1TPrimo montre que d√©j√† √† la fin des troisi√®mes dizaines de millions (c'est moins d'un centi√®me de pour cent du volume 1TPrimo) - puis partout ailleurs - les intervalles entre les nombres premiers adjacents tombent r√©guli√®rement en dehors de la plage de 0..255. <br></p><p></p><p>  N√©anmoins, une exp√©rience num√©rique l√©g√®rement compliqu√©e r√©v√®le que la croissance de l'intervalle maximal entre les nombres premiers voisins avec la croissance de la table elle-m√™me est tr√®s, tr√®s lente - ce qui signifie que l'id√©e est toujours bonne d'une certaine mani√®re. <br></p><p></p><p>  Le deuxi√®me, plus attentif au tableau des intervalles, sugg√®re qu'il est possible de stocker non pas la diff√©rence elle-m√™me, mais sa moiti√©.  Puisque tous les nombres premiers sup√©rieurs √† 2 sont √©videmment impairs, respectivement, leurs diff√©rences sont √©videmment √©gales.  En cons√©quence, les diff√©rences peuvent √™tre r√©duites de 2 sans perte de valeur;  et pour √™tre complet, on peut √©galement soustraire un du quotient obtenu afin d'utiliser utilement la valeur z√©ro qui n'a pas √©t√© revendiqu√©e autrement (figure 4).  Une telle r√©duction des intervalles sera appel√©e ci-apr√®s monolithique, contrairement √† la forme initiale l√¢che et poreuse, dans laquelle toutes les valeurs impaires et z√©ro se sont av√©r√©es non r√©clam√©es. <br></p><br><p><br><img src="https://habrastorage.org/webt/ix/ob/fp/ixobfp-kfzmw2gkwjrkkmwcfxn4.jpeg" alt="fig.4"><br><br></p><br><p>  Il convient de noter que puisque l'intervalle entre les deux premiers simples (2 et 3) ne correspond pas √† ce sch√©ma, alors 2 devra √™tre exclu du tableau des intervalles et garder ce fait √† l'esprit tout le temps. <br></p><p></p><p>  Cette technique simple vous permet de coder des intervalles de 2 √† 512 dans la plage de valeurs 0..255. Encore une fois, l'espoir prend vie que la m√©thode de la diff√©rence nous permettra d'emballer une s√©quence beaucoup plus puissante de nombres premiers.  Et √† juste titre: une s√©rie de 37,6 milliards de valeurs pr√©sent√©es dans la liste 1TPrimo n'a r√©v√©l√© que 6 (six!) Intervalles qui ne sont pas dans la plage 2..512. <br></p><p></p><p>  Mais c'√©tait une bonne nouvelle;  la mauvaise chose est que ces six intervalles sont dispers√©s assez librement sur la liste, et le premier d'entre eux se produit d√©j√† √† la fin du premier tiers de la liste, transformant les deux tiers restants en ballast impropre √† cette m√©thode de compression (Fig.5): <br></p><br><p><br><img src="https://habrastorage.org/webt/k_/0y/aw/k_0yaw46rbatmne64qzj0vp9mus.jpeg" alt="fig.5"><br><br></p><br><p>  Un tel flush (quelques malheureux six pi√®ces pour pr√®s de quarante milliards! - et sur vous ...) m√™me avec une mouche dans la pommade √† comparer - pour montrer l'honneur du goudron.  Mais h√©las, c'est un mod√®le, pas un accident.  Si l'on trace la premi√®re apparition d'intervalles entre les nombres premiers en fonction de la longueur des donn√©es, il devient clair que ce ph√©nom√®ne r√©side dans la g√©n√©tique des nombres premiers, bien qu'il progresse extr√™mement lentement (Fig. 6 *). <br></p><br><p><br><img src="https://habrastorage.org/webt/sj/c_/ah/sjc_ah1hgw7ud9xewa3_s47edhq.jpeg" alt="fig.6"><br><br></p><br><p>  * Calendrier compil√© selon le site th√©matique de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thomas R. Nisley</a> , <br>  qui sont plusieurs ordres de grandeur sup√©rieurs √† la puissance de la liste 1TPrimo </p><br><p></p><p>  Mais m√™me cette progression tr√®s lente laisse entendre sans ambigu√Øt√©: on ne peut se limiter √† une certaine profondeur de bits pr√©d√©termin√©e d'un intervalle qu'√† une certaine puissance pr√©d√©termin√©e de la liste.  Autrement dit, il ne convient pas comme solution universelle. <br></p><p></p><p>  Cependant, le fait que la m√©thode propos√©e de compression d'une s√©quence de nombres premiers vous permette d'impl√©menter une table compacte simple avec une capacit√© de pr√®s de 12 milliards de valeurs est d√©j√† tout √† fait un r√©sultat.  Une telle table occupe un volume de 11,1 gigaoctets - contre 89,4 gigaoctets dans un format trivial 64 bits.  Certes, pour un certain nombre d'applications, une telle solution peut √™tre suffisante. <br></p><p></p><p>  Et ce qui est int√©ressant: la proc√©dure de traduction d'une table 1TPrimo 64 bits au format d'intervalles 8 bits avec une structure de bloc, en utilisant un seul c≈ìur de processeur (pour la parall√©lisation, vous devrez recourir √† une complication importante du programme, et cela n'en valait absolument pas la peine) et pas plus de 5 % de la charge du processeur (la plupart du temps consacr√© aux op√©rations sur les fichiers) n'a pris que 19 minutes Contre - je me souviens - 14 heures sur huit c≈ìurs √† 80-90% de la charge d√©pens√©e par l'archiveur 7-zip. <br></p><p></p><p>  Bien s√ªr, seul le premier tiers du tableau a √©t√© soumis √† cette traduction, dans laquelle la plage d'intervalles ne d√©passe pas 512. Par cons√©quent, si nous apportons les 14 heures compl√®tes au m√™me tiers, alors 19 minutes doivent √™tre compar√©es √† pr√®s de 5 heures de l'archiveur 7-zip.  Avec une quantit√© comparable de compression (8 et 8,5), la diff√©rence est environ 15 fois.  √âtant donn√© que la part du lion du temps de travail du programme de diffusion √©tait occup√©e par les op√©rations de fichiers, la diff√©rence serait encore plus accentu√©e sur un syst√®me de disque plus rapide.  Et intellectuellement, le temps de fonctionnement de 7-zip sur huit c≈ìurs doit toujours √™tre compt√© sur un seul thread, puis la comparaison deviendra vraiment ad√©quate. <br></p><p></p><p>  La s√©lection dans une telle base de donn√©es diff√®re tr√®s peu dans le temps de la s√©lection dans la table des donn√©es d√©compress√©es et est presque enti√®rement d√©termin√©e par le temps des op√©rations sur les fichiers.  Les nombres sp√©cifiques d√©pendent fortement du mat√©riel sp√©cifique, sur mon serveur, en moyenne, l'acc√®s √† un bloc de donn√©es arbitraire a pris 37,8 Œºs, tandis que la lecture s√©quentielle des blocs - 4,2 Œºs par bloc, pour un d√©ballage complet du bloc - moins de 1 Œºs.  Autrement dit, cela n'a aucun sens de comparer la d√©compression des donn√©es avec le travail d'un archiveur standard.  Et c'est un gros plus. <br></p><p></p><p>  Et, enfin, les observations offrent une autre troisi√®me solution qui supprime toute restriction sur la puissance des donn√©es: des intervalles de codage avec des valeurs de longueur variable.  Cette technique est depuis longtemps largement utilis√©e dans les applications li√©es √† la compression.  Sa signification est que si l'on trouve dans l'entr√©e que certaines valeurs sont souvent trouv√©es, certaines sont moins courantes et certaines sont tr√®s rares, alors nous pouvons coder le premier avec des codes courts, le second avec des codes plus authentiques et le troisi√®me - tr√®s long (peut-√™tre m√™me tr√®s long, car peu importe: tout de m√™me, de telles donn√©es sont tr√®s rares).  Par cons√©quent, la longueur totale des codes re√ßus peut √™tre beaucoup plus courte que les donn√©es d'entr√©e. <br></p><p></p><p>  En examinant d√©j√† le graphique de l'apparence des intervalles de la figure 7, nous pouvons faire l'hypoth√®se que si les intervalles sont 2, 4, 6, etc.  apparaissent plus t√¥t que les intervalles, disons 100, 102, 104, etc., alors les premiers devraient continuer √† se produire beaucoup plus souvent que les seconds.  Et vice versa - si les intervalles 514 ne se pr√©sentent qu'√† partir de 11,99 milliards, 516 - √† partir de 16,2 milliards et 518 - √† partir de seulement 87,7 milliards, ils ne se rencontreront que tr√®s rarement.  C'est-√†-dire que, a priori, nous pouvons supposer la relation inverse entre la taille de l'intervalle et sa fr√©quence dans une s√©quence de nombres premiers.  Et cela signifie - vous pouvez construire une structure simple qui impl√©mente des codes de longueur variable pour eux. <br></p><p></p><p>  Bien entendu, les statistiques sur la fr√©quence des intervalles devraient devenir d√©terminantes pour le choix d'une m√©thode de codage particuli√®re.  Heureusement, contrairement aux donn√©es arbitraires, la fr√©quence des intervalles entre les nombres premiers - qui en eux-m√™mes sont une s√©quence donn√©e d√©termin√©e une fois pour toutes - est √©galement une caract√©ristique d√©finie une fois pour toutes et strictement d√©termin√©e. <br></p><p></p><p>  La figure 7 montre la r√©ponse en fr√©quence des intervalles pour l'ensemble de la liste 1TPrimo: <br></p><br><p><br><img src="https://habrastorage.org/webt/7q/ga/ii/7qgaii-1mwxlmuvicojaklwrbuk.jpeg" alt="fig.7"><br><br></p><br><p>  Ici, il est n√©cessaire de mentionner √† nouveau que l'intervalle entre les tout premiers nombres premiers 2 et 3 est exclu du graphique: cet intervalle est 1 et se produit exactement une fois dans la s√©quence des nombres premiers, quelle que soit la puissance de la liste.  Cet intervalle est si particulier qu'il est plus facile de supprimer 2 de la liste des simples que de s'√©garer constamment dans les r√©servations.  Le sim est d√©clar√© que le <b>nombre 2 est un nombre premier virtuel</b> : il n'est pas visible dans les listes, mais il est l√†.  Comme ce gopher. <br></p><p></p><p>  √Ä premi√®re vue, le graphique des fr√©quences confirme pleinement l'hypoth√®se a priori donn√©e par quelques paragraphes ci-dessus.  Il montre clairement l'h√©t√©rog√©n√©it√© statistique des intervalles et la fr√©quence √©lev√©e des petites valeurs par rapport aux grandes.  Cependant, dans la deuxi√®me vue, plus convexe, le graphique s'av√®re beaucoup plus int√©ressant (Fig.8): <br></p><br><p><br><img src="https://habrastorage.org/webt/qm/4_/xu/qm4_xuzdshet30cdd9ucm7t4q0m.jpeg" alt="fig.8"><br><br></p><br><p>  De fa√ßon assez inattendue, il s'av√®re que les intervalles les plus fr√©quents ne sont pas 2 et 4, comme cela semblait provenir de consid√©rations g√©n√©rales, mais 6, 12 et 18, suivis de 10 - et seulement ensuite 2 et 4 avec une fr√©quence presque √©gale (diff√©rence en 7 chiffres apr√®s le point d√©cimal).  Et en outre, la multiplicit√© des valeurs de cr√™te du nombre 6 est trac√©e dans tout le graphique. <br></p><p></p><p>  Encore plus int√©ressant, cette nature r√©v√©l√©e par inadvertance du graphique est universelle - et, dans tous les d√©tails, avec tous ses d√©fauts - sur toute la s√©quence d'intervalles simples repr√©sent√©e par la liste 1TPrimo, il est probable qu'elle soit universelle pour toute s√©quence d'intervalles simples (bien s√ªr, une telle d√©claration audacieuse a besoin de preuves, que je transmets avec grand plaisir aux √©paules des sp√©cialistes de la th√©orie des nombres).  La figure 10 montre une comparaison des statistiques d'intervalle complet (ligne √©carlate) avec des √©chantillons √† intervalle limit√© pr√©lev√©s √† plusieurs endroits arbitraires de la liste 1TPrimo (lignes d'autres couleurs): <br></p><br><p><br><img src="https://habrastorage.org/webt/xs/jk/hd/xsjkhdqm8aztn2qztye3ftpf0yw.jpeg" alt="fig.9"><br></p><br><p>  On peut voir sur ce graphique que tous ces √©chantillons se r√©p√®tent exactement, avec seulement une l√©g√®re diff√©rence dans les parties gauche et droite de la figure: ils semblent √™tre l√©g√®rement tourn√©s dans le sens antihoraire autour du point d'intervalle avec une valeur de 24. Cette rotation est probablement due au fait que le plus haut dans la gauche des parties des graphiques sont construites sur des √©chantillons avec des profondeurs de bits plus faibles.  Dans de tels √©chantillons, il n'y en a pas encore du tout, ou de grands intervalles sont rares, qui deviennent fr√©quents dans les √©chantillons avec des profondeurs de bits plus √©lev√©es.  En cons√©quence, leur absence est en faveur de la fr√©quence des intervalles avec des valeurs plus faibles.  Dans les √©chantillons avec des profondeurs de bits plus √©lev√©es, de nombreux nouveaux intervalles avec de grandes valeurs apparaissent; par cons√©quent, la fr√©quence des intervalles plus petits diminue l√©g√®rement.  Tr√®s probablement, le point de pivot, avec une augmentation de la puissance de la liste, se d√©placera vers des valeurs plus grandes.  Quelque part, √† c√¥t√©, se trouve le point d'√©quilibre du graphique, o√π la somme de toutes les valeurs √† droite est approximativement √©gale √† la somme de toutes les valeurs √† gauche. <br></p><p></p><p>  Cette nature int√©ressante de la fr√©quence des intervalles sugg√®re d'abandonner la structure triviale des codes de longueur variable.  Typiquement, une telle structure se compose d'un paquet de bits de diff√©rentes longueurs et fins.  Par exemple, vient d'abord un certain nombre de bits de pr√©fixe d√©finis sur une valeur sp√©cifique, par exemple 0. Il y a un bit d'arr√™t derri√®re eux, qui devrait indiquer l'ach√®vement du pr√©fixe et, par cons√©quent, devrait diff√©rer du pr√©fixe: 1 dans ce cas.  Le pr√©fixe peut ne pas avoir de longueur, c'est-√†-dire que l'√©chantillonnage peut commencer imm√©diatement avec un bit d'arr√™t, d√©terminant ainsi la s√©quence la plus courte.  Le bit d'arr√™t est g√©n√©ralement suivi d'un suffixe, dont la longueur est d√©termin√©e d'une mani√®re pr√©d√©termin√©e par la longueur du pr√©fixe.      ,       ,      ‚Äî        .      ,        -  .    -    (, , - )  ,          . <br></p><p></p><p>              ,   . <br></p><p></p><p> Et ici, une chose plus importante doit √™tre d√©clar√©e.  √Ä premi√®re vue, la cyclicit√© observ√©e implique la division des intervalles en triples: <code>{2,4, <b>6</b> }</code> , <code>{8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> }</code> et ainsi de suite (les valeurs avec la fr√©quence maximale dans chaque triple sont marqu√©es en gras) .  Cependant, en fait, le cycle ici est l√©g√®rement diff√©rent. <br></p><p></p><p>  Je ne citerai pas toute la ligne de raisonnement, qui, en fait, n'est pas l√†: c'√©tait une supposition intuitive, compl√©t√©e par une m√©thode d'√©num√©ration brutale des options, des calculs et des √©chantillons qui prenait plusieurs jours par intermittence.  La cyclicit√© r√©v√©l√©e √† la suite consiste en <b>six</b> intervalles <code>{2,4, <b>6</b> ,8,10, <b>12</b> }</code> , <code>{14,16, <b>18</b> ,20,22, <b>24</b> }</code> , <code>{26,28, <b>30</b> ,32,34, <b>36</b> }</code> et ainsi de suite (les intervalles de fr√©quence maximale sont √† nouveau mis en √©vidence en gras). <br></p><p></p><p>  En un mot, l'algorithme de conditionnement propos√© est le suivant. <br></p><p></p><p>  La division des intervalles en six nombres pairs nous permet de repr√©senter tout intervalle <code>g</code> sous la forme <code>g = i * 12 + t</code> , o√π <code>i</code> est l'indice des six auxquels appartient cet intervalle ( <code>i = {0,1,2,3, ...}</code> ) et <code>t</code> est une queue repr√©sentant l'une des valeurs d'une d√©finition rigide, born√©e et identique pour six quelconques de l'ensemble <code>{2,4,6,8,10,12}</code> .  La r√©ponse en fr√©quence de l'indice mis en √©vidence ci-dessus est presque exactement inversement proportionnelle √† sa valeur, il est donc logique de convertir les six indices en une structure triviale d'un code de longueur variable, dont un exemple est donn√© ci-dessus.  Les caract√©ristiques de fr√©quence de la pince vous permettent de la diviser en deux groupes qui peuvent √™tre encod√©s avec des cha√Ænes de bits de longueurs diff√©rentes: les valeurs 6 et 12, qui sont le plus souvent trouv√©es, sont encod√©es avec un bit, les valeurs 2, 4, 8 et 10, que l'on rencontre beaucoup moins fr√©quemment, sont encod√©es avec deux bits.  Bien s√ªr, un bit de plus est n√©cessaire pour distinguer ces deux options. <br></p><p></p><p>  Un tableau contenant des paquets de bits est compl√©t√© par des champs fixes qui sp√©cifient les valeurs de d√©part des donn√©es pr√©sent√©es dans le bloc, et d'autres quantit√©s n√©cessaires pour restaurer un simple arbitraire ou une s√©quence de simples √† partir des intervalles stock√©s dans le bloc. <br></p><p></p><p>  En plus de cette structure d'index de bloc, l'utilisation de codes de longueur variable est compliqu√©e par les co√ªts suppl√©mentaires par rapport aux intervalles √† bits fixes. <br></p><p></p><p>  Lorsque vous utilisez des intervalles de taille fixe, d√©terminer le bloc dans lequel rechercher un nombre premier par son num√©ro de s√©rie est une t√¢che assez simple, car le nombre d'intervalles par bloc est connu √† l'avance.  Mais la recherche d'une solution simple √† la valeur la plus proche n'a pas de solution directe.  Alternativement, vous pouvez utiliser une formule empirique qui vous permet de trouver le num√©ro de bloc approximatif avec l'intervalle requis, apr√®s quoi vous devrez rechercher le bloc souhait√© par une recherche exhaustive. <br></p><p></p><p>  Pour une table avec des codes de longueur variable, la m√™me approche est requise pour les deux t√¢ches: √† la fois pour r√©cup√©rer une valeur par nombre et pour rechercher par valeur.  Comme la longueur des codes varie, on ne sait jamais √† l'avance combien de diff√©rences sont stock√©es dans un bloc particulier, et dans quel bloc se trouve la valeur souhait√©e.  Il a √©t√© d√©termin√© exp√©rimentalement qu'avec une taille de bloc de 512 octets (qui inclut certains octets d'en-t√™te), la capacit√© du bloc peut aller jusqu'√† 10-12 pour cent de la valeur moyenne.  Des blocs plus petits donnent une dispersion relative encore plus grande.  Dans le m√™me temps, la valeur moyenne de la capacit√© du bloc lui-m√™me a tendance √† diminuer lentement √† mesure que la table grandit.  La s√©lection de formules empiriques pour une d√©termination impr√©cise du bloc initial pour rechercher la valeur souhait√©e √† la fois en nombre et en valeur est une t√¢che non triviale.  Vous pouvez √©galement utiliser une indexation plus complexe et sophistiqu√©e. <br></p><p></p><p>  En fait, c'est tout. <br></p><p></p><p>  Ci-dessous, les subtilit√©s de compression d'une table principale utilisant des codes de longueur variable et les structures qui lui sont associ√©es sont d√©crites de mani√®re plus formelle et d√©taill√©e, et le code des fonctions d'emballage et de d√©ballage des intervalles en C est donn√©. <br></p><p></p><p>  Le r√©sultat. <br></p><p></p><p>  La quantit√© de donn√©es converties du tableau 1TPrimo en codes de longueur variable, compl√©t√©e par une structure d'index de bloc, √©galement d√©crite ci-dessous, s'√©l√®ve √† 26309295104 octets (24,5 Go), c'est-√†-dire que le taux de compression atteint 11,4.  De toute √©vidence, avec l'augmentation de la profondeur de bits, le taux de compression augmentera. <br></p><p></p><p>  Le temps de diffusion de 280 Go de la table 1TPrimo dans le nouveau format √©tait de 1 heure.  C'est le r√©sultat attendu apr√®s des exp√©riences avec des intervalles de compression en entiers √† un octet.  Dans les deux cas, la traduction de la table source se compose principalement d'op√©rations sur les fichiers et ne charge presque pas le processeur (dans le second cas, la charge est toujours plus √©lev√©e en raison de la complexit√© de calcul plus √©lev√©e de l'algorithme).  Le temps d'acc√®s aux donn√©es n'est pas non plus tr√®s diff√©rent des intervalles √† un octet, mais le temps de d√©compresser un bloc complet de la m√™me taille a pris 1,5 Œºs, en raison de la complexit√© plus √©lev√©e de l'algorithme d'extraction des codes de longueur variable. <br></p><p></p><p>  Le tableau (Fig. 10) r√©sume les caract√©ristiques volum√©triques des tableaux de nombres premiers mentionn√©s dans ce texte. <br></p><br><p><br><img src="https://habrastorage.org/webt/dc/jw/6o/dcjw6oz2efm88nqvzolxsz7mx6m.jpeg" alt="fig.10"></p><br><p></p><p><br></p><h3>  Description de l'algorithme de compression </h3><br><h4>  Termes et notation </h4><br>  <code>P (prime): P1=3, P2=5, P3=7 ... Pn, Pn1</code> sont des nombres premiers en fonction de leurs num√©ros de s√©rie.  Encore une fois (et pour la derni√®re fois), je souligne que <code>P0=2</code> est un nombre premier virtuel;  par souci d'uniformit√© formelle, ce nombre est physiquement exclu de la liste des nombres premiers. <br><p></p><p>  <code>G (gap)</code> - l'intervalle entre deux nombres premiers cons√©cutifs <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code>  <code>Gn = Pn1 - Pn; G={2,4,6,8 ...}</code> . <br></p><p></p><p>  <code>D (dense)</code> - r√©duit √† un intervalle de forme monolithique: <code>D = G/2 -1; D={0,1,2,3 ...}</code>  <code>D = G/2 -1; D={0,1,2,3 ...}</code> .  Les six intervalles sous la forme monolithique ressemblent √† <code>{0,1,2,3,4,5}, {6,7,8,9,10,11}, {12,13,14,15,16,17}</code> etc. <br></p><p></p><p>  <code>Q (quotient)</code> - indice des six r√©duit √† une forme monolithique, <code>Q = D div 6; Q={0,1,2,3 ...}</code> <code>Q = D div 6; Q={0,1,2,3 ...}</code> <br></p><p></p><p>  <code>R (remainder)</code> - le reste des six monolithiques <code>R = D mod 6. R</code> toujours une valeur dans la plage <code>{0,1,2,3,4,5}</code> . <br></p><p></p><p>  Les valeurs <code>Q</code> et <code>R</code> obtenues par la m√©thode ci-dessus √† partir de tout intervalle arbitraire <code>G</code> , en raison de leurs caract√©ristiques de fr√©quence stables, sont soumises √† la compression et au stockage sous la forme de paquets de bits de longueur variable, d√©crits ci-dessous.  Les cha√Ænes de bits codant les valeurs <code>Q</code> et <code>R</code> dans un paquet sont cr√©√©es de diff√©rentes mani√®res: pour coder l'index <code>Q</code> , la cha√Æne de bits du pr√©fixe <code>H</code> , le flux <code>F</code> et le bit auxiliaire <code>S</code> , et le groupe de bits de l'infixe <code>X</code> et le bit auxiliaire <code>A</code> sont utilis√©s pour coder le reste <code>R</code> <br></p><p></p><p>  <code>A (arbiter)</code> - un bit qui d√©termine la taille de l'infixe <code>X</code> : 0 - infixe un bit, 1 - deux bits. <br></p><p></p><p>  <code>X (infix)</code> - Infixe √† 1 ou 2 bits, avec le bit d'arbitre <code></code> , d√©terminant mutuellement la valeur de <code>R</code> tabulaire (le tableau montre √©galement la fr√©quence des six premiers avec de tels infixes pour r√©f√©rence): <br></p><br><p><br><img src="https://habrastorage.org/webt/kp/hk/a4/kphka4ymveajnxr8icfzgggln4e.jpeg" alt="infixer les bits"><br><br></p><br><p>  <code>F (fluxion)</code> est une fluxion, une d√©riv√©e de l'indice <code>Q</code> longueur variable <code>L={0,1,2...}</code> , con√ßue pour distinguer la s√©mantique des cha√Ænes de bits <code>(), 0, 00, 000,</code> ou <code>1, 01, 001</code> , etc. d. <br></p><p></p><p>  Une cha√Æne de bits d'unit√©s de longueur <code>L</code> est exprim√©e par <code>2^L - 1</code> (le signe <code>^</code> signifie exponentiation).  En notation C, la m√™me valeur peut √™tre obtenue par l'expression <code>1&lt;&lt;L - 1</code> .  La valeur de fluxia de longueur <code>L</code> peut alors √™tre obtenue √† partir de <code>Q</code> expression <br></p><p></p><p></p><pre> F = Q - (1 &lt;&lt; L - 1),
</pre><p></p><p>  et restaurer <code>Q</code> de fluxia par expression <br></p><p></p><p></p><pre> Q = (1 &lt;&lt; L - 1) + F.
</pre><p></p><p>  Par exemple, pour les quantit√©s <code>Q = {0..15}</code> , les cha√Ænes de bits Fluxia suivantes seront obtenues: <br></p><br><p><br><img src="https://habrastorage.org/webt/j0/kb/4y/j0kb4y3ob_yutugxxvpwlddqofc.jpeg" alt="bits de flux"><br><br></p><br><p>  Les deux derniers champs de bits n√©cessaires pour compresser / restaurer les valeurs sont: <br></p><p></p><p>  <code>H (header)</code> - pr√©fixe, une cha√Æne de bits d√©finie sur 0. <br></p><p></p><p>  <code>S (stop)</code> - bit d'arr√™t mis √† 1, terminant le pr√©fixe. <br></p><p></p><p>  En fait, ces bits sont trait√©s d'abord dans des cha√Ænes de bits, ils vous permettent de d√©terminer lors du d√©ballage ou de d√©finir lors de l'emballage la taille du flux et le d√©but de l'arbitre et des champs de flux - imm√©diatement apr√®s le bit d'arr√™t. <br></p><p></p><p>  <code>W (width)</code> - la largeur de tout le code en bits. <br></p><p></p><p>  La structure compl√®te du paquet de bits est repr√©sent√©e sur la figure 11: <br></p><br><p><br><img src="https://habrastorage.org/webt/ke/7u/tz/ke7utzoka0xkdd9dzzux6yden7e.jpeg" alt="fig.11"><br><br></p><br><p>  Les valeurs de <code>Q</code> et <code>R</code> r√©cup√©r√©es √† partir de ces cha√Ænes nous permettent de restaurer la valeur initiale de l'intervalle: <br></p><p></p><p></p><pre> D = Q * 6 + R,
 G = (D + 1) * 2,
</pre><p></p><p>  et la s√©quence d'intervalles restaur√©s vous permet de restaurer les nombres premiers d'origine √† partir d'une valeur de base donn√©e du bloc (bloc d'intervalles initial) en y ajoutant tous les intervalles de ce bloc en s√©quence. <br></p><p></p><p>  Pour travailler avec des cha√Ænes de bits, une variable enti√®re de 32 bits est utilis√©e, dans laquelle les bits les moins significatifs sont trait√©s et apr√®s les avoir utilis√©s, les bits sont d√©cal√©s vers la gauche lors du compactage ou vers la droite lors du d√©compactage. <br></p><p></p><br><h4>  Structure des blocs </h4><br><p></p><p>  En plus des cha√Ænes de bits, un bloc contient les informations n√©cessaires pour extraire ou ajouter des bits, ainsi que pour d√©terminer le contenu d'un bloc. <br></p><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    typedef unsigned char BYTE; typedef unsigned short WORD; typedef unsigned int LONG; typedef unsigned long long HUGE; typedef int BOOL; #define TRUE 1 #define FALSE 0 #define BLOCKSIZE (256) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ :   , #define HEADSIZE (8+8+2+2+2) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   , #define BODYSIZE (BLOCKSIZE-HEADSIZE) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/           typedef struct { HUGE base; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      HUGE card; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        WORD count; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      WORD delta; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ base+delta =      WORD offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        BYTE body[BODYSIZE]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } crunch_block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   put()  get() crunch_block block; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ NB:  len/val</span></span>  rev/rel     /<span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . static struct tail_t { BYTE len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      S  A BYTE val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,   A  - S BYTE rev; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    BYTE rel; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    } tails[6] = { { 4, 3, 2, 3 }, { 4, 7, 5, 3 }, { 3, 1, 0, 4 }, { 4,11, 1, 4 }, { 4,15, 3, 4 }, { 3, 5, 4, 4 } }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             BOOL put(int gap) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 1.      int Q, R, L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   (),  (),   int val = gap /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; Q = val / <span class="hljs-number"><span class="hljs-number">6</span></span>; R = val % <span class="hljs-number"><span class="hljs-number">6</span></span>; L = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .., <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> val = Q + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (val) { val <span class="hljs-meta"><span class="hljs-meta">&gt;&gt;= </span></span><span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/    L val = Q - (1 &lt;&lt; L) + 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  val &lt;&lt;= tails[R].len; val += tails[R].val; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      val &lt;&lt;= L; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   L += L + tails[R].len; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2.   val  L   buffer   put_index if (block.offset + L &gt; BODYSIZE * 8) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ !      return FALSE; Q = (block.offset /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,      R = block.offset % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.offset += L; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      block.count++; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     block.delta += gap; if (R &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) /<span class="hljs-regexp"><span class="hljs-regexp">/        { val &lt;&lt;= R; val |= block.body[Q]; L += R; } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     L = L /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> + ((L % <span class="hljs-number"><span class="hljs-number">8</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     while (L-- &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { block.body[Q++] = (char)val; val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">8</span></span>; } return TRUE; } /<span class="hljs-regexp"><span class="hljs-regexp">/          int get_index; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int get() { if (get_index &gt;= BODYSIZE * 8) return 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      int val = *((int*)&amp;block.body[get_index /</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>]) &gt;&gt; get_index % <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>   if (val == <span class="hljs-number"><span class="hljs-number">0</span></span>) return -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> !       int Q, R, L, F, M, len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> , , , ,     L = <span class="hljs-number"><span class="hljs-number">0</span></span>; while (!(val &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>)) { val &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; L++; } /<span class="hljs-regexp"><span class="hljs-regexp">/  -     if ((val &amp; 3) == 1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       R = (val &gt;&gt; 2) &amp; 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   else R = ((val &gt;&gt; 2) &amp; 3) + 2; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   len = tails[R].rel; get_index += 2 * L + len; val &gt;&gt;= len; M = ((1 &lt;&lt; L) - 1); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   F = val &amp; M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    Q = F + M; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   return 2 * (1 + (6 * Q + tails[R].rev)); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         }</span></span></code> </pre><br><p></p><br><h4>  Am√©liorations </h4><br><p></p><p>  Si nous alimentons la base d'intervalles obtenue au m√™me archiveur 7 zip, puis en une heure et demie de travail intensif sur un serveur 8 c≈ìurs, il parvient √† compresser le fichier d'entr√©e de pr√®s de 5%.  Autrement dit, dans la base de donn√©es d'intervalles de longueur variable du point de vue de l'archiveur, il y a encore une certaine redondance.  Il y a donc lieu de sp√©culer un peu (dans le bon sens du terme) sur le th√®me de la r√©duction suppl√©mentaire de la redondance des donn√©es. <br></p><p></p><p>  Le d√©terminisme fondamental de la s√©quence d'intervalles entre les nombres premiers permet de faire des calculs exacts de l'efficacit√© de codage par une m√©thode ou une autre.  En particulier, de petits croquis (plut√¥t chaotiques) ont permis de tirer une conclusion fondamentale sur les avantages du codage des six sur les triplets, et sur les avantages de la m√©thode propos√©e sur les codes triviaux de longueur variable (Fig.12): <br></p><br><p><br><img src="https://habrastorage.org/webt/w9/_l/9q/w9_l9qaibojgrxt5izuw4j7lxzc.jpeg" alt="fig.12"><br><br></p><br><p>  Cependant, les hauts ennuyeux du graphique rouge sugg√®rent de mani√®re transparente qu'il peut y avoir d'autres m√©thodes de codage qui rendraient le graphique encore plus doux. <br></p><p></p><p>  Une autre direction sugg√®re de v√©rifier la fr√©quence des intervalles cons√©cutifs.  √Ä partir de consid√©rations g√©n√©rales: √©tant donn√© que les intervalles 6, 12 et 18 sont les plus courants dans une population de nombres premiers, alors ils sont susceptibles d'√™tre plus souvent trouv√©s en paires (doublets), triplets (triplets) et les combinaisons similaires d'intervalles.  Si la r√©p√©tabilit√© des doublons (et peut-√™tre m√™me des triplets ... enfin, tout d'un coup!) S'av√®re statistiquement significative dans la masse totale des intervalles, alors il est logique de les traduire dans un code s√©par√©. <br></p><p></p><p>  L'exp√©rience √† grande √©chelle r√©v√®le une certaine pr√©dominance des doublets individuels sur les autres.  Cependant, si le leadership absolu est attendu pour la paire <code>(6,6)</code> - 1,37% de tous les doublets - alors les autres gagnants de cette note sont beaucoup moins √©vidents: <br></p><p><br><img src="https://habrastorage.org/webt/4m/jq/o-/4mjqo-jyxt27cpw6e6bnasgxl0s.jpeg" alt="statistiques de doublet"><br><br></p><br><p>  Et, comme le doublet <code>(6,6)</code> sym√©trique, et que tous les autres doublets not√©s sont asym√©triques et se retrouvent dans le classement par doubles miroir avec la m√™me fr√©quence, il semble que le record d'enregistrement du doublet <code>(6,6)</code> dans cette s√©rie devrait √™tre divis√© en deux entre les doubles indiscernables <code>(6,6)</code> et <code>(6,6)</code> , ce qui les place √† 0,68% loin de la fronti√®re du palmar√®s.  Et cela confirme une fois de plus l'observation qu'aucune supposition vraie sur les nombres premiers ne peut se produire sans surprises. <br></p><p></p><p>  Les statistiques des triplets d√©montrent √©galement le leadership de ces triplets d'intervalles, qui ne correspondent pas tout √† fait √† l'hypoth√®se sp√©culative partant de la fr√©quence la plus √©lev√©e des intervalles 6, 12, 18. Par ordre d√©croissant de popularit√©, les leaders de fr√©quence parmi les triplets se pr√©sentent comme suit: <br></p><p><br><img src="https://habrastorage.org/webt/nn/if/sw/nnifswq5tugkq5kypoe44qllyj4.jpeg" alt="triple statistique"><br><br></p><p>  etc. <br></p><p></p><p>  Je crains cependant que les r√©sultats de mes sp√©culations int√©ressent moins les programmeurs que les math√©maticiens, peut-√™tre √† cause des corrections inattendues apport√©es par la pratique aux suppositions intuitives.  Il est peu probable qu'il soit possible de tirer un dividende substantiel du pourcentage de fr√©quence mentionn√© en faveur d'une nouvelle augmentation du taux de compression, tandis que la complexit√© de l'algorithme menace de cro√Ætre de mani√®re tr√®s significative. <br></p><p></p><p></p><h4>  Limitations </h4><br><p></p><p>  Il a d√©j√† √©t√© not√© plus haut que l'augmentation de la valeur maximale des intervalles en relation avec la capacit√© des nombres premiers est tr√®s, tr√®s lente.  En particulier, on peut voir sur la figure 6 que l'intervalle entre les nombres premiers qui peuvent √™tre repr√©sent√©s au format d'un entier non sign√© 64 bits sera √©videmment inf√©rieur √† 1600. <br></p><p></p><p>  L'impl√©mentation d√©crite vous permet d'empaqueter et de d√©compresser correctement toutes les valeurs d'intervalle de 18 bits (en fait, la premi√®re erreur d'empaquetage se produit avec un intervalle d'entr√©e de 442358).  Je n'ai pas assez d'imagination pour supposer que la base de donn√©es des intervalles premiers peut atteindre de telles valeurs: au d√©part, elle se situe aux alentours de 100 bits et pour calculer plus pr√©cis√©ment la paresse.  En cas d'incendie, il n'est pas toujours difficile d'√©largir la plage d'intervalles. <br></p><p></p><p>  Merci d'avoir lu cet endroit :) <br></p><br><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417753/">https://habr.com/ru/post/fr417753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417743/index.html">Amplificateurs l√©gendaires - Anatomie de la tendance historique: son du transistor froid</a></li>
<li><a href="../fr417745/index.html">Exp√©rience personnelle: l'ing√©nierie des donn√©es chez Upwork</a></li>
<li><a href="../fr417747/index.html">Re: "Comparaison des frameworks JS: React, Vue et Hyperapp"</a></li>
<li><a href="../fr417749/index.html">Projet Loon en tant que projet commercial: le premier contrat est sign√©</a></li>
<li><a href="../fr417751/index.html">Kunstkamera: E-m√®tre - Appareil de Scientologie pour mesurer les th√©tans</a></li>
<li><a href="../fr417755/index.html">√âtude: 80% des ICO 2017 consid√©r√©es comme frauduleuses</a></li>
<li><a href="../fr417757/index.html">Cr√©ation d'un bot pour participer √† la mini coupe AI. Exp√©rience GPU</a></li>
<li><a href="../fr417759/index.html">Sois mon canard en caoutchouc</a></li>
<li><a href="../fr417761/index.html">GitLab passe d'Azure √† Google Cloud Platform. Nouvelles sur la r√©installation et dates de maintenance</a></li>
<li><a href="../fr417763/index.html">MVIDroid: une revue de la nouvelle biblioth√®que MVI (Model-View-Intent)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>