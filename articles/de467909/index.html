<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕒 ⏹️ 🦑 Chatten Sie unter iOS: Verwenden von Sockets 👨🏾‍🎤 👩🏻‍✈️ 🏔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bild erstellt von rawpixel.com 

 In dieser Veröffentlichung gehen wir auf die TCP-Ebene ein und lernen am Beispiel der Entwicklung einer Chat-Anwendu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chatten Sie unter iOS: Verwenden von Sockets</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467909/"><img src="https://habrastorage.org/webt/dn/dv/gc/dndvgcrra0mv7ipvglf1ywvxdaw.png"><br>  <i>Bild erstellt von rawpixel.com</i> <br><br>  In dieser Veröffentlichung gehen wir auf die TCP-Ebene ein und lernen am Beispiel der Entwicklung einer Chat-Anwendung die Sockets und Tools von Core Foundation kennen. <br><br>  Geschätzte Lesezeit: 25 Minuten. <br><a name="habracut"></a><br><h2>  Warum Steckdosen? </h2><br>  Sie fragen sich vielleicht: "Warum sollte ich eine Stufe niedriger als <b>URLSession gehen</b> ?"  Wenn Sie klug genug sind und diese Frage nicht stellen, fahren Sie direkt mit dem nächsten Abschnitt fort. <br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort für nicht so klug</b> <div class="spoiler_text"> Gute Frage!  Tatsache ist, dass die Verwendung von URLSession auf dem <b>HTTP-Protokoll</b> basiert, dh die Verbindung erfolgt im Stil der <b>Anforderungs-Antwort</b> , ungefähr wie folgt: <br><br><ul><li>  Fordern Sie vom Server einige Daten im JSON-Format an </li><li>  Holen Sie sich diese Daten, verarbeiten, anzeigen, etc. </li></ul><br>  Was aber, wenn wir von sich aus einen Server benötigen, um Daten an Ihre Anwendung zu übertragen?  Hier ist HTTP arbeitslos. <br><br>  Natürlich können wir den Server kontinuierlich ziehen und prüfen, ob Daten für uns vorhanden sind (auch als <b>Polling bezeichnet</b> ).  Oder wir können anspruchsvoller sein und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Langzeitabfragen verwenden</a> .  Aber all diese Krücken sind in diesem Fall etwas ungeeignet. <br><br>  Warum sollten Sie sich schließlich auf das Anforderungs-Antwort-Paradigma beschränken, wenn es etwas weniger als nichts zu unserer Aufgabe passt? <br><br>  In diesem Handbuch erfahren Sie, wie Sie in eine niedrigere Abstraktionsebene <b>eintauchen</b> und <b>SOCKETS</b> direkt in der Chat-Anwendung verwenden. <br><br>  Anstatt den Server auf neue Nachrichten zu überprüfen, verwendet unsere Anwendung Streams, die während der Chat-Sitzung geöffnet bleiben. <br></div></div><br><h2>  Erste Schritte </h2><br>  Laden Sie die <a href="">Quellmaterialien</a> herunter.  Es gibt eine Schein-Client-Anwendung und einen einfachen Server, der in <b>Go geschrieben ist</b> . <br><br>  Sie müssen nicht in Go schreiben, sondern müssen die Serveranwendung ausführen, damit Clientanwendungen eine Verbindung dazu herstellen können. <br><br><h2>  Starten Sie die Serveranwendung </h2><br>  Die Quellmaterialien haben sowohl eine kompilierte Anwendung als auch eine Quelle.  Wenn Sie eine gesunde Paranoia haben und dem kompilierten Code eines anderen nicht vertrauen, können Sie den Quellcode selbst kompilieren. <br><br>  Wenn Sie mutig sind, öffnen Sie <b>Terminal</b> , wechseln Sie in das Verzeichnis mit den heruntergeladenen Materialien und führen Sie den folgenden Befehl aus: <br><br><a name="a1"></a> <code>sudo ./server</code> <br> <br>  Wenn Sie dazu aufgefordert werden, geben Sie Ihr Passwort ein.  Danach sollten Sie eine Nachricht sehen <br><br>  <i>Hören auf 127.0.0.1:80.</i> <br><br><blockquote>  Hinweis: Die Serveranwendung wird im privilegierten Modus (Befehl "sudo") gestartet, da sie Port 80 überwacht. Alle Ports mit Nummern unter 1024 erfordern einen speziellen Zugriff. </blockquote><br>  Ihr Chat-Server ist bereit!  Sie können mit dem nächsten Abschnitt fortfahren. <br><br><div class="spoiler">  <b class="spoiler_title">Wenn Sie den Server-Quellcode selbst kompilieren möchten,</b> <div class="spoiler_text">  In diesem Fall müssen Sie <b>Go</b> mit <b>Homebrew</b> installieren. <br><br>  Wenn Sie kein Homebrew haben, müssen Sie es zuerst installieren.  Öffnen Sie Terminal und fügen Sie dort die folgende Zeile ein: <br><br> <code>/usr/bin/ruby -e \ <br> "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code> <br> <br>  Verwenden Sie dann diesen Befehl, um Go zu installieren: <br><br> <code>brew install go</code> <br> <br>  Wechseln Sie am Ende in das Verzeichnis mit den heruntergeladenen Quellmaterialien und kompilieren Sie den Quellcode der Serveranwendung: <br><br> <code>go build server.go</code> <br> <br>  Schließlich können Sie den Server mit dem Befehl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am Anfang dieses Abschnitts</a> starten. <br></div></div><br><h2>  Wir schauen uns an, was wir im Kunden haben </h2><br>  Öffnen Sie nun das <b>DogeChat-</b> Projekt, kompilieren Sie es und sehen Sie, was da ist. <br><br><img src="https://habrastorage.org/webt/t5/mq/uw/t5mquwzt4dfvbn25cqglbf8sxgy.gif"><br><br>  Wie Sie sehen können, können Sie mit DogeChat jetzt einen Benutzernamen eingeben und zum Chat-Bereich selbst gehen. <br><br>  Es scheint, dass der Entwickler dieses Projekts keine Ahnung hatte, wie man einen Chat macht.  Wir haben also nur eine grundlegende Benutzeroberfläche und Navigation.  Wir werden eine Netzwerkschicht schreiben.  Hurra! <br><br><h2>  Erstellen Sie einen Chatraum </h2><br>  Um direkt zur Entwicklung zu gelangen, gehen Sie zu <b>ChatRoomViewController.swift</b> .  Dies ist ein Ansichts-Controller, der vom Benutzer eingegebenen Text empfangen und empfangene Nachrichten in einer Tabellenansicht anzeigen kann. <br><br>  Da wir einen <b>ChatRoomViewController haben</b> , ist es sinnvoll, eine <b>ChatRoom-</b> Klasse zu entwickeln, die die ganze <b>harte</b> Arbeit <b>erledigt</b> . <br><br>  Lassen Sie uns darüber nachdenken, was die neue Klasse bieten wird: <br><br><ul><li>  Öffnen einer Verbindung zur Serveranwendung; </li><li>  Verbinden eines Benutzers mit dem von ihm angegebenen Namen mit dem Chat; </li><li>  Senden und Empfangen von Nachrichten; </li><li>  Schließen der Verbindung am Ende. </li></ul><br>  Nachdem wir wissen, was wir von dieser Klasse wollen, drücken Sie <b>Befehlstaste</b> <b>-N</b> , wählen Sie <b>Swift File</b> und nennen Sie es <b>ChatRoom</b> . <br><br><h2>  E / A-Streams erstellen </h2><br>  <b>Ersetzen Sie den</b> Inhalt von <b>ChatRoom.swift</b> durch <b>Folgendes</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ChatRoom: NSObject { <span class="hljs-comment"><span class="hljs-comment">//1 var inputStream: InputStream! var outputStream: OutputStream! //2 var username = "" //3 let maxReadLength = 4096 }</span></span></code> </pre> <br>  Hier definieren wir die <b>ChatRoom-</b> Klasse und deklarieren die Eigenschaften, die wir benötigen. <br><br><ol><li>  Zuerst definieren wir die Eingabe- / Ausgabestreams.  Wenn wir sie als Paar verwenden, können wir eine Socket-Verbindung zwischen der Anwendung und dem Chat-Server herstellen.  Natürlich werden wir Nachrichten über den Ausgabestream senden und über den Eingabestream empfangen. </li><li>  Als nächstes definieren wir den Benutzernamen. </li><li>  Und schließlich definieren wir die Variable maxReadLength, die die maximale Länge einer einzelnen Nachricht begrenzt. </li></ol><br>  Gehen Sie nun zur Datei <b>ChatRoomViewController.swift</b> und fügen Sie diese Zeile zur Liste ihrer Eigenschaften hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chatRoom = <span class="hljs-type"><span class="hljs-type">ChatRoom</span></span>()</code> </pre> <br>  Nachdem wir die Grundstruktur der Klasse erstellt haben, ist es Zeit, die erste der geplanten Aufgaben zu erledigen: die Verbindung zwischen der Anwendung und dem Server zu öffnen. <br><br><h2>  Verbindung öffnen </h2><br>  Wir kehren zu ChatRoom.swift zurück und fügen diese Methode für Eigenschaftsdefinitionen hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupNetworkCommunication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 var readStream: Unmanaged&lt;CFReadStream&gt;? var writeStream: Unmanaged&lt;CFWriteStream&gt;? // 2 CFStreamCreatePairWithSocketToHost(kCFAllocatorDefault, "localhost" as CFString, 80, &amp;readStream, &amp;writeStream) }</span></span></code> </pre> <br>  Folgendes machen wir hier: <br><br><ol><li>  Zuerst definieren wir zwei Variablen für Socket-Streams ohne automatische Speicherverwaltung </li><li>  Dann erstellen wir unter Verwendung derselben Variablen direkt Streams, die an die Host- und Portnummer gebunden sind. </li></ol><br>  Die Funktion hat vier Argumente.  Der erste ist der Typ des Speicherzuordners, den wir beim Initialisieren der Threads verwenden.  Sie sollten <b>kCFAllocatorDefault verwenden</b> , obwohl es andere mögliche Optionen gibt, falls Sie das Verhalten der Threads ändern möchten. <br><br><div class="spoiler">  <b class="spoiler_title">Anmerkung des Übersetzers</b> <div class="spoiler_text">  In der Dokumentation zur Funktion <b>CFStreamCreatePairWithSocketToHost</b> heißt es: Verwenden Sie <b>NULL</b> oder <b>kCFAllocatorDefault</b> .  Und die Beschreibung von <b>kCFAllocatorDefault</b> besagt, dass es ein Synonym für <b>NULL ist</b> .  Der Kreis ist geschlossen! <br></div></div><br>  Dann setzen wir den Hostnamen.  In unserem Fall stellen wir eine Verbindung zum lokalen Server her.  Befindet sich Ihr Server an einem anderen Ort, können Sie seine IP-Adresse festlegen. <br><br>  Dann die Portnummer, die der Server abhört. <br><br>  Schließlich übergeben wir Zeiger an unsere E / A-Streams, damit die Funktion sie initialisieren und mit den von ihr erstellten Streams verbinden kann. <br><br>  Nachdem wir die initialisierten Flows haben, können wir Links zu ihnen speichern, indem wir diese Zeilen am Ende der <b>setupNetworkCommunication ()</b> -Methode <b>hinzufügen</b> : <br><br><pre> <code class="swift hljs">inputStream = readStream!.takeRetainedValue() outputStream = writeStream!.takeRetainedValue()</code> </pre> <br>  Durch die Verwendung von <b>takeRetainedValue (),</b> wie es auf ein nicht verwaltetes Objekt angewendet wird, können wir einen Verweis darauf beibehalten und gleichzeitig zukünftige Speicherverluste vermeiden.  Jetzt können wir unsere Threads verwenden, wo immer wir wollen. <br><br>  Jetzt müssen wir diese Threads zur <b>Ausführungsschleife</b> hinzufügen, damit unsere Anwendung Netzwerkereignisse korrekt verarbeitet.  <b>Fügen</b> Sie dazu diese beiden Zeilen am Ende von <b>setupNetworkCommunication () hinzu</b> : <br><br><pre> <code class="swift hljs">inputStream.schedule(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .current, forMode: .common) outputStream.schedule(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .current, forMode: .common)</code> </pre> <br>  Endlich ist es Zeit zu segeln!  <b>Fügen</b> Sie dies zunächst ganz am Ende der <b>setupNetworkCommunication ()</b> -Methode hinzu: <br><br><pre> <code class="swift hljs">inputStream.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>() outputStream.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>()</code> </pre> <br>  Jetzt haben wir eine offene Verbindung zwischen unserer Client- und Serveranwendung. <br><br>  Wir können unsere Anwendung kompilieren und ausführen, aber Sie werden noch keine Änderungen sehen, da wir mit unserer Client-Server-Verbindung nichts anfangen. <br><br><h2>  Verbindung zum Chat herstellen </h2><br>  Nachdem wir eine Verbindung zum Server hergestellt haben, ist es Zeit, etwas dagegen zu unternehmen!  Im Falle eines Chats müssen Sie sich zuerst vorstellen und können dann Nachrichten an die Gesprächspartner senden. <br><br>  Dies führt uns zu einer wichtigen Schlussfolgerung: Da wir zwei Arten von Nachrichten haben, müssen wir sie irgendwie unterscheiden. <br><br><h2>  Chat-Protokoll </h2><br>  Einer der Vorteile der Verwendung der TCP-Schicht besteht darin, dass wir unser eigenes „Protokoll“ für die Kommunikation definieren können. <br><br>  Wenn wir HTTP verwenden würden, müssten wir diese verschiedenen Wörter <b>GET</b> , <b>PUT</b> , <b>PATCH verwenden</b> .  Wir müssten URLs bilden und die richtigen Header und all das verwenden. <br><br>  Wir haben nur zwei Arten von Nachrichten.  Wir werden senden <br><br> <code>iam:Luke</code> <br> <br>  um in den Chat einzutreten und sich vorzustellen. <br><br>  Und wir werden senden <br><br> <code>msg:Hey, how goes it, man?</code> <br> <br>  um eine Chat-Nachricht an alle Befragten zu senden. <br><br>  Es ist sehr einfach, aber absolut prinzipienlos. Verwenden Sie diese Methode daher nicht in kritischen Projekten. <br><br>  Jetzt wissen wir, was unser Server erwartet, und können eine Methode in die <b>ChatRoom-</b> Klasse schreiben, mit der der Benutzer eine Verbindung zum Chat herstellen kann.  Das einzige Argument ist der Spitzname des Benutzers. <br><br>  Fügen Sie diese Methode in <b>ChatRoom.swift hinzu</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">joinChat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(username: String)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 let data = "iam:\(username)".data(using: .utf8)! //2 self.username = username //3 _ = data.withUnsafeBytes { guard let pointer = $0.baseAddress?.assumingMemoryBound(to: UInt8.self) else { print("Error joining chat") return } //4 outputStream.write(pointer, maxLength: data.count) } }</span></span></code> </pre> <br><ol><li>  Zuerst bilden wir unsere Nachricht mit unserem eigenen „Protokoll“. </li><li>  Speichern Sie den Namen zur späteren Bezugnahme. </li><li>  <b>withUnsafeBytes (_ :)</b> bietet eine bequeme Möglichkeit, mit einem unsicheren Zeiger in einem Abschluss zu arbeiten. </li><li>  Schließlich senden wir unsere Nachricht an den Ausgabestream.  Dies sieht möglicherweise komplizierter aus als erwartet. Write (_: maxLength :) verwendet jedoch den im vorherigen Schritt erstellten unsicheren Zeiger. </li></ol><br>  Jetzt ist unsere Methode fertig, öffnen Sie <b>ChatRoomViewController.swift</b> und fügen Sie dieser Methode am Ende von <b>viewWillAppear (_ :)</b> einen Aufruf hinzu. <br><br><pre> <code class="swift hljs">chatRoom.joinChat(username: username)</code> </pre> <br>  Kompilieren Sie nun die Anwendung und führen Sie sie aus.  Geben Sie Ihren Spitznamen ein und tippen Sie auf Zurück, um zu sehen ... <br><br><img src="https://habrastorage.org/webt/t5/mq/uw/t5mquwzt4dfvbn25cqglbf8sxgy.gif"><br><br>  ... <b>dass sich wieder nichts geändert hat!</b> <br><br>  Warten Sie, es ist alles in Ordnung!  Gehen Sie zum Terminalfenster.  Dort sehen Sie die Nachricht, der <b>Vasya beigetreten ist</b> oder so, wenn Sie nicht Vasya heißen. <br><br>  Das ist großartig, aber es wäre schön, wenn auf dem Bildschirm Ihres Telefons ein Hinweis auf eine erfolgreiche Verbindung angezeigt würde. <br><br><h2>  Antworten auf eingehende Nachrichten </h2><br>  Der Server sendet Client-Beitrittsnachrichten an alle Mitglieder des Chats, einschließlich Sie.  Glücklicherweise verfügt unsere Anwendung bereits über alles, um eingehende Nachrichten in Form von Zellen in der Nachrichtentabelle in <b>ChatRoomViewController anzuzeigen</b> . <br><br>  Sie müssen <b>lediglich inputStream verwenden</b> , um diese Nachrichten zu „fangen“, sie in Instanzen der <b>Message-</b> Klasse zu konvertieren und sie zur Anzeige an die Tabelle zu übergeben. <br><br>  Um auf eingehende Nachrichten antworten zu können, benötigen Sie <b>ChatRoom</b> , <b>um</b> das <b>StreamDelegate-</b> Protokoll <b>einzuhalten</b> . <br><br>  <b>Fügen</b> Sie dazu diese Erweiterung am Ende der Datei <b>ChatRoom.swift hinzu</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoom</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamDelegate</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Geben Sie nun an, wer Delegierter von inputStream werden soll. <br><br>  Fügen Sie diese Zeile der setupNetworkCommunication () -Methode unmittelbar vor den aufzurufenden Aufrufen hinzu (in: forMode :): <br><br><pre> <code class="swift hljs">inputStream.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  Fügen Sie nun die Implementierung der Stream-Methode (_: handle :) zur Erweiterung hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStream: Stream, handle eventCode: Stream.Event)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> eventCode { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .hasBytesAvailable: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"new message received"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .endEncountered: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"The end of the stream has been reached."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .errorOccurred: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"error occurred"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .hasSpaceAvailable: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"has space available"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"some other event..."</span></span>) } }</code> </pre> <br><h2>  Wir verarbeiten eingehende Nachrichten </h2><br>  Wir sind also bereit, eingehende Nachrichten zu verarbeiten.  Das Ereignis, das uns interessiert, ist <b>.hasBytesAvailable</b> , was darauf hinweist, dass eine eingehende Nachricht eingetroffen ist. <br><br>  Wir werden eine Methode schreiben, die diese Nachrichten verarbeitet.  Unterhalb der neu hinzugefügten Methode schreiben wir Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readAvailableBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stream: InputStream)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 let buffer = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: maxReadLength) //2 while stream.hasBytesAvailable { //3 let numberOfBytesRead = inputStream.read(buffer, maxLength: maxReadLength) //4 if numberOfBytesRead &lt; 0, let error = stream.streamError { print(error) break } // Construct the Message object } }</span></span></code> </pre> <br><ol><li>  Wir legen den Puffer fest, in dem die eingehenden Bytes gelesen werden. </li><li>  Wir drehen uns in einer Schleife, während im Eingabestream etwas zu lesen ist. </li><li>  Wir rufen read (_: maxLength :) auf, das die Bytes aus dem Stream liest und in den Puffer legt. </li><li>  Wenn der Aufruf einen negativen Wert zurückgibt, geben wir einen Fehler zurück und verlassen die Schleife. </li></ol><br>  Wir müssen diese Methode aufrufen, sobald wir Daten im eingehenden Stream haben. Gehen Sie also zur <b>switch-Anweisung</b> in der <b>stream-</b> Methode <b>(_: handle :)</b> , suchen Sie den Schalter <b>.hasBytesAvailable</b> und rufen Sie diese Methode unmittelbar nach der print-Anweisung auf: <br><br><pre> <code class="swift hljs">readAvailableBytes(stream: aStream <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">InputStream</span></span>)</code> </pre> <br>  An dieser Stelle haben wir einen vorbereiteten Puffer mit empfangenen Daten! <br><br>  Wir müssen diesen Puffer jedoch noch in den Inhalt der Nachrichtentabelle umwandeln. <br><br>  Platzieren Sie diese Methode auf <b>readAvailableBytes (stream :)</b> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processedMessageString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buffer: UnsafeMutablePointer&lt;UInt8&gt;, length: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Message?</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 guard let stringArray = String( bytesNoCopy: buffer, length: length, encoding: .utf8, freeWhenDone: true)?.components(separatedBy: ":"), let name = stringArray.first, let message = stringArray.last else { return nil } //2 let messageSender: MessageSender = (name == self.username) ? .ourself : .someoneElse //3 return Message(message: message, messageSender: messageSender, username: name) }</span></span></code> </pre> <br>  Zuerst initialisieren wir String mit dem Puffer und der Größe, die wir an diese Methode übergeben. <br><br>  Der Text befindet sich in UTF-8. Am Ende wird der Puffer freigegeben und die Nachricht durch das Symbol ':' geteilt, um den Namen des Absenders und die Nachricht selbst zu trennen. <br><br>  Jetzt analysieren wir, ob diese Nachricht von einem anderen Teilnehmer stammt.  Auf dem Produkt können Sie so etwas wie ein einzigartiges Token erstellen. Dies reicht für die Demo aus. <br><br>  Schließlich bilden wir aus all dieser Wirtschaft eine Instanz der Botschaft und geben sie zurück. <br><br>  Um diese Methode zu verwenden, fügen Sie unmittelbar nach dem letzten Kommentar das folgende <b>if-let</b> am Ende der <b>while-Schleife</b> in die Methode <b>readAvailableBytes (stream :) ein</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = processedMessageString(buffer: buffer, length: numberOfBytesRead) { <span class="hljs-comment"><span class="hljs-comment">// Notify interested parties }</span></span></code> </pre> <br>  Jetzt ist alles bereit, an jemanden weiterzugeben. <b>Nachricht</b> ... Aber an wen? <br><br><h2>  Erstellen Sie das ChatRoomDelegate-Protokoll </h2><br>  Wir müssen <b>ChatRoomViewController.swift</b> über die neue Nachricht informieren, haben jedoch keinen Link dazu.  Da es einen starken <b>ChatRoom-</b> Link enthält, können wir in die Falle eines starken <b>Linkzyklus geraten</b> . <br><br>  Dies ist der perfekte Ort, um ein Delegatenprotokoll zu erstellen.  ChatRoom ist es egal, wer über neue Beiträge Bescheid wissen muss. <br><br>  <b>Fügen Sie</b> oben in <b>ChatRoom.swift</b> eine neue Protokolldefinition hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomDelegate</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">received</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: Message)</span></span></span></span> }</code> </pre> <br>  <b>Fügen Sie</b> nun in der <b>ChatRoom-</b> Klasse ein schwaches Glied hinzu, um zu speichern, wer der Delegat wird: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delegate: <span class="hljs-type"><span class="hljs-type">ChatRoomDelegate?</span></span></code> </pre> <br>  <b>Fügen</b> wir nun die Methode <b>readAvailableBytes (stream :)</b> hinzu und fügen die folgende Zeile innerhalb des if-let-Konstrukts unter dem letzten Kommentar in der Methode hinzu: <br><br><pre> <code class="swift hljs">delegate?.received(message: message)</code> </pre> <br>  <b>Kehren</b> Sie zu <b>ChatRoomViewController.swift zurück</b> und fügen Sie unmittelbar nach MessageInputDelegate die folgende Klassenerweiterung hinzu, die die Einhaltung des <b>ChatRoomDelegate-</b> Protokolls sicherstellt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">received</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: Message)</span></span></span></span> { insertNewMessageCell(message) } }</code> </pre> <br>  Das ursprüngliche Projekt enthält bereits die erforderlichen <b>Informationen. InsertNewMessageCell (_ :)</b> akzeptiert Ihre Nachricht und zeigt die richtige Zelle in der Tabellenansicht an. <br><br>  <b>Weisen Sie</b> nun den View Controller als Delegaten zu, indem Sie diesen unmittelbar nach dem Aufruf von super.viewWillAppear () zu <b>viewWillAppear (_ :)</b> hinzufügen. <br><br><pre> <code class="swift hljs">chatRoom.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  Kompilieren Sie nun die Anwendung und führen Sie sie aus.  Geben Sie einen Namen ein und tippen Sie auf Zurück. <br><br><img src="https://habrastorage.org/webt/km/21/ed/km21ed-ey4avyntpx53si6oqbra.gif"><br><br>  Sie sehen eine Zelle über Ihre Verbindung zum Chat.  Hurra, Sie haben erfolgreich eine Nachricht an den Server gesendet und eine Antwort von ihm erhalten! <br><br><h2>  Nachrichten posten </h2><br>  Jetzt, da ChatRoom Nachrichten senden und empfangen kann, ist es Zeit, dem Benutzer die Möglichkeit zu geben, seine eigenen Phrasen zu senden. <br><br>  <b>Fügen Sie</b> in <b>ChatRoom.swift</b> am Ende der Klassendefinition die folgende Methode hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: String)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-string"><span class="hljs-string">"msg:\(message)"</span></span>.data(using: .utf8)! <span class="hljs-number"><span class="hljs-number">_</span></span> = data.withUnsafeBytes { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pointer = $<span class="hljs-number"><span class="hljs-number">0</span></span>.baseAddress?.assumingMemoryBound(to: <span class="hljs-type"><span class="hljs-type">UInt8</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Error joining chat"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } outputStream.write(pointer, maxLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>) } }</code> </pre> <br>  Diese Methode ähnelt <b>joinChat (Benutzername :)</b> , den wir zuvor geschrieben haben, außer dass das <b>msg-</b> Präfix vor dem Text steht (um anzuzeigen, dass es sich um eine echte Chat-Nachricht handelt). <br><br>  Da wir Nachrichten über die Schaltfläche <b>Senden</b> senden möchten, kehren wir zu <b>ChatRoomViewController.swift zurück</b> und finden dort <b>MessageInputDelegate</b> . <br><br>  Hier sehen wir die leere Methode <b>sendWasTapped (message :)</b> .  Um eine Nachricht zu senden, senden Sie sie an chatRoom: <br><br><pre> <code class="swift hljs">chatRoom.send(message: message)</code> </pre> <br>  Eigentlich ist das alles!  Da der Server die Nachricht empfängt und an alle weiterleitet, wird ChatRoom über die neue Nachricht auf die gleiche Weise benachrichtigt wie beim Beitritt zum Chat. <br><br>  Kompilieren Sie die Anwendung und führen Sie sie aus. <br><br><img src="https://habrastorage.org/webt/i6/e6/r1/i6e6r1tzjl-2r1ekzdk5gvplbsq.gif"><br><br>  Wenn Sie noch niemanden zum Chatten haben, öffnen Sie ein neues Terminalfenster und geben Sie Folgendes ein: <br><br> <code>nc localhost 80</code> <br> <br>  Dadurch werden Sie mit dem Server verbunden.  Jetzt können Sie mit demselben "Protokoll" eine Verbindung zum Chat herstellen: <br><br> <code>iam:gregg</code> <br> <br>  Und so - senden Sie eine Nachricht: <br><br> <code>msg:Ay mang, wut's good?</code> <br> <br><img src="https://habrastorage.org/webt/qm/5e/_l/qm5e_l4wi4a0_whqffyzbmeyqzs.gif"><br><br>  Herzlichen Glückwunsch, Sie haben einen Kunden für den Chat geschrieben! <br><br><h2>  Wir reinigen uns </h2><br>  Wenn Sie jemals Anwendungen entwickelt haben, die Dateien aktiv lesen / schreiben, sollten Sie wissen, dass gute Entwickler Dateien schließen, wenn sie mit ihnen fertig sind.  Tatsache ist, dass die Verbindung über den Socket vom Dateideskriptor bereitgestellt wird.  Dies bedeutet, dass Sie es nach Abschluss der Arbeiten wie jede andere Datei schließen müssen. <br><br>  <b>Fügen Sie</b> dazu <b>ChatRoom.swift</b> die folgende Methode <b>hinzu,</b> nachdem Sie <b>send (message :) definiert haben</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopChatSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { inputStream.close() outputStream.close() }</code> </pre><br>  Wie Sie wahrscheinlich vermutet haben, schließt diese Methode Threads, sodass Sie keine Nachrichten mehr empfangen und senden können.  Außerdem werden Threads aus der <b>Ausführungsschleife entfernt,</b> in der wir sie zuvor platziert haben. <br><br>  Fügen Sie dieser Methode im Abschnitt <b>.endEncountered</b> der <b>switch-Anweisung</b> im <b>Stream</b> einen Aufruf hinzu <b>(_: handle :)</b> : <br><br><pre> <code class="swift hljs">stopChatSession()</code> </pre> <br>  Gehen Sie dann zurück zu <b>ChatRoomViewController.swift</b> und machen Sie dasselbe in <b>viewWillDisappear (_ :)</b> : <br><br><pre> <code class="swift hljs">chatRoom.stopChatSession()</code> </pre> <br>  Das ist alles!  Jetzt sicher! <br><br><h2>  Fazit </h2><br>  Nachdem Sie die Grundlagen der Vernetzung mit Sockets beherrschen, können Sie Ihr Wissen vertiefen. <br><br><h4>  UDP-Sockets </h4><br>  Diese Anwendung ist ein Beispiel für die Netzwerkkommunikation mit TCP, die die Zustellung von Paketen an das Ziel garantiert. <br><br>  Sie können jedoch UDP-Sockets verwenden.  Diese Art der Verbindung garantiert nicht die Lieferung von Paketen zu ihrem beabsichtigten Zweck, ist jedoch viel schneller. <br><br>  Dies ist besonders nützlich in Spielen.  Schon mal eine Verzögerung erlebt?  Dies bedeutete, dass Sie eine schlechte Verbindung hatten und viele UDP-Pakete verloren gingen. <br><br><h4>  Websockets </h4><br>  Eine weitere Alternative zu HTTP in Anwendungen ist eine Technologie namens Web Sockets. <br><br>  Im Gegensatz zu normalen TCP-Sockets verwenden Web-Sockets HTTP, um die Kommunikation herzustellen.  Mit ihrer Hilfe können Sie dasselbe erreichen wie mit normalen Steckdosen, jedoch mit Komfort und Sicherheit, wie in einem Browser. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467909/">https://habr.com/ru/post/de467909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467897/index.html">Autotest-Tools, Yandex Mapkit 3-Integration, cooles Design und Server Driven UI-Ansatz - Android Mitap-Ankündigung</a></li>
<li><a href="../de467901/index.html">Widerlegen Sie vier Stereotypen über die Programmiersprache Rust</a></li>
<li><a href="../de467903/index.html">Top 20 Navigationsfunktionen bei IntelliJ IDEA. Teil 1</a></li>
<li><a href="../de467905/index.html">Wie wir in Cloud Mail.ru Meilensteine ​​erkannt haben und warum</a></li>
<li><a href="../de467907/index.html">Vor- und Nachteile des Outsourcings</a></li>
<li><a href="../de467913/index.html">Wie man das „Bastard-Mineral“ oder die neue Schnittstelle für das Solarpanel verbessert</a></li>
<li><a href="../de467915/index.html">Überwachung von Postgres in Openshift</a></li>
<li><a href="../de467917/index.html">Verwaltungsvorlagen</a></li>
<li><a href="../de467921/index.html">Nehmen Sie staubige Stifte heraus: Handschrift ist gut für das Gehirn</a></li>
<li><a href="../de467923/index.html">Sie möchten also Analyst im Bereich Netzwerksicherheit werden ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>