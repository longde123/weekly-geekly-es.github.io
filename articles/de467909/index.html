<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïí ‚èπÔ∏è ü¶ë Chatten Sie unter iOS: Verwenden von Sockets üë®üèæ‚Äçüé§ üë©üèª‚Äç‚úàÔ∏è üèîÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bild erstellt von rawpixel.com 

 In dieser Ver√∂ffentlichung gehen wir auf die TCP-Ebene ein und lernen am Beispiel der Entwicklung einer Chat-Anwendu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chatten Sie unter iOS: Verwenden von Sockets</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467909/"><img src="https://habrastorage.org/webt/dn/dv/gc/dndvgcrra0mv7ipvglf1ywvxdaw.png"><br>  <i>Bild erstellt von rawpixel.com</i> <br><br>  In dieser Ver√∂ffentlichung gehen wir auf die TCP-Ebene ein und lernen am Beispiel der Entwicklung einer Chat-Anwendung die Sockets und Tools von Core Foundation kennen. <br><br>  Gesch√§tzte Lesezeit: 25 Minuten. <br><a name="habracut"></a><br><h2>  Warum Steckdosen? </h2><br>  Sie fragen sich vielleicht: "Warum sollte ich eine Stufe niedriger als <b>URLSession gehen</b> ?"  Wenn Sie klug genug sind und diese Frage nicht stellen, fahren Sie direkt mit dem n√§chsten Abschnitt fort. <br><br><div class="spoiler">  <b class="spoiler_title">Die Antwort f√ºr nicht so klug</b> <div class="spoiler_text"> Gute Frage!  Tatsache ist, dass die Verwendung von URLSession auf dem <b>HTTP-Protokoll</b> basiert, dh die Verbindung erfolgt im Stil der <b>Anforderungs-Antwort</b> , ungef√§hr wie folgt: <br><br><ul><li>  Fordern Sie vom Server einige Daten im JSON-Format an </li><li>  Holen Sie sich diese Daten, verarbeiten, anzeigen, etc. </li></ul><br>  Was aber, wenn wir von sich aus einen Server ben√∂tigen, um Daten an Ihre Anwendung zu √ºbertragen?  Hier ist HTTP arbeitslos. <br><br>  Nat√ºrlich k√∂nnen wir den Server kontinuierlich ziehen und pr√ºfen, ob Daten f√ºr uns vorhanden sind (auch als <b>Polling bezeichnet</b> ).  Oder wir k√∂nnen anspruchsvoller sein und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Langzeitabfragen verwenden</a> .  Aber all diese Kr√ºcken sind in diesem Fall etwas ungeeignet. <br><br>  Warum sollten Sie sich schlie√ülich auf das Anforderungs-Antwort-Paradigma beschr√§nken, wenn es etwas weniger als nichts zu unserer Aufgabe passt? <br><br>  In diesem Handbuch erfahren Sie, wie Sie in eine niedrigere Abstraktionsebene <b>eintauchen</b> und <b>SOCKETS</b> direkt in der Chat-Anwendung verwenden. <br><br>  Anstatt den Server auf neue Nachrichten zu √ºberpr√ºfen, verwendet unsere Anwendung Streams, die w√§hrend der Chat-Sitzung ge√∂ffnet bleiben. <br></div></div><br><h2>  Erste Schritte </h2><br>  Laden Sie die <a href="">Quellmaterialien</a> herunter.  Es gibt eine Schein-Client-Anwendung und einen einfachen Server, der in <b>Go geschrieben ist</b> . <br><br>  Sie m√ºssen nicht in Go schreiben, sondern m√ºssen die Serveranwendung ausf√ºhren, damit Clientanwendungen eine Verbindung dazu herstellen k√∂nnen. <br><br><h2>  Starten Sie die Serveranwendung </h2><br>  Die Quellmaterialien haben sowohl eine kompilierte Anwendung als auch eine Quelle.  Wenn Sie eine gesunde Paranoia haben und dem kompilierten Code eines anderen nicht vertrauen, k√∂nnen Sie den Quellcode selbst kompilieren. <br><br>  Wenn Sie mutig sind, √∂ffnen Sie <b>Terminal</b> , wechseln Sie in das Verzeichnis mit den heruntergeladenen Materialien und f√ºhren Sie den folgenden Befehl aus: <br><br><a name="a1"></a> <code>sudo ./server</code> <br> <br>  Wenn Sie dazu aufgefordert werden, geben Sie Ihr Passwort ein.  Danach sollten Sie eine Nachricht sehen <br><br>  <i>H√∂ren auf 127.0.0.1:80.</i> <br><br><blockquote>  Hinweis: Die Serveranwendung wird im privilegierten Modus (Befehl "sudo") gestartet, da sie Port 80 √ºberwacht. Alle Ports mit Nummern unter 1024 erfordern einen speziellen Zugriff. </blockquote><br>  Ihr Chat-Server ist bereit!  Sie k√∂nnen mit dem n√§chsten Abschnitt fortfahren. <br><br><div class="spoiler">  <b class="spoiler_title">Wenn Sie den Server-Quellcode selbst kompilieren m√∂chten,</b> <div class="spoiler_text">  In diesem Fall m√ºssen Sie <b>Go</b> mit <b>Homebrew</b> installieren. <br><br>  Wenn Sie kein Homebrew haben, m√ºssen Sie es zuerst installieren.  √ñffnen Sie Terminal und f√ºgen Sie dort die folgende Zeile ein: <br><br> <code>/usr/bin/ruby -e \ <br> "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</code> <br> <br>  Verwenden Sie dann diesen Befehl, um Go zu installieren: <br><br> <code>brew install go</code> <br> <br>  Wechseln Sie am Ende in das Verzeichnis mit den heruntergeladenen Quellmaterialien und kompilieren Sie den Quellcode der Serveranwendung: <br><br> <code>go build server.go</code> <br> <br>  Schlie√ülich k√∂nnen Sie den Server mit dem Befehl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">am Anfang dieses Abschnitts</a> starten. <br></div></div><br><h2>  Wir schauen uns an, was wir im Kunden haben </h2><br>  √ñffnen Sie nun das <b>DogeChat-</b> Projekt, kompilieren Sie es und sehen Sie, was da ist. <br><br><img src="https://habrastorage.org/webt/t5/mq/uw/t5mquwzt4dfvbn25cqglbf8sxgy.gif"><br><br>  Wie Sie sehen k√∂nnen, k√∂nnen Sie mit DogeChat jetzt einen Benutzernamen eingeben und zum Chat-Bereich selbst gehen. <br><br>  Es scheint, dass der Entwickler dieses Projekts keine Ahnung hatte, wie man einen Chat macht.  Wir haben also nur eine grundlegende Benutzeroberfl√§che und Navigation.  Wir werden eine Netzwerkschicht schreiben.  Hurra! <br><br><h2>  Erstellen Sie einen Chatraum </h2><br>  Um direkt zur Entwicklung zu gelangen, gehen Sie zu <b>ChatRoomViewController.swift</b> .  Dies ist ein Ansichts-Controller, der vom Benutzer eingegebenen Text empfangen und empfangene Nachrichten in einer Tabellenansicht anzeigen kann. <br><br>  Da wir einen <b>ChatRoomViewController haben</b> , ist es sinnvoll, eine <b>ChatRoom-</b> Klasse zu entwickeln, die die ganze <b>harte</b> Arbeit <b>erledigt</b> . <br><br>  Lassen Sie uns dar√ºber nachdenken, was die neue Klasse bieten wird: <br><br><ul><li>  √ñffnen einer Verbindung zur Serveranwendung; </li><li>  Verbinden eines Benutzers mit dem von ihm angegebenen Namen mit dem Chat; </li><li>  Senden und Empfangen von Nachrichten; </li><li>  Schlie√üen der Verbindung am Ende. </li></ul><br>  Nachdem wir wissen, was wir von dieser Klasse wollen, dr√ºcken Sie <b>Befehlstaste</b> <b>-N</b> , w√§hlen Sie <b>Swift File</b> und nennen Sie es <b>ChatRoom</b> . <br><br><h2>  E / A-Streams erstellen </h2><br>  <b>Ersetzen Sie den</b> Inhalt von <b>ChatRoom.swift</b> durch <b>Folgendes</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit class ChatRoom: NSObject { <span class="hljs-comment"><span class="hljs-comment">//1 var inputStream: InputStream! var outputStream: OutputStream! //2 var username = "" //3 let maxReadLength = 4096 }</span></span></code> </pre> <br>  Hier definieren wir die <b>ChatRoom-</b> Klasse und deklarieren die Eigenschaften, die wir ben√∂tigen. <br><br><ol><li>  Zuerst definieren wir die Eingabe- / Ausgabestreams.  Wenn wir sie als Paar verwenden, k√∂nnen wir eine Socket-Verbindung zwischen der Anwendung und dem Chat-Server herstellen.  Nat√ºrlich werden wir Nachrichten √ºber den Ausgabestream senden und √ºber den Eingabestream empfangen. </li><li>  Als n√§chstes definieren wir den Benutzernamen. </li><li>  Und schlie√ülich definieren wir die Variable maxReadLength, die die maximale L√§nge einer einzelnen Nachricht begrenzt. </li></ol><br>  Gehen Sie nun zur Datei <b>ChatRoomViewController.swift</b> und f√ºgen Sie diese Zeile zur Liste ihrer Eigenschaften hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chatRoom = <span class="hljs-type"><span class="hljs-type">ChatRoom</span></span>()</code> </pre> <br>  Nachdem wir die Grundstruktur der Klasse erstellt haben, ist es Zeit, die erste der geplanten Aufgaben zu erledigen: die Verbindung zwischen der Anwendung und dem Server zu √∂ffnen. <br><br><h2>  Verbindung √∂ffnen </h2><br>  Wir kehren zu ChatRoom.swift zur√ºck und f√ºgen diese Methode f√ºr Eigenschaftsdefinitionen hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupNetworkCommunication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 var readStream: Unmanaged&lt;CFReadStream&gt;? var writeStream: Unmanaged&lt;CFWriteStream&gt;? // 2 CFStreamCreatePairWithSocketToHost(kCFAllocatorDefault, "localhost" as CFString, 80, &amp;readStream, &amp;writeStream) }</span></span></code> </pre> <br>  Folgendes machen wir hier: <br><br><ol><li>  Zuerst definieren wir zwei Variablen f√ºr Socket-Streams ohne automatische Speicherverwaltung </li><li>  Dann erstellen wir unter Verwendung derselben Variablen direkt Streams, die an die Host- und Portnummer gebunden sind. </li></ol><br>  Die Funktion hat vier Argumente.  Der erste ist der Typ des Speicherzuordners, den wir beim Initialisieren der Threads verwenden.  Sie sollten <b>kCFAllocatorDefault verwenden</b> , obwohl es andere m√∂gliche Optionen gibt, falls Sie das Verhalten der Threads √§ndern m√∂chten. <br><br><div class="spoiler">  <b class="spoiler_title">Anmerkung des √úbersetzers</b> <div class="spoiler_text">  In der Dokumentation zur Funktion <b>CFStreamCreatePairWithSocketToHost</b> hei√üt es: Verwenden Sie <b>NULL</b> oder <b>kCFAllocatorDefault</b> .  Und die Beschreibung von <b>kCFAllocatorDefault</b> besagt, dass es ein Synonym f√ºr <b>NULL ist</b> .  Der Kreis ist geschlossen! <br></div></div><br>  Dann setzen wir den Hostnamen.  In unserem Fall stellen wir eine Verbindung zum lokalen Server her.  Befindet sich Ihr Server an einem anderen Ort, k√∂nnen Sie seine IP-Adresse festlegen. <br><br>  Dann die Portnummer, die der Server abh√∂rt. <br><br>  Schlie√ülich √ºbergeben wir Zeiger an unsere E / A-Streams, damit die Funktion sie initialisieren und mit den von ihr erstellten Streams verbinden kann. <br><br>  Nachdem wir die initialisierten Flows haben, k√∂nnen wir Links zu ihnen speichern, indem wir diese Zeilen am Ende der <b>setupNetworkCommunication ()</b> -Methode <b>hinzuf√ºgen</b> : <br><br><pre> <code class="swift hljs">inputStream = readStream!.takeRetainedValue() outputStream = writeStream!.takeRetainedValue()</code> </pre> <br>  Durch die Verwendung von <b>takeRetainedValue (),</b> wie es auf ein nicht verwaltetes Objekt angewendet wird, k√∂nnen wir einen Verweis darauf beibehalten und gleichzeitig zuk√ºnftige Speicherverluste vermeiden.  Jetzt k√∂nnen wir unsere Threads verwenden, wo immer wir wollen. <br><br>  Jetzt m√ºssen wir diese Threads zur <b>Ausf√ºhrungsschleife</b> hinzuf√ºgen, damit unsere Anwendung Netzwerkereignisse korrekt verarbeitet.  <b>F√ºgen</b> Sie dazu diese beiden Zeilen am Ende von <b>setupNetworkCommunication () hinzu</b> : <br><br><pre> <code class="swift hljs">inputStream.schedule(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .current, forMode: .common) outputStream.schedule(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: .current, forMode: .common)</code> </pre> <br>  Endlich ist es Zeit zu segeln!  <b>F√ºgen</b> Sie dies zun√§chst ganz am Ende der <b>setupNetworkCommunication ()</b> -Methode hinzu: <br><br><pre> <code class="swift hljs">inputStream.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>() outputStream.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>()</code> </pre> <br>  Jetzt haben wir eine offene Verbindung zwischen unserer Client- und Serveranwendung. <br><br>  Wir k√∂nnen unsere Anwendung kompilieren und ausf√ºhren, aber Sie werden noch keine √Ñnderungen sehen, da wir mit unserer Client-Server-Verbindung nichts anfangen. <br><br><h2>  Verbindung zum Chat herstellen </h2><br>  Nachdem wir eine Verbindung zum Server hergestellt haben, ist es Zeit, etwas dagegen zu unternehmen!  Im Falle eines Chats m√ºssen Sie sich zuerst vorstellen und k√∂nnen dann Nachrichten an die Gespr√§chspartner senden. <br><br>  Dies f√ºhrt uns zu einer wichtigen Schlussfolgerung: Da wir zwei Arten von Nachrichten haben, m√ºssen wir sie irgendwie unterscheiden. <br><br><h2>  Chat-Protokoll </h2><br>  Einer der Vorteile der Verwendung der TCP-Schicht besteht darin, dass wir unser eigenes ‚ÄûProtokoll‚Äú f√ºr die Kommunikation definieren k√∂nnen. <br><br>  Wenn wir HTTP verwenden w√ºrden, m√ºssten wir diese verschiedenen W√∂rter <b>GET</b> , <b>PUT</b> , <b>PATCH verwenden</b> .  Wir m√ºssten URLs bilden und die richtigen Header und all das verwenden. <br><br>  Wir haben nur zwei Arten von Nachrichten.  Wir werden senden <br><br> <code>iam:Luke</code> <br> <br>  um in den Chat einzutreten und sich vorzustellen. <br><br>  Und wir werden senden <br><br> <code>msg:Hey, how goes it, man?</code> <br> <br>  um eine Chat-Nachricht an alle Befragten zu senden. <br><br>  Es ist sehr einfach, aber absolut prinzipienlos. Verwenden Sie diese Methode daher nicht in kritischen Projekten. <br><br>  Jetzt wissen wir, was unser Server erwartet, und k√∂nnen eine Methode in die <b>ChatRoom-</b> Klasse schreiben, mit der der Benutzer eine Verbindung zum Chat herstellen kann.  Das einzige Argument ist der Spitzname des Benutzers. <br><br>  F√ºgen Sie diese Methode in <b>ChatRoom.swift hinzu</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">joinChat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(username: String)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 let data = "iam:\(username)".data(using: .utf8)! //2 self.username = username //3 _ = data.withUnsafeBytes { guard let pointer = $0.baseAddress?.assumingMemoryBound(to: UInt8.self) else { print("Error joining chat") return } //4 outputStream.write(pointer, maxLength: data.count) } }</span></span></code> </pre> <br><ol><li>  Zuerst bilden wir unsere Nachricht mit unserem eigenen ‚ÄûProtokoll‚Äú. </li><li>  Speichern Sie den Namen zur sp√§teren Bezugnahme. </li><li>  <b>withUnsafeBytes (_ :)</b> bietet eine bequeme M√∂glichkeit, mit einem unsicheren Zeiger in einem Abschluss zu arbeiten. </li><li>  Schlie√ülich senden wir unsere Nachricht an den Ausgabestream.  Dies sieht m√∂glicherweise komplizierter aus als erwartet. Write (_: maxLength :) verwendet jedoch den im vorherigen Schritt erstellten unsicheren Zeiger. </li></ol><br>  Jetzt ist unsere Methode fertig, √∂ffnen Sie <b>ChatRoomViewController.swift</b> und f√ºgen Sie dieser Methode am Ende von <b>viewWillAppear (_ :)</b> einen Aufruf hinzu. <br><br><pre> <code class="swift hljs">chatRoom.joinChat(username: username)</code> </pre> <br>  Kompilieren Sie nun die Anwendung und f√ºhren Sie sie aus.  Geben Sie Ihren Spitznamen ein und tippen Sie auf Zur√ºck, um zu sehen ... <br><br><img src="https://habrastorage.org/webt/t5/mq/uw/t5mquwzt4dfvbn25cqglbf8sxgy.gif"><br><br>  ... <b>dass sich wieder nichts ge√§ndert hat!</b> <br><br>  Warten Sie, es ist alles in Ordnung!  Gehen Sie zum Terminalfenster.  Dort sehen Sie die Nachricht, der <b>Vasya beigetreten ist</b> oder so, wenn Sie nicht Vasya hei√üen. <br><br>  Das ist gro√üartig, aber es w√§re sch√∂n, wenn auf dem Bildschirm Ihres Telefons ein Hinweis auf eine erfolgreiche Verbindung angezeigt w√ºrde. <br><br><h2>  Antworten auf eingehende Nachrichten </h2><br>  Der Server sendet Client-Beitrittsnachrichten an alle Mitglieder des Chats, einschlie√ülich Sie.  Gl√ºcklicherweise verf√ºgt unsere Anwendung bereits √ºber alles, um eingehende Nachrichten in Form von Zellen in der Nachrichtentabelle in <b>ChatRoomViewController anzuzeigen</b> . <br><br>  Sie m√ºssen <b>lediglich inputStream verwenden</b> , um diese Nachrichten zu ‚Äûfangen‚Äú, sie in Instanzen der <b>Message-</b> Klasse zu konvertieren und sie zur Anzeige an die Tabelle zu √ºbergeben. <br><br>  Um auf eingehende Nachrichten antworten zu k√∂nnen, ben√∂tigen Sie <b>ChatRoom</b> , <b>um</b> das <b>StreamDelegate-</b> Protokoll <b>einzuhalten</b> . <br><br>  <b>F√ºgen</b> Sie dazu diese Erweiterung am Ende der Datei <b>ChatRoom.swift hinzu</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoom</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamDelegate</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br>  Geben Sie nun an, wer Delegierter von inputStream werden soll. <br><br>  F√ºgen Sie diese Zeile der setupNetworkCommunication () -Methode unmittelbar vor den aufzurufenden Aufrufen hinzu (in: forMode :): <br><br><pre> <code class="swift hljs">inputStream.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  F√ºgen Sie nun die Implementierung der Stream-Methode (_: handle :) zur Erweiterung hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aStream: Stream, handle eventCode: Stream.Event)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> eventCode { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .hasBytesAvailable: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"new message received"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .endEncountered: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"The end of the stream has been reached."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .errorOccurred: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"error occurred"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .hasSpaceAvailable: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"has space available"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"some other event..."</span></span>) } }</code> </pre> <br><h2>  Wir verarbeiten eingehende Nachrichten </h2><br>  Wir sind also bereit, eingehende Nachrichten zu verarbeiten.  Das Ereignis, das uns interessiert, ist <b>.hasBytesAvailable</b> , was darauf hinweist, dass eine eingehende Nachricht eingetroffen ist. <br><br>  Wir werden eine Methode schreiben, die diese Nachrichten verarbeitet.  Unterhalb der neu hinzugef√ºgten Methode schreiben wir Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readAvailableBytes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stream: InputStream)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 let buffer = UnsafeMutablePointer&lt;UInt8&gt;.allocate(capacity: maxReadLength) //2 while stream.hasBytesAvailable { //3 let numberOfBytesRead = inputStream.read(buffer, maxLength: maxReadLength) //4 if numberOfBytesRead &lt; 0, let error = stream.streamError { print(error) break } // Construct the Message object } }</span></span></code> </pre> <br><ol><li>  Wir legen den Puffer fest, in dem die eingehenden Bytes gelesen werden. </li><li>  Wir drehen uns in einer Schleife, w√§hrend im Eingabestream etwas zu lesen ist. </li><li>  Wir rufen read (_: maxLength :) auf, das die Bytes aus dem Stream liest und in den Puffer legt. </li><li>  Wenn der Aufruf einen negativen Wert zur√ºckgibt, geben wir einen Fehler zur√ºck und verlassen die Schleife. </li></ol><br>  Wir m√ºssen diese Methode aufrufen, sobald wir Daten im eingehenden Stream haben. Gehen Sie also zur <b>switch-Anweisung</b> in der <b>stream-</b> Methode <b>(_: handle :)</b> , suchen Sie den Schalter <b>.hasBytesAvailable</b> und rufen Sie diese Methode unmittelbar nach der print-Anweisung auf: <br><br><pre> <code class="swift hljs">readAvailableBytes(stream: aStream <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">InputStream</span></span>)</code> </pre> <br>  An dieser Stelle haben wir einen vorbereiteten Puffer mit empfangenen Daten! <br><br>  Wir m√ºssen diesen Puffer jedoch noch in den Inhalt der Nachrichtentabelle umwandeln. <br><br>  Platzieren Sie diese Methode auf <b>readAvailableBytes (stream :)</b> . <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processedMessageString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buffer: UnsafeMutablePointer&lt;UInt8&gt;, length: Int)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Message?</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 guard let stringArray = String( bytesNoCopy: buffer, length: length, encoding: .utf8, freeWhenDone: true)?.components(separatedBy: ":"), let name = stringArray.first, let message = stringArray.last else { return nil } //2 let messageSender: MessageSender = (name == self.username) ? .ourself : .someoneElse //3 return Message(message: message, messageSender: messageSender, username: name) }</span></span></code> </pre> <br>  Zuerst initialisieren wir String mit dem Puffer und der Gr√∂√üe, die wir an diese Methode √ºbergeben. <br><br>  Der Text befindet sich in UTF-8. Am Ende wird der Puffer freigegeben und die Nachricht durch das Symbol ':' geteilt, um den Namen des Absenders und die Nachricht selbst zu trennen. <br><br>  Jetzt analysieren wir, ob diese Nachricht von einem anderen Teilnehmer stammt.  Auf dem Produkt k√∂nnen Sie so etwas wie ein einzigartiges Token erstellen. Dies reicht f√ºr die Demo aus. <br><br>  Schlie√ülich bilden wir aus all dieser Wirtschaft eine Instanz der Botschaft und geben sie zur√ºck. <br><br>  Um diese Methode zu verwenden, f√ºgen Sie unmittelbar nach dem letzten Kommentar das folgende <b>if-let</b> am Ende der <b>while-Schleife</b> in die Methode <b>readAvailableBytes (stream :) ein</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message = processedMessageString(buffer: buffer, length: numberOfBytesRead) { <span class="hljs-comment"><span class="hljs-comment">// Notify interested parties }</span></span></code> </pre> <br>  Jetzt ist alles bereit, an jemanden weiterzugeben. <b>Nachricht</b> ... Aber an wen? <br><br><h2>  Erstellen Sie das ChatRoomDelegate-Protokoll </h2><br>  Wir m√ºssen <b>ChatRoomViewController.swift</b> √ºber die neue Nachricht informieren, haben jedoch keinen Link dazu.  Da es einen starken <b>ChatRoom-</b> Link enth√§lt, k√∂nnen wir in die Falle eines starken <b>Linkzyklus geraten</b> . <br><br>  Dies ist der perfekte Ort, um ein Delegatenprotokoll zu erstellen.  ChatRoom ist es egal, wer √ºber neue Beitr√§ge Bescheid wissen muss. <br><br>  <b>F√ºgen Sie</b> oben in <b>ChatRoom.swift</b> eine neue Protokolldefinition hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomDelegate</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">received</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: Message)</span></span></span></span> }</code> </pre> <br>  <b>F√ºgen Sie</b> nun in der <b>ChatRoom-</b> Klasse ein schwaches Glied hinzu, um zu speichern, wer der Delegat wird: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> delegate: <span class="hljs-type"><span class="hljs-type">ChatRoomDelegate?</span></span></code> </pre> <br>  <b>F√ºgen</b> wir nun die Methode <b>readAvailableBytes (stream :)</b> hinzu und f√ºgen die folgende Zeile innerhalb des if-let-Konstrukts unter dem letzten Kommentar in der Methode hinzu: <br><br><pre> <code class="swift hljs">delegate?.received(message: message)</code> </pre> <br>  <b>Kehren</b> Sie zu <b>ChatRoomViewController.swift zur√ºck</b> und f√ºgen Sie unmittelbar nach MessageInputDelegate die folgende Klassenerweiterung hinzu, die die Einhaltung des <b>ChatRoomDelegate-</b> Protokolls sicherstellt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatRoomDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">received</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: Message)</span></span></span></span> { insertNewMessageCell(message) } }</code> </pre> <br>  Das urspr√ºngliche Projekt enth√§lt bereits die erforderlichen <b>Informationen. InsertNewMessageCell (_ :)</b> akzeptiert Ihre Nachricht und zeigt die richtige Zelle in der Tabellenansicht an. <br><br>  <b>Weisen Sie</b> nun den View Controller als Delegaten zu, indem Sie diesen unmittelbar nach dem Aufruf von super.viewWillAppear () zu <b>viewWillAppear (_ :)</b> hinzuf√ºgen. <br><br><pre> <code class="swift hljs">chatRoom.delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span></code> </pre> <br>  Kompilieren Sie nun die Anwendung und f√ºhren Sie sie aus.  Geben Sie einen Namen ein und tippen Sie auf Zur√ºck. <br><br><img src="https://habrastorage.org/webt/km/21/ed/km21ed-ey4avyntpx53si6oqbra.gif"><br><br>  Sie sehen eine Zelle √ºber Ihre Verbindung zum Chat.  Hurra, Sie haben erfolgreich eine Nachricht an den Server gesendet und eine Antwort von ihm erhalten! <br><br><h2>  Nachrichten posten </h2><br>  Jetzt, da ChatRoom Nachrichten senden und empfangen kann, ist es Zeit, dem Benutzer die M√∂glichkeit zu geben, seine eigenen Phrasen zu senden. <br><br>  <b>F√ºgen Sie</b> in <b>ChatRoom.swift</b> am Ende der Klassendefinition die folgende Methode hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: String)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = <span class="hljs-string"><span class="hljs-string">"msg:\(message)"</span></span>.data(using: .utf8)! <span class="hljs-number"><span class="hljs-number">_</span></span> = data.withUnsafeBytes { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pointer = $<span class="hljs-number"><span class="hljs-number">0</span></span>.baseAddress?.assumingMemoryBound(to: <span class="hljs-type"><span class="hljs-type">UInt8</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Error joining chat"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } outputStream.write(pointer, maxLength: data.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span>) } }</code> </pre> <br>  Diese Methode √§hnelt <b>joinChat (Benutzername :)</b> , den wir zuvor geschrieben haben, au√üer dass das <b>msg-</b> Pr√§fix vor dem Text steht (um anzuzeigen, dass es sich um eine echte Chat-Nachricht handelt). <br><br>  Da wir Nachrichten √ºber die Schaltfl√§che <b>Senden</b> senden m√∂chten, kehren wir zu <b>ChatRoomViewController.swift zur√ºck</b> und finden dort <b>MessageInputDelegate</b> . <br><br>  Hier sehen wir die leere Methode <b>sendWasTapped (message :)</b> .  Um eine Nachricht zu senden, senden Sie sie an chatRoom: <br><br><pre> <code class="swift hljs">chatRoom.send(message: message)</code> </pre> <br>  Eigentlich ist das alles!  Da der Server die Nachricht empf√§ngt und an alle weiterleitet, wird ChatRoom √ºber die neue Nachricht auf die gleiche Weise benachrichtigt wie beim Beitritt zum Chat. <br><br>  Kompilieren Sie die Anwendung und f√ºhren Sie sie aus. <br><br><img src="https://habrastorage.org/webt/i6/e6/r1/i6e6r1tzjl-2r1ekzdk5gvplbsq.gif"><br><br>  Wenn Sie noch niemanden zum Chatten haben, √∂ffnen Sie ein neues Terminalfenster und geben Sie Folgendes ein: <br><br> <code>nc localhost 80</code> <br> <br>  Dadurch werden Sie mit dem Server verbunden.  Jetzt k√∂nnen Sie mit demselben "Protokoll" eine Verbindung zum Chat herstellen: <br><br> <code>iam:gregg</code> <br> <br>  Und so - senden Sie eine Nachricht: <br><br> <code>msg:Ay mang, wut's good?</code> <br> <br><img src="https://habrastorage.org/webt/qm/5e/_l/qm5e_l4wi4a0_whqffyzbmeyqzs.gif"><br><br>  Herzlichen Gl√ºckwunsch, Sie haben einen Kunden f√ºr den Chat geschrieben! <br><br><h2>  Wir reinigen uns </h2><br>  Wenn Sie jemals Anwendungen entwickelt haben, die Dateien aktiv lesen / schreiben, sollten Sie wissen, dass gute Entwickler Dateien schlie√üen, wenn sie mit ihnen fertig sind.  Tatsache ist, dass die Verbindung √ºber den Socket vom Dateideskriptor bereitgestellt wird.  Dies bedeutet, dass Sie es nach Abschluss der Arbeiten wie jede andere Datei schlie√üen m√ºssen. <br><br>  <b>F√ºgen Sie</b> dazu <b>ChatRoom.swift</b> die folgende Methode <b>hinzu,</b> nachdem Sie <b>send (message :) definiert haben</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stopChatSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { inputStream.close() outputStream.close() }</code> </pre><br>  Wie Sie wahrscheinlich vermutet haben, schlie√üt diese Methode Threads, sodass Sie keine Nachrichten mehr empfangen und senden k√∂nnen.  Au√üerdem werden Threads aus der <b>Ausf√ºhrungsschleife entfernt,</b> in der wir sie zuvor platziert haben. <br><br>  F√ºgen Sie dieser Methode im Abschnitt <b>.endEncountered</b> der <b>switch-Anweisung</b> im <b>Stream</b> einen Aufruf hinzu <b>(_: handle :)</b> : <br><br><pre> <code class="swift hljs">stopChatSession()</code> </pre> <br>  Gehen Sie dann zur√ºck zu <b>ChatRoomViewController.swift</b> und machen Sie dasselbe in <b>viewWillDisappear (_ :)</b> : <br><br><pre> <code class="swift hljs">chatRoom.stopChatSession()</code> </pre> <br>  Das ist alles!  Jetzt sicher! <br><br><h2>  Fazit </h2><br>  Nachdem Sie die Grundlagen der Vernetzung mit Sockets beherrschen, k√∂nnen Sie Ihr Wissen vertiefen. <br><br><h4>  UDP-Sockets </h4><br>  Diese Anwendung ist ein Beispiel f√ºr die Netzwerkkommunikation mit TCP, die die Zustellung von Paketen an das Ziel garantiert. <br><br>  Sie k√∂nnen jedoch UDP-Sockets verwenden.  Diese Art der Verbindung garantiert nicht die Lieferung von Paketen zu ihrem beabsichtigten Zweck, ist jedoch viel schneller. <br><br>  Dies ist besonders n√ºtzlich in Spielen.  Schon mal eine Verz√∂gerung erlebt?  Dies bedeutete, dass Sie eine schlechte Verbindung hatten und viele UDP-Pakete verloren gingen. <br><br><h4>  Websockets </h4><br>  Eine weitere Alternative zu HTTP in Anwendungen ist eine Technologie namens Web Sockets. <br><br>  Im Gegensatz zu normalen TCP-Sockets verwenden Web-Sockets HTTP, um die Kommunikation herzustellen.  Mit ihrer Hilfe k√∂nnen Sie dasselbe erreichen wie mit normalen Steckdosen, jedoch mit Komfort und Sicherheit, wie in einem Browser. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de467909/">https://habr.com/ru/post/de467909/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de467897/index.html">Autotest-Tools, Yandex Mapkit 3-Integration, cooles Design und Server Driven UI-Ansatz - Android Mitap-Ank√ºndigung</a></li>
<li><a href="../de467901/index.html">Widerlegen Sie vier Stereotypen √ºber die Programmiersprache Rust</a></li>
<li><a href="../de467903/index.html">Top 20 Navigationsfunktionen bei IntelliJ IDEA. Teil 1</a></li>
<li><a href="../de467905/index.html">Wie wir in Cloud Mail.ru Meilensteine ‚Äã‚Äãerkannt haben und warum</a></li>
<li><a href="../de467907/index.html">Vor- und Nachteile des Outsourcings</a></li>
<li><a href="../de467913/index.html">Wie man das ‚ÄûBastard-Mineral‚Äú oder die neue Schnittstelle f√ºr das Solarpanel verbessert</a></li>
<li><a href="../de467915/index.html">√úberwachung von Postgres in Openshift</a></li>
<li><a href="../de467917/index.html">Verwaltungsvorlagen</a></li>
<li><a href="../de467921/index.html">Nehmen Sie staubige Stifte heraus: Handschrift ist gut f√ºr das Gehirn</a></li>
<li><a href="../de467923/index.html">Sie m√∂chten also Analyst im Bereich Netzwerksicherheit werden ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>