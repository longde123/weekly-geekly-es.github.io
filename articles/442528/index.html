<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüíº ‚öõÔ∏è üë±üèø C√≥mo hacer que el juego funcione a 60 fps üë®üèª‚Äçüéì üë®‚Äçüë©‚Äçüë¶ üë∞üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagina el problema: tienes un juego y necesitas que funcione a 60 fps en un monitor de 60 Hz. Su computadora es lo suficientemente r√°pida para render...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo hacer que el juego funcione a 60 fps</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442528/">  Imagina el problema: tienes un juego y necesitas que funcione a 60 fps en un monitor de 60 Hz.  Su computadora es lo suficientemente r√°pida para renderizar y actualizar y ocupar una cantidad de tiempo insignificante, por lo que enciende vsync y escribe este ciclo de juego: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { update(); render(); display(); }</code> </pre> <br>  Muy facil!  Ahora el juego funciona a 60 fps y todo funciona como un reloj.  Listo  Gracias por leer esta publicaci√≥n. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/57e/bf1/0ae57ebf1f1695e4ecbcafddcb4255bb.jpg"></div><br>  Bueno, obviamente, no todo es tan bueno.  ¬øQu√© pasa si alguien tiene una computadora d√©bil que no puede procesar el juego a una velocidad suficiente para proporcionar 60 fps?  ¬øQu√© pasa si alguien compra uno de esos nuevos monitores de 144 hertz?  ¬øQu√© pasa si apaga vsync en la configuraci√≥n del controlador? <br><a name="habracut"></a><br>  Podr√≠a pensar: necesito medir el tiempo en alg√∫n lugar y proporcionar una actualizaci√≥n con la frecuencia correcta.  Esto es bastante simple: solo acumule tiempo en cada ciclo y actualice cada vez que exceda el umbral en 1/60 de segundo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render(); display(); }</code> </pre> <br>  Hecho, en ning√∫n lado m√°s f√°cil.  De hecho, hay un mont√≥n de juegos en los que el c√≥digo se ve esencialmente de esa manera.  Pero esto est√° mal.  Esto es adecuado para ajustar los tiempos, pero conduce a problemas con sacudidas (tartamudeo) y otros desajustes.  Tal problema es muy com√∫n: los cuadros no se muestran exactamente 1/60 de segundo;  incluso cuando vsync est√° activado, siempre hay un poco de ruido en el tiempo que se muestran (y en la precisi√≥n del temporizador del sistema operativo).  Por lo tanto, surgir√°n situaciones cuando renderice un marco, y el juego cree que el tiempo para la actualizaci√≥n a√∫n no ha llegado (porque la bater√≠a est√° rezagada una peque√±a fracci√≥n), por lo que simplemente repite el mismo marco nuevamente, pero ahora el juego llega tarde para el marco, por lo que se duplica actualizaci√≥n  ¬°Aqu√≠ est√° la contracci√≥n! <br><br>  En Google, puede encontrar varias soluciones listas para eliminar esta contracci√≥n.  Por ejemplo, un juego puede usar una variable en lugar de un paso de tiempo constante, y simplemente abandonar por completo las bater√≠as en el c√≥digo de tiempo.  O puede implementar un paso de tiempo constante con un renderizador interpolador, descrito en un art√≠culo bastante famoso " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> " de Glenn Fielder.  O bien, puede rehacer el c√≥digo del temporizador para que sea un poco m√°s flexible, como se describe en la publicaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20171206005813/" rel="nofollow noopener">Problemas de sincronizaci√≥n</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://web.archive.org/web/20171206005813/" rel="nofollow noopener">marco de</a> Slick Entertainment (desafortunadamente este blog ya no est√° all√≠). <br><br><hr><br><h3>  Tiempos difusos </h3><br>  El m√©todo Slick Entertainment con "tiempos difusos" en mi motor fue el m√°s f√°cil de implementar, ya que no requer√≠a cambios en la l√≥gica y el renderizado del juego.  As√≠ que en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">The End is Nigh</a> lo us√©.  Bastaba con insertarlo en el motor.  De hecho, simplemente permite que el juego se actualice "un poco antes" para evitar problemas con los desajustes de tiempo.  Si el juego incluye vsync, entonces solo te permite usar vsync como el temporizador principal del juego y proporciona una imagen fluida. <br><br>  As√≠ es como se ve el c√≥digo de actualizaci√≥n ahora (el juego "puede funcionar" a 62 fps, pero a√∫n procesa cada paso como si funcionara a 60 fps. No entiendo bien por qu√© limitarlo para que los valores de la bater√≠a no caigan por debajo de 0, pero sin Este c√≥digo no funciona).  Puede interpretarlo de esta manera: "el juego se actualiza con un paso fijo, si se procesa en el intervalo de 60 fps a 62 fps": <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">62.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Si vsync est√° habilitado, esencialmente permite que el juego funcione con un tono fijo, que coincide con la frecuencia de actualizaci√≥n del monitor, y proporciona una imagen uniforme.  El principal problema aqu√≠ es que cuando vsync est√° desactivado, el juego funcionar√° un <i>poco</i> m√°s r√°pido, pero la diferencia es tan insignificante que nadie lo notar√°. <br><br>  Corredores de velocidad.  Los corredores de velocidad lo notar√°n.  Poco despu√©s de que se lanz√≥ el juego, notaron que algunas personas en las listas de puntajes m√°s altos de speedran ten√≠an tiempos de viaje m√°s pobres, pero result√≥ ser mejor que otros.  Y la raz√≥n inmediata de esto fueron los tiempos poco claros y la desconexi√≥n de vsync en el juego (o monitores de 144 Hz).  Por lo tanto, se hizo evidente que debe desactivar esta confusi√≥n al desconectar vsync. <br><br>  Ah, pero a√∫n no podemos comprobar si vsync est√° deshabilitado.  No hay llamadas para esto en el sistema operativo, y aunque podemos solicitar a la aplicaci√≥n que habilite o deshabilite vsync, de hecho, depende completamente del sistema operativo y del controlador de gr√°ficos.  Lo √∫nico que se puede hacer es renderizar un mont√≥n de cuadros, intentar medir el tiempo de ejecuci√≥n de esta tarea y luego comparar si toman aproximadamente el mismo tiempo.  Eso es exactamente lo que hice para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">The End is Nigh</a> .  Si el juego no incluye vsync con una frecuencia de 60 Hz, entonces regresa al temporizador de cuadro original con "60 fps estrictos".  Adem√°s, agregu√© un par√°metro al archivo de configuraci√≥n que obliga al juego a no usar borrosidad (principalmente para los corredores de velocidad que necesitan un tiempo preciso) y agregu√© un controlador de temporizador exacto en el juego para ellos, lo que permite usar el divisor autom√°tico (este es un script que funciona con un temporizador de tiempo at√≥mico). <br><br>  Algunos usuarios todav√≠a se quejaron de la sacudida ocasional de marcos individuales, pero parec√≠an tan raros que podr√≠an explicarse por eventos del sistema operativo u otras razones externas.  No es gran cosa.  Derecho? <br><br>  Al revisar mi c√≥digo de temporizador recientemente, not√© algo extra√±o.  La bater√≠a se desplaz√≥, cada cuadro tard√≥ un poco m√°s de 1/60 de segundo, por lo que de vez en cuando el juego pens√≥ que era tarde para el cuadro, y realiz√≥ una doble actualizaci√≥n.  Result√≥ que mi monitor funciona con una frecuencia de 59,94 Hz, y no 60 Hz.  Esto significaba que cada 1000 cuadros ten√≠a que realizar una doble actualizaci√≥n para "ponerse al d√≠a".  Sin embargo, esto es muy sencillo de solucionar: simplemente cambie el intervalo de frecuencias de trama permitidas (no de 60 a 62, sino de 59 a 61). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  El problema descrito anteriormente con vsync desconectado y monitores de alta frecuencia a√∫n persiste, y se aplica la misma soluci√≥n (revertir al temporizador estricto si el monitor <i>no</i> est√° sincronizado vsync en 60). <br><br>  Pero, ¬øc√≥mo saber si esta es la soluci√≥n correcta?  ¬øC√≥mo asegurarse de que funcionar√° correctamente en todas las combinaciones de computadoras con diferentes tipos de monitores, con y sin vsync activado, y as√≠ sucesivamente?  Es muy dif√≠cil hacer un seguimiento de todos estos problemas del temporizador en la cabeza y comprender qu√© causa la desincronizaci√≥n, los bucles extra√±os y dem√°s. <br><br><h3>  Monitor simulador </h3><br>  Al intentar encontrar una soluci√≥n confiable para el "problema del monitor de 59.94 hertzios", me di cuenta de que no pod√≠a simplemente realizar comprobaciones de prueba y error, con la esperanza de encontrar una soluci√≥n confiable.  Necesitaba una manera conveniente de probar diferentes intentos de escribir un temporizador de alta calidad y una manera f√°cil de verificar si causa una sacudida o un cambio de tiempo en diferentes configuraciones de monitor. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Monitor Simulator</a> aparece en la escena.  Este es el c√≥digo "sucio y r√°pido" que escrib√≠, simulando la "operaci√≥n del monitor" y esencialmente mostr√°ndome un mont√≥n de n√∫meros que dan una idea de la estabilidad de cada temporizador probado. <br><br>  Por ejemplo, para el temporizador m√°s simple, los siguientes valores se muestran desde el principio del art√≠culo: <br><br> <code>20211012021011202111020211102012012102012[...] <br> TOTAL UPDATES: 10001 <br> TOTAL VSYNCS: 10002 <br> TOTAL DOUBLE UPDATES: 2535 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.683 <br> SYSTEM TIME: 166.7</code> <br> <br>  Primero, el c√≥digo muestra para cada vsync emulado el n√∫mero del n√∫mero de "actualizaciones" al ciclo del juego despu√©s del vsync anterior.  Cualquier valor que no sea s√≥lido 1 conduce a una imagen nerviosa.  Al final, el c√≥digo muestra las estad√≠sticas acumuladas. <br><br>  Cuando se utiliza el "temporizador difuso" (con un intervalo de 60‚Äì62 fps) en un monitor de 59,94 hercios, el c√≥digo muestra lo siguiente: <br><br> <code>111111111111111111111111111111111111111111111[...] <br> TOTAL UPDATES: 10000 <br> TOTAL VSYNCS: 9991 <br> TOTAL DOUBLE UPDATES: 10 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.667 <br> SYSTEM TIME: 166.683</code> <br> <br>  La sacudida del marco es muy rara, por lo que puede ser dif√≠cil notarlo con un n√∫mero de 1. Pero las estad√≠sticas mostradas muestran claramente que el juego ha realizado varias actualizaciones dobles aqu√≠, lo que lleva a la sacudida.  En la versi√≥n fija (con un intervalo de 59‚Äì61 fps), hay 0 actualizaciones omitidas o dobles. <br><br>  Tambi√©n puede deshabilitar vsync.  El resto de los datos estad√≠sticos deja de ser importante, pero esto me muestra claramente la magnitud del "cambio de tiempo" (el cambio de tiempo del sistema en relaci√≥n con el tiempo del juego). <br><br> <code>GAME TIME: 166.667 <br> SYSTEM TIME: 169.102</code> <br> <br>  Es por eso que cuando vsync est√° deshabilitado, debe cambiar a un temporizador estricto, de lo contrario, estas discrepancias se acumulan con el tiempo. <br><br>  Si configuro el tiempo de representaci√≥n en .02 (es decir, se necesita "m√°s de un cuadro" para la representaci√≥n), obtendr√© una contracci√≥n.  Idealmente, el patr√≥n del juego deber√≠a verse como 202020202020, pero es un poco desigual. <br><br>  En esta situaci√≥n, este temporizador se comporta un poco mejor que el anterior, pero se vuelve m√°s confuso y m√°s dif√≠cil descubrir c√≥mo y por qu√© funciona.  Pero solo puedo poner las pruebas en este simulador y verificar c√≥mo se comportan, y puedes averiguar las razones m√°s adelante.  Prueba y error, beb√©! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ simulate_update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>‚Äì<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Puede descargar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">un simulador de monitor</a> y verificar de forma independiente diferentes m√©todos de c√°lculo de tiempos.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Env√≠ame un correo electr√≥nico</a> si encuentras algo mejor. <br><br>  No estoy 100% satisfecho con mi decisi√≥n (todav√≠a requiere un truco con "reconocimiento de vsync" y pueden ocurrir sacudidas ocasionales durante la desincronizaci√≥n), pero creo que es casi tan bueno como un intento de implementar un ciclo de juego con un paso fijo.  Parte de este problema surge porque aqu√≠ es muy dif√≠cil determinar los par√°metros de lo que se considera "aceptable".  La principal dificultad radica en la compensaci√≥n entre el cambio de tiempo y los marcos dobles / omitidos.  Si ejecuta un juego de 60 Hz en un monitor PAL de 50 Hz ... ¬øcu√°l ser√° la decisi√≥n correcta?  ¬øQuieres sacudidas salvajes o un juego notablemente m√°s lento?  Ambas opciones parecen malas. <br><br><h3>  Renderizado separado </h3><br>  En los m√©todos anteriores, describ√≠ lo que yo llamo "representaci√≥n en bloque".  El juego actualiza su estado, luego renderiza y, cuando se procesa, siempre muestra el estado m√°s reciente del juego.  El renderizado y la actualizaci√≥n est√°n conectados entre s√≠. <br><br>  Pero puedes separarlos.  Esto es exactamente lo que hace el m√©todo descrito en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">publicaci√≥n</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> ".  No me repetir√©, definitivamente deber√≠as leer esta publicaci√≥n.  Este (seg√∫n tengo entendido) es el "est√°ndar de la industria" utilizado en los juegos y motores AAA como Unity e Unreal (sin embargo, en los juegos activos 2D intensos, generalmente prefieren usar un paso fijo (bloqueo), porque a veces la precisi√≥n que le brinda este m√©todo) <br><br>  Pero si describimos brevemente la publicaci√≥n de Glenn, simplemente describe el m√©todo de actualizaci√≥n con una velocidad de cuadro fija, pero cuando se procesa, la interpolaci√≥n se realiza entre el estado "actual" y "anterior" del juego, y el valor actual de la bater√≠a se usa como el valor de interpolaci√≥n.  Con este m√©todo, puede renderizar a cualquier velocidad de cuadros y actualizar el juego a cualquier frecuencia, y la imagen siempre ser√° suave.  Sin sacudidas, funciona universalmente. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running){ computeDeltaTimeSomehow(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ previous_state = current_state; current_state = update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render_interpolated_somehow(previous_state, current_state, accumulator/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>)); display(); }</code> </pre> <br>  Entonces, elemental.  El problema est√° resuelto. <br><br>  Ahora solo necesitas asegurarte de que el juego pueda representar los estados interpolados ... pero espera un minuto, realmente no es nada f√°cil.  En la publicaci√≥n de Glenn, simplemente se supone que esto se puede hacer.  Es bastante f√°cil almacenar en cach√© la posici√≥n anterior del objeto del juego e interpolar sus movimientos, pero el estado del juego es mucho m√°s que eso.  Es necesario tener en cuenta en √©l el estado de la animaci√≥n, la creaci√≥n y destrucci√≥n de objetos y un mont√≥n de cosas. <br><br>  Adem√°s, en la l√≥gica del juego, debe considerar si el objeto se teletransporta o si se debe mover suavemente para que el interpolador no haga suposiciones falsas sobre la ruta realizada por el objeto del juego a su posici√≥n actual.  El caos real puede ocurrir con los giros, especialmente si en un cuadro el giro de un objeto puede cambiar en m√°s de 180 grados.  ¬øY c√≥mo procesar adecuadamente los objetos creados y destruidos? <br><br>  Por el momento, solo estoy trabajando en esta tarea en mi motor.  De hecho, solo interpolo los movimientos y dejo todo lo dem√°s como est√°.  No notar√° sacudidas si el objeto no se mueve suavemente, por lo tanto, omitir cuadros de animaci√≥n y sincronizar la creaci√≥n / destrucci√≥n del objeto en un cuadro no se convertir√° en un problema si todo lo dem√°s se realiza sin problemas. <br><br>  Sin embargo, es extra√±o que, de hecho, este m√©todo represente el juego en un estado que est√° retrasado por 1 estado del juego desde donde ahora se encuentra la simulaci√≥n.  Esto es discreto, pero se puede conectar a otras fuentes de retrasos, por ejemplo, el retraso de entrada y la frecuencia de actualizaci√≥n del monitor, por lo que aquellos que necesitan el juego m√°s receptivo (estoy hablando de ustedes, corredores de velocidad) probablemente preferir√°n usar el bloqueo en el juego. <br><br>  En mi motor, solo doy una opci√≥n.  Si tiene un monitor de 60 hertzios y una computadora r√°pida, lo mejor es usar lockstep con vsync habilitado.  Si el monitor tiene una frecuencia de actualizaci√≥n no est√°ndar, o su computadora d√©bil no puede procesar constantemente 60 cuadros por segundo, entonces habilite la interpolaci√≥n de cuadros.  Quiero llamar a esta opci√≥n "desbloquear framerate", pero la gente podr√≠a pensar que simplemente significa "habilitar esta opci√≥n si tiene una buena computadora".  Sin embargo, este problema puede resolverse m√°s tarde. <br><br>  En realidad, hay <i>un</i> m√©todo para solucionar este problema. <br><br><h3>  Actualizaciones de paso de tiempo variable </h3><br>  Muchas personas me preguntaron por qu√© no solo actualizan el juego con un paso de tiempo variable, y los programadores te√≥ricos a menudo dicen: "si el juego est√° escrito CORRECTAMENTE, entonces simplemente puede actualizarlo con un paso de tiempo arbitrario". <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); update(deltaTime); render(); display(); }</code> </pre> <br>  No hay rarezas con los tiempos.  Sin renderizado de interpolaci√≥n extra√±o.  Todo es simple, todo funciona. <br><br>  Entonces, elemental.  El problema est√° resuelto.  Y ahora para siempre!  ¬°Es imposible lograr un mejor resultado! <br><br>  Ahora es lo suficientemente simple como para que la l√≥gica del juego funcione con un paso de tiempo arbitrario.  Es simple, simplemente reemplace todo este c√≥digo: <br><br><pre> <code class="cpp hljs">position += speed;</code> </pre> <br>  en esto: <br><br><pre> <code class="cpp hljs">position += speed * deltaTime;</code> </pre> <br>  y reemplace el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs">speed += acceleration; position += speed;</code> </pre> <br>  en esto: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; position += speed * deltaTime;</code> </pre> <br>  y reemplace el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs">speed += acceleration; speed *= friction; position += speed;</code> </pre> <br>  en esto: <br><br><pre> <code class="cpp hljs">Vec3D p0 = position; Vec3D v0 = velocity; Vec3D a = acceleration*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = friction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n = dt*<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fN = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, n); position = p0 + ((f*(a*(f*fN-f*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>)+n)+(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*v0*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)))/((f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)))*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); velocity = v0*fN+a*(f*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)/(f<span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br>  ... entonces espera <br><br>  ¬øDe d√≥nde vino todo esto? <br><br>  La √∫ltima parte se copia literalmente del c√≥digo auxiliar de mi motor, que realiza "un movimiento realmente correcto, independiente de la velocidad de fotogramas con velocidad de limitaci√≥n de fricci√≥n".  Hay un poco de basura en √©l (estas multiplicaciones y divisiones por 60).  Pero esta es la versi√≥n "correcta" del c√≥digo con un paso de tiempo variable para el fragmento anterior.  Lo descubr√≠ durante m√°s de una hora con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Wolfram Alpha</a> . <br><br>  Ahora pueden preguntarme por qu√© no hacerlo as√≠: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; speed *= <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, deltaTime); position += speed * deltaTime;</code> </pre> <br>  Y aunque parece funcionar, en realidad est√° mal hacerlo.  Puedes comprobarlo t√∫ mismo.  Realice dos actualizaciones con deltaTime = 1, y luego realice una actualizaci√≥n con deltaTime = 2, y los resultados ser√°n diferentes.  Por lo general, nos esforzamos para que el juego funcione en concierto, por lo que esas discrepancias no son bienvenidas.  Probablemente sea una soluci√≥n lo suficientemente buena, si sabe con certeza que deltaTime siempre es aproximadamente igual a un valor, pero luego necesita escribir c√≥digo para asegurarse de que las actualizaciones se realicen con cierta frecuencia constante y ... s√≠.  As√≠ es, ahora estamos tratando de hacer todo "CORRECTAMENTE". <br><br>  Si un c√≥digo tan peque√±o se despliega en monstruosos c√°lculos matem√°ticos, imag√≠nese patrones de movimiento m√°s complejos en los que participen muchos objetos interactivos, y cosas por el estilo.  Ahora puede ver claramente que la soluci√≥n "correcta" es irrealizable.  Lo m√°ximo que podemos lograr es una "aproximaci√≥n aproximada".  Olvid√©moslo por ahora y supongamos que realmente tenemos una versi√≥n "realmente correcta" de las funciones de movimiento.  Genial, verdad? <br><br>  No, en realidad  Aqu√≠ hay un ejemplo de la vida real del problema que tuve con esto en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow noopener">Bombernauts</a> .  Un jugador puede rebotar aproximadamente 1 mosaico, y el juego se desarrolla en una cuadr√≠cula de bloques en 1 mosaico.  Para aterrizar en un bloque, las piernas del personaje deben elevarse por encima de la superficie superior del bloque. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/eff/806/956eff806c65598bd694f6bc81713c1c.png"></div><br>  Pero dado que el reconocimiento de colisiones aqu√≠ se realiza con un paso discreto, si el juego funciona con una velocidad de fotogramas baja, a veces las patas no alcanzar√°n la superficie de la loseta, aunque siguieron la misma curva de movimiento, y en lugar de levantar, el jugador se deslizar√° fuera de la pared. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/ab7/cfc/5adab7cfc0abca780385cb3da53d63e5.png"></div><br>  Obviamente, este problema es solucionable.  Pero ilustra los tipos de problemas que encontramos cuando intentamos implementar correctamente el trabajo del ciclo del juego con un paso de tiempo variable.  Perdemos coherencia y determinismo, por lo que tendremos que deshacernos de las funciones de repetici√≥n del juego registrando la entrada del jugador, el multijugador determinista y dem√°s.  Para los juegos 2D r√°pidos basados ‚Äã‚Äãen reflejos, la consistencia es extremadamente importante (y hola nuevamente a los corredores de velocidad). <br><br>  Si intenta ajustar los pasos de tiempo para que no sean ni demasiado grandes ni demasiado peque√±os, perder√° la ventaja principal obtenida del paso de tiempo variable, y puede usar con seguridad los otros dos m√©todos descritos aqu√≠.  El juego no vale la pena.  Se pondr√° demasiado esfuerzo adicional en la l√≥gica del juego (la implementaci√≥n de las matem√°ticas correctas del movimiento), y se requerir√°n demasiadas v√≠ctimas en el campo del determinismo y la coherencia.  Usar√≠a este m√©todo solo para un juego de ritmo musical (en el que las ecuaciones de movimiento son simples y requieren la m√°xima capacidad de respuesta y suavidad).  En todos los dem√°s casos, elegir√© una actualizaci√≥n fija. <br><br><hr><br><h3>  Conclusi√≥n </h3><br>  Ahora sabes c√≥mo hacer que el juego funcione a una frecuencia constante de 60 fps.  Esto es trivialmente simple, y nadie m√°s deber√≠a tener un problema con √©l.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay otros problemas que</a> complican esta tarea. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/442528/">https://habr.com/ru/post/442528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442518/index.html">Las 10 mejores t√©cnicas de pirater√≠a web 2018</a></li>
<li><a href="../442520/index.html">Caso. Ahorro de 300 000 p. por mes en publicidad contextual</a></li>
<li><a href="../442522/index.html">Intuitivo RL (aprendizaje de refuerzo): Introducci√≥n a Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../442524/index.html">C√≥mo aumentar la seguridad en la identificaci√≥n personal y los sistemas de control de acceso</a></li>
<li><a href="../442526/index.html">La historia de los reproductores de cassette sovi√©ticos (segunda parte): el auge de Walkmen, un dispositivo para el KGB y las grabadoras</a></li>
<li><a href="../442530/index.html">Wireshark 3.0.0: revisi√≥n de innovaciones</a></li>
<li><a href="../442532/index.html">Grabadoras de video para video vigilancia - gratis</a></li>
<li><a href="../442534/index.html">Revisi√≥n de Sprint: de mierda a genial</a></li>
<li><a href="../442536/index.html">Conexi√≥n de buzones externos a Zimbra</a></li>
<li><a href="../442542/index.html">SmartMail Conf: Primera conferencia de correo de aprendizaje autom√°tico de Mail.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>