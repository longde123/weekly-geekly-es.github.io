<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔶 ♿️ 🔯 高精度时间：如何在MySQL和PHP中工作几分之一秒 👦🏾 👃🏽 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="一旦我想到，在数据库中使用时间时，我几乎总是使用精确到秒的时间，这仅仅是因为我已经习惯了，并且这是文档中描述的选项以及大量示例。 但是，现在这种精度远远不能满足所有任务的需要。 现代系统很复杂-它们可以由许多部分组成，有数以百万计的用户与它们交互-并且在许多情况下，使用更高的精度更为方便，而这种精度...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>高精度时间：如何在MySQL和PHP中工作几分之一秒</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/469615/"><p><img src="https://habrastorage.org/webt/uu/43/0k/uu430kx8xpmnjcelv7obc41muik.jpeg"></p><br><p> 一旦我想到，在数据库中使用时间时，我几乎总是使用精确到秒的时间，这仅仅是因为我已经习惯了，并且这是文档中描述的选项以及大量示例。 但是，现在这种精度远远不能满足所有任务的需要。 现代系统很复杂-它们可以由许多部分组成，有数以百万计的用户与它们交互-并且在许多情况下，使用更高的精度更为方便，而这种精度已经存在了很长时间。 </p><br><p> 在本文中，我将讨论在MySQL和PHP中使用时间的几分之一秒的方法。 它被设计为教程，因此该材料是为广泛的读者设计的，在某些地方重复了文档。 主要的价值应该在于，我在一个文本中收集了在MySQL，PHP和Yii框架中使用这些时间所需的一切知识，并且还添加了对您可能遇到的显而易见问题的描述。 </p><br><p> 我将使用术语“高精度时间”。 在MySQL文档中，您将看到术语“小数秒”，但是其字面翻译听起来很奇怪，但是我没有找到其他确定的翻译。 </p><a name="habracut"></a><br><h2 id="kogda-stoit-ispolzovat-vremya-vysokoy-tochnosti"> 什么时候使用高精度时间？ </h2><br><p> 首先，我将显示收件箱中收件箱的屏幕截图，它很好地说明了这个想法： </p><br><p><img src="https://habrastorage.org/webt/bc/tg/gx/bctggxr0qbeetqe9hmmb4zjmbom.png" alt="一位发件人发送的两封信"></p><br><p> 信件是同一个人对一个事件的反应。 一个人不小心按下了错误的按钮，迅速意识到了这一点并纠正了自己。 结果，我们收到了大约同时发送的两个字母，这对于正确排序很重要。 如果发送时间相同，则可能会以错误的顺序显示字母，使收件人感到尴尬，因为这样他会收到错误的结果，他将为此计算。 </p><br><p> 我遇到了以下情况，其中高精度时间是很重要的： </p><br><ol><li> 您要测量某些操作之间的时间。 这里的一切都非常简单：时间间隔边界处的时间戳精度越高，结果的精度越高。 如果您使用整秒，那么您可能会犯错误1秒钟（如果您落在秒的边界上）。 如果使用六个小数位，则误差将降低六个数量级。 </li><li> 您有一个集合，其中可能有多个具有相同创建时间的对象。 一个例子是大家都熟悉的聊天，其中联系人列表按上一条消息的时间排序。 如果出现逐页导航，则甚至存在在页面边界失去联系的风险。 由于通过一对字段（时间+对象的唯一标识符）进行排序和分页，可以在没有高精度时间的情况下解决此问题，但是此解决方案具有其缺点（至少是SQL查询的复杂性，不仅如此）。 增加时间的准确性将有助于减少出现问题的可能性，并且不会使系统复杂化。 </li><li>您需要保留某些对象的更改历史记录。 这在服务世界中尤其重要，在服务世界中，修改可以并行进行，也可以在完全不同的地方进行。 例如，我可以处理我们用户的照片，其中可以并行执行许多不同的操作（用户可以将照片设为私人照片或将其删除，可以在多个系统之一中对其进行审核，裁剪后用作聊天中的照片等）。 ） </li></ol><br><p> 必须牢记，一个人不能100％信任所获得的值，并且所获得的值的实际准确性可能少于六个小数位。 这是由于以下事实：我们获得的时间值不准确（特别是在由许多服务器组成的分布式系统中工作时），时间可能会意外更改（例如，通过NTP同步或更改时钟时）等。我不会讨论所有这些问题，但是我将提供一些文章，您可以在其中阅读更多有关它们的信息： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“程序员在时间方面的错误”</a> （文章本身非常简单，但是除了文本中的这些内容之外，还可以在注释中找到解释）； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“时间很重</a> 。 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">”</a> </li></ul><br><h2 id="rabota-so-vremenem-vysokoy-tochnosti-v-mysql"> 在MySQL中使用高精度时间 </h2><br><p> MySQL支持三种可以存储时间的列： <code>TIME</code> ， <code>DATETIME</code>和<code>TIMESTAMP</code> 。 最初，它们只能存储一秒的倍数的值（例如，2019-08-14 19:20:21）。 在2011年12月发布的5.6.4版本中，可以使用零点几秒的时间。 为此，在创建列时，需要指定小数位数，该位数必须存储在时间戳的小数部分中。 支持的最大字符数为六个，这使您可以存储精确到微秒的时间。 如果尝试使用更多字符，则会出现错误。 </p><br><p> 一个例子： </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> ( <span class="hljs-string"><span class="hljs-string">`chat_id`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> AUTO_INCREMENT PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-string"><span class="hljs-string">`title`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">`last_message_send_time`</span></span> <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">ENGINE</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">InnoDB</span></span>; Query OK, 0 rows affected (0.02 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODIFY</span></span> last_message_send_time <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ERROR 1426 (42000): Too-big precision 9 specified for 'last_message_send_time'. Maximum is 6. Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-string"><span class="hljs-string">`ChatContactsList`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODIFY</span></span> last_message_send_time <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Query OK, 0 rows affected (0.09 sec) Records: 0 Duplicates: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ChatContactsList (title, last_message_send_time) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Chat #1'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>()); Query OK, 1 row affected (0.03 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:23:15.000 | +---------+---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p> 在此示例中，插入记录的时间戳具有零分数。 发生这种情况是因为输入值显示为最接近的秒数。 要解决该问题，输入值的精度必须与数据库中的值相同。 该建议似乎很明显，但却是相关的，因为在实际应用中可能会出现类似的问题：我们面临这样的情况，即输入值的小数位数为3位，数据库中存储了6位。 </p><br><p> 防止此问题发生的最简单方法是使用输入精度最高的输入值（最高微秒）。 在这种情况下，将数据写入表时，时间将四舍五入到所需的精度。 这是绝对正常的情况，不会引起任何警告： </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> last_message_send_time=<span class="hljs-string"><span class="hljs-string">"2019-09-22 22:23:15.2345"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chat_id=<span class="hljs-number"><span class="hljs-number">1</span></span>; Query OK, 1 row affected (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:23:15.235 | +---------+---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p> 当使用格式为<code>DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</code>的结构对TIMESTAMP列进行自动初始化和自动更新时，重要的是，这些值必须与列本身具有相同的精度： </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>; ERROR 1067 (42000): Invalid default value for 'updated' Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>); ERROR 1067 (42000): Invalid default value for 'updated' Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">updated</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_TIMESTAMP</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); Query OK, 0 rows affected (0.07 sec) Records: 0 Duplicates: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> last_message_send_time=<span class="hljs-string"><span class="hljs-string">'2019-09-22 22:22:22'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> chat_id=<span class="hljs-number"><span class="hljs-number">1</span></span>; Query OK, 0 rows affected (0.00 sec) Rows matched: 1 Changed: 0 Warnings: 0 Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList; +<span class="hljs-comment"><span class="hljs-comment">---------+---------+-------------------------+-------------------------+ | chat_id | title | last_message_send_time | updated | +---------+---------+-------------------------+-------------------------+ | 1 | Chat #1 | 2019-09-22 22:22:22.000 | 2019-09-22 22:26:39.968 | +---------+---------+-------------------------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p> 随着时间的推移，MySQL函数支持使用度量单位的小数部分。 我不会列出所有内容（我建议您在文档中查找），但是我将给出一些示例： </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">NOW</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">INTERVAL</span></span> <span class="hljs-number"><span class="hljs-number">7.5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SECOND</span></span>; +<span class="hljs-comment"><span class="hljs-comment">------------------------+--------------------------+------------------------------+ | NOW(2) | NOW(4) | NOW(4) + INTERVAL 7.5 SECOND | +------------------------+--------------------------+------------------------------+ | 2019-09-22 21:12:23.31 | 2019-09-22 21:12:23.3194 | 2019-09-22 21:12:30.8194 | +------------------------+--------------------------+------------------------------+ 1 row in set (0.00 sec) Test&gt; SELECT SUBTIME(CURRENT_TIME(6), CURRENT_TIME(3)), CURRENT_TIME(6), CURRENT_TIME(3); +-------------------------------------------+-----------------+-----------------+ | SUBTIME(CURRENT_TIME(6), CURRENT_TIME(3)) | CURRENT_TIME(6) | CURRENT_TIME(3) | +-------------------------------------------+-----------------+-----------------+ | 00:00:00.000712 | 21:12:50.793712 | 21:12:50.793 | +-------------------------------------------+-----------------+-----------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p> 在SQL查询中使用秒的小数部分相关的主要问题是比较（ <code>&gt;</code> ， <code>&lt;</code> ， <code>BETWEEN</code> ）的准确性不一致。 如果数据库中的数据具有一种准确性，而查询中的具有另一种准确性，则可能会遇到这种情况。 这是一个说明此问题的小示例： </p><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#         Test&gt; INSERT INTO ChatContactsList (title, last_message_send_time) VALUES ('Chat #2', '2019-09-22 21:16:39.123456'); Query OK, 0 row affected (0.00 sec) Test&gt; SELECT chat_id, title, last_message_send_time FROM ChatContactsList WHERE title='Chat #2'; +---------+---------+-------------------------+ | chat_id | title | last_message_send_time | +---------+---------+-------------------------+ | 2 | Chat #2 | 2019-09-22 21:16:39.123 | &lt;-     - ,    +---------+---------+-------------------------+ 1 row in set (0.00 sec) Test&gt; SELECT title, last_message_send_time FROM ChatContactsList WHERE last_message_send_time &gt;= '2019-09-22 21:16:39.123456'; &lt;-    ,    INSERT- +---------+-------------------------+ | title | last_message_send_time | +---------+-------------------------+ | Chat #1 | 2019-09-22 22:22:22.000 | +---------+-------------------------+ 1 row in set (0.00 sec) &lt;- Chat #2   - ,     ,    </span></span></code> </pre> <br><p> 在此示例中，查询中的值的准确性高于数据库中的值的准确性，并且此问题发生在“从上方的边界上”。 在相反的情况下（如果输入值的精度低于数据库中的值）将没有问题-MySQL将在INSERT和SELECT中将值都提高到所需的精度： </p><br><pre> <code class="sql hljs">Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> ChatContactsList (title, last_message_send_time) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'Chat #3'</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-09-03 21:20:19.1'</span></span>); Query OK, 1 row affected (0.00 sec) Test&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> title, last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> last_message_send_time &lt;= <span class="hljs-string"><span class="hljs-string">'2019-09-03 21:20:19.1'</span></span>; +<span class="hljs-comment"><span class="hljs-comment">---------+-------------------------+ | title | last_message_send_time | +---------+-------------------------+ | Chat #3 | 2019-09-03 21:20:19.100 | +---------+-------------------------+ 1 row in set (0.00 sec)</span></span></code> </pre> <br><p> 在使用高精度时间时，应始终牢记值准确性的一致性。 如果此类边界问题对您来说很关键，那么您需要确保代码和数据库使用相同的小数位数。 </p><br><div class="spoiler">  <b class="spoiler_title">关于选择小数秒部分的列中的精度的思考</b> <div class="spoiler_text"><p> 时间单位的小数部分占用的空间量取决于列中的字符数。 选择熟悉的含义似乎很自然：三到六个小数位。 但是，对于三个字符，这并不是那么简单。 实际上，MySQL使用一个字节存储两个小数位： </p><br><blockquote><div class="scrollable-table"><table><thead><tr><th> 分数秒精度 </th><th> 储存要求 </th></tr></thead><tbody><tr><td>  0 </td><td>  0字节 </td></tr><tr><td> 一二 </td><td>  1个字节 </td></tr><tr><td>  3 4 </td><td>  2字节 </td></tr><tr><td>  5、6 </td><td>  3个字节 </td></tr></tbody></table></div><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">日期和时间类型存储要求</a> </blockquote><p> 事实证明，如果选择三个小数位，那么您将无法充分利用占用的空间，并且对于相同的开销，您可能需要四个字符。 通常，我建议您在输出时始终使用偶数个字符，并在必要时“裁剪”不必要的字符。 理想的选择是不要贪婪，并保持小数点后六位。 在最坏的情况下（具有DATETIME类型），此列将占用8个字节，即与BIGINT列中的整数相同。 </p></div></div><br><p> 另请参阅： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“时间值的分数秒”</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ TIMESTAMP和DATETIME的自动初始化和更新”</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“日期和时间功能”</a> 。 </li></ul><br><h2 id="rabota-so-vremenem-vysokoy-tochnosti-v-php"> 在PHP中使用高精度时间 </h2><br><p> 在数据库中拥有高精度时间是不够的-您需要能够在程序代码中使用它。 在本节中，我将讨论三个要点： </p><br><ol><li> 接收和格式化时间：我将解释如何在将时间戳记放入数据库，从那里获取并进行某种操作之前获取时间戳。 </li><li> 在PDO中使用时间：我将向您展示一个示例，说明PHP如何支持数据库库中的时间格式化。 </li><li> 在框架中使用时间：我将讨论在迁移中使用时间来更改数据库的结构。 </li></ol><br><h3 id="poluchenie-i-formatirovanie-vremeni"> 获取和格式化时间 </h3><br><p> 在处理时间时，您需要执行一些基本操作： </p><br><ul><li> 获取当前时间点； </li><li> 从格式化的字符串中获取时间； </li><li> 在时间点上添加一个周期（或减去一个周期）； </li><li> 获取某个时间点的格式化字符串。 </li></ul><br><p> 在这一部分中，我将告诉您PHP中执行这些操作的可能性。 </p><br><p> 第一种方法是使用<strong>时间戳作为数字</strong> 。 在这种情况下，在PHP代码中，我们使用数值变量，这些变量通过诸如<code>time</code> ， <code>date</code>和<code>strtotime</code>函数进行操作。 此方法不能用于高精度时间，因为在所有这些函数中，时间戳均为整数（这意味着时间戳中的小数部分将丢失）。 </p><br><p> 以下是官方文档中主要此类功能的签名： </p><br><blockquote> <code>time ( void ) : int</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.php.net/manual/ru/function.time.php</a> <br><br> <code>strtotime ( string $time [, int $now = time() ] ) : int</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">http://php.net/manual/ru/function.strtotime.php</a> <br><br> <code>date ( string $format [, int $timestamp = time() ] ) : string</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://php.net/manual/ru/function.date.php</a> <br><br> <code>strftime ( string $format [, int $timestamp = time() ] ) : string</code> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.php.net/manual/ru/function.strftime.php</a> </blockquote><br><div class="spoiler">  <b class="spoiler_title">关于日期函数的有趣之处</b> <div class="spoiler_text"><p> 尽管不可能将秒的小数部分传递给这些函数的输入，但是在传递给<code>date</code>函数的输入的格式模板行中，您可以将字符设置为显示毫秒和微秒。 格式化时，零将始终返回其位置。 </p><br><div class="scrollable-table"><table><thead><tr><th> 字符串格式的字符 </th><th> 内容描述 </th><th> 返回值示例 </th></tr></thead><tbody><tr><td>  ü </td><td> 微秒（在PHP 5.2.2中添加）。 请注意，date（）将始终返回000000，因为 它使用一个整数参数，而DateTime :: format（）如果与它们一起创建DateTime，则支持微秒。 </td><td> 例如：654321 </td></tr><tr><td>  v </td><td> 毫秒（PHP 7.0.0中已添加）。 备注与您相同。 </td><td> 例如：654 </td></tr></tbody></table></div><br><p> 一个例子： </p><br><pre> <code class="php hljs">$now = time(); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> date(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>, $now); <span class="hljs-comment"><span class="hljs-comment">// 2019-09-11 21:27:18.000000 print date('Ymd H:i:s.v', $now); // 2019-09-11 21:27:18.000</span></span></code> </pre> </div></div><br><p> 此方法还包括<code>microtime</code>和<code>hrtime</code> ，这些<code>hrtime</code>使您可以获得当前时刻的带有小数部分的<code>hrtime</code> 。 问题在于尚无现成的方式来格式化这样的标签并从特定格式的字符串中获取它。 可以通过独立实现这些功能来解决，但我不会考虑这种选择。 </p><br><blockquote> 如果您只需要使用计时器，则<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HRTime</a>库是一个不错的选择，由于使用限制，我将不作详细介绍。 我只能说，它使您可以工作到十亿分之一秒的时间，并保证了计时器的单调性，从而消除了使用其他库时可能遇到的一些问题。 </blockquote><p> 要完全使用秒的小数部分，您需要使用<strong>DateTime</strong>模块。 进行某些保留后，您可以执行上面列出的所有操作： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//    : $time = new \DateTimeImmutable(); //      : $time = new \DateTimeImmutable('2019-09-12 21:32:43.908502'); $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43.9085'); // / : $period = \DateInterval::createFromDateString('5 seconds'); $timeBefore = $time-&gt;add($period); $timeAfter = $time-&gt;sub($period); //      : print $time-&gt;format('Ymd H:i:s.v'); // '2019-09-12 21:32:43.908' print $time-&gt;format("Ymd H:i:su"); // '2019-09-12 21:32:43.908502'</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">使用`DateTimeImmutable :: createFromFormat`时的非明显点</b> <div class="spoiler_text"><p> 格式字符串中的字母<code>u</code>表示微秒，但是在精度较低的小数部分的情况下也可以正常工作。 此外，这是在格式字符串中指定秒的小数部分的唯一方法。 一个例子： </p><br><pre> <code class="php hljs">$time = \DateTimeImmutable::createFromFormat(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>, <span class="hljs-string"><span class="hljs-string">'2019-09-12 21:32:43.9085'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt;   DateTimeImmutable    2019-09-12 21:32:43.908500 $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43.90'); // =&gt;   DateTimeImmutable    2019-09-12 21:32:43.900000 $time = \DateTimeImmutable::createFromFormat('Ymd H:i:s.u', '2019-09-12 21:32:43'); // =&gt;  false</span></span></code> </pre> </div></div><br><p> 该模块的主要问题是在处理包含小数秒的时间间隔时会带来不便（甚至无法进行此类工作）。  <code>\DateInterval</code>尽管它包含精确到小数点后六位的秒的小数部分<code>\DateInterval</code>但是您只能通过<code>DateTime::diff</code>初始化此小数部分。  DateInterval类的构造函数和工厂方法<code>\DateInterval::createFromDateString</code>仅可以整秒使用，并且不允许指定小数部分： </p><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//     -   $buggyPeriod1 = new \DateInterval('PT7.500S'); //       ,    $buggyPeriod2 = \DateInterval::createFromDateString('2 minutes 7.5 seconds'); print $buggyPeriod2-&gt;format('%R%H:%I:%S.%F') . PHP_EOL; //  "+00:02:00.000000"</span></span></code> </pre> <br><p> 使用<code>\DateTimeImmutable::diff</code>方法计算两个时间点之间的差异时，可能会出现另一个问题。 在7.2.12版之前的PHP中，存在一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误，</a>由于该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误</a> ，一秒钟的小数部分与其他数字分开存在，并且可能会收到自己的符号： </p><br><pre> <code class="php hljs">$timeBefore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2019-09-12 21:20:19.987654'</span></span>); $timeAfter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(<span class="hljs-string"><span class="hljs-string">'2019-09-14 12:13:14.123456'</span></span>); $diff = $timeBefore-&gt;diff($timeAfter); <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> $diff-&gt;format(<span class="hljs-string"><span class="hljs-string">'%R%a days %H:%I:%S.%F'</span></span>) . PHP_EOL; <span class="hljs-comment"><span class="hljs-comment">//  PHP  7.2.12+   "+1 days 14:52:54.135802" //       "+1 days 14:52:55.-864198"</span></span></code> </pre> <br><p> 通常，我建议您在使用间隔时要格外小心，并在测试中仔细覆盖此类代码。 </p><br><p> 另请参阅： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“日期和时间”</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“计时功能。”</a> </li></ul><br><h3 id="rabota-so-vremenem-vysokoy-tochnosti-v-pdo"> 在PDO中以高精度时间工作 </h3><br><p>  PDO和mysqli是从PHP代码查询MySQL数据库的两个主要接口。 在有关时间的对话中，它们彼此相似，因此我只谈论其中之一-PDO。 </p><br><p> 在PDO中使用数据库时，时间出现在两个地方： </p><br><ul><li> 作为传递给已执行查询的参数； </li><li> 作为响应SELECT查询的值。 </li></ul><br><p> 将参数传递给请求时，最好使用占位符。 占位符可以从很小的一组类型中传输值：布尔值，字符串和整数。 没有合适的日期和时间类型，因此您必须手动将值从DateTime / DateTimeImmutable类的对象转换为字符串。 </p><br><pre> <code class="php hljs">$now = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable(); $db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \PDO(<span class="hljs-string"><span class="hljs-string">'mysql:...'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>, [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]); $stmt = $db-&gt;prepare(<span class="hljs-string"><span class="hljs-string">'INSERT INTO Test.ChatContactsList (title, last_message_send_time) VALUES (:title, :date)'</span></span>); $result = $stmt-&gt;execute([<span class="hljs-string"><span class="hljs-string">':title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"Test #1"</span></span>, <span class="hljs-string"><span class="hljs-string">':date'</span></span> =&gt; $now-&gt;format(<span class="hljs-string"><span class="hljs-string">'Ymd H:i:s.u'</span></span>)]);</code> </pre> <br><p> 使用这样的代码不是很方便，因为每次您都需要格式化传输的值。 因此，在Badoo代码库中，我们在包装程序中实现了对类型化占位符的支持，以使用数据库。 对于日期而言，这非常方便，因为它允许您以不同的格式传输值（实现DateTimeInterface的对象，带格式的字符串或带有时间戳的数字），并且所有必需的转换和对传输值的正确性的检查都已在内部完成。 另外，当传递不正确的值时，我们会立即了解该错误，而不是在执行查询时从MySQL收到错误后才了解该错误。 </p><br><p> 从查询结果中检索数据看起来非常简单。 执行此操作时，PDO以字符串形式返回数据，并且在代码中，如果我们要使用时间对象，我们需要进一步处理结果（这里我们需要从格式化的字符串中获取时间的功能，这在上一节中已经讨论过）。 </p><br><pre> <code class="php hljs">$stmt = $db-&gt;prepare(<span class="hljs-string"><span class="hljs-string">'SELECT * FROM Test.ChatContactsList ORDER BY last_message_send_time DESC, chat_id DESC LIMIT 5'</span></span>); $stmt-&gt;execute(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($row = $stmt-&gt;fetch(PDO::FETCH_ASSOC)) { $row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>] = is_null($row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>]) ? <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \DateTimeImmutable($row[<span class="hljs-string"><span class="hljs-string">'last_message_send_time'</span></span>]); <span class="hljs-comment"><span class="hljs-comment">//  -  }</span></span></code> </pre> <br><blockquote> 注意事项 <br><br>  PDO将数据作为字符串返回的事实并不完全正确。 接收值时，可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>PDOStatement::bindColumn</code></a>设置列的值类型。 我之所以没有谈论这一点，是因为存在相同的有限类型集，这些类型对日期没有帮助。 </blockquote><p> 不幸的是，有一个问题要注意。 在版本7.3之前的PHP中，存在一个错误，由于该错误，如果<code>PDO::ATTR_EMULATE_PREPARES</code>了<code>PDO::ATTR_EMULATE_PREPARES</code>属性，则当从数据库接收到<code>PDO::ATTR_EMULATE_PREPARES</code>属性时<code>PDO::ATTR_EMULATE_PREPARES</code> “切断”该秒的小数部分。 可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在php.net上</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误描述中</a>找到详细信息和示例。 在PHP 7.3中，此错误已修复，并警告<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">该更改会破坏向后兼容性</a> 。 </p><br><p> 如果您使用的是PHP 7.2或更早版本，并且无法更新或启用<code>PDO::ATTR_EMULATE_PREPARES</code> ，则可以通过更正返回小数部分的返回时间的SQL查询来解决此错误，以便此列具有字符串类型。 例如，可以这样做： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> *, <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> last_message_send_time_fixed <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ChatContactsList <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> last_message_send_time <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p> 使用<code>mysqli</code>模块时也会遇到此问题：如果通过调用<code>mysqli::prepare</code>方法使用<code>mysqli</code>准备查询，则在7.3版之前的PHP中，将不返回小数部分。 与PDO一样，您可以通过更新PHP或绕过将时间转换为字符串类型来解决此问题。 </p><br><p> 另请参阅： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ PDO中准备好的查询和存储过程”</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“在mysqli中准备查询”</a> ； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">mysqli_stmt :: bind_param方法的文档</a> （此处描述了mysqli支持的占位符类型）； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">向PHP发出缓冲请求，在其中固定了秒的小数部分的“截断”</a> 。 </li></ul><br><h3 id="rabota-so-vremenem-vysokoy-tochnosti-v-yii-2"> 高精度工作在Yii 2 </h3><br><p> 大多数现代框架都提供了迁移功能，使您可以在代码中存储数据库架构更改的历史记录并进行增量更改。 如果您使用迁移并希望使用高精度时间，那么您的框架应该支持它。 幸运的是，这在所有主要框架中都是开箱即用的。 </p><br><p> 在本节中，我将展示如何在Yii中实现这种支持（在示例中，我使用的是2.0.26版）。 关于Laravel，Symfony和其他人，我不会写这篇文章以使文章永无止境，但是如果您在有关此主题的评论或新文章中添加详细信息，我将感到高兴。 </p><br><p> 在迁移中，我们编写描述数据模式更改的代码。 创建新表时，我们使用\ yii \ db \ Migration类中的特殊方法来描述其所有列（它们在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SchemaBuilderTrait托盘</a>中声明）。 可以采用准确性输入值的<code>time</code> ， <code>timestamp</code>和<code>datetime</code>方法负责描述包含日期和时间的列。 </p><br><p> 一个迁移示例，其中使用高精度时间列创建新表： </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">yii</span></span>\<span class="hljs-title"><span class="hljs-title">db</span></span>\<span class="hljs-title"><span class="hljs-title">Migration</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m190914_141123_create_news_table</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Migration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;createTable(<span class="hljs-string"><span class="hljs-string">'news'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;primaryKey(), <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;string()-&gt;notNull(), <span class="hljs-string"><span class="hljs-string">'content'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;text(), <span class="hljs-string"><span class="hljs-string">'published'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-comment"><span class="hljs-comment">//     ]); } public function down() { $this-&gt;dropTable('news'); } }</span></span></code> </pre> <br><p> 这是一个迁移示例，其中现有列的准确性发生了变化： </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m190916_045702_change_news_time_precision</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Migration</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">up</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;alterColumn( <span class="hljs-string"><span class="hljs-string">'news'</span></span>, <span class="hljs-string"><span class="hljs-string">'published'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">6</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">down</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;alterColumn( <span class="hljs-string"><span class="hljs-string">'news'</span></span>, <span class="hljs-string"><span class="hljs-string">'published'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;timestamp(<span class="hljs-number"><span class="hljs-number">3</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p>       ActiveRecord     -  :          ,         DateTime-.  ,     —    «»      <code>PDO::ATTR_EMULATE_PREPARES</code> .   Yii    ,        .   ,       ,        PDO. </p><br><p> . : </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">    Yii 2</a> ; </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  SchemaBuilderTrait</a> . </li></ul><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> ,   ,     —  ,     .                 ,    ,    . ,    ! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN469615/">https://habr.com/ru/post/zh-CN469615/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN469599/index.html">在WinForms上汇报开发2D引擎</a></li>
<li><a href="../zh-CN469605/index.html">Li-Fi的未来：极化子，激子，光子和一些二硫化钨</a></li>
<li><a href="../zh-CN469607/index.html">人类意识。 无法传输副本？</a></li>
<li><a href="../zh-CN469609/index.html">请上网</a></li>
<li><a href="../zh-CN469613/index.html">关于国家数据管理系统</a></li>
<li><a href="../zh-CN469617/index.html">破坏美国在EDA中的垄断地位。 Innopolis迈出第一步</a></li>
<li><a href="../zh-CN469619/index.html">研究：如果买家知道他正在与聊天机器人聊天，那么购买将根本不会进行</a></li>
<li><a href="../zh-CN469623/index.html">具有Web应用程序防火墙和性能分析的GitLab 12.3</a></li>
<li><a href="../zh-CN469625/index.html">我们如何从在线平台上收集有关广告活动的数据（产品的棘手路径）</a></li>
<li><a href="../zh-CN469629/index.html">并非每个家庭都拥有和平原子：放射性核素能源的出乎意料的选择</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>