<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî£ üë´ üïô Rust 1.30 Release üßöüèø üê† üßíüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Rust-Entwicklungsteam freut sich, die Ver√∂ffentlichung einer neuen Version von Rust bekannt zu geben: 1.30.0. Rust ist eine Systemprogrammiersprac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.30 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428073/"><p>  Das Rust-Entwicklungsteam freut sich, die Ver√∂ffentlichung einer neuen Version von Rust bekannt zu geben: 1.30.0.  Rust ist eine Systemprogrammiersprache, die auf Sicherheit, Geschwindigkeit und parallele Codeausf√ºhrung abzielt. </p><br><p> Wenn Sie eine fr√ºhere Version von Rust mit <code>rustup</code> installiert <code>rustup</code> , m√ºssen Sie nur Folgendes tun, um Rust auf Version 1.30.0 zu aktualisieren: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Wenn Sie <code>rustup</code> noch nicht installiert <code>rustup</code> , k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es</a> von der entsprechenden Seite unserer Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installieren</a> .  <a href="">Detaillierte Versionshinweise f√ºr Rust 1.30.0</a> sind auf GitHub verf√ºgbar. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1300">  Was ist in der stabilen Version 1.30.0 enthalten </h2><br><p>  Rust 1.30 ist eine herausragende Ver√∂ffentlichung mit einer Reihe wichtiger Innovationen.  Am Montag wird im offiziellen Blog eine Anfrage zur √úberpr√ºfung der Beta-Version von Rust 1.31 ver√∂ffentlicht, der ersten Ver√∂ffentlichung von "Rust 2018".  Weitere Informationen hierzu finden Sie in unserer vorherigen Ver√∂ffentlichung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûWhat is Rust 2018‚Äú</a> . </p><br><h3 id="procedurnye-makrosy">  Prozedurale Makros </h3><br><p>  Zur√ºck in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust 1.15 haben</a> wir die M√∂glichkeit hinzugef√ºgt, "benutzerdefinierte Ableitungsmakros" zu definieren.  Mit <code>serde_derive</code> k√∂nnen Sie beispielsweise <code>serde_derive</code> deklarieren: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  Und konvertieren Sie <code>Pet</code> mit <code>serde_json</code> in JSON und zur√ºck in die Struktur.  Dies ist dank der automatischen Inferenz von <code>Serialize</code> und <code>Deserialize</code> mithilfe von prozeduralen Makros in <code>serde_derive</code> . </p><br><p>  Rust 1.30 erweitert die Funktionalit√§t von prozeduralen Makros um die M√∂glichkeit, zwei weitere Arten von Makros zu definieren: "Attribut prozedurale Makros" und "funktionale prozedurale Makros". </p><a name="habracut"></a><br><p>  Attributmakros √§hneln dem Ableiten von Makros f√ºr die automatische Ausgabe, aber anstatt Code nur f√ºr das Attribut <code>#[derive]</code> generieren, k√∂nnen Benutzer ihre eigenen neuen Attribute erstellen.  Dies macht sie flexibler: Ableiten von Makros funktioniert nur f√ºr Strukturen und Aufz√§hlungen, Attribute k√∂nnen jedoch auch auf andere Objekte wie Funktionen angewendet werden.  Mit Attributmakros k√∂nnen Sie beispielsweise Folgendes verwenden, wenn Sie ein Webframework verwenden: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[route(GET, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>() {</code> </pre> <br><p>  Dieses Attribut <code>#[route]</code> wird im Framework selbst als prozedurales Makro definiert.  Seine Unterschrift wird so aussehen: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro_attribute]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">route</span></span></span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Hier haben wir zwei Eingabeparameter vom Typ <code>TokenStream</code> : Der erste <code>TokenStream</code> sich auf den Inhalt des Attributs selbst, <code>TokenStream</code> die Parameter <code>GET, "/"</code> .  Der zweite ist der Hauptteil des Objekts, auf das das Attribut angewendet wird.  In unserem Fall ist dies <code>fn index() {}</code> und der Rest des Funktionsk√∂rpers. </p><br><p>  Funktionsmakros definieren Makros, deren Verwendung wie ein Funktionsaufruf aussieht.  Zum Beispiel das <code>sql!</code>  :: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sql = sql!(SELECT * FROM posts WHERE id=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Dieses Makro in sich selbst analysiert SQL-Ausdr√ºcke und √ºberpr√ºft sie auf syntaktische Korrektheit.  Ein √§hnliches Makro sollte wie folgt deklariert werden: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sql</span></span></span></span>(input: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Dies √§hnelt der Signatur des Ableitungsmakros: Wir erhalten die Token in den Klammern und geben den von ihnen generierten Code zur√ºck. </p><br><h3 id="makrosy-i-use">  Makros und <code>use</code> </h3><br><p>  Jetzt k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makros mit dem Schl√ºsselwort use in den Bereich importieren</a> .  Um beispielsweise das <code>json</code> Makro aus dem <code>serde-json</code> Paket zu verwenden, <code>serde-json</code> der Eintrag fr√ºher: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Und jetzt m√ºssen Sie schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_json::json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Hier werden das Makro sowie andere Elemente importiert, sodass die Annotation <code>macro_use</code> nicht verwendet werden <code>macro_use</code> . </p><br><p>  Schlie√ülich wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Paket proc_macro stabilisiert</a> , das die zum Schreiben von prozeduralen Makros erforderliche API bereitstellt.  Au√üerdem wurde die Fehlerbehandlungs-API erheblich verbessert, und Pakete wie <code>syn</code> und <code>quote</code> verwenden sie bereits.  Zum Beispiel fr√ºher: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span> { ok: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, bad: std::thread::Thread, }</code> </pre> <br><p>  f√ºhrte zu diesem Fehler: </p><br><pre> <code class="hljs rust">error[E0277]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bound</span></span></span></span> `std::thread::Thread: _IMPL_SERIALIZE_FOR_Demo::_serde::Serialize` is not satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> | ^^^^^^^^^ the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_IMPL_SERIALIZE_FOR_Demo</span></span></span></span>::_serde::Serialize` is not implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `std::thread::Thread`</code> </pre> <br><p>  Jetzt wird es ausgestellt: </p><br><pre> <code class="hljs cpp">error[E0277]: the trait bound `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread: serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">7</span></span> | bad: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread, | ^^^ the trait `serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread`</code> </pre> <br><h2 id="uluchshenie-sistemy-moduley">  Verbesserung des Modulsystems </h2><br><p>  Das Modulsystem ist seit langem ein wunder Punkt f√ºr Anf√§nger in Rust;  Einige seiner Regeln waren in der Praxis unpraktisch.  Diese √Ñnderungen sind der erste Schritt zur Vereinfachung des Modulsystems. </p><br><p>  Zus√§tzlich zu der obigen √Ñnderung f√ºr Makros gibt es zwei neue Verbesserungen f√ºr die <code>use</code> .  Zun√§chst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden jetzt externe Pakete zum Vorspiel hinzugef√ºgt</a> , d. H. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  let json = ::serde_json::from_str("..."); //  let json = serde_json::from_str("...");</span></span></code> </pre> <br><p>  Der Haken ist, dass der alte Stil aufgrund der Merkmale des Rust-Modulsystems nicht immer ben√∂tigt wurde: </p><br><pre> <code class="hljs powershell">extern crate serde_json; fn main() { //   ;     ,  `serde_json` //     let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } mod foo { fn bar() { //   ;     `foo`,  `serde_json` //    let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } //   -        `use` use serde_json; fn baz() { //   -   `::serde_json`,   //  ,   let json = ::serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } }</code> </pre> <br><p>  Es war √§rgerlich, fehlerhaften Code zu erhalten, indem die Funktion einfach in ein Submodul verschoben wurde.  Jetzt wird der erste Teil des Pfades √ºberpr√ºft, und wenn er einer <code>extern crate</code> , wird er unabh√§ngig von der Position des Aufrufs in der Modulhierarchie verwendet. </p><br><p>  Schlie√ülich begann die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung, den Import von Elementen in den aktuellen Bereich mit Pfaden zu unterst√ºtzen, die auf der Kiste beginnen</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } //  use ::foo::bar; //  use foo::bar; //  use crate::foo::bar;</span></span></code> </pre> <br><p>  Das Schl√ºsselwort crate am Anfang des Pfads gibt an, dass der Pfad am Stammverzeichnis des Pakets beginnt.  Bisher wurden die in der Importzeile f√ºr die <code>use</code> angegebenen Pfade immer relativ zum Stammverzeichnis des Pakets angegeben. Die Pfade im Rest des Codes, die direkt auf die Elemente verweisen, wurden jedoch relativ zum aktuellen Modul angegeben, was zu einem inkonsistenten Verhalten der Pfade f√ºhrte: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } mod baz { pub fn qux() { //  ::foo::bar(); //  ,    `use`: // foo::bar(); //  crate::foo::bar(); } }</span></span></code> </pre> <br><p>  Sobald der neue Stil weit verbreitet ist, werden hoffentlich die absoluten Pfade klarer, ohne dass das h√§ssliche Pr√§fix <code>::</code> . </p><br><p>  Alle diese √Ñnderungen zusammen vereinfachen das Verst√§ndnis, wie Pfade aufgel√∂st werden.  Wo immer Sie den Pfad <code>a::b::c</code> , mit Ausnahme der <code>use</code> Anweisung, k√∂nnen Sie fragen: </p><br><ul><li>  Ist <code>a</code> Paketname?  Dann m√ºssen Sie darin nach <code>b::c</code> suchen. </li><li>  Ist <code>a</code> Keyword- <code>crate</code> ?  Dann m√ºssen Sie im Stammverzeichnis des aktuellen Pakets nach <code>b::c</code> suchen. </li><li>  Andernfalls m√ºssen Sie an der aktuellen Position in der Modulhierarchie nach <code>a::b::c</code> suchen. </li></ul><br><p>  Das alte Verhalten der verwendeten Pfade, das immer am Stammverzeichnis des Pakets beginnt, ist weiterhin anwendbar.  Bei einem einmaligen √úbergang zu einem neuen Stil werden diese Regeln jedoch √ºberall einheitlich auf Pfade angewendet, und Sie m√ºssen sich beim Verschieben von Code weniger um Importe k√ºmmern. </p><br><h2 id="syrye-identifikatory">  Rohe Bezeichner </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie k√∂nnen jetzt Schl√ºsselw√∂rter als Bezeichner</a> mit der folgenden neuen Syntax verwenden: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      `for` let r#for = true; //     `for` fn r#for() { // ... } //    r#for();</span></span></code> </pre> <br><p>  Bisher gibt es nicht viele F√§lle, in denen dies f√ºr Sie n√ºtzlich ist.  Aber eines Tages werden Sie versuchen, das Paket f√ºr Rust 2015 in einem Projekt f√ºr Rust 2018 zu verwenden oder umgekehrt, dann werden die Schl√ºsselw√∂rter anders sein.  Wir werden in der kommenden Ank√ºndigung von Rust 2018 mehr dar√ºber sprechen. </p><br><h2 id="prilozheniya-bez-standartnoy-biblioteki">  Anwendungen ohne Standardbibliothek </h2><br><p>  Zur√ºck in Rust 1.6 haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stabilisierung von "no_std" und libcore angek√ºndigt</a> , um Projekte ohne Standardbibliothek zu erstellen.  Mit einer Klarstellung: Es war m√∂glich, nur Bibliotheken, aber keine Anwendungen zu erstellen. </p><br><p>  In Rust 1.30 k√∂nnen Sie das Attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>#[panic_handler]</code></a> , um Panik unabh√§ngig zu implementieren.  Dies bedeutet, dass Sie jetzt Anwendungen erstellen k√∂nnen, nicht nur Bibliotheken, die die Standardbibliothek nicht verwenden. </p><br><h2 id="drugoe">  Andere </h2><br><p>  Eine letzte Sache: In Makros k√∂nnen Sie jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereichsmodifikatoren</a> wie <code>pub</code> mithilfe des <code>vis</code> Qualifikators <code>vis</code> .  Au√üerdem werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jetzt</a> "Werkzeugattribute" wie <code>#[rustfmt::skip]</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stabilisiert</a> .  F√ºr <em>statische Analysewerkzeuge</em> wie <code>#[allow(clippy::something)]</code> sind sie noch nicht stabil. </p><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisierung der Standardbibliothek </h3><br><p>  Die <a href="">folgenden APIs</a> wurden in dieser Version <a href="">stabilisiert</a> : </p><br><ul><li> <code>Ipv4Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Ipv6Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Iterator::find_map</code> </li> </ul><br><p>  Dar√ºber hinaus verf√ºgt die Standardbibliothek seit langem √ºber Funktionen zum Entfernen von Leerzeichen auf einer Seite eines Texts, z. B. <code>trim_left</code> .  Bei RTL-Sprachen f√ºhrt die Bedeutung von ‚Äûrechts‚Äú und ‚Äûlinks‚Äú hier jedoch zu Verwirrung.  Daher f√ºhren wir neue Namen f√ºr diese Funktionen ein: </p><br><ul><li>  <code>trim_left</code> -&gt; <code>trim_start</code> </li><li>  <code>trim_right</code> -&gt; <code>trim_end</code> </li><li>  <code>trim_left_matches</code> -&gt; <code>trim_start_matches</code> </li><li>  <code>trim_right_matches</code> -&gt; <code>trim_end_matches</code> </li></ul><br><p>  Wir planen, die alten Namen in Rust 1.33 f√ºr veraltet zu erkl√§ren (aber nat√ºrlich nicht zu l√∂schen). </p><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h3 id="uluchsheniya-v-cargo">  Frachtverbesserungen </h3><br><p>  Die gr√∂√üte Verbesserung von Cargo in dieser Version ist, dass wir jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Fortschrittsbalken haben!</a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/84f/4ce/626/84f4ce6263525deded821b6007735dec.gif" alt="Demo GIF"></p><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h2 id="razrabotchiki-1300">  Entwickler 1.30.0 </h2><br><p>  Viele Leute haben zusammen Rust 1.30 erstellt.  Ohne jeden von Ihnen h√§tten wir die Arbeit nicht abschlie√üen k√∂nnen.  <a href="">Vielen Dank!</a> </p><br><p>  <em>Von einem √úbersetzer: Ich danke den Mitgliedern der Rustycrate-Community und pers√∂nlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">vitvakatu</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Virtuos86</a> f√ºr ihre Hilfe bei der √úbersetzung und beim Korrekturlesen.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428073/">https://habr.com/ru/post/de428073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428061/index.html">Projektkosten mit Earned Value Management verwalten</a></li>
<li><a href="../de428063/index.html">Browser verweigern die Unterst√ºtzung f√ºr TLS 1.0 und 1.1</a></li>
<li><a href="../de428065/index.html">Weniger bedeutet nicht schlimmer: Skyrmionen und Dom√§nenw√§nde in Ferromagneten</a></li>
<li><a href="../de428067/index.html">AntiFuzzing: Sicherheit durch Dunkelheit !?</a></li>
<li><a href="../de428069/index.html">Optimieren Sie den Lastausgleich in der Veeam Backup & Replication-Infrastruktur</a></li>
<li><a href="../de428075/index.html">Trotzdem kannst du es nicht tun! - Verwenden von Schnittstellen und Abh√§ngigkeitsinjektion f√ºr das langfristige Design</a></li>
<li><a href="../de428077/index.html">React.js: Ein Leitfaden f√ºr Anf√§nger</a></li>
<li><a href="../de428079/index.html">Anwendung von SOLID-Prinzipien zur Reaktion auf die Anwendungsentwicklung</a></li>
<li><a href="../de428081/index.html">Verwenden von RxJS in der Reaktionsentwicklung zum Verwalten des Anwendungsstatus</a></li>
<li><a href="../de428083/index.html">Webanalyse beeinflusst Matrix - das strategische System von Avinash Koshik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>