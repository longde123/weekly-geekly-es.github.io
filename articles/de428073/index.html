<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔣 👫 🕙 Rust 1.30 Release 🧚🏿 🐠 🧒🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Rust-Entwicklungsteam freut sich, die Veröffentlichung einer neuen Version von Rust bekannt zu geben: 1.30.0. Rust ist eine Systemprogrammiersprac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.30 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428073/"><p>  Das Rust-Entwicklungsteam freut sich, die Veröffentlichung einer neuen Version von Rust bekannt zu geben: 1.30.0.  Rust ist eine Systemprogrammiersprache, die auf Sicherheit, Geschwindigkeit und parallele Codeausführung abzielt. </p><br><p> Wenn Sie eine frühere Version von Rust mit <code>rustup</code> installiert <code>rustup</code> , müssen Sie nur Folgendes tun, um Rust auf Version 1.30.0 zu aktualisieren: </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Wenn Sie <code>rustup</code> noch nicht installiert <code>rustup</code> , können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es</a> von der entsprechenden Seite unserer Website <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installieren</a> .  <a href="">Detaillierte Versionshinweise für Rust 1.30.0</a> sind auf GitHub verfügbar. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1300">  Was ist in der stabilen Version 1.30.0 enthalten </h2><br><p>  Rust 1.30 ist eine herausragende Veröffentlichung mit einer Reihe wichtiger Innovationen.  Am Montag wird im offiziellen Blog eine Anfrage zur Überprüfung der Beta-Version von Rust 1.31 veröffentlicht, der ersten Veröffentlichung von "Rust 2018".  Weitere Informationen hierzu finden Sie in unserer vorherigen Veröffentlichung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„What is Rust 2018“</a> . </p><br><h3 id="procedurnye-makrosy">  Prozedurale Makros </h3><br><p>  Zurück in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rust 1.15 haben</a> wir die Möglichkeit hinzugefügt, "benutzerdefinierte Ableitungsmakros" zu definieren.  Mit <code>serde_derive</code> können Sie beispielsweise <code>serde_derive</code> deklarieren: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize, Debug)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span></span> { name: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, }</code> </pre> <br><p>  Und konvertieren Sie <code>Pet</code> mit <code>serde_json</code> in JSON und zurück in die Struktur.  Dies ist dank der automatischen Inferenz von <code>Serialize</code> und <code>Deserialize</code> mithilfe von prozeduralen Makros in <code>serde_derive</code> . </p><br><p>  Rust 1.30 erweitert die Funktionalität von prozeduralen Makros um die Möglichkeit, zwei weitere Arten von Makros zu definieren: "Attribut prozedurale Makros" und "funktionale prozedurale Makros". </p><a name="habracut"></a><br><p>  Attributmakros ähneln dem Ableiten von Makros für die automatische Ausgabe, aber anstatt Code nur für das Attribut <code>#[derive]</code> generieren, können Benutzer ihre eigenen neuen Attribute erstellen.  Dies macht sie flexibler: Ableiten von Makros funktioniert nur für Strukturen und Aufzählungen, Attribute können jedoch auch auf andere Objekte wie Funktionen angewendet werden.  Mit Attributmakros können Sie beispielsweise Folgendes verwenden, wenn Sie ein Webframework verwenden: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[route(GET, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span></span>() {</code> </pre> <br><p>  Dieses Attribut <code>#[route]</code> wird im Framework selbst als prozedurales Makro definiert.  Seine Unterschrift wird so aussehen: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro_attribute]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">route</span></span></span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Hier haben wir zwei Eingabeparameter vom Typ <code>TokenStream</code> : Der erste <code>TokenStream</code> sich auf den Inhalt des Attributs selbst, <code>TokenStream</code> die Parameter <code>GET, "/"</code> .  Der zweite ist der Hauptteil des Objekts, auf das das Attribut angewendet wird.  In unserem Fall ist dies <code>fn index() {}</code> und der Rest des Funktionskörpers. </p><br><p>  Funktionsmakros definieren Makros, deren Verwendung wie ein Funktionsaufruf aussieht.  Zum Beispiel das <code>sql!</code>  :: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sql = sql!(SELECT * FROM posts WHERE id=<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br><p>  Dieses Makro in sich selbst analysiert SQL-Ausdrücke und überprüft sie auf syntaktische Korrektheit.  Ein ähnliches Makro sollte wie folgt deklariert werden: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[proc_macro]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sql</span></span></span></span>(input: TokenStream) -&gt; TokenStream {</code> </pre> <br><p>  Dies ähnelt der Signatur des Ableitungsmakros: Wir erhalten die Token in den Klammern und geben den von ihnen generierten Code zurück. </p><br><h3 id="makrosy-i-use">  Makros und <code>use</code> </h3><br><p>  Jetzt können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Makros mit dem Schlüsselwort use in den Bereich importieren</a> .  Um beispielsweise das <code>json</code> Makro aus dem <code>serde-json</code> Paket zu verwenden, <code>serde-json</code> der Eintrag früher: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Und jetzt müssen Sie schreiben: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_json::json; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> john = json!({ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"John Doe"</span></span>, <span class="hljs-string"><span class="hljs-string">"age"</span></span>: <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-string"><span class="hljs-string">"phones"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"+44 1234567"</span></span>, <span class="hljs-string"><span class="hljs-string">"+44 2345678"</span></span> ] });</code> </pre> <br><p>  Hier werden das Makro sowie andere Elemente importiert, sodass die Annotation <code>macro_use</code> nicht verwendet werden <code>macro_use</code> . </p><br><p>  Schließlich wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Paket proc_macro stabilisiert</a> , das die zum Schreiben von prozeduralen Makros erforderliche API bereitstellt.  Außerdem wurde die Fehlerbehandlungs-API erheblich verbessert, und Pakete wie <code>syn</code> und <code>quote</code> verwenden sie bereits.  Zum Beispiel früher: </p><br><pre> <code class="hljs rust"><span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Demo</span></span></span></span> { ok: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>, bad: std::thread::Thread, }</code> </pre> <br><p>  führte zu diesem Fehler: </p><br><pre> <code class="hljs rust">error[E0277]: the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bound</span></span></span></span> `std::thread::Thread: _IMPL_SERIALIZE_FOR_Demo::_serde::Serialize` is not satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">3</span></span> | <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize)]</span></span> | ^^^^^^^^^ the <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> `</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_IMPL_SERIALIZE_FOR_Demo</span></span></span></span>::_serde::Serialize` is not implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `std::thread::Thread`</code> </pre> <br><p>  Jetzt wird es ausgestellt: </p><br><pre> <code class="hljs cpp">error[E0277]: the trait bound `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread: serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied --&gt; src/main.rs:<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">5</span></span> | <span class="hljs-number"><span class="hljs-number">7</span></span> | bad: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread, | ^^^ the trait `serde::Serialize` is <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> implemented <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> `<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::Thread`</code> </pre> <br><h2 id="uluchshenie-sistemy-moduley">  Verbesserung des Modulsystems </h2><br><p>  Das Modulsystem ist seit langem ein wunder Punkt für Anfänger in Rust;  Einige seiner Regeln waren in der Praxis unpraktisch.  Diese Änderungen sind der erste Schritt zur Vereinfachung des Modulsystems. </p><br><p>  Zusätzlich zu der obigen Änderung für Makros gibt es zwei neue Verbesserungen für die <code>use</code> .  Zunächst <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden jetzt externe Pakete zum Vorspiel hinzugefügt</a> , d. H. </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  let json = ::serde_json::from_str("..."); //  let json = serde_json::from_str("...");</span></span></code> </pre> <br><p>  Der Haken ist, dass der alte Stil aufgrund der Merkmale des Rust-Modulsystems nicht immer benötigt wurde: </p><br><pre> <code class="hljs powershell">extern crate serde_json; fn main() { //   ;     ,  `serde_json` //     let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } mod foo { fn bar() { //   ;     `foo`,  `serde_json` //    let json = serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } //   -        `use` use serde_json; fn baz() { //   -   `::serde_json`,   //  ,   let json = ::serde_json::from_str(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); } }</code> </pre> <br><p>  Es war ärgerlich, fehlerhaften Code zu erhalten, indem die Funktion einfach in ein Submodul verschoben wurde.  Jetzt wird der erste Teil des Pfades überprüft, und wenn er einer <code>extern crate</code> , wird er unabhängig von der Position des Aufrufs in der Modulhierarchie verwendet. </p><br><p>  Schließlich begann die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verwendung, den Import von Elementen in den aktuellen Bereich mit Pfaden zu unterstützen, die auf der Kiste beginnen</a> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } //  use ::foo::bar; //  use foo::bar; //  use crate::foo::bar;</span></span></code> </pre> <br><p>  Das Schlüsselwort crate am Anfang des Pfads gibt an, dass der Pfad am Stammverzeichnis des Pakets beginnt.  Bisher wurden die in der Importzeile für die <code>use</code> angegebenen Pfade immer relativ zum Stammverzeichnis des Pakets angegeben. Die Pfade im Rest des Codes, die direkt auf die Elemente verweisen, wurden jedoch relativ zum aktuellen Modul angegeben, was zu einem inkonsistenten Verhalten der Pfade führte: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> foo { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ... } } mod baz { pub fn qux() { //  ::foo::bar(); //  ,    `use`: // foo::bar(); //  crate::foo::bar(); } }</span></span></code> </pre> <br><p>  Sobald der neue Stil weit verbreitet ist, werden hoffentlich die absoluten Pfade klarer, ohne dass das hässliche Präfix <code>::</code> . </p><br><p>  Alle diese Änderungen zusammen vereinfachen das Verständnis, wie Pfade aufgelöst werden.  Wo immer Sie den Pfad <code>a::b::c</code> , mit Ausnahme der <code>use</code> Anweisung, können Sie fragen: </p><br><ul><li>  Ist <code>a</code> Paketname?  Dann müssen Sie darin nach <code>b::c</code> suchen. </li><li>  Ist <code>a</code> Keyword- <code>crate</code> ?  Dann müssen Sie im Stammverzeichnis des aktuellen Pakets nach <code>b::c</code> suchen. </li><li>  Andernfalls müssen Sie an der aktuellen Position in der Modulhierarchie nach <code>a::b::c</code> suchen. </li></ul><br><p>  Das alte Verhalten der verwendeten Pfade, das immer am Stammverzeichnis des Pakets beginnt, ist weiterhin anwendbar.  Bei einem einmaligen Übergang zu einem neuen Stil werden diese Regeln jedoch überall einheitlich auf Pfade angewendet, und Sie müssen sich beim Verschieben von Code weniger um Importe kümmern. </p><br><h2 id="syrye-identifikatory">  Rohe Bezeichner </h2><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie können jetzt Schlüsselwörter als Bezeichner</a> mit der folgenden neuen Syntax verwenden: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      `for` let r#for = true; //     `for` fn r#for() { // ... } //    r#for();</span></span></code> </pre> <br><p>  Bisher gibt es nicht viele Fälle, in denen dies für Sie nützlich ist.  Aber eines Tages werden Sie versuchen, das Paket für Rust 2015 in einem Projekt für Rust 2018 zu verwenden oder umgekehrt, dann werden die Schlüsselwörter anders sein.  Wir werden in der kommenden Ankündigung von Rust 2018 mehr darüber sprechen. </p><br><h2 id="prilozheniya-bez-standartnoy-biblioteki">  Anwendungen ohne Standardbibliothek </h2><br><p>  Zurück in Rust 1.6 haben wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stabilisierung von "no_std" und libcore angekündigt</a> , um Projekte ohne Standardbibliothek zu erstellen.  Mit einer Klarstellung: Es war möglich, nur Bibliotheken, aber keine Anwendungen zu erstellen. </p><br><p>  In Rust 1.30 können Sie das Attribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>#[panic_handler]</code></a> , um Panik unabhängig zu implementieren.  Dies bedeutet, dass Sie jetzt Anwendungen erstellen können, nicht nur Bibliotheken, die die Standardbibliothek nicht verwenden. </p><br><h2 id="drugoe">  Andere </h2><br><p>  Eine letzte Sache: In Makros können Sie jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bereichsmodifikatoren</a> wie <code>pub</code> mithilfe des <code>vis</code> Qualifikators <code>vis</code> .  Außerdem werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jetzt</a> "Werkzeugattribute" wie <code>#[rustfmt::skip]</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stabilisiert</a> .  Für <em>statische Analysewerkzeuge</em> wie <code>#[allow(clippy::something)]</code> sind sie noch nicht stabil. </p><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h3 id="stabilizaciya-standartnoy-biblioteki">  Stabilisierung der Standardbibliothek </h3><br><p>  Die <a href="">folgenden APIs</a> wurden in dieser Version <a href="">stabilisiert</a> : </p><br><ul><li> <code>Ipv4Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Ipv6Addr::{BROADCAST, LOCALHOST, UNSPECIFIED}</code> </li> <li> <code>Iterator::find_map</code> </li> </ul><br><p>  Darüber hinaus verfügt die Standardbibliothek seit langem über Funktionen zum Entfernen von Leerzeichen auf einer Seite eines Texts, z. B. <code>trim_left</code> .  Bei RTL-Sprachen führt die Bedeutung von „rechts“ und „links“ hier jedoch zu Verwirrung.  Daher führen wir neue Namen für diese Funktionen ein: </p><br><ul><li>  <code>trim_left</code> -&gt; <code>trim_start</code> </li><li>  <code>trim_right</code> -&gt; <code>trim_end</code> </li><li>  <code>trim_left_matches</code> -&gt; <code>trim_start_matches</code> </li><li>  <code>trim_right_matches</code> -&gt; <code>trim_end_matches</code> </li></ul><br><p>  Wir planen, die alten Namen in Rust 1.33 für veraltet zu erklären (aber natürlich nicht zu löschen). </p><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h3 id="uluchsheniya-v-cargo">  Frachtverbesserungen </h3><br><p>  Die größte Verbesserung von Cargo in dieser Version ist, dass wir jetzt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Fortschrittsbalken haben!</a> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/84f/4ce/626/84f4ce6263525deded821b6007735dec.gif" alt="Demo GIF"></p><br><p>  Weitere <a href="">Informationen finden Sie in den</a> Versionshinweisen. </p><br><h2 id="razrabotchiki-1300">  Entwickler 1.30.0 </h2><br><p>  Viele Leute haben zusammen Rust 1.30 erstellt.  Ohne jeden von Ihnen hätten wir die Arbeit nicht abschließen können.  <a href="">Vielen Dank!</a> </p><br><p>  <em>Von einem Übersetzer: Ich danke den Mitgliedern der Rustycrate-Community und persönlich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">vitvakatu</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Virtuos86</a> für ihre Hilfe bei der Übersetzung und beim Korrekturlesen.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428073/">https://habr.com/ru/post/de428073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428061/index.html">Projektkosten mit Earned Value Management verwalten</a></li>
<li><a href="../de428063/index.html">Browser verweigern die Unterstützung für TLS 1.0 und 1.1</a></li>
<li><a href="../de428065/index.html">Weniger bedeutet nicht schlimmer: Skyrmionen und Domänenwände in Ferromagneten</a></li>
<li><a href="../de428067/index.html">AntiFuzzing: Sicherheit durch Dunkelheit !?</a></li>
<li><a href="../de428069/index.html">Optimieren Sie den Lastausgleich in der Veeam Backup & Replication-Infrastruktur</a></li>
<li><a href="../de428075/index.html">Trotzdem kannst du es nicht tun! - Verwenden von Schnittstellen und Abhängigkeitsinjektion für das langfristige Design</a></li>
<li><a href="../de428077/index.html">React.js: Ein Leitfaden für Anfänger</a></li>
<li><a href="../de428079/index.html">Anwendung von SOLID-Prinzipien zur Reaktion auf die Anwendungsentwicklung</a></li>
<li><a href="../de428081/index.html">Verwenden von RxJS in der Reaktionsentwicklung zum Verwalten des Anwendungsstatus</a></li>
<li><a href="../de428083/index.html">Webanalyse beeinflusst Matrix - das strategische System von Avinash Koshik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>