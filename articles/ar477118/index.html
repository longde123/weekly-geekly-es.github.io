<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔹 👩🏽‍🎨 👧 MIRO عبارة عن منصة روبوت داخلية مفتوحة. الجزء 5 - مكون البرنامج: ARDUINO (AVR) ، نحن تسلق "تحت غطاء محرك السيارة" ☠️ 👩🏻‍✈️ 🔲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="هذه المرة ، لنلقي نظرة أعمق قليلاً على تنفيذ بعض أساليب المكتبة الرئيسية لـ ARDUINO (AVR) ، المسؤولة عن تحريك الروبوت MIRO. سيكون هذا الجزء ممتعًا لكل...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIRO عبارة عن منصة روبوت داخلية مفتوحة. الجزء 5 - مكون البرنامج: ARDUINO (AVR) ، نحن تسلق "تحت غطاء محرك السيارة"</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/477118/" style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/m-/j7/gm/m-j7gmvwywlwzlopp5x-27y_jta.png" alt="صورة"><br><br>  هذه المرة ، لنلقي نظرة أعمق قليلاً على تنفيذ بعض أساليب المكتبة الرئيسية لـ ARDUINO (AVR) ، المسؤولة عن تحريك الروبوت MIRO.  سيكون هذا الجزء ممتعًا لكل من تساءل عن كيفية التحكم في السرعة الخطية والزاوية للروبوت على ARDUINO ، المزودة بمحركات بأبسط برامج التشفير. <br><a name="habracut"></a><br>  جدول المحتويات: <a href="https://habr.com/ru/post/472380/">الجزء 1</a> ، <a href="https://habr.com/ru/post/472802/">الجزء 2</a> ، <a href="https://habr.com/ru/post/473368/">الجزء 3</a> ، <a href="https://habr.com/ru/post/475512/">الجزء 4</a> ، <a href="https://habr.com/ru/post/477118/">الجزء 5</a> . <br><br>  لا تزال الطرق المسؤولة عن القيادة مع قياس المسافات عبارة عن ألم من حيث شرح كيف ولماذا ولماذا.  أول ما تحتاج إلى معرفته عن التحكم في حركة الروبوت هو الحقيقة البسيطة والواضحة وهي أن محركات جامع الروبوت لا تدور أبدًا بنفس السرعة دون تعديل إضافي.  قابض مختلف ، وخصائص خرج مختلفة لقنوات السائق ، ومحركات كهربائية مختلفة قليلاً وتزييت في علبة التروس. <br><br>  الحقيقة الثانية التي يجب أن تفهمها وتعرفها هي وجود القصور الذاتي في المحرك ، حتى مع وجود نسبة ترس كبيرة بما فيه الكفاية.  أي  عند إزالة الجهد من أطراف المحرك ، فإن العجلة ، حتى لو لم يتم تحميلها ، تجعل الحركة بضع درجات إضافية.  يعتمد حجم الدوران الإضافي هذا على قوة التحميل على العجلة ، وعلى سرعة الدوران قبل تخفيف الضغط ، وعلى نفس العوامل غير المرئية مثل نوع وكمية التشحيم في علبة التروس. <br><br>  تحدد هذه الحقائق تنفيذ مجموعة من الأساليب المتعلقة بحركة الهيكل المزودة بأجهزة استشعار عداد المسافات (في حالة MIRO ، الترميز الرقمي لكل عجلة). <br><br>  كما اكتشفنا في الجزء الرابع ، في طراز البرنامج ، توجد فئة <b>الهيكل</b> ، والتي تطبق التحكم في دوران محركات الهيكل الفردية.  أريد التأكيد - ليس التحكم في حركة الهيكل ، العربة ، ولكن التحكم في محركات العربة.  يتم تطبيق التحكم المباشر في العربة في فئتي <b>Robot</b> و <b>Miro</b> . <br><br>  لنبدأ من فوق.  فيما يلي طريقة لفئة <b>Miro</b> تنفذ حركة الروبوت بمسافة معينة ( <b>dist</b> ، بالأمتار) <b>بسرعات</b> خطية معينة ( <b>lin_speed</b> ، m / s) <b>وسرعات</b> ( <b>ang_speed</b> ، deg / s) زاوي.  لم ننتبه بعد إلى المعلمة <b>en_break</b> . <br><br><pre style=";text-align:right;direction:rtl"><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Miro::moveDist(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lin_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ang_speed, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dist, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> en_break) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAngSpeed[WHEEL_COUNT]; _wheelSetAngSpeed[LEFT] = MIRO_PI2ANG * (lin_speed - (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; _wheelSetAngSpeed[RIGHT] = MIRO_PI2ANG * (lin_speed + (ROBOT_DIAMETER * ang_speed / (<span class="hljs-number"><span class="hljs-number">2</span></span> * MIRO_PI2ANG))) / WHEEL_RADIUS; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _wheelSetAng[WHEEL_COUNT]; _wheelSetAng[RIGHT] = _wheelSetAngSpeed[RIGHT] * dist / lin_speed; _wheelSetAng[LEFT] = _wheelSetAngSpeed[LEFT] * dist / lin_speed; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;chassis.wheelRotateAng(_wheelSetAngSpeed, _wheelSetAng, en_break); }</code> </pre> <br>  في هذه الطريقة ، يتم أولاً حساب السرعات الزاوية المطلوبة للمحركات اليمنى واليسرى.  وفقا لصيغ واضحة إلى حد ما ، والتي ليست مشكلة لاستنتاج.  من الضروري فقط مراعاة أن السرعة الخطية في الطريقة محددة بالأمتار في الثانية ، والسرعة الزاوية بالدرجات في الثانية (وليس بالراديان).  لذلك ، نحن نقوم بحساب <b>MIRO_PI2ANG</b> الثابت <b>مسبقًا = 57.29 = 180 / pi.</b>  <b>ROBOT_DIAMETER</b> - المسافة بين العجلات اليسرى واليمنى للروبوت (بالأمتار) ، <b>WHEEL_RADIUS</b> - نصف قطر العجلة (بالأمتار أيضًا).  جميع الثوابت العددية لهذه الحالات موجودة في ملف defs.h ، والمعلمات المخصصة للروبوت والهيكل موجودة في ملف config.h. <br><br>  بعد ذلك ، يتم حساب الزاوية التي يجب أن تُدار بها كل عجلة بحيث ينتقل الروبوت المسافة (بالأمتار أيضًا). <br><br>  وبالتالي ، في هذه المرحلة ، نحصل على السرعة والزاوية التي تحتاجها لتدوير كل عجلة في هيكل الروبوت.  ثم يتم <b>استدعاء</b> طريقة <b>wheelRotateAng ()</b> لكائن <b>الهيكل</b> . <br><br>  يتم <b>استخدام</b> طريقة <b>wheelRotateAng (السرعة العائمة * ، العائمة * ang ، bool en_break)</b> لتدوير عجلات الروبوت بالسرعات الزاوية المحددة في صفيف <b>السرعة []</b> (م / ث) بواسطة الزوايا المحددة بواسطة مصفوفة <b>ang []</b> بالدرجات).  تحدد المعلمة الأخيرة <b>en_break</b> (التي سبق أن <b>استوفيناها</b> سابقًا) المتطلبات لإيقاف العجلات بشدة بعد إجراء منعطف عن طريق استخدام جهد عكسي قصير الأجل لها.  هذا ضروري لقمع القصور الذاتي للروبوت ، ومنعه من التحرك بعد المسافة المطلوبة بالفعل بعد إزالة الجهد السيطرة من المحركات.  للرضا التام ، بالطبع ، هناك طريقة <b>wheelRotateAngRad ()</b> ، مماثلة <b>لعجلة wheelRotateAng ()</b> مع الفارق الذي يأخذ قيم زوايا الدوران والسرعات الزاوية في الراديان والراديان في الثانية كمعلمات. <br><br>  خوارزمية طريقة <b>wheelRotateAng ()</b> هي كما يلي. <br><br>  1. أولاً ، يتم فحص مراسلات القيم من <b>السرعة []</b> و <b>[ang] إلى</b> بعض شروط الحدود.  من الواضح أن الهيكل له قيود مادية على الحد الأقصى للسرعة الزاوية لتناوب العجلات ، وعلى الحد الأدنى (الحد الأدنى لسرعة الابتعاد).  أيضًا ، لا يمكن أن تكون الزوايا في الزاوية <b>[]</b> أقل من الحد الأدنى لزاوية الدوران الثابتة ، والتي تحددها دقة برامج التشفير. <br><br>  2. بعد ذلك ، يتم حساب اتجاه دوران كل عجلة.  من الواضح من خلال علامة المنتج <b>ang [i] * speed [i]</b> ؛ <br><br>  3. يتم حساب "مسافة الدوران" <b>Dw [i]</b> لكل عجلة - عدد عينات التشفير التي يجب القيام بها للتدوير بواسطة <b>ang [i] المحددة</b> . <br>  يتم تحديد هذه القيمة بواسطة الصيغة: <br><br>  <b>Dw [i] = ang [i] * WHEEL_SEGMENTS / 360</b> ، <br>  حيث <b>WHEEL_SEGMENTS</b> هو عدد مقاطع عجلة التشفير (الثورة الكاملة). <br><br>  4. يتم تسجيل قيمة الجهد على سائق المحرك. <br><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">حول الجهد على المحركات</b> <div class="spoiler_text" style=";text-align:right;direction:rtl">  * <i>يتم استخدام PWM للتحكم في دوران المحركات ، وبالتالي ، من أجل معرفة الجهد الذي يتم توفيره لكل محرك ، من الضروري معرفة الجهد الكهربائي لسائق المحرك.</i>  <i>في روبوت MIRO ، يتصل السائق مباشرة بدائرة طاقة البطارية.</i>  <i>وظيفة تعويم getVoltage () ؛</i>  <i>تقوم بإرجاع الجهد من مقسم الجهد بعامل VOLTAGE_DIVIDER.</i>  <i>الجهد المرجعي ADC: 5V.</i>  <i>في الوقت الحالي ، تبلغ قيمة VOLTAGE_DIVIDER في الروبوت 2 ، ويتم توفير الجهد من بنك واحد (1S) من البطارية لمدخل ADC (PIN_VBAT).</i>  <i>هذا ليس صحيحًا تمامًا نظرًا لحقيقة أن بنوك البطاريات يمكنها تفريغها بشكل مختلف وفقدان الرصيد ، ولكن كما أظهرت الممارسة ، مع وجود شحن مستمر للبطارية مع الموازنة ، يعمل الحل تمامًا.</i>  <i>في المستقبل ، نخطط لعمل مقسم طبيعي مع عبوتين من البطاريات.</i> <br></div></div><br>  5. وفقًا لجدول المعايرة لكل عجلة ، يتم تحديد القيمة الأولية لإشارة PWM ، مما يضمن دوران العجلة بسرعة <b>السرعة</b> المطلوبة <b>[i]</b> .  ما نوع طاولة المعايرة ومن أين أتت - سنحلل أكثر. <br><br>  6. يتم بدء دوران المحركات وفقًا للقيم المحسوبة للسرعة واتجاه الدوران.  في نص تطبيق الفصل ، تكون الطريقة الخاصة <b>_wheel_rotate_sync ()</b> مسؤولة عن هذا. <br><br>  نذهب أعمق.  تعمل طريقة <b>_wheel_rotate_sync ()</b> وفقًا للخوارزمية التالية: <br><br>  1. في حلقة لا نهائية ، يتم إجراء فحص لتحقيق عداد استجابات المشفر لمسافة الدوران <b>Dw [i]</b> لكل عجلة.  إذا تم الوصول إلى أي من العدادات <b>Dw [i]</b> ، تتوقف جميع العجلات وتخرج من الدورة ثم تخرج من الوظيفة (الخطوة 5).  يتم ذلك للأسباب التالية.  نظرًا لتقدير قياس زاوية الدوران ، يكون الوضع شائعًا للغاية عندما يتم الحصول على المسافة المحسوبة <b>Dw [i]</b> لعجلة واحدة عن طريق تقريب قيمة غير صحيحة إلى جانب أصغر و <b>Dw [j] من</b> العجلة الثانية إلى زاوية أكبر.  هذا يؤدي إلى حقيقة أنه بعد إيقاف إحدى العجلات ، تستمر العجلة الثانية في الدوران.  بالنسبة للهيكل الذي يحتوي على محرك تفاضلي (وبالنسبة للعديد من الأجهزة الأخرى) ، يؤدي هذا إلى "منعطف" غير مخطط له من الروبوت في نهاية المهمة.  لذلك ، في حالة تنظيم الحركة المكانية للهيكل بالكامل ، من الضروري إيقاف جميع المحركات في وقت واحد. <br><br>  2. إذا لم <b>يتم</b> الوصول إلى <b>Dw [i]</b> ، في هذه الحلقة يتم التحقق من حقيقة العملية التالية <b>لجهاز</b> التشفير (المتغير <b>_syncloop [w]</b> ، يتم تحديثه من مقاطعة المشفر وإعادة ضبطه في هذه الحلقة اللانهائية).  عند حدوث التقاطع التالي ، يقوم البرنامج بحساب الوحدة النمطية للسرعة الزاوية الحالية لكل عجلة (درجة / ثانية) ، وفقًا للصيغة الواضحة: <br><br>  <b>W [i] = (360 * tau [i]) / WHEEL_SEGMENTS</b> ، <br>  حيث: <br>  <b>tau [i]</b> - متوسط ​​قيمة الوقت بين آخر استجابتين من الترميز.  يتم تحديد "عمق" مرشح <b>التوسط</b> عن طريق <b>MEAN_DEPTH</b> والافتراضات إلى 8. <br><br>  3. بناءً على سرعات العجلة المحسوبة ، يتم حساب الأخطاء المطلقة كالفوارق بين السرعات الزاوية والسرعة الفعلية. <br><br>  4. استنادًا إلى الأخطاء المحسوبة ، يتم تصحيح إجراء التحكم (قيمة إشارة PWM) لكل محرك. <br><br>  5. بعد الوصول إلى <b>Dw [i]</b> ، في حالة <b>اندلاع</b> نشط ، يتم تطبيق الجهد العكسي قصير الأجل على المحركات.  يتم تحديد مدة هذا التأثير من جدول المعايرة (انظر أدناه) وعادة ما تتراوح بين 15 إلى 40 مللي ثانية. <br><br>  6. هناك إصدار كامل من الإجهاد من المحركات والخروج <b>_wheel_rotate_sync ()</b> . <br><br>  لقد ذكرت بالفعل جدول معايرة معين مرتين.  لذلك ، يوجد في المكتبة جدول خاص للقيم المخزنة في EEPROM لذاكرة الروبوت ويحتوي على سجلات من ثلاث قيم ذات صلة: <br><br>  1. الجهد في محطات السيارات.  يتم حسابه عن طريق ترجمة قيمة إشارة PWM إلى الجهد الفعلي.  لهذا ، في الخطوة 4 من طريقة <b>wheelRotateAng ()</b> ، يتم تسجيل الجهد الفعلي على برنامج تشغيل المحرك. <br><br>  2. السرعة الزاوية لتناوب العجلة (بدون حمل) المقابلة لجهد معين. <br><br>  3. مدة إشارة توقف الثابت المقابلة لهذه السرعة الزاوية. <br>  بشكل افتراضي ، يكون حجم جدول المعايرة 10 سجلات (يتم تحديدها بواسطة <b>WHEEL_TABLE_SIZE</b> الثابت في ملف <b>config.h</b> ) - 10 أضعاف قيم "الجهد - السرعة الزاوية - مدة إشارة التوقف". <br><br>  لتحديد القيم من 2 و 3 إدخالات في هذا الجدول ، يتم استخدام طريقة خاصة - <b>wheelCalibrate (byte wheel)</b> . <br><br>  دعونا ننظر قليلا في ذلك.  تطبق هذه الطريقة سلسلة من الإجراءات لتحديد القيم المفقودة في جدول معايرة المحرك / العجلة ، وكذلك لمعرفة الحد الأدنى للسرعة الزاوية لبدء التشغيل والحد الأقصى للسرعة الزاوية للعجلة. <br><br>  لإجراء المعايرة ، يتم تثبيت الروبوت على حامل ؛ يتم إجراء جميع دوران العجلات أثناء المعايرة دون تحميل. <br><br>  1. تحتاج أولاً إلى تحديد الحد الأدنى لسرعة البدء.  يتم ذلك ببساطة شديدة.  في دورة ما ، يتم تغذية عنصر التحكم PWM للمحرك ، بدءًا من 0 ، بزيادة قدرها 1. في كل خطوة ، ينتظر البرنامج لبعض الوقت ، <b>ويتم</b> تحديده بواسطة ثابت <b>WHEEL_TIME_MAX</b> ( <b>تأخير</b> عادي <b>()</b> ).  بعد انقضاء وقت الانتظار ، يتحقق الأمر لمعرفة ما إذا كانت البداية قد اكتملت (عن طريق تغيير قيمة عداد التشفير).  في حالة اكتمال الانسحاب ، يتم حساب السرعة الزاوية للعجلة.  لمزيد من اليقين ، تتم إضافة قيمة 10 إلى قيمة PWM المقابلة لسرعة البدء هذه ، وهذا يعطي الزوج الأول من القيم "الجهد على المحرك" - "السرعة الزاوية". <br><br>  2. بعد العثور على سرعة البدء ، يتم حساب خطوة PWM لملء جدول المعايرة بشكل موحد. <br><br>  3. في الدورة ، لكل قيمة PWM جديدة ، يتم تدوير العجلة <b>بفترتين كاملتين</b> ويتم قياس السرعة الزاوية وفقًا لخوارزمية مشابهة <b>لطريقة _wheel_rotate_sync ()</b> .  في نفس الدورة ، وأيضًا عن طريق التقريب المتتابع ، يتم قياس القيمة المثلى لفترة إشارة التوقف الثابت.  في البداية ، يتم اتخاذ بعض قيمة كبيرة بشكل واضح.  وبعد ذلك يتم اختباره في وضع "التوقف".  باعتبارها القيمة المثلى ، يتم تحديد الحد الأقصى لقيمة مدة إشارة التوقف ، حيث لا يتم تجاوز "مسافة الدوران" المحددة.  وبعبارة أخرى ، يتم إيقاف هذه القيمة لمدة الإشارة ، عند تزويد المحرك من ناحية ، بالقصور الذاتي ، ومن ناحية أخرى ، لا توجد حركة عكسية قصيرة الأجل (يتم تثبيتها بواسطة نفس المشفر). <br><br>  4. بعد اكتمال المعايرة ، يتوقف جهد التحكم في المحرك المعاير ليتم تسجيل جدول معايرة هذه العجلة في EEPROM. <br><br>  لقد حذفت كل أنواع التفاهات في التنفيذ وحاولت أن أذكر الجوهر.  قد تلاحظ أن <b>طريقتي wheelRotateAng ()</b> و <b>wheelRotateAngRad () تحظران</b> الوظائف.  هذا هو ثمن دقة الحركة وتكامل بسيط إلى حد ما في الرسومات المستخدم.  قد يكون من الممكن إنشاء مدير مهام صغير مع توقيت ثابت ، ولكن هذا سيتطلب من المستخدم تضمين وظائفه بدقة في الحصة الزمنية المخصصة. <br><br>  وبالنسبة للتطبيقات غير <b>المحظورة</b> ، يحتوي API على <b>تدوير للعجلة</b> الوظيفية <b>(السرعة العائمة)</b> .  كما هو واضح من قائمة المعلمات ، يؤدي ببساطة دوران العجلات بسرعات محددة.  ويتم ضبط سرعة الدوران في طريقة <b>Sync ()</b> لهيكل الروبوت ، والتي تسمى في طريقة <b>Sync ()</b> لكائن فئة Miro الذي يحمل نفس الاسم.  ووفقًا لمتطلبات بنية رسم المستخدم ، يجب أن تسمى هذه الطريقة كل تكرار <b>للحلقة</b> الرئيسية <b>() من حلقة</b> ARDUINO. <br><br>  في الخطوة 4 ، في وصف طريقة <b>_wheel_rotate_sync ()</b> ، ذكرت "تصحيح التحكم" الخاص بالمحرك.  كيف تخمين)؟  هذا هو وحدة تحكم PID).  حسنا ، أكثر دقة تحكم PD.  كما تعلمون (في الواقع - ليس دائمًا) ، فإن أفضل طريقة لتحديد معاملات المنظم هي الاختيار).  يوجد تعريف واحد في ملف التكوين config.h: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEBUG_WHEEL_PID</span></span></code> </pre><br>  إذا قمت <b>بالإلغاء</b> ، عند استدعاء الأسلوب <b>moveDist ()</b> لفئة Miro ، سيتم عرض الرسم البياني المقلوب التالي للخطأ النسبي في التحكم في السرعة الزاوية لإحدى عجلات الروبوت (يسار) في وحدة التحكم الآلية. <br><br> <a href=""><img src="https://habrastorage.org/webt/_v/4i/hr/_v4ihrxfnzpq-fvnofq_3kjkcz0.png"></a> <br><br>  لا يشبه أي شيء)؟  أسفل هو الوقت (كل شريط هو خطوة من دورة التحكم) ، ويتم حفظ قيمة الخطأ إلى اليمين (مع الحفاظ على علامة).  فيما يلي زوجان من الرسوم البيانية على نفس المقياس مع معاملات مختلفة لوحدة تحكم PD.  "الحدب" هي مجرد "موجات" من التجاوز.  الأرقام على الأشرطة الأفقية هي خطأ نسبي (مع الحفاظ على علامة).  تصور بسيط للمنظم ، مما يساعد على ضبط المعاملات يدويا.  مع مرور الوقت ، آمل أن أقوم بإعداد تلقائي ، لكن الآن. <br><br>  هنا مثل هذا adok :-) <br><br>  حسنًا ، أخيرًا ، دعونا ننظر إلى مثال.  مباشرة من مكتبة API_Miro_moveDist: <br><br><pre style=";text-align:right;direction:rtl"> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Miro.h&gt; using namespace miro; byte PWM_pins[2] = { 5, 6 }; byte DIR_pins[2] = { 4, 7 }; byte ENCODER_pins[2] = { 2, 3 }; Miro robot(PWM_pins, DIR_pins, ENCODER_pins); int laps = 0; void setup() { Serial.begin(115200); } void loop() { for (unsigned char i = 0; i &lt; 4; i++) { robot.moveDist(robot.getOptLinSpeed(), 0, 1, true); delay(500); robot.rotateAng(0.5*robot.getOptAngSpeed(), -90, true); delay(500); } Serial.print("Laps: "); Serial.println(laps); laps++; }</span></span></span></span></code> </pre><br>  من نص البرنامج يجب أن يكون كل شيء واضحًا.  كيف يعمل - في الفيديو. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Bd96kgY2YsY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  600 × 600 ملم البلاط و 5 ملم الفجوات البلاط.  من الناحية النظرية ، يجب أن يتجول الروبوت حول مربع مع جانب متر واحد.  بالطبع ، المسار "يطفو بعيدا".  لكن من الإنصاف ، يجدر القول أنه في إصدار الروبوت الذي تركته للاختبارات ، توجد محركات دوّارة يصعب السير فيها ببطء.  ولكن في السرعة العالية والانزلاق ، هناك مكان مناسب ، والقصور الذاتي ليس من السهل التغلب عليه.  يجب أن تتصرف المحركات ذات نسبة التروس الأعلى (مثل حتى في روبوتات MIRO الخاصة بنا ، التي لم تكن موجودة أثناء الاختبار) بشكل أفضل إلى حد ما. <br><br>  إذا كانت هناك لحظات غير مفهومة - يسعدني التوضيح والمناقشة والتحسين.  ردود الفعل مثيرة للاهتمام بشكل عام. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar477118/">https://habr.com/ru/post/ar477118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar477098/index.html">نتعامل مع نقل الفيديو بدقة 4K بسرعة 60 هرتز عبر محور USB-C</a></li>
<li><a href="../ar477100/index.html">ماراثون Microsoft Dynamics 365 التقني</a></li>
<li><a href="../ar477104/index.html">التحسس الذكي بمساعدة AI لقاعدة بيانات فريقك</a></li>
<li><a href="../ar477110/index.html">التخطيط الترفيهي</a></li>
<li><a href="../ar477114/index.html">MSH تنفيذ مترجم</a></li>
<li><a href="../ar477120/index.html">استمرار رصد نسبة السكر في الدم برمجيات ويندوز</a></li>
<li><a href="../ar477122/index.html">دماغ الشركة. الجزء 3</a></li>
<li><a href="../ar477124/index.html">بيتكوين في قفص؟</a></li>
<li><a href="../ar477126/index.html">المشرف في 5 دقائق. الواجهة الأمامية - رد فعل المشرف ، الواجهة الخلفية - قارورة الراحة</a></li>
<li><a href="../ar477128/index.html">هبرا المباحث في عطلة نهاية الأسبوع</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>