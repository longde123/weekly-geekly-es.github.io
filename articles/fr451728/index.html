<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìâ üë®üèª‚Äçüîß üî¨ RESTinio est un serveur HTTP asynchrone. Asynchrone üöµüèæ üí§ üíÜüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques ann√©es, nous avons publi√© RESTinio , notre petit framework OpenSource C ++ pour int√©grer un serveur HTTP dans des applications C ++. R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RESTinio est un serveur HTTP asynchrone. Asynchrone</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451728/"><p>  Il y a quelques ann√©es, nous avons publi√© <a href="">RESTinio</a> , notre petit framework OpenSource C ++ pour int√©grer un serveur HTTP dans des applications C ++.  RESTinio n'est pas devenu tr√®s populaire pendant cette p√©riode, mais il n'a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pas</a> √©t√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">perdu</a> .  Quelqu'un le choisit pour la prise en charge ¬´native¬ª de Windows, quelqu'un pour certaines fonctionnalit√©s individuelles (comme la prise en charge de sendfile), quelqu'un pour le rapport des fonctionnalit√©s, la facilit√© d'utilisation et la personnalisation.  Mais je pense qu'au d√©part, de nombreux RESTinio sont attir√©s par ce laconique "Hello, World": </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;restinio/all.hpp&gt; int main() { restinio::run( restinio::on_this_thread() .port(8080) .address("localhost") .request_handler([](auto req) { return req-&gt;create_response().set_body("Hello, World!").done(); })); return 0; }</span></span></span></span></code> </pre> <br><p>  C'est vraiment tout ce qui est n√©cessaire pour ex√©cuter le serveur HTTP dans une application C ++. </p><br><p>  Et bien que nous essayions toujours de dire que la fonctionnalit√© cl√© pour laquelle nous nous sommes g√©n√©ralement engag√©s dans RESTinio √©tait le traitement asynchrone des demandes entrantes, nous rencontrons toujours occasionnellement des questions sur ce qu'il faut faire si √† l'int√©rieur de request_handler vous devez effectuer de longues op√©rations. </p><br><p>  Et comme une telle question est pertinente, vous pouvez en reparler et donner quelques petits exemples. </p><a name="habracut"></a><br><h1 id="nebolshaya-otsylka-k-istokam">  Une petite r√©f√©rence aux origines </h1><br><p>  Nous avons d√©cid√© de rendre notre serveur HTTP int√©grable apr√®s plusieurs fois d'affil√©e face √† des t√¢ches tr√®s similaires: il fallait organiser une entr√©e HTTP pour une application C ++ existante ou il fallait √©crire un microservice dans lequel il fallait r√©utiliser le C ++ "lourd" d√©j√† existant ny code.  Une caract√©ristique commune de ces t√¢ches √©tait que le traitement de la demande par l'application pouvait s'√©tendre sur des dizaines de secondes. </p><br><p>  En gros, pendant une milliseconde, le serveur HTTP a tri√© une nouvelle requ√™te HTTP, mais pour √©mettre une r√©ponse HTTP, il a fallu se tourner vers d'autres services ou effectuer de longs calculs.  Si vous traitez les requ√™tes HTTP en mode synchrone, le serveur HTTP aura besoin d'un pool de milliers de threads de travail, ce qui peut difficilement √™tre consid√©r√© comme une bonne id√©e m√™me dans des conditions modernes. </p><br><p>  C'est beaucoup plus pratique lorsque le serveur HTTP ne peut travailler que sur un seul thread de travail, sur lequel des E / S sont effectu√©es et des gestionnaires de requ√™tes sont appel√©s.  Le gestionnaire de demandes d√©l√®gue simplement le traitement r√©el d'un autre thread de travail et renvoie le contr√¥le au serveur HTTP.  Lorsque, bien plus tard, quelque part sur un autre thread de travail, les informations sont pr√™tes √† r√©pondre √† la demande, une r√©ponse HTTP est simplement g√©n√©r√©e qui r√©cup√®re automatiquement le serveur HTTP et envoie cette r√©ponse au client appropri√©. </p><br><p>  Comme nous n'avons jamais trouv√© de version pr√™te √† l'emploi qui soit simple et pratique √† utiliser, elle √©tait multiplateforme et supportait Windows en tant que plate-forme ¬´native¬ª, fournirait des performances plus ou moins d√©centes et, plus important encore, serait affin√©e sp√©cifiquement pour les applications asynchrones. travail, puis d√©but 2017 nous avons commenc√© √† d√©velopper RESTinio. </p><br><p>  Nous voulions cr√©er un serveur HTTP int√©grable asynchrone, facile √† utiliser, lib√©rant l'utilisateur de certains soucis de routine, tout en √©tant plus ou moins productif, multiplateforme et permettant une configuration flexible pour diff√©rentes conditions.  Cela semble fonctionner, mais laissons aux utilisateurs le soin de juger ... </p><br><h1 id="itak-est-vhodyaschiy-zapros-trebuyuschiy-mnogo-vremeni-na-obrabotku-chto-delat">  Il y a donc une demande entrante qui n√©cessite beaucoup de temps de traitement.  Que faire </h1><br><h2 id="rabochie-niti-restinioasio">  Fils de travail RESTinio / Asio </h2><br><p>  Parfois, les utilisateurs de RESTinio ne r√©fl√©chissent pas aux threads de travail et √† la fa√ßon exacte d'utiliser RESTinio.  Par exemple, quelqu'un pourrait consid√©rer que lorsque RESTinio est lanc√© sur un thread de travail (en utilisant <code>run(on_this_thread(...))</code> , comme dans l'exemple ci-dessus), alors sur ce thread de travail, RESTinio n'appelle que les gestionnaires de demandes.  Alors que pour les E / S, RESTinio cr√©e un filetage s√©par√© sous le capot.  Et ce thread s√©par√© continue de servir de nouvelles connexions lorsque le thread de travail principal est occup√© par request_handler. </p><br><p>  En fait, tous les threads que l'utilisateur alloue √† RESTinio sont utilis√©s √† la fois pour effectuer des op√©rations d'E / S et pour appeler des gestionnaires de requ√™tes.  Par cons√©quent, si vous avez d√©marr√© le serveur RESTinio via <code>run(on_this_thread(...))</code> , puis √† l'int√©rieur de <code>run()</code> sur le thread actuel, les E / S et les gestionnaires de requ√™tes seront ex√©cut√©s. </p><br><p>  En gros, RESTinio lance une boucle d'√©v√©nements Asio, √† l'int√©rieur de laquelle il traite les nouvelles connexions, lit et analyse les donn√©es des connexions existantes, √©crit les donn√©es pr√™tes pour l'envoi, g√®re la fermeture des connexions, etc.  Entre autres choses, apr√®s que la requ√™te entrante a √©t√© lue et compl√®tement analys√©e √† partir de la connexion suivante, le gestionnaire de requ√™tes sp√©cifi√© par l'utilisateur est appel√© pour traiter cette requ√™te. </p><br><p>  Par cons√©quent, si request_handler bloque le fonctionnement du thread actuel, la boucle d'√©v√©nements Asio-action travaillant sur le m√™me thread est √©galement bloqu√©e.  Tout est simple. </p><br><p>  Si RESTinio est d√©marr√© sur un pool de threads de travail (c'est-√†-dire au moyen de <code>run(on_thread_pool(...))</code> , comme <a href="">dans cet exemple</a> ), alors presque la m√™me chose se produit: une boucle d'√©v√©nement Asio-event est lanc√©e sur chaque thread du pool.  Par cons√©quent, si certains request_handler commencent √† multiplier les grandes matrices, cela bloquera le thread de travail dans le pool et les op√©rations d'E / S ne seront plus servies sur ce thread. </p><br><p>  Par cons√©quent, lorsque vous utilisez RESTinio, la t√¢che du d√©veloppeur est de terminer ses gestionnaires de requ√™tes dans un d√©lai raisonnable et, de pr√©f√©rence, pas tr√®s long. </p><br><h2 id="nuzhen-li-vam-pul-rabochih-potokov-dlya-restinioasio">  Avez-vous besoin d'un pool de workflows pour RESTinio / Asio? </h2><br><p>  Ainsi, lorsque le request_handler sp√©cifi√© par l'utilisateur bloque le thread de travail sur lequel il est appel√© pendant une longue p√©riode, ce thread perd la capacit√© de traiter les op√©rations d'E / S.  Mais que se passe-t-il si request_handler a besoin de beaucoup de temps pour former une r√©ponse?  Supposons qu'il effectue une sorte d'op√©ration informatique lourde, dont le temps, en principe, ne peut pas √™tre raccourci √† quelques millisecondes? </p><br><p>  L'un des utilisateurs pourrait penser que, puisque RESTinio peut fonctionner sur un pool de threads de travail, il suffit de sp√©cifier la plus grande taille de pool et c'est tout. </p><br><p>  Malheureusement, cela ne fonctionnera que dans des cas simples lorsque vous avez peu de connexions parall√®les.  Et l'intensit√© des requ√™tes est faible.  Si le nombre de requ√™tes parall√®les atteint des milliers (au moins quelques centaines), il est facile d'obtenir une situation o√π tous les threads de travail du pool seront occup√©s √† traiter des demandes d√©j√† accept√©es.  Et il ne restera plus de threads pour effectuer des op√©rations d'E / S.  En cons√©quence, le serveur perdra sa r√©activit√©.  L'inclusion de RESTinio perdra la capacit√© de traiter les d√©lais d'attente que RESTinio compte automatiquement lorsqu'il re√ßoit de nouvelles connexions et lors du traitement des demandes. </p><br><p>  Par cons√©quent, si vous devez effectuer de longues op√©rations de blocage pour traiter les demandes entrantes, il est pr√©f√©rable d'allouer un seul thread de travail pour RESTinio, mais d'affecter un grand pool de flux de travail pour effectuer ces m√™mes op√©rations.  Le gestionnaire de demande mettra simplement la demande suivante dans une file d'attente, d'o√π la demande sera r√©cup√©r√©e et soumise pour traitement. </p><br><p>  Nous avons examin√© un exemple de ce sch√©ma en d√©tail lorsque nous avons parl√© de notre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet de d√©monstration Shrimp</a> dans cet article: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shrimp: redimensionner et partager des images HTTP en C ++ moderne en utilisant ImageMagic ++, SObjectizer et RESTinio</a> ." </p><br><h2 id="primery-delegirovaniya-obrabotki-zaprosov-na-otdelnye-rabochie-niti">  Exemples de d√©l√©gation du traitement des demandes √† des threads de travail individuels </h2><br><p>  Ci-dessus, j'ai essay√© d'expliquer pourquoi il n'est pas n√©cessaire d'effectuer un traitement long directement dans le request_handler.  D'o√π vient le r√©sultat √©vident: le long traitement des demandes doit √™tre d√©l√©gu√© √† un autre fil de travail.  Voyons √† quoi cela pourrait ressembler. </p><br><p>  Dans les deux exemples ci-dessous, nous avons besoin d'un seul thread de travail pour ex√©cuter RESTinio et d'un autre thread de travail pour simuler un long traitement des demandes.  Et nous avons √©galement besoin d'une sorte de file d'attente de messages pour transf√©rer les demandes du thread RESTinio vers un thread de travail distinct. </p><br><p>  Il n'a pas √©t√© facile pour moi de cr√©er une nouvelle impl√©mentation de file d'attente de messages thread-safe sur mes genoux pour ces deux exemples, j'ai donc utilis√© mon SObjectizer natif et ses mchains, qui sont des canaux CSP.  Vous pouvez en savoir plus sur mchain ici: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âchange d'informations entre les threads de travail sans douleur? Canaux CSP pour nous aider</a> ." </p><br><h3 id="sohranenie-obekta-request_handle">  Enregistrement de l'objet request_handle </h3><br><p>  La technique de base sur laquelle repose la d√©l√©gation du traitement des demandes est le transfert de l'objet <code>request_handle_t</code> quelque part. </p><br><p>  Lorsque RESTinio appelle le request_handler sp√©cifi√© par l'utilisateur pour traiter une demande entrante, un objet de type <code>request_handle_t</code> est pass√© √† ce <code>request_handle_t</code> .  Ce type n'est rien de plus qu'un pointeur intelligent vers les param√®tres de la demande re√ßue.  Donc, s'il est pratique pour quelqu'un de penser que <code>request_handle_t</code> est <code>shared_ptr</code> , vous pouvez le penser en toute s√©curit√©.  Ce <code>shared_ptr</code> est. </p><br><p>  Et puisque <code>request_handle_t</code> est <code>shared_ptr</code> , nous pouvons passer ce pointeur intelligent quelque part en toute s√©curit√©.  Ce que nous ferons dans les exemples ci-dessous. </p><br><p>  Nous avons donc besoin d'un thread de travail et d'un canal distincts pour communiquer avec lui.  Cr√©ons tout cela: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  SObjectizer. so_5::wrapped_env_t sobj; //  std::thread    . std::thread processing_thread; //    main      join. //    RAII. auto processing_thread_joiner = so_5::auto_join(processing_thread); //      . auto req_ch = so_5::create_mchain(sobj); //       main. //    RAII. auto ch_closer = so_5::auto_close_drop_content(req_ch); //     . //      main()  - , //     ,      join(). processing_thread = std::thread{ processing_thread_func, req_ch };</span></span></code> </pre> <br><p>  Le corps du thread de travail lui-m√™me est situ√© √† l'int√©rieur de la fonction <code>processing_thread_func()</code> , dont nous parlerons un peu plus tard. </p><br><p>  Maintenant, nous avons d√©j√† un thread de travail s√©par√© et un canal de communication avec lui.  Vous pouvez d√©marrer le serveur RESTinio: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;() .port(8080) .address("localhost") .request_handler([req_ch](auto req) { //   GET-   . if(restinio::http_method_t::http_get == req-&gt;header().method() &amp;&amp; "/" == req-&gt;header().path()) { //    . so_5::send&lt;handle_request&gt;(req_ch, req); return restinio::request_accepted(); } else return restinio::request_rejected(); }) .cleanup_func([&amp;] { //      . //    , ..  req_ch //          //     . so_5::close_drop_content(req_ch); }));</span></span></code> </pre> <br><p>  La logique de ce serveur est tr√®s simple.  Si une demande GET est arriv√©e pour '/', nous d√©l√©guons le traitement de la demande d'un seul thread.  Pour ce faire, nous effectuons deux op√©rations importantes: </p><br><ul><li>  envoyer l'objet <code>request_handle_t</code> au canal CSP.  Bien que cet objet soit stock√© √† l'int√©rieur du canal CSP ou ailleurs, RESTinio sait que la demande est toujours en vie; </li><li>  nous <code>restinio::request_accepted()</code> la valeur <code>restinio::request_accepted()</code> du gestionnaire de requ√™tes.  Cela permet √† RESTinio de comprendre que la demande a √©t√© accept√©e pour traitement et que la connexion avec le client ne peut pas √™tre ferm√©e. </li></ul><br><p>  Le fait que request_handler n'ait pas g√©n√©r√© imm√©diatement une r√©ponse RESTinio ne d√©range pas.  Une fois <code>restinio::request_accepted()</code> retourn√©, l'utilisateur a pris la responsabilit√© de traiter la demande et un jour la r√©ponse √† la demande sera g√©n√©r√©e. </p><br><p>  Si le gestionnaire de demande a renvoy√© <code>restinio::request_rejected()</code> , alors RESTinio comprend que la demande ne sera pas trait√©e et renverra une erreur 501 au client. </p><br><p>  Donc, nous fixons le r√©sultat pr√©liminaire: l'instance <code>request_handle_t</code> peut √™tre pass√©e quelque part, car il s'agit en fait de <code>std::shared_ptr</code> .  Tant que cette instance est vivante, RESTinio consid√®re que la demande est en cours de traitement.  Si le gestionnaire de demande a renvoy√© <code>restinio::request_accepted()</code> , alors RESTinio ne s'inqui√©tera pas que la r√©ponse √† la demande n'ait pas √©t√© g√©n√©r√©e pour l'instant. </p><br><p>  Maintenant, nous pouvons regarder la mise en ≈ìuvre de ce fil tr√®s distinct: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       //    . std::random_device rd; std::mt19937 generator{rd()}; std::uniform_int_distribution&lt;&gt; pause_generator{350, 3500}; //      timeout_elapsed. auto delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); //     -  . bool stop = false; select( so_5::from_all() //      . .on_close([&amp;stop](const auto &amp;) { stop = true; }) //     select(). //  select()     . .stop_on([&amp;stop]{ return stop; }), //   handle_request     RESTinio. case_(req_ch, [&amp;](handle_request cmd) { //     . const std::chrono::milliseconds pause{pause_generator(generator)}; //     . so_5::send_delayed&lt;timeout_elapsed&gt;(delayed_ch, //    timeout_elapsed. pause, //      timeout_elapsed. cmd.m_req, pause); }), //   timeout_elapsed. case_(delayed_ch, [](timeout_elapsed cmd) { //     . cmd.m_req-&gt;create_response() .set_body("Hello, World! (pause:" + std::to_string(cmd.m_pause.count()) + "ms)") .done(); }) ); }</span></span></code> </pre> <br><p>  La logique ici est tr√®s simple: nous obtenons la demande initiale sous la forme d'un message <code>handle_request</code> et nous la transmettons sous la forme d'un message <code>timeout_elapsed</code> retard√© pendant un certain temps al√©atoire.  Nous n'effectuons le traitement r√©el de la demande qu'√† r√©ception de <code>timeout_elapsed</code> . </p><br><p>  <strong>Upd.</strong>  Lorsque la m√©thode <code>done()</code> est appel√©e sur un thread de travail distinct, RESTinio est averti qu'une r√©ponse toute pr√™te est apparue et doit √™tre √©crite sur la connexion TCP.  RESTinio lance l'op√©ration d'√©criture, mais l'op√©ration d'E / S elle-m√™me ne sera pas ex√©cut√©e lorsque <code>done()</code> appel√©e, mais lorsque RESTinio effectue les E / S et appelle request_handlers.  C'est-√†-dire  dans cet exemple, <code>done()</code> est appel√©e sur un thread de travail s√©par√© et l'op√©ration d'√©criture sera effectu√©e sur le thread principal, o√π <code>restinio::run()</code> fonctionne. </p><br><p>  Les messages eux-m√™mes sont les suivants: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timeout_elapsed</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds m_pause; };</code> </pre> <br><p>  C'est-√†-dire  un thread de travail s√©par√© prend <code>request_handle_t</code> et l'enregistre jusqu'√† ce que l'occasion se pr√©sente de former une r√©ponse compl√®te.  Et lorsque cette opportunit√© se pr√©sente, <code>create_response()</code> est appel√©e sur l'objet de demande enregistr√© et la r√©ponse est renvoy√©e √† RESTinio.  Ensuite, RESTinio d√©j√† dans son contexte de travail √©crit la r√©ponse en relation avec le client correspondant. </p><br><p>  Ici, l'instance <code>timeout_elapsed</code> est stock√©e dans un message diff√©r√© <code>timeout_elapsed</code> , car il n'y a pas de traitement r√©el dans cet exemple primitif.  Dans une application r√©elle, <code>request_handle_t</code> peut √™tre stock√© dans une sorte de file d'attente ou √† l'int√©rieur d'un objet cr√©√© pour traiter la demande. </p><br><p>  Le code complet de cet exemple se trouve <a href="">parmi les exemples r√©guliers de RESTinio</a> . </p><br><h4 id="neskolko-nebolshih-poyasneniy-po-kodu">  Quelques petites notes de code </h4><br><p>  Cette construction d√©finit les propri√©t√©s RESTinio qu'un serveur RESTinio devrait avoir: </p><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ,     . struct traits_t : public restinio::default_traits_t { using logger_t = restinio::shared_ostream_logger_t; }; restinio::run( restinio::on_this_thread&lt;traits_t&gt;()</span></span></code> </pre> <br><p>  Pour cet exemple, j'ai besoin de RESTinio pour enregistrer ses actions de traitement des demandes.  Par cons√©quent, j'ai d√©fini <code>logger_t</code> √™tre diff√©rent du <code>null_logger_t</code> par d√©faut.  Mais depuis  RESTinio fonctionnera, en fait, sur plusieurs threads (RESTinio traite les demandes entrantes sur le thread principal, mais les r√©ponses viennent d'un thread de travail s√©par√©), alors vous avez besoin d'un enregistreur thread-safe, qui est <code>shared_ostream_logger_t</code> . </p><br><p>  √Ä l'int√©rieur de <code>processing_thread_func()</code> , la fonction SObjectizer <code>select()</code> , ce qui est quelque peu similaire √† la construction de s√©lection Go-shn: vous pouvez lire et traiter les messages de plusieurs canaux √† la fois.  La fonction <code>select()</code> fonctionne jusqu'√† ce que tous les canaux qui lui sont pass√©s soient ferm√©s.  Ou jusqu'√† ce qu'on lui dise de force qu'il est temps de mettre fin. </p><br><p>  Dans le m√™me temps, si le canal de communication avec le serveur RESTinio est ferm√©, il est inutile de poursuivre le travail.  Par cons√©quent, dans <code>select()</code> , la r√©ponse √† la fermeture de l'un des canaux est d√©termin√©e: d√®s qu'un canal est ferm√©, le drapeau d'arr√™t est lev√©.  Et cela conduira √† l'ach√®vement de <code>select()</code> et √† la sortie de <code>processing_thread_func()</code> . </p><br><h3 id="sohranenie-obekta-response_builder">  Enregistrement de l'objet response_builder </h3><br><p>  Dans l'exemple pr√©c√©dent, nous avons consid√©r√© un cas simple o√π il est possible d'enregistrer <code>request_handle_t</code> jusqu'√† ce que nous puissions imm√©diatement donner la r√©ponse enti√®re √† la demande. </p><br><p>  Mais il peut y avoir des sc√©narios plus complexes lorsque, par exemple, vous devez donner une r√©ponse en plusieurs parties.  Autrement dit, nous recevons une demande, nous ne pouvons imm√©diatement former que la premi√®re partie de la r√©ponse.  Nous le formons.  Ensuite, apr√®s un certain temps, nous avons la possibilit√© de former la deuxi√®me partie de la r√©ponse.  Ensuite, apr√®s un peu plus de temps, nous pouvons former la partie suivante, etc. </p><br><p>  De plus, il peut √™tre souhaitable pour nous que toutes ces parties disparaissent au fur et √† mesure que nous les formons.  C'est-√†-dire  Tout d'abord, la premi√®re partie de la r√©ponse pour que le client puisse la soustraire, puis la deuxi√®me, puis la troisi√®me, etc. </p><br><p>  RESTinio vous permet de le faire en raison de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">diff√©rents types de responce_builders</a> .  En particulier, des types tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">user_controlled_output</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">chunked_output</a> . </p><br><p>  Dans ce cas, il ne suffit pas d'enregistrer <code>request_handle_t</code> , car <code>request_handle_t</code> ne sera utile que jusqu'au premier appel √† <code>create_reponse()</code> .  Ensuite, nous devons travailler avec response_builder.  Et bien ... </p><br><p>  Eh bien, √ßa va.  Response_builder est un type mobile, quelque peu similaire √† unique_ptr.  Nous pouvons donc le conserver aussi longtemps que nous en avons besoin.  Et pour montrer √† quoi √ßa ressemble, on refait l√©g√®rement l'exemple ci-dessus.  Laissez la fonction <code>processing_thread_func()</code> former la r√©ponse en plusieurs parties. </p><br><p>  Ce n'est pas du tout difficile. </p><br><p>  Nous devons d'abord d√©cider des types dont le nouveau <code>processing_thread_func()</code> aura besoin: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handle_request</span></span></span><span class="hljs-class"> {</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">request_handle_t</span></span> m_req; }; <span class="hljs-comment"><span class="hljs-comment">//     . using output_t = restinio::chunked_output_t; //   reponse_builder-   . using response_t = restinio::response_builder_t&lt;output_t&gt;; //     . struct timeout_elapsed { response_t m_resp; int m_counter; };</span></span></code> </pre> <br><p>  Le message <code>handle_request</code> reste inchang√©.  Mais dans le message <code>timeout_elapsed</code> nous stockons maintenant non <code>request_handle_t</code> , mais response_builder du type dont nous avons besoin.  Plus un compteur des pi√®ces restantes.  D√®s que ce compteur est r√©initialis√©, le service de demande se termine. </p><br><p>  Maintenant, nous pouvons regarder une nouvelle version de la fonction <code>processing_thread_func()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processing_thread_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::random_device rd; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mt19937 generator{rd()}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;&gt; pause_generator{<span class="hljs-number"><span class="hljs-number">350</span></span>, <span class="hljs-number"><span class="hljs-number">3500</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delayed_ch = so_5::create_mchain(req_ch-&gt;environment()); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> stop = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; select( so_5::from_all() .on_close([&amp;stop](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;) { stop = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }) .stop_on([&amp;stop]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stop; }), case_(req_ch, [&amp;](handle_request cmd) { <span class="hljs-comment"><span class="hljs-comment">//    ,    . auto resp = cmd.m_req-&gt;create_response&lt;output_t&gt;(); resp.append_header( restinio::http_field::server, "RESTinio" ) .append_header_date_field() .append_header( restinio::http_field::content_type, "text/plain; charset=utf-8" ); //    ,  RESTinio //   . resp.flush(); //       . so_5::send_delayed&lt;so_5::mutable_msg&lt;timeout_elapsed&gt;&gt;(delayed_ch, //     . std::chrono::milliseconds{pause_generator(generator)}, //    timeout_elapsed. //     response_builder-  . std::move(resp), 3); }), case_(delayed_ch, [&amp;](so_5::mutable_mhood_t&lt;timeout_elapsed&gt; cmd) { //      . cmd-&gt;m_resp.append_chunk( "this is the next part of the response\n" ); //  RESTinio   . cmd-&gt;m_resp.flush(); cmd-&gt;m_counter -= 1; if( 0 != cmd-&gt;m_counter ) { //        . so_5::send_delayed( delayed_ch, std::chrono::milliseconds{pause_generator(generator)}, std::move(cmd)); } else // ,   . cmd-&gt;m_resp.done(); }) ); }</span></span></code> </pre> <br><p>  C'est-√†-dire     ,        .       .         . </p><br><p> <strong>Upd.</strong>   <code>flush()</code>   ,     <code>done()</code> : RESTinio   ,   I/O-    ,   <code>flush()</code> ,  ,  RESTinio  -   request_handler-.  C'est-√†-dire    <code>flush()</code>     ,        , ,   <code>restinio::run()</code> . </p><br><p>       ,    RESTinio    : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:02:35.106] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:02:35.106] INFO: init accept #0 [2019-05-13 15:02:35.106] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:02:39.050] TRACE: accept connection from 127.0.0.1:49280 on socket #0 [2019-05-13 15:02:39.050] TRACE: [connection:1] start connection with 127.0.0.1:49280 [2019-05-13 15:02:39.050] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:39.050] TRACE: [connection:1] continue reading request [2019-05-13 15:02:39.050] TRACE: [connection:1] received 78 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:02:39.050] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:39.050] TRACE: [connection:1] start response (#0): HTTP/1.1 200 OK [2019-05-13 15:02:39.050] TRACE: [connection:1] sending resp data, buf count: 1, total size: 167 [2019-05-13 15:02:39.050] TRACE: [connection:1] outgoing data was sent: 167 bytes [2019-05-13 15:02:39.050] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:39.050] TRACE: [connection:1] should keep alive [2019-05-13 15:02:40.190] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:40.190] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:40.190] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:40.190] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:40.190] TRACE: [connection:1] should keep alive [2019-05-13 15:02:43.542] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:43.542] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:43.542] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:43.542] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:43.542] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { not_final_parts, connection_keepalive }, write group size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] start next write group for response (#0), size: 3 [2019-05-13 15:02:46.297] TRACE: [connection:1] sending resp data, buf count: 3, total size: 42 [2019-05-13 15:02:46.297] TRACE: [connection:1] append response (#0), flags: { final_parts, connection_keepalive }, write group size: 1 [2019-05-13 15:02:46.297] TRACE: [connection:1] outgoing data was sent: 42 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start next write group for response (#0), size: 1 [2019-05-13 15:02:46.298] TRACE: [connection:1] sending resp data, buf count: 1, total size: 5 [2019-05-13 15:02:46.298] TRACE: [connection:1] outgoing data was sent: 5 bytes [2019-05-13 15:02:46.298] TRACE: [connection:1] finishing current write group [2019-05-13 15:02:46.298] TRACE: [connection:1] should keep alive [2019-05-13 15:02:46.298] TRACE: [connection:1] start waiting for request [2019-05-13 15:02:46.298] TRACE: [connection:1] continue reading request [2019-05-13 15:02:46.298] TRACE: [connection:1] EOF and no request, close connection [2019-05-13 15:02:46.298] TRACE: [connection:1] close [2019-05-13 15:02:46.298] TRACE: [connection:1] close: close socket [2019-05-13 15:02:46.298] TRACE: [connection:1] close: timer canceled [2019-05-13 15:02:46.298] TRACE: [connection:1] close: reset responses data [2019-05-13 15:02:46.298] TRACE: [connection:1] destructor called</code> </pre> <br><p>   ,  RESTinio           167 .          ,           , RESTinio          . </p><br><p>   ,    RESTinio   -     response_builder     ,        . </p><br><p>      .        , ,     .       response_builder   .     ,   responce_builder       ,          .. </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . </p><br><h2 id="chto-budet-esli-obrabotka-zaprosa-zaymet-slishkom-mnogo-vremeni">  ,       ? </h2><br><p> ,   request_handler-     -   .  ,      ,           ? </p><br><p>  RESTinio    ,   -  request_handler-.    - ,     , RESTinio       . ,         . , : </p><br><pre> <code class="plaintext hljs">[2019-05-13 15:32:23.618] TRACE: starting server on 127.0.0.1:8080 [2019-05-13 15:32:23.618] INFO: init accept #0 [2019-05-13 15:32:23.618] INFO: server started on 127.0.0.1:8080 [2019-05-13 15:32:26.768] TRACE: accept connection from 127.0.0.1:49502 on socket #0 [2019-05-13 15:32:26.768] TRACE: [connection:1] start connection with 127.0.0.1:49502 [2019-05-13 15:32:26.768] TRACE: [connection:1] start waiting for request [2019-05-13 15:32:26.768] TRACE: [connection:1] continue reading request [2019-05-13 15:32:26.768] TRACE: [connection:1] received 78 bytes [2019-05-13 15:32:26.768] TRACE: [connection:1] request received (#0): GET / [2019-05-13 15:32:30.768] TRACE: [connection:1] handle request timed out [2019-05-13 15:32:30.768] TRACE: [connection:1] close [2019-05-13 15:32:30.768] TRACE: [connection:1] close: close socket [2019-05-13 15:32:30.768] TRACE: [connection:1] close: timer canceled [2019-05-13 15:32:30.768] TRACE: [connection:1] close: reset responses data [2019-05-13 15:32:31.768] WARN: [connection:1] try to write response, while socket is closed [2019-05-13 15:32:31.768] TRACE: [connection:1] destructor called</code> </pre> <br><p>   -       . ,      ,  RESTinio   , ..     . </p><br><p>   -    <code>handle_request_timeout</code> ,     RESTinio- ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> ). </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p> ,   ,      RESTinio ‚Äî   ,   .  ,     RESTinio,    ,        RESTinio,     . </p><br><p>      RESTinio        ,  , ,  :  ? -  ? -  ? - -  ? </p><br><p>  PS.    RESTinio     ,   SObjectizer,    .  ,  -   RESTinio ,     : " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> C++      HTTP-   </a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> HTTP-  C++:   RESTinio,   libcurl.  1</a> ", " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shrimp:     HTTP    C++  ImageMagic++, SObjectizer  RESTinio</a> " </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr451728/">https://habr.com/ru/post/fr451728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr451718/index.html">Cr√©er un assistant vocal</a></li>
<li><a href="../fr451720/index.html">Chargement de FIAS dans la base de donn√©es sur MSSQLSERVER par des moyens improvis√©s (SQLXMLBULKLOAD). Comment cela (probablement) n'a pas besoin d'√™tre fait</a></li>
<li><a href="../fr451722/index.html">Biblioth√®que de widgets asynchrones Qt-async</a></li>
<li><a href="../fr451724/index.html">Skyrmion √† skyrmion discord: skyrmions polaires tridimensionnels dans les ferro√©lastiques</a></li>
<li><a href="../fr451726/index.html">Vous cherchez du travail √† l'√©tranger: 7 conseils simples pour les professionnels de l'informatique</a></li>
<li><a href="../fr451738/index.html">Br√®ve revue de l'article "DeViSE: un mod√®le d'int√©gration visuelle et s√©mantique profonde"</a></li>
<li><a href="../fr451742/index.html">Un jour avant DotNext 2019 Piter. Annonce de diffusion gratuite</a></li>
<li><a href="../fr451746/index.html">MegaSlerm pour les ing√©nieurs et architectes Kubernetes</a></li>
<li><a href="../fr451748/index.html">Surveillance de l'√©tat du SSD dans les baies Qsan</a></li>
<li><a href="../fr451750/index.html">Livre "Elasticsearch, Kibana, Logstash et Next Generation Search Engine"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>