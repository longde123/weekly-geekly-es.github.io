<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚷 👋 ™️ Blazor + MVVM = Silverlight反击，因为远古邪恶无敌 🤶🏻 🧓🏿 🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 

 因此，是的，net core 3.0即将推出，并且将有一个项目模板，其中Blazor是默认模板之一。 在我看来，该框架的名称类似于某些Pokemon的名称。 开拓者开始战斗！ 我决定看一下它是哪种动物，以及它被吃什么，所以我在上面制作了一个待办事项表。 好吧，也可以在Vue.js上与...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blazor + MVVM = Silverlight反击，因为远古邪恶无敌</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463197/"> 哈Ha！ <br><br> 因此，是的，net core 3.0即将推出，并且将有一个项目模板，其中Blazor是默认模板之一。 在我看来，该框架的名称类似于某些Pokemon的名称。 开拓者开始战斗！ 我决定看一下它是哪种动物，以及它被吃什么，所以我在上面制作了一个待办事项表。 好吧，也可以在Vue.js上与主题进行比较，因为在我看来，它们在组件和反应性方面都类似于组件系统，仅此而已。 更多女神神灵！ 实际上，这是一个指南，面向那些懒于学习TypeScript或JavaScript并且想要在网站上进行按钮和输入的懒惰的年轻人。 就像那个模因一样-“这位技术人员想写一本书，但指示却出来了。” 谁对我在前端的冒险感兴趣，或者发现欢迎您使用哪种Blazor。 <a name="habracut"></a><br><br><h2> 引言 </h2><br> 微软曾经有过在浏览器中使用C＃的想法，并将其称为Silverlight。 它没有起飞。 然后，您的这些tyrnet与实际的浏览器有所不同。 我为什么认为它现在正在起飞？ 因为现在默认情况下，Web程序集在所有现代浏览器中都可用。 无需安装单独的扩展。 另一个问题是应用程序大小。 如果Vue.js SPA的重量为1.7兆字节，那么Blazor的21兆字节完全相同。 现在，Internet变得比Silverlight时代更快，更可靠，您需要下载一次应用程序，然后就可以拥有缓存和所有内容。 通常，Blazor看起来与Vue.js非常相似。 因此，为了向Silverligtht，WPF和UWP致敬，并且因为在Sharper中如此普遍，我决定在项目中使用MVVM模式。 因此，仅供参考-我通常是后端，我喜欢Blazor。 我警告我-例子中的设计和布局非常糟糕，在使用Vue.js的项目中，经验丰富的前端作家可以看到很多govnokod。 好吧，有了拼写和标点符号，事情也就这样。 <br><br><h2> 参考文献 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vue + Vuex上的Todo示例</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Blazor上的Todo示例</a> <br><br><h2> 展示位置模型 </h2><br><ol><li> 在客户端。 可以以多种方式分发的标准SPA。 在我的示例中，我使用了一个模板，在其中将应用程序文件发送到asp.net核心上的浏览器服务器。 这种方法的缺点是需要下载到浏览器的那21兆字节。 </li><li> 在服务器端。 一切都在服务器上发生，完成的DOM通过套接字传递给客户端。 浏览器一开始根本不需要下载任何东西，而是不断地分段下载更新的DOM。 好吧，客户端代码的全部负载突然落到了服务器上。 </li></ol><br> 我个人更喜欢第一种选择，并且可以在不需要担心用户转换的所有情况下使用。 例如，这是公司的某种内部信息系统或专用的B2B解决方案，因为Blazor首次下载已很长时间。 如果您的用户不断登录到您的应用程序，那么他们将不会注意到与JS版本的任何区别。 如果用户单击广告链接，则只需查看那里的网站类型，很可能他不会等待很长时间就可以加载并离开网站。 在这种情况下，最好使用第二个放置选项，即 服务器端西装外套 <br><br><h2> 项目创建 </h2><br> 下载Net Core 3.0 <a href="">dotnet.microsoft.com/download/dotnet-core/3.0</a> <br> 在终端中运行命令，该命令将为您加载必要的模板。 <br><br><pre><code class="bash hljs">dotnet new -i Microsoft.AspNetCore.Blazor.Templates</code> </pre> <br> 创建服务器端 <br><br><pre> <code class="bash hljs">dotnet new blazorserverside -o MyWebApp</code> </pre><br> 对于客户端，其文件将由asp.net核心服务器分发 <br><br><pre> <code class="bash hljs">dotnet new blazorhosted -o MyWebApp</code> </pre><br> 如果您想了解异国情调并突然决定不将asp.net core用作服务器，则可以使用其他命令（是否完全需要它？），使用此命令只能创建一个没有服务器的客户端。 <br><br><pre> <code class="bash hljs">dotnet new blazor -o MyWebApp</code> </pre><br><h2> 绑定 </h2><br> 支持单向和双向绑定。 因此，是的，您不需要像WPF中的任何OnPropertichanged。 更改视图模型时，布局会自动更改。 <br><br><pre> <code class="cs hljs">&lt;label&gt;One way binding:&lt;/label&gt; &lt;br /&gt; &lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>=@Text /&gt; &lt;br /&gt; &lt;label&gt;Two way binding:&lt;/label&gt; &lt;br /&gt; &lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> @bind=@Text /&gt; &lt;br /&gt; &lt;label&gt;Two way binding         Text   oninput:&lt;/label&gt; &lt;br /&gt; &lt;input type=<span class="hljs-string"><span class="hljs-string">"text"</span></span> @bind=@Text @bind:<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>=<span class="hljs-string"><span class="hljs-string">"oninput"</span></span> /&gt; <span class="hljs-comment"><span class="hljs-comment">//ViewModel @code{ string Text; async Task InpuValueChanged() { Console.WriteLine("Input value changed"); } }</span></span></code> </pre><br> 因此，这里有一个具有Text字段的ViewModel（匿名）。 <br><br> 在第一个输入中，通过“ value = @ Text”，我们进行了单向绑定。 现在，当我们在代码中更改文本时，输入中的文本将立即更改。 只有这样我们才能在输入中不进行打印，这才以任何方式影响我们的VM。 在第二个输入中，通过“ @ bind = @ Text”，我们进行了双向绑定。 现在，如果我们在输入中编写新内容，我们的VM将立即更改，反之亦然，即 如果我们更改代码中的“文本”字段，那么我们的输入将立即显示新值。 有一个BUT-默认情况下，更改与输入的onchange事件相关，因此VM仅在完成输入后才会更改。 在第三个输入“ @bind：event =” oninput“”中，我们现在每次将某些字符打印到新值时，都会将用于将VM数据传输到oninput的事件更改为oninput。 例如，您还可以指定DateTime的格式。 <br><br><pre> <code class="cs hljs">&lt;input @bind=@Today @bind:format=<span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd"</span></span> /&gt;</code> </pre> <br><h2> 查看模型 </h2><br> 您可以将其设为匿名，然后需要在“ @code {}”块中将其停止 <br><br><pre> <code class="cs hljs">@page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> &lt;p&gt;  @UserName &lt;/p&gt; @code{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserName{<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre><br> 或者您可以将其放在单独的文件中。 然后必须从ComponentBase继承它，并在页面顶部使用“ @inherits”指定指向我们的VM的链接 <br><br> 举个例子 <br><br>  TodoViewModel.cs： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TodoViewModel</span></span>: <span class="hljs-title"><span class="hljs-title">ComponentBase</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserName{<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre><br>  Todo.razor： <br><br><pre> <code class="cs hljs">@page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> @inherits MyWebApp.ViewModels.TodoViewModel &lt;p&gt;  @UserName &lt;/p&gt;</code> </pre><br><h2> 路由选择 </h2><br> 在页面的开头使用“ @page”指示页面将响应的路由。 而且，可能有几个。 将按照从上到下的顺序选择完全匹配的第一个。 例如： <br><br><pre> <code class="cs hljs">@page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> @page <span class="hljs-string"><span class="hljs-string">"/todo/delete"</span></span> &lt;h1&gt; Hello!&lt;/h1&gt;</code> </pre><br> 此页面将以“ / todo”或“ todo / delete”打开 <br><br><h2> 版面 </h2><br> 通常，通常在几页上放置相同的内容。 像侧边栏，等等。 <br><br> 为了首先使用布局，您需要创建它。 必须使用“ @inherits”从LayotComponentBase继承。 举个例子 <br><br><pre> <code class="cs hljs">@inherits LayoutComponentBase &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"sidebar"</span></span>&gt; &lt;NavMenu /&gt; &lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"main"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-row px-4"</span></span>&gt; &lt;a href=<span class="hljs-string"><span class="hljs-string">"http://blazor.net"</span></span> target=<span class="hljs-string"><span class="hljs-string">"_blank"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"ml-md-auto"</span></span>&gt;About&lt;/a&gt; &lt;/div&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"content px-4"</span></span>&gt; @Body &lt;/div&gt; &lt;/div&gt;</code> </pre><br> 其次，它需要导入。 为此，在包含使用它的页面的目录中，您需要创建_imports.razor文件，然后在该文件中添加“ @layout”行 <br><br><pre> <code class="cs hljs">@layout MainLayout @<span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System</code> </pre><br> 第三，您可以在页面上指示其直接使用哪种布局 <br><br><pre> <code class="cs hljs">@layout MainLayout @page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> @inherits BlazorApp.Client.Presentation.TodoViewModel &lt;h3&gt;Todo&lt;/h3&gt;</code> </pre><br> 通常，_imports.razor及其在其中使用会作用于与它位于同一文件夹中的所有页面。 <br><br><h2> 路线选项 </h2><br> 首先，在我们的路线中，使用大括号表示参数及其类型（不区分大小写）。 支持标准类型。 所以是的，没有可选参数，即 值必须始终传递。 <br><br> 可以通过在ViewModel中创建一个与参数同名的属性并使用[Parameter] BTB属性来获取值本身-之前已经遇到过-父组件中的数据和事件也可以使用[Parameter]属性以及级联参数从父组件中传输。 它们从父组件传递到其所有子组件及其子组件。 它们主要用于样式，但是最好只使用CSS样式，所以为什么不在乎。 <br><br><pre> <code class="cs hljs">@page <span class="hljs-string"><span class="hljs-string">"/todo/delete/{id:guid}"</span></span> &lt;h1&gt; Hello!&lt;/h1&gt; @code{ [Parameter] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Guid Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><h2>  DI </h2><br> 与常规asp.net核心应用程序一样，所有内容都在Startup.cs中注册。 这里没有新内容。 但是，我们的VM依赖关系的实现仍然通过公共属性而不是通过构造函数进行。 该属性只需用[Inject]属性装饰 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeleteTodoViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ComponentBase</span></span> { [Parameter] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Guid Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICommandDispatcher CommandDispatcher { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br> 默认情况下，已经连接了3个服务。  HttpClient-好吧，你知道为什么。  IJSRuntime-从C＃调用JS代码。  IUriHelper-使用它无法重定向到其他页面。 <br><br><h2> 应用实例 </h2><br><h3>  Todo电子表格 </h3><br>  TodoTableComponent.razor： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1) &lt;table class="table table-hover"&gt; &lt;thead&gt; &lt;th&gt; &lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt; &lt;/th&gt; &lt;th&gt;&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; //2) @foreach (var item in Items) { //3) &lt;tr @onclick=@(()=&gt;ClickRow(item.Id)) class="@(item.Id == Current?"table-primary":null)"&gt; &lt;td&gt;&lt;input type="checkbox" checked="@item.IsComplite" disabled="disabled" /&gt;&lt;/td&gt; &lt;td&gt;@item.Name&lt;/td&gt; &lt;td&gt;@item.Created.ToString("dd.MM.yyyy HH:mm:ss")&lt;/td&gt; &lt;td&gt;&lt;a href="/todo/delete/@item.Id" class="btn btn-danger"&gt;&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; } &lt;/tbody&gt; &lt;/table&gt; @code { //4) [Parameter] private List&lt;BlazorApp.Client.Presentation.TodoDto&gt; Items { get; set; } [Parameter] private EventCallback&lt;UIMouseEventArgs&gt; OnClick { get; set; } [Parameter] private Guid Current { get; set; } private async Task ClickRow(Guid id) { //5 await OnClick.InvokeAsync(CreateArgs(id)); } private ClickTodoEventArgs CreateArgs(Guid id) { return new ClickTodoEventArgs { Id = id }; } //6) public class ClickTodoEventArgs : UIMouseEventArgs { public Guid Id { get; set; } } }</span></span></code> </pre><br><ol><li> 由于此组件，我们不需要“ @page”和“ @layout”，因为它不会参与路由，并且会使用父组件的布局 </li><li>  C＃代码以@符号开头。 其实和剃刀一样 </li><li><pre> <code class="cs hljs">@onclick=@(()=&gt;ClickRow(item.Id))</code> </pre> 将行单击事件绑定到我们的ViewModel的ClickRow方法 </li><li> 使用[Parameter]属性指定哪些参数将从父组件或页面转移到我们的组件或页面 </li><li> 我们调用从父组件收到的回调函数。 因此，父组件得知孩子中发生了一些事件。 函数只能包装在EventCallback &lt;&gt;参数化的EventArgs中传递。 可在此处找到EventArgs的可能列表<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-docs.microsoft.com/ru-ru/aspnet/core/blazor/components?view=aspnetcore-3.0#event-handling</a> </li><li> 由于EventArgs可能类型的列表是有限的，并且我们需要将附加的Id属性传递给父组件一侧的事件处理程序，因此我们创建了从基类继承的自己的参数类，并将其传递给事件。 是的，在父组件中，常规UIMouseEventArgs将进入事件处理程序的函数，并且需要将其转换为我们的类型，例如，使用as运算符 </li></ol><br> 用法示例： <br><br><pre> <code class="cs hljs">&lt;TodoTableComponent Items=@Items OnClick=@Select Current=@(Selected?.Id??Guid.Empty)&gt;&lt;/TodoTableComponent&gt;</code> </pre> <br><h3> 待办事项删除页面 </h3><br> 我们的ViewModel aka VM是DeleteTodoViewModel.cs： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeleteTodoViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ComponentBase</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1) [Parameter] private Guid Id { get; set; } //2) [Inject] public ICommandDispatcher CommandDispatcher { get; set; } [Inject] public IQueryDispatcher QueryDispatcher { get; set; } [Inject] public IUriHelper UriHelper { get; set; } //3) public TodoDto Todo { get; set; } protected override async Task OnInitAsync() { var todo = await QueryDispatcher.Execute&lt;GetById,TodoItem&gt;(new GetById(Id)); if (todo != null) Todo = new TodoDto { Id = todo.Id, IsComplite = todo.IsComplite, Name = todo.Name, Created = todo.Created }; await base.OnInitAsync(); } //4) public async Task Delete() { if (Todo != null) await CommandDispatcher.Execute(new Remove(Todo.Id)); Todo = null; //5) UriHelper.NavigateTo("/todo"); } }</span></span></code> </pre><br><ol><li> 路由参数“ / todo / delete / {id：guid}”在此处传递给Guid，例如，如果传递到localhost / todo / delete / ae434aae44 ... </li><li> 将服务从DI容器注入到我们的VM中。 </li><li> 只是我们VM的一个属性。 我们可以根据需要自行设置其值。 </li><li> 初始化页面后，将自动调用此方法。 在这里，我们为VM的属性设置必要的值 </li><li> 我们的VM的方法。 例如，我们可以将其绑定到单击视图的任何按钮的事件上 </li><li> 转到位于“ / todo”地址的另一页，即 她在行首有“ @page” /“ todo” <br> 我们的视图是DeleteTodo.razor： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//1) @page "/todo/delete/{id:guid}" @using BlazorApp.Client.TodoModule.Presentation @using BlazorApp.Client.Shared; //2) @layout MainLayout //3) @inherits DeleteTodoViewModel &lt;h3&gt; Todo &lt;/h3&gt; @if (Todo != null) { &lt;div class="row"&gt; &lt;div class="col"&gt; &lt;input type="checkbox" checked=@Todo.IsComplite disabled="disabled" /&gt; &lt;br /&gt; &lt;label&gt;@Todo.Name&lt;/label&gt; &lt;br /&gt; //4) &lt;button class="btn btn-danger" onclick=@Delete&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; } else { &lt;p&gt;&lt;em&gt; Todo  &lt;/em&gt;&lt;/p&gt; }</span></span></code> </pre><br><ol><li> 我们指示该国家/地区的地址为{我们网站的根地址} +“ / todo / delete /” + {某种Guid}。 例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">localhost / todo / delete / ae434aae44</a> ... </li><li> 指定我们的页面将在MainLayout.razor中呈现 </li><li> 指定我们的页面将使用DeleteTodoViewModel类的属性和方法 </li><li> 我们缩小范围，当您单击此按钮时，将调用我们虚拟机的Delete（）方法 </li></ol><br><h3> 待办事项首页 </h3><br>  TodoViewModel.cs： <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TodoViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">ComponentBase</span></span> { [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICommandDispatcher CommandDispatcher { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [Inject] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IQueryDispatcher QueryDispatcher { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//1) [Required(ErrorMessage = "  Todo")] public string NewTodo { get; set; } public List&lt;TodoDto&gt; Items { get; set; } public TodoDto Selected { get; set; } protected override async Task OnInitAsync() { await LoadTodos(); await base.OnInitAsync(); } public async Task Create() { await CommandDispatcher.Execute(new Add(NewTodo)); await LoadTodos(); NewTodo = string.Empty; } //2) public async Task Select(UIMouseEventArgs args) { //3) var e = args as TodoTableComponent.ClickTodoEventArgs; if (e == null) return; var todo = await QueryDispatcher.Execute&lt;GetById, TodoItem&gt;(new GetById(e.Id)); if (todo == null) { Selected = null; return; } Selected = new TodoDto { Id = todo.Id, IsComplite = todo.IsComplite, Name = todo.Name, Created = todo.Created }; } public void CanselEdit() { Selected = null; } public async Task Update() { await CommandDispatcher.Execute(new Update(Selected.Id, Selected.Name, Selected.IsComplite)); Selected = null; await LoadTodos(); } private async Task LoadTodos() { var todos = await QueryDispatcher.Execute&lt;GetAll, List&lt;TodoItem&gt;&gt;(new GetAll()); Items = todos.Select(t =&gt; new TodoDto { Id = t.Id, IsComplite = t.IsComplite, Name = t.Name, Created = t.Created }) .ToList(); } }</span></span></code> </pre><br><ol><li> 支持System.ComponentModel.DataAnnotations中的标准验证属性。 具体来说，在这里我们指示此字段是必填字段，并且如果用户未在输入中指定与该字段关联的值，则将显示该文本。 </li><li> 使用参数处理事件的方法。 此方法将处理子组件中的事件。 </li><li> 我们将参数转换为我们在子组件中创建的类型 </li></ol><br>  Todo.razor： <br><br><pre> <code class="cs hljs">@layout MainLayout @page <span class="hljs-string"><span class="hljs-string">"/todo"</span></span> @inherits BlazorApp.Client.Presentation.TodoViewModel &lt;h3&gt;Todo&lt;/h3&gt; &lt;h4&gt;&lt;/h4&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"row"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"col"</span></span>&gt; @<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Items == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { &lt;p&gt;&lt;em&gt;...&lt;/em&gt;&lt;/p&gt; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Items.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) { &lt;p&gt;&lt;em&gt;   .    .&lt;/em&gt;&lt;/p&gt; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1) &lt;TodoTableComponent Items=@Items OnClick=@Select Current=@(Selected?.Id??Guid.Empty)&gt;&lt;/TodoTableComponent&gt; } &lt;/div&gt; &lt;/div&gt; &lt;br /&gt; &lt;h4&gt; Todo&lt;/h4&gt; &lt;div class="row"&gt; &lt;div class="col"&gt; @if (Items != null) { //2) &lt;EditForm name="addForm" Model=@this OnValidSubmit=@Create&gt; //3) &lt;DataAnnotationsValidator /&gt; //4) &lt;ValidationSummary /&gt; &lt;div class="form-group"&gt; //5) &lt;InputText @bind-Value=@NewTodo /&gt; //6) &lt;ValidationMessage For="@(() =&gt; this. NewTodo)" /&gt; //7) &lt;button type="submit" class="btn btn-primary"&gt;&lt;/button&gt; &lt;/div&gt; &lt;/EditForm&gt; } &lt;/div&gt; &lt;/div&gt; &lt;br /&gt; &lt;h4&gt; Todo&lt;/h4&gt; &lt;div class="row"&gt; &lt;div class="col"&gt; @if (Items != null) { @if (Selected != null) { &lt;EditForm name="editForm" Model=@Selected OnValidSubmit=@Update&gt; &lt;DataAnnotationsValidator /&gt; &lt;ValidationSummary /&gt; &lt;div class="form-group"&gt; &lt;InputCheckbox @bind-Value=@Selected.IsComplite /&gt; &lt;InputText @bind-Value=@Selected.Name /&gt; &lt;button type="submit" class="btn btn-primary"&gt;&lt;/button&gt; &lt;button type="reset" class="btn btn-warning" @onclick=@CanselEdit&gt;&lt;/button&gt; &lt;/div&gt; &lt;/EditForm&gt; } else { &lt;p&gt;&lt;em&gt;     &lt;/em&gt;&lt;/p&gt; } } &lt;/div&gt; &lt;/div&gt;</span></span></code> </pre><br><ol><li> 我们调用子组件并将其VM的属性和方法作为参数传递给它。 </li><li> 带有数据验证功能的内置表单组件。 我们在其中指出，作为模型，他将使用我们的VM，并在发送有效数据时将调用其Create（）方法 </li><li> 将使用[Requared]等模型属性执行验证。 </li><li> 在这里，我将显示验证的一般错误 </li><li> 将创建带有验证的输入。 可能的标签列表为InputText，InputTextArea，InputSelect，InputNumber，InputCheckbox，InputDate </li><li> 公共字符串属性NewTodo {get; set;}的验证错误将在此处显示 </li><li> 当您单击此按钮时，将引发我们表单的OnValidSubmit事件 </li></ol><br><h3>  Startup.cs文件 </h3><br> 在这里我们注册我们的服务 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Startup</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureServices</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IServiceCollection services</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// LocalStorage  SessionStorage       //    //     Nuget  Blazor.Extensions.Storage services.AddStorage(); services.AddSingleton&lt;ITodoRepository, TodoRepository&gt;(); services.AddSingleton&lt;ICommandDispatcher, CommandDispatcher&gt;(); services.AddSingleton&lt;IQueryDispatcher, QueryDispatcher&gt;(); services.AddSingleton&lt;IQueryHandler&lt;GetAll, List&lt;TodoItem&gt;&gt;, GetAllHandler&gt;(); services.AddSingleton&lt;IQueryHandler&lt;GetById, TodoItem&gt;, GetByIdHandler&gt;(); services.AddSingleton&lt;ICommandHandler&lt;Add&gt;, AddHandler&gt;(); services.AddSingleton&lt;ICommandHandler&lt;Remove&gt;, RemoveHandler&gt;(); services.AddSingleton&lt;ICommandHandler&lt;Update&gt;, UpdateHandler&gt;(); } public void Configure(IComponentsApplicationBuilder app) { //       App.razor //        &lt;app&gt;&lt;/app&gt; app.AddComponent&lt;App&gt;("app"); } }</span></span></code> </pre><br><h2> 结语 </h2><br> 写这篇文章是为了胃口，并鼓励进一步研究Blazor。 我希望我实现了我的目标。 好吧，为了更好地研究它，我建议阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Microsoft</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方手册</a> 。 <br><br><h2> 致谢 </h2><br> 感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">AndreyNikolin</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">win32nipuh</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">SemenPV</a>在文本中发现的拼写和语法错误。 </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463197/">https://habr.com/ru/post/zh-CN463197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463183/index.html">培训Cisco 200-125 CCNA v3.0。 第13天。配置VLAN</a></li>
<li><a href="../zh-CN463185/index.html">玻利维亚地震如何在地下660公里的深度发现山脉</a></li>
<li><a href="../zh-CN463189/index.html">关于互联网上的匿名性，生活及其相对性</a></li>
<li><a href="../zh-CN463193/index.html">使用非负矩阵分解将黑白图像转换为ASCII图形</a></li>
<li><a href="../zh-CN463195/index.html">Tele2 Internet发生了什么</a></li>
<li><a href="../zh-CN463203/index.html">时间的沉重负担。 Yandex报告了与工作有关的常见错误</a></li>
<li><a href="../zh-CN463205/index.html">最初无法操作：如何在Windows 10上的笔记本电脑和32 GB的驱动器中生存</a></li>
<li><a href="../zh-CN463207/index.html">聊天机器人开发（电报+ YouTube）</a></li>
<li><a href="../zh-CN463213/index.html">对C＃新手开发人员的误解。 试图回答标准问题</a></li>
<li><a href="../zh-CN463225/index.html">WiFi企业。 FreeRadius + FreeIPA + Ubiquiti</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>