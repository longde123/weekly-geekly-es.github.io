<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöΩ üìπ ‚§¥Ô∏è Protocolo SmartCard I2C. Intercambie comandos APDU a trav√©s de la interfaz I2C üë®üèº‚Äçüîß üë®üèΩ‚ÄçüöÄ üë®‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Hace alg√∫n tiempo, particip√© en el desarrollo de un dispositivo en el que era necesario implementar la criptograf√≠a rusa. Como en el fu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protocolo SmartCard I2C. Intercambie comandos APDU a trav√©s de la interfaz I2C</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439574/"><h2>  Introduccion </h2><br>  Hace alg√∫n tiempo, particip√© en el desarrollo de un dispositivo en el que era necesario implementar la criptograf√≠a rusa.  Como en el futuro se supon√≠a que certificar√≠a esta decisi√≥n, se presentaron ciertos requisitos para la implementaci√≥n de la criptograf√≠a.  Y como una de las opciones para simplificar la implementaci√≥n de estos requisitos, consideramos la posibilidad de integrar un lector de tarjetas inteligentes en el dispositivo o instalar un chip de tarjeta inteligente, en el que ya se han implementado muchos escenarios necesarios para trabajar con informaci√≥n clave. <br><br>  Desafortunadamente, tal soluci√≥n no encaj√≥ por alguna raz√≥n, aunque si hubiera sido posible utilizar la criptograf√≠a de hardware rusa ya preparada, esto deber√≠a haber acelerado significativamente el desarrollo y la posterior certificaci√≥n del producto final.  Y las razones de la imposibilidad de usar tokens USB o tarjetas inteligentes eran bastante comunes: el dispositivo deber√≠a haber sido bastante compacto (un peque√±o m√≥dulo para dispositivos M2M o IoT), operado principalmente en modo libre de mantenimiento y operado en un amplio rango de temperatura. <br><br>  En este art√≠culo, quiero hablar sobre una posible soluci√≥n para tal caso utilizando el chip A7001, que est√° conectado al sistema a trav√©s de la interfaz I2C. <br><br><img src="https://habrastorage.org/webt/e5/bw/lh/e5bwlh2fhtuxpwj7cdmmt7ujtjc.png"><br><a name="habracut"></a><br><h2>  Problemas de implementaci√≥n de criptograf√≠a en el PAC </h2><br>  No quiero detenerme en los problemas de la certificaci√≥n de criptograf√≠a.  Quien trabaja con esto lo sabe de todos modos, pero el resto no parece necesitarlo.  Pero a√∫n vale la pena mencionar algunos puntos importantes. <br><br>  En teor√≠a, no deber√≠a haber ning√∫n problema especial con la criptograf√≠a.  Despu√©s de todo, es suficiente tomar una de las bibliotecas criptogr√°ficas, por ejemplo, OpenSSL, o cualquier otra de las muchas existentes. <br><br>  Los problemas comienzan cuando se requiere que esta soluci√≥n est√© certificada.  Y la implementaci√≥n puramente de software de criptograf√≠a en el firmware convierte el dispositivo en un dispositivo de protecci√≥n de informaci√≥n criptogr√°fica completo, que requiere un estudio minucioso en un laboratorio de pruebas.  Despu√©s de todo, cuando desarrolle una soluci√≥n usando criptograf√≠a, tarde o temprano tendr√° que pensar en cosas como un esquema clave, almacenar claves, generar n√∫meros aleatorios y otros asuntos sutiles. <br><br>  Existe un m√©todo elegante para implementar algoritmos criptogr√°ficos rusos certificados para algunas soluciones, que nos permite simplificar ligeramente el proceso de creaci√≥n de dispositivos finales y reducir el tiempo para su desarrollo y posterior certificaci√≥n.  Es suficiente incrustar una tarjeta inteligente o un chip de tarjeta inteligente en el dispositivo, utiliz√°ndolo como una especie de "ra√≠z de confianza", y as√≠ resolver un n√∫mero significativo de problemas dolorosos que requieren una larga investigaci√≥n y confirmaci√≥n en los laboratorios de pruebas. <br><br><img src="https://habrastorage.org/webt/e2/iq/6i/e2iq6i49c7ber2rkbgu6sv8fl3u.png"><br><br><h2>  Microcontrolador de tarjeta inteligente con interfaz I2C </h2><br>  Para escribir este art√≠culo, utilic√© el chip A7001, que se conecta al dispositivo final a trav√©s del bus I2C, que est√° disponible en casi cualquier dispositivo.  El chip fue proporcionado por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aladdin RD</a> , que ya tiene un firmware instalado que admite la criptograf√≠a rusa. <br><br>  El microcontrolador A7001AG (Microcontrolador de autenticaci√≥n segura) es fabricado por NXP.  De acuerdo con la hoja de datos del chip, el <b>A7001AG</b> es un microcontrolador protegido contra el acceso no autorizado basado en la arquitectura cl√°sica 80C51 con un coprocesador criptogr√°fico. <br><br>  En modo de ahorro de energ√≠a, el microcontrolador consume 50 ŒºA.  Admite voltaje de alimentaci√≥n en el rango de 1.62V a 5.5V y puede funcionar a temperaturas de ‚àí25 ¬∞ C a + 85 ¬∞ C. <br><br>  Para interactuar con dispositivos externos, la interfaz esclava I2C se utiliza con una velocidad de hasta 100 kbit / s. <br><br>  El microcontrolador est√° disponible en varias opciones de alojamiento.  Termin√© en el formato HVQFN32.  Esta es una caja de pl√°stico que mide 5x5x0.85 mm con 32 contactos y un paso de 0.5 mm. <br><br>  Apariencia del caso: <br><br><img src="https://habrastorage.org/webt/tn/7r/mz/tn7rmzk8pbzw1ezupbdv7fxvqhm.png"><br><br>  Su pinout: <br><br><img src="https://habrastorage.org/webt/tr/bo/5r/trbo5rlj2_q0v-lxbs7wbqevlu0.png"><br><br><h2>  Sistema host para conectar el chip A7001 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La placa ESP32 WiFi Kit 32 de Heltec</a> se tom√≥ como el dise√±o del sistema host con la interfaz I2C.  Cuesta menos de 1000 rublos, tiene todas las interfaces cableadas e inal√°mbricas necesarias, hay un conector para conectar una bater√≠a de litio con un circuito de carga, as√≠ como una pantalla OLED de 0.96 pulgadas. <br><br><img src="https://habrastorage.org/webt/uf/kq/li/ufkqlihfpi9w0692rq8junv0ybo.jpeg"><br><br>  Un sistema casi perfecto para la creaci√≥n de prototipos de varios dispositivos IoT y M2M, con los que siempre he querido jugar. <br><br>  La placa se puede programar tanto en el entorno de desarrollo nativo como en el IDE de Arduino.  Hay muchos ejemplos para trabajar con √©l.  Por simplicidad, me decid√≠ por el IDE Arduino est√°ndar. <br><br><h2>  Diagrama de circuito </h2><br>  El diagrama del circuito para conectar el chip A7001 se muestra en la figura.  <s>Es ligeramente diferente de la hoja de datos recomendada.</s>  <s>Seg√∫n la descripci√≥n del fabricante, el terminal 22 (se√±al de reinicio RST_N) deber√≠a tener un alto potencial, pero el circuito no se inici√≥ de acuerdo con este esquema.</s>  <s>Como resultado del "golpe cient√≠fico", la operabilidad se logr√≥ conectando una resistencia pull-up R4 al conductor de potencia negativo.</s> <br><br>  <i>ACTUALIZACI√ìN: Como se sugiere en los comentarios, el esquema corresponde a la hoja de datos, mientras que la descripci√≥n de salida me confundi√≥</i> <blockquote>  RST_N - Restablecer entrada, <b>activo BAJO</b> </blockquote><br><br><img src="https://habrastorage.org/webt/ud/l3/nd/udl3nd7nz2ck8gtwkb3dhdudzqy.png"><br><br>  El circuito est√° montado en una peque√±a placa de pruebas.  Las se√±ales de alimentaci√≥n e I2C est√°n conectadas por cuatro cables de conexi√≥n, y el m√≥dulo ESP32 est√° conectado a la computadora a trav√©s de USB para recibir alimentaci√≥n en todo el circuito y llenar el firmware. <br><br><img src="https://habrastorage.org/webt/de/xz/w1/dexzw1kvlnoixvk0ko-9svuvkbg.png"><br><br><h2>  Protocolo de tarjeta inteligente I2C </h2><br>  Cuando escuch√© por primera vez sobre la conexi√≥n de microcontroladores de tarjetas inteligentes a trav√©s del bus I2C, me explicaron que la capa f√≠sica de la interfaz de la tarjeta inteligente (GOST R ISO / IEC 7816-3-2013) fue reemplazada por I2C (SMBus), y todo lo dem√°s funcion√≥ como de costumbre. Tarjetas inteligentes seg√∫n GOST R ISO / IEC 7816-4-2013 utilizando comandos APDU. <br><br>  Result√≥ que esto no es del todo cierto, o m√°s bien no lo es en absoluto.  La interacci√≥n con el microcontrolador a un alto nivel ocurre usando comandos APDU convencionales, pero tambi√©n hubo algunos "peros". <br><br><ol><li>  La interfaz I2C (SMBus) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ru.wikipedia.org/wiki/I%C2%B2C</a> es un bus con direccionamiento esclavo, que es fundamentalmente diferente de la interfaz serial UART, que est√° dise√±ada para comunicar dos dispositivos punto a punto y no utiliza direccionamiento .  Esto significa que todos los datos transmitidos (comandos APDU) deben "empaquetarse" en el formato de datos del bus I2C. </li><li>  El trabajo con una tarjeta inteligente comienza con su reinicio, generalmente apagando la alimentaci√≥n, por ejemplo, quitando f√≠sicamente la tarjeta del lector de tarjetas.  Despu√©s del restablecimiento, la tarjeta inteligente primero env√≠a el bloque de datos ATR (Respuesta para restablecer), que contiene la informaci√≥n de configuraci√≥n necesaria para configurar la interacci√≥n con la tarjeta inteligente. <br>  Y el chip en el bus I2C no es una excepci√≥n, pero en el caso de que el microcontrolador deba soldarse a la placa de circuito impreso, es posible que no tenga un circuito de suministro de energ√≠a del microcircuito o control de software de la salida de reinicio.  Por lo tanto, se implementa el reinicio del chip, incluso a nivel de los comandos del protocolo I2C. </li></ol><br>  Estos y otros problemas se resuelven en el marco del Protocolo Smart Card I2C, cuya descripci√≥n se puede encontrar en el sitio web de NXP <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">www.nxp.com/docs/en/supporting-information/AN12207.pdf</a> . <br><br><h2>  Parte de software </h2><br>  Una b√∫squeda en la biblioteca con la implementaci√≥n del <i>protocolo Smart Card I2C Protocol</i> no arroj√≥ ning√∫n resultado.  Por lo tanto, tuve que entender las especificaciones y hacer la implementaci√≥n de las funciones b√°sicas de lo que estaba a la mano. <br><br><div class="spoiler">  <b class="spoiler_title">Fuentes de croquis para Arduino IDE</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Wire.h&gt; #include &lt;vector&gt; // I2C address on chip A7001 #define ADDR_A7001 static_cast&lt;uint16_t&gt;(0x48) using namespace std; typedef std::vector&lt;uint8_t&gt; vect; //-------------------------------------------------------------------------- // Output dump data by serial port void vect_dump(const char * prefix, const vect &amp; v, const size_t start = 0, const size_t count = 0) { if(prefix) { Serial.print(prefix); } if(v.size() &lt; start) { Serial.println("Empty"); return; } for(size_t i=0; i &lt; (v.size()-start) &amp;&amp; (count == 0 || i &lt; count); i++) { uint8_t b = v[start + i]; // Format output HEX data if(i) Serial.print(" "); if(b &lt; 0x0F) Serial.print("0"); Serial.print(b, HEX); } Serial.println(""); } //-------------------------------------------------------------------------- // Send array bytes by I2C to address A7001 and read response result_size bytes vect sci2c_exchange(const vect data, const uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(data.data(), data.size()); Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); //delay(1); vect result(result_size, 0); if(result_size &gt;= 2) { result[0] = Wire.read(); // Data size CDB result[1] = Wire.read(); // PCB for(size_t i=2; i&lt;result.size()-2 &amp;&amp; Wire.available(); i++) { result[i+2] = Wire.read(); } } return result; } //-------------------------------------------------------------------------- // Read Status Code uint8_t sci2c_status(const char * msg = nullptr) { vect v = sci2c_exchange({0b0111}, 2); uint8_t status = v[1] &gt;&gt; 4; if(msg) { Serial.print(msg); // Prefix switch(status) { case 0b0000: Serial.println("OK (Ready)"); break; case 0b0001: Serial.println("OK (Busy)"); break; case 0b1000: Serial.println("ERROR (Exception raised)"); break; case 0b1001: Serial.println("ERROR (Over clocking)"); break; case 0b1010: Serial.println("ERROR (Unexpected Sequence)"); break; case 0b1011: Serial.println("ERROR (Invalid Data Length)"); break; case 0b1100: Serial.println("ERROR (Unexpected Command)"); break; case 0b1101: Serial.println("ERROR (Invalid EDC)"); break; default: Serial.print("ERROR (Other Exception "); Serial.print(status, BIN); Serial.println("b)"); break; } } return status; } static uint8_t apdu_master_sequence_counter = 0; // Sequence Counter Master, Master to Slave //-------------------------------------------------------------------------- // Send APDU void sci2c_apdu_send(const vect apdu) { vect_dump("C-APDU =&gt; ", apdu); vect data(2, 0); // 0x00 - Master to Slave Data Transmission command + reserve to length data.insert(data.end(), std::begin(apdu), std::end(apdu)); data[0] |= (apdu_master_sequence_counter &lt;&lt; 4); if(++apdu_master_sequence_counter &gt; 0b111) { apdu_master_sequence_counter = 0; } data[1] = data.size() - 2; sci2c_exchange(data, 2); delay(10); sci2c_status(""); } //-------------------------------------------------------------------------- // Receive APDU vect sci2c_apdu_recv(uint8_t result_size) { Wire.beginTransmission(ADDR_A7001); Wire.write(0b0010); // 0010b - Slave to Master Data Transmission command Wire.endTransmission(false); Wire.requestFrom(ADDR_A7001, result_size, true); vect result(result_size, 0); for(size_t i=0; i&lt;result.size() &amp;&amp; Wire.available(); i++) { result[i] = Wire.read(); } vect_dump("R-APDU &lt;= ", result); return result; } //-------------------------------------------------------------------------- void setup(){ Wire.begin(); Serial.begin(9600); while (!Serial); Serial.println(""); Serial.println("Smart Card I2C Protocol Arduino demo on A7001"); Serial.println(""); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); sci2c_exchange({0b00001111}, 2); //The bits b0 to b5 set to 001111b indicate the Wakeup command. sci2c_status("Status Wakeup: "); // Soft Reset sci2c_exchange({0b00011111}, 2); //The bits b0 to b5 set to 011111b indicate the Soft Reset command. delay(5); // Wait at least tRSTG (time, ReSeT Guard) sci2c_status("Status SoftReset: "); // Read ATR vect ATR = sci2c_exchange({0b101111}, 29+2); //The bits b0 to b5 set to 101111b indicate the Read Answer to Reset command. sci2c_status("Status ATR: "); vect_dump("ATR: ", ATR, 2); // Parameter Exchange // The bits b0 to b5 set to 111111b of the PCB send by the master device indicate the Parameter Exchange command. // The bits b6 and b7 of the PCB send by the master device code the CDBIsm,max(Command Data Bytes Integer, Slave to Master, MAXimum) vect CDB = sci2c_exchange({0b11111111}, 2); sci2c_status("Status CDB: "); vect_dump("CDB: ", CDB, 1); // Further examples of the exchange of APDU // Exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); // Read Card Production Life Cycle sci2c_apdu_send({0x80, 0xCA, 0x9F, 0x7F, 0x00}); sci2c_status("Status card LC send: "); sci2c_apdu_recv(0x30+1); // R-APDU size + 1 byte PBC sci2c_status("Status card LC recv: "); // Read Card Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0x66, 0x00}); sci2c_status("Status card info send: "); sci2c_apdu_recv(0x51+1); // R-APDU size + 1 byte PBC sci2c_status("Status card info recv: "); // Read Key Info sci2c_apdu_send({0x80, 0xCA, 0x00, 0xE0, 0x00}); sci2c_status("Status key send: "); sci2c_apdu_recv(0x17+1); // R-APDU size + 1 byte PBC sci2c_status("Status key recv: "); // Again exchanges APDU from exmaple chapter sci2c_apdu_send({0x00, 0xA4, 0x04, 0x04, 0x04, 0x54, 0x65, 0x73, 0x74, 0x00}); sci2c_status("Status Test send: "); sci2c_apdu_recv(3+1); // R-APDU size + 1 byte PBC sci2c_status("Status Test recv: "); Serial.println("Done!\n"); } //-------------------------------------------------------------------------- void loop() { delay(100); }</span></span></span></span></code> </pre> <br></div></div><br>  Para trabajar con el puerto I2C, utilic√© la biblioteca est√°ndar de Wire.  Debo decir de inmediato que esta biblioteca no es adecuada para la implementaci√≥n completa del Protocolo Smart Card I2C, porque  no permite controlar ACK y NACK al transmitir y leer bytes individuales, lo cual es necesario para implementar la recepci√≥n correcta de datos de longitud variable desde una tarjeta inteligente. <br><br>  S√≠, y los ejemplos habituales del c√≥digo Wire no funcionaron la primera vez, pero despu√©s de bailar con un teclado de <s>pandereta</s> , varios litros de caf√©, buscar en Google en Yandex y Yandex en Google, se encontr√≥ una soluci√≥n. <br><br><pre> <code class="cpp hljs">Wire.write ( ); Wire.endTransmission (<span class="hljs-literal"><span class="hljs-literal">false</span></span>); Wire.requestFrom (ADDR_A7001, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  A juzgar por la documentaci√≥n de la biblioteca, este dise√±o no libera el bus I2C despu√©s de llamar a <i>endTransmission</i> .  Pero result√≥ que para el m√≥dulo basado en ESP32 que utilic√©, la transferencia de datos no ocurre f√≠sicamente durante la llamada a <i>endTransmission (falso)</i> , como est√° escrito en la documentaci√≥n de la biblioteca Wire, sino durante la llamada a <i>requestFrom (true)</i> , mientras que los datos solo se ponen en cola antes de esto para transferir. <br><br>  Dadas tales limitaciones, tuve que hacer algunas "muletas", pero realmente quer√≠a lanzar el chip A7001 sin reescribir las bibliotecas est√°ndar.  Debido a esto, no se implement√≥ el manejo de errores de protocolo, y tampoco fue posible recibir datos de longitud variable (es decir, siempre debe especificar el n√∫mero exacto de bytes para leer). <br><br>  Dichas restricciones no est√°n permitidas en un sistema real, pero no son esenciales para demostrar el uso de comandos APDU cuando se trabaja en el bus I2C.  Por lo tanto, si se produce un error en el protocolo de intercambio al intercambiar datos a trav√©s del puerto I2C, entonces el interruptor de encendido / apagado es nuestro. <br>  En otras palabras, si durante la repetici√≥n de estos experimentos todo funcion√≥ y de repente se detuvo antes de buscar un error en el c√≥digo, apague y vuelva a encender.  Con un alto grado de probabilidad, esto puede solucionar el problema. <br><br><h2>  Ejemplos de c√≥digo para trabajar con el chip A7001 </h2><br>  En los ejemplos, uso varias funciones de ayuda: <br><br>  <b>vect_dump</b> : <b>env√≠a</b> datos de volcado en formato HEX al puerto de depuraci√≥n; <br>  <b>sci2c_exchange</b> : env√≠a una matriz de datos a trav√©s de I2C y lee el n√∫mero especificado de bytes de respuesta; <br>  <b>sci2c_status</b> : lee el estado de respuesta del microcircuito y, si es necesario, muestra su estado en el puerto de depuraci√≥n; <br>  <b>sci2c_apdu_send</b> - env√≠a un comando APDU; <br>  <b>sci2c_apdu_recv</b> - lee la respuesta al comando APDU. <br><br><h3>  Inicializaci√≥n de microchip </h3><br>  De acuerdo con la descripci√≥n del <i>Protocolo I2C</i> de la <i>tarjeta inteligente</i> , antes de comenzar a trabajar con el chip, se deben ejecutar tres comandos secuencialmente: reiniciar (restablecimiento en fr√≠o o suave), leer ATR (leer respuesta para restablecer) y configurar par√°metros de intercambio (par√°metro de intercambio del dispositivo maestro).  Y solo despu√©s de eso, el chip est√° listo para aceptar comandos APDU. <br><br><h3>  Restablecimiento parcial </h3><br>  Aqu√≠ todo es simple, enviamos un comando de reinicio y esperamos el tiempo establecido: <br><br><pre> <code class="cpp hljs">sci2c_exchange ({<span class="hljs-number"><span class="hljs-number">0b00011111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); delay(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      (tRSTG, time, ReSeT Guard)</span></span></code> </pre><br><h3>  Leer respuesta para restablecer </h3><br>  Leer ATR es un poco m√°s complicado, ya que  no solo debe enviar un comando, sino tambi√©n leer los datos de respuesta.  De acuerdo con la descripci√≥n del protocolo, el tama√±o m√°ximo de los CDBATS de datos devueltos, MAX (Bytes de datos de comando, Respuesta para restablecer, MAXimum) puede ser de 29 bytes. <br><br><pre> <code class="cpp hljs">vect ATR = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b101111</span></span>}, <span class="hljs-number"><span class="hljs-number">29</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 29  + 1  PCB + 1  ‚Äî   vect_dump("ATR: ", ATR);</span></span></code> </pre><br>  Leer datos ATR: <b>1E 00 00 00 B8 03 11 01 05 B9 02 01 01 BA 01 01 BB 0D 41 37 30 30 31 43 47 20 32 34 32 52 31</b> <br><br>  Donde 1E es el tama√±o de los datos devueltos (29 bytes + 1 byte de la PCB) y 00 es la PCB (Byte de control de protocolo), que deber√≠a ser igual a 0 y, aparentemente, en este ejemplo, los datos no se leyeron correctamente (debe haber un byte de la PCB, y hay tres de ellos). <br><br>  Los siguientes son datos codificados en formato TLV: <br><br>  <b>B8h</b> - <i>Objeto de datos de bajo nivel</i> , tama√±o 3 bytes ( <i>11h 01h 05h</i> ); <br>  <b>B9h</b> - <i>Objeto de datos de enlace de protocolo</i> , 2 bytes de tama√±o ( <i>01h 01h</i> ); <br>  <b>BAh</b> : <i>objeto de datos de capa superior</i> , 1 byte ( <i>01h</i> ) de tama√±o; <br>  <b>BBh</b> : <i>objeto de datos del sistema operativo</i> , 13 bytes ( <i>41 37 30 30 31 43 47 20 32 34 32 52 31</i> ). <br><br>  <b>Descifrado de la configuraci√≥n de lectura del chip</b> <br>  <i>Objeto de datos de bajo nivel</i> : <b>11h</b> - versiones <b>principales</b> y secundarias del protocolo compatible. <br><br>  <i>C√≥digos de detecci√≥n de errores</i> : <b>01h</b> : soporte para la detecci√≥n de errores y el control de integridad de los datos transmitidos utilizando LRC (C√≥digo de redundancia longitudinal). <br><br>  <i>Entero en espera de trama (FWI)</i> : <b>05h</b> - retraso m√°ximo entre dos comandos.  El rango de valores puede ser de 10 ms a 5120ms, por defecto 5120ms.  El valor se calcula mediante la f√≥rmula T = 10ms x 2 ^ FWI.  Lo que en este caso nos da un retraso de 320 ms (10ms x 2 ^ 5). <br><br>  <i>Objeto de datos de enlace de protocolo</i> : consta de dos valores, <b>01h 01h</b> , que codifican el protocolo compatible y el protocolo predeterminado.  Estos valores significan soporte para el protocolo APDU [GOST R ISO / IEC 7816-3-2013], y, como puede suponer, el mismo protocolo est√° instalado de forma predeterminada. <br><br>  <i>Objeto de datos de capa superior</i> : el n√∫mero <b>01h</b> significa soporte para el formato APDU corto y extendido. <br><br>  <i>El objeto de datos del sistema operativo</i> es un identificador de hasta 15 bytes de tama√±o, como se define en el est√°ndar [GOST R ISO / IEC 7816-4-2013].  En nuestro caso, esta es la cadena " <i>A7001CG 242R1</i> ". <br><br><h3>  Par√°metro de intercambio de dispositivos maestros </h3><br>  El √∫ltimo comando para inicializar la configuraci√≥n de intercambio: <br><br><pre> <code class="cpp hljs">vect CDB = sci2c_exchange({<span class="hljs-number"><span class="hljs-number">0b11111111</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>); sci2c_status(<span class="hljs-string"><span class="hljs-string">"Status CDB: "</span></span>); vect_dump(<span class="hljs-string"><span class="hljs-string">"CDB: "</span></span>, CDB, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Valor de retorno: <b>CCh</b> - (11001100b) de acuerdo con la hoja de datos, 4 y 5 bits deben ser negaci√≥n bit a bit de los bits 2 y 3 (NNb codifica los CDBIMS negados a nivel de bit, MAX) y, de acuerdo con el valor codificado, el chip admite el tama√±o de comando m√°ximo posible de 252 bytes CDBIMS , MAX (entero de bytes de datos de comando, maestro a esclavo, valor m√°ximo). <br><br>  De acuerdo con la descripci√≥n del protocolo, despu√©s de ejecutar estos tres comandos y en ese orden, el microcircuito est√° listo para ejecutar los comandos APDU habituales (aunque parece funcionar sin establecer par√°metros de intercambio, es decir, fue suficiente para realizar un reinicio suave y leer ATR). <br><br><h2>  Ejecutando comandos APDU </h2><br>  <b>Cada ciclo de ejecuci√≥n de comandos APDU consta de los siguientes pasos:</b> <br><br><ol><li>  Enviar APDU (comando de transmisi√≥n de datos maestro a esclavo). </li><li>  Espere el tiempo de protecci√≥n para recibir y procesar el comando. </li><li>  Espere a que el procesamiento del comando lea el estado (comando de estado). </li><li>  Leer datos de respuesta (comando de transmisi√≥n de datos esclavo a maestro). </li></ol><br>  Esta l√≥gica se implementa en las <b>funciones</b> <b>sci2c_apdu_send</b> y <b>sci2c_apdu_recv</b> , y aqu√≠ hay un punto importante: en el formato del protocolo del Protocolo Smart Card I2C, hay contadores de los comandos APDU transmitidos.  Estos contadores deben controlar los dispositivos maestro y esclavo y est√°n dise√±ados para controlar la secuencia de datos transmitidos, de modo que en caso de un error de recepci√≥n sea posible transmitir o solicitar datos APDU nuevamente. <br><br>  Se pueden encontrar ejemplos de la implementaci√≥n de estas funciones en el c√≥digo, y a continuaci√≥n se encuentran solo los comandos APDU y los datos de respuesta. <br><br><h3>  Ejemplo de la hoja de datos: </h3><br>  C-APDU =&gt; <b>00 A4 04 04 04 54 65 73 74 00</b> - lea el archivo con el nombre "Prueba". <br>  R-APDU &lt;= <b>6A 86</b> : seg√∫n la hoja de datos, la respuesta debe ser <b>64 82</b> ( <i>archivo o aplicaci√≥n no encontrada</i> ), pero en nuestro caso el firmware se carga en el microcircuito, y la respuesta difiere del ejemplo descrito en la documentaci√≥n. <br><br><h3>  Ciclo de vida de producci√≥n de tarjetas de lectura </h3><br>  C-APDU =&gt; <b>80 CA 9F 7F 00</b> <br>  R-APDU &lt;= <b>9F 7F 2A 47 90 51 67 47 91 12 10 38 00 53 56 00 40 39 93 73 50 48 12 53 63 00 00 00 00 13 2C 19 30 34 30 33 39 00 00 00 00 00 00 00 00 90 00</b> <br><br><h3>  Leer Leer informaci√≥n de la tarjeta </h3><br><br>  C-APDU =&gt; <b>80 CA 00 66 00</b> <br>  R-APDU &lt;= <b>66 4C 73 4A 06 07 2A 86 48 86 FC 6B 01 60 0C 06 0A 2A 86 48 86 FC 6B 02 02 01 01 63 09 06 07 2A 86 48 86 FC 6B 03 64 0B 06 09 2A 86 48 86 FC 6B 04 02 55 65 0B 06 09 2B 85 10 86 48 64 02 01 03 66 0C 06 0A 2B 06 01 04 01 2A 02 6E 01 02 90 00</b> <br><br><h3>  Leer Leer informaci√≥n clave </h3><br>  C-APDU =&gt; <b>80 CA 00 E0 00</b> <br>  R-APDU &lt;= <b>E0 12 C0 04 01 FF 80 10 C0 04 02 FF 80 10 C0 04 03 FF 80 10 90 00</b> <br><br><h2>  En conclusi√≥n </h2><br>  Esta experiencia de implementar el intercambio de equipos APDU a trav√©s de la interfaz I2C fue muy interesante.  Incluso me encontr√© varias veces pensando que disfruto resolviendo varios problemas del campo de los circuitos, y tambi√©n de la soldadura ordinaria, desde la √∫ltima vez que tuve que recoger un soldador hace m√°s de 5 a√±os. <br><br>  Espero que este art√≠culo sea √∫til y ayude a comprender a los interesados ‚Äã‚Äãen este tema.  Escribe si el material te interesa.  Intentar√© responder a todas las preguntas de este art√≠culo, y si el tema del uso del Protocolo Smart Card I2C es interesante, intentar√© divulgarlo con m√°s detalle en las siguientes publicaciones. <br><br><h2>  Referencias </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n de la interfaz I2C (SMBus)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hoja de datos sobre el microcontrolador A7001AG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Descripci√≥n del protocolo Smart Card I2C</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GOST R ISO / IEC 7816-3-2013</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GOST R ISO / IEC 7816-4-2013</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439574/">https://habr.com/ru/post/439574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439564/index.html">Aplicaci√≥n pr√°ctica de la transformaci√≥n del √°rbol AST utilizando Putout como ejemplo</a></li>
<li><a href="../439566/index.html">Por qu√© es importante la documentaci√≥n de SRE. Parte 3</a></li>
<li><a href="../439568/index.html">SSD basados ‚Äã‚Äãen QLC: ¬øun asesino del disco duro? No realmente</a></li>
<li><a href="../439570/index.html">Magia de IPython para editar etiquetas de celda de Jupyter</a></li>
<li><a href="../439572/index.html">Dise√±o asistido por computadora de equipos electr√≥nicos.</a></li>
<li><a href="../439576/index.html">Una amplia descripci√≥n de las entrevistas de Python. Consejos y trucos</a></li>
<li><a href="../439578/index.html">A la cuesti√≥n de las transformaciones y otras operaciones.</a></li>
<li><a href="../439580/index.html">Hacer que Git para Windows funcione en ReactOS</a></li>
<li><a href="../439584/index.html">Proyecto Lenergy como un replanteamiento de las fuentes de alimentaci√≥n port√°tiles.</a></li>
<li><a href="../439586/index.html">El protocolo SPBm como base del Campus Extreme Automated</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>