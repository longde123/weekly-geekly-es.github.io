<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎡 🍶 🐙 Algoritma debugging pada grafik - sekarang dengan gambar 🧓 👨🏽‍🍳 💍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bayangkan situasi yang khas di tahun pertama: Anda membaca tentang algoritma Dinits , mengimplementasikannya, tetapi tidak berhasil, dan Anda tidak ta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritma debugging pada grafik - sekarang dengan gambar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/461473/">  Bayangkan situasi yang khas di tahun pertama: Anda membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang algoritma Dinits</a> , mengimplementasikannya, tetapi tidak berhasil, dan Anda tidak tahu mengapa.  Solusi standar adalah memulai debugging dalam langkah-langkah, setiap kali menggambar keadaan grafik saat ini di selembar kertas, tetapi ini sangat merepotkan.  Saya mencoba untuk memperbaiki situasi sebagai bagian dari proyek semester di Rekayasa Perangkat Lunak, dan dalam sebuah posting saya akan memberi tahu Anda bagaimana saya berakhir dengan plug-in untuk Visual Studio.  Anda dapat mengunduhnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> , kode sumber dan dokumentasi dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Berikut adalah screenshot dari grafik yang diperoleh untuk algoritma Dinits. <br><br><img src="https://habrastorage.org/webt/mq/m_/bg/mqm_bgawuvqn8v0wwqb9-jgm4cm.png"><a name="habracut"></a><br><br><h2>  Tentang diri saya </h2><br>  Nama saya Olga, saya lulus dari tahun ketiga dengan jurusan "Matematika Terapan dan Ilmu Komputer" di St. Petersburg HSE dengan gelar di bidang Rekayasa Perangkat Lunak.  Sebelum masuk universitas, saya tidak terlibat dalam pemrograman. <br><br><h2>  Penelitian: persyaratan </h2><br>  Di pekerjaan penelitian praktik semester fakultas kami.  Biasanya ini terjadi seperti ini: pada awal semester ada presentasi karya penelitian - perwakilan dari berbagai perusahaan menawarkan semua jenis proyek.  Kemudian siswa memilih proyek favorit mereka, pengawas memilih siswa favorit mereka, dan sebagainya.  Pada akhirnya, setiap siswa menemukan proyek untuk dirinya sendiri. <br><br>  Tetapi ada cara lain: Anda dapat secara mandiri menemukan penyelia dan proyek, dan kemudian meyakinkan kurator bahwa proyek ini benar-benar dapat menjadi R&amp;D penuh.  Untuk melakukan ini, buktikan bahwa: <br><br><ol><li>  Anda akan melakukan sesuatu yang baru.  Tentu saja, proyek tersebut mungkin memiliki analog, tetapi opsi Anda harus memiliki beberapa keunggulan dibandingkan mereka. <br></li><li>  Tugasnya seharusnya cukup sulit, yaitu, pekerjaan harus ada selama satu semester, dan bukan untuk sehari.  Pada saat yang sama, perlu bahwa proyek itu benar-benar dilakukan dalam satu semester. <br></li><li>  Proyek Anda harus bermanfaat bagi dunia.  Artinya, ketika ditanya mengapa ini perlu, Anda seharusnya tidak menjawab: "Ya, saya perlu melakukan semacam riset." <br></li></ol><br>  Saya memilih cara kedua.  Hal pertama yang harus dilakukan setelah saya setuju dengan penyelia adalah menemukan topik proyek.  Daftar ide termasuk: pemeriksa gaya kode untuk Lua, debugger yang memungkinkan Anda untuk menghitung ekspresi di bagian, dan alat untuk olimpiade / pelatihan pemrograman, yang memungkinkan Anda untuk memvisualisasikan apa yang terjadi dalam kode.  Yaitu, visualizer untuk struktur data arbitrer yang dikombinasikan dengan debugger.  Sebagai contoh, seseorang menulis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pohon Cartesius</a> , dan dalam proses simpul, tepi, simpul saat ini dan seterusnya ditarik.  Pada akhirnya, saya memutuskan untuk memikirkan opsi ini. <br><br><h2>  Rencana kerja proyek </h2><br>  Pekerjaan saya pada proyek terdiri dari tahapan-tahapan berikut: <br><br><ol><li>  <b>Studi tentang bidang studi</b> diperlukan untuk memahami apakah masalah ini telah diselesaikan (maka topik proyek harus diubah), analog apa yang ada, apa keuntungan dan kerugian yang mereka miliki yang bisa saya perhitungkan dalam pekerjaan saya. <br></li><li>  <b>Menentukan fungsionalitas spesifik</b> yang akan dimiliki alat yang dibuat.  Tema proyek dinyatakan secara abstrak, dan ini diperlukan untuk memastikan bahwa tugasnya cukup rumit, tetapi pada saat yang sama dapat diselesaikan dalam satu semester. <br></li><li>  <b>Membuat antarmuka pengguna prototipe</b> diperlukan untuk menunjukkan bagaimana alat yang dibuat dapat digunakan.  Itu menambahkan bahkan lebih spesifik daripada serangkaian fitur yang dijelaskan oleh kata-kata. <br></li><li>  <b>Pilihan ketergantungan</b> - Anda perlu memahami bagaimana semuanya akan diatur dari sudut pandang pengembang dan memutuskan alat yang akan digunakan dalam proses penulisan kode. <br></li><li>  <b>Membuat prototipe (proof-of-concept)</b> , yaitu, contoh minimal di mana sebagian besar akan di-hardcode.  Dengan contoh ini, saya harus berurusan dengan semua alat yang akan saya gunakan, dan juga belajar bagaimana menyelesaikan semua kesulitan yang muncul di sepanjang jalan, sehingga versi final sudah ditulis dengan "bersih." <br></li><li>  <b>Bekerja pada bagian konten</b> , yaitu, pengembangan dan implementasi logika alat. <br></li><li>  Diperlukan <b>perlindungan proyek</b> agar dapat dengan cepat berbicara tentang pekerjaan yang dilakukan dan untuk memberikan kesempatan untuk mengevaluasinya kepada semua orang, bahkan orang-orang yang tidak mencari-cari dalam subjek.  Ini adalah pelatihan sebelum kelulusan.  Pada saat yang sama, sebuah proyek yang dibuat dengan baik tidak menjamin bahwa laporan tersebut akan menjadi baik, karena memerlukan keterampilan lain, misalnya, kemampuan untuk berbicara kepada publik. <br></li></ol><br>  Saya selalu melakukan perencanaan dengan penyelia saya.  Kami juga selalu menemukan dan mendiskusikan semua ide yang muncul di sepanjang jalan.  Selain itu, penyelia memberi saya saran tentang kode dan membantu dengan manajemen waktu.  Tentang semua masalah teknis (bug yang tidak bisa dipahami, dll.) Saya juga selalu melaporkan, tetapi paling sering saya berhasil menyelesaikannya sendiri. <br><br><h2>  Subjek penelitian </h2><br>  Sebagai permulaan, kepemimpinan kita seharusnya diyakinkan bahwa topik ini layak menjadi pekerjaan penelitian saya.  Dan mulai dari titik pertama: pencarian analog. <br><br>  Ternyata, ada banyak analog.  Tetapi kebanyakan dari mereka dirancang untuk visualisasi memori.  Artinya, mereka akan melakukan pekerjaan yang bagus dengan visualisasi pohon Cartesian, tetapi mereka tidak dapat memahami bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan pada array</a> tidak boleh digambarkan sebagai array, tetapi sebagai pohon.  Ini termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gdbgui</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Debugger Tampilan Data</a> , plug-in untuk Eclipse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jGRASP,</a> dan plug-in untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visualizer Struktur Data</a> Studio Visual.  Yang terakhir ini juga dibuat untuk masalah pemrograman olimpiade, tetapi hanya dapat memvisualisasikan struktur data pada pointer. <br><br>  Ada beberapa alat lagi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algojammer</a> untuk python (dan kami ingin plus, sebagai bahasa paling populer di kalangan olympiadniki) dan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lens</a> dikembangkan pada 1994.  Yang terakhir, dilihat dari deskripsi, melakukan hampir apa yang diperlukan, tetapi, sayangnya, itu dibuat di bawah Sun OS 4.1.3 (sistem operasi dari 1992).  Jadi, terlepas dari ketersediaan kode sumber, diputuskan untuk tidak membuang waktu pada arkeologi yang meragukan ini. <br><br>  Jadi, setelah beberapa penelitian ditemukan bahwa Tula, yang akan melakukan apa yang kita inginkan, dan pada saat yang sama bekerja pada mesin-mesin modern, belum ada di alam. <br><br><h2>  Definisi Fungsi </h2><br>  Langkah kedua adalah membuktikan bahwa tugas ini cukup rumit, tetapi bisa dilakukan.  Untuk melakukan ini, perlu mengusulkan sesuatu yang lebih spesifik daripada "Saya ingin gambar yang indah, dan semuanya menjadi jelas darinya segera". <br><br>  Dalam proyek ini, kami memutuskan untuk berkonsentrasi pada memvisualisasikan hanya grafik: ada banyak algoritma pada grafik yang dapat diimplementasikan dengan cara yang berbeda, dan bahkan jika dipersempit, tugas masih tetap non-sepele. <br><br>  Juga kurang lebih jelas bahwa alat tersebut entah bagaimana harus diintegrasikan dengan debugger.  Kita harus dapat melihat nilai-nilai variabel dan ekspresi, dan menggambar gambar yang sudah jadi dari nilai-nilai ini. <br><br>  Setelah itu, perlu untuk membuat bahasa tertentu yang memungkinkan kita untuk membuat grafik sesuai dengan kondisi program saat ini seperti yang kita inginkan.  Selain grafik itu sendiri, perlu menyediakan kemampuan untuk mengubah warna simpul dan tepi, menambahkan label sewenang-wenang kepada mereka dan mengubah properti lainnya.  Dengan demikian, ide pertama adalah: <br><br><ol><li>  Tentukan apa yang kita miliki simpul, misalnya, angka dari 0 hingga n. <br></li><li>  Tentukan keberadaan tepi antara simpul menggunakan kondisi Boolean.  Dalam hal ini, ujung-ujungnya dari tipe yang berbeda, dan masing-masing tipe memiliki set properti sendiri. <br></li><li>  Selanjutnya, kita dapat mendefinisikan properti vertex seperti warna, juga menggunakan kondisi Boolean. <br></li><li>  Ikuti langkah-langkah dengan debugger: semua ekspresi dihitung, semua kondisi diperiksa, dan, tergantung pada ini, grafik dibuat. <br></li></ol><br><h2>  Prototipe Antarmuka Pengguna </h2><br>  Saya menggambar prototipe antarmuka pengguna di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NinjaMock</a> .  Ini diperlukan untuk lebih memahami bagaimana tampilan antarmuka dari sudut pandang pengguna, dan tindakan apa yang perlu dilakukan.  Jika ada masalah dengan prototipe, kita akan memahami bahwa ada beberapa inkonsistensi logis, dan ide ini harus dibuang.  Untuk kesetiaan, saya mengambil beberapa algoritma.  Gambar di bawah ini menunjukkan contoh bagaimana saya membayangkan pengaturan visualisasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DFS</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Floyd</a> . <br><br><img src="https://habrastorage.org/webt/_c/kw/q9/_ckwq9qv_z5-4_wayyxxb0m8sro.png"><br><br>  <i>Seperti yang saya bayangkan pengaturan untuk DFS.</i>  <i>Grafik disimpan sebagai daftar adjacency, sehingga tepi antara simpul i dan j ditentukan oleh kondisi <code>g[i].find() != g[i].end()</code> (pada kenyataannya, agar tidak menggandakan tepi, perlu untuk memeriksa bahwa <code>i &lt;= j</code> ).</i>  <i>Jalur DFS ditampilkan secara terpisah: <code>p[j] == i</code> .</i>  <i>Tepi ini akan berorientasi.</i> <i><br><br><img src="https://habrastorage.org/webt/1n/rv/28/1nrv283bilq1cslyq9urbrymgzm.png"><br><br></i>  <i>Saya berasumsi bahwa untuk algoritma Floyd, akan perlu untuk menggambar hitam tepi nyata yang disimpan dalam array <code>c</code> , dan abu-abu - jalur terpendek yang ditemukan pada tahap ini, disimpan dalam array <code>d</code> .</i>  <i>Untuk setiap tepi dan jalur terpendek, bobotnya tertulis.</i> <br><br><h2>  Pemilihan Ketergantungan </h2><br>  Untuk langkah selanjutnya, perlu dipahami bagaimana melakukan semua ini.  Pertama-tama, diperlukan integrasi dengan debugger.  Hal pertama yang terlintas dalam pikiran ketika kata "debugger" adalah gdb, tetapi kemudian Anda harus membuat seluruh antarmuka grafis dari awal, yang sangat sulit bagi siswa untuk melakukannya dalam satu semester.  Ide jelas kedua adalah membuat plugin untuk beberapa lingkungan pengembangan yang ada.  Sebagai opsi, saya mempertimbangkan QTCreator, CLion dan Visual Studio. <br><br>  Opsi CLion segera dibuang, karena, pertama, ia telah menutup kode sumber, dan kedua, semuanya sangat buruk dengan dokumentasi (dan tidak ada yang membutuhkan kesulitan tambahan).  QTCreator, tidak seperti Visual Studio, adalah cross-platform dan open source, dan karena itu, pada awalnya kami memutuskan untuk memikirkannya. <br><br>  Namun ternyata, QTCreator tidak diadaptasi dengan baik untuk ekstensi menggunakan plugin.  Langkah pertama dalam membuat plugin untuk QTCreator adalah membangun dari sumber.  Butuh saya satu setengah minggu.  Pada akhirnya, saya mengirim dua laporan bug ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sana</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ) mengenai proses perakitan.  Ya, itulah upaya yang dilakukan untuk membangun QTCreator hanya untuk mengetahui bahwa debugger di QTCreator tidak memiliki API publik.  Saya kembali ke opsi lain, yaitu Visual Studio. <br><br>  Dan ini ternyata menjadi keputusan yang tepat: Visual Studio tidak hanya memiliki API yang hebat, tetapi juga dokumentasi yang sangat baik untuk itu.  <code>_debugger.GetExpression(...).Value</code> ekspresi disederhanakan dengan memanggil <code>_debugger.GetExpression(...).Value</code> .  Visual Studio juga menyediakan kemampuan untuk beralih di atas bingkai, dan mengevaluasi ekspresi dalam konteks salah satu dari mereka.  Untuk melakukan ini, ubah properti <code>CurrentStackFrame</code> ke yang diperlukan.  Anda juga dapat melacak pembaruan untuk kontes debugger untuk menggambar ulang gambar saat berubah. <br><br>  Tentu saja, tidak seharusnya saya terlibat dalam visualisasi grafik dari awal - ada banyak perpustakaan khusus untuk ini.  Yang paling terkenal dari mereka adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Graphviz</a> , dan kami berencana untuk menggunakannya pada awalnya.  Tetapi untuk plug-in untuk Visual Studio, akan lebih logis untuk menggunakan perpustakaan untuk C #, karena saya akan menulis di atasnya.  Saya mencari Google sedikit dan menemukan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MSAGL</a> : ia memiliki semua fungsi yang diperlukan dan memiliki antarmuka yang sederhana dan intuitif. <br><br><h2>  Bukti konsep </h2><br>  Sekarang, memiliki mekanisme untuk menghitung ekspresi sewenang-wenang di satu sisi dan perpustakaan untuk memvisualisasikan grafik di sisi lain, perlu membuat prototipe.  Prototipe pertama dibuat untuk DFS, kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma</a> Dinits, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Kuhn</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian komponen yang terhubung ganda</a> , pohon Cartesian, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SNM</a> diambil sebagai contoh.  Saya mengambil implementasi lama dari algoritma ini dari tahun pertama hingga tahun kedua, membuat plug-in baru, menggambar grafik yang sesuai dengan tugas ini (semua nama variabel di-hardcode).  Berikut adalah contoh grafik yang saya dapatkan untuk algoritma Kuhn: <br><br><img src="https://habrastorage.org/webt/dr/bz/c1/drbzc1kb3yf0d2vkesimolwhhda.png"><br>  <i>Pada grafik ini, tepi pencocokan saat ini ditampilkan dalam warna ungu, deks dfs saat ini ditampilkan dalam warna merah, simpul yang dikunjungi berwarna abu-abu, tepi rantai bergantian yang bukan dari pencocokan ditampilkan dalam warna merah.</i> <br><br>  Saya menganggap itu diperbolehkan untuk sedikit mengubah kode algoritma untuk membuatnya lebih mudah untuk divisualisasikan.  Misalnya, dalam kasus pohon Cartesian, ternyata lebih mudah untuk menambahkan semua node yang dibuat ke vektor daripada memotong pohon di dalam plugin. <br><br>  Penemuan yang tidak menyenangkan adalah bahwa debugger di Visual Studio tidak mendukung metode dan fungsi panggilan dari STL.  Ini berarti bahwa tidak mungkin untuk memeriksa keberadaan elemen dalam wadah menggunakan <code>std::find</code> , seperti yang diasumsikan semula.  Masalah ini dapat diselesaikan baik dengan membuat fungsi yang ditentukan pengguna, atau dengan menduplikasi properti "elemen yang terkandung dalam wadah" dalam array Boolean. <br><br>  Di plugin percobaan saya, sesuatu seperti yang berikut terjadi (jika grafik disimpan sebagai daftar adjacency): <br><br><ol><li>  Pertama, perulangan <code>for</code> dari <code>0</code> ke <code>_debugger.GetExpression("n").Value</code> , yang menambahkan semua simpul ke grafik, masing-masing dengan nomornya sendiri. <br></li><li>  Lalu ada dua bersarang <code>for</code> <code>_debugger.GetExpression($"g[{i}].size()").Value</code> , yang pertama untuk <code>i</code> - dari <code>0</code> ke <code>n</code> , yang kedua untuk <code>j</code> - dari <code>0</code> ke <code>_debugger.GetExpression($"g[{i}].size()").Value</code> , dan tepi <code>{i, _debugger.GetExpression($"g[{i}][{j}]").Value}</code> . <br></li><li>  Jika diperlukan, beberapa informasi tambahan ditambahkan ke label simpul dan tepi.  Misalnya, nilai array <code>d</code> , yang bertanggung jawab untuk jarak ke simpul yang dipilih. <br></li><li>  Jika algoritma didasarkan pada dfs, maka satu loop melewati semua frame, dan semua simpul dalam stack ( <code>stackFrame.FunctionName.Equals("dfs") &amp;&amp; stackFrame.Arguments.Item(1) == v</code> ) disorot dengan warna abu-abu. <br></li><li>  Kemudian, untuk setiap <code>i</code> dari <code>0</code> hingga <code>n</code> , yang menunjukkan jumlah simpul, beberapa kondisi diperiksa, dan jika mereka puas, maka beberapa properti berubah di puncak, paling sering warnanya. <br></li></ol><br>  Pada saat itu, saya menulis kode “seperlunya”, tanpa mencoba membuat skema umum untuk semua algoritma, atau menulis kode setidaknya entah bagaimana dengan indahnya.  Pembuatan setiap plugin baru dimulai dengan copy-paste yang sebelumnya. <br><br><h2>  Konfigurasi grafik </h2><br>  Setelah penelitian, perlu dibuat skema umum yang dapat diterapkan untuk semua algoritma.  Hal pertama yang diperkenalkan adalah indeks untuk simpul dan tepi.  Setiap indeks memiliki nama dan rentang akhir yang unik, dihitung menggunakan <code>_debugger.GetExpression</code> .  Untuk mengakses nilai indeks, gunakan namanya yang dikelilingi oleh __ (mis. __X__).  Ekspresi dengan tempat untuk menggantikan nilai indeks, serta nama fungsi saat ini (__CURRENT_FUNCTION__) dan nilai argumennya (__ARG1__, __ARG2__, ...), disebut template. <br><br>  Indeks diganti untuk setiap titik atau tepi, dan setelah itu dihitung dalam debugger.  Templat digunakan untuk menyaring beberapa nilai indeks (jika grafik disimpan sebagai matriks adjacency <code>c</code> , maka indeks akan a dan b dari 0 ke n, dan templat untuk validasi adalah <code>c[__a__][__b__]</code> ).  Batas-batas rentang indeks juga merupakan templat, karena mungkin berisi indeks sebelumnya. <br><br>  Grafik dapat memiliki berbagai jenis simpul dan tepi.  Misalnya, dalam hal mencari pencocokan maksimum dalam grafik bipartit, setiap fraksi dapat diindeks secara terpisah.  Oleh karena itu, konsep keluarga diperkenalkan untuk simpul dan tepi.  Untuk setiap keluarga, pengindeksan dan semua properti ditentukan secara independen.  Dalam hal ini, ujung-ujungnya dapat menghubungkan simpul dari keluarga yang berbeda. <br><br>  Anda bisa menetapkan properti spesifik ke keluarga vertex atau edge yang akan diterapkan secara selektif ke elemen dalam keluarga.  Properti ini diterapkan jika kondisinya terpenuhi.  Kondisi terdiri dari templat yang mengevaluasi <code>true</code> atau <code>false</code> , dan ekspresi reguler untuk nama fungsi.  Kondisi diperiksa baik hanya untuk bingkai kaca saat ini, atau untuk semua bingkai kaca (dan kemudian dianggap terpenuhi jika dipenuhi setidaknya satu). <br><br>  Properti sangat beragam.  Untuk simpul: label, isi warna, warna batas, lebar tepi, bentuk, gaya tepi (misalnya, garis putus-putus).  Untuk tepi: label, warna, lebar, gaya, orientasi (Anda dapat menentukan dua panah - dari awal hingga akhir atau sebaliknya; dalam hal ini, bisa ada dua panah pada saat yang sama). <br><br>  Penting bahwa setiap kali grafik digambar dari awal, dan keadaan sebelumnya tidak diperhitungkan dengan cara apa pun.  Ini bisa menjadi masalah jika grafik berubah secara dinamis selama algoritme - simpul dan tepi dapat secara dramatis mengubah posisi mereka, dan kemudian sulit untuk memahami apa yang terjadi. <br><br>  Penjelasan terperinci tentang konfigurasi grafik dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Antarmuka pengguna </h2><br>  Dengan antarmuka, saya memutuskan untuk tidak terlalu repot.  Jendela utama dengan pengaturan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ToolWindow</a> ) berisi textarea untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konfigurasi</a> berseri dalam JSON dan daftar keluarga vertex dan edge.  Setiap keluarga memiliki jendela sendiri dengan pengaturan, dan setiap properti dalam keluarga memiliki satu jendela lagi (diperoleh tiga tingkat sarang).  Grafik itu sendiri digambar dalam jendela terpisah.  Tidak berfungsi untuk meletakkannya di ToolWindow, jadi saya mengirim <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan bug</a> ke pengembang MSAGL, tetapi mereka menjawab bahwa ini bukan kasus penggunaan target.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporan bug lain</a> dikirim ke Visual Studio, karena TextBox kadang-kadang tergantung di jendela pengaturan tambahan. <br><br><img src="https://habrastorage.org/webt/n2/jo/-b/n2jo-buqxeq40a03zs0wochfrl0.png"><br><br><h2>  Plugin </h2><br>  Untuk mengkonfigurasi grafik, plugin memiliki antarmuka pengguna dan kemampuan untuk (menonaktifkan) serialisasi konfigurasi dalam JSON.  Skema umum interaksi semua komponen adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/yv/kz/rx/yvkzrx4fglqdelkutvbdqzgqlj0.png"><br><br>  Biru menunjukkan komponen yang ada pada awalnya, abu-abu - yang saya buat.  Ketika Visual Studio dimulai, ekstensi diinisialisasi (di sini komponen utama ditetapkan sebagai Utama).  Pengguna mendapat kesempatan untuk menentukan konfigurasi melalui antarmuka.  Setiap kali konteks debugger diubah, komponen utama diberitahu.  Jika konfigurasi ditentukan dan program yang sedang di-debug dieksekusi, GraphRenderer diluncurkan.  Dia menerima input konfigurasi dan dengan bantuan debugger membangun grafik di atasnya, yang kemudian ditampilkan di jendela khusus. <br><br><h2>  Contohnya </h2><br>  Akibatnya, saya membuat alat yang memungkinkan Anda untuk memvisualisasikan algoritma grafik dan membutuhkan perubahan kecil dalam kode.  Ini telah diuji pada delapan tugas berbeda.  Berikut adalah beberapa gambar yang dihasilkan: <br><br><img src="https://habrastorage.org/webt/a1/lw/z6/a1lwz6jlyloms0dfmzddoxx9gxk.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma Ford-Bellman</a> : titik di mana kita menghitung jalur terpendek ditunjukkan oleh sebuah rumah, jarak terpendek saat ini yang ditemukan untuk simpul adalah d, merah menunjukkan tepi sepanjang relaksasi dilewati.</i> <br><br><img src="https://habrastorage.org/webt/5k/5h/rk/5k5hrko_liqr2kgbctgdeznbc44.gif"><br>  <i>Animasi dengan DFS - simpul saat ini ditampilkan dalam warna merah, simpul dalam tumpukan berwarna abu-abu, dan simpul yang dikunjungi lainnya berwarna hijau.</i>  <i>Iga raspberry menunjukkan arah jalan pintas.</i> <br><br>  Lebih banyak contoh algoritma tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br><h2>  Perlindungan NIR </h2><br>  Untuk melindungi pekerjaan penelitian, siswa diwajibkan dalam tujuh menit untuk menceritakan tentang pekerjaan mereka selama satu semester.  Pada saat yang sama, terlepas dari apakah topik itu diusulkan sebagai bagian dari presentasi karya penelitian atau siswa menemukannya sendiri, Anda harus dapat menjawab untuk membenarkan mengapa topik proyek berada di bawah persyaratan yang dijelaskan di awal.  Biasanya, sebuah laporan disusun sebagai berikut: pertama ada motivasi, kemudian tinjauan analog, dikatakan tentang mengapa mereka tidak sesuai dengan kita, kemudian tujuan dan sasaran dirumuskan, dan kemudian masing-masing tugas dijelaskan bagaimana hal itu diselesaikan.  Pada akhirnya ada slide dengan hasilnya, yang sekali lagi mengatakan bahwa tujuan telah tercapai dan semua tugas diselesaikan. <br><br>  Karena saya sudah memutuskan pada motivasi dan ulasan analog pada tahap awal, saya hanya perlu mengumpulkan semua informasi dan mengompresnya menjadi tujuh menit.  Pada akhirnya, saya berhasil, pertahanan berjalan lancar, saya diberi skor maksimal untuk penelitian. <br><br><h2>  Referensi </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori GitHub</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pasar visual studio</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Posting di Codeforce</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461473/">https://habr.com/ru/post/id461473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461463/index.html">Proses bisnis di perusahaan perusahaan: spekulasi dan kenyataan. Terangkan dengan R</a></li>
<li><a href="../id461465/index.html">Panduan Pengukuran</a></li>
<li><a href="../id461467/index.html">Contoh membuat aplikasi Makefile for Go</a></li>
<li><a href="../id461469/index.html">Bagaimana rasanya mendengarkan kode dengan 1000 kata per menit</a></li>
<li><a href="../id461471/index.html">.NET - Alat untuk bekerja dengan multithreading dan asynchrony - Bagian 2</a></li>
<li><a href="../id461475/index.html">AMA dengan Habr. 1011</a></li>
<li><a href="../id461483/index.html">Openstack Load Balancing</a></li>
<li><a href="../id461487/index.html">Tugas CTF Mini</a></li>
<li><a href="../id461493/index.html">Django 3.0 akan tidak sinkron</a></li>
<li><a href="../id461497/index.html">Render teks modern di Linux: bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>