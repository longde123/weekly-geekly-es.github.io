<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👶🏾 🔜 🈲 Rückentwicklung des Zeitschalters VL-76-S 🚇 ◻️ 🧘🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war einmal eine Zeit, in der ich auf die elektronische digitale Zeitschaltuhr VL-76-S stieß, die neu in der Verpackung, aber in einem fehlerhaften ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rückentwicklung des Zeitschalters VL-76-S</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414345/">  Es war einmal eine Zeit, in der ich auf die elektronische digitale Zeitschaltuhr VL-76-S stieß, die neu in der Verpackung, aber in einem fehlerhaften Zustand war.  Auf den Leiterplatten im Inneren wurden keine Mängel festgestellt.  Daher Fabrikheirat, kaputte Firmware. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cn/vj/2v/cnvj2vs2aonwmvjljydwos0ewqi.jpeg"></div><br>  <i>Gesamtansicht des Relais.</i> <br><a name="habracut"></a><br>  Was uns überraschte, war die Verwendung des beliebten und einfachen Mikrocontrollers ATTiny2313.  Äußerlich besteht diese Konstruktion aus einem Master in Form von drei Jahrzehnten langen Schaltern und einem Anschluss, an den 220-V-Strom und Kontakte eines EM-Relais angeschlossen sind.  Der Bereich der Aufgabe beträgt 0,1 ... 99,9 Minuten.  in Schritten von 0,1 min  (6 Sekunden).  Es gibt keine Schaltkreise und Firmware zu diesem Design im Internet, was nicht überraschend ist.  Ohne nachzudenken, beschloss ich, die Schaltung von den Leiterplatten zu ziehen und das Programm in Zukunft selbst auf den MK zu schreiben. <br><br>  Das Design besteht aus drei miteinander verbundenen Leiterplatten.  Auf der ersten Platine befinden sich ein Netzteil und ein TRA3-Ausführungsrelais.  Die Stromversorgung erfolgt nach einer transformatorlosen Schaltung: Löschkondensatoren werden zur Spannungsreduzierung eingesetzt.  Auf der zweiten Platine befindet sich der ATTiny2313 MK und andere Hilfselemente.  Auf der dritten Karte befinden sich Schalter (Sollwerte) und eine Steuer-LED. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/be/ew/4h/beew4hzen1salm0a6x7mlwhak2g.jpeg"></div><br>  <i>Foto der dritten Tafel von hinten.</i> <br><br>  Ich werde die Beschreibung mit der dritten Tafel beginnen.  Die Schalter sind Schalter mit 10 Positionen.  Es gibt keine Markierung auf ihnen, jeder von ihnen hat 5 Kontakte.  Daher werden je nach Position bestimmte Kontakte in verschiedenen Kombinationen geschlossen.  Beim Aufrufen von Kontakten habe ich sofort das Muster erkannt: Ein fester Ausgang (allgemein) wird mit den anderen vier Ausgängen (Informationen) entsprechend der binären Darstellung der Nummer geschlossen, die der Nummer der ausgewählten Position entspricht.  Wenn beispielsweise die Position "3" ausgewählt ist, schließt die allgemeine Ausgabe (fünfte in Folge) mit der Ausgabe der dritten und vierten, da die Zahl "3" in der Binärdarstellung "0011" ist.  Hier ist so ein kniffliger Schalter.  Und es gibt drei von ihnen.  Sie werden über XP1- und XP2-Anschlüsse mit MK an die zweite Karte angeschlossen.  Ein XP3-Anschluss verbindet eine LED und einen anderen unnötigen, nicht gelöteten Mist, für den sich ein Platz auf der Platine befindet.  Höchstwahrscheinlich handelt es sich hierbei um einen herkömmlichen sechspoligen DPDT-Schalter (z. B. einen quadratischen, z. B. PB22E06).  Vielleicht ist das Board universell, aber es wird in diesem speziellen Modell nicht verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/tv/rq/lotvrq9ovoeetew2zmaa6sauury.jpeg"></div><br>  <i>Foto der zweiten (Haupt-) Tafel.</i> <br><br>  Als ich die Kontakte der Switches anrief, verstand ich das Prinzip ihrer Verbindung zu den MK-Ports nicht sofort.  Auf der Hauptplatine sind sofort 8 SMD-Transistoren erkennbar.  Er fand später heraus, dass diese Transistoren als Diodenpaare mit einer gemeinsamen Anode verwendet werden.  Ihre Basen gehen zu MK-Ports, und Kollektoren und Emitter gehen zu Schaltkontakten.  Dann erklärten sie mir, dass es in solchen Fällen Diodenpaare gibt, die wie Transistoren klingeln, aber keine Transistoren sind.  Insgesamt haben wir 16 Leiter, die die Diodenpaare auf der dritten Platine belassen.  Drei Viertel von ihnen (12 Stück) kommen zu den Informationskontakten der Schalter (drei bis vier), und vier bleiben frei.  Es ist leicht zu erraten, dass sie theoretisch für den vierten Schalter vorgesehen sind, der irgendwie nicht fehlt, da auf der Platine überhaupt kein Platz dafür vorhanden ist.  Um die Logik des Denkens nicht zu verletzen, werde ich diesen imaginären vierten Schalter erwähnen.  Die gemeinsamen Enden des zweiten und dritten Schalters sowie des ersten und vierten Schalters (der vierte sieht jedoch nicht die Platine vor) sind paarweise durch Schienen in der Hauptplatine an den Gegensteckern XS1 und XS2 miteinander verbunden.  Diese beiden Paare sind mit den Ausgängen von Transistorgruppen verbunden.  Diese beiden identischen Gruppen werden auf den Transistoren BC857 und BC847 (unterschiedliche Strukturen) hergestellt.  Ihre Eingänge sind mit dem MK verbunden.  Wenn Sie eine logische "0" auf die Eingabe dieser Gruppe anwenden, ist die Ausgabe auch eine logische "0".  Auf der Karte befinden sich außerdem ein XP2-Anschluss für die MK-Firmware, der an die SPI-Anschlüsse der MK-Schnittstelle angeschlossen ist, ein XS3-Anschluss für eine LED und ein XP1-Anschluss, der über ein Kabel mit der ersten Karte verbunden ist.  Es sollte beachtet werden, dass einige der MK-Ports sowohl für SPI (für Firmware) als auch für gewöhnliche Eingabe-Ausgabe (Arbeit in der Schaltung) verwendet werden können. <br><br>  All das spiegelt sich in den Diagrammen wider, die ich zuerst im Entwurf, dann in SPlan gezeichnet habe.  Die Bewertungen von Funkelementen, die nicht markiert wurden (z. B. SMD-Kondensatoren), fehlen in den Diagrammen, sie sind nicht so wichtig.  Zuerst werde ich ein Diagramm der Hauptplatine und der Platine mit den Setzern geben (Signaturen der Bilder unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/r8/gr/4cr8gr6u5edycy869h9wuyprgs0.gif"></div><br>  <i>Schema der Hauptplatine.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pg/sx/uy/pgsxuy7cgafwqwabsx39prgwkgw.gif"></div><br><br>  <i>Schema der dritten Tafel mit Setzern</i> <br><br>  Überlegen Sie, wie die Abfrage jedes Setzers.  Die Signale von den Anschlüssen PB4 und PB5 MK logisch "0" öffnen die Transistoren VT2 und VT1, gefolgt von VT4 und VT3, und verbinden sich mit den gemeinsamen Nullbuskontakten der Schalter Nr. 1 bzw. Nr. 2-Nr. 3.  Dies geschieht wiederum.  Erstens kommt die logische „0“ von PB4 (PB5 wurde bisher auf die logische „1“ gesetzt) ​​und verbindet den zweiten und dritten Schalter.  In diesem Zustand werden die Werte der Signale wiederum von der Steuerung von den Eingangsports PB3, PB2, PB1, PB0 über die Diodengruppen 2VD1 ... 2VD4 von den zweiten und fehlenden vierten Schaltern aufgezeichnet.  Sofort sind die Werte der Signale von den Pins PD6, PD5, PD4, PD3 MK festgelegt, auf die die Signale vom ersten und dritten Schalter über die Diodengruppen 2VD5 ... 2VD8 kommen.  Da jedoch nur der zweite und der dritte Schalter durch einen gemeinsamen Kontakt verbunden sind, kommen die Signale vom zweiten Schalter zu den ersten angegebenen Ports des MK und der vierte wird ignoriert.  In ähnlicher Weise kommen Signale vom dritten Schalter in die zweite Hälfte des MK und der erste wird ignoriert.  Zu diesem Zeitpunkt weiß die Steuerung, in welchen Positionen der zweite und dritte Schalter installiert sind.  Danach wird PB4 auf „Einheit“ eingestellt, der zweite und dritte Schalter werden ausgeschaltet, und PB5 wird auf „Null“ gesetzt.  In diesem Fall sind der erste und der fehlende vierte Schalter durch ein gemeinsames Ende mit dem „Fall“ verbunden.  Ihre Abfrage erfolgt genauso wie im vorherigen Fall, aber jetzt werden Signale von den Schaltern aufgezeichnet, die beim letzten Mal ignoriert wurden.  Somit kennt die Steuerung die Positionsinformationen aller Schalter.  Dieser Vorgang ähnelt dem Abfragen einer Matrixtastatur, in diesem Fall jedoch einer 4-Schicht-Matrix mit den Abmessungen 2 x 2 und einem fehlenden Element. <br><br>  Widerstände R8 ... R15 - Klimmzüge.  Es war jedoch möglich, im MK selbst "hochzuziehen".  Die genaue Taktfrequenz MK liefert Quarz bei 10 MHz.  R1 und C4 - MK Reset-Schaltung.  Es gibt nichts Interessanteres auf diesem Board. <br><br><img src="https://habrastorage.org/webt/5u/u-/8s/5uu-8sh8ffhwe3qcxqs6gzppcqa.jpeg"><br>  <i>Foto der ersten (Strom-) Platine von der Seite der Elemente.</i> <br><br><img src="https://habrastorage.org/webt/oe/ln/3-/oeln3-vbwunn8pr0ku2gcwloywm.jpeg"><br>  <i>Foto der ersten (Strom-) Platine von hinten.</i> <br><br>  Fahren wir mit dem Schema der ersten Karte fort (Abb. Oben).  Das Schema schien sehr interessant und an einigen Stellen unverständlich. <br><br><img src="https://habrastorage.org/webt/ku/br/ys/kubrysrquhsy3n1xfwmeuvnh8qw.gif"><br>  <i>Schema der ersten (Strom-) Karte.</i> <br><br>  C1C2 - zur Spannungsreduzierung.  R1 - um das oben genannte zu entladen.  Nach der Diodenbrücke DB1 befinden sich zwei Elektrolyte.  Zur Komplikation der Schaltung (oder aus Gründen der Zuverlässigkeit) - Kaskadenstabilisierungsschema VT3R6VD3 - VT7R12VD5.  VD5 ähnelt einem nicht verwendeten Emitter-SMD-Transistor.  Dies liefert eine stabilisierte Gleichspannung von 12V.  Als nächstes kommt der Linearregler VR1 bei 5V.  Gleichzeitig wird die Spannung von der DB1-Diodenbrücke durch die VD2-Diode zu einem anderen 24-V-VT1R3VD1-Stabilisator entfernt.  Diese Spannung wird der Spule des EM-Relais Rel1 und R17 zugeführt.  Letzteres ist nicht klar warum.  Am anderen Ende von R17 kommt das Signal von der Transistorgruppe VT9VT10.  Die Schaltung dieser Gruppe ähnelt der Schaltung auf der Hauptplatine.  Ein Signal von einem separaten MK PB6-Port kommt über den Stecker zum Eingang dieser Transistorgruppe.  Warum wird es benötigt?  Warum einen R17-Widerstand an 24V anschließen?  Höchstwahrscheinlich gab es die Idee, dass Sie anstelle eines Widerstands etwas anderes einsetzen können, beispielsweise eine interne Steuerungs-LED, indem Sie den Port PB6 MK auf eine bestimmte Weise programmieren.  Oder ein zusätzlicher Vermittlungsknoten.  Trotzdem ist das Unsinn, wie meine Bekannten Funkingenieure es ausdrückten und auf die Design-Tafel schauten.  Das zweite Ende des EM-Relais Rel1 ist mit einer ähnlichen Transistorgruppe VT2VT5 verbunden und mit dem MK PD0-Port verbunden.  Das Signal "0" von diesem Port schaltet das ausführende EM-Relais ein.  Das Interessanteste ist, dass die externe LED nicht parallel zum EM-Relais, sondern über zwei Anschlüsse (durch die Hauptplatine) mit der Emitterlücke des VT2-Transistors verbunden ist.  An der Klemme bleiben die Pin-Nummern 1 und 2, gemessen am Aufkleber am Relais, leer.  In der Schaltung ist jedoch Kontakt Nr. 2 mit einem gemeinsamen Draht verbunden, und Kontakt Nr. 1 wird dem Eingang der Transistorgruppe VT6VT8 zugeführt.  Die Ausgabe dieser Gruppe wird an den PD2 MK-Port gesendet.  Später habe ich in der Spezifikation für dieses Relaismodell gelesen, dass diese Kontakte zur Steuerung anderer Relaismodelle verwendet werden, die im selben Fall zusammengebaut wurden.  Das Modell, das ich in Betracht ziehe, beinhaltet keine Steuerung, kann jedoch beim Schreiben eines Programms auf MK implementiert werden, da das Schema diese Möglichkeit bietet.  Unter der Kontrolle kann ein Start, ein Zurücksetzen (sowohl im "Trigger" als auch im normalen Modus) und alles, was mir in den Sinn kommt, bedeuten.  Die Spezifikationen für andere Relais zeigen Zeitdiagramme, die das Verhalten der Relais in Abhängigkeit von einem bestimmten Steuersignal zeigen.  Es heißt auch unten: Auf Wunsch des Kunden können wir jedes mögliche Diagramm implementieren.  Und der letzte Moment im Schema.  Dieses Steuersignal von Klemme Nr. 1 kommt auch zu dem unbrauchbaren VT4-Transistor, der mit einer 12-V-Spannung versorgt wird.  Dies ist wiederum eine Komplikation des Schemas.  Oder ist vielleicht noch eine Idee festgelegt?  Ich habe mich nicht tief vertieft.  Ich freue mich über Kommentare. <br><br>  Die Markierungen der Anschlüsse der Steckverbinder sind durch den Punkt nach dem Namen des Steckverbinders selbst gekennzeichnet.  Römische Ziffern nach dem Symbol „~“ weisen auf nutzlose und fehlende Schlussfolgerungen hin.  Letztere sind nicht wenige im Schema, aber ich werde nicht auf sie eingehen.  Im Folgenden gebe ich Skizzen jeder Platine mit den Bezeichnungen der Anschlüsse, Schlussfolgerungen und Grundelemente. <br><br><img src="https://habrastorage.org/webt/9g/nt/94/9gnt940dbha1c-50htijfyd3erq.gif"><br>  <i>Brettskizzen.</i> <br><br>  Beachten Sie die Beschreibung des Quellcodes für das MK-Programm.  Das Programm selbst ist einfach und wurde von mir 20 Minuten lang in CVAVR geschrieben.  Ich werde den Algorithmus diskutieren, mit dem das Programm ausgeführt wird.  Diese Informationen mögen einigen recht banal erscheinen, sind aber für Anfänger nicht überflüssig.  In meiner Version des Algorithmus werden die Timer des Zeitrelais nicht nur einmal, sondern kontinuierlich abgefragt.  Darüber hinaus wird die Abfrage auch nach Auslösung des Relais fortgesetzt.  Auf diese Weise können Sie unterwegs Anpassungen vornehmen.  Vielleicht stimmt dieser Algorithmus nicht mit dem ursprünglichen Algorithmus für den Betrieb dieses Relais überein, aber ich bin mit dem ursprünglichen Algorithmus nicht vertraut.  Am Beispiel des oben genannten Algorithmus wird die Beschreibung des Programms berücksichtigt. <br><br><div class="spoiler">  <b class="spoiler_title">Quellcode für C-Programm mit Beschreibung.</b> <div class="spoiler_text">  Wir verbinden die Bibliothek für die Arbeit mit dem ATTiny2313 MK sowie die Bibliothek der Verzögerungsfunktionen. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tiny2313.h&gt; #include &lt;delay.h&gt;</span></span></span></span></code> </pre> <br>  Als nächstes führen wir die erforderliche Makrosubstitution gemäß den Schaltungszuweisungen der MK-Ports durch.  Diese Ersetzungen sind praktisch, da Sie im Programmtext anstelle von beispielsweise PORTB.5 getAD schreiben können, was bequemer ist.  Die Kompilierung getAD wird als PORTB interpretiert. 5.  Die erste Ersetzung sind also die Ausgänge zum Anschließen der ersten (A) und vierten (D) Sollwertschalter.  Die zweite ist für die zweite (B) und dritte (C).  Als nächstes folgt die Ersetzung, um das Relais zu aktivieren.  Und schließlich die Substitution „Strg“, die im Programm und im betrachteten Modell nicht verwendet wird.  Du kannst es nicht schreiben. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getAD PORTB.5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getBC PORTB.4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RL PORTD.0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Ctrl PIND.2</span></span></code> </pre><br>  Die Variablen A, B, C werden verwendet, um die Positionsnummer der entsprechenden drei Schalter zu speichern und Werte von 0 bis 9 anzunehmen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A,B,C;</code> </pre><br>  Variable i - der aktuelle Wert der Zahl der Zehntelminuten (6 Sekunden), dh die Zahl des minimalen „Ticks“ des Relais.  Die Variable t ist die Anzahl der vom Master empfangenen Zehntelminuten (Ticks). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>,t;</code> </pre><br>  Die Hauptfunktion des Programms wird unten vorgestellt.  In den ersten 6 Zeilen habe ich nicht verstanden.  Sie werden mit dem Hilfsdienstleister CodeWizadAVR gebildet und sind mit dem Vorhandensein von externem Quarz bei 10 MHz verbunden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize- CLKPR=0x80; CLKPR=0x00; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPTIMIZE_SIZE_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize+ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Die folgenden zwei Zeilen konfigurieren Port B unseres MK.  Gemäß dem Schema setzen wir die unteren 4 Bits an den Eingang und die wichtigsten an den Ausgang (PB7 wird nicht verwendet und PB6 ist nutzlos, aber theoretisch der Ausgang).  Daher schreiben wir gemäß den Prinzipien der MK-Konfiguration, die ich nicht beschreiben werde, die Nummer 240 in das DDRB-Register (F0 in hexadezimaler Notation).  Der anfängliche Ausgangspegel ist "1", mit Ausnahme des unnötigen PB7.  Und für alle Fälle verbinden wir die „Pull-up-Widerstände“ von MK mit den Eingängen, obwohl sie bereits in der Schaltung installiert sind.  Setzen wir dazu das PORTB-Register in hexadezimaler Schreibweise auf 7F. <br><br><pre> <code class="cpp hljs">PORTB=<span class="hljs-number"><span class="hljs-number">0x7F</span></span>; DDRB=<span class="hljs-number"><span class="hljs-number">0xF0</span></span>;</code> </pre><br>  Port D wird auf die gleiche Weise konfiguriert: Alle Pins am Eingang mit Ausnahme der beiden unteren.  Die „Pull-up-Widerstände“ am Eingang und der anfängliche Ausgangspegel „1“ am Ausgang sind ähnlich. <br><br><pre> <code class="cpp hljs">PORTD=<span class="hljs-number"><span class="hljs-number">0x7D</span></span>; DDRD=<span class="hljs-number"><span class="hljs-number">0x03</span></span>;</code> </pre><br>  Die folgenden fünf Zeilen beziehen sich auf die Konfiguration eines der MK-Timer.  Dieser Timer ist sechzehnstellig, dh er liefert eine Punktzahl von bis zu 2 ^ 16 = 65536.  Die Zählfrequenz wird durch die MK-Taktfrequenz und den Teilungskoeffizienten (einer von fünf vordefinierten) bestimmt.  In dem beschriebenen Programm wurde beschlossen, ein Konto für 6 Sekunden zu führen (der minimale Aufgabenschritt), dann die Variable i um 1 zu erhöhen und den Timer auf den Beginn der Zählung zurückzusetzen.  Um dies zu gewährleisten, müssen Sie das maximale Teilungsverhältnis von 1024 nehmen und bis 58594 zählen. Letzteres ist einfach zu berechnen.  MK-Frequenz - 10.000.000 Hz.  Bei einem Teilungsverhältnis von 1024 beträgt die Zeitgeberfrequenz 10.000.000 / 1.024 = 9.765,625 Hz und die Periode 1.024.000 / 10.000.000 = 0.0001024 s.  Innerhalb von 6 Sekunden werden 6 / 0,0001024 = 58593,75 solcher Perioden gestapelt.  Diese Zahl liegt im 16-Bit-Timer, ist jedoch keine Ganzzahl. Sie müssen also auf 58594 runden. In diesem Fall ist der Fehler unseres Zeitrelais unbedeutend: 58594-58593.75 = 0.25;  0,25 * 0,0001024 = 0,0000256;  0,0000256 * 999 = 0,0255744.  Das heißt, für den maximal möglichen Zeitraum (99,9 Minuten) beträgt die Ungenauigkeit dieses Zeitrelais ungefähr 25,6 Millisekunden, was in der Praxis durchaus akzeptabel ist.  Übrigens schreibt der Hersteller auch den Fehler des Geräts vor, und unser Fehler wird nicht schlimmer sein.  Schreiben Sie in das TCCR1B-Timer-Konfigurationsregister den Wert 5. Ohne ins Detail zu gehen, bedeutet dies, dass der Timer startet und der Teilungskoeffizient 1024 beträgt. Im TCNT1-Register schreiben wir den Wert 0. Dieses Register ist 16-Bit und in zwei 8-Bit-Hälften unterteilt: die jüngste (L. ) und Senior (H).  Der Wert wird darauf geschrieben, von wo aus der Timer weiter zählt.  Wir müssen von Grund auf neu zählen.  Der Wert OCR1A registriert, vor dem der Timer liest und danach die Interrupt-Funktion aufruft.  In diesem Moment wird die Hauptfunktion des Programms unterbrochen und die in der Funktion dieses Interrupts angegebenen Aktionen werden ausgeführt.  Nach dem Üben des Interrupts wird die Hauptfunktion weiterhin ausgeführt.  Dieser Wert ist, wie oben gesagt, gleich 58594 (E4E2 in hexadezimaler Notation).  Da das OCR1A-Register ebenfalls in zwei Hälften geteilt ist, schreiben wir den obigen Wert in Teilen. <br><br><pre> <code class="cpp hljs">TCCR1B=<span class="hljs-number"><span class="hljs-number">0x05</span></span>; TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; OCR1AH=<span class="hljs-number"><span class="hljs-number">0xE4</span></span>; OCR1AL=<span class="hljs-number"><span class="hljs-number">0xE2</span></span>;</code> </pre><br>  In den nächsten beiden Zeilen wird die Auflösung von Interrupts ordnungsgemäß konfiguriert (gehen Sie nicht auf Details ein). <br><br><pre> <code class="cpp hljs">TIMSK=<span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-meta"><span class="hljs-meta">#asm(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sei"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br>  Im Hauptzyklus werden die Setzschalter ständig (gemäß dem Algorithmus in der Schaltungsbeschreibung) mit 30 ms Verzögerung für einen korrekten und stabilen Betrieb abgefragt.  Durch Setzen des Wertes "0" auf PORTB.5 (getAD = 0) bereiten wir den ersten Schalter vor.  Seine Schlussfolgerungen sind mit Port D des MK an den Pins 6, 5, 4, 3 verbunden. Die Richtung ist vom jüngsten zum ältesten.  Das heißt, das niederwertige Bit des Schalters ist mit dem relativ niederwertigen Bit (Bit 3) von Port MK verbunden.  Um Informationen von Port D des MK über die Position des ersten Schalters zu empfangen, ist es daher erforderlich, eine bitweise Verschiebung nach rechts um drei Positionen (PIND &gt;&gt; 3) vorzunehmen und die empfangenen Bits mit der Operation "~" zu invertieren (da die Informationen gemäß dem Schema in "0" eingehen). und die unnötig hohen vier Bits des empfangenen 8-Bit-Werts zurücksetzen.  Die letzte Operation erfolgt durch logische bitweise Multiplikation des Ergebnisses mit der Zahl 15 (00001111 in binärer Darstellung).  Nach dieser Operation wird der Variablen A der Positionswert des ersten Schalters zugewiesen.  Als nächstes wird der erste Schalter ausgeschaltet und der zweite und dritte werden vorbereitet.  Der Wert vom zweiten Schalter zur Variablen B wird in ähnlicher Weise von Port B des MK übernommen, jedoch ohne Schaltvorgang, da die Anschlüsse dieses Schalters mit den untersten Pins von Port B des MK und auch in Gleichrichtung verbunden sind.  Informationen vom dritten Schalter zur Variablen C werden auf die gleiche Weise wie vom ersten entfernt.  Danach werden der zweite und dritte Schalter (getBC = 1) "geschlossen" und der eingestellte Wert (die Anzahl der Zehntelminuten) aus den drei Schaltern wird in der Variablen t berechnet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>){ delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); A=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">1</span></span>; getBC=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); B=(~PINB)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>; C=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getBC=<span class="hljs-number"><span class="hljs-number">1</span></span>; t=<span class="hljs-number"><span class="hljs-number">100</span></span>*A+<span class="hljs-number"><span class="hljs-number">10</span></span>*B+C; } }</code> </pre><br>  Ein Vergleich dieser Variablen mit einer ähnlichen Echtzeitvariablen i erfolgt in der Interruptfunktion. <br><br><pre> <code class="cpp hljs">interrupt [TIM1_COMPA] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer1_compa_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ i+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&gt;=t){ RL=<span class="hljs-number"><span class="hljs-number">0</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ RL=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; }</code> </pre><br>  Wenn die letzte Variable den eingestellten Wert überschreitet, wird das „Ausführungsrelais“ (RL = 0) mit „0“ eingeschaltet.  Darüber hinaus wird es ausgeschaltet, wenn gleichzeitig die Schalter auf einen Wert eingestellt werden, der größer ist als der Wert, der in der Variablen i ausgeführt wurde.  In derselben Interrupt-Funktion wird die Variable i um 1 erhöht und der Timer auf 0 zurückgesetzt. <br><br>  FUSE-Bits wurden von MK abgeschrieben und unverändert gelassen.  Ich habe sie analysiert, dort ist alles in Ordnung. <br><br><img src="https://habrastorage.org/webt/zv/dt/ll/zvdtllilqlufxumtsv98xelmwnc.png"><br><br><br></div></div><br>  So wurde nicht nur das Gerätediagramm kopiert, sondern auch ein MK-Programm entwickelt, das sich in seiner Funktionalität nicht von dem proprietären unterscheidet.  Darüber hinaus wurde es auf Softwareebene möglich, die Zeitparameter des Geräts recht flexibel (und vor allem kostenlos) zu ändern und den Steuerausgang (Nr. 1 am Terminal) in verschiedenen Funktionen zu verwenden.  Das Programm ist so einfach, dass es (noch besser) in Assembler geschrieben werden kann, aber ich mache es noch nicht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414345/">https://habr.com/ru/post/de414345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414335/index.html">Hintergrund. Roskomnadzor, was bist du?</a></li>
<li><a href="../de414337/index.html">Ramda Style Thinking: Unveränderlichkeit und Objekte</a></li>
<li><a href="../de414339/index.html">Tolle Fototour durch die neue Seite von Moskau Coworking #tceh</a></li>
<li><a href="../de414341/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 256 (vom 3. bis 12. Juni)</a></li>
<li><a href="../de414343/index.html">Google Neural Machine Translation</a></li>
<li><a href="../de414347/index.html">Passive Aggression: Wie sie unser Arbeitsleben zerstört und wie man damit umgeht</a></li>
<li><a href="../de414349/index.html">Erhalten Sie MCC-Kostenstatistiken: Tinkoff und Rocketbank</a></li>
<li><a href="../de414351/index.html">Die ungewöhnlichsten Musikinstrumente: Hammond-Orgel, Vako-Orchester und Synclavier</a></li>
<li><a href="../de414353/index.html">Kivy. Von der Kreation bis zur Produktion ist ein Schritt. Teil 2</a></li>
<li><a href="../de414355/index.html">Leben nach der Explosion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>