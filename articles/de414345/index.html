<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∂üèæ üîú üà≤ R√ºckentwicklung des Zeitschalters VL-76-S üöá ‚óªÔ∏è üßòüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es war einmal eine Zeit, in der ich auf die elektronische digitale Zeitschaltuhr VL-76-S stie√ü, die neu in der Verpackung, aber in einem fehlerhaften ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>R√ºckentwicklung des Zeitschalters VL-76-S</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414345/">  Es war einmal eine Zeit, in der ich auf die elektronische digitale Zeitschaltuhr VL-76-S stie√ü, die neu in der Verpackung, aber in einem fehlerhaften Zustand war.  Auf den Leiterplatten im Inneren wurden keine M√§ngel festgestellt.  Daher Fabrikheirat, kaputte Firmware. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cn/vj/2v/cnvj2vs2aonwmvjljydwos0ewqi.jpeg"></div><br>  <i>Gesamtansicht des Relais.</i> <br><a name="habracut"></a><br>  Was uns √ºberraschte, war die Verwendung des beliebten und einfachen Mikrocontrollers ATTiny2313.  √Ñu√üerlich besteht diese Konstruktion aus einem Master in Form von drei Jahrzehnten langen Schaltern und einem Anschluss, an den 220-V-Strom und Kontakte eines EM-Relais angeschlossen sind.  Der Bereich der Aufgabe betr√§gt 0,1 ... 99,9 Minuten.  in Schritten von 0,1 min  (6 Sekunden).  Es gibt keine Schaltkreise und Firmware zu diesem Design im Internet, was nicht √ºberraschend ist.  Ohne nachzudenken, beschloss ich, die Schaltung von den Leiterplatten zu ziehen und das Programm in Zukunft selbst auf den MK zu schreiben. <br><br>  Das Design besteht aus drei miteinander verbundenen Leiterplatten.  Auf der ersten Platine befinden sich ein Netzteil und ein TRA3-Ausf√ºhrungsrelais.  Die Stromversorgung erfolgt nach einer transformatorlosen Schaltung: L√∂schkondensatoren werden zur Spannungsreduzierung eingesetzt.  Auf der zweiten Platine befindet sich der ATTiny2313 MK und andere Hilfselemente.  Auf der dritten Karte befinden sich Schalter (Sollwerte) und eine Steuer-LED. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/be/ew/4h/beew4hzen1salm0a6x7mlwhak2g.jpeg"></div><br>  <i>Foto der dritten Tafel von hinten.</i> <br><br>  Ich werde die Beschreibung mit der dritten Tafel beginnen.  Die Schalter sind Schalter mit 10 Positionen.  Es gibt keine Markierung auf ihnen, jeder von ihnen hat 5 Kontakte.  Daher werden je nach Position bestimmte Kontakte in verschiedenen Kombinationen geschlossen.  Beim Aufrufen von Kontakten habe ich sofort das Muster erkannt: Ein fester Ausgang (allgemein) wird mit den anderen vier Ausg√§ngen (Informationen) entsprechend der bin√§ren Darstellung der Nummer geschlossen, die der Nummer der ausgew√§hlten Position entspricht.  Wenn beispielsweise die Position "3" ausgew√§hlt ist, schlie√üt die allgemeine Ausgabe (f√ºnfte in Folge) mit der Ausgabe der dritten und vierten, da die Zahl "3" in der Bin√§rdarstellung "0011" ist.  Hier ist so ein kniffliger Schalter.  Und es gibt drei von ihnen.  Sie werden √ºber XP1- und XP2-Anschl√ºsse mit MK an die zweite Karte angeschlossen.  Ein XP3-Anschluss verbindet eine LED und einen anderen unn√∂tigen, nicht gel√∂teten Mist, f√ºr den sich ein Platz auf der Platine befindet.  H√∂chstwahrscheinlich handelt es sich hierbei um einen herk√∂mmlichen sechspoligen DPDT-Schalter (z. B. einen quadratischen, z. B. PB22E06).  Vielleicht ist das Board universell, aber es wird in diesem speziellen Modell nicht verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/tv/rq/lotvrq9ovoeetew2zmaa6sauury.jpeg"></div><br>  <i>Foto der zweiten (Haupt-) Tafel.</i> <br><br>  Als ich die Kontakte der Switches anrief, verstand ich das Prinzip ihrer Verbindung zu den MK-Ports nicht sofort.  Auf der Hauptplatine sind sofort 8 SMD-Transistoren erkennbar.  Er fand sp√§ter heraus, dass diese Transistoren als Diodenpaare mit einer gemeinsamen Anode verwendet werden.  Ihre Basen gehen zu MK-Ports, und Kollektoren und Emitter gehen zu Schaltkontakten.  Dann erkl√§rten sie mir, dass es in solchen F√§llen Diodenpaare gibt, die wie Transistoren klingeln, aber keine Transistoren sind.  Insgesamt haben wir 16 Leiter, die die Diodenpaare auf der dritten Platine belassen.  Drei Viertel von ihnen (12 St√ºck) kommen zu den Informationskontakten der Schalter (drei bis vier), und vier bleiben frei.  Es ist leicht zu erraten, dass sie theoretisch f√ºr den vierten Schalter vorgesehen sind, der irgendwie nicht fehlt, da auf der Platine √ºberhaupt kein Platz daf√ºr vorhanden ist.  Um die Logik des Denkens nicht zu verletzen, werde ich diesen imagin√§ren vierten Schalter erw√§hnen.  Die gemeinsamen Enden des zweiten und dritten Schalters sowie des ersten und vierten Schalters (der vierte sieht jedoch nicht die Platine vor) sind paarweise durch Schienen in der Hauptplatine an den Gegensteckern XS1 und XS2 miteinander verbunden.  Diese beiden Paare sind mit den Ausg√§ngen von Transistorgruppen verbunden.  Diese beiden identischen Gruppen werden auf den Transistoren BC857 und BC847 (unterschiedliche Strukturen) hergestellt.  Ihre Eing√§nge sind mit dem MK verbunden.  Wenn Sie eine logische "0" auf die Eingabe dieser Gruppe anwenden, ist die Ausgabe auch eine logische "0".  Auf der Karte befinden sich au√üerdem ein XP2-Anschluss f√ºr die MK-Firmware, der an die SPI-Anschl√ºsse der MK-Schnittstelle angeschlossen ist, ein XS3-Anschluss f√ºr eine LED und ein XP1-Anschluss, der √ºber ein Kabel mit der ersten Karte verbunden ist.  Es sollte beachtet werden, dass einige der MK-Ports sowohl f√ºr SPI (f√ºr Firmware) als auch f√ºr gew√∂hnliche Eingabe-Ausgabe (Arbeit in der Schaltung) verwendet werden k√∂nnen. <br><br>  All das spiegelt sich in den Diagrammen wider, die ich zuerst im Entwurf, dann in SPlan gezeichnet habe.  Die Bewertungen von Funkelementen, die nicht markiert wurden (z. B. SMD-Kondensatoren), fehlen in den Diagrammen, sie sind nicht so wichtig.  Zuerst werde ich ein Diagramm der Hauptplatine und der Platine mit den Setzern geben (Signaturen der Bilder unten). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/r8/gr/4cr8gr6u5edycy869h9wuyprgs0.gif"></div><br>  <i>Schema der Hauptplatine.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pg/sx/uy/pgsxuy7cgafwqwabsx39prgwkgw.gif"></div><br><br>  <i>Schema der dritten Tafel mit Setzern</i> <br><br>  √úberlegen Sie, wie die Abfrage jedes Setzers.  Die Signale von den Anschl√ºssen PB4 und PB5 MK logisch "0" √∂ffnen die Transistoren VT2 und VT1, gefolgt von VT4 und VT3, und verbinden sich mit den gemeinsamen Nullbuskontakten der Schalter Nr. 1 bzw. Nr. 2-Nr. 3.  Dies geschieht wiederum.  Erstens kommt die logische ‚Äû0‚Äú von PB4 (PB5 wurde bisher auf die logische ‚Äû1‚Äú gesetzt) ‚Äã‚Äãund verbindet den zweiten und dritten Schalter.  In diesem Zustand werden die Werte der Signale wiederum von der Steuerung von den Eingangsports PB3, PB2, PB1, PB0 √ºber die Diodengruppen 2VD1 ... 2VD4 von den zweiten und fehlenden vierten Schaltern aufgezeichnet.  Sofort sind die Werte der Signale von den Pins PD6, PD5, PD4, PD3 MK festgelegt, auf die die Signale vom ersten und dritten Schalter √ºber die Diodengruppen 2VD5 ... 2VD8 kommen.  Da jedoch nur der zweite und der dritte Schalter durch einen gemeinsamen Kontakt verbunden sind, kommen die Signale vom zweiten Schalter zu den ersten angegebenen Ports des MK und der vierte wird ignoriert.  In √§hnlicher Weise kommen Signale vom dritten Schalter in die zweite H√§lfte des MK und der erste wird ignoriert.  Zu diesem Zeitpunkt wei√ü die Steuerung, in welchen Positionen der zweite und dritte Schalter installiert sind.  Danach wird PB4 auf ‚ÄûEinheit‚Äú eingestellt, der zweite und dritte Schalter werden ausgeschaltet, und PB5 wird auf ‚ÄûNull‚Äú gesetzt.  In diesem Fall sind der erste und der fehlende vierte Schalter durch ein gemeinsames Ende mit dem ‚ÄûFall‚Äú verbunden.  Ihre Abfrage erfolgt genauso wie im vorherigen Fall, aber jetzt werden Signale von den Schaltern aufgezeichnet, die beim letzten Mal ignoriert wurden.  Somit kennt die Steuerung die Positionsinformationen aller Schalter.  Dieser Vorgang √§hnelt dem Abfragen einer Matrixtastatur, in diesem Fall jedoch einer 4-Schicht-Matrix mit den Abmessungen 2 x 2 und einem fehlenden Element. <br><br>  Widerst√§nde R8 ... R15 - Klimmz√ºge.  Es war jedoch m√∂glich, im MK selbst "hochzuziehen".  Die genaue Taktfrequenz MK liefert Quarz bei 10 MHz.  R1 und C4 - MK Reset-Schaltung.  Es gibt nichts Interessanteres auf diesem Board. <br><br><img src="https://habrastorage.org/webt/5u/u-/8s/5uu-8sh8ffhwe3qcxqs6gzppcqa.jpeg"><br>  <i>Foto der ersten (Strom-) Platine von der Seite der Elemente.</i> <br><br><img src="https://habrastorage.org/webt/oe/ln/3-/oeln3-vbwunn8pr0ku2gcwloywm.jpeg"><br>  <i>Foto der ersten (Strom-) Platine von hinten.</i> <br><br>  Fahren wir mit dem Schema der ersten Karte fort (Abb. Oben).  Das Schema schien sehr interessant und an einigen Stellen unverst√§ndlich. <br><br><img src="https://habrastorage.org/webt/ku/br/ys/kubrysrquhsy3n1xfwmeuvnh8qw.gif"><br>  <i>Schema der ersten (Strom-) Karte.</i> <br><br>  C1C2 - zur Spannungsreduzierung.  R1 - um das oben genannte zu entladen.  Nach der Diodenbr√ºcke DB1 befinden sich zwei Elektrolyte.  Zur Komplikation der Schaltung (oder aus Gr√ºnden der Zuverl√§ssigkeit) - Kaskadenstabilisierungsschema VT3R6VD3 - VT7R12VD5.  VD5 √§hnelt einem nicht verwendeten Emitter-SMD-Transistor.  Dies liefert eine stabilisierte Gleichspannung von 12V.  Als n√§chstes kommt der Linearregler VR1 bei 5V.  Gleichzeitig wird die Spannung von der DB1-Diodenbr√ºcke durch die VD2-Diode zu einem anderen 24-V-VT1R3VD1-Stabilisator entfernt.  Diese Spannung wird der Spule des EM-Relais Rel1 und R17 zugef√ºhrt.  Letzteres ist nicht klar warum.  Am anderen Ende von R17 kommt das Signal von der Transistorgruppe VT9VT10.  Die Schaltung dieser Gruppe √§hnelt der Schaltung auf der Hauptplatine.  Ein Signal von einem separaten MK PB6-Port kommt √ºber den Stecker zum Eingang dieser Transistorgruppe.  Warum wird es ben√∂tigt?  Warum einen R17-Widerstand an 24V anschlie√üen?  H√∂chstwahrscheinlich gab es die Idee, dass Sie anstelle eines Widerstands etwas anderes einsetzen k√∂nnen, beispielsweise eine interne Steuerungs-LED, indem Sie den Port PB6 MK auf eine bestimmte Weise programmieren.  Oder ein zus√§tzlicher Vermittlungsknoten.  Trotzdem ist das Unsinn, wie meine Bekannten Funkingenieure es ausdr√ºckten und auf die Design-Tafel schauten.  Das zweite Ende des EM-Relais Rel1 ist mit einer √§hnlichen Transistorgruppe VT2VT5 verbunden und mit dem MK PD0-Port verbunden.  Das Signal "0" von diesem Port schaltet das ausf√ºhrende EM-Relais ein.  Das Interessanteste ist, dass die externe LED nicht parallel zum EM-Relais, sondern √ºber zwei Anschl√ºsse (durch die Hauptplatine) mit der Emitterl√ºcke des VT2-Transistors verbunden ist.  An der Klemme bleiben die Pin-Nummern 1 und 2, gemessen am Aufkleber am Relais, leer.  In der Schaltung ist jedoch Kontakt Nr. 2 mit einem gemeinsamen Draht verbunden, und Kontakt Nr. 1 wird dem Eingang der Transistorgruppe VT6VT8 zugef√ºhrt.  Die Ausgabe dieser Gruppe wird an den PD2 MK-Port gesendet.  Sp√§ter habe ich in der Spezifikation f√ºr dieses Relaismodell gelesen, dass diese Kontakte zur Steuerung anderer Relaismodelle verwendet werden, die im selben Fall zusammengebaut wurden.  Das Modell, das ich in Betracht ziehe, beinhaltet keine Steuerung, kann jedoch beim Schreiben eines Programms auf MK implementiert werden, da das Schema diese M√∂glichkeit bietet.  Unter der Kontrolle kann ein Start, ein Zur√ºcksetzen (sowohl im "Trigger" als auch im normalen Modus) und alles, was mir in den Sinn kommt, bedeuten.  Die Spezifikationen f√ºr andere Relais zeigen Zeitdiagramme, die das Verhalten der Relais in Abh√§ngigkeit von einem bestimmten Steuersignal zeigen.  Es hei√üt auch unten: Auf Wunsch des Kunden k√∂nnen wir jedes m√∂gliche Diagramm implementieren.  Und der letzte Moment im Schema.  Dieses Steuersignal von Klemme Nr. 1 kommt auch zu dem unbrauchbaren VT4-Transistor, der mit einer 12-V-Spannung versorgt wird.  Dies ist wiederum eine Komplikation des Schemas.  Oder ist vielleicht noch eine Idee festgelegt?  Ich habe mich nicht tief vertieft.  Ich freue mich √ºber Kommentare. <br><br>  Die Markierungen der Anschl√ºsse der Steckverbinder sind durch den Punkt nach dem Namen des Steckverbinders selbst gekennzeichnet.  R√∂mische Ziffern nach dem Symbol ‚Äû~‚Äú weisen auf nutzlose und fehlende Schlussfolgerungen hin.  Letztere sind nicht wenige im Schema, aber ich werde nicht auf sie eingehen.  Im Folgenden gebe ich Skizzen jeder Platine mit den Bezeichnungen der Anschl√ºsse, Schlussfolgerungen und Grundelemente. <br><br><img src="https://habrastorage.org/webt/9g/nt/94/9gnt940dbha1c-50htijfyd3erq.gif"><br>  <i>Brettskizzen.</i> <br><br>  Beachten Sie die Beschreibung des Quellcodes f√ºr das MK-Programm.  Das Programm selbst ist einfach und wurde von mir 20 Minuten lang in CVAVR geschrieben.  Ich werde den Algorithmus diskutieren, mit dem das Programm ausgef√ºhrt wird.  Diese Informationen m√∂gen einigen recht banal erscheinen, sind aber f√ºr Anf√§nger nicht √ºberfl√ºssig.  In meiner Version des Algorithmus werden die Timer des Zeitrelais nicht nur einmal, sondern kontinuierlich abgefragt.  Dar√ºber hinaus wird die Abfrage auch nach Ausl√∂sung des Relais fortgesetzt.  Auf diese Weise k√∂nnen Sie unterwegs Anpassungen vornehmen.  Vielleicht stimmt dieser Algorithmus nicht mit dem urspr√ºnglichen Algorithmus f√ºr den Betrieb dieses Relais √ºberein, aber ich bin mit dem urspr√ºnglichen Algorithmus nicht vertraut.  Am Beispiel des oben genannten Algorithmus wird die Beschreibung des Programms ber√ºcksichtigt. <br><br><div class="spoiler">  <b class="spoiler_title">Quellcode f√ºr C-Programm mit Beschreibung.</b> <div class="spoiler_text">  Wir verbinden die Bibliothek f√ºr die Arbeit mit dem ATTiny2313 MK sowie die Bibliothek der Verz√∂gerungsfunktionen. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tiny2313.h&gt; #include &lt;delay.h&gt;</span></span></span></span></code> </pre> <br>  Als n√§chstes f√ºhren wir die erforderliche Makrosubstitution gem√§√ü den Schaltungszuweisungen der MK-Ports durch.  Diese Ersetzungen sind praktisch, da Sie im Programmtext anstelle von beispielsweise PORTB.5 getAD schreiben k√∂nnen, was bequemer ist.  Die Kompilierung getAD wird als PORTB interpretiert. 5.  Die erste Ersetzung sind also die Ausg√§nge zum Anschlie√üen der ersten (A) und vierten (D) Sollwertschalter.  Die zweite ist f√ºr die zweite (B) und dritte (C).  Als n√§chstes folgt die Ersetzung, um das Relais zu aktivieren.  Und schlie√ülich die Substitution ‚ÄûStrg‚Äú, die im Programm und im betrachteten Modell nicht verwendet wird.  Du kannst es nicht schreiben. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getAD PORTB.5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> getBC PORTB.4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RL PORTD.0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Ctrl PIND.2</span></span></code> </pre><br>  Die Variablen A, B, C werden verwendet, um die Positionsnummer der entsprechenden drei Schalter zu speichern und Werte von 0 bis 9 anzunehmen. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> A,B,C;</code> </pre><br>  Variable i - der aktuelle Wert der Zahl der Zehntelminuten (6 Sekunden), dh die Zahl des minimalen ‚ÄûTicks‚Äú des Relais.  Die Variable t ist die Anzahl der vom Master empfangenen Zehntelminuten (Ticks). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>,t;</code> </pre><br>  Die Hauptfunktion des Programms wird unten vorgestellt.  In den ersten 6 Zeilen habe ich nicht verstanden.  Sie werden mit dem Hilfsdienstleister CodeWizadAVR gebildet und sind mit dem Vorhandensein von externem Quarz bei 10 MHz verbunden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize- CLKPR=0x80; CLKPR=0x00; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _OPTIMIZE_SIZE_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> optsize+ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  Die folgenden zwei Zeilen konfigurieren Port B unseres MK.  Gem√§√ü dem Schema setzen wir die unteren 4 Bits an den Eingang und die wichtigsten an den Ausgang (PB7 wird nicht verwendet und PB6 ist nutzlos, aber theoretisch der Ausgang).  Daher schreiben wir gem√§√ü den Prinzipien der MK-Konfiguration, die ich nicht beschreiben werde, die Nummer 240 in das DDRB-Register (F0 in hexadezimaler Notation).  Der anf√§ngliche Ausgangspegel ist "1", mit Ausnahme des unn√∂tigen PB7.  Und f√ºr alle F√§lle verbinden wir die ‚ÄûPull-up-Widerst√§nde‚Äú von MK mit den Eing√§ngen, obwohl sie bereits in der Schaltung installiert sind.  Setzen wir dazu das PORTB-Register in hexadezimaler Schreibweise auf 7F. <br><br><pre> <code class="cpp hljs">PORTB=<span class="hljs-number"><span class="hljs-number">0x7F</span></span>; DDRB=<span class="hljs-number"><span class="hljs-number">0xF0</span></span>;</code> </pre><br>  Port D wird auf die gleiche Weise konfiguriert: Alle Pins am Eingang mit Ausnahme der beiden unteren.  Die ‚ÄûPull-up-Widerst√§nde‚Äú am Eingang und der anf√§ngliche Ausgangspegel ‚Äû1‚Äú am Ausgang sind √§hnlich. <br><br><pre> <code class="cpp hljs">PORTD=<span class="hljs-number"><span class="hljs-number">0x7D</span></span>; DDRD=<span class="hljs-number"><span class="hljs-number">0x03</span></span>;</code> </pre><br>  Die folgenden f√ºnf Zeilen beziehen sich auf die Konfiguration eines der MK-Timer.  Dieser Timer ist sechzehnstellig, dh er liefert eine Punktzahl von bis zu 2 ^ 16 = 65536.  Die Z√§hlfrequenz wird durch die MK-Taktfrequenz und den Teilungskoeffizienten (einer von f√ºnf vordefinierten) bestimmt.  In dem beschriebenen Programm wurde beschlossen, ein Konto f√ºr 6 Sekunden zu f√ºhren (der minimale Aufgabenschritt), dann die Variable i um 1 zu erh√∂hen und den Timer auf den Beginn der Z√§hlung zur√ºckzusetzen.  Um dies zu gew√§hrleisten, m√ºssen Sie das maximale Teilungsverh√§ltnis von 1024 nehmen und bis 58594 z√§hlen. Letzteres ist einfach zu berechnen.  MK-Frequenz - 10.000.000 Hz.  Bei einem Teilungsverh√§ltnis von 1024 betr√§gt die Zeitgeberfrequenz 10.000.000 / 1.024 = 9.765,625 Hz und die Periode 1.024.000 / 10.000.000 = 0.0001024 s.  Innerhalb von 6 Sekunden werden 6 / 0,0001024 = 58593,75 solcher Perioden gestapelt.  Diese Zahl liegt im 16-Bit-Timer, ist jedoch keine Ganzzahl. Sie m√ºssen also auf 58594 runden. In diesem Fall ist der Fehler unseres Zeitrelais unbedeutend: 58594-58593.75 = 0.25;  0,25 * 0,0001024 = 0,0000256;  0,0000256 * 999 = 0,0255744.  Das hei√üt, f√ºr den maximal m√∂glichen Zeitraum (99,9 Minuten) betr√§gt die Ungenauigkeit dieses Zeitrelais ungef√§hr 25,6 Millisekunden, was in der Praxis durchaus akzeptabel ist.  √úbrigens schreibt der Hersteller auch den Fehler des Ger√§ts vor, und unser Fehler wird nicht schlimmer sein.  Schreiben Sie in das TCCR1B-Timer-Konfigurationsregister den Wert 5. Ohne ins Detail zu gehen, bedeutet dies, dass der Timer startet und der Teilungskoeffizient 1024 betr√§gt. Im TCNT1-Register schreiben wir den Wert 0. Dieses Register ist 16-Bit und in zwei 8-Bit-H√§lften unterteilt: die j√ºngste (L. ) und Senior (H).  Der Wert wird darauf geschrieben, von wo aus der Timer weiter z√§hlt.  Wir m√ºssen von Grund auf neu z√§hlen.  Der Wert OCR1A registriert, vor dem der Timer liest und danach die Interrupt-Funktion aufruft.  In diesem Moment wird die Hauptfunktion des Programms unterbrochen und die in der Funktion dieses Interrupts angegebenen Aktionen werden ausgef√ºhrt.  Nach dem √úben des Interrupts wird die Hauptfunktion weiterhin ausgef√ºhrt.  Dieser Wert ist, wie oben gesagt, gleich 58594 (E4E2 in hexadezimaler Notation).  Da das OCR1A-Register ebenfalls in zwei H√§lften geteilt ist, schreiben wir den obigen Wert in Teilen. <br><br><pre> <code class="cpp hljs">TCCR1B=<span class="hljs-number"><span class="hljs-number">0x05</span></span>; TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; OCR1AH=<span class="hljs-number"><span class="hljs-number">0xE4</span></span>; OCR1AL=<span class="hljs-number"><span class="hljs-number">0xE2</span></span>;</code> </pre><br>  In den n√§chsten beiden Zeilen wird die Aufl√∂sung von Interrupts ordnungsgem√§√ü konfiguriert (gehen Sie nicht auf Details ein). <br><br><pre> <code class="cpp hljs">TIMSK=<span class="hljs-number"><span class="hljs-number">0x40</span></span>; <span class="hljs-meta"><span class="hljs-meta">#asm(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sei"</span></span></span><span class="hljs-meta">)</span></span></code> </pre><br>  Im Hauptzyklus werden die Setzschalter st√§ndig (gem√§√ü dem Algorithmus in der Schaltungsbeschreibung) mit 30 ms Verz√∂gerung f√ºr einen korrekten und stabilen Betrieb abgefragt.  Durch Setzen des Wertes "0" auf PORTB.5 (getAD = 0) bereiten wir den ersten Schalter vor.  Seine Schlussfolgerungen sind mit Port D des MK an den Pins 6, 5, 4, 3 verbunden. Die Richtung ist vom j√ºngsten zum √§ltesten.  Das hei√üt, das niederwertige Bit des Schalters ist mit dem relativ niederwertigen Bit (Bit 3) von Port MK verbunden.  Um Informationen von Port D des MK √ºber die Position des ersten Schalters zu empfangen, ist es daher erforderlich, eine bitweise Verschiebung nach rechts um drei Positionen (PIND &gt;&gt; 3) vorzunehmen und die empfangenen Bits mit der Operation "~" zu invertieren (da die Informationen gem√§√ü dem Schema in "0" eingehen). und die unn√∂tig hohen vier Bits des empfangenen 8-Bit-Werts zur√ºcksetzen.  Die letzte Operation erfolgt durch logische bitweise Multiplikation des Ergebnisses mit der Zahl 15 (00001111 in bin√§rer Darstellung).  Nach dieser Operation wird der Variablen A der Positionswert des ersten Schalters zugewiesen.  Als n√§chstes wird der erste Schalter ausgeschaltet und der zweite und dritte werden vorbereitet.  Der Wert vom zweiten Schalter zur Variablen B wird in √§hnlicher Weise von Port B des MK √ºbernommen, jedoch ohne Schaltvorgang, da die Anschl√ºsse dieses Schalters mit den untersten Pins von Port B des MK und auch in Gleichrichtung verbunden sind.  Informationen vom dritten Schalter zur Variablen C werden auf die gleiche Weise wie vom ersten entfernt.  Danach werden der zweite und dritte Schalter (getBC = 1) "geschlossen" und der eingestellte Wert (die Anzahl der Zehntelminuten) aus den drei Schaltern wird in der Variablen t berechnet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>){ delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); A=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getAD=<span class="hljs-number"><span class="hljs-number">1</span></span>; getBC=<span class="hljs-number"><span class="hljs-number">0</span></span>; delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); B=(~PINB)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>; C=(~(PIND&gt;&gt;<span class="hljs-number"><span class="hljs-number">3</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">15</span></span>); delay_ms(<span class="hljs-number"><span class="hljs-number">30</span></span>); getBC=<span class="hljs-number"><span class="hljs-number">1</span></span>; t=<span class="hljs-number"><span class="hljs-number">100</span></span>*A+<span class="hljs-number"><span class="hljs-number">10</span></span>*B+C; } }</code> </pre><br>  Ein Vergleich dieser Variablen mit einer √§hnlichen Echtzeitvariablen i erfolgt in der Interruptfunktion. <br><br><pre> <code class="cpp hljs">interrupt [TIM1_COMPA] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer1_compa_isr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ i+=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i&gt;=t){ RL=<span class="hljs-number"><span class="hljs-number">0</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ RL=<span class="hljs-number"><span class="hljs-number">1</span></span>; } TCNT1H=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; TCNT1L=<span class="hljs-number"><span class="hljs-number">0x00</span></span>; }</code> </pre><br>  Wenn die letzte Variable den eingestellten Wert √ºberschreitet, wird das ‚ÄûAusf√ºhrungsrelais‚Äú (RL = 0) mit ‚Äû0‚Äú eingeschaltet.  Dar√ºber hinaus wird es ausgeschaltet, wenn gleichzeitig die Schalter auf einen Wert eingestellt werden, der gr√∂√üer ist als der Wert, der in der Variablen i ausgef√ºhrt wurde.  In derselben Interrupt-Funktion wird die Variable i um 1 erh√∂ht und der Timer auf 0 zur√ºckgesetzt. <br><br>  FUSE-Bits wurden von MK abgeschrieben und unver√§ndert gelassen.  Ich habe sie analysiert, dort ist alles in Ordnung. <br><br><img src="https://habrastorage.org/webt/zv/dt/ll/zvdtllilqlufxumtsv98xelmwnc.png"><br><br><br></div></div><br>  So wurde nicht nur das Ger√§tediagramm kopiert, sondern auch ein MK-Programm entwickelt, das sich in seiner Funktionalit√§t nicht von dem propriet√§ren unterscheidet.  Dar√ºber hinaus wurde es auf Softwareebene m√∂glich, die Zeitparameter des Ger√§ts recht flexibel (und vor allem kostenlos) zu √§ndern und den Steuerausgang (Nr. 1 am Terminal) in verschiedenen Funktionen zu verwenden.  Das Programm ist so einfach, dass es (noch besser) in Assembler geschrieben werden kann, aber ich mache es noch nicht. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de414345/">https://habr.com/ru/post/de414345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de414335/index.html">Hintergrund. Roskomnadzor, was bist du?</a></li>
<li><a href="../de414337/index.html">Ramda Style Thinking: Unver√§nderlichkeit und Objekte</a></li>
<li><a href="../de414339/index.html">Tolle Fototour durch die neue Seite von Moskau Coworking #tceh</a></li>
<li><a href="../de414341/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 256 (vom 3. bis 12. Juni)</a></li>
<li><a href="../de414343/index.html">Google Neural Machine Translation</a></li>
<li><a href="../de414347/index.html">Passive Aggression: Wie sie unser Arbeitsleben zerst√∂rt und wie man damit umgeht</a></li>
<li><a href="../de414349/index.html">Erhalten Sie MCC-Kostenstatistiken: Tinkoff und Rocketbank</a></li>
<li><a href="../de414351/index.html">Die ungew√∂hnlichsten Musikinstrumente: Hammond-Orgel, Vako-Orchester und Synclavier</a></li>
<li><a href="../de414353/index.html">Kivy. Von der Kreation bis zur Produktion ist ein Schritt. Teil 2</a></li>
<li><a href="../de414355/index.html">Leben nach der Explosion</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>