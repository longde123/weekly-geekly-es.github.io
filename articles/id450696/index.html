<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📭 ♑️ 👨‍🎤 Generator widget CRUD untuk Yii ⬇️ 🍛 👨🏻‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa komentar di artikel tentang Habré dan opsi tambahan yang sama saat membeli mobil? 



 Dari sudut pandang pemodelan data, keduanya merupakan entit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generator widget CRUD untuk Yii</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450696/">  Apa komentar di artikel tentang Habré dan opsi tambahan yang sama saat membeli mobil? <br><br><img src="https://habrastorage.org/webt/4x/ex/_2/4xex_2tbdcc_iwesc63zed-dqzm.png"><br><br>  Dari sudut pandang pemodelan data, keduanya merupakan entitas "bersarang" yang tidak memiliki signifikansi independen dalam isolasi dari objek induk. <br><br>  Di Yii ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kerangka php</a> ) ada Gii - generator kode bawaan yang memungkinkan Anda membuat antarmuka CRUD dasar menggunakan model data dengan beberapa klik mouse, yang secara signifikan mempercepat pengembangan, tetapi hanya berlaku untuk entitas independen, seperti artikel atau mesin dalam contoh di atas. <br><br>  Akan sangat bagus untuk dapat menghasilkan sesuatu yang serupa untuk objek data "bersarang", kan?  Sekarang - Anda bisa, selamat datang di kat untuk detailnya. <br><a name="habracut"></a><br>  Untuk yang paling tidak sabar di akhir artikel, instruksi diberikan untuk memulai dengan cepat. <br><br>  Dan bagi mereka yang tertarik dengan artikel tersebut, aspek dari aplikasi bisnis ke perangkat internal dipertimbangkan: <br><br><ul><li>  Kasus Bisnis: Posting berdasarkan Topik <br><ul><li>  Daftar topik di utama </li><li>  Daftar posting terkait </li></ul></li><li>  Di bawah tenda: generator gii berdasarkan CRUD <br><ul><li>  Template Generator Gii </li><li>  Kelas dasar widget </li><li>  Pengontrol fasad terintegrasi </li></ul></li><li>  Mulai cepat <br><ul><li>  Tentang dukungan dan pengembangan </li></ul></li></ul><br><h2>  Kasus Bisnis: Posting berdasarkan Topik </h2><br>  Mungkin komentar tentang habr dan contoh buruk sejak itu  seringkali lebih bermanfaat daripada artikel itu sendiri, tetapi, dalam kasus apa pun, ketika mengembangkan suatu aplikasi, sering kali ada situasi di mana objek tertentu dari model data kurang menarik bagi pengguna sebagai entitas independen. <br><br>  Pertimbangkan tugas bisnis yang disederhanakan: untuk membuat situs web untuk menerbitkan pesan yang dikelompokkan berdasarkan berbagai topik. <br><br>  Situs harus memiliki antarmuka berikut: <br><br><ol><li>  Halaman utama - harus mendukung berbagai widget di masa depan, tetapi pada tahap implementasi saat ini hanya ada satu: daftar topik yang disaring oleh beberapa kriteria. </li><li>  Daftar lengkap topik - daftar lengkap topik dalam bentuk tabel; </li><li>  Halaman topik - informasi tentang topik dan daftar tulisan yang diterbitkan di dalamnya. </li></ol><br>  Cukup standar, bukan? <br><br>  Mari kita lihat model data: <br><br><img src="https://habrastorage.org/webt/f0/db/dp/f0dbdpmz9gbbxhsmxhu7vmzurem.png"><br><br>  Juga tidak ada kejutan.  Dua kelas model akan berisi logika bisnis kami: <br><br><ul><li>  Kelas <b>Topik</b> - data tentang topik, validasi, daftar posting di dalamnya, serta metode terpisah yang mengembalikan daftar topik yang difilter menurut kriteria widget di halaman utama. </li><li>  Kelas <b>Post</b> hanya data dan validasi. </li></ul><br>  Aplikasi akan dilayani oleh dua pengontrol: <br><br><ul><li>  <b>SiteController</b> - halaman standar (tentang kami, kontak, dll.), Otorisasi (tidak diperlukan oleh ketentuan referensi, tetapi kami tahu sesuatu) dan indeks - halaman utama.  Karena  kami berharap banyak widget yang berbeda di masa mendatang, masuk akal untuk meninggalkan halaman utama di controller ini, dan tidak mentransfernya ke model yang spesifik untuk satu. </li><li>  <b>TopicController</b> adalah serangkaian tindakan standar: daftar, buat, edit, lihat, dan hapus topik. </li></ul><br>  Secara potensial, Anda juga dapat membuat <b>PostController</b> - untuk keperluan administrasi dan / atau menyalin-tempel kode ke widget khusus, tetapi biarkan ini di luar cakupan artikel ini. <br>  Hingga saat ini, sebagian besar kode dapat dihasilkan menggunakan gii, yang mempercepat pengembangan dan mengurangi risiko (kode manual lebih sedikit = lebih sedikit peluang untuk melakukan kesalahan). <br><br>  Masih ada dua pertanyaan: <br><br><ol><li>  Bagaimana cara menampilkan daftar topik yang difilter pada halaman utama? </li><li>  Bagaimana cara menampilkan daftar posting berdasarkan topik? </li></ol><br>  Jika Anda dapat menyelesaikannya menggunakan generator otomatis - ini akan menjadi pencapaian yang solid. <br><br><h3>  Daftar topik di utama </h3><br>  Halaman utama yang dilayani oleh situs / alamat indeks harus berisi daftar topik yang difilter oleh kriteria yang telah ditentukan.  Kriteria penyaringan, sebagai bagian dari logika bisnis, kami telah dimasukkan dalam model. <br><br>  Untuk tampilan, ada beberapa opsi implementasi. <br><br>  Yang pertama, kotor dan cepat, adalah melakukan semuanya langsung di file <b>tampilan</b> ( <b>views / site / index.php</b> ): <br><br><ol><li>  Buat <b>ActiveDataProvider</b> ; </li><li>  Isi dengan data dari model <b>Topik</b> ; </li><li>  Tampilan menggunakan widget <b>ListView</b> / <b>GridView</b> standar, menentukan bidang yang diperlukan secara manual. </li></ol><br>  Anda dapat melangkah lebih jauh dan mengemas semuanya ke dalam file tampilan yang terpisah, sesuatu seperti <b>views / site / _topic-list-widget.php</b> , menggunakan <b>rendernya</b> dari file utama.  Ini akan memberikan sedikit lebih mudah dikelola dan diperpanjang, tetapi masih terlihat sangat kotor. <br><br>  Sebagian besar dari kita cenderung membuat widget terpisah sesuai dengan semua aturan, dalam ruang nama yang terpisah ( <b>komponen</b> <b>app \ widgets</b> atau <b>app \</b> untuk templat dasar - tergantung pada versi yang Anda gunakan), di mana mereka merangkum pembuatan <b>ActiveDataProvider</b> berdasarkan model dan ditampilkan secara terpisah. pengajuan.  Yang tersisa hanyalah memanggil widget ini dari halaman utama.  Solusi ini adalah yang paling benar dari sudut pandang dekomposisi kelas, pengelolaan dan ekstensibilitas kode. <br><br>  Tetapi apakah rasanya kode widget ini akan sangat mengulang kode <b>TopicController</b> dalam hal menangani <b>actionIndex ()</b> ?  Dan sangat menjengkelkan menulis kode ini secara manual. <br><br>  Akan jauh lebih baik untuk menghasilkan kode ini secara otomatis dan kemudian panggil widget yang sudah selesai: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= \app\widgets\TopicControllerWidget::widget([ <span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'index'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'query'</span></span> =&gt; app\models\Topic::findBySomeSpecificCriteria() ], ]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br><h3>  Daftar posting terkait </h3>  Halaman untuk melihat topik yang dilayani oleh <b>topik /</b> alamat <b>tampilan</b> harus berisi informasi tentang topik itu sendiri dan daftar pesan yang diterbitkan di dalamnya.  Kami mendapatkan daftar pesan untuk topik dalam model secara otomatis jika kami telah mengkonfigurasi hubungan antara tabel dengan benar, sehingga hanya pertanyaan tampilan yang tersisa. <br><br>  Dengan analogi dengan daftar topik yang difilter, kami memiliki opsi yang hampir sama. <br><br>  Yang pertama adalah melakukan segala sesuatu dalam kode file tampilan untuk melihat topik ( <b>views / topic / view.php</b> ): <br><br><ol><li>  Buat <b>ActiveDataProvider</b> ; </li><li>  Isi dengan data dari model <b>$ model-&gt; getPosts ()</b> ; </li><li>  Tampilan menggunakan widget <b>ListView</b> / <b>GridView</b> standar, menentukan bidang yang diperlukan secara manual. </li></ol><br>  Yang kedua adalah mengisolasi kode ini ke dalam file presentasi yang terpisah: <b>views / topic / _posts-list-widget.php</b> , supaya tidak merusak pemandangan - menggunakannya kembali di suatu tempat masih akan gagal. <br><br>  Yang ketiga adalah widget lengkap yang sebagian besar akan menduplikasi kode dari <b>PostController</b> bersyarat di bagian <b>actionIndex ()</b> , tetapi ditulis secara manual. <br><br>  Atau buat kode secara otomatis dan panggil widget yang sudah selesai: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([ <span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'index'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'query'</span></span> =&gt; $model-&gt;getPosts(), ], ]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre><br><h2>  Di bawah tenda: generator gii berdasarkan CRUD </h2><br>  Tugas bisnis ditentukan, persyaratan untuk widget yang dihasilkan diuraikan, kami akan mencari tahu bagaimana tepatnya kami akan menghasilkannya.  Gii sudah memiliki generator untuk pengontrol CRUD.  Untuk widget CRUD, kita perlu membuat generator baru berdasarkan yang sudah ada. <br><br>  Beberapa tautan ke dokumentasi sebelum memulai - itu juga akan berguna jika Anda memutuskan untuk menulis ekstensi Anda sendiri: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ekstensi Yii</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Templat Yii gii</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generator Yii gii</a> . </li></ul><br>  Jelas, semua fungsi dikemas dalam ekstensi Yii, yang diinstal melalui komposer dan masuk ke folder vendor proyek Anda. <br><br>  Perpanjangan terdiri dari tiga bagian: <br><br><ol><li>  Direktori <b>templat / crud yang</b> berisi templat generator gii; </li><li>  File <b>controller.php</b> - pengontrol fasad bawaan untuk panggilan widget; </li><li>  File <b>Widget.php</b> adalah kelas dasar untuk semua widget yang dihasilkan. </li></ol><br><img src="https://habrastorage.org/webt/uh/le/4c/uhle4cnzxzmubqgtoitn3ox5b_u.png"><br><br><h3>  Template Generator Gii </h3><br>  Ekstensi harus menghasilkan kode, jadi bagian utamanya adalah generator Gii. <br><br>  Awalnya, diasumsikan bahwa untuk mengimplementasikan ekstensi itu akan cukup untuk menulis template Anda sendiri untuk generator CRUD-Controller bawaan.  Ngomong-ngomong, inilah sebabnya direktori tersebut disebut template, bukan generator.  Tetapi ternyata generator CRUD-Controller melakukan validasi data input yang sangat intensif, yang tidak memungkinkan untuk mengimplementasikan banyak persyaratan, misalnya, mengubah kelas untuk warisan.  Oleh karena itu, ekstensi berisi generator lengkap, dan bukan hanya templat. <br><br>  Generator gii terdiri dari bagian-bagian berikut (semua ada di dalam direktori templat / crud): <br><br><ul><li>  Direktori <b>default</b> adalah template di mana semua keajaiban terjadi: setiap file dalam direktori ini akan sesuai dengan satu file yang dihasilkan dalam proyek Anda; </li><li>  File <b>form.php</b> - seperti yang Anda tebak dari namanya, ini adalah formulir untuk memasukkan parameter pembuatan (nama kelas, dll.); </li><li>  File <b>Generator.php</b> - orkestra generasi yang menerima data dari formulir, memvalidasinya, dan kemudian secara berurutan memanggil file templat untuk membuat hasilnya. </li></ul><br>  File <b>Generator.php</b> dan <b>form.php</b> sebagian besar berisi perubahan kosmetik relatif terhadap yang asli dari generator CRUD: nama file, validasi, deskripsi, dan prompt teks, dll. <br><br>  File template bertanggung jawab atas tampilan yang dihasilkan dan kode widget itu sendiri.  Pertama-tama, <b>templat</b> file <b>/ crud / default / controller.php adalah</b> penting, yang bertanggung jawab untuk secara langsung menghasilkan kelas widget yang sesuai dengan kelas controller dari generator asli. <br><br>  Widget harus memiliki tindakan yang sama dengan kontroler CRUD, tetapi dihasilkan sedikit berbeda.  Contoh di bawah ini menunjukkan hasil generasi dengan komentar: <br><br><ul><li>  actionIndex - alih-alih keluaran tanpa syarat semua model, metode menerima parameter $ query; <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($query)</span></span></span><span class="hljs-function"> </span></span>{ $dataProvider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActiveDataProvider([ <span class="hljs-string"><span class="hljs-string">'query'</span></span> =&gt; $query, ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;render(<span class="hljs-string"><span class="hljs-string">'index'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'dataProvider'</span></span> =&gt; $dataProvider, ]); }</code> </pre> </li><li>  actionCreate dan actionUpdate - jika sukses, alih-alih redirect, mereka hanya mengembalikan kode sukses, pemrosesan lebih lanjut disediakan oleh pengontrol fasad bawaan; <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $model = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Post(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($model-&gt;load(Yii::$app-&gt;request-&gt;post()) &amp;&amp; $model-&gt;save()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'success'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;render(<span class="hljs-string"><span class="hljs-string">'create'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'model'</span></span> =&gt; $model, ]); }</code> </pre> <br></li><li>  actionDelete - mendukung metode GET untuk menampilkan widget hapus (secara default - satu tombol) dan POST untuk melakukan tindakan;  jika berhasil, itu juga tidak melakukan redirect, tetapi mengembalikan kode. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">actionDelete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $model = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;findModel($id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Yii::$app-&gt;request-&gt;method == <span class="hljs-string"><span class="hljs-string">'GET'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;render(<span class="hljs-string"><span class="hljs-string">'delete'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'model'</span></span> =&gt; $model, ]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $model-&gt;delete(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'success'</span></span>; } }</code> </pre> </li></ul><br>  Akhirnya, lihat file berisi suntingan dasar berikut: <br><br><ul><li>  Semua header diterjemahkan ke h2 bukan h1; </li><li>  Menghapus kode yang bertanggung jawab untuk menampilkan judul halaman dan untuk remah roti - widget tidak boleh memengaruhi hal-hal ini; </li><li>  Membuat dan mengedit model dilakukan menggunakan jendela modal (widget Modal bawaan); </li><li>  Menambahkan template hapus widget - dengan satu tombol merah besar. </li></ul><br><h3>  Kelas dasar widget </h3><br>  Ketika generator menyelesaikan tugasnya, itu akan membuat kelas widget di namespace aplikasi.  Rantai pewarisan terlihat seperti ini: widget yang dihasilkan untuk aplikasi diwarisi dari widget ekstensi dasar, kelas <b>\ ianikanov \ wce \ Widget</b> , yang, pada gilirannya, diwarisi dari widget Yii dasar, kelas <b>\ yii \ base \ Widget</b> . <br><br>  Kelas dasar widget ekstensi menyelesaikan tugas-tugas berikut: <br><br><ol><li>  Menentukan dua bidang utama: $ action dan $ params, yang dengannya kontrol ditransfer ke widget dari tampilan panggilan; </li><li>  Menentukan sejumlah parameter standar yang dapat ditimpa di kelas yang dibuat, seperti jalur ke file tampilan widget, nama dan jalur ke pengontrol fasad (tentangnya di bawah) dan pesan kesalahan; </li><li>  Menentukan parameter standar saat menampilkan tampilan: render dan renderFile; </li><li>  Menyediakan infrastruktur acara yang mirip dengan infrastruktur pengontrol sehingga filter standar seperti <b>AccessControl</b> dan <b>VerbFilter berfungsi</b> ; </li><li>  Menentukan metode run yang mengumpulkan semua ini bersama-sama. </li></ol><br><h3>  Pengontrol fasad terintegrasi </h3>  Tidak ada masalah dengan tampilan data ini - widget dimaksudkan untuk tujuan ini.  Tetapi untuk mengedit, Anda memerlukan pengontrol.  Hasilkan pengontrol unik untuk setiap widget - seluruh esensinya hilang.  Menggunakan CRUD standar tidak selalu relevan, dan saya tidak ingin bergantung pada peluncuran tambahan gii.  Oleh karena itu, opsi ini digunakan dengan pengontrol-fasad universal yang terintegrasi. <br><br>  Pengontrol ini terdaftar di peta aplikasi melalui file konfigurasi dan hanya berisi satu metode - actionIndex, yang melakukan tindakan berikut: <br><br><ol><li>  Menerima permintaan dari klien; </li><li>  Kontrol transfer ke kelas widget yang sesuai; </li><li>  Menangani kesalahan bisnis sebagai akibat dari widget; </li><li>  Pengalihan kembali ke aplikasi utama. </li></ol><br>  Mungkin lebih penting untuk menunjukkan apa yang BUKAN pengendali ini: <br><br><ol><li>  Itu tidak memeriksa tingkat akses - logika ini milik widget tertentu; </li><li>  Itu tidak melakukan manipulasi input - parameter dilewatkan ke widget apa adanya; </li><li>  Itu tidak memanipulasi output kecuali untuk memeriksa kode sukses yang telah ditentukan. </li></ol><br>  Pendekatan ini memungkinkan Anda untuk mempertahankan fleksibilitas fasad, meninggalkan penerapan persyaratan bisnis, termasuk persyaratan keamanan, kode aplikasi aplikasi. <br><br><h2>  Mulai cepat </h2>  Tantangan bisnisnya jelas, siap untuk memulai?  Menggunakan ekstensi memiliki empat langkah: <br><br><ol><li>  Instalasi; </li><li>  Konfigurasi; </li><li>  Generasi; </li><li>  Aplikasi. </li></ol><br>  Memasang ekstensi dilakukan menggunakan komposer: <br><br><pre> <code class="bash hljs">php composer.phar require --prefer-dist ianikanov/yii2-wce <span class="hljs-string"><span class="hljs-string">"dev-master"</span></span></code> </pre> <br>  Selanjutnya, Anda perlu membuat beberapa perubahan pada file konfigurasi aplikasi. <br><br>  Pertama, tambahkan referensi ke generator gii: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (YII_ENV_DEV) { $config[<span class="hljs-string"><span class="hljs-string">'modules'</span></span>][<span class="hljs-string"><span class="hljs-string">'gii'</span></span>] = [ <span class="hljs-string"><span class="hljs-string">'class'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'yii\gii\Module'</span></span>, <span class="hljs-string"><span class="hljs-string">'allowedIPs'</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, <span class="hljs-string"><span class="hljs-string">'::1'</span></span>, <span class="hljs-string"><span class="hljs-string">'192.168.0.*'</span></span>, <span class="hljs-string"><span class="hljs-string">'192.168.178.20'</span></span>], <span class="hljs-string"><span class="hljs-string">'generators'</span></span> =&gt; [ <span class="hljs-comment"><span class="hljs-comment">//here 'widgetCrud' =&gt; [ 'class' =&gt; '\ianikanov\wce\templates\crud\Generator', 'templates' =&gt; [ 'WCE' =&gt; '@vendor/ianikanov/yii2-wce/templates/crud/default', // template name ], ], ], ]; }</span></span></code> </pre> <br>  Kedua, tambahkan pengontrol fasad terintegrasi ke peta: <br><br><pre> <code class="php hljs">$config = [ ... <span class="hljs-string"><span class="hljs-string">'controllerMap'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'wce-embed'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'\ianikanov\wce\Controller'</span></span>, ], ... ];</code> </pre> <br>  Ini menyelesaikan instalasi dan konfigurasi. <br><br>  Untuk menghasilkan widget: <br><br><ol><li>  Buka gii; </li><li>  Pilih "Widget Pengontrol CRUD"; </li><li>  Isi kolom formulir; </li><li>  Lihat dan hasilkan kode. </li></ol><br>  Selanjutnya, untuk menggunakan widget, itu harus dipanggil dengan menentukan tindakan dan params - hampir sama dengan controller yang disebut. <br><br>  Widget untuk melihat daftar model: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([ <span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'index'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span> =&gt; [ <span class="hljs-string"><span class="hljs-string">'query'</span></span> =&gt; $otherModel-&gt;getPosts(), ], ]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Widget untuk melihat satu model: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([<span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'view'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; $post_id]]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Widget pembuatan model (tombol + formulir yang dibungkus dengan Modal): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([<span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'create'</span></span>]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Widget perubahan model (tombol + formulir yang dibungkus dengan Modal): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([<span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'update'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span>=&gt;[<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; $post_id]]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Widget penghapusan model (tombol): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?</span></span>= app\widgets\PostControllerWidget::widget([<span class="hljs-string"><span class="hljs-string">'action'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'delete'</span></span>, <span class="hljs-string"><span class="hljs-string">'params'</span></span>=&gt;[<span class="hljs-string"><span class="hljs-string">'id'</span></span> =&gt; $post_id]]) <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Kode widget dan semua tampilan milik aplikasi dan dapat dengan mudah diubah - semuanya persis sama seperti saat membuat controller. <br><br><h3>  Tentang dukungan dan pengembangan </h3><br>  Beberapa kata tentang bagaimana ekspansi akan didukung dan dikembangkan.  Saya memiliki pekerjaan utama dan beberapa proyek "sampingan" saya (proyek kesayangan).  Jadi, ekstensi ini adalah proyek sampingan dari proyek sampingan saya, jadi saya akan mengembangkan peningkatan hanya untuk kebutuhan proyek saya. <br><br>  Dalam tradisi open source terbaik, kode tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> , dan saya akan mendukungnya dalam hal memperbaiki bug, dan saya juga akan mencoba melakukan tinjauan tepat waktu jika ada yang ingin mengirim permintaan tarik, jadi siapa yang tertarik, bergabunglah. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450696/">https://habr.com/ru/post/id450696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450682/index.html">Buku "CSS for the pro"</a></li>
<li><a href="../id450684/index.html">Cool Smart Jumps: Tangram Smart Rope Smart Rope Review</a></li>
<li><a href="../id450686/index.html">Tiga fitur tersembunyi lainnya dari Zimbra Collaboration Suite yang akan membantu meningkatkan produktivitas karyawan</a></li>
<li><a href="../id450692/index.html">Bagaimana Perusahaan Menggunakan 7 Dosa Mematikan dalam Penjualan Produk</a></li>
<li><a href="../id450694/index.html">Mengapa Jeff Bezos merekomendasikan penskalaan kegagalan dan menonton fiksi ilmiah</a></li>
<li><a href="../id450698/index.html">Gears di Box2D</a></li>
<li><a href="../id450700/index.html">Lagi tentang abstraksi berlubang (atau tentang lingkungan yang tidak dapat diprediksi)</a></li>
<li><a href="../id450702/index.html">Tempatnya terkutuk?</a></li>
<li><a href="../id450704/index.html">Minggu Keamanan 19: Kerentanan dalam Kamera IP, Pelacak GPS dan Monitor Nirkabel</a></li>
<li><a href="../id450708/index.html">Python dalam Visual Studio Code - April 2019 Release</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>