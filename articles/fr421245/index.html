<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèÇüèª üíá üßëüèª‚Äçü§ù‚Äçüßëüèª C #: un cas d'utilisation pour n'importe quelle t√¢che üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø ‚ôÄÔ∏è üå∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Nous continuons √† parler de programmation asynchrone en C #. Aujourd'hui, nous parlerons d'un cas d'utilisation unique ou d'un sc√©nario...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C #: un cas d'utilisation pour n'importe quelle t√¢che</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/421245/">  Bonjour, Habr!  Nous continuons √† parler de programmation asynchrone en C #.  Aujourd'hui, nous parlerons d'un cas d'utilisation unique ou d'un sc√©nario sp√©cifique √† l'utilisateur adapt√© √† toutes les t√¢ches dans le cadre de la programmation asynchrone.  Nous aborderons les sujets de la synchronisation, des blocages, des param√®tres de l'op√©rateur, de la gestion des exceptions et bien plus encore.  Rejoignez-nous maintenant! <br><br><img src="https://habrastorage.org/webt/fn/3y/w8/fn3yw8b2lmo8cbbziqaiogmvsxy.jpeg"><a name="habracut"></a><br><br><blockquote>  <b>Articles connexes pr√©c√©dents</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Programmation asynchrone C #: Comment faites-vous avec les performances?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Remplacer Equals et GetHashCode.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mais est-ce n√©cessaire?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Que trouve-t-on dans le code de quelqu'un d'autre?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Une s√©lection de mat√©riaux utiles pour .NET</a> </li></ul></blockquote><br>  Presque tout comportement non standard des m√©thodes asynchrones en C # peut √™tre expliqu√© sur la base d'un sc√©nario utilisateur: la conversion d'un code synchrone existant en asynchrone doit √™tre aussi simple que possible.  Vous devez pouvoir ajouter le mot-cl√© async avant le type de retour de la m√©thode, ajouter le suffixe Async au nom de cette m√©thode et ajouter le mot-cl√© wait ici et dans la zone de texte de la m√©thode pour obtenir une m√©thode asynchrone enti√®rement fonctionnelle. <br><br><img width="550" src="https://habrastorage.org/webt/di/uw/i8/diuwi85jehdfov_iozovmreg59s.png"><br><br>  Un sc√©nario ¬´simple¬ª modifie consid√©rablement de nombreux aspects du comportement des m√©thodes asynchrones: de la planification de la dur√©e d'une t√¢che √† la gestion des exceptions.  Le script semble convaincant et significatif, mais dans son contexte, la simplicit√© des m√©thodes asynchrones devient tr√®s trompeuse. <br><br><h2>  Contexte de synchronisation </h2><br>  Le d√©veloppement de l'interface utilisateur (UI) est un domaine dans lequel le sc√©nario ci-dessus est particuli√®rement important.  En raison de longues op√©rations dans le thread d'interface utilisateur, le temps de r√©ponse des applications augmente, auquel cas la programmation asynchrone a toujours √©t√© consid√©r√©e comme un outil tr√®s efficace. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 -- UI Thread var result = await _stockPrices.GetStockPricesForAsync("MSFT"); // 2 -- Usually non-UI Thread textBox.Text = "Result is: " + result; //3 -- Should be UI Thread }</span></span></code> </pre> <br>  Le code semble tr√®s simple, mais il y a un probl√®me.  Il existe des restrictions pour la plupart des interfaces utilisateur: les √©l√©ments de l'interface utilisateur ne peuvent √™tre modifi√©s que par des threads sp√©ciaux.  Autrement dit, √† la ligne 3, une erreur se produit si la dur√©e de la t√¢che est planifi√©e dans le thread √† partir du pool de threads.  Heureusement, ce probl√®me est connu depuis longtemps et le concept de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contexte de synchronisation est</a> apparu dans la version du .NET Framework 2.0. <br><br>  Chaque interface utilisateur fournit des utilitaires sp√©ciaux pour le marshaling des t√¢ches dans un ou plusieurs threads d'interface utilisateur sp√©cialis√©s.  Windows Forms utilise la m√©thode <code>Control.Invoke</code> , WPF <code>Control.Invoke</code> m√©thode Dispatcher.Invoke, d'autres syst√®mes peuvent acc√©der √† d'autres m√©thodes.  Les sch√©mas utilis√©s dans tous ces cas sont largement similaires, mais diff√®rent en d√©tail.  Le contexte de synchronisation vous permet de faire abstraction des diff√©rences en fournissant une API pour ex√©cuter le code dans un contexte ¬´sp√©cial¬ª qui permet le traitement des d√©tails mineurs par des types d√©riv√©s tels que <code>WindowsFormsSynchronizationContext</code> , <code>DispatcherSynchronizationContext</code> , etc. <br><br>  Pour r√©soudre le probl√®me de l'affinit√© des threads, les programmeurs C # ont d√©cid√© d'introduire le contexte de synchronisation actuel au stade initial de la mise en ≈ìuvre des m√©thodes asynchrones et de planifier toutes les op√©rations suivantes dans ce contexte.  D√©sormais, chacun des blocs entre les instructions en attente est ex√©cut√© dans le thread d'interface utilisateur, ce qui permet d'impl√©menter le script principal.  Cependant, cette solution a soulev√© un certain nombre de nouveaux probl√®mes. <br><br><h2>  Deadlocks </h2><br>  Regardons un petit morceau de code relativement simple.  Y a-t-il des probl√®mes ici? <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { await Task.Yield(); return 42; }</span></span></code> </pre> <br>  Ce code provoque un <b>blocage</b> .  Le thread d'interface utilisateur d√©marre une op√©ration asynchrone et attend le r√©sultat de mani√®re synchrone.  Toutefois, la m√©thode asynchrone ne peut pas √™tre termin√©e car la deuxi√®me ligne de <code>GetStockPricesForAsync</code> doit √™tre ex√©cut√©e dans le thread d'interface utilisateur qui provoque le blocage. <br><br>  Vous objecterez que ce probl√®me est assez facile √† r√©soudre.  Oui en effet.  Vous devez interdire tous les appels √† la <code>Task.Wait</code> <code>Task.Result</code> ou <code>Task.Wait</code> partir du code d'interface utilisateur, cependant, le probl√®me peut toujours se produire si le composant utilis√© par ce code attend le r√©sultat de l'op√©ration utilisateur de mani√®re synchrone: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// UI code private void buttonOk_Click(object sender, EventArgs args) { textBox.Text = "Running.."; var result = _stockPrices.GetStockPricesForAsync("MSFT").Result; textBox.Text = "Result is: " + result; } // StockPrices.dll public Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // We know that the initialization step is very fast, // and completes synchronously in most cases, // let's wait for the result synchronously for "performance reasons". InitializeIfNeededAsync().Wait(); return Task.FromResult((decimal)42); } // StockPrices.dll private async Task InitializeIfNeededAsync() =&gt; await Task.Delay(1);</span></span></code> </pre> <br>  Ce code provoque √† nouveau un blocage.  Comment le r√©soudre: <br><br><ul><li>  Vous ne devez pas bloquer le code asynchrone avec <code>Task.Wait()</code> ou <code>Task.Result</code> et </li><li>  utilisez <code>ConfigureAwait(false)</code> dans le code de la biblioth√®que. </li></ul><br>  La signification de la premi√®re recommandation est claire, et la deuxi√®me, nous l'expliquerons ci-dessous. <br><br><h2>  Configuration des instructions d'attente </h2><br>  Il existe deux raisons pour lesquelles un blocage se produit dans le dernier exemple: <code>Task.Wait()</code> dans <code>GetStockPricesForAsync</code> et l'utilisation indirecte du contexte de synchronisation dans les √©tapes suivantes de InitializeIfNeededAsync.  Bien que les programmeurs C # ne recommandent pas de bloquer les appels aux m√©thodes asynchrones, il est √©vident que dans la plupart des cas, ce blocage est toujours utilis√©.  Les programmeurs C # offrent la solution suivante √† un probl√®me de blocage: <code>Task.ConfigureAwait(continueOnCapturedContext:false)</code> . <br><br>  Malgr√© l'apparence √©trange (si un appel de m√©thode est ex√©cut√© sans argument nomm√©, cela ne signifie rien du tout), cette solution remplit sa fonction: elle fournit une poursuite forc√©e de l'ex√©cution sans contexte de synchronisation. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Delay(<span class="hljs-number"><span class="hljs-number">1</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  Dans ce cas, la poursuite de la <code>Task.Delay(1</code> ) (voici l'instruction vide) est planifi√©e dans le thread du pool de threads, et non dans le thread de l'interface utilisateur, ce qui √©limine le blocage. <br><br><h2>  D√©sactiver le contexte de synchronisation </h2><br>  Je sais que <code>ConfigureAwait</code> r√©sout r√©ellement ce probl√®me, mais il appara√Æt beaucoup plus.  Voici un petit exemple: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPricesForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> symbol</span></span></span><span class="hljs-function">)</span></span> { InitializeIfNeededAsync().Wait(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult((<span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>)<span class="hljs-number"><span class="hljs-number">42</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Initialize the cache field first await _cache.InitializeAsync().ConfigureAwait(false); // Do some work await Task.Delay(1); }</span></span></code> </pre> <br>  Voyez-vous le probl√®me?  Nous avons utilis√© <code>ConfigureAwait(false)</code> , donc tout devrait bien se passer.  Mais pas un fait. <br><br>  <code>ConfigureAwait(false)</code> renvoie un objet <code>ConfiguredTaskAwaitable</code> attente personnalis√©, et nous savons qu'il n'est utilis√© que si la t√¢che ne se termine pas de mani√®re synchrone.  Autrement dit, si <code>_cache.InitializeAsync()</code> termine de mani√®re synchrone, un blocage est toujours possible. <br><br>  Pour √©liminer les blocages, toutes les t√¢ches en attente de fin doivent √™tre ¬´d√©cor√©es¬ª avec un appel √† la m√©thode <code>ConfigureAwait(false)</code> .  Tout cela agace et g√©n√®re des erreurs. <br><br>  Vous pouvez √©galement utiliser l'objet personnalis√© waiter dans toutes les m√©thodes publiques pour d√©sactiver le contexte de synchronisation dans la m√©thode asynchrone: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).Result; textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; } <span class="hljs-comment"><span class="hljs-comment">// StockPrices.dll public async Task&lt;decimal&gt; GetStockPricesForAsync(string symbol) { // The rest of the method is guarantee won't have a current sync context. await Awaiters.DetachCurrentSyncContext(); // We can wait synchronously here and we won't have a deadlock. InitializeIfNeededAsync().Wait(); return 42; }</span></span></code> </pre> <br>  <code>Awaiters.DetachCurrentSyncContext</code> renvoie l'objet d'attente personnalis√© suivant: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DetachSynchronizationContextAwaiter : ICriticalNotifyCompletion { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Returns true if a current synchronization context is null. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> It means that the continuation is called only when a current context </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> is presented. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public bool IsCompleted =&gt; SynchronizationContext.Current == null; public void OnCompleted(Action continuation) { ThreadPool.QueueUserWorkItem(state =&gt; continuation()); } public void UnsafeOnCompleted(Action continuation) { ThreadPool.UnsafeQueueUserWorkItem(state =&gt; continuation(), null); } public void GetResult() { } public DetachSynchronizationContextAwaiter GetAwaiter() =&gt; this; } public static class Awaiters { public static DetachSynchronizationContextAwaiter DetachCurrentSyncContext() { return new DetachSynchronizationContextAwaiter(); } }</span></span></code> </pre> <br>  <code>DetachSynchronizationContextAwaiter</code> effectue les op√©rations suivantes: la m√©thode async fonctionne avec un contexte de synchronisation diff√©rent de z√©ro.  Mais si la m√©thode async fonctionne sans contexte de synchronisation, la propri√©t√© <code>IsCompleted</code> renvoie true et la poursuite de la m√©thode est effectu√©e de mani√®re synchrone. <br><br>  Cela signifie que les donn√©es de service sont proches de z√©ro lorsque la m√©thode asynchrone est ex√©cut√©e √† partir d'un thread dans le pool de threads et que le paiement est effectu√© une fois pour le transfert de l'ex√©cution du thread de l'interface utilisateur vers le thread du pool de threads. <br><br>  D'autres avantages de cette approche sont √©num√©r√©s ci-dessous. <br><br><ul><li>  <b>La probabilit√© d'erreur est r√©duite.</b>  <code>ConfigureAwait(false)</code> ne fonctionne que s'il est appliqu√© √† toutes les t√¢ches en attente de fin.  Il vaut la peine d'oublier au moins une chose - et une impasse peut se produire.  Dans le cas d'un objet attendant personnalis√©, n'oubliez pas que toutes les m√©thodes de biblioth√®que publique doivent commencer par <code>Awaiters.DetachCurrentSyncContext()</code> .  Des erreurs sont possibles ici, mais leur probabilit√© est beaucoup plus faible. </li><li>  <b>Le code r√©sultant est plus d√©claratif et clair.</b>  La m√©thode <code>ConfigureAwait</code> avec plusieurs appels me semble moins lisible (en raison d'√©l√©ments suppl√©mentaires) et pas assez informative pour les d√©butants. </li></ul><br><h2>  Gestion des exceptions </h2><br>  Quelle est la diff√©rence entre ces deux options: <br><br>  Task mayFail = Task.FromException (new ArgumentNullException ()); <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Case 1 try { await mayFail; } catch (ArgumentException e) { // Handle the error } // Case 2 try { mayFail.Wait(); } catch (ArgumentException e) { // Handle the error }</span></span></code> </pre> <br>  Dans le premier cas, tout r√©pond aux attentes - le traitement des erreurs est effectu√©, mais dans le second cas, cela ne se produit pas.  La biblioth√®que de t√¢ches parall√®les TPL est con√ßue pour la programmation asynchrone et parall√®le, et la t√¢che / t√¢che peut repr√©senter le r√©sultat de plusieurs op√©rations.  C'est pourquoi <code>Task.Result</code> et <code>Task.Wait()</code> toujours une <code>AggregateException</code> , qui peut contenir plusieurs erreurs. <br><br>  Cependant, notre sc√©nario principal change tout: l'utilisateur devrait pouvoir ajouter l'op√©rateur asynchrone / attendre sans toucher √† la logique de gestion des erreurs.  Autrement dit, l'instruction d'attente doit √™tre diff√©rente de <code>Task.Result</code> / <code>Task.Wait()</code> : elle doit supprimer l'encapsuleur d'une exception dans l'instance <code>AggregateException</code> .  Aujourd'hui, nous allons s√©lectionner la premi√®re exception. <br><br>  Tout va bien si toutes les m√©thodes bas√©es sur Task sont asynchrones et que les calculs parall√®les ne sont pas utilis√©s pour effectuer des t√¢ches.  Mais dans certains cas, tout est diff√©rent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// await will rethrow the first exception await Task.WhenAll(task1, task2); } catch (Exception e) { // ArgumentNullException. The second error is lost! Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br>  <code>Task.WhenAll</code> renvoie une t√¢che avec deux erreurs, cependant, l'instruction d'attente r√©cup√®re et remplit uniquement la premi√®re. <br><br>  Il existe deux fa√ßons de r√©soudre ce probl√®me: <br><br><ol><li>  afficher manuellement les t√¢ches si elles y ont acc√®s, ou </li><li>  configurez la biblioth√®que TPL pour forcer l'exception √† √™tre encapsul√©e dans une autre <code>AggregateException</code> . </li></ol><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task1 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException()); Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; task2 = Task.FromException&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException()); <span class="hljs-comment"><span class="hljs-comment">// t.Result forces TPL to wrap the exception into AggregateException await Task.WhenAll(task1, task2).ContinueWith(t =&gt; t.Result); } catch(Exception e) { // AggregateException Console.WriteLine(e.GetType()); }</span></span></code> </pre> <br><h2>  M√©thode Async void </h2><br>  La m√©thode bas√©e sur les t√¢ches renvoie un jeton qui peut √™tre utilis√© pour traiter les r√©sultats √† l'avenir.  Si la t√¢che est perdue, le jeton devient inaccessible √† la lecture par le code utilisateur.  Une op√©ration asynchrone qui renvoie la m√©thode void g√©n√®re une erreur qui ne peut pas √™tre g√©r√©e dans le code utilisateur.  En ce sens, les jetons sont inutiles et m√™me dangereux - maintenant nous le verrons.  Cependant, notre sc√©nario principal suppose leur utilisation obligatoire: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buttonOk_ClickAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs args</span></span></span><span class="hljs-function">)</span></span> { textBox.Text = <span class="hljs-string"><span class="hljs-string">"Running.."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> _stockPrices.GetStockPricesForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); textBox.Text = <span class="hljs-string"><span class="hljs-string">"Result is: "</span></span> + result; }</code> </pre> <br>  Mais que se passe- <code>GetStockPricesForAsync</code> si <code>GetStockPricesForAsync</code> g√©n√®re une erreur?  Une exception de m√©thode async void non g√©r√©e est marshal√©e dans le contexte de synchronisation actuel, d√©clenchant le m√™me comportement que pour le code synchrone (pour plus d'informations, consultez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">m√©thode ThrowAsync</a> sur la page Web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AsyncMethodBuilder.cs</a> ).  Sur Windows Forms, une exception non g√©r√©e dans le gestionnaire d'√©v√©nements d√©clenche l'√©v√©nement <code>Application.ThreadException</code> , pour WPF, l'√©v√©nement <code>Application.DispatcherUnhandledException</code> d√©clenche, etc. <br><br>  Que faire si la m√©thode async void n'obtient pas le contexte de synchronisation?  Dans ce cas, une exception non g√©r√©e provoque un blocage fatal de l'application.  Il ne d√©clenchera pas l'√©v√©nement [ <code>TaskScheduler.UnobservedTaskException</code> ] en cours de restauration, mais d√©clenchera l'√©v√©nement <code>AppDomain.UnhandledException</code> qui ne sera pas restaur√©, puis fermera l'application.  Cela se produit intentionnellement, et c'est exactement le r√©sultat dont nous avons besoin. <br><br>  Voyons maintenant une autre m√©thode bien connue: utiliser des m√©thodes void asynchrones uniquement pour les gestionnaires d'√©v√©nements de l'interface utilisateur. <br><br>  Malheureusement, la m√©thode asynch void est facile √† appeler par accident. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Task&lt;T&gt; ActionWithRetry&lt;T&gt;(Func&lt;Task&lt;T&gt;&gt; provider, Action&lt;Exception&gt; onError) { <span class="hljs-comment"><span class="hljs-comment">// Calls 'provider' N times and calls 'onError' in case of an error. } public async Task&lt;string&gt; AccidentalAsyncVoid(string fileName) { return await ActionWithRetry( provider: () =&gt; { return File.ReadAllTextAsync(fileName); }, // Can you spot the issue? onError: async e =&gt; { await File.WriteAllTextAsync(errorLogFile, e.ToString()); }); }</span></span></code> </pre> <br>  √Ä premi√®re vue, l'expression lambda est difficile √† dire si la fonction est une m√©thode bas√©e sur des t√¢ches ou une m√©thode async void, et donc une erreur peut se glisser dans votre base de code, malgr√© la v√©rification la plus approfondie. <br><br><h2>  Conclusion </h2><br>  De nombreux aspects de la programmation asynchrone en C # ont √©t√© influenc√©s par un seul sc√©nario utilisateur - il suffit de convertir le code synchrone d'une application d'interface utilisateur existante en asynchrone: <br><br><ul><li>  L'ex√©cution ult√©rieure de m√©thodes asynchrones est planifi√©e dans le contexte de synchronisation r√©sultant, ce qui peut entra√Æner des blocages. </li><li>  Pour les √©viter, il est n√©cessaire de placer des appels <code>ConfigureAwait(false)</code> partout dans le code de la biblioth√®que asynchrone. </li><li>  attendre la t√¢che;  produit la premi√®re erreur, ce qui complique la cr√©ation d'une exception de traitement pour la programmation parall√®le. </li><li>  Des m√©thodes async void ont √©t√© introduites pour g√©rer les √©v√©nements de l'interface utilisateur, mais elles sont faciles √† ex√©cuter par accident, ce qui entra√Ænera le blocage de l'application si une exception est lev√©e. </li></ul><br>  Le fromage gratuit se produit uniquement dans une sourici√®re.  La facilit√© d'utilisation peut parfois entra√Æner de grandes difficult√©s dans d'autres domaines.  Si vous connaissez l'histoire de la programmation asynchrone en C #, le comportement le plus √©trange ne semble plus si √©trange et la probabilit√© d'erreurs dans le code asynchrone est consid√©rablement r√©duite. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr421245/">https://habr.com/ru/post/fr421245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr421227/index.html">Pr√©sentation des cadres de d√©veloppement mobile multiplateforme</a></li>
<li><a href="../fr421229/index.html">L'histoire de mon mal de t√™te</a></li>
<li><a href="../fr421235/index.html">Lunettes Magic Leap One - lunettes pour 2295 $ avec maintenabilit√© 3 sur 10</a></li>
<li><a href="../fr421241/index.html">La Banque centrale demande le blocage avant proc√®s des sites malveillants</a></li>
<li><a href="../fr421243/index.html">LLTR Partie 2: Algorithme pour d√©terminer la topologie du r√©seau √† partir des statistiques collect√©es</a></li>
<li><a href="../fr421247/index.html">Comment transformer des graphiques en son et pourquoi en avez-vous besoin</a></li>
<li><a href="../fr421249/index.html">Pourquoi les financiers de Wall Street travaillent trop et peuvent-ils √™tre corrig√©s</a></li>
<li><a href="../fr421251/index.html">Syst√®me de sauvegarde</a></li>
<li><a href="../fr421253/index.html">Pourquoi avons-nous besoin de voitures √† queue?</a></li>
<li><a href="../fr421255/index.html">Elon Musk a abandonn√© son projet de transformer Tesla en soci√©t√© priv√©e</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>