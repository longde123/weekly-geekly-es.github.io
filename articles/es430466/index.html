<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙁 🤘🏿 🚾 Mini AI Cup # 3: Escribiendo un Top Bot 🎌 👼🏽 📩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A principios de otoño, se completó la competencia para escribir bots Mini AI Cup # 3 (también conocida como Mad Cars), en la que los participantes tuv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mini AI Cup # 3: Escribiendo un Top Bot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/430466/"><p><img src="https://habrastorage.org/webt/uk/nd/_2/uknd_2qxbi4b0qt85hqcoxgvt7i.png"></p><br><p>  A principios de otoño, se completó la competencia para escribir bots <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Mini AI Cup # 3</a> (también conocida como Mad Cars), en la que los participantes tuvieron que pelear en autos.  Los participantes discutieron mucho sobre lo que funcionará y lo que no funcionará, las ideas se expresaron y probaron desde simples ifs hasta redes neuronales de entrenamiento, pero los chicos ocuparon los primeros lugares con la llamada "simulación".  Intentemos averiguar qué es, comparar soluciones para el 1er, 3er y 4to lugar y discutir otras posibles soluciones. </p><a name="habracut"></a><br><h1 id="diskleymer">  Descargo de responsabilidad </h1><br><p>  El artículo fue escrito en colaboración con <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alexei Dichkovsky (Comandos)</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Vladimir Kiselev (Valdemar)</a> . </p><br><p>  Para aquellos que solo quieren leer sobre las decisiones de los ganadores, les aconsejo que comiencen de inmediato con el ítem "Simulación". </p><br><h1 id="postanovka-zadachi">  Declaración del problema. </h1><br><p> Esta vez, la mecánica del mundo era muy parecida al juego móvil Drive Ahead: a los jugadores se les dio un automóvil con un botón ubicado en él;  la tarea es presionar el botón del enemigo más rápido que él.  Si nadie gana en 600 ticks de juego, la carta comienza a hundirse en una pila de basura, que también puede presionar un botón.  En otras palabras, debes proteger tu botón de los enemigos, el mundo que te rodea y un montón de basura (vitalmente, sí).  A cada jugador se le dieron 5 vidas, el juego pasó de 5 a 9 rondas, mientras que alguien no terminó sus vidas.  Cada ronda se llevó a cabo en un mapa aleatorio y automóviles, lo mismo para ambos participantes.  En total había 6 cartas diferentes y 3 tipos de autos, un total de 18 combinaciones diferentes. </p><br><p> Cada ronda se divide en garrapatas.  Una marca es un movimiento, como en el ajedrez.  La única diferencia es que ambos jugadores van al mismo tiempo.  Hay competiciones donde todos se turnan, o puedes hacer una acción solo una vez cada pocos movimientos y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">seleccionar unidades como marco</a> . <br>  Cada tic en el bot llega a un estado de paz y se le da la oportunidad de realizar 3 acciones: <code></code> , <code></code> , <code></code> .  Estas acciones hacen que el automóvil vaya en una de las direcciones, y si al mismo tiempo no toca las ruedas de la tierra, entonces le dan una pequeña rotación a todo el cuerpo (un poco de física arcade).  Después de que ambos oponentes hayan elegido una acción, se inicia una simulación del mundo del juego, se considera un nuevo estado y se envía a los jugadores.  Si alguien hizo clic en un botón, la ronda finaliza y comienza la siguiente.  Todo es simple, pero hay matices. </p><br><p>  Reglas más completas se pueden encontrar <a href="">aquí</a> .  Y mira los juegos finales <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><h1 id="obschee-opisanie-resheniya">  Descripción general de la solución </h1><br><p>  La mayoría de las competiciones de escritura de bot son muy similares: hay un número finito de ticks (hay aproximadamente 1,500 como máximo para una ronda), hay un número finito de acciones posibles, debes elegir una secuencia de acciones para ser mejor que tus oponentes.  Un poco más tarde volveremos a lo que significa ser mejor, pero por ahora descubriremos cómo lidiar con el problema principal: una gran cantidad de opciones: al principio tenemos un estado inicial, luego cada máquina puede moverse de tres maneras diferentes, que nos da 9 combinaciones diferentes para dos autos, para el movimiento 1500 será 9 ^ 1500 combinaciones diferentes ... Lo cual es un poco más de lo que nos gustaría si planeamos resolverlos durante la existencia del Universo. </p><br><p>  Aquí llegamos a lo que <strong>es la simulación</strong> .  Este no es algún tipo de algoritmo, sino simplemente una recreación de las reglas del juego con precisión suficiente o completa para que sea posible clasificar las soluciones.  Por supuesto, no analizaremos todas las soluciones, sino solo una parte de ellas.  Se utilizará un algoritmo de búsqueda para esto: en el árbol de estado del juego estamos buscando lo mejor para nosotros.  Hay muchos algoritmos (desde minimax hasta MCTS), cada uno tiene sus propios matices.  Es mejor familiarizarse con las decisiones que escribieron los participantes en competencias pasadas de IA.  Esto proporcionará una comprensión básica de en qué condiciones funcionan los algoritmos y en qué no.  Hay muchos enlaces para esto en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio especial</a> . </p><br><p>  Al elegir un algoritmo, debe considerar: </p><br><ul><li>  límite de tiempo para 1 marca (aquí calculé mal mucho este año, pero pude permanecer en el 3er lugar); </li><li>  Número de jugadores.  Por ejemplo, si hay tres jugadores, será difícil usar minimax; </li><li>  precisión de simulación, como  esto puede permitir la reutilización de cálculos antiguos; </li><li>  "Ramificación" del árbol de estado (es posible calcular todos los estados posibles al menos 10 movimientos adelante); </li><li>  sentido común: no comience a escribir MCTS si la competencia dura 4 horas. </li></ul><br><p>  En esta competencia, 1 tick dio alrededor de 10-13 ms (2 minutos para todo el juego).  Durante este tiempo, el bot tuvo que leer los datos, tomar una decisión y enviar un comando para moverse.  Esto fue suficiente para estimular unos 500-1000 movimientos.  Iterar sobre todos los estados.  El algoritmo de búsqueda más simple puede parecer una comparación de tres opciones de movimiento: "50 ticks van a la izquierda", "50 ticks van a la derecha", "50 ticks clic en detener".  Y no importa cuán simple suene, no está muy lejos de la decisión del ganador. </p><br><p>  Porque  solo contamos 50 movimientos por delante, que en la mayoría de los casos no cuentan hasta el final del juego, entonces necesitamos <strong>una función de evaluación</strong> que diga cuán bueno y malo es el estado del mundo para nosotros.  Muy a menudo, se basa en la heurística y en la comprensión de lo que es importante para la victoria.  Por ejemplo, en la competencia rusa de la Copa AI de 2014 hubo carreras, pero podría ganar si llegara el último, si obtiene más puntos de bonificación.  Por lo tanto, la función de calificación debería estimular la recolección de puntos al mismo tiempo que el movimiento rápido a lo largo de la carretera.  La puntuación solo se puede calcular para el último estado de la simulación (después de 50 ticks) o como la suma de las estimaciones de los estados intermedios.  A menudo, la estimación "se desvanece" a tiempo para que los estados que ocurren antes estén más influenciados.  Porque  no podemos predecir con seguridad al enemigo, entonces es menos probable que ocurran opciones futuras, no confiaremos en gran medida en ellas.  Además, esta técnica hace que el bot sea más rápido para completar sus tareas y no posponer todo para más adelante.  Pero vale la pena señalar que el bot tomará menos riesgos en aras de los beneficios posteriores. </p><br><p>  Como vamos a predecir el estado del mundo en respuesta a nuestras acciones, necesitamos modelar de alguna manera el comportamiento de los enemigos.  No hay nada complicado y hay un par de opciones comunes: </p><br><ul><li>  <strong>Trozo o heurístico</strong> <br>  Se escribe una lógica simple de comportamiento donde el enemigo simplemente no hace nada, o elige acciones basadas en heurísticas simples (por ejemplo, puede usar sus primeras versiones de la estrategia o simplemente repetir el movimiento anterior del oponente). </li><li>  <strong>Usa el mismo algoritmo que tú mismo</strong> <br>  Primero intentamos encontrar las mejores acciones para el enemigo (contra nuestro mejor conjunto de acciones desde el último movimiento, o contra un trozo), y luego buscamos la mejor acción para nosotros mismos, utilizando el comportamiento que encontró el enemigo.  Aquí el bot intentará resistir a los enemigos difíciles.  Esta lógica no funciona bien al comienzo de la competencia, porque  muchos bots siguen siendo muy débiles, y tu decisión será demasiado cautelosa con ellos. </li><li>  <strong>Otros</strong> <br>  El mismo minimax itera sobre todos los movimientos de los jugadores al mismo tiempo, y él simplemente no necesitará heurística. </li></ul><br><p>  Si implementa todos los pasos anteriores, lo más probable es que obtenga un bot muy bueno, especialmente si puede elegir una buena función de calificación.  Pero, mirando a través de sus peleas, puedes ver que en ciertas situaciones se comporta de manera extraña.  Corregir la función de evaluación para estas situaciones puede ser difícil o existe un gran riesgo de romper otra lógica.  Aquí muletas y si vienen al rescate.  Sí, los últimos días de la competencia a menudo se reducen a escribir muletas y ifs para corregir los defectos en cualquier condición específica.  Personalmente, realmente no me gusta esta parte, pero he notado más de una vez que son las muletas en la final las que pueden afectar la disposición de los lugares entre los diez primeros, lo que significa que un no escrito puede costarle un premio (mi corazón duele cuando escribo estas palabras, yo También amo hermosos algoritmos y soluciones). </p><br><p>  <strong>P: ¿Es posible prescindir de la simulación?</strong> <br>  <em>R: Sí, puede usar soluciones en heurística (árboles de decisión, un montón de ifs, etc.).</em>  <em>Hay un buen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> con arquitecturas de IA sobre heurística.</em> </p><br><p>  <strong>P: ¿Cuánto mejor es el uso de la simulación que los enfoques heurísticos?</strong> <br>  <em>A: Todo depende de la tarea.</em>  <em>Por ejemplo, aquí algunas combinaciones de cartas y autos podrían codificarse con ifs y siempre ganar (o robar).</em>  <em>Sin embargo, a menudo la simulación encuentra soluciones que son difíciles de pensar por sí mismas o difíciles de implementar heurísticas.</em>  <em>En este concurso, cuando volteas otro auto, las soluciones en las simulaciones ponen su rueda sobre la rueda del enemigo, que apaga la bandera "en el aire", lo que significa que el enemigo no puede aplicar la rotación del cuerpo y girar sobre las ruedas.</em>  <em>Pero la decisión no pensó en el significado de esto, solo encontró opciones donde el enemigo caería más rápido en el techo y presionaría su botón.</em> </p><br><p><img src="https://habrastorage.org/webt/in/i4/wk/ini4wk8qqxl7dfzdzlcegwpmyyq.gif"></p><br><p>  <strong>P: ¿Redes neuronales y RL?</strong> <br>  <em>R: No importa cuán popular sea esto, en las competiciones de bot tales soluciones rara vez funcionan bien.</em>  <em>Aunque las redes neuronales no necesitan simulación, porque</em>  <em>simplemente pueden emitir una acción basada en los parámetros de entrada del estado actual, aún necesitan aprender algo, y para esto a menudo tienen que escribir un simulador para manejar miles de juegos localmente.</em>  <em>Personalmente, creo que tienen potencial.</em>  <em>Quizás puedan resolver parte del problema o utilizarlo en condiciones de tiempo de respuesta muy limitado.</em> </p><br><p>  <strong>Nota</strong> <br>  <em>Con respecto al número finito de acciones posibles, vale la pena aclarar que a veces se permite ajustar "sin problemas" algún parámetro.</em>  <em>Por ejemplo, no solo conduce hacia adelante, sino con cierto porcentaje de potencia.</em>  <em>En este caso, la "finitud" del número de conclusiones puede lograrse fácilmente simplemente usando varios valores, por ejemplo, 0%, 25%, 50%, 75% y 100%.</em>  <em>Muy a menudo, solo dos son suficientes: "completamente encendido" y "completamente apagado".</em> </p><br><h1 id="simulyaciya">  Simulación </h1><br><p>  En esta competencia, utilizamos el motor de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">física de ardilla</a> lista para usar.  Las expectativas de los organizadores eran que él es viejo, probado en el tiempo y tiene muchos envoltorios para que todos puedan incluirlo en su decisión ... </p><br><p>  En la dura realidad, el motor produce diferentes valores cada vez, lo que dificulta el reinicio para calcular las opciones de movimientos.  El problema se resolvió "de frente": se escribió un asignador de memoria en C y se copió completamente un fragmento de memoria con el estado del mundo.  Tal asignador puso fin a la capacidad de escribir soluciones en lenguajes distintos de C ++ (de hecho, era posible, pero muy laborioso y un asignador aún tendría que escribirse en C).  Además, la precisión de la predicción estuvo influenciada por el orden de agregar elementos al mundo del juego, que requería una copia muy precisa del código que los organizadores utilizaron para calcular los juegos.  Pero él ya estaba en Python.  El último aspecto destacado en el ataúd de otros lenguajes de programación fue que el motor es antiguo y contiene muchas optimizaciones que no se pueden recrear con precisión durante la competencia para obtener su propia versión recortada de la simulación física. </p><br><p>  Como resultado, el motor, que se suponía debía dar a todos los participantes las mismas condiciones para simular movimientos, se convirtió en el obstáculo más difícil para esto.  Más de 10 personas pudieron superarlo. Los primeros 7 lugares en la tabla de clasificación fueron ocupados exclusivamente por los muchachos que hicieron una simulación precisa, lo que puede servir como evidencia de su importancia en tales competiciones. </p><br><p>  Con la excepción de un par de participantes que pudieron ingresar al interior de la ardilla listada y optimizar la copia de su estado, el resto tuvo una simulación de aproximadamente el mismo rendimiento (lo que hizo que la competencia fuera un poco más interesante, porque sabes que la lucha es por el algoritmo de decisión, no "quién cuenta más los movimientos"). </p><br><h1 id="algoritm-poiska-i-predskazanie-protivnika">  Algoritmo para buscar y predecir un adversario. </h1><br><p>  A partir de este punto, comienza una descripción separada de las soluciones.  Los algoritmos se describirán en nombre de su autor. </p><br><h3 id="vladimir-kiselev-valdemar-4-mesto">  Vladimir Kiselev (Valdemar) 4to lugar </h3><br><p>  Se utilizó una búsqueda aleatoria (Monte Carlo) para buscar el espacio de la solución.  El algoritmo es el siguiente: </p><br><ol><li>  Inicializamos el genoma, una secuencia de acciones (izquierda, derecha, parada) para 60 ticks, datos aleatorios. </li><li>  Toma el mejor genoma encontrado </li><li>  Cambiar aleatoriamente una de las acciones </li><li>  Usando la función de evaluación obtenemos un número, un indicador de cuán bueno es el nuevo genoma </li><li>  Si obtiene una mejor solución, actualice la mejor solución. </li><li>  Repita nuevamente desde el paso 2 </li></ol><br><p>  Mi simulador produjo ~ 100k simulaciones del mundo en 1 segundo, considerando que hay un promedio de ~ 12ms por tic, obtenemos 1200 acciones por tic.  Es decir, en 1 tick logramos pasar por el ciclo completo unas 20 veces. </p><br><p>  Para encontrar la solución óptima, este número de iteraciones claramente no fue suficiente.  Por lo tanto, la idea con acciones de "estiramiento" se realizó: en lugar del genoma de 60 movimientos, operaremos con una cadena de 12 movimientos "estirados": creemos que cada acción dura 5 tics seguidos. <br>  Además: al mejorar la calidad de las mutaciones al reducir la longitud del genoma, la simulación también se puede ejecutar cada 5 tics y verificar 100 genomas en lugar de 20 (para evitar caídas en el límite de tiempo, finalmente me detuve en 70). <br>  Menos: las acciones de estiramiento pueden conducir a soluciones no óptimas (por ejemplo, balancearse sobre el parachoques, en lugar de un estante estable) </p><br><p>  Cabe señalar las técnicas que han mejorado significativamente la calidad del algoritmo: </p><br><ul><li>  Llevamos a cabo la inicialización aleatoria solo en el primer tic, el resto del tiempo reutilizamos la mejor solución encontrada con un cambio de 1 movimiento (la acción en el segundo tic se desplaza al primero, etc., se agrega una acción aleatoria al final).  Esto mejora en gran medida la calidad de la búsqueda, ya que de lo contrario el algoritmo "olvida" lo que iba a hacer en el último tic y produce sacudidas sin sentido en diferentes direcciones. </li><li>  Al comienzo del curso, realizamos cambios más intensivos (cambiamos el genoma 2 o 3 veces en lugar de uno) con la esperanza de romper el máximo local (similitud de temperatura en el método de simulación de recocido). <br>  La intensidad se seleccionó manualmente: las primeras 30 iteraciones hacen 3 mutaciones, las siguientes 10 por 2, luego por 1. </li><li>  Muy importante es la predicción de las acciones enemigas.  En detrimento del tiempo para buscar nuestra propia solución, lanzamos una búsqueda aleatoria desde el lado del oponente, a 20 iteraciones, luego 50 para nosotros, utilizando información sobre los movimientos óptimos del oponente. <br>  La mejor decisión del oponente también se reutiliza en el siguiente movimiento con un desplazamiento.  Al mismo tiempo, cuando busco una solución para el enemigo, el genoma del último movimiento se usa como mis acciones previstas. </li></ul><br><p>  Durante la competencia, utilizó activamente herramientas para el desarrollo local, lo que hizo posible encontrar rápidamente errores y centrarse en los puntos débiles de la estrategia: </p><br><ul><li>  arena local: lanzamiento de muchos partidos contra la versión anterior; </li><li>  visualizador para el comportamiento de depuración; </li><li>  Una secuencia de comandos para recopilar estadísticas sobre coincidencias del sitio: le permite comprender en qué mapas y máquinas se produce la derrota con mayor frecuencia. </li></ul><br><blockquote>  <strong>mortido</strong> <br>  Contar cada 5 ticks parece arriesgado, especialmente si el enemigo se está alejando de las opciones que predice.  Por otro lado, en este mundo de juego por 5 ticks, no pasó mucho. <br>  Además, en mi decisión, sin embargo, agregué combinaciones aleatorias en cada tic, pero definitivamente no diré cómo esto afectó la decisión. <br><br>  <strong>Comandos:</strong> <br>  Cambiar un par de acciones con tantas simulaciones no parece muy significativo, porque ocurren muy pocos cambios en una sola acción.  Pero cuando extiendes una acción a 5 tics de significado, parece volverse más. <br>  Tampoco me gusta la idea en sí misma: tomamos el mejor conjunto e intentamos editarlo en algún lugar al principio.  Parece ilógico que cambiar las primeras marcas dejará las siguientes al menos relativamente adecuadas. </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto">  Alexander Kiselev (mortido) 3er lugar </h3><br><p>  Armado con artículos de ganadores de otras competiciones, decidí usar el algoritmo genético.  Resultó, sin embargo, algo similar a una búsqueda aleatoria o incluso una imitación de recocido, pero más sobre eso más adelante. </p><br><p>  Codificamos la solución con una matriz de 40 números, donde -1, 0 y 1 corresponden a los movimientos <code></code> , <code></code> y <code></code> . </p><br><p>  Al comienzo de cada ronda, calculé la cantidad de tiempo que ya había gastado en todo el juego, conté un nuevo límite de tiempo basado en cuántas rondas más quedarían, y cada ronda supuse que eran 1200 ticks.  T.O.  Inicialmente, traté de pasar no más de 11 ms por turno, pero podía "caminar" un poco al final si las rondas anteriores eran más rápidas que 1200 ticks. </p><br><blockquote>  <strong>Valdemar:</strong> <br>  Curiosamente, este chip empeoró el juego para mí.  Resultó que siempre es mejor gastar 20-30 ms que 11 primero y 60 al final </blockquote><p>  Un tercio de este tiempo estaba buscando el mejor movimiento del enemigo, el resto fue para calcular mi propia decisión.  Al buscar un movimiento para el enemigo, mi comportamiento fue modelado como el mejor del último movimiento, cambiado por 1 tic.  Es decir  como si siguiera actuando de acuerdo con el plan elaborado en el último tic, y él está tratando de resistirse a mí. </p><br><p>  La búsqueda de la solución en sí fue la misma tanto para él como para el oponente: </p><br><ol><li>  Tomamos la decisión del último movimiento y lo cambiamos por 1 movimiento (que ya hemos hecho) </li><li>  Probamos a la población de soluciones aleatorias hasta que lo llenemos todo </li><li>  Simulamos todas las decisiones y establecemos la aptitud utilizando la función de evaluación.  Recordamos lo mejor. </li><li>  Si bien hay tiempo para los cálculos <br><ol><li>  Sugerencia, siempre agregue 1 mutación de la mejor solución actual a la población, recuérdelo si es mejor </li><li>  Mientras haya un lugar en la nueva población y no se haya excedido el tiempo para los cálculos (puede ir al piso de una población poblada) <br><ol><li>  Tomamos dos individuos diferentes y nos vamos con la mejor forma física: mamá </li><li>  Tomamos dos individuos diferentes y nos vamos con la mejor forma física: papá (no debe coincidir con mamá) </li><li>  Cruzarlos </li><li>  Mutar si <code>RND &lt;  </code> </li><li>  Simulamos una solución y la recordamos, si es la mejor. </li></ol></li></ol></li></ol><br><p>  Como resultado, devolveremos la secuencia de acciones que se considera óptima.  El primer movimiento en él se envía como una acción bot.  Desafortunadamente, hubo un serio inconveniente en mi plan, ya que  el número de simulaciones que se pueden hacer en un tic era muy pequeño (incluso debido a la larga función de evaluación), luego en el servidor de competencia se realizaron 4 puntos solo 1 vez, y para el enemigo no se realizó en absoluto.  Esto hizo que el algoritmo se pareciera más a una búsqueda aleatoria o un recocido simulado (ya que logramos mutar la solución 1 vez desde el último movimiento).  Ya era demasiado tarde para cambiar algo, y logramos mantener el 3er lugar. </p><br><p>  Es importante implementar los algoritmos para cruzar, mutar y generar soluciones aleatorias iniciales, ya que  depende de qué decisiones se probarán, y una decisión aleatoria completa no es tan buena como podría parecer a primera vista (funcionará, pero se necesitarán muchas más opciones). </p><br><p>  En la versión final, se generaron decisiones aleatorias en segmentos, que excluyeron las soluciones "espasmódicas" en un solo lugar: </p><br><ol><li>  Equipo aleatorio seleccionado </li><li>  Para toda la longitud de la solución (40 movimientos) <br><ol><li>  Escribimos el comando actual en la celda </li><li>  Con una probabilidad del 10% cambiamos el equipo actual a un azar </li></ol></li></ol><br><p>  Según una tecnología similar, también se produjo una mutación: un segmento aleatorio de la solución se reemplazó con un comando aleatorio.  El cruce se llevó a cabo eligiendo el punto en el que se tomó la decisión de 1 padre y después del 2 °. </p><br><p>  Me gustó que usáramos todo el tiempo disponible para encontrar la mejor solución.  No es un gran problema si la solución no es la mejor, podemos mejorarla en el siguiente paso, porque  la optimización resulta ser "borrosa" a tiempo.     ,        .  ,      -  ,    .           ,           </p><br><blockquote> <strong>Valdemar:</strong> <br>   1     , ,             . <br><br> <strong>Commandos:</strong> <br>    —   -        . <br>         —    ,     .         ,     …      ,        .    "    ”.         -. </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto">   (Commandos) 1  </h3><br><p>        (  ),   <strong>n</strong>  <strong>m</strong>  .    3^2=9 .       <strong>m</strong> + <strong>n</strong>      40 . </p><br><p>  : </p><br><pre> <code class="plaintext hljs">|----------- n  -----------|---------- m  --------| |   ...   |   ...   |</code> </pre> <br><p>          :     ,  ,  .      (   ). </p><br><p>       <strong>n</strong>  <strong>m</strong> ,          .       ,     . </p><br><p>        : </p><br><ol><li>     ,       (       ,   ): <br><ul><li>   ,     ,   ,     . </li><li>       ,      ,   .           .                .            ,       ,      ,     . </li><li>         .   ;        (           ). </li></ul></li><li>       <strong>n</strong>  <strong>m</strong>  .      ,    .1,      ,          .     -  (    )  ,        —        ,      ; </li><li>             .   ,     —      .    ,       (       ). </li></ol><br><blockquote> <strong>Valdemar:</strong> <br> ,       2    .    .         ,    . <br><br> <strong>mortido:</strong> <br> !   ,       .    .  ,   2    ,   40-60       .  ,        3   . <br> n + m == const ? </blockquote><p>   .  <code>n + m != const</code> ,              .      ,  .  -   . </p><br><h1 id="funkciya-ocenki">   </h1><br><h3 id="vladimir-kiselev-valdemar-4-mesto-1">   (Valdemar) 4  </h3><br><p>   ,       . ,    (  , ,   ..)    [0..1]. <br>           .     :   ,        . <br>            ,    ,      :      ,          . </p><br><p> ,   : </p><br><ul><li>    —    70  180  (  :         ). <br>       ,       . </li><li>       0..500 </li><li>   —  [2pi, pi/4]   [0, 1] </li><li>    —    ,       (    ),   (  ,      ,        ) </li><li>   — ,      ,     ,           . <br>      ,  ,       . </li><li>  —     .          . </li><li>     Y   —    . </li><li>           </li></ul><br><p>  ,       2           , . </p><br><p>           . </p><br><p>         : </p><br><ul><li>  “”      ,       </li><li>  “  ”        ,   ,        . </li></ul><br><blockquote> <strong>mortido:</strong> <br>    , ..      ,     . <br><br> <strong>Commandos:</strong> <br>      ,      .    -  </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto-1">   (mortido) 3  </h3><br><p>        ,      chipmunk.              .     ,      ,     ,   ,   .        . </p><br><p>                    3   <del>  </del>   . </p><br><p>   ,        ( ,     ,   ): </p><br><ul><li>   .          ,  ,        (       ,     ); </li><li>    ,    —       ,     ;      ,     1  ; </li><li>   ; </li><li>      (    ,  ); </li><li>       (   “+”,    “-”); <br> -     (   “+”,    “-”);   ,     ,      ,          ; <br>   30    ,       ,      (   ); </li><li>  ,         . </li></ul><br><p>  ,        ,         (,            ,     ) </p><br><blockquote> <strong>Valdemar:</strong> <br>         .    ,     “  ,     ,    ”     ,      (     ..)     . </blockquote><p>  ,    ,        .    . </p><br><blockquote> <strong>Commandos:</strong> <br>   ,   ,   “”…      ?              ,   “” . </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto-1">   (Commandos) 1  </h3><br><p>      <code>SquaredWheelsBuggy</code> ,      ..  ,       .     Buggy   ,          ,          (         /). <br> : </p><br><ol><li>   ; </li><li>     ;         — ,     ,   1  0; ..        ; </li><li>     .        ;          10      (            ); </li><li>             (       ,    ); </li><li>     (,          ); </li><li>       — -    ,   ; </li><li> /     ;       ,       —   ;             . </li></ol><br><p>  1-5      ,   .   2     “  ”. </p><br><blockquote> <strong>Valdemar:</strong> <br>     ,        .       ,      . <br><br> <strong>mortido:</strong> <br>      ,     10 . </blockquote><br><h1 id="kostyli-i-ify">   IF' </h1><br><h3 id="vladimir-kiselev-valdemar-4-mesto-2">   (Valdemar) 4  </h3><br><p>      ,            if'.         3    ,         ,           . ,        ,         -. <br>  :      ,    “”   —      ,   - ,           (  ,   ) —   . </p><br><p>     : </p><br><ul><li>     .      ,        . </li><li>      —     ,                  . </li><li>   .      “  ”      . <br>      ,        ,         . <br>                ,      ,      . </li></ul><br><p>        ,    :     .   ,       ,   if'     . </p><br><blockquote> <strong>mortido:</strong> <br>     ,       .            . <br><br> <strong>Commandos:</strong> <br>   if'.   ,    ,    …          ,     ,     . </blockquote><br><h3 id="aleksandr-kiselev-mortido-3-mesto-2">   (mortido) 3  </h3><br><p>              - . </p><br><p>     3  .    .         .  “”,                  .        ,      ,    . </p><br><p>          ,     “”   .       .     ,        , ,      -  .        .     ,       , ..    . </p><br><p>    ,      ,  ,     ,           ,       .     …         .    -       —  ,     (      ,     ). </p><br><blockquote> <strong>Valdemar:</strong> <br>    ,     .          .        “” ,       if'.  ,           —             . </blockquote><p>          ,       +      . ,       . </p><br><blockquote> <strong>Commandos:</strong> <br>   …  ,  -   —   ,      ,   .        ,     ,                . </blockquote><br><h3 id="aleksey-dichkovskiy-commandos-1-mesto-2">   (Commandos) 1  </h3><br><p>         .      (,     ,    ).         (  )   /. </p><br><p>    pill carcass map        ,       ,             (         ).      island map,      ,     . </p><br><p>             island hole  buggy.    /      ,     ,      (  ).       —    .  ,          ,    .   SquaredWheelBuggy           .    ,      ,      ,    .  ,   …    ,      ,     . </p><br><p>    (Pill map, Bus)                 ,        (     /  100% ). </p><br><p>         pill hubble map.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> (    ),     .       . </p><br><p>               —         ,   ... </p><br><p>       ,     .                ,    .          (     ). </p><br><blockquote> <strong>Valdemar:</strong> <br>   ,          —        .   ,     . <br><br> <strong>mortido:</strong> <br>     ,     “”  . </blockquote><br><h1 id="emocii">  </h1><br><blockquote> <strong>Valdemar:</strong> <br>     .           ,      .    (   )      . <br>                  .  “”,      ,          , ,  :) <br>  ,  mailru  ,     . <br><br> <strong>mortido:</strong> <br>        :               ,          …   ,      ,       (      ).     ,     3   ,    ,   …      . <br><br> <strong>Commandos:</strong> <br> -     ,     . , ,   ,  .    …       .         —     ,      . <br>     —       ++.       .       ,       .     1  <del>       </del>     -. </blockquote><br><h1 id="itak">  </h1><br><p> ,           .    ,              .      ,      ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> . </p><br><p>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  Mail.Ru Group   . </p><br><h1 id="bonus">  Bono </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Valdemar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mortido</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   </a> </p><br><div class="spoiler"> <b class="spoiler_title"> ,    </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/bz/b8/cd/bzb8cdwabur3c-7qbcwzmjokx0o.gif"></p><br><p><img src="https://habrastorage.org/webt/tw/nw/cw/twnwcwndcdjglzq2hhuh0ulxohc.gif"></p><br><p><img src="https://habrastorage.org/webt/ib/jh/vq/ibjhvquma8mwq6meckt2qzteicy.gif"></p><br><p><img src="https://habrastorage.org/webt/4e/eg/c9/4eegc9jvtcg-0namubh_9cqx2ok.gif"></p><br><p><img src="https://habrastorage.org/webt/4f/uw/w8/4fuww8dcs4-fx4nuar8bcur0lpm.gif"></p><br><p><img src="https://habrastorage.org/webt/fz/q3/6u/fzq36ufo15jgjwbd9ev_cnc6mso.gif"></p><br><p><img src="https://habrastorage.org/webt/og/55/dt/og55dtgv4ohguhiucwhn0qwqiak.gif"></p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430466/">https://habr.com/ru/post/es430466/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430454/index.html">Estoy rodeado de idiotas o de cómo trabajar en equipo.</a></li>
<li><a href="../es430456/index.html">Legal Project Management Books por PMI</a></li>
<li><a href="../es430458/index.html">Superconductor de grafeno multicapa: investigación de zonas planas</a></li>
<li><a href="../es430460/index.html">Pingüino de Troya: haciendo un virus para Linux</a></li>
<li><a href="../es430462/index.html">En Rusia, apareció un proyecto de ley sobre el suministro de datos de usuarios de redes sociales a un círculo ilimitado de personas. Redes sociales contra</a></li>
<li><a href="../es430468/index.html">Sensibilizar a los ciudadanos.</a></li>
<li><a href="../es430470/index.html">¿Por qué mantener el contexto en la cuenta del cliente? Honestamente y de manera rentable</a></li>
<li><a href="../es430472/index.html">Red DECT sin costura de bricolaje</a></li>
<li><a href="../es430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../es430476/index.html">NCBI Genome Workbench: Investigación en peligro de extinción</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>