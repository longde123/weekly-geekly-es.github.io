<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üë®üèø‚Äçüîß üê´ El futuro de WebAssembly como un "√°rbol de habilidades" ‚ôÇÔ∏è üîö üôèüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algunas personas de alguna manera malinterpretaron WebAssembly. Hay quienes creen que, dado que los navegadores ya admiten WebAssembly (desde 2017), e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El futuro de WebAssembly como un "√°rbol de habilidades"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/infopulse/blog/428347/">  Algunas personas de alguna manera malinterpretaron WebAssembly.  Hay quienes creen que, dado que los navegadores ya admiten WebAssembly (desde 2017), entonces todo est√° listo.  A√∫n no est√° cerca, solo el MVP (producto m√≠nimamente viable) est√° listo.  Puedo adivinar de d√≥nde proviene la ra√≠z de este error: despu√©s del lanzamiento de MVP, sus desarrolladores prometieron mantener la compatibilidad con versiones anteriores en el nivel de "cualquier c√≥digo escrito ahora funcionar√° en el futuro".  Pero esto no significa que el desarrollo de WebAssembly se haya completado, ¬°en absoluto!  Muchas caracter√≠sticas se est√°n desarrollando en este momento y est√°n planificadas para su desarrollo en un futuro pr√≥ximo.  Y cuando se implementen, todo cambiar√° mucho. <br><br>  Puedes intentar imaginar todas estas caracter√≠sticas en forma de √°rbol de habilidades en alg√∫n juego.  Tenemos un par de "b√°sicas" (caracter√≠sticas ya implementadas) y un √°rbol completo con muchas ramas y hojas que se abrir√°n con el tiempo, d√°ndonos m√°s y m√°s poder. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c6f/7a8/30f/c6f7a830f86adac22fb26212840d79e6.png" alt="imagen"></a> <br>  Veamos lo que ya tenemos y lo que todav√≠a tenemos que descubrir. <br>  ( <b>Debajo del corte muchas fotos, tr√°fico</b> ) <br><a name="habracut"></a><br><h2>  Producto m√≠nimo viable (MVP) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/fc2/578/e24fc257831cdd6a1e1ff997eb6e31a4.png" alt="imagen"><br>  Al principio de la historia de WebAssembly se encuentra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Emscripten</a> , que hizo posible compilar c√≥digo C ++ en c√≥digo JavaScript.  Esto nos permiti√≥ transferir una gran cantidad de bibliotecas C ++ al mundo de la web, sin lo cual ser√≠a imposible ejecutar c√≥digo de nivel superior.  El c√≥digo JS generado distaba mucho de ser ideal y funcionaba lentamente (en comparaci√≥n con su versi√≥n nativa).  Pero a√∫n as√≠, los ingenieros de Mozilla encontraron un par de formas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">para hacerlo</a> m√°s r√°pido.  El principal fue la asignaci√≥n de un subconjunto del lenguaje que se pod√≠a realizar a velocidades comparables a las velocidades de ejecuci√≥n del c√≥digo nativo.  Este subconjunto se llam√≥ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">asm.js.</a> <br><br>  Los desarrolladores de otros navegadores notaron y apreciaron la velocidad de asm.js, todos los principales navegadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">obtuvieron</a> su soporte.  Pero esto no termin√≥ la historia.  Eso fue solo el comienzo.  Todav√≠a hab√≠a espacio para trabajar m√°s r√°pido.  Pero ya fueron m√°s all√° de Javascript.  Result√≥ que el c√≥digo nativo (por ejemplo, en C ++) ten√≠a que compilarse no en Javascript, sino en otra cosa.  En algo nuevo, creado espec√≠ficamente como una alternativa r√°pida a JS.  Y as√≠ surgi√≥ WebAssembly. <br><br>  ¬øQu√© se incluye en la primera versi√≥n de WebAssembly?  ¬øQu√© fue suficiente para obtener el orgulloso t√≠tulo de "producto m√≠nimo viable"? <br><br><h3>  Habilidad: plataforma compiladora objetivo </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/363/557/8a43635574df19b6115ac43061f809ab.png" alt="imagen"><br><br>  Los programadores que trabajaron en WebAssembly entendieron que su tarea no era admitir solo C o C ++.  La tarea era dar la oportunidad de compilar c√≥digo en cualquier idioma en WebAssembly.  Se supon√≠a que era un "ensamblador", que deber√≠a ejecutarse en el navegador, tal como se ejecuta el c√≥digo de m√°quina de la aplicaci√≥n de escritorio, por ejemplo, en la plataforma x86.  Pero este nuevo lenguaje no deber√≠a depender de ninguna plataforma espec√≠fica, su objetivo deber√≠a ser una plataforma abstracta de un nivel superior, cuya implementaci√≥n espec√≠fica ya depender√≠a del conjunto de instrucciones utilizadas en este hardware. <br><br><h3>  Habilidad: ejecuci√≥n r√°pida de c√≥digo </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/1de/2ef/f15/1de2eff156f50e2791dee8b2fbf6c794.png" alt="imagen"><br><br>  Todo ten√≠a que funcionar r√°pido.  De lo contrario, ¬øpor qu√© molestarse con toda esta historia?  Al final, el usuario deber√≠a poder ejecutar aplicaciones realmente "pesadas", poder jugar los mejores juegos en el navegador, etc. <br><br><h3>  Habilidad: Compacidad </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/38c/906/a9f38c9069761e4e6c5619641b159399.png" alt="imagen"><br><br>  Es importante no solo la velocidad de ejecuci√≥n del c√≥digo, sino tambi√©n la velocidad de su carga.  Los usuarios est√°n acostumbrados a las aplicaciones de escritorio que se inician muy r√°pidamente (porque se instalan localmente y tienen todos los recursos necesarios a la mano).  Las aplicaciones web tambi√©n se ejecutan relativamente r√°pido porque no cargan tantos recursos a la vez.  Y esto plantea un nuevo desaf√≠o para nosotros: si queremos crear un nuevo tipo de aplicaci√≥n web con una base de c√≥digo tan grande como la cl√°sica de escritorio, pero descargable desde Internet, el c√≥digo debe ser lo m√°s compacto posible. <br><br><h3>  Habilidad: acceso a memoria </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/350/e55/239/350e55239fe24dc00799045dce0bb36e.png" alt="imagen"><br><br>  Nuestras nuevas aplicaciones tambi√©n necesitar√°n trabajar con la memoria de una manera ligeramente diferente que el c√≥digo JavaScript.  Necesita acceso directo a bloques de memoria.  Esto se debe a la peculiaridad de los lenguajes C y C ++, en los que hay punteros.  Un puntero es, m√°s o menos, una variable que contiene una direcci√≥n en la memoria.  Una aplicaci√≥n puede leer datos en esta direcci√≥n, cambiarlos e incluso usar la aritm√©tica en un puntero para "caminar" en la memoria hacia adelante desde la direcci√≥n especificada.  Una gran cantidad de c√≥digo C / C ++ usa punteros para aumentar la eficiencia de su trabajo, crear una plataforma objetivo para dicho c√≥digo es imposible sin el apoyo de punteros. <br><br>  Pero no podemos permitir que ning√∫n fragmento de c√≥digo descargado de Internet tenga acceso directo a la memoria de nuestro proceso; esto es demasiado peligroso.  Tendremos que crear un entorno que, por un lado, permita que el c√≥digo nativo compilado en WebAssembly crea que tiene acceso directo a la memoria, pero por otro lado, limitar√° estrictamente el √°rea en la que est√° permitido manipular datos. <br><br>  Para esto, WebAssembly utiliza el "modelo de memoria lineal".  Esto se implementa utilizando TypedArrays, algo as√≠ como una matriz en JavaScript, pero que contiene solo un conjunto secuencial de bytes en la memoria.  Cuando desea poner algo en √©l, utiliza el acceso al elemento por √≠ndice (que puede ser una direcci√≥n en la memoria).  Por lo tanto, esta matriz "pretende" ser un bloque de memoria para el c√≥digo C ++. <br><br><h3>  Nuevo logro! </h3><br>  Entonces, con todo lo anterior, las personas finalmente podr√°n ejecutar la aplicaci√≥n de escritorio en un navegador con aproximadamente el mismo rendimiento que si fuera nativo.  Se trata de este conjunto de caracter√≠sticas y se llam√≥ el "producto m√≠nimo viable" (MVP). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a9/c6e/ac9/3a9c6eac96976ad0cd5c5893b47e9ccc.png" alt="imagen"><br><br>  En este punto, algunas aplicaciones ya podr√≠an estar compiladas bajo WebAssembly y ganar dinero en el navegador.  Pero todav√≠a quedaba un largo camino por recorrer. <br><br><h2>  Aplicaciones de escritorio pesadas </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/393/bfe/b91/393bfeb91e6a174d57e9a8896fd2f912.png" alt="imagen"><br><br>  El siguiente paso importante deber√≠a ser la capacidad de lanzar aplicaciones de escritorio realmente grandes.  ¬øTe imaginas la versi√≥n completa de Photoshop ejecut√°ndose en un navegador?  Y no lo instal√≥, simplemente abri√≥ el enlace, y ahora tiene toda la potencia de este producto, a la velocidad nativa, la √∫ltima versi√≥n con todas las actualizaciones y correcciones, en cualquier dispositivo. <br><br>  Y no estamos tan lejos de esto, ya est√°n comenzando a aparecer ejemplos.  Por ejemplo, AutoCAD.  Y tambi√©n Adobe Lightroom.  Pero seamos honestos: no todo est√° listo en la implementaci√≥n actual de WebAssembly para lanzar aplicaciones verdaderamente grandes.  Los cuellos de botella se investigan y corrigen aqu√≠ mismo en este momento cuando lees este art√≠culo. <br><br><h3>  Habilidad: multihilo </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c2/779/cac/7c2779cac9e06ed2a7ea21469efcb54e.png" alt="imagen"><br><br>  Obviamente, necesitamos multihilo.  Las computadoras modernas tienen muchos n√∫cleos.  Necesitamos poder usarlos. <br><br><h3>  Habilidad: SIMD </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c98/11c/2ecc9811c01888acb643fb14fe70c7b3.png" alt="imagen"><br><br>  Adem√°s del subprocesamiento m√∫ltiple, existe otra tecnolog√≠a que permite una implementaci√≥n m√°s eficiente del procesamiento de datos en paralelo.  Esto es SIMD: procesamiento por una sola instrucci√≥n de varios bloques de datos a la vez.  Un aspecto importante necesario para WebAssembly realmente r√°pido. <br><br><h3>  Habilidad: direccionamiento de 64 bits </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/e7e/26d/0fde7e26d23106765832788445d65f88.png" alt="imagen"><br><br>  Otra caracter√≠stica importante de la arquitectura de hardware moderna, que a√∫n no est√° disponible en WebAssembly, es la compatibilidad con el direccionamiento de memoria de 64 bits.  Todo es simple: con direcciones de 32 bits puede usar solo 4 GB de memoria (que es muy peque√±a para programas grandes), pero con direcciones de 64 bits ya es de hasta 16 exabytes (esto es mucho para el software moderno).  Por supuesto, no solo el m√°ximo te√≥rico es importante, sino tambi√©n el pr√°ctico (cu√°nta memoria le dar√° el sistema operativo).  Pero en la mayor√≠a de los dispositivos modernos ya hay 4 o m√°s GB de RAM y este n√∫mero aumentar√°. <br><br><h3>  Habilidad: Compilaci√≥n Stream </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/477/392/ade/477392ade953503f39a7f98214190ef1.png" alt="imagen"><br><br>  No solo necesitamos ejecutar aplicaciones r√°pidamente.  Tambi√©n debemos reducir el intervalo de tiempo entre el inicio de su descarga a trav√©s de la red y su inicio.  La compilaci√≥n de flujo le permite comenzar a procesar un archivo de WebAssembly antes de que finalmente se descargue.  Revisamos las instrucciones a medida que se descargan a trav√©s de la red.  Por lo tanto, la carga y la compilaci√≥n van en paralelo.  En el c√≥digo de Firefox, pudimos lograr una velocidad de compilaci√≥n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">superior a la velocidad de descarga</a> , es decir, el tiempo de procesamiento de algunos c√≥digos de N bytes result√≥ ser menor que el tiempo de descarga de este c√≥digo en la red.  Los desarrolladores de otros navegadores tambi√©n est√°n trabajando en la compilaci√≥n de secuencias. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/ad8/71f/c7aad871f04688b8f1d93480c48e6a74.png" alt="imagen"><br><br>  Una cosa relacionada con la compilaci√≥n de transmisi√≥n es el uso de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dos compiladores</a> .  Uno de ellos (descrito anteriormente) funciona r√°pidamente y le permite iniciar inmediatamente el c√≥digo descargado.  Sin embargo, no realiza todas las optimizaciones te√≥ricamente posibles, ya que requiere m√°s tiempo.  Tales optimizaciones son realizadas por otro compilador que trabaja en segundo plano.  Tan pronto como termina su trabajo, una versi√≥n en memoria reemplaza a otra y luego funciona en su lugar. <br><br>  Entonces obtenemos tanto el inicio r√°pido de la aplicaci√≥n como su operaci√≥n efectiva. <br><br><h3>  Habilidad: almacenamiento en cach√© </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/287/101/9b4/2871019b4d4d50c27713f67c9fe6ccd9.png" alt="imagen"><br><br>  Si una vez descargamos y compilamos un c√≥digo de WebAssembly por el compilador de optimizaci√≥n, entonces no tiene sentido hacer lo mismo al cargar este c√≥digo en otra pesta√±a (o la pr√≥xima vez que se abra el navegador, siempre que la aplicaci√≥n permanezca sin cambios).  El c√≥digo compilado puede (y debe) almacenarse en cach√© y luego usarse desde el cach√©. <br><br><h3>  Habilidad: otras mejoras </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/85f/14f/157/85f14f1575ad1327cb1d0afa9e3ed353.png" alt="imagen"><br><br>  Ahora se discute mucho sobre qu√© otras mejoras son posibles y en qu√© deber√≠an centrarse los esfuerzos de los desarrolladores.  Definitivamente algo se realizar√°, algo no inmediato, algo no suceder√° en absoluto.  Yo, con su permiso, definir√© todos estos puntos en la clase general "otras mejoras", y lo que entraremos en esto lo entenderemos con el tiempo. <br><br><h3>  Donde estamos ahora </h3><br>  En alg√∫n lugar por aqu√≠: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/e7b/b13/a04e7bb13ef5b52fd1f0a5a1af4c298d.png" alt="imagen"><br><br><h4>  Multithreading </h4><br>  Para el subprocesamiento m√∫ltiple, tenemos un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plan</a> casi listo, pero una de sus partes clave ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SharedArrayBuffers</a> ) se vio obligada a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">deshabilitarse</a> a principios de este a√±o.  Se volver√° a encender pronto y podemos continuar. <br><br><h4>  SIMD </h4><br>  <a href="">Desarrollado</a> activamente en este momento. <br><br><h4>  Direccionamiento de 64 bits </h4><br>  Para <a href="">wasm-64</a> , tenemos una idea bastante clara de c√≥mo deber√≠an funcionar las cosas.  Nos basamos en enfoques de arquitectura x86 y ARM. <br><br><h4>  Recopilaci√≥n de transmisiones </h4><br>  En Firefox, se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">agreg√≥</a> en 2017, otros navegadores est√°n trabajando en ello. <br><br><h4>  Usando dos compiladores </h4><br>  En Firefox, esto se agreg√≥ en 2017 y en otros navegadores en 2018. <br><br><h4>  Cach√© HTTP impl√≠cito </h4><br>  En Firefox, el desarrollo est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">casi completo</a> , habr√° un lanzamiento pronto. <br><br><h4>  Otras mejoras </h4><br>  Hay una discusi√≥n <br><br>  Como puede ver, la mayor√≠a de los elementos todav√≠a est√°n en desarrollo activo.  Y sin embargo, ya podemos ver aplicaciones que se ejecutan en WebAssembly hoy, ya que las capacidades de hoy ya son suficientes para alguien.  Tan pronto como todas las caracter√≠sticas anteriores est√©n listas, abriremos otro "nuevo logro" e incluso m√°s aplicaciones nuevas recibir√°n soporte de WebAssembly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/994/53c/36b/99453c36b420ead1b724c7a7e415c689.png" alt="imagen"><br><br><h2>  Interacci√≥n Javascript </h2><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/42e/383/372/42e383372c2216891576c4cdda6ae193.png" alt="imagen"></a> <br><br>  WebAssembly fue creado no solo como una plataforma para juegos y aplicaciones pesadas.  Se puede usar para el desarrollo web regular.  Somos conscientes de que hoy en d√≠a hay aplicaciones web muy grandes escritas en Javascript y pocos deciden tomarlas y reescribirlas por completo en WebAssembly.  El punto importante aqu√≠ es que esto no es necesario.  Lo m√°s probable es que la mayor√≠a de estas aplicaciones funcionen bastante bien y solo en algunos cuellos de botella, tal vez, haya una falta de rendimiento en los c√°lculos o en el ancho de banda del procesamiento de datos, o falta de funcionalidad debido a la falta de una versi√≥n JS de alguna biblioteca.  Queremos dar a los desarrolladores la oportunidad de reescribir solo estos cuellos de botella en WebAssembly, dejando el resto del c√≥digo en JS familiar.  Y ya es posible.  Por ejemplo, al reescribir el analizador Gutenberg en Rust y ensamblarlo bajo WebAssebly, logramos un aumento de productividad de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">86 veces</a> . <br><br>  Pero para que esta pr√°ctica sea masiva y conveniente, necesitamos implementar algo m√°s. <br><br><h3>  Habilidad: llamadas r√°pidas entre JS y WebAssembly </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/557/618/0ec/5576180eca50ce1736a684aa32575524.png" alt="imagen"><br><br>  Llamar a WebAssembly desde JS deber√≠a funcionar muy r√°pido.  Al agregar un peque√±o m√≥dulo WebAssembly, el programador no deber√≠a sentir ninguna p√©rdida de rendimiento, incluso si este m√≥dulo se llama con mucha frecuencia.  Este no es el caso en MVP (ya que el objetivo de MVP no era maximizar el rendimiento de tales llamadas).  Este problema a√∫n no se ha solucionado.  En Firefox, ya nos hemos asegurado de que algunas llamadas JS-&gt; WebAssembly <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ya</a> sean <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">m√°s r√°pidas que las llamadas JS-&gt; JS no en l√≠nea</a> .  Los desarrolladores de otros navegadores tambi√©n est√°n trabajando en esta tarea. <br><br><h3>  Habilidad: intercambio r√°pido de datos </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/606/f9c/445/606f9c44570c6a3a4f64b008be4e5eda.png" alt="imagen"><br><br>  Esta tarea est√° conectada con la anterior: es importante no solo llamar r√°pidamente al c√≥digo de WebAssembly desde JS, sino tambi√©n transferir r√°pidamente los datos entre ellos.  Hay ciertos problemas con esto.  Por ejemplo, el hecho de que WebAssembly solo comprende n√∫meros.  No hay objetos en √©l, pero en JS s√≠.  Resulta que necesitamos alg√∫n tipo de capa de traducci√≥n.  Ya existe, pero a√∫n no es lo suficientemente productivo. <br><br><h3>  Habilidad: Integraci√≥n con m√≥dulos ES </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/15f/db4/b4f15fdb4151fccd40d509e675e3363e.png" alt="imagen"><br><br>  Ahora, usar el m√≥dulo WebAssembly parece llamar a una API especial que le devolver√° el m√≥dulo para su uso.  Pero esto significa que el m√≥dulo WebAssembly no es realmente parte del gr√°fico del m√≥dulo JS de la aplicaci√≥n web.  Para tener todas las funciones disponibles para los m√≥dulos ES (como exportar e importar), el m√≥dulo WebAssembly debe poder integrarse con los m√≥dulos ES. <br><br><h3>  Habilidad: Integraci√≥n en el desarrollo </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/60a/a00/b26/60aa00b2662dcb635ff336ad09319e85.png" alt="imagen"><br><br>  El solo hecho de poder importar y exportar no significa convertirse en un m√≥dulo completamente funcional.  Necesitamos un lugar donde se puedan distribuir los m√≥dulos de WebAssembly.  ¬øCu√°l ser√° el an√°logo de npm para WebAssembly?  Hmm ... ¬øqu√© tal npm en s√≠?  ¬øY cu√°l ser√° el an√°logo de webpack o Parcel para WebAssembly?  Hmm ... ¬øqu√© pasa con webpack y parcela? <br><br>  Los m√≥dulos de WebAssembly no deben diferir de los m√≥dulos ordinarios, lo que significa que pueden distribuirse a trav√©s de la misma infraestructura.  Pero necesitamos herramientas para integrarlos en esta infraestructura. <br><br><h3>  Habilidad: Compatibilidad con versiones anteriores </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/86f/b36/e1e86fb36b5c6f28e1084613b8acd24f.png" alt="imagen"><br><br>  Hay otra cosa importante que debemos proporcionar.  Todo deber√≠a funcionar bien incluso en versiones anteriores de navegadores.  Incluso aquellos que no tienen idea sobre WebAssembly.  Debemos garantizar que una vez que escribamos el c√≥digo para WebAssembly, el desarrollador no tendr√° que escribir la segunda versi√≥n del mismo c√≥digo en Javascript simplemente porque el sitio tambi√©n debe abrirse en IE11. <br><br><h3>  Donde estamos ahora </h3><br>  En alg√∫n lugar aqu√≠: <br><img src="https://habrastorage.org/getpro/habr/post_images/49e/46e/ff9/49e46eff987d5d8de4984576f954847c.png" alt="imagen"><br><br><h4>  Atajos entre JS y WebAssembly </h4><br>  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">implementado</a> en Firefox, se est√° trabajando en otros navegadores. <br><br><h4>  Intercambio de datos r√°pido </h4><br>  Hay varias sugerencias  Por ejemplo, expanda el sistema de tipos en WebAssembly con referencias a objetos JS.  Esto es posible, pero necesitar√° escribir c√≥digo adicional (por ejemplo, para llamar a m√©todos JS), que no funciona demasiado r√°pido.  Para resolver este problema, a su vez, hay varias sugerencias. <br><br>  Hay otro aspecto relacionado con el intercambio de datos.  Se trata de rastrear cu√°nto tiempo se pueden almacenar los datos en la memoria.  Si tiene alg√∫n dato en la memoria al que el c√≥digo JS deber√≠a tener acceso, debe dejarlo all√≠ hasta que el c√≥digo JS lo lea.  Pero si los dejas all√≠ para siempre, tendremos una p√©rdida de memoria.  ¬øC√≥mo saber que los datos ya se pueden eliminar (el c√≥digo JS ya los ha le√≠do)?  Hoy, esta responsabilidad recae en el programador: todo se libera manualmente.  Una vez que el c√≥digo JS ha terminado de leer los datos, deber√≠a llamar a algo as√≠ como la funci√≥n "libre".  Pero este enfoque est√° desactualizado y a menudo conduce a errores.  Para resolver este problema, presentamos el concepto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WeakRef</a> en Javascript.  Esto permite leer datos en el lado del c√≥digo JS, y cuando el recolector de basura funciona, es necesario borrar correctamente la memoria en el m√≥dulo WebAssembly. <br><br>  Todo esto todav√≠a est√° en desarrollo.  Mientras tanto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">, se</a> han <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">creado herramientas</a> en el ecosistema Rust que automatizan la escritura de dicho c√≥digo para usted, reemplazando las partes que a√∫n no se han implementado con su propia implementaci√≥n.  Una de estas herramientas merece una menci√≥n especial.  Se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wasm-bindgen</a> .  Cuando se da cuenta de que su c√≥digo Rust est√° tratando de obtener o devolver objetos JS u objetos DOM, crea autom√°ticamente una capa JS que podr√° interactuar con su c√≥digo Rust.  Y esta capa tambi√©n puede interactuar con el m√≥dulo WebAssembly escrito en cualquier otro idioma, por lo que no solo los programadores de Rust pueden usar esta herramienta. <br><br><h4>  Integraci√≥n con m√≥dulos ES </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un plan de</a> trabajo en esta √°rea ha existido desde hace bastante tiempo.  Estamos trabajando activamente en ello junto con desarrolladores de otros navegadores. <br><br><h4>  Integraci√≥n de desarrollo </h4><br>  Ya existen herramientas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">wasm-pack</a> en el ecosistema Rust que le permiten empacar autom√°ticamente todo lo que necesita para su lanzamiento en npm.  Y hay personas que usan esta herramienta para crear sus m√≥dulos. <br><br><h4>  Compatibilidad con versiones anteriores </h4><br>  Para compatibilidad con versiones anteriores, tenemos la herramienta wasm2js.  Le permite convertir un archivo wasm en un archivo JS equivalente.  Este c√≥digo Javascript no ser√° r√°pido, pero funcionar√° en cualquier navegador (incluido uno que no sea compatible con WebAssembly). <br><br>  Como puede ver, estamos muy cerca de recibir este "logro".  Y tan pronto como hagamos esto, se abrir√° el camino a dos m√°s. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cd/f82/ac3/4cdf82ac3ee88090ba897f2ca4b339da.png" alt="imagen"></a> <br><br><h2>  Marcos JS y lenguajes compilados JS </h2><br>  El primero es la capacidad de reescribir marcos JS de peso pesado populares en WebAssebly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/e65/121/794e6512119d46d55953dba013ed3273.png" alt="imagen"><br><br>  El segundo es habilitar los lenguajes de programaci√≥n que compilan en Javascript para reemplazarlo con WebAssembly.  Estamos hablando de idiomas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Scala.js</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reason</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Elm</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31c/1ce/750/31c1ce750e3bfefe906d372292e8dfdb.png" alt="imagen"><br><br>  Para ambas tareas, WebAssembly debe admitir una serie de nuevas caracter√≠sticas de alto nivel. <br><br><h3>  Habilidad: recolector de basura </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c3e/8eb/160/c3e8eb1609af4cde10a08081ee63f046.png" alt="imagen"><br><br>  Necesitamos integraci√≥n con un recolector de basura basado en navegador por varias razones.  Primero, recordemos la tarea de reescribir los marcos JS (o partes de ellos).  Puede ser necesario ,  React      DOM-,     Rust   .     -     .   DOM     ,         ,        . ,    ,     ,      .      ,   . <br><br>        JS-.       - ,   .           ,      ,       Javascript.  JS-          WebAssembly-,            JS-. <br><br>       (  ),       .    ,   ,    . WebAssembly        ,   . <br><br>       Scala.js, Reason, Kotlin  Elm ‚Äî     Javascript,        .   WebAssembly      ‚Äî          WebAssembly             (    ). <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/98a/88d/f2f98a88dd8f91735a5572950606811e.png" alt="imagen"><br><br>    . ,  ,  Rust,   .    ‚Äî .            ‚Äî    .       WebAssembly     . <br><br>  ,    Javascript.          ‚Äî -           - .   WebAssembly-  JS-,     ‚Äî      .   Rust, ,     .   ,       . <br><br><h3> :  </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0dc/5f2/b8a/0dc5f2b8a7da6d533192464f6258c314.png" alt="imagen"><br><br>   ,    JS-,    .         Javascript-.         WebAssembly. <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/365/d07/1d8/365d071d8415b5510f45f70982edee2e.png" alt="imagen"><br><br>       ,   " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ".       ,        ‚Äî              .         ,        WebAssembly. <br><br><h3>   ? </h3><br> -  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f5/b0d/853/8f5b0d8534744ec21059f27231fa080b.png" alt="imagen"><br><br><h4>   </h4><br>  Para implementar la recolecci√≥n de basura, actualmente se est√° trabajando en dos direcciones: estos son los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">objetos con tipo</a> para JS y, de hecho, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el recolector de basura para WebAssembly</a> .  Typed Objects le permite describir la estructura clara del objeto.  Ya existe una visi√≥n de c√≥mo deber√≠a funcionar esto, y se discutir√° en la pr√≥xima reuni√≥n del TC39.  En consecuencia, el GC para WebAssembly podr√° acceder a la estructura anterior para sus propios fines.  Ya se est√° trabajando en su implementaci√≥n. <br><br>  Tan pronto como ambas partes est√©n terminadas, obtendremos un sistema al interactuar JS y WebAssembly, capaz de comprender en todos los niveles en qu√© consiste el objeto y utilizar sus datos internos de manera efectiva.  Ya tenemos un prototipo funcional.  Sin embargo, el prototipo no solo puede tomarse y lanzarse: tenemos que dedicar un tiempo a la estandarizaci√≥n y las revisiones.  Esperamos que llegue al lanzamiento en alg√∫n momento del a√±o 2019. <br><br><h4>  Manejo de excepciones </h4><br>  El trabajo sobre <a href="">excepciones se encuentra</a> actualmente en investigaci√≥n y desarrollo.  Consideramos varias propuestas, tratamos de implementarlas y vemos cu√°n efectivamente funcionan. <br><br><h4>  Depuraci√≥n </h4><br>  Para la depuraci√≥n, ya hay alg√∫n soporte en las herramientas para desarrolladores de Firefox.  Pero el ideal a√∫n est√° lejos.  Queremos mostrarle al desarrollador su c√≥digo fuente y su posici√≥n actual, y no solo las instrucciones del ensamblador.  Tenemos que desarrollar e implementar soporte para archivos de s√≠mbolos, lo que nos permitir√° correlacionar cada instrucci√≥n de c√≥digo con la l√≠nea de origen.  En este momento, <a href="">se est√° trabajando</a> en la especificaci√≥n de este mecanismo. <br><br><h4>  La cola llama </h4><br>  <a href="">Hay un trabajo en progreso</a> . <br><br>  Cuando se completa todo lo anterior, podemos suponer que hemos logrado el logro "Marcos e idiomas de JS compilados en JS" <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8cb/651/7b4/8cb6517b4483f2b4f566783157f9511d.png" alt="imagen"></a> <br><br>  Entonces, era un plan para obtener "logros" en el navegador.  ¬øQu√© pasa con lo que sucede fuera del navegador? <br><br><h2>  Fuera del navegador </h2><br>  Quiz√°s te avergonz√≥ la combinaci√≥n de las palabras "fuera del navegador".  ¬øRealmente tenemos algo adem√°s del navegador cuando hablamos de la web?  Pero la "web" la tenemos en el nombre "WebAssembly".  Pero, de hecho, HTML, CSS y JavaScript son solo la punta del iceberg. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c11/606/9c4c1160641ee4014f7317b71711f3d2.png" alt="imagen"><br><br>  S√≠, son mejor visibles, porque son ellos quienes forman la interfaz de usuario.  Pero hay otra parte muy importante de la web: las conexiones.  La conexi√≥n de todo con todo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/d7b/4f4/f34d7b4f4d2fdfe6487614b4d1530416.png" alt="imagen"><br><br>  Puedo enlazar a tu p√°gina ahora mismo.  No necesito el tuyo ni el permiso de nadie m√°s.  Acabo de hacer este enlace, lo agrego a mi sitio.  Cualquiera puede seguirlo y se mostrar√° su contenido, se lanzar√° el c√≥digo que escribi√≥.  Esta simplicidad de crear conexiones y la transici√≥n a trav√©s de ellas ha creado nuestra Internet tal como es.  Ahora tenemos redes sociales y otros sitios que, en esencia, expanden el concepto de "enlace" con la capacidad de acoplar cualquier cosa: personas, dispositivos, negocios, etc. <br><br>  Pero con todos estos enlaces y enlaces, hay dos problemas. <br><br>  Primero, ¬øa qu√© debe conducir el enlace?  Si va a alg√∫n lado y el sitio le ofrece un c√≥digo que debe ejecutarse en su navegador, este c√≥digo debe ser multiplataforma.  Deber√≠a compilarse en algo y ejecutarse en una amapola, en Windows, en un Android.  En todas partes  La portabilidad del c√≥digo descargable es una parte importante del concepto de conectividad web. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b38/d74/4c1/b38d744c118cebfdff5d8cd198f8a490.png" alt="imagen"><br><br>  Pero solo descargar y ejecutar el c√≥digo no es suficiente.  Debe comprender que no sabemos nada sobre este c√≥digo.  No confiamos en √©l lo suficiente como para dar un control total sobre la computadora del usuario.  ¬øQu√© pasa si es un c√≥digo malicioso?  El puede hacer algo malo.  Y aqu√≠ necesitamos alg√∫n tipo de modelo de seguridad.  Necesitamos una caja de arena donde podamos poner un c√≥digo desconocido, darle algunas herramientas controladas para el trabajo, pero eliminar todo lo cr√≠ticamente importante e inseguro lejos de √©l. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/1d6/0c6/0bf1d60c6df0e2a76b4afb83e3dffe42.png" alt="imagen"><br><br>  Por lo tanto, hay dos aspectos del concepto de "comunicaci√≥n": portabilidad y seguridad.  Sabemos que definitivamente podemos ejecutar el c√≥digo y que ciertamente no nos har√° da√±o.  ¬øPor qu√© insisto en estos conceptos y c√≥mo esta vista de las cosas difiere de la vista de la web como una combinaci√≥n de HTML, CSS y Javascript?  Porque este enfoque cambia fundamentalmente la visi√≥n de lo que es WebAssembly. <br><br>  Por un lado, podemos pensar en WebAssembly como "otra herramienta disponible en un navegador moderno".  Y asi es. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1df/51f/fe5/1df51ffe596ea6f2f45543f913ca7911.png" alt="imagen"><br><br>  Pero la portabilidad y la seguridad de la ejecuci√≥n del c√≥digo nos abren otras puertas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/71e/e98/5da71ee982b4cb6a126d14aa962ed491.png" alt="imagen"><br><br><h2>  Node.js </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/643/c55/b5c643c55f8c180e50e1a24ee4122ef6.png" alt="imagen"><br><br>  ¬øC√≥mo puede ayudar WebAssembly a Node?  Trayendo portabilidad. <br><br>  El nodo proporciona un nivel bastante alto de portabilidad mediante el uso de Javascript.  Pero todav√≠a hay muchos casos en los que el rendimiento del c√≥digo JS no es suficiente o simplemente no se ha escrito a√∫n el c√≥digo JS correcto, pero hay una versi√≥n nativa del mismo.  Y luego Node usa m√≥dulos nativos.  Est√°n escritos en lenguajes como C y deben compilarse para la plataforma espec√≠fica en la que se ejecuta su nodo. <br><br>  Los m√≥dulos nativos pueden compilarse durante la instalaci√≥n o puede tenerlos listos de inmediato para una de las plataformas populares.  Ambos enfoques son posibles, pero esta es solo una elecci√≥n de dos males: ya sea un dolor de cabeza adicional para el usuario o el autor del m√≥dulo. <br><br>  Si imagina que estos m√≥dulos estar√°n en WebAssembly, no ser√° necesario compilarlos.  La portabilidad le permite ejecutarlos en cualquier plataforma, inmediatamente, como el c√≥digo Javascript.  Pero funcionar√°n con el rendimiento de las versiones nativas. <br><br>  Y aqu√≠ la felicidad llega al mundo de Node en forma de portabilidad total de todo y en todas partes.  Puede portar la aplicaci√≥n Node de Linux a Windows, y todo continuar√° funcionando sin ninguna recompilaci√≥n.  Pero al mismo tiempo, el m√≥dulo WebAssembly no tiene acceso a los recursos del sistema (funciona en su caja de arena).  Pero los m√≥dulos de Nodo nativos (e incluso no nativos) no funcionan en el sandbox, tienen acceso a todo; esta es la ideolog√≠a de Node.  Por lo tanto, para que el m√≥dulo WebAssembly obtenga las mismas caracter√≠sticas, se necesita una capa adicional de acceso a los recursos del sistema operativo.  Algo as√≠ como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">las</a> funciones <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">POSIX</a> (no son necesarias, se dan solo como un ejemplo de una interfaz de acceso a recursos relativamente estable y suficiente). <br><br><h3>  Habilidad: interfaz port√°til </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/e88/688/a08e88688da9312cf9b0821ea1ebd9de.png" alt="imagen"><br><br>  Entonces, ¬øqu√© necesitan los desarrolladores de Node para usar los m√≥dulos de WebAssembly?  Alg√∫n tipo de interfaz para acceder a sus funciones.  Ser√≠a bueno estandarizarlo.  Bueno, para que no solo Node pueda invocar estas funciones, sino tambi√©n cualquier persona en general.  Si desea utilizar el m√≥dulo WebAssembly en su aplicaci√≥n, lo hemos conectado y lo estamos utilizando.  Algo as√≠ como "POSIX para WebAssembly".  PWSIX (interfaz del sistema port√°til WebAssembly)? <br><br><h3>  Donde estamos ahora </h3><br>  Hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documento</a> que describe el mecanismo para proporcionar una ruta a un m√≥dulo por su nombre.  Es probable que lo utilicen tanto los navegadores como Node (podr√°n proporcionar diferentes rutas).  Si bien no hay un desarrollo activo, hay mucha discusi√≥n. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69c/74f/63f/69c74f63fd64008d91dbf31a18dce24e.png" alt="imagen"><br><br>  Lo m√°s probable es que se implemente de alguna forma.  Esto es bueno porque nos abre una serie de posibilidades. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ae2/750/50f/ae275050f12b82aba399d26d50656c0f.png" alt="imagen"></a> <br><br><h2>  CDN, sin servidor y computaci√≥n perimetral </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/77d/224/c1677d22458933b7f3c07cdf47b9bf12.png" alt="imagen"><br><br>  Ejemplos son cosas como CDN, Serverless, Edge Computing.  Casos en los que coloca su c√≥digo en el servidor de otra persona, lo que se encarga de su disponibilidad para los clientes.  ¬øPor qu√© podr√≠a necesitar WebAssembly aqu√≠?  Recientemente hubo un excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> sobre este tema.  En resumen, puede ser necesario ejecutar c√≥digo desde diferentes fuentes (que no conf√≠an entre s√≠) dentro de un proceso.  Este c√≥digo debe aislarse entre s√≠ y del sistema operativo.  Las soluciones como una m√°quina virtual JS (SpiderMonkey o V8) funcionan de alguna manera, pero no proporcionan el rendimiento y la escalabilidad deseados.  Y WebAssembly - da. <br><br>  ¬øQu√© se necesita para que esto funcione? <br><br><h3>  Habilidad: tiempo de ejecuci√≥n </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/965/16f/e4c/96516fe4ccb30f39a885d1f460033e0c.png" alt="imagen"><br><br>  Necesitamos un entorno de tiempo de ejecuci√≥n y algunas empresas crean el suyo propio.  Ya tenemos compiladores WebAssembly (como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cranelift</a> ): son r√°pidos y eficientes en memoria.  Pero el c√≥digo generado por √©l no puede vivir en el vac√≠o: necesita confiar en algo, de alguna manera interactuar con el medio ambiente.  Ahora, algunas compa√±√≠as, como Fastly, escriben este entorno de ejecuci√≥n por su cuenta.  Pero este no es un enfoque muy bueno, despu√©s de todo, muchas compa√±√≠as lo necesitar√°n y har√°n el mismo trabajo, una y otra vez.  Podr√≠amos hacerlo una vez, agregar al est√°ndar y ahorrar a todos un mont√≥n de recursos. <br><br><h3>  Donde estamos ahora </h3><br>  En alg√∫n lugar aqu√≠: <br><img src="https://habrastorage.org/getpro/habr/post_images/bba/460/2be/bba4602be78c2f8132a7106d7463218f.png" alt="imagen"><br><br>  No hay un est√°ndar de tiempo de ejecuci√≥n todav√≠a.  Lo que no impide que varios tiempos de ejecuci√≥n independientes ya utilizados en proyectos reales existan y funcionen.  Por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WAVM</a> y wasmjit. <br><br>  Tambi√©n planeamos lanzar un tiempo de ejecuci√≥n construido sobre Cranelift, se llamar√° wasmtime.  Y tan pronto como tengamos algo estandarizado y funcionando, esta es una oportunidad abierta para desarrollar una serie de cosas, como, por ejemplo ... <br><br><h2>  Utilidades port√°tiles de l√≠nea de comando </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/90a/f8f/a14/90af8fa14441a34a3652478d0bd9b948.png" alt="imagen"><br><br>  WebAssembly se puede usar no solo en el navegador, sino tambi√©n en los sistemas operativos tradicionales.  No hablaremos sobre el kernel (aunque hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">temerarios</a> que tambi√©n lo est√°n haciendo), pero el c√≥digo de WebAssembly puede funcionar en modo de usuario.  Y esto hace posible crear utilidades de l√≠nea de comandos que, una vez compiladas, funcionar√°n garantizadas para ser las mismas para cualquier sistema operativo. <br><br><h2>  Internet de las cosas </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/10a/dcd/18f10adcda7bfa676d90b6e92cb2bb30.png" alt="imagen"><br><br>  Por "Internet de las cosas" generalmente se refieren a dispositivos de baja potencia (como sensores / controladores port√°tiles o varios en "hogares inteligentes").  Las limitaciones en los recursos de procesador y RAM disponibles afectan negativamente la capacidad de ejecutar c√≥digo JS all√≠, pero WebAssembly es un asunto completamente diferente.  La optimizaci√≥n de compiladores como Cranelift y un tiempo de ejecuci√≥n como wasmtime brillar√° en tales condiciones, ya que fueron escritos para tareas de ahorro de recursos.  En casos absolutamente extremos, WebAssembly incluso hace posible compilar su m√≥dulo en el binario nativo de la plataforma de destino.  Bueno, de nuevo, portabilidad: hoy en d√≠a hay muchos de estos dispositivos IoT y est√°n construidos en diferentes plataformas.  Con WebAssembly, no tiene que preocuparse por esto: el c√≥digo desarrollado se ejecutar√° en todas partes. <br><br><h2>  Conclusiones </h2><br>  Retrocedamos un poco y echemos un vistazo a nuestro "√°rbol de habilidades" nuevamente. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0c6/201/71f/0c620171f0b0c2b880e730e84ee9f1b4.png" alt="imagen"></a> <br><br>  Comenc√© este art√≠culo con el hecho de que algunas personas no entienden por qu√© WebAssembly a√∫n no ha terminado.  Como puedes entender ahora, su camino apenas ha comenzado.  S√≠, MVP ya est√° abriendo algunas posibilidades.  Ya podemos compilar algo en WebAssembly y ejecutarlo en un navegador.  Pero todav√≠a hay mucho trabajo por delante: admitir todo lo que necesita para aplicaciones pesadas e idiomas de alto nivel, reemplazar los marcos JS y todas estas cosas "fuera del navegador" de las que habl√©.  Cuando todo esto est√© listo, veremos una nueva web.  Alto rendimiento, m√°s grande, m√°s port√°til.  Ya no habr√° ese tipo de software que no se puede escribir para su ejecuci√≥n en el navegador: juegos, blockchain, Internet de las cosas, utilidades de l√≠nea de comandos: todo comenzar√°. <br><br>  WebAssembly no est√° terminado.  El acaba de comenzar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428347/">https://habr.com/ru/post/es428347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428337/index.html">JavaScript entretenido: sin llaves</a></li>
<li><a href="../es428339/index.html">No lo automatice: malos consejos comerciales</a></li>
<li><a href="../es428341/index.html">Tecnolog√≠a Qsan RAID EE</a></li>
<li><a href="../es428343/index.html">Un rompecabezas interesante en C</a></li>
<li><a href="../es428345/index.html">Requisitos de cobertura con estuches. SuperJob Realities</a></li>
<li><a href="../es428353/index.html">C√≥mo creamos un sistema para rastreos m√≥viles en SIBUR</a></li>
<li><a href="../es428355/index.html">Mec√°nica de gamificaci√≥n: calificaci√≥n</a></li>
<li><a href="../es428363/index.html">Construyendo un jetpack / hoverboard: sistemas de rescate</a></li>
<li><a href="../es428365/index.html">La historia de c√≥mo cambi√≥ la facturaci√≥n de Google o c√≥mo evitar costos innecesarios</a></li>
<li><a href="../es428367/index.html">Creamos el m√≥dem sonar m√°s peque√±o del mundo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>