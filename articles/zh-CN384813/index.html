<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎞️ 👉🏻 ✊🏿 STM32F3Discovery上的PPM到USB适配器，或者我们通过STM32Cube将飞机模型控制台作为HID游戏杆连接到计算机 🚝 🥄 🤞🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将告诉您如何：
 

- 在STM32CubeMX中创建一个项目，并设置计时器以捕获外部信号。 
- 从飞机模型控制台解码PPM信号。 
- 在STM32上制作人机界面设备并编写您的HID报告描述符。 
- 在赛车直升机上的模拟器中飞行。:)
 前言
 最近，FPV在第250类直升机上的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>STM32F3Discovery上的PPM到USB适配器，或者我们通过STM32Cube将飞机模型控制台作为HID游戏杆连接到计算机</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/384813/"><img src="https://habrastorage.org/files/42a/e17/45b/42ae1745bcc442529f2839504fdf51f4.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将告诉您如何：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在STM32CubeMX中创建一个项目，并设置计时器以捕获外部信号。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从飞机模型控制台解码PPM信号。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在STM32上制作人机界面设备并编写您的HID报告描述符。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在赛车直升机上的模拟器中飞行。</font><font style="vertical-align: inherit;">:)</font></font></li>
</ul><a name="habracut"></a><br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前言</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，FPV在第250类直升机上的竞赛（FPV-第一人称视角）越来越受欢迎。</font><font style="vertical-align: inherit;">数字250表示电动机对角线之间的距离，这是小型机动直升机所特有的。</font><font style="vertical-align: inherit;">此类设备建立在可承受跌落和碰撞的耐用碳纤维框架上。</font><font style="vertical-align: inherit;">直径为5到6英寸且具有较大台阶（桨叶倾斜角）的螺旋桨安装在功能强大的电机上，以实现最动态的飞行。</font><font style="vertical-align: inherit;">来自模拟航向便携式摄像机的图像以5.8 GHz的频率传输到飞行员的监视器或视频眼镜。</font><font style="vertical-align: inherit;">由于通过WiFi进行的数字传输会产生较长的延迟（200-300毫秒），因此视频始终会在模拟频道上播放。</font><font style="vertical-align: inherit;">要录制壮观的剪辑，请在其上放置运动相机（GoPro，Mobius，SJcam，Xiaomi Yi等）。</font></font><br>
<br>
<div style="text-align:center;"><img width="40%" src="https://habrastorage.org/files/727/722/0e5/7277220e5a8c4b749415d16d28091648.jpg"></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下是一些有关FPV直升机的精彩视频：</font></font></b><div class="spoiler_text"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://www.youtube.com/embed/NsxyV-kgfio%3Ffeature%3Doembed&amp;usg=ALkJrhiDXGQU9KpvznZvdr3Vnv_vFLYjnQ" frameborder="0" allowfullscreen=""></iframe><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://www.youtube.com/embed/1MBW8zoZUR4%3Ffeature%3Doembed&amp;usg=ALkJrhgmLwMQHcENu5g4tcvKIopvs_BLYg" frameborder="0" allowfullscreen=""></iframe><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://www.youtube.com/embed/70pusNNunMA%3Ffeature%3Doembed&amp;usg=ALkJrhjx_06o8qRpqiYCjifdkKDS5FBb7w" frameborder="0" allowfullscreen=""></iframe></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在建造我的微型直升机之前，我想乘模拟器飞行，看看我是否会对FPV比赛感兴趣。对于培训，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPV FreeRider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模拟器非常适合</font><font style="vertical-align: inherit;">。它价格便宜，具有免费的演示版本，并且根据经验丰富的飞行员的说法，它非常准确地模仿了飞行的真实机制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过键盘或操纵杆在模拟器中控制飞机。键盘不适合用于导航，因为这些按钮只能发送离散值（按下/未按下按钮），并且不可能发送平滑变化的中间值。来自游戏机的带有模拟摇杆的操纵杆要好得多，但它们的摇杆非常小，因此您无法足够准确地控制设备。模拟器的理想选择是通过专用适配器连接到计算机的飞机模型控制台，因此操作系统将其视为操纵杆。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我已经拥有一架直升机，可以进行休闲飞行和摄影，但又太大又笨重，无法进行比赛。因此，有一个遥控器-Turnigy 9X（在第一个图中）。在背面，它有一个连接器，用于连接输出PPM信号的适配器。该信号是一个短脉冲，间隔为1到2毫秒，其持续时间与控件的位置相对应（在解码部分中与该控件有关的更多信息）。</font></font><br>
<br>
<div style="text-align:center;"><img width="33%" src="https://habrastorage.org/files/68b/cc1/4f0/68bcc14f02164d51a17401da82253df4.jpg"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我必须说，用于将遥控器从PPM连接到USB的适配器已经发布了很长时间，并且已经出售。</font><font style="vertical-align: inherit;">可以在中国以5美元的价格购买类似的闪存驱动器适配器，而在俄罗斯的商店则要贵一些。</font><font style="vertical-align: inherit;">AVR控制器上</font><font style="vertical-align: inherit;">也有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开源</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">适配器</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">项目</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是当深夜，当莫斯科所有飞机模型商店都已经关门时，我立刻想到了飞行的强烈愿望。</font><font style="vertical-align: inherit;">我不想在早上等待，因为没有时间用ATmega来中毒和焊接该板，所以我决定在STM32F3Discovery板上制作一个PPM-USB适配器，该适配器长期处于闲置状态，就在手边。</font></font><br>
<br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要什么</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了制作适配器，您将需要：</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM32F3Discovery</a>.     STM32,     USB,   . </li>
<li>  c - 3,5     ( Turnigy)   BLS-,   ,   ( Discovery).</li>
<li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">STM32CubeMX</a>. </li>
<li>IDE    ARM.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Keil uVision 5</a>.          32 ,      .</li>
<li> Turnigy 9X     PPM-.       FlySky FS-i6.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发现调试板非常昂贵。</font><font style="vertical-align: inherit;">所描述的F3售价约为20美元，其功能对于这样一个简单的项目是多余的。</font><font style="vertical-align: inherit;">我之所以使用它，是因为在撰写本文时，这是我在家中发现的唯一带有硬件USB的主板。</font><font style="vertical-align: inherit;">对于那些还没有购买它的人，我建议您注意一下带有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AliExpress</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">STM32F103C8T6</font></a><font style="vertical-align: inherit;">控制器的小型开发板，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">价格为3美元</font></a><font style="vertical-align: inherit;">，那里的ST-Link编程器也是如此。</font><font style="vertical-align: inherit;">该过程与本文中描述的过程没有什么不同。</font><font style="vertical-align: inherit;">除非一开始必须选择其他控制器，否则请指明是否存在石英谐振器，并使用稍微不同的引脚排列。</font></font><br>
<br>
<div style="text-align:center;"><img width="30%" src="https://habrastorage.org/files/cf1/88d/0a1/cf188d0a1da94acfb233350ff94830ae.jpg"></div><br>
<br>
<a name="cube"></a><h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在STM32CubeMX中创建项目</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
STM32Cube是意法半导体（STMicroelectronics）开发的软件包，目的是使STM32器件开发人员的生活更加轻松。它由CubeMX图形实用程序，HAL驱动程序和中间件组件组成。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CubeMX</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是用于创建项目和初始化外围设备的工具。要开始使用，只需选择控制器，选中所需模块的框，在菜单中选择所需模式，然后在几个字段中输入所需值。 CubeMX将生成项目并将所需的库连接到该项目。设备的开发人员将只编写应用程序的逻辑。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAL驱动程序</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（硬件抽象层）是用于处理微控制器的模块和外围设备的API。 HAL允许您将开发人员创建的应用程序顶层与寄存器分开，并使程序代码在STM32控制器系列之间尽可能可移植。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中间件</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或中间组件包括FreeRTOS操作系统，用于处理文件系统的库，USB库，TCP / IP等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看来现在可以用鼠标编程，而不用手动将位写入寄存器了。</font><font style="vertical-align: inherit;">但是，简单和方便并不能消除您需要阅读文档的事实，尤其是在需要以最快的速度，最低的功耗或在非标准模式下使用外围设备的情况下。</font><font style="vertical-align: inherit;">STM32Cube尚未涵盖微控制器所有功能的100％，但正在接近这一目标。</font><font style="vertical-align: inherit;">意法半导体不时更新Cube，扩展功能并修复错误。</font><font style="vertical-align: inherit;">因此，如果您已经安装了Cube，请检查它是否为最新版本。</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始设定</font></font></b></h5><br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/acf/6b2/4fc/acf6b24fc6c449f58c2be3b9ce9d1c1e.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从选择控制器开始处理项目。启动STM32CubeMX，点击</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新建项目</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MCU选择器”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡上，</font><font style="vertical-align: inherit;">您可以从过滤器中选择所需的控制器。由于我们已经完成了调试板，因此在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Board Selector</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡上</font><font style="vertical-align: inherit;">，我们找到了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STM32F3Discovery</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。选择板子后，将显示带有高亮和带符号的引脚的控制器图像。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
窗口上部有四个大选项卡：</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引脚分配</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -用于配置引脚功能和预设模块。我们目前正在处理。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时钟配置</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -时钟设置，PLL，分频器。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -外围设备和中间件的更详细的配置。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功耗计算器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -计算微控制器的功耗。</font></font><br>
<br>
<img src="https://habrastorage.org/files/d02/a54/3a7/d02a543a7fe148d99d67ae83ad6a8fc9.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引脚排列”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡的左侧菜单中，</font><font style="vertical-align: inherit;">可以使用所需的外围设备，并在控制器电路上为微控制器的任何输出选择功能。左侧的某些项目是警告图标。这意味着模块（在本例中为ADC，DAC，OPAMP2，RTC）现在不能完全使用，因为它们的某些输出已被其他功能占用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
控制器电路上已配置的引脚以绿色突出显示。</font><font style="vertical-align: inherit;">由于我们选择的不是裸露的控制器而不是捆扎带，而是选择现成的F3-Discovery调试板，因此已经配置了一些输出，例如，将蓝色按钮连接到PA0，将LED连接到PE8 ... 15。</font><font style="vertical-align: inherit;">在Discovery上与某些外部设备连接的那些引脚以橙色突出显示，但尚未配置它们的外围模块。</font><font style="vertical-align: inherit;">如您所见，这些是用于USB的引脚，石英谐振器，用于陀螺仪和罗盘的SPI和I2C引脚，用于USB的DP和DM。</font><font style="vertical-align: inherit;">灰色结论目前尚未使用，我们可以将其用于我们的目的。</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入选择</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将捕获脉冲的持续时间，因此输入必须连接到任何计时器的通道之一。</font><font style="vertical-align: inherit;">此外，Turnity 9X的信号电平与STM32的电源电压不同，不是3.3V，而是5V。</font><font style="vertical-align: inherit;">我们懒得焊接分压器，所以您需要选择可承受5V的输入（这些输入称为5V耐压）。</font><font style="vertical-align: inherit;">合适的引脚可以</font><font style="vertical-align: inherit;">在STM32F303VCT6 </font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手册的“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引脚和引脚描述”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分中找到</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">STM32F3中有许多定时器，它们分散在几乎所有引脚上。</font><font style="vertical-align: inherit;">一个方便的选择是PC6。</font><font style="vertical-align: inherit;">它可以承受5伏电压，位于电路板的左下角，靠近GND。</font><font style="vertical-align: inherit;">将第三定时器TIM3_CH1的第一通道分配给该引脚。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/eb7/4b2/67e/eb74b267e70140b9842408158de617e8.png"></div><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时钟设定</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使USB正常工作，微控制器必须以非常稳定的频率提供时钟，这就是为什么几乎所有USB设备都具有石英谐振器的原因。内置的RC发生器的频率稳定性不足以支持USB。但是在STM32F3 Discovery板上，由于某种原因，开发人员很贪婪，没有放石英石。但是，如果仔细研究</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电路</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您会发现</font><i><font style="vertical-align: inherit;">MCO</font></i><font style="vertical-align: inherit;">信号已连接</font><font style="vertical-align: inherit;">至输入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PF0-OSC_IN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，石英应连接</font><i><font style="vertical-align: inherit;">至此</font></i><font style="vertical-align: inherit;">。它来自装有石英的同一板上的ST-Link编程器。 “ </font><i><font style="vertical-align: inherit;">OSC时钟”</font></i><font style="vertical-align: inherit;">部分的F3发现</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">用户手册</font></a><font style="vertical-align: inherit;">（UM1570）</font><font style="vertical-align: inherit;">表示8 MHz正在</font><font style="vertical-align: inherit;">发送</font><font style="vertical-align: inherit;">到此线路。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<img width="30%" src="https://habrastorage.org/files/b5c/234/80f/b5c23480ffca498d8e52e6fef4c0892f.png"><img width="65%" src="https://habrastorage.org/files/c00/160/fb8/c00160fb809b4c7190390d8a8ccd3ac6.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，微控制器由外部源提供时钟。此模式称为旁路。在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RCC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分的外设设置菜单中，</font><font style="vertical-align: inherit;">要</font><font style="vertical-align: inherit;">选择</font><i><font style="vertical-align: inherit;">时钟</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高速时钟，请</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYPASS Clock Source</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/files/934/7e5/17e/9347e517e21540a88c922d35d881c009.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在进行更详细的时钟设置之前，我们在外围菜单中注意到，微控制器将充当USB设备。</font></font><br>
<br>
<img src="https://habrastorage.org/files/597/c20/ddb/597c20ddbe2e4c2898c90db97110e454.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您可以转到下一个大选项卡</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Clock Configuration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在这里，我们将看到一个巨大的图，该图显示了微控制器中存在哪些时钟信号，它们来自何处，如何分支，相乘和除法。我用黄色突出显示了应该注意的那些参数。</font></font><br>
<br>
<img src="https://habrastorage.org/files/1a5/9a8/596/1a59a8596d434c1f8d09ee5e8335adee.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查输入频率</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入频率</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为8 MHz。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLL Source Mux</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开关设置</font><font style="vertical-align: inherit;">为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HSE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（高速外部）以从外部源而不是内部源提供时钟。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLL-锁相环</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或PLL-锁相环用于将外部频率倍增。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将PLLMul</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">乘数</font><i><font style="vertical-align: inherit;">设置</font></i><font style="vertical-align: inherit;">为9。然后我们将达到STM32F303的最大可能频率-72 MHz。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系统时钟复用器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须位于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PLLCLK</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位置</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">以使时钟频率乘以PLL。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于USB模块，需要48 MHz，因此在USB前面放置一个1.5分频器。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意频率</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APB1定时器时钟</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位于电路的左侧。</font><font style="vertical-align: inherit;">它用于计时器，对将来对我们很有用。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果任何频率配置错误，超过最大可能值或开关处于无效位置，则CubeMX将以红色突出显示此位置。</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计时器设定</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了测量脉冲持续时间，我们将在输入捕捉模式下启动TIM3定时器。在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考手册</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，节下</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通用定时器（TIM2 / TIM3 / TIM4），</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有示出的定时器的操作的图。我用颜色突出显示了输入捕捉模式下使用的信号和寄存器。</font></font><br>
<br>
<img src="https://habrastorage.org/files/e76/54c/ea5/e7654cea52cb46c891e5a73e91068b71.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以绿色突出显示的时钟信号连续进入CNT计数器寄存器，并在每个时钟周期将其值增加1。在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预分频器PSC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分频器中，</font><font style="vertical-align: inherit;">时钟频率可能会降低以降低计数速度。</font><font style="vertical-align: inherit;">外部信号</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
输入到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIMx_CH1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边缘检测器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它识别输入信号的边沿-跃迁从0到1或从1到0。当登记前，它给以黄色突出显示两个命令：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-一个命令写入的值</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CNT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计数器</font><font style="vertical-align: inherit;">到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捕获/比较1个寄存器（CCR1）寄存器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和呼叫</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CC1I</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中断</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-用于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从模式控制器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的命令</font><font style="vertical-align: inherit;">，通过该命令将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CNT</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font><font style="vertical-align: inherit;">重置为0，并再次开始倒计时。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是时间轴中流程的说明：</font></font><br>
<br>
<img width="50%" src="https://habrastorage.org/files/3b5/80b/ab0/3b580bab0b894981b8d28eadd9f444b2.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发生中断时，我们将使用捕获的值执行操作。如果输入脉冲太频繁，并且中断处理程序中发生的动作太长，则在我们读取前一个之前，可以覆盖CCR1的值。在这种情况下，当来自CCR1的数据自动填充内存中准备好的阵列时，您需要检查Overcapture标志或应用DMA（直接内存访问）。在我们的例子中，最短的脉冲持续时间为1毫秒，并且中断处理程序将简单而又短，因此不必担心重写。</font><i><font style="vertical-align: inherit;">去</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
回</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引脚</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡</font><font style="vertical-align: inherit;">，并设置</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIM3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定时器</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外设</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">菜单</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/files/437/703/50b/43770350badf4efcb4d02a11ea2f9db0.png"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从模式：重置模式</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-表示在某些情况下定时器将复位为0。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">触发源：TI1FP1-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用来复位和启动定时器的事件是从TI1输入捕获的信号沿。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ClockSource：内部时钟</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -计时器由微控制器的内部发生器提供时钟。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通道1：输入捕捉直接模式</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -捕捉CCR1寄存器中第一个通道的间隔。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下一个较大的“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡上，我们</font><font style="vertical-align: inherit;">将进行其他计时器设置。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/db8/b67/8d8/db8b678d8f7846c9af081a0bfdb0d7b1.png"></div><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/63b/6ac/c06/63b6acc06716451399d01566635d2f87.png"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预分频器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是定时器分频器。如果为0，则频率直接从时钟总线APB时钟获取-72 MHz。如果预分频器为1，则将频率除以2，并变为36 MHz。将除数设置为71，以便将频率除以72。然后，定时器频率将为1 MHz，间隔将以1微秒的分辨率进行测量。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计数器周期</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -设置最大可能的16位值0xFFFF。该周期对于生成时隙（例如，PWM）很重要。但是周期对于捕获信号并不重要；我们将使它对于任何输入脉冲来说都很大。</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">极性选择：下降沿</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -定时器值将在输入信号的下降沿捕获。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NVIC设置”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡上，</font><font style="vertical-align: inherit;">放置一个daw</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIM3全局中断</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此与第三计时器相关的事件将产生中断。</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USB设备设置</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经注意到，该控制器将是USB设备。</font><font style="vertical-align: inherit;">由于操纵杆属于HID设备的类别，因此在“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中间件-&gt; USB_DEVICE”菜单中，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FS IP的类别：人机接口设备类别（HID）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后，CubeMX将HID设备的库连接到项目。</font></font><br>
<br>
<img src="https://habrastorage.org/files/3fe/080/472/3fe0804729bd4b2f995c5f32a9173d47.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们转到</font><font style="vertical-align: inherit;">“ </font><i><font style="vertical-align: inherit;">中间件”</font></i><font style="vertical-align: inherit;">部分</font><font style="vertical-align: inherit;">“ </font><i><font style="vertical-align: inherit;">配置”</font></i><font style="vertical-align: inherit;">选项卡上</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USB_DEVICE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置</font><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/574/ba7/dde/574ba7dde3794ce4911f955e628f7ce7.png"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">供应商ID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">产品ID</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是两个16位标识符，对于每种USB设备型号都是唯一的。 VID对应于设备制造商，每个制造商都根据自己的考虑分配PID。我找不到VID和PID的官方列表，只找到</font><font style="vertical-align: inherit;">发烧友支持</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的标识符库</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。要获得自己的供应商ID，您需要访问</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usb.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上的USB Implementers Forum，</font><font style="vertical-align: inherit;">并支付几千美元。负担不起VID的小型公司或开放源代码开发人员可以请求USB芯片制造商，并正式为其项目获得VID / PID对。此类服务由FTDI或Silicon Laboratories提供。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您连接两个具有相同VID / PID但类型不同的设备（例如，一个是HID设备，另一个是大容量存储），则操作系统将尝试为其安装相同的驱动程序，至少其中一个不管用。这就是为什么不同设备型号的VID / PID对必须唯一的原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们不是自己制造设备，所以我们不会出售和分发该设备，因此我们将保留与STMicroelectronics相对应的VID 0x0483，并提出自己的PID。默认情况下，CubeMX为HID设备提供PID 0x5710。例如，将其替换为0x57FF。</font><font style="vertical-align: inherit;">用</font><i><font style="vertical-align: inherit;">STM32 PPM-USB适配器</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
替换</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">产品字符串</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该名称将显示在Windows控制面板中的设备列表中。我们不会更改序列号（S \ N）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows检测到它检测到以前从未见过的具有VID，PID和S \ N组合的设备时，系统会为其安装适当的驱动程序。如果已经使用了VID，PID和S \ N的组合，则Windows会自动替换以前使用的驱动程序。例如，当您将闪存驱动器连接到USB时，您会看到此信息。第一次连接和安装需要一些时间。在随后的连接中，驱动器几乎立即开始工作。但是，如果您连接了相同型号但序列号不同的闪存驱动器的另一个实例，则系统将为其安装新的驱动程序，即使它具有相同的VID和PID。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我将解释为什么这很重要。</font><font style="vertical-align: inherit;">如果您在STM32上创建了带有VID，PID和S \ N的USB鼠标，将其连接到计算机，然后在不更改VID，PID和S \ N的情况下制作了USB游戏杆，则Windows会将新设备视为已经存在的鼠标在系统中使用，并且不会安装操纵杆驱动程序。</font><font style="vertical-align: inherit;">因此，操纵杆将不起作用。</font><font style="vertical-align: inherit;">因此，如果要更改设备的类型，而使VID / PID保持不变，请确保更改其序列号。</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDE的项目生成</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您需要进行的最后设置是项目生成设置。这是通过</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project-&gt; Settings完成的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在这里，我们将设置名称，目标文件夹和所需的IDE，CubeMX将在该IDE下创建项目。我选择了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDK-ARM V5</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为我使用的是Keil uVision5。在“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码生成器”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项卡上，</font><font style="vertical-align: inherit;">可以选中“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅复制必要的库文件”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复选框，以免</font><font style="vertical-align: inherit;">不必要的文件使项目混乱。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按下按钮</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">项目-&gt;生成代码</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 CubeMX将使用可在Keil uVision中打开，无需其他设置即可编译和刷新的代码创建项目。在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">的</font><i><font style="vertical-align: inherit;">main（void）</font></i><font style="vertical-align: inherit;">函数中</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已插入功能来初始化时钟，端口，计时器和USB。在其中，微控制器模块根据我们在CubeMX中设置的模式进行配置。</font></font><br>
<br>
<img src="https://habrastorage.org/files/fb6/a32/393/fb6a323933734c7cb3ac4e11550d7420.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在代码中，经常会发现这种构造：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span><font></font>
(...)<font></font>
<span class="hljs-comment">/* USER CODE END 0 */</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假定用户将其代码嵌入这些部分中。如果在CubeMX项目设置中启用了</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“在重新生成时保留用户代码”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选项</font><font style="vertical-align: inherit;">，则在二次生成现有项目期间，这些行之间包含的代码将不会被覆盖。不幸的是，仅保存了由CubeMX创建的部分。节</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ *用户代码* /</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由用户创建将会丢失。因此，如果在IDE中编写了代码之后，您想返回CubeMX并使用新设置再次生成项目，则建议制作该项目的备份副本。</font><font style="vertical-align: inherit;">建议您</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在uVision的固件设置中（Flash- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; Configure Flash Tools</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），启用</font><i><font style="vertical-align: inherit;">Flash之后重置</font></i><font style="vertical-align: inherit;">选项。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，微控制器在闪烁后立即启动。</font><font style="vertical-align: inherit;">默认情况下，它是禁用的，并且每次闪烁后，您必须按板上的Reset（重置）按钮。</font></font><br>
<br>
<img src="https://habrastorage.org/files/1e1/a3d/20d/1e1a3d20dd994c1787f8a8758fcd200e.png"><br>
<br>
<a name="ppm"></a><h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PPM解码</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PPM-脉冲位置调制-一种编码传输信号的方法，在飞机模型电子设备中非常普遍。</font><font style="vertical-align: inherit;">它是一个脉冲序列，其时间间隔对应于所传输的数值。</font></font><br>
<br>
<div style="text-align:center;"><img width="80%" src="https://habrastorage.org/files/905/3ec/257/9053ec2573f8438b9a3053f2ef408739.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据此协议，控制台将信息发送到发送无线电模块，该模块插入到背面的控制台中。放置在直升机上的许多接收器可以通过PPM为飞行控制器发送控制信号。此外，几乎所有控制台都具有连接器，用于在培训师-学生模式下连接第二个控制台以及将控制台连接到通常也使用PPM的模拟器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用逻辑分析仪从Turnigy 9X的仿真器输出中写入信号：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/53e/da5/319/53eda5319a6d45b59ee6e265de445992.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个序列都编码遥控器上控件的当前状态。通常前四个值（也称为通道）对应于模拟摇杆的位置，而后四个对应于拨动开关或电位计的位置。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
控件的最小位置对应于间隔1000μs，最大间隔-2000μs，平均位置-1500μs。脉冲或帧的突发之间间隔较长的时间，间隔为20–25 ms。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们仔细看一下信号：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/703/86d/84e/70386d84efe24577a958767f8c5b7ae9.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，三根摇杆位于中间位置（1、3、4），一根位于极限位置（2）。</font><font style="vertical-align: inherit;">三个拨动开关已关闭（5、6、7），最后一个已打开（8）。</font><font style="vertical-align: inherit;">作为适配器的微控制器必须捕获这样的序列，将值添加到数组中，并通过USB作为操纵杆的命令将其发送出去。</font><font style="vertical-align: inherit;">让我们写一个脉冲序列解码器。</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捕获中断</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化之后</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">在main </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while循环</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之前</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">从通道1以输入捕获捕获模式启动TIM3计时器，并产生捕获中断。</font><font style="vertical-align: inherit;">为此，请使用HAL中的相应功能：</font></font><br>
<br>
<pre><code class="cpp hljs">HAL_TIM_IC_Start_IT(&amp;htim3, TIM_CHANNEL_1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font><i><font style="vertical-align: inherit;">main.c中</font></i><font style="vertical-align: inherit;">声明</font><font style="vertical-align: inherit;">
的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">htim3</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">是TIM3计时器处理程序，它包含与计时器相关的所有结构和变量：初始化参数，指向所有计时器寄存器的指针（计数器值，除法器，所有设置，中断标志），指针在与此计时器配合使用的处理程序DMA等上开发人员无需查找哪个寄存器中的哪些位负责什么，而无需手动设置和重置它们。将处理程序传递给HAL函数就足够了。 HAL库将自行完成其余工作。</font><font style="vertical-align: inherit;">
HAL结构原理在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">STM32F3xx HAL驱动程序</font></a><font style="vertical-align: inherit;">说明文档中有更详细的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">描述</font></a><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（UM1786）。应该注意的是，HAL库本身有充分的文档记录。要了解HAL如何用于计时器以及如何使用它，可以阅读</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32f3xx_hal_tim.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32f3xx_hal_tim.c文件中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的注释</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于TIM3计时器生成的每个中断，都会</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用TIM3_IRQHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">处理程序</font><font style="vertical-align: inherit;">。它位于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32f3xx_it.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件中</font><font style="vertical-align: inherit;">，依次</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有计时器的标准</font><i><font style="vertical-align: inherit;">HAL_TIM_IRQHandler</font></i><font style="vertical-align: inherit;">处理程序</font><font style="vertical-align: inherit;">，并将指向htim3结构的指针传递给它。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TIM3_IRQHandler</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  <span class="hljs-comment">/* USER CODE BEGIN TIM3_IRQn 0 */</span><font></font>
<font></font>
  <span class="hljs-comment">/* USER CODE END TIM3_IRQn 0 */</span><font></font>
  HAL_TIM_IRQHandler(&amp;htim3);<font></font>
  <span class="hljs-comment">/* USER CODE BEGIN TIM3_IRQn 1 */</span><font></font>
<font></font>
  <span class="hljs-comment">/* USER CODE END TIM3_IRQn 1 */</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们查看</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAL_TIM_IRQHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stm32f3xx_hal_tim.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><i><font style="vertical-align: inherit;">则会</font></i><font style="vertical-align: inherit;">看到一个巨大的处理程序，该处理程序检查中断标志的计时器是否导致回调函数，并在执行后清除该标志。</font><font style="vertical-align: inherit;">如果发生捕获事件，它将调用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAL_TIM_IC_CaptureCallback</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">看起来像这样：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">__weak <span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>
</span>{
<span class="hljs-comment">/* NOTE : This function Should not be modified, when the callback is needed, the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
*/</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着我们可以在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c中</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">覆盖此函数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，</font><font style="vertical-align: inherit;">将此回调</font><font style="vertical-align: inherit;">插入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int main（void）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数之前</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>
</span>{<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想看看中断是如何执行的。</font><font style="vertical-align: inherit;">快速添加以下结论之一：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>
</span>{<font></font>
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_SET);<font></font>
  __nop();__nop();__nop();__nop();__nop();__nop();<font></font>
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_8, GPIO_PIN_RESET);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PE8引脚已被初始化为输出。</font><font style="vertical-align: inherit;">在打开和关闭之间，插入</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__nop（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指令</font><font style="vertical-align: inherit;">，这形成1个时钟周期的延迟。</font><font style="vertical-align: inherit;">这样做是为了使我的$ 8中文逻辑分析仪在24 MHz下运行时不会错过来自72 MHz微控制器的太短脉冲。</font><font style="vertical-align: inherit;">现在，编译项目</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project-&gt; Build target</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并询问</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">控制器</font><i><font style="vertical-align: inherit;">-&gt; Download</font></i><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将把PPM从远程连接到PC6，并查看PC6和PE8与分析仪之间的情况。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/abf/64c/e2c/abf64ce2c6874057933df9edb58dff8f.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回调实际上是在正确的时间进行的-在输入信号从1转换为0之后。因此，一切都正确完成了。</font></font><br>
<br>
<h5><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">捕获和处理捕获的数据</font></font></b></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将对回调进行编辑，以便将每个捕获的值</font><font style="vertical-align: inherit;">保持不变地</font><font style="vertical-align: inherit;">添加到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capture_value</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缓冲区中</font><font style="vertical-align: inherit;">。如果计时器捕获到非常大的值（大于5000μs），则意味着记录了暂停，数据包已全部接收，可以进行处理。将处理后的值添加到</font><font style="vertical-align: inherit;">5个元素</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rc_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">中。在前四个中，操纵杆位置减小到范围[0; [1000]，在第五个中，根据拨动开关设置各个位，这将被解释为游戏手柄上的按下按钮。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint16_t</span> captured_value[<span class="hljs-number">8</span>] = {<span class="hljs-number">0</span>};
<span class="hljs-keyword">uint16_t</span> rc_data[<span class="hljs-number">5</span>] = {<span class="hljs-number">0</span>};
<span class="hljs-keyword">uint8_t</span> pointer = <span class="hljs-number">0</span>;
<span class="hljs-keyword">uint8_t</span> data_ready = <span class="hljs-number">0</span>;<font></font>
<font></font>
...<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">HAL_TIM_IC_CaptureCallback</span><span class="hljs-params">(TIM_HandleTypeDef *htim)</span>
</span>{
    <span class="hljs-keyword">uint8_t</span> i;
    <span class="hljs-keyword">uint16_t</span> temp;
    <span class="hljs-comment">//     </span><font></font>
    temp = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);<font></font>
    <span class="hljs-comment">//    , ,  </span>
    <span class="hljs-keyword">if</span> ((temp &gt; <span class="hljs-number">5000</span>) &amp;&amp; (!data_ready))<font></font>
    {<font></font>
        pointer = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//        [0;1000]</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (captured_value[i] &lt; <span class="hljs-number">1000</span>)<font></font>
                captured_value[i] = <span class="hljs-number">1000</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (captured_value[i] &gt; <span class="hljs-number">2000</span>)<font></font>
                captured_value[i] = <span class="hljs-number">2000</span>;<font></font>
            rc_data[i] = captured_value[i]<span class="hljs-number">-1000</span>;<font></font>
        };<font></font>
        <span class="hljs-comment">//     </span>
        rc_data[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span> (captured_value[<span class="hljs-number">4</span>] &gt; <span class="hljs-number">1500</span>)<font></font>
            rc_data[<span class="hljs-number">4</span>] |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">4</span>);
        <span class="hljs-keyword">if</span> (captured_value[<span class="hljs-number">5</span>] &gt; <span class="hljs-number">1500</span>)<font></font>
            rc_data[<span class="hljs-number">4</span>] |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>);
        <span class="hljs-keyword">if</span> (captured_value[<span class="hljs-number">6</span>] &gt; <span class="hljs-number">1500</span>)<font></font>
            rc_data[<span class="hljs-number">4</span>] |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">6</span>);
        <span class="hljs-keyword">if</span> (captured_value[<span class="hljs-number">7</span>] &gt; <span class="hljs-number">1500</span>)<font></font>
            rc_data[<span class="hljs-number">4</span>] |= (<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">7</span>);<font></font>
        data_ready = <span class="hljs-number">1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> <span class="hljs-comment">//      </span><font></font>
    {<font></font>
        captured_value[pointer] = temp;<font></font>
        pointer++;<font></font>
    };<font></font>
    <span class="hljs-keyword">if</span> (pointer == <span class="hljs-number">8</span>) <span class="hljs-comment">//   </span>
        pointer = <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我解释一下为什么我将与按钮相对应的位不是放在低4位，而是放在第五到第八位。在模拟器中，应该连接Xbox上的游戏板，其中使用了LB，RB，“开始”和“返回”按钮，并且它们的编号从5到8。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在主循环中，data_ready标志将连续旋转，通过该标志将数据发送到计算机。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (data_ready)<font></font>
  {<font></font>
    <span class="hljs-comment">//      </span>
    data_ready = <span class="hljs-number">0</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要检查它是如何工作的，请连接遥控器，再次对其进行编译和刷新，然后开始调试</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug-&gt; Start / Stop Debug Session</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
打开用于跟踪变量的窗口，然后单击“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查看”-&gt;“监视Windows”-&gt;“监视1”，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后在其中添加</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">captured_value</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rc_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试”-&gt;“运行”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令</font><font style="vertical-align: inherit;">实时</font><font style="vertical-align: inherit;">开始调试</font><font style="vertical-align: inherit;">，甚至无需添加断点，就可以看到数字在摇杆之后如何变化。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/5cf/7da/c9c/5cf7dac9c152498e89ea3948a8549efb.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，您需要以操纵杆命令的形式将数据发送到计算机。</font></font><br>
<br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置HID设备并创建HID报告描述符</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USB HID（人机接口设备）是用于人机交互的一类设备。这些包括键盘，鼠标，操纵杆，游戏板，触摸板。 HID设备的主要优点是，它们不需要任何操作系统（Windows，OS X，Android甚至iOS）中的特殊驱动程序（通过USB-Lightning适配器）。详细说明可以在文档“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设备类定义”中找到</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。创建PPM-USB适配器需要了解的主要内容是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID报告</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID报告描述符</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HID设备以预定义的格式将字节数据包发送到计算机。每个这样的程序包都是一个HID报告。设备在连接时会通知计算机有关数据格式的信息，并发送HID报告描述符，数据包描述，以指示数据包包含多少字节以及数据包中每个字节和位的用途。例如，简单鼠标的HID报告由四个字节组成：第一个字节包含有关按下的按钮的信息，第二个和第三个字节包含光标沿X和Y的相对移动，第四个字节包含滚轮的旋转。报告描述符以字节数组形式存储在设备控制器内存中。</font></font><br>
<br>
<div style="text-align:center;"><img width="35%" src="https://habrastorage.org/files/22f/dd2/aa6/22fdd2aa67154365a6f89f6a2f7f2798.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在创建描述符之前，我想分别介绍术语。在英语环境中，两个术语很常见- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏杆</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏手柄</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 “ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操纵杆</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”一词</font><font style="vertical-align: inherit;">通常称为用一只手握住并向不同方向倾斜的操纵器，而</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">游戏手柄</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是指用两只手握住的带有按钮和</font><i><font style="vertical-align: inherit;">操纵杆</font></i><font style="vertical-align: inherit;">的设备。讲俄语的用户通常将操纵杆称为“另一个”。在HID设备的说明中，操纵杆和游戏手柄之间存在差异。飞机模型控制台在功能上与游戏手柄更为相似，因此将来我有时会使用术语“游戏手柄”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们生成了一个项目，指示该设备将充当人机接口设备。</font><font style="vertical-align: inherit;">这意味着USB HID库已连接到项目，并且已经生成了设备描述符。</font><font style="vertical-align: inherit;">它位于</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usbd_hid.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件中</font><font style="vertical-align: inherit;">，描述了鼠标报告，如下所示：</font></font><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID_Mouse_Report_Descriptor</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">__ALIGN_BEGIN <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> HID_MOUSE_ReportDesc[HID_MOUSE_REPORT_DESC_SIZE]  __ALIGN_END =<font></font>
{<font></font>
  <span class="hljs-number">0x05</span>,   <span class="hljs-number">0x01</span>,
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x02</span>,
  <span class="hljs-number">0xA1</span>,   <span class="hljs-number">0x01</span>,
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x01</span>,<font></font>
<font></font>
  <span class="hljs-number">0xA1</span>,   <span class="hljs-number">0x00</span>,
  <span class="hljs-number">0x05</span>,   <span class="hljs-number">0x09</span>,
  <span class="hljs-number">0x19</span>,   <span class="hljs-number">0x01</span>,
  <span class="hljs-number">0x29</span>,   <span class="hljs-number">0x03</span>,<font></font>
<font></font>
  <span class="hljs-number">0x15</span>,   <span class="hljs-number">0x00</span>,
  <span class="hljs-number">0x25</span>,   <span class="hljs-number">0x01</span>,
  <span class="hljs-number">0x95</span>,   <span class="hljs-number">0x03</span>,
  <span class="hljs-number">0x75</span>,   <span class="hljs-number">0x01</span>,<font></font>
<font></font>
  <span class="hljs-number">0x81</span>,   <span class="hljs-number">0x02</span>,
  <span class="hljs-number">0x95</span>,   <span class="hljs-number">0x01</span>,
  <span class="hljs-number">0x75</span>,   <span class="hljs-number">0x05</span>,
  <span class="hljs-number">0x81</span>,   <span class="hljs-number">0x01</span>,<font></font>
<font></font>
  <span class="hljs-number">0x05</span>,   <span class="hljs-number">0x01</span>,
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x30</span>,
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x31</span>,
  <span class="hljs-number">0x09</span>,   <span class="hljs-number">0x38</span>,<font></font>
<font></font>
  <span class="hljs-number">0x15</span>,   <span class="hljs-number">0x81</span>,
  <span class="hljs-number">0x25</span>,   <span class="hljs-number">0x7F</span>,
  <span class="hljs-number">0x75</span>,   <span class="hljs-number">0x08</span>,
  <span class="hljs-number">0x95</span>,   <span class="hljs-number">0x03</span>,<font></font>
<font></font>
  <span class="hljs-number">0x81</span>,   <span class="hljs-number">0x06</span>,
  <span class="hljs-number">0xC0</span>,   <span class="hljs-number">0x09</span>,
  <span class="hljs-number">0x3c</span>,   <span class="hljs-number">0x05</span>,
  <span class="hljs-number">0xff</span>,   <span class="hljs-number">0x09</span>,<font></font>
<font></font>
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0x15</span>,
  <span class="hljs-number">0x00</span>,   <span class="hljs-number">0x25</span>,
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0x75</span>,
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0x95</span>,<font></font>
<font></font>
  <span class="hljs-number">0x02</span>,   <span class="hljs-number">0xb1</span>,
  <span class="hljs-number">0x22</span>,   <span class="hljs-number">0x75</span>,
  <span class="hljs-number">0x06</span>,   <span class="hljs-number">0x95</span>,
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0xb1</span>,<font></font>
<font></font>
  <span class="hljs-number">0x01</span>,   <span class="hljs-number">0xc0</span><font></font>
};<font></font>
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手动创建HID报告描述符非常耗时。</font><font style="vertical-align: inherit;">为了简化该任务，有一个称为</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID描述符工具</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（DT）的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">工具</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">该程序可以为您的设备创建描述符。</font><font style="vertical-align: inherit;">在随附的归档文件中，您可以找到用于不同设备的描述符的几个示例。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/a3c/6fd/07c/a3c6fd07c997415ab94ba603edda628d.png"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇有关为鼠标和键盘创建自己的HID描述符的很好的文章（英文）。我将用俄语告诉您如何制作游戏手柄。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
控制台发送的HID报告必须包含两个模拟摇杆轴的四个16位值和按钮的16个一位值。总共10个字节。在DT中创建的句柄如下所示：</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-number">0x05</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">// USAGE_PAGE (Generic Desktop)</span>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x05</span>,                    <span class="hljs-comment">// USAGE (Game Pad)</span>
    <span class="hljs-number">0xa1</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">// COLLECTION (Application)</span>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">//   USAGE (Pointer)</span>
    <span class="hljs-number">0xa1</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//   COLLECTION (Physical)</span>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x30</span>,                    <span class="hljs-comment">//     USAGE (X)</span>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x31</span>,                    <span class="hljs-comment">//     USAGE (Y)</span>
    <span class="hljs-number">0x15</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//     LOGICAL_MINIMUM (0)</span>
    <span class="hljs-number">0x26</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x03</span>,              <span class="hljs-comment">//     LOGICAL_MAXIMUM (1000)</span>
    <span class="hljs-number">0x75</span>, <span class="hljs-number">0x10</span>,                    <span class="hljs-comment">//     REPORT_SIZE (16)</span>
    <span class="hljs-number">0x95</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//     REPORT_COUNT (2)</span>
    <span class="hljs-number">0x81</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//     INPUT (Data,Var,Abs)</span>
    <span class="hljs-number">0xc0</span>,                          <span class="hljs-comment">//   END_COLLECTION</span>
    <span class="hljs-number">0xa1</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//   COLLECTION (Physical)</span>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x33</span>,                    <span class="hljs-comment">//     USAGE (Rx)</span>
    <span class="hljs-number">0x09</span>, <span class="hljs-number">0x34</span>,                    <span class="hljs-comment">//     USAGE (Ry)</span>
    <span class="hljs-number">0x15</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//     LOGICAL_MINIMUM (0)</span>
    <span class="hljs-number">0x26</span>, <span class="hljs-number">0xe8</span>, <span class="hljs-number">0x03</span>,              <span class="hljs-comment">//     LOGICAL_MAXIMUM (1000)</span>
    <span class="hljs-number">0x75</span>, <span class="hljs-number">0x10</span>,                    <span class="hljs-comment">//     REPORT_SIZE (16)</span>
    <span class="hljs-number">0x95</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//     REPORT_COUNT (2)</span>
    <span class="hljs-number">0x81</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//     INPUT (Data,Var,Abs)</span>
    <span class="hljs-number">0xc0</span>,                          <span class="hljs-comment">//   END_COLLECTION</span>
    <span class="hljs-number">0x05</span>, <span class="hljs-number">0x09</span>,                    <span class="hljs-comment">//   USAGE_PAGE (Button)</span>
    <span class="hljs-number">0x19</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">//   USAGE_MINIMUM (Button 1)</span>
    <span class="hljs-number">0x29</span>, <span class="hljs-number">0x10</span>,                    <span class="hljs-comment">//   USAGE_MAXIMUM (Button 16)</span>
    <span class="hljs-number">0x15</span>, <span class="hljs-number">0x00</span>,                    <span class="hljs-comment">//   LOGICAL_MINIMUM (0)</span>
    <span class="hljs-number">0x25</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">//   LOGICAL_MAXIMUM (1)</span>
    <span class="hljs-number">0x75</span>, <span class="hljs-number">0x01</span>,                    <span class="hljs-comment">//   REPORT_SIZE (1)</span>
    <span class="hljs-number">0x95</span>, <span class="hljs-number">0x10</span>,                    <span class="hljs-comment">//   REPORT_COUNT (16)</span>
    <span class="hljs-number">0x81</span>, <span class="hljs-number">0x02</span>,                    <span class="hljs-comment">//   INPUT (Data,Var,Abs)</span>
    <span class="hljs-number">0xc0</span>                           <span class="hljs-comment">// END_COLLECTION</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它看起来不亚于鼠标描述符。</font><font style="vertical-align: inherit;">但是，如果您了解每一行的含义，那么一切都会变得很容易理解和合乎逻辑。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE显示系统应如何解释更进一步的数据。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用法类型有很多，它们分为几类-用法页面。</font><font style="vertical-align: inherit;">因此，为了选择特定的用法，必须首先参考相应的USAGE_PAGE。</font><font style="vertical-align: inherit;">关于什么用法可以在“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隐藏用法表”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文档中找到</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在描述符的最开始，我们指示将描述操纵杆：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USAGE_PAGE（通用桌面）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE（游戏</font><font style="vertical-align: inherit;">手柄</font><font style="vertical-align: inherit;">）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
COLLECTION合并了几个相关的数据集。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
物理收集用于与一个特定几何点（例如，一根模拟棒）有关的数据。</font><font style="vertical-align: inherit;">应用程序集合用于在一个设备中组合不同的功能。</font><font style="vertical-align: inherit;">例如，具有集成触控板的键盘可能具有两个Application Collection。</font><font style="vertical-align: inherit;">我们仅描述操纵杆，这意味着该集合将是其中一个：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COLLECTION（应用程序）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
END_COLLECTION</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之后，您需要指定将描述传输坐标的元素。</font><font style="vertical-align: inherit;">使用指针用于描述鼠标，操纵杆，游戏手柄，数字转换器：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用方法（指针）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下是对集合中的模拟摇杆的描述：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集合（物理）</font></font><br>
 <blockquote>USAGE (X)<br>
 USAGE (Y)<br>
 LOGICAL_MINIMUM (0)<br>
 LOGICAL_MAXIMUM (1000)<br>
 REPORT_SIZE (16)<br>
 REPORT_COUNT (2)<br>
 INPUT (Data,Var,Abs)</blockquote>END_COLLECTION</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的用法表示使用X和Y这两个轴上的偏差值</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.LOGICAL_MINIMUM和LOGICAL_MAXIMUM指定了所传输的值可以变化的程度。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
REPORT_COUNT和REPORT_SIZE分别设置要传输多少个数字和什么大小，即两个16位数字。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INPUT（数据，变量，绝对值）表示数据从设备到计算机，并且这些数据可以更改。我们的价值观是绝对的。例如，相对值来自鼠标以移动光标。有时数据被描述为Const，而不是Var。这对于传输非有效位是必需的。例如，在具有三个按钮的鼠标报告中，将传输按钮的3位Var和Const的5位以将传输大小补充为一个字节。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，X和Y轴的描述组合在一起。</font><font style="vertical-align: inherit;">它们具有相同的大小，相同的限制。</font><font style="vertical-align: inherit;">可以如下描述同一根模拟棒，分别描述每个轴。</font><font style="vertical-align: inherit;">这样的描述符将类似于上一个描述符：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集合（物理）</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用法（X）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MINIMUM（0）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MAXIMUM（1000）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_SIZE（16）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_COUNT（1）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 输入（数据，变量，绝对值）</font></font></blockquote><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用法（Y）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MINIMUM（0）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MAXIMUM（1000）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_SIZE（16）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_COUNT（1）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 输入（数据，变量，绝对值）</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END_COLLECTION</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一个摇杆之后，描述了第二个模拟摇杆。</font><font style="vertical-align: inherit;">它的轴有不同的用法，因此您可以将它们与第一个操纵杆区分开-Rx和Ry：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集合（物理）</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用量（Rx）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 使用量（Ry）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MINIMUM（0）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 LOGICAL_MAXIMUM（1000）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_SIZE（16）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 REPORT_COUNT（2）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 输入（数据，变量，绝对值）</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">END_COLLECTION</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您需要描述游戏手柄的几个按钮。</font><font style="vertical-align: inherit;">可以按照以下步骤进行：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USAGE_PAGE（按钮）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE（按钮1）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE（按钮2）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE（按钮3）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE（按钮16）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过使用范围，可以减少相同类型按钮的繁琐录制：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">USAGE_PAGE（按钮）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE_MINIMUM（按钮1）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
USAGE_MAXIMUM（按钮16）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按钮发送的数据是16个单位值，范围从0到1：</font></font><br>
<blockquote>LOGICAL_MINIMUM (0)<br>
LOGICAL_MAXIMUM (1)<br>
REPORT_SIZE (1)<br>
REPORT_COUNT (16)<br>
INPUT (Data,Var,Abs)</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
描述符中各行的顺序并不严格。例如，可以在“用法”（按钮）之前写入Logical_Minimum和Logical_Maximum，或者可以交换Report_Size和Report_Count行。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
输入命令必须具有用于数据传输的所有必需参数（用法，最小，最大值，大小，计数），这一点很重要。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
形成描述符后，可以使用“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析描述符”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命令检查它</font><font style="vertical-align: inherit;">是否存在错误。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果一切正常，则将其导出为扩展名h。在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usbd_hid.c</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件中</font><i><font style="vertical-align: inherit;">，</font></i><font style="vertical-align: inherit;">将描述符替换为新的描述符，并在</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usbd_hid.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HID_MOUSE_REPORT_DESC_SIZE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述符</font><i><font style="vertical-align: inherit;">的</font></i><font style="vertical-align: inherit;">大小</font><font style="vertical-align: inherit;">从74调整为61。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_ready</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标志发送报告</font><font style="vertical-align: inherit;">。为此</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c我们将</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usbd_hid.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标头文件，</font><font style="vertical-align: inherit;">并在主循环中调用报告发送功能。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rc_data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">的类型为uint16，因此指向它的指针必须转换为8位类型，并且将大小传递为10，而不是5。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"usbd_hid.h"</span></span><font></font>
...<font></font>
<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (data_ready)<font></font>
  {<font></font>
    USBD_HID_SendReport(&amp;hUsbDeviceFS, (<span class="hljs-keyword">uint8_t</span>*)rc_data, <span class="hljs-number">10</span>);<font></font>
    data_ready = <span class="hljs-number">0</span>;<font></font>
  };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们编译项目并再次刷新它。</font></font><br>
<br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接与使用</font></font></b></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将USB电缆从ST-LINK USB接口重新连接到USER USB接口。</font><font style="vertical-align: inherit;">Windows将检测到新设备并自动安装驱动程序。</font><font style="vertical-align: inherit;">让我们转到“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">控制面板”-&gt;“设备和打印机”，</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并查看带有游戏手柄图标的STM32 USB-PPM适配器设备。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/1ee/5ad/846/1ee5ad84654545dfbcec807073ef8207.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在设备的参数中，您可以看到十字线在操纵杆移动后如何围绕田野移动以及列如何移动，并且按钮符号从拨动开关点亮。</font><font style="vertical-align: inherit;">不需要校准，因为已经在描述符中设置了最小值和最大值。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/files/52c/4b0/9db/52c4b09db3074871b917aa74b3375de6.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
启动FPV FreeRider，我们将看到在绘制的虚拟游戏手柄的主屏幕上，操纵杆如何根据我们的遥控器移动。</font><font style="vertical-align: inherit;">如果由于某种原因未正确分配轴，则可以在“ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">校准控制器”</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">部分中重新配置它们</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与遥控器上的按钮相对应的拨动开关用于切换飞行模式（杂技/稳定），切换摄像头视图（从板上/从地面），从头开始飞行或暂时打开比赛。</font></font><br>
<br>
<div style="text-align:center;"><img width="70%" src="https://habrastorage.org/files/153/bc2/3a8/153bc23a87bd4fedad1dd9b04c2aae22.png"></div><br>
<br>
<h3><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">飞！</font></font></b></h3><br>
<iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://www.youtube.com/embed/ilMeTba4EOE%3Ffeature%3Doembed&amp;usg=ALkJrhipxPaGdtfnUtzI0ua7sxzBYV3mSg" frameborder="0" allowfullscreen=""></iframe><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在视频上-我几天训练的结果。当我以自动调平飞行而不是杂技模式飞行时，就像所有FPV赛车大师一样。在acro模式下，如果松开摇杆，直升机将不会自动返回到水平位置，而是继续以与飞行时相同的角度飞行。以acro模式进行管理要困难得多，但是您可以实现更高的速度，机动性，空中动荡甚至颠倒飞行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
致</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">查普大师赛</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我仍然很遥远，但我仍在继续训练，我可以肯定地说，赛车微型直升机的想法使我更加感兴趣。</font><font style="vertical-align: inherit;">很快，我肯定会不再在模拟器中从事它的建造和飞行，而是要在严酷的现实中，发生真正的坠毁，螺旋桨损坏，电动机损坏以及电池烧坏的情况。</font><font style="vertical-align: inherit;">但这是其他文章的主题：)</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keil uVision 5和STM32CubeMX的项目位于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub上</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN384813/">https://habr.com/ru/post/zh-CN384813/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN384801/index.html">庞贝的最后一天：意大利科学家扫描了灾难受害者的遗体</a></li>
<li><a href="../zh-CN384803/index.html">Пол Грэм: Идеи для «органического» стартапа</a></li>
<li><a href="../zh-CN384805/index.html">IFixit专家拆除了AppleTV，Apple从AppStore卸载了iFixit应用程序</a></li>
<li><a href="../zh-CN384809/index.html">纸还是“数字”？两者：NeoLAB Convergence Neo smartpen N2智能笔的评测</a></li>
<li><a href="../zh-CN384811/index.html">专家意见：电子中的半导体材料</a></li>
<li><a href="../zh-CN384815/index.html">保障儿童安全和父母平安的电话：新型bb-mobile的评述</a></li>
<li><a href="../zh-CN384817/index.html">数千张阿波罗照片已上传至Flickr</a></li>
<li><a href="../zh-CN384819/index.html">现在，“ Google”不再是“不是邪恶的”，而是“在做正确的事情”</a></li>
<li><a href="../zh-CN384821/index.html">学生介绍了一种手套，可以使言语障碍者进行交流</a></li>
<li><a href="../zh-CN384823/index.html">推广手机游戏的非标准方式</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>