<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ© ğŸ““ â†•ï¸ "Sepertinya ini sudah terjadi?" Cari insiden dan klaim serupa âœ‹ğŸ¿ ğŸŒ ğŸ”—</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Setiap orang yang menghabiskan waktu tertentu untuk mendukung sistem terbiasa dengan perasaan dÃ©jÃ  vu ketika mereka menerima aplikasi baru: "seperti i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Sepertinya ini sudah terjadi?" Cari insiden dan klaim serupa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472210/"><p>  Setiap orang yang menghabiskan waktu tertentu untuk mendukung sistem terbiasa dengan perasaan dÃ©jÃ  vu ketika mereka menerima aplikasi baru: "seperti itu, itu sudah beres, tapi saya tidak ingat bagaimana tepatnya".  Anda dapat menghabiskan waktu, mempelajari aplikasi-aplikasi sebelumnya dan mencoba menemukan yang serupa.  Ini akan membantu: insiden akan ditutup lebih cepat, atau bahkan mungkin mendeteksi akar penyebab dan menutup masalah sekali dan untuk semua. </p><br><p>  Karyawan â€œmudaâ€ yang baru saja bergabung dengan tim tidak memiliki kisah seperti itu di kepala mereka.  Kemungkinan besar, mereka tidak tahu bahwa kejadian serupa, misalnya, terjadi enam bulan hingga setahun yang lalu.  Dan kolega dari kamar sebelah memutuskan kejadian itu. </p><br><p>  Kemungkinan besar, karyawan "muda" tidak akan mencari sesuatu yang serupa dalam database kejadian, tetapi akan menyelesaikan masalah dari awal.  Luangkan lebih banyak waktu, dapatkan pengalaman, dan waktu berikutnya akan mengatasi lebih cepat.  Atau mungkin mereka akan segera melupakannya di bawah aliran aplikasi baru.  Dan lain kali semuanya akan terjadi lagi. </p><br><p>  Kami sudah menggunakan model ML untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengklasifikasikan insiden</a> .  Untuk membantu tim kami memproses aplikasi lebih efisien, kami telah membuat model ML lain untuk menyiapkan daftar "insiden serupa yang sebelumnya ditutup".  Detail - di bawah potongan. </p><a name="habracut"></a><br><h2 id="chto-nam-nuzhno">  Apa yang kita butuhkan </h2><br><p>  Untuk setiap insiden yang masuk, perlu untuk menemukan insiden tertutup "serupa" dalam sejarah.  Definisi "kesamaan" harus terjadi pada awal insiden, lebih disukai sebelum staf pendukung memulai analisis. </p><br><p>  Untuk membandingkan insiden, perlu menggunakan informasi yang disediakan oleh pengguna saat menghubungi: deskripsi singkat, deskripsi terperinci (jika ada), atribut apa pun dari catatan pengguna. </p><br><p>  Tim mendukung 4 kelompok sistem.  Jumlah total insiden yang ingin saya gunakan untuk mencari yang serupa adalah sekitar 10 ribu. </p><br><h2 id="pervoe-reshenie">  Keputusan pertama </h2><br><p>  Tidak ada informasi terverifikasi tentang "kesamaan" insiden yang ada.  Jadi opsi canggih untuk melatih jaringan Siam harus ditunda untuk saat ini. <br>  Hal pertama yang terlintas dalam pikiran adalah pengelompokan sederhana "kantong kata-kata" yang terdiri dari isi banding. </p><br><p>  Dalam hal ini, proses penanganan insiden adalah sebagai berikut: </p><br><ol><li>  Sorot fragmen teks yang diperlukan </li><li>  Pra-pemrosesan / pembersihan teks </li><li>  Vektorisasi TF-IDF </li><li>  Temukan tetangga terdekat Anda </li></ol><br><p>  Jelas bahwa dengan pendekatan yang dijelaskan, kesamaan akan didasarkan pada perbandingan kamus: menggunakan kata-kata yang sama atau n-gram dalam dua insiden yang berbeda akan dianggap sebagai "kesamaan". </p><br><p>  Tentu saja, ini adalah pendekatan yang cukup disederhanakan.  Tetapi dengan mengingat bahwa kami mengevaluasi teks-teks mengenai pengguna, jika masalahnya dijelaskan dengan kata-kata yang serupa - kemungkinan besar insidennya serupa.  Selain teks, Anda dapat menambahkan nama departemen pengguna, berharap bahwa pengguna dari departemen yang sama di organisasi yang berbeda akan memiliki masalah yang sama. </p><br><h3 id="vydelenie-neobhodimyh-tekstovyh-fragmentov">  Sorot fragmen teks yang diperlukan </h3><br><p>  Data insiden yang kami dapatkan dari service-now.com dengan cara yang paling sederhana - dengan menjalankan laporan khusus secara terprogram dan menerima hasilnya dalam bentuk file CSV. </p><br><p>  Data pada pesan yang dipertukarkan antara dukungan dan pengguna sebagai bagian dari insiden dikembalikan dalam kasus ini dalam bentuk satu bidang teks besar, dengan seluruh riwayat korespondensi. </p><br><p>  Informasi tentang panggilan pertama dari bidang seperti itu harus "dipotong" dengan ekspresi reguler. </p><br><ul><li>  Semua pesan dipisahkan oleh garis karakteristik &lt;when&gt; - &lt;who&gt;. </li><li>  Pesan sering diakhiri dengan tanda tangan resmi, terutama jika permohonan diajukan melalui email.  Informasi ini secara nyata "fonil" ada dalam daftar kata-kata penting, jadi tanda tangannya juga harus dihapus. </li></ul><br><p>  Ternyata sesuatu seperti ini: </p><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_first_message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messages)</span></span></span><span class="hljs-function">:</span></span> res = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(messages) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># take the first message spl = re.split("\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2} - ((\w+((\s|-)\w+)?,(\s\w+)+)|\w{9}|guest)\s\(\w+\s\w+\)\n", messages.lower()) res = spl[-1] # cut off "mail footer" with finalization statements res = re.split("(best|kind)(\s)+regard(s)+", res)[0] # cut off "mail footer" with embedded pictures res = re.split("\[cid:", res)[0] # cut off "mail footer" with phone prefix res = re.split("\+(\d(\s|-)?){7}", res)[0] return res</span></span></code> </pre> <br><h3 id="predvaritelnaya-obrabotka-tekstov-incidenta">  Memproses teks insiden </h3><br><p>  Untuk meningkatkan kualitas klasifikasi, teks banding telah diproses terlebih dahulu. </p><br><p>  Menggunakan seperangkat ekspresi reguler dalam deskripsi kejadian, fragmen karakteristik ditemukan: tanggal, nama server, kode produk, alamat IP, alamat web, bentuk nama yang salah, dll.  Fragmen seperti itu diganti dengan token konsep yang sesuai. </p><br><p>  Pada akhirnya, gagap digunakan untuk membawa kata-kata ke bentuk umum.  Ini memungkinkan kita untuk menyingkirkan bentuk jamak dan akhiran kata kerja.  <code>snowballstemmer</code> terkenal digunakan sebagai stemmer. </p><br><p>  Semua proses pemrosesan digabungkan menjadi satu kelas transformasi, yang dapat digunakan dalam proses yang berbeda. </p><br><p>  By the way, ternyata (percobaan, tentu saja) bahwa metode <code>stemmer.stemWord()</code> tidak aman thread.  Oleh karena itu, jika Anda mencoba menerapkan pemrosesan teks paralel dalam pipa, misalnya, menggunakan <code>joblib</code> / tertunda, maka akses ke instance umum stemmer harus dilindungi dengan kunci. </p><br><pre> <code class="python hljs">__replacements = [ (<span class="hljs-string"><span class="hljs-string">'(\d{1,3}\.){3}\d{1,3}'</span></span>, <span class="hljs-string"><span class="hljs-string">'IPV4'</span></span>), (<span class="hljs-string"><span class="hljs-string">'(?&lt;=\W)((\d{2}[-\/ \.]?){2}(19|20)\d{2})|(19|20)\d{2}([-\/ \.]?\d{2}){2}(?=\W)'</span></span>, <span class="hljs-string"><span class="hljs-string">'YYYYMMDD'</span></span>), (<span class="hljs-string"><span class="hljs-string">'(?&lt;=\W)(19|20)\d{2}(?=\W)'</span></span>, <span class="hljs-string"><span class="hljs-string">'YYYY'</span></span>), (<span class="hljs-string"><span class="hljs-string">'(?&lt;=\W)(0|1)?\d\s?(am|pm)(?=\W)'</span></span>, <span class="hljs-string"><span class="hljs-string">'HOUR'</span></span>), (<span class="hljs-string"><span class="hljs-string">'http[s]?:\/\/(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'</span></span>, <span class="hljs-string"><span class="hljs-string">'SOMEURL'</span></span>) <span class="hljs-comment"><span class="hljs-comment">#      ] __stemmer_lock = threading.Lock() __stemmer = snowballstemmer.stemmer('english') def stem_string(text: str): def stem_words(word_list): with __stemmer_lock: res = __stemmer.stemWords(word_list) return res return " ".join(stem_words(text.split())) def clean_text(text: str): res = text for p in __replacements: res = re.sub(p[0], '#'+p[1]+'#', res) return res def process_record(record): txt = "" for t in record: t = "" if t == np.nan else t txt += " " + get_first_message(str(t)) return stem_string(clean_text(txt.lower())) class CommentsTextTransformer(BaseEstimator, TransformerMixin): _n_jobs = 1 def __init__(self, n_jobs=1): self._n_jobs = n_jobs def fit(self, X, y=None): return self def transform(self, X, y=None): features = Parallel(n_jobs=self._n_jobs)( delayed(process_record)(rec) for i, rec in enumerate(X.values) ) return np.array(features, dtype=object).reshape(len(X),)</span></span></code> </pre> <br><h3 id="vektorizaciya">  Vektorisasi </h3><br><p>  Vektorisasi dilakukan oleh <code>TfidfVectorizer</code> standar dengan pengaturan berikut: </p><br><ul><li>  <code>max_features</code> = 10000 </li><li>  <code>ngram</code> = (1,3) - dalam upaya untuk menangkap kombinasi stabil dan koneksi semantik </li><li>  <code>max_df</code> / <code>min_df</code> - dibiarkan secara default </li><li>  <code>stop_words</code> - daftar standar kata-kata bahasa Inggris, ditambah set kata-kata tambahannya sendiri.  Misalnya, beberapa pengguna menyebutkan nama analis, dan cukup sering nama yang tepat menjadi atribut yang signifikan. </li></ul><br><p>  <code>TfidfVectorizer</code> sendiri melakukan normalisasi L2 secara default, sehingga vektor-vektor insiden siap untuk mengukur jarak kosinus di antara mereka. </p><br><h3 id="poisk-pohozhih-incidentov">  Cari insiden serupa </h3><br><p>  Tugas utama dari proses ini adalah mengembalikan daftar tetangga N terdekat.  Kelas <code>sklearn.neighbors.NearestNeighbors</code> cukup cocok untuk ini.  Satu masalah adalah bahwa ia tidak menerapkan metode <code>transform</code> , yang tanpanya tidak dapat digunakan dalam <code>pipeline</code> . </p><br><p>  Oleh karena itu, perlu untuk membuatnya berdasarkan <code>Transformer</code> , yang baru kemudian menempatkan pada langkah terakhir dari <code>pipeline</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NearestNeighborsTransformer</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(NearestNeighbors, TransformerMixin)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, n_neighbors=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, radius=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, algorithm=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'auto'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, leaf_size=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">, metric=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'minkowski'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, metric_params=None, n_jobs=None, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(NearestNeighbors, self).__init__(n_neighbors=n_neighbors, radius=radius, algorithm=algorithm, leaf_size=leaf_size, metric=metric, p=p, metric_params=metric_params, n_jobs=n_jobs) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, X, y=None)</span></span></span><span class="hljs-function">:</span></span> res = self.kneighbors(X, self.n_neighbors, return_distance=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><h3 id="process-obrabotki">  Proses pengolahan </h3><br><p>  Menyatukan semuanya, kami mendapatkan proses yang ringkas: </p><br><pre> <code class="python hljs">p = Pipeline( steps=[ (<span class="hljs-string"><span class="hljs-string">'grp'</span></span>, ColumnTransformer( transformers=[ (<span class="hljs-string"><span class="hljs-string">'text'</span></span>, Pipeline(steps=[ (<span class="hljs-string"><span class="hljs-string">'pp'</span></span>, CommentsTextTransformer(n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>)), (<span class="hljs-string"><span class="hljs-string">"tfidf"</span></span>, TfidfVectorizer(stop_words=get_stop_words(), ngram_range=(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), max_features=<span class="hljs-number"><span class="hljs-number">10000</span></span>)) ]), [<span class="hljs-string"><span class="hljs-string">'short_description'</span></span>, <span class="hljs-string"><span class="hljs-string">'comments'</span></span>, <span class="hljs-string"><span class="hljs-string">'u_impacted_department'</span></span>] ) ] )), (<span class="hljs-string"><span class="hljs-string">"nn"</span></span>, NearestNeighborsTransformer(n_neighbors=<span class="hljs-number"><span class="hljs-number">10</span></span>, metric=<span class="hljs-string"><span class="hljs-string">'cosine'</span></span>)) ], memory=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>)</code> </pre> <br><p>  Setelah pelatihan, <code>pipeline</code> dapat disimpan ke file menggunakan <code>pickle</code> dan digunakan untuk menangani insiden yang masuk. <br>  Bersama-sama dengan model, kita akan menyimpan bidang insiden yang diperlukan - untuk kemudian menggunakannya dalam output ketika model sedang berjalan. </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># inc_data - pandas.Dataframe,     # ref_data - pandas.Dataframe,    . #     .    # inc_data["recommendations_json"] = "" #   . # column_list -  ,          nn_dist, nn_refs = p.transform(inc_data[column_list]) for idx, refs in enumerate(nn_refs): nn_data = ref_data.iloc[refs][['number', 'short_description']].copy() nn_data['distance'] = nn_dist[idx] inc_data.iloc[idx]["recommendations_json"] = nn_data.to_json(orient='records') #     , .     -. inc_data[['number', 'short_description', 'recommendations_json']].to_json(out_file_name, orient='records')</span></span></code> </pre> <br><h2 id="pervye-rezultaty-primeneniya">  Hasil aplikasi pertama </h2><br><p>  Reaksi kolega terhadap pengenalan sistem "petunjuk" pada umumnya sangat positif.  Insiden berulang mulai diselesaikan lebih cepat, kami mulai mengerjakan pemecahan masalah. </p><br><p>  Namun, orang tidak dapat mengharapkan keajaiban dari sistem pembelajaran yang tidak diawasi.  Kolega mengeluh bahwa kadang-kadang sistem menawarkan tautan yang sama sekali tidak relevan.  Kadang-kadang bahkan sulit untuk memahami dari mana rekomendasi tersebut berasal. </p><br><p>  Sudah jelas bahwa bidang untuk meningkatkan model sangat besar.  Beberapa kekurangan dapat diatasi, termasuk atau tidak termasuk beberapa atribut insiden.  Bagian - dengan memilih tingkat cutoff yang memadai untuk jarak antara insiden saat ini dan "rekomendasi".  Metode vektorisasi lain dapat dipertimbangkan. </p><br><p>  Tetapi masalah utama adalah kurangnya metrik kualitas untuk rekomendasi.  Dan jika demikian, tidak mungkin untuk memahami "apa yang baik dan apa yang buruk, dan berapa banyak", dan membangun perbandingan model pada ini. </p><br><p>  Kami tidak memiliki akses ke log http, karena sistem layanan bekerja dari jarak jauh (SaaS).  Kami melakukan survei pengguna - tetapi hanya secara kualitatif.  Itu perlu untuk melanjutkan ke penilaian kuantitatif, dan membangun berdasarkan metrik kualitas yang jelas. </p><br><p>  Tetapi lebih lanjut tentang itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di bagian selanjutnya ...</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472210/">https://habr.com/ru/post/id472210/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472198/index.html">Lokalisasi pesan push dalam aplikasi seluler</a></li>
<li><a href="../id472200/index.html">Modernisasi kelas ilmu komputer di sekolah Rusia dengan raspberry: murah dan ceria</a></li>
<li><a href="../id472202/index.html">Windows 10 + Python = VS Code + WSL</a></li>
<li><a href="../id472204/index.html">Eksperimen sederhana dengan mikrokontroler STM32F103 (Blue Tablet)</a></li>
<li><a href="../id472208/index.html">Layar OLED smartphone Android dan cara menghadapinya</a></li>
<li><a href="../id472212/index.html">Bagaimana cara mendaratkan Pesawat Ulang-alik dari luar angkasa</a></li>
<li><a href="../id472214/index.html">Percabangan yang salah diprediksi dapat secara signifikan meningkatkan waktu pelaksanaan program</a></li>
<li><a href="../id472216/index.html">Apa yang harus kita bangun IOT? IoT Anda di Amazon dalam Satu Hari</a></li>
<li><a href="../id472220/index.html">Mengapa fisikawan papan atas tidak menyukai interpretasi multi-dunia</a></li>
<li><a href="../id472222/index.html">â€œBaca jika Anda suka mendengarkanâ€: buku-buku untuk mereka yang tidak acuh pada musik - dari klasik hingga hip-hop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>