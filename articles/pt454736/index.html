<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßúüèª ü§≤üèæ ü§µ Suporte do Visual Studio 2019 no PVS-Studio üõåüèΩ üèáüèæ üìú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O suporte do Visual Studio 2019 no PVS-Studio afetou v√°rios componentes: o pr√≥prio plug-in, o analisador de linha de comando, os n√∫cleos dos analisado...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suporte do Visual Studio 2019 no PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454736/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  O suporte do Visual Studio 2019 no PVS-Studio afetou v√°rios componentes: o pr√≥prio plug-in, o analisador de linha de comando, os n√∫cleos dos analisadores C ++ e C # e alguns utilit√°rios.  Neste artigo, explicarei brevemente quais problemas encontramos ao implementar o suporte ao IDE e como os solucionamos. <br><a name="habracut"></a><br>  Antes de come√ßarmos, gostaria de relembrar o hist√≥rico de suporte √†s vers√µes anteriores do Visual Studio no PVS-Studio para entender melhor nossa vis√£o da tarefa e das solu√ß√µes que descobrimos em todas as situa√ß√µes. <br><br>  Desde a primeira vers√£o do PVS-Studio que acompanha um plug-in para o Visual Studio (era o Visual Studio 2005 naquela √©poca), oferecer suporte a novas vers√µes desse IDE tem sido uma tarefa bastante trivial para n√≥s, que basicamente se resumiu √† atualiza√ß√£o do projeto do plug-in arquivo e depend√™ncias das v√°rias extens√µes de API do Visual Studio.  De vez em quando, ter√≠amos que adicionar suporte para novos recursos do C ++, com os quais o compilador do Visual C ++ estava gradualmente aprendendo a trabalhar, mas geralmente tamb√©m n√£o era uma tarefa dif√≠cil e poderia ser feita facilmente antes de uma nova vers√£o do Visual Studio. .  Al√©m disso, o PVS-Studio tinha apenas um analisador na √©poca - para C / C ++. <br><br>  As coisas mudaram quando o Visual Studio 2017 foi lan√ßado.  Al√©m de grandes mudan√ßas em muitas extens√µes de API do IDE, tamb√©m encontramos um problema em manter a compatibilidade com vers√µes anteriores do novo analisador C # adicionado pouco antes (assim como da nova camada do analisador para que o C ++ funcione com projetos MSBuild) com o novas vers√µes do MSBuild \ Visual Studio. <br><br>  Considerando tudo isso, recomendo vivamente que voc√™ veja um artigo relacionado sobre o suporte do Visual Studio 2017, " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Suporte do Visual Studio 2017 e Roslyn 2.0 no PVS-Studio: √†s vezes n√£o √© t√£o f√°cil usar solu√ß√µes prontas como pode parecer</a> ", antes de continuar lendo.  Esse artigo discute os problemas que enfrentamos na √∫ltima vez e o modelo de intera√ß√£o entre diferentes componentes (como PVS-Studio, MSBuild e Roslyn).  Conhecer esses detalhes pode ajudar voc√™ a entender melhor o artigo atual. <br><br>  A solu√ß√£o desses problemas levou a mudan√ßas significativas no analisador, e esper√°vamos que as novas abordagens aplicadas nos ajudassem a oferecer suporte a vers√µes futuras do Visual Studio \ MSBuild com muito mais facilidade e rapidez.  Essa esperan√ßa j√° come√ßou a se mostrar realista quando as in√∫meras atualiza√ß√µes do Visual Studio 2017 foram lan√ßadas.  A nova abordagem nos ajudou no suporte ao Visual Studio 2019?  Continue lendo para descobrir. <br><br><h2>  Plug-in PVS-Studio para Visual Studio 2019 </h2><br>  O come√ßo parecia promissor.  N√£o foi necess√°rio muito esfor√ßo para portar o plug-in para o Visual Studio 2019 e faz√™-lo iniciar e executar bem.  Mas j√° encontramos dois problemas ao mesmo tempo que poderiam trazer mais problemas posteriormente. <br><br>  O primeiro tinha a ver com a interface <i>IVsSolutionWorkspaceService</i> usada para oferecer suporte ao modo Lightweight Solution Load (que, a prop√≥sito, havia sido desativado em uma das atualiza√ß√µes anteriores, no Visual Studio 2017).  Foi decorado com o atributo <i>Descontinuado</i> , que atualmente acionava apenas um aviso no momento da constru√ß√£o, mas que se tornaria um grande problema no futuro.  Esse modo n√£o durou muito tempo ... Isso foi f√°cil de corrigir - simplesmente paramos de usar essa interface. <br><br>  O segundo problema foi a seguinte mensagem que receb√≠amos ao carregar o Visual Studio com o plug-in habilitado: O <i>Visual Studio detectou uma ou mais extens√µes que est√£o em risco ou n√£o est√£o funcionando em um recurso VS update.</i> <br><br>  Os logs das ativa√ß√µes do Visual Studio (o arquivo ActivityLog) ajudaram a esclarec√™-lo: <br><br>  <i>Aviso: a extens√£o 'PVS-Studio' usa o recurso 'carregamento autom√°tico s√≠ncrono' do Visual Studio.</i>  <i>Esse recurso n√£o ser√° mais suportado em uma atualiza√ß√£o futura do Visual Studio 2019, quando a extens√£o n√£o funcionar√°.</i>  <i>Entre em contato com o fornecedor da extens√£o para obter uma atualiza√ß√£o.</i> <br><br>  O que isso significava para n√≥s era que ter√≠amos que mudar do modo de carregamento s√≠ncrono para ass√≠ncrono.  Espero que voc√™ n√£o se importe se eu poupar os detalhes de como interagimos com as interfaces COM do Visual Studio e apenas descrever brevemente as altera√ß√µes. <br><br>  H√° um artigo da Microsoft sobre o carregamento de plugins de forma ass√≠ncrona: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como usar o AsyncPackage para carregar o VSPackages em segundo plano</a> ".  No entanto, j√° estava claro que havia mais mudan√ßas por vir. <br><br>  Uma das maiores mudan√ßas foi no modo de carregamento, ou melhor, no modo de inicializa√ß√£o.  Nas vers√µes anteriores, toda a inicializa√ß√£o necess√°ria era feita usando dois m√©todos: <i>Inicializar</i> nossa classe herdada de <i>Package</i> e <i>OnShellPropertyChange</i> .  O √∫ltimo teve que ser adicionado porque, ao carregar de forma s√≠ncrona, o pr√≥prio Visual Studio ainda pode estar no processo de carregamento e inicializa√ß√£o e, portanto, algumas das a√ß√µes necess√°rias eram imposs√≠veis de executar durante a inicializa√ß√£o do plug-in.  Uma maneira de corrigir isso era atrasar a execu√ß√£o dessas a√ß√µes at√© o Visual Studio sair do estado 'zumbi'.  Foi essa parte da l√≥gica que escolhemos no m√©todo <i>OnShellPropertyChange</i> com uma verifica√ß√£o do status de 'zumbi'. <br><br>  O m√©todo <i>Initialize</i> da classe abstrata <i>AsyncPackage</i> , do qual s√£o carregados os plugins de forma ass√≠ncrona, √© <i>selado</i> . Portanto, a inicializa√ß√£o deve ser feita no m√©todo substitu√≠do <i>InitializeAsync</i> , que √© exatamente o que fizemos.  A l√≥gica de verifica√ß√£o do 'zumbi' tamb√©m teve que ser alterada porque as informa√ß√µes de status n√£o estavam mais dispon√≠veis para o nosso plugin.  Al√©m disso, ainda t√≠nhamos que executar as a√ß√µes que precisavam ser realizadas ap√≥s a inicializa√ß√£o do plugin.  <i>Resolvemos</i> isso utilizando o m√©todo <i>OnPackageLoaded</i> da interface <i>IVsPackageLoadEvents</i> , que √© onde essas a√ß√µes atrasadas foram executadas. <br><br>  Outro problema resultante do carregamento ass√≠ncrono era que os comandos do plug-in n√£o podiam ser usados ‚Äã‚Äãat√© depois do carregamento do Visual Studio.  A abertura do log do analisador clicando duas vezes no gerenciador de arquivos (se voc√™ precisar abri-lo no Visual Studio) resultou no lan√ßamento da vers√£o correspondente do devenv.exe com um comando para abrir o log.  O comando de inicializa√ß√£o se parecia com isso: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  O sinalizador "/ command" √© usado aqui para executar o comando registrado no Visual Studio.  Essa abordagem n√£o funcionou mais, pois os comandos n√£o estavam mais dispon√≠veis at√© o carregamento do plug-in.  A solu√ß√£o alternativa que criamos foi analisar o comando devenv.exe launch ap√≥s o carregamento do plug-in e executar o comando log open, se encontrado no comando launch.  Portanto, descartar a id√©ia de usar a interface "apropriada" para trabalhar com comandos nos permitiu manter a funcionalidade necess√°ria, com a abertura atrasada do log ap√≥s o carregamento completo do plug-in. <br><br>  Ufa, parece que finalmente conseguimos;  o plug-in carrega e abre como esperado, sem nenhum aviso. <br><br>  E √© aqui que as coisas d√£o errado.  Paul (Oi Paul!) Instala o plug-in no computador e pergunta por que ainda n√£o mudamos para o carregamento ass√≠ncrono. <br><br>  Dizer que ficamos chocados seria um eufemismo.  Isso n√£o poderia ser!  Mas √© real: aqui est√° a nova vers√£o do plug-in, e aqui est√° uma mensagem dizendo que o pacote est√° carregando de forma s√≠ncrona.  Alexander (Oi Alexander!) E eu tento a mesma vers√£o em nossos respectivos computadores - funciona bem.  Como isso √© poss√≠vel?  Ocorre-nos para verificar as vers√µes das bibliotecas PVS-Studio carregadas no Visual Studio - e descobrimos que s√£o as bibliotecas do Visual Studio 2017, enquanto o pacote VSIX cont√©m as novas vers√µes, ou seja, para o Visual Studio 2019. <br><br>  Depois de mexer no VSIXInstaller por um tempo, conseguimos descobrir que o problema estava relacionado ao cache de pacotes.  Essa teoria tamb√©m foi apoiada pelo fato de restringir o acesso ao pacote em cache (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) causado pelo VSIXInstaller para gerar uma mensagem de erro no log.  Curiosamente, quando o erro n√£o ocorreu, as informa√ß√µes sobre a instala√ß√£o de pacotes em cache n√£o apareceram. <br><br>  <b>Nota lateral</b> .  Enquanto estudava o comportamento do VSIX Installer e das bibliotecas associadas, pensei em como √© legal o Roslyn e o MSBuild serem de c√≥digo aberto, o que permite ler e depurar convenientemente o c√≥digo deles e rastrear sua l√≥gica de trabalho. <br><br>  Ent√£o, foi o que aconteceu: ao instalar o plug-in, o VSIX Installer viu que o pacote correspondente j√° estava em cache (na verdade era o pacote .vsix do Visual Studio 2017) e instalou esse pacote em vez do novo.  Por que ele ignorou as restri√ß√µes / requisitos definidos no arquivo .vsixmanifest (que, entre outras coisas, restringiu a instala√ß√£o de extens√µes a uma vers√£o espec√≠fica do Visual Studio) √© uma quest√£o ainda a ser respondida.  Como resultado, o plug-in projetado para o Visual Studio 2017 foi instalado no Visual Studio 2019 - apesar das restri√ß√µes especificadas no arquivo .vsixmanifest. <br><br>  O pior de tudo √© que essa instala√ß√£o quebrou o gr√°fico de depend√™ncias do Visual Studio e, embora o IDE parecesse estar funcionando bem, as coisas estavam realmente terr√≠veis.  Voc√™ n√£o p√¥de instalar ou excluir extens√µes, atualizar etc.  O processo de "restaura√ß√£o" tamb√©m foi doloroso, pois tivemos que excluir a extens√£o (ou seja, os arquivos que a cont√™m) manualmente e - tamb√©m manualmente - editar os arquivos de configura√ß√£o que armazenam as informa√ß√µes sobre o pacote instalado.  Em outras palavras, n√£o foi nada divertido. <br><br>  Para corrigir isso e garantir que n√£o enfrentemos situa√ß√µes como essa no futuro, decidimos criar nosso pr√≥prio GUID para o novo pacote, para que os pacotes do Visual Studio 2017 e Visual Studio 2019 sejam isolados um do outro ( os pacotes mais antigos eram bons; sempre usavam um GUID compartilhado). <br><br>  Desde que come√ßamos a falar de surpresas desagrad√°veis, eis outra: depois de atualizar para a Visualiza√ß√£o 2, o menu PVS-Studio "mudou" para a guia "Extens√µes".  N√£o √© grande coisa, mas tornou o acesso √† funcionalidade do plugin menos conveniente.  Esse comportamento persistiu nas pr√≥ximas vers√µes do Visual Studio 2019, incluindo o lan√ßamento.  Eu encontrei men√ß√µes a esse "recurso" nem na documenta√ß√£o nem no blog. <br><br>  Ok, agora as coisas pareciam bem e parecia que finalmente t√≠nhamos terminado o suporte do Visual Studio 2019.  Isso se mostrou errado no dia seguinte ap√≥s o lan√ßamento do PVS-Studio 7.02.  Era o modo de carregamento ass√≠ncrono novamente.  Ao abrir a janela de resultados da an√°lise (ou iniciar a an√°lise), a janela do analisador pareceria "vazia" para o usu√°rio - sem bot√µes, sem grade, nada. <br><br>  De fato, esse problema ocorreu de vez em quando durante a an√°lise.  Mas afetou apenas um computador e n√£o apareceu at√© o Visual Studio ser atualizado para uma das primeiras itera√ß√µes de 'Preview'.  Suspeitamos que algo tivesse quebrado durante a instala√ß√£o ou atualiza√ß√£o.  O problema, no entanto, desapareceu algum tempo depois e n√£o ocorreria nem naquele computador em particular, por isso pensamos que "foi consertado sozinho".  Mas n√£o - n√≥s apenas tivemos sorte.  Ou infeliz, por falar nisso. <br><br>  Como descobrimos, foi a ordem em que a pr√≥pria janela do IDE (a classe derivada do <i>ToolWindowPane</i> ) e seu conte√∫do (nosso controle com a grade e os bot√µes) foram inicializados.  Sob certas condi√ß√µes, o controle seria inicializado antes do painel e, embora as coisas funcionassem bem, e o m√©todo <i>FindToolWindowAsync</i> (criar a janela quando for acessada pela primeira vez) funcionasse bem, o controle permaneceria invis√≠vel.  Corrigimos isso adicionando uma inicializa√ß√£o lenta para nosso controle ao c√≥digo de preenchimento do painel. <br><br><h2>  Suporte do C # 8.0 </h2><br>  H√° uma grande vantagem em usar o Roslyn como base para o analisador: voc√™ n√£o precisa adicionar suporte para novas constru√ß√µes de linguagem manualmente - isso √© feito automaticamente pelas bibliotecas da Microsoft, an√°lise de c√≥digo e apenas usamos as solu√ß√µes prontas.  Isso significa que a nova sintaxe √© suportada simplesmente atualizando as bibliotecas. <br><br>  Quanto √† an√°lise em si, tivemos que ajustar as coisas por conta pr√≥pria, √© claro - em particular, lidar com novas constru√ß√µes de linguagem.  Certamente, tivemos a nova √°rvore de sintaxe gerada automaticamente, simplesmente atualizando o Roslyn, mas ainda tivemos que ensinar ao analisador exatamente como interpretar e processar n√≥s de √°rvore de sintaxe novos ou modificados. <br><br>  Os tipos de refer√™ncia anul√°veis ‚Äã‚Äãs√£o talvez o novo recurso mais discutido no C # 8. N√£o falarei sobre eles agora, porque um t√≥pico t√£o grande vale um artigo separado (que est√° sendo escrito atualmente).  Por enquanto, decidimos ignorar anota√ß√µes anul√°veis ‚Äã‚Äãem nosso mecanismo de fluxo de dados (ou seja, entendemos, analisamos e ignoramos).  A id√©ia √© que uma vari√°vel, mesmo de um tipo de refer√™ncia n√£o anul√°vel, ainda possa receber o valor <i>nulo</i> com bastante facilidade (ou acidentalmente), terminando com um NRE ao tentar desrefer√™-lo.  Nosso analisador pode detectar esses erros e relatar uma poss√≠vel desrefer√™ncia nula (se encontrar essa atribui√ß√£o no c√≥digo, √© claro), mesmo que a vari√°vel seja do tipo refer√™ncia n√£o nula. <br><br>  O uso de tipos de refer√™ncia anul√°veis ‚Äã‚Äãe sintaxe associada permite que voc√™ escreva um c√≥digo bastante interessante.  N√≥s o apelidamos de "sintaxe emocional".  Este trecho √© perfeitamente compil√°vel: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  A prop√≥sito, minhas experi√™ncias me levaram a descobrir alguns truques que voc√™ pode usar para "travar" o Visual Studio usando a nova sintaxe.  Eles s√£o baseados no fato de que voc√™ tem permiss√£o para escrever tantos '!'  caracteres como voc√™ gosta.  Isso significa que voc√™ pode escrever n√£o apenas um c√≥digo como este: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  mas tamb√©m assim: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  E, empurrando ainda mais, voc√™ pode escrever coisas loucas como esta: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Esse c√≥digo √© compil√°vel, mas se voc√™ tentar exibir a √°rvore de sintaxe no Syntax Visualizer a partir do .NET Compiler Platform SDK, o Visual Studio falhar√°. <br><br>  O relat√≥rio de falha pode ser extra√≠do do Visualizador de Eventos: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Se voc√™ ficar ainda mais louco e adicionar v√°rias vezes mais pontos de exclama√ß√£o, o Visual Studio come√ßar√° a travar sozinho, sem a ajuda do Syntax Visualizer.  As bibliotecas Microsoft.CodeAnalysis e o compilador csc.exe tamb√©m n√£o podem lidar com esse c√≥digo. <br><br>  Esses exemplos s√£o inventados, √© claro, mas achei esse truque engra√ßado. <br><br><h2>  Conjunto de ferramentas </h2><br>  Era √≥bvio que a atualiza√ß√£o do conjunto de ferramentas seria a parte mais dif√≠cil.  Pelo menos √© o que parecia no come√ßo, mas agora acho que o suporte ao plugin foi a parte mais dif√≠cil.  Por um lado, j√° t√≠nhamos um conjunto de ferramentas e um mecanismo para avaliar os projetos do MSBuild, o que foi bom, apesar de ainda n√£o ter sido estendido.  O fato de n√£o termos que escrever os algoritmos do zero tornou mais f√°cil.  A estrat√©gia de contar com o "nosso" conjunto de ferramentas, ao qual preferimos seguir o suporte ao Visual Studio 2017, mais uma vez se mostrou correta. <br><br>  Tradicionalmente, o processo come√ßa com a atualiza√ß√£o dos pacotes NuGet.  A guia para gerenciar pacotes NuGet para a solu√ß√£o atual cont√©m o bot√£o "Atualizar" ... mas n√£o ajuda.  Atualizar todos os pacotes de uma vez causou v√°rios conflitos de vers√£o e tentar resolv√™-los todos n√£o parecia uma boa ideia.  Uma maneira mais dolorosa e presumivelmente mais segura foi atualizar seletivamente os pacotes de destino do Microsoft.Build / Microsoft.CodeAnalysis. <br><br>  Uma diferen√ßa foi identificada imediatamente ao testar o diagn√≥stico: a estrutura da √°rvore de sintaxe foi alterada em um n√≥ existente.  N√£o √© grande coisa;  consertamos isso rapidamente. <br><br>  Deixe-me lembr√°-lo, testamos nossos analisadores (para C #, C ++, Java) em projetos de c√≥digo aberto.  Isso nos permite testar minuciosamente os diagn√≥sticos - por exemplo, verifique se h√° falsos positivos ou veja se perdemos algum caso (para reduzir o n√∫mero de falsos negativos).  Esses testes tamb√©m nos ajudam a rastrear uma poss√≠vel regress√£o na etapa inicial de atualiza√ß√£o das bibliotecas / conjunto de ferramentas.  Desta vez, eles pegaram uma s√©rie de quest√µes tamb√©m. <br><br>  Uma era que o comportamento nas bibliotecas da CodeAnalysis piorava.  Especificamente, ao verificar determinados projetos, come√ßamos a obter exce√ß√µes do c√≥digo das bibliotecas em v√°rias opera√ß√µes, como obter informa√ß√µes sem√¢nticas, abrir projetos etc. <br><br>  Aqueles de voc√™s que leram atentamente o artigo sobre o suporte do Visual Studio 2017 lembram que nossa distribui√ß√£o √© fornecida com um manequim - o arquivo MSBuild.exe de 0 bytes. <br><br>  Agora tivemos que aprimorar ainda mais essa pr√°tica e incluir manequins vazios para os compiladores csc.exe, vbc.exe e VBCSCompiler.exe.  Porque  Chegamos a essa solu√ß√£o depois de analisar um dos projetos de nossa base de testes e obter relat√≥rios de diferen√ßas: a nova vers√£o do analisador n√£o produziria alguns dos avisos esperados. <br><br>  Descobrimos que isso tinha a ver com s√≠mbolos de compila√ß√£o condicional, alguns dos quais n√£o foram extra√≠dos corretamente ao usar a nova vers√£o do analisador.  Para chegar √† raiz do problema, tivemos que nos aprofundar no c√≥digo das bibliotecas de Roslyn. <br><br>  Os s√≠mbolos de compila√ß√£o condicional s√£o analisados ‚Äã‚Äãusando o m√©todo <i>GetDefineConstantsSwitch</i> da classe <i>Csc</i> da biblioteca <i>Microsoft.Build.Tasks.CodeAnalysis</i> .  A an√°lise √© feita usando o m√©todo <i>String.Split</i> em v√°rios separadores: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Esse mecanismo de an√°lise funciona perfeitamente;  todos os s√≠mbolos de compila√ß√£o condicional s√£o extra√≠dos corretamente.  Ok, vamos continuar cavando. <br><br>  O pr√≥ximo ponto-chave foi a chamada do m√©todo <i>ComputePathToTool</i> da classe <i>ToolTask</i> .  Este m√©todo calcula o caminho para o arquivo execut√°vel ( <i>csc.exe</i> ) e verifica se est√° l√°.  Nesse caso, o m√©todo retorna o caminho para ele ou <i>null</i> caso contr√°rio. <br><br>  O c√≥digo de chamada: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Como n√£o h√° arquivo <i>csc.exe</i> (por que precisamos dele?), O <i>PathToTool</i> recebe o valor <i>nulo</i> neste momento, e o m√©todo atual ( <i>ToolTask.Execute</i> ) retorna <i>false</i> .  Os resultados da execu√ß√£o da tarefa, incluindo os s√≠mbolos de compila√ß√£o condicional extra√≠dos, s√£o ignorados. <br><br>  Ok, vamos ver o que acontece se colocarmos o arquivo <i>csc.exe</i> onde ele deveria estar. <br><br>  Agora <i>pathToTool</i> armazena o caminho real para o arquivo agora presente, e o <i>ToolTask.Execute</i> continua em execu√ß√£o.  O pr√≥ximo ponto-chave √© a chamada do m√©todo <i>ManagedCompiler.ExecuteTool</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  A propriedade <i>SkipCompilerExecution</i> √© <i>verdadeira</i> (logicamente o suficiente, pois n√£o estamos compilando de verdade).  O m√©todo de chamada (o <i>ToolTask.Execute</i> j√° mencionado) verifica se o valor de retorno para <i>ExecuteTool</i> √© 0 e, nesse caso, retorna <i>true</i> .  Se o seu <i>csc.exe</i> foi um compilador real ou "Guerra e Paz" de Leo Tolstoy, n√£o importa. <br><br>  Portanto, o problema tem a ver com a ordem em que as etapas foram definidas: <br><br><ul><li>  verifique se h√° compilador; </li><li>  verifique se o compilador deve ser iniciado; </li></ul><br>  E esperar√≠amos uma ordem inversa.  √â para corrigir isso que os manequins para os compiladores foram adicionados. <br><br>  Ok, mas como conseguimos obter os s√≠mbolos de compila√ß√£o, com o arquivo csc.exe ausente (e os resultados da tarefa ignorados)? <br><br>  Bem, tamb√©m existe um m√©todo para este caso: <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> da biblioteca <i>Microsoft.CodeAnalysis.CSharp</i> .  Tamb√©m faz a an√°lise chamando o m√©todo <i>String.Split</i> em v√°rios separadores: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Veja como esse conjunto de separadores √© diferente daquele tratado pelo m√©todo <i>Csc.GetDefineConstantsSwitch</i> ?  Aqui, um espa√ßo n√£o √© um separador.  Isso significa que s√≠mbolos de compila√ß√£o condicional separados por espa√ßos n√£o ser√£o analisados ‚Äã‚Äãcorretamente por esse m√©todo. <br><br>  Foi o que aconteceu quando checamos os projetos problem√°ticos: eles usavam s√≠mbolos de compila√ß√£o condicional separados por espa√ßo e, portanto, foram analisados ‚Äã‚Äãcom √™xito pelo m√©todo <i>GetDefineConstantsSwitch</i> , mas n√£o pelo m√©todo <i>ParseConditionalCompilationSymbols</i> . <br><br>  Outro problema que apareceu ap√≥s a atualiza√ß√£o das bibliotecas foi o comportamento interrompido em certos casos - especificamente, em projetos que n√£o foram criados.  Isso afetou as bibliotecas da Microsoft, <i>Code Analysis</i> e se manifestou como exce√ß√µes de todos os tipos: <i>ArgumentNullException</i> (falha na inicializa√ß√£o de algum log interno), <i>NullReferenceException</i> e assim por diante. <br><br>  Gostaria de falar sobre um erro em particular que achei bastante interessante. <br><br>  Encontramos isso ao verificar a nova vers√£o do projeto Roslyn: uma das bibliotecas estava lan√ßando uma <i>NullReferenceException</i> .  Gra√ßas a informa√ß√µes detalhadas sobre sua fonte, encontramos rapidamente o c√≥digo-fonte do problema e, por curiosidade, decidimos verificar se o erro persistiria ao trabalhar no Visual Studio. <br><br>  Conseguimos reproduzi-lo no Visual Studio (vers√£o 16.0.3).  Para fazer isso, voc√™ precisa de uma defini√ß√£o de classe como esta: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Voc√™ tamb√©m precisar√° do Syntax Visualizer (ele vem com o .NET Compiler Platform SDK).  Procure o <i>TypeSymbol</i> (clicando no item de menu "View TypeSymbol (se houver)") do n√≥ da √°rvore de sintaxe do tipo <i>ConstantPatternSyntax</i> ( <i>null</i> ).  O Visual Studio ser√° reiniciado e as informa√ß√µes da exce√ß√£o - especificamente, o rastreamento de pilha - ficar√£o dispon√≠veis no Visualizador de Eventos: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Como voc√™ pode ver, o problema √© causado por uma refer√™ncia de refer√™ncia nula. <br><br>  Como j√° mencionei, encontramos um problema semelhante ao testar o analisador.  Se voc√™ constru√≠-lo usando as bibliotecas de depura√ß√£o da Microsoft, <i>Code Analysis</i> , voc√™ pode ir direto ao ponto do problema, <i>consultando</i> o <i>TypeSymbol</i> do n√≥ da √°rvore de sintaxe correspondente. <br><br>  Eventualmente, ele nos levar√° ao m√©todo <i>ClassifyImplicitBuiltInConversionSlow</i> mencionado no rastreamento de pilha acima: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  Aqui, o par√¢metro de <i>destino</i> √© <i>nulo</i> , portanto, chamar <i>destination.SpecialType</i> resulta em lan√ßar uma <i>NullReferenceException</i> .  Sim, a opera√ß√£o de desrefer√™ncia √© precedida por <i>Debug.Assert</i> , mas n√£o ajuda porque, na verdade, n√£o protege de nada - simplesmente permite que voc√™ localize o problema nas vers√µes de depura√ß√£o das bibliotecas.  Ou n√£o. <br><br><h3>  Altera√ß√µes no mecanismo de avalia√ß√£o de projetos C ++ </h3><br>  N√£o havia muita coisa interessante nesta parte: os algoritmos existentes n√£o exigiam grandes modifica√ß√µes que merecessem ser mencionadas, mas voc√™ pode querer saber sobre dois pequenos problemas. <br><br>  O primeiro foi que tivemos que modificar os algoritmos que dependiam do valor num√©rico de ToolsVersion.  Sem entrar em detalhes, h√° certos casos em que voc√™ precisa comparar conjuntos de ferramentas e escolher, digamos, a vers√£o mais recente.  A nova vers√£o, naturalmente, tem um valor maior.  Esper√°vamos que ToolsVersion para o novo MSBuild / Visual Studio tivesse o valor 16.0.  Sim claro!  A tabela abaixo mostra como os valores das diferentes propriedades foram alterados ao longo do hist√≥rico de desenvolvimento do Visual Studio: <br><div class="scrollable-table"><table><tbody><tr><td>  Nome do produto Visual Studio <br></td><td>  N√∫mero da vers√£o do Visual Studio <br></td><td>  Vers√£o das ferramentas <br></td><td>  Vers√£o PlatformToolset <br></td></tr><tr><td>  Visual studio 2010 <br></td><td>  10.0 <br></td><td>  4.0 <br></td><td>  100 <br></td></tr><tr><td>  Visual studio 2012 <br></td><td>  11,0 <br></td><td>  4.0 <br></td><td>  110 <br></td></tr><tr><td>  Visual studio 2013 <br></td><td>  12,0 <br></td><td>  12,0 <br></td><td>  120 <br></td></tr><tr><td>  Visual studio 2015 <br></td><td>  14,0 <br></td><td>  14,0 <br></td><td>  140 <br></td></tr><tr><td>  Visual studio 2017 <br></td><td>  15,0 <br></td><td>  15,0 <br></td><td>  141 <br></td></tr><tr><td>  Visual studio 2019 <br></td><td>  16,0 <br></td><td>  Atual <br></td><td>  142 <br></td></tr></tbody></table></div><br>  Sei que a piada sobre os n√∫meros de vers√µes complicadas do Windows e Xbox √© antiga, mas prova que voc√™ n√£o pode fazer previs√µes confi√°veis ‚Äã‚Äãsobre os valores (seja no nome ou na vers√£o) dos futuros produtos da Microsoft.  :) <br><br>  Resolvemos isso facilmente adicionando a prioriza√ß√£o de conjuntos de ferramentas (ou seja, destacando a prioridade como uma entidade separada). <br><br>  O segundo problema envolveu problemas com o trabalho no Visual Studio 2017 ou ambiente relacionado (por exemplo, quando a vari√°vel de ambiente <i>VisualStudioVersion</i> est√° definida).  Isso ocorre porque os par√¢metros de computa√ß√£o necess√°rios para avaliar um projeto C ++ √© uma tarefa muito mais dif√≠cil do que avaliar um projeto .NET.  Para o .NET, usamos nosso pr√≥prio conjunto de ferramentas e o valor correspondente de ToolsVersion.  Para C ++, podemos utilizar nosso pr√≥prio conjunto de ferramentas e os fornecidos pelo sistema.  A partir do Build Tools para Visual Studio 2017, os conjuntos de ferramentas s√£o definidos no arquivo <i>MSBuild.exe.config em</i> vez do registro.  √â por isso que n√£o conseguimos mais obt√™-los da lista global de conjuntos de ferramentas (usando o <i>Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</i> , por exemplo), diferente dos definidos no registro (por exemplo, para o Visual Studio 2015 e vers√µes anteriores). <br><br>  Tudo isso nos impede de avaliar um projeto usando o <i>ToolsVersion 15.0,</i> porque o sistema n√£o ver√° o conjunto de ferramentas necess√°rio.  O conjunto de ferramentas mais recente, <i>Current</i> , ainda estar√° dispon√≠vel, pois √© nosso pr√≥prio conjunto de ferramentas e, portanto, n√£o existe esse problema no Visual Studio 2019. A solu√ß√£o era bastante simples e nos permitiu corrigir isso sem alterar os algoritmos de avalia√ß√£o existentes: apenas tivemos que incluir outro conjunto de ferramentas, <i>15.0</i> , na lista de nossos pr√≥prios conjuntos de ferramentas, al√©m de <i>Atual</i> . <br><br><h3>  Altera√ß√µes no mecanismo de avalia√ß√£o de projetos C # .NET Core </h3><br>  Esta tarefa envolveu dois problemas inter-relacionados: <br><br><ul><li>  adicionar o conjunto de ferramentas 'Atual' interrompeu a an√°lise dos projetos do .NET Core no Visual Studio 2017; </li><li>  a an√°lise n√£o funcionaria para projetos do .NET Core em sistemas sem pelo menos uma c√≥pia do Visual Studio instalada. </li></ul><br>  Ambos os problemas vinham da mesma fonte: alguns arquivos base .targets / .props foram procurados por caminhos incorretos.  Isso nos impediu de avaliar um projeto usando nosso conjunto de ferramentas. <br><br>  Se voc√™ n√£o tivesse uma inst√¢ncia do Visual Studio instalada, obteria o seguinte erro (com a vers√£o anterior do conjunto de ferramentas, <i>15.0</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br>  Ao avaliar um projeto C # .NET Core no Visual Studio 2017, voc√™ recebe o seguinte erro (com a vers√£o atual do conjunto de ferramentas, <i>Atual</i> ): <br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br>  Como esses problemas s√£o semelhantes (o que parecem ser), podemos tentar matar dois coelhos com uma cajadada s√≥. <br><br>  Nos pr√≥ximos par√°grafos, explicarei como realizamos isso, sem entrar em detalhes.  Esses detalhes (sobre como os projetos C # .NET Core s√£o avaliados, bem como altera√ß√µes no mecanismo de avalia√ß√£o em nosso conjunto de ferramentas) ser√£o o t√≥pico de um de nossos futuros artigos.  A prop√≥sito, se voc√™ estava lendo este artigo com aten√ß√£o, provavelmente percebeu que esta √© a segunda refer√™ncia aos nossos futuros artigos.  :) <br><br>  Agora, como resolvemos esse problema?  Estendemos nosso pr√≥prio conjunto de ferramentas com os arquivos .targets / .props base do .NET Core SDK ( <i>Sdk.props</i> , <i>Sdk.targets</i> ).  Isso nos deu mais controle sobre a situa√ß√£o e mais flexibilidade no gerenciamento de importa√ß√£o, bem como na avalia√ß√£o dos projetos do .NET Core em geral.  Sim, nosso conjunto de ferramentas ficou um pouco maior novamente e tamb√©m tivemos que adicionar l√≥gica para configurar o ambiente necess√°rio para a avalia√ß√£o de projetos do .NET Core, mas parece valer a pena. <br><br>  At√© ent√£o, t√≠nhamos avaliado os projetos do .NET Core simplesmente solicitando a avalia√ß√£o e contando com o MSBuild para fazer o trabalho. <br><br>  Agora que t√≠nhamos mais controle sobre a situa√ß√£o, o mecanismo mudou um pouco: <br><br><ul><li>  configurar o ambiente necess√°rio para avaliar projetos do .NET Core; </li><li>  avalia√ß√£o: <ul><li>  inicie a avalia√ß√£o usando arquivos .targets / .props do nosso conjunto de ferramentas; </li><li>  continue a avalia√ß√£o usando arquivos externos. </li></ul></li></ul><br>  Essa sequ√™ncia sugere que a cria√ß√£o do ambiente persegue dois objetivos principais: <br><br><ul><li>  iniciar avalia√ß√£o usando arquivos .targets / .props do nosso conjunto de ferramentas; </li><li>  redirecione todas as opera√ß√µes subseq√ºentes para arquivos .targets / .props externos. </li></ul><br>  Uma biblioteca especial Microsoft.DotNet.MSBuildSdkResolver √© usada para procurar os arquivos .targets / .props necess√°rios.  Para iniciar a configura√ß√£o do ambiente usando arquivos do nosso conjunto de ferramentas, utilizamos uma vari√°vel de ambiente especial usada por essa biblioteca para que pud√©ssemos apontar para a fonte de onde importar os arquivos necess√°rios (por exemplo, nosso conjunto de ferramentas).  Como a biblioteca est√° inclu√≠da em nossa distribui√ß√£o, n√£o h√° risco de uma falha l√≥gica repentina. <br><br>  Agora, importamos primeiro os arquivos Sdk do nosso conjunto de ferramentas e, como podemos alter√°-los facilmente agora, controlamos completamente o restante da l√≥gica de avalia√ß√£o.  Isso significa que agora podemos decidir quais arquivos e de qual local importar.  O mesmo se aplica ao Microsoft.Common.props mencionado acima.  Importamos este e outros arquivos de base do nosso conjunto de ferramentas para n√£o precisarmos nos preocupar com a exist√™ncia ou o conte√∫do deles. <br><br>  Depois que todas as importa√ß√µes necess√°rias forem feitas e as propriedades definidas, passamos o controle sobre o processo de avalia√ß√£o para o .NET Core SDK real, onde todas as demais opera√ß√µes necess√°rias s√£o executadas. <br><br><h2>  Conclus√£o </h2><br>  O suporte ao Visual Studio 2019 geralmente era mais f√°cil do que o suporte ao Visual Studio 2017 por v√°rios motivos.  Primeiro, a Microsoft n√£o mudou tantas coisas quanto na atualiza√ß√£o do Visual Studio 2015 para o Visual Studio 2017. Sim, eles mudaram o conjunto de ferramentas base e for√ßaram os plug-ins do Visual Studio a mudar para o modo de carregamento ass√≠ncrono, mas essa altera√ß√£o n√£o foi que dr√°stico.  Segundo, j√° t√≠nhamos uma solu√ß√£o pronta envolvendo nosso pr√≥prio conjunto de ferramentas e mecanismo de avalia√ß√£o de projetos e simplesmente n√£o precis√°vamos trabalhar tudo do zero - apenas desenvolver o que j√° t√≠nhamos.  O processo relativamente indolor de dar suporte √† an√°lise de projetos do .NET Core sob novas condi√ß√µes (e em computadores sem c√≥pias do Visual Studio instaladas) estendendo nosso sistema de avalia√ß√£o de projetos tamb√©m nos d√° esperan√ßa de que fizemos a escolha certa, assumindo parte do controle nossas m√£os. <br><br>  Mas gostaria de repetir a ideia divulgada no artigo anterior: √†s vezes, usar solu√ß√µes prontas n√£o √© t√£o f√°cil quanto pode parecer. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454736/">https://habr.com/ru/post/pt454736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454720/index.html">Como reviver a documenta√ß√£o?</a></li>
<li><a href="../pt454728/index.html">Acesso √† Internet aberto: a tecnologia LUWRAIN ajuda os usu√°rios cegos</a></li>
<li><a href="../pt454730/index.html">Encontro do Allure Server: grava√ß√µes em v√≠deo de relat√≥rios</a></li>
<li><a href="../pt454732/index.html">5 t√©cnicas robustas de prioriza√ß√£o para equipes de TI</a></li>
<li><a href="../pt454734/index.html">Backup, Parte 4: Vis√£o geral e testes zbackup, restic, borgbackup</a></li>
<li><a href="../pt454738/index.html">Suporte do Visual Studio 2019 no PVS-Studio</a></li>
<li><a href="../pt454740/index.html">Maio 2019 Joomla Digest</a></li>
<li><a href="../pt454742/index.html">Pelo menos um truque do Vim que voc√™ n√£o conhecia</a></li>
<li><a href="../pt454744/index.html">Vis√£o geral dos relat√≥rios de trilha Java da confer√™ncia RigaDevDays</a></li>
<li><a href="../pt454748/index.html">Guia de sobreviv√™ncia do MongoDB</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>