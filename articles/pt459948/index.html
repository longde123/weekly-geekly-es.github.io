<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòí üì¢ üéê Implementando nuvens volum√©tricas fisicamente corretas como no Horizon Zero Dawn ‚è¨ üê¢ üçº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anteriormente, as nuvens nos jogos eram desenhadas com sprites 2D comuns, que sempre s√£o rotacionados na dire√ß√£o da c√¢mera, mas nos √∫ltimos anos, novo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementando nuvens volum√©tricas fisicamente corretas como no Horizon Zero Dawn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459948/">  Anteriormente, as nuvens nos jogos eram desenhadas com sprites 2D comuns, que sempre s√£o rotacionados na dire√ß√£o da c√¢mera, mas nos √∫ltimos anos, novos modelos de placas de v√≠deo permitem desenhar nuvens fisicamente corretas sem perdas vis√≠veis de desempenho.  Acredita-se que nuvens volumosas no jogo trouxeram o est√∫dio Guerrilla Games junto com o jogo Horizon Zero Dawn.  Obviamente, essas nuvens foram capazes de renderizar antes, mas o est√∫dio formou algo como um padr√£o do setor para os recursos de origem e os algoritmos usados, e agora qualquer implementa√ß√£o de nuvens volum√©tricas est√° de alguma forma em conformidade com esse padr√£o. <br><br><img src="https://habrastorage.org/webt/v9/uq/em/v9uqemwtz5ty7x5uvpppsoonmdu.png"><br><a name="habracut"></a><br>  Todo o processo de renderiza√ß√£o de nuvens √© muito bem dividido em est√°gios e √© importante observar que a implementa√ß√£o imprecisa, mesmo em um deles, pode levar a consequ√™ncias que n√£o ficar√£o claras onde est√° o erro e como corrigi-lo; portanto, √© recomend√°vel fazer uma conclus√£o de controle do resultado a cada vez. <br><br><h2>  Mapeamento de tons, sRGB </h2><br>  Antes de come√ßar a trabalhar com ilumina√ß√£o, √© importante fazer duas coisas: <br><br><ol><li>  Antes de exibir a imagem final na tela, aplique pelo menos o mapeamento de tom mais simples: <br><br><pre><code class="cpp hljs">tunedColor=color/(<span class="hljs-number"><span class="hljs-number">1</span></span>+color)</code> </pre> <br>  Isso √© necess√°rio porque os valores de cores calculados ser√£o muito maiores que a unidade. <br></li><li>  Verifique se o buffer de quadros final no qual voc√™ est√° desenhando e exibido na tela est√° no formato sRGB.  Se a ativa√ß√£o do modo sRGB for um problema, a convers√£o poder√° ser feita manualmente no shader: <br><br><pre> <code class="cpp hljs">finalColor=<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(color, vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.2</span></span>))</code> </pre> <br>  A f√≥rmula √© adequada para a maioria dos casos, mas n√£o 100%, dependendo do monitor.  √â importante que a convers√£o de sRGB seja sempre feita por √∫ltimo. </li></ol><br><h2>  Modelo de ilumina√ß√£o </h2><br>  Considere um espa√ßo preenchido com mat√©ria parcialmente transparente de diferentes densidades.  Quando um raio de luz passa atrav√©s dessa subst√¢ncia, √© exposto a quatro efeitos: absor√ß√£o, dispers√£o, dispers√£o amplificada e auto-radia√ß√£o.  O √∫ltimo ocorre no caso de processos qu√≠micos em uma subst√¢ncia e n√£o √© afetado aqui. <br><br>  Suponha que tenhamos um raio de luz que atravessa a mat√©ria do ponto A ao ponto B: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/1t/9w/_11t9wizftnmwilerlsi5fvcrm4.png"></div><br>  <b>Absor√ß√£o</b> <br><br>  A luz que passa atrav√©s de uma subst√¢ncia sofre absor√ß√£o por essa mesma subst√¢ncia.  A fra√ß√£o de luz n√£o absorvida pode ser encontrada pela f√≥rmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/34c/ec6/56734cec6154e1fab8bb2d1538a8dffa.svg"></div><br>  onde <img src="https://habrastorage.org/getpro/habr/post_images/a3e/204/11f/a3e20411f145906908c5cd2b53a36dbe.svg">  - a luz restante no ponto ap√≥s absor√ß√£o <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  - ponto no segmento AB √† dist√¢ncia <img src="https://habrastorage.org/getpro/habr/post_images/2a3/102/4ea/2a31024ea1803c34a47496e24a53a1ef.svg">  de A. <br><br>  <b>Dispers√£o</b> <br><br>  Parte da luz sob a influ√™ncia de part√≠culas da mat√©ria muda de dire√ß√£o.  A fra√ß√£o de luz que n√£o mudou de dire√ß√£o pode ser encontrada pela f√≥rmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04b/c17/2f5/04bc172f53fa572aebf0399275b5009f.svg"></div><br>  onde <img src="https://habrastorage.org/getpro/habr/post_images/5e3/0b7/bad/5e30b7badd64b9da62be750e48573c7d.svg">  - fra√ß√£o da luz que n√£o mudou de dire√ß√£o ap√≥s a dispers√£o em um ponto <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  A absor√ß√£o e a dispers√£o devem ser combinadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/d5a/f1a/8d7d5af1a0506ee776c4c2f850e862a9.svg"></div><br>  Fun√ß√£o <img src="https://habrastorage.org/getpro/habr/post_images/33f/297/4e9/33f2974e9c84331f8b92d8b7ed5aca97.svg">  chamado atenua√ß√£o ou extin√ß√£o.  Uma fun√ß√£o <img src="https://habrastorage.org/getpro/habr/post_images/eea/d4d/0d4/eead4d0d4f08873f9aa49b69a7c46fd8.svg">  - fun√ß√£o de transfer√™ncia.  Ele mostra quanta luz resta ao passar do ponto A ao ponto B. <br><br>  No que diz respeito <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  e <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  : <img src="https://habrastorage.org/getpro/habr/post_images/b76/ea9/fd5/b76ea9fd577eb1c2cee545caa4153bd3.svg">  , em que C √© uma determinada constante, que pode ter um valor diferente para cada canal em RGB, <img src="https://habrastorage.org/getpro/habr/post_images/9ee/494/9d2/9ee4949d2897f56ac90e563db1eb96cd.svg">  √â a densidade do meio no ponto <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Agora vamos complicar a tarefa.  A luz se move do ponto A ao ponto B, desaparece durante o movimento.  No ponto X, parte da luz √© espalhada em dire√ß√µes diferentes, uma das dire√ß√µes corresponde ao observador no ponto O. Em seguida, uma parte da luz espalhada se move do ponto X para o ponto O e √© √∫mida novamente.  O caminho da luz AXO de interesse para n√≥s. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/b_/tr/zob_troftvd8-ggp1ga7wesnrlk.png"></div><br>  A perda de luz ao passar de A para X, sabemos: <img src="https://habrastorage.org/getpro/habr/post_images/25d/8c9/f76/25d8c9f76986f59eb045b801f19d4e0a.svg">  , assim como sabemos a perda de luz de X para O - isso <img src="https://habrastorage.org/getpro/habr/post_images/25b/3a9/8e3/25b3a98e370f0a95b734794b74bee57a.svg">  .  Mas e a fra√ß√£o de luz que ser√° espalhada na dire√ß√£o do observador? <br><br>  <b>Dispers√£o de amplifica√ß√£o</b> <br><br>  Se, no caso da dispers√£o comum, a intensidade da luz diminui, ent√£o, no caso da amplifica√ß√£o da dispers√£o, aumenta devido √† dispers√£o da luz que ocorreu nas regi√µes vizinhas.  A quantidade total de luz proveniente de regi√µes vizinhas pode ser encontrada pela f√≥rmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e4/be1/bd9/7e4be1bd9a1d8f05b9d1d47e1bb27ecc.svg"></div><br>  onde <img src="https://habrastorage.org/getpro/habr/post_images/e63/878/1e4/e638781e456c920d7864e85c8b14a746.svg">  significa assumir a integral sobre a esfera, <img src="https://habrastorage.org/getpro/habr/post_images/1ad/0bb/23e/1ad0bb23eb22871d78d2b5cc67d58292.svg">  - fun√ß√£o de fase <img src="https://habrastorage.org/getpro/habr/post_images/da9/7bc/3c5/da97bc3c51ddad728182deecd39ba0d0.svg">  - luz vinda da dire√ß√£o <img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg">  . <br><br>  √â bastante dif√≠cil calcular a luz de todas as dire√ß√µes, no entanto, sabemos que a parte original da luz √© transportada pelo nosso feixe AB original.  A f√≥rmula pode ser bastante simplificada: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/4aa/222/ef84aa22259c648ea9925502712250f6.svg"></div><br>  onde <img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg">  - o √¢ngulo entre o feixe luminoso e o feixe observador (ou seja, o √¢ngulo AXO), <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - o valor inicial da intensidade da luz.  Resumindo todas as op√ß√µes acima, obtemos a f√≥rmula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/fb7/273/642fb727356c245fc6f053dbc9affde8.svg"></div><br>  onde <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - luz recebida <img src="https://habrastorage.org/getpro/habr/post_images/f7a/fbd/138/f7afbd138efabfc5bf5dad3e26e6c0fb.svg">  - a luz atingindo o observador. <br><br>  N√≥s complicamos a tarefa um pouco mais.  Digamos que a luz seja emitida por uma luz direcional, ou seja,  o sol: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/r2/gg/wzr2ggl_1oshhmhn3kkqalhtkoo.png"></div><br>  Tudo acontece da mesma forma que no caso anterior, mas muitas vezes.  A luz do ponto A1 est√° espalhada no ponto X1 em dire√ß√£o ao observador no ponto O, a luz do ponto A2 est√° espalhada no ponto X2 em dire√ß√£o ao observador no ponto O, etc.  Vemos que a luz que chega ao observador √© igual √† soma: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/191/24f/83819124f0beb6bdd5adc3644a79653b.svg"></div><br>  Ou uma express√£o integral mais precisa: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/7b0/5d2/e017b05d2026f311f43bc53da48c130e.svg"></div><br>  √â importante entender que aqui <img src="https://habrastorage.org/getpro/habr/post_images/e7b/3af/88e/e7b3af88eb6397d1f88774b011fe4cbb.svg">  , ou seja,  o segmento √© dividido em um n√∫mero infinito de se√ß√µes com comprimento zero. <br><br><h2>  O c√©u </h2><br>  Com uma ligeira simplifica√ß√£o, um raio de sol que passa atrav√©s da atmosfera sofre apenas dispers√£o, isto √©, <img src="https://habrastorage.org/getpro/habr/post_images/c79/ce0/055/c79ce005518e112e707da427d7231066.svg">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/mm/tz/k0mmtzjcir3wnqxbcjzsouln4yo.png"></div><br>  E nem mesmo um tipo de espalhamento, mas dois: espalhamento Rayleigh e espalhamento Mi.  O primeiro √© causado por mol√©culas de ar e o segundo √© causado por um aerossol de √°gua. <br><br>  A densidade total do ar (ou aerossol) atrav√©s da qual passa um raio de luz, movendo-se do ponto A ao ponto B: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d80/e5d/0bcd80e5d5b35e43fef8336e6c66cde0.svg"></div>  onde <img src="https://habrastorage.org/getpro/habr/post_images/14b/01a/bf0/14b01abf043545d56ac10d61e69792e8.svg">  - altura de escala, h - altura atual. <br><br>  Uma solu√ß√£o integral simples seria: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/b07/e75/d3fb07e750a91c2a253fdcf1de74de72.svg"></div><br>  onde dh √© o tamanho da etapa com a qual a amostra de altura √© coletada. <br><br>  Agora observe a figura e use a f√≥rmula derivada na parte anterior do "modelo de ilumina√ß√£o": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/n0/fr/grn0fr0f-dly-jjpcjpg_pxof9a.png"></div><br>  O observador olha de O para O '.  Queremos coletar toda a luz que atinge os pontos X1, X2, ..., Xn, √© espalhada neles e, em seguida, atinge o observador: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/c25/470/540c25470466173df2e5cf7880390ff9.svg"></div><br>  onde <img src="https://habrastorage.org/getpro/habr/post_images/c87/cb3/ca4/c87cb3ca4e0a0f0fc9d1a9d5c485c116.svg">  a intensidade da luz emitida pelo sol, <img src="https://habrastorage.org/getpro/habr/post_images/6c3/b25/b5f/6c3b25b5f22b9a03c093ef2f25a06339.svg">  - altura no ponto <img src="https://habrastorage.org/getpro/habr/post_images/ee6/2f8/bed/ee62f8bed8d0d0e9b3d3cd2c81841ded.svg">  ;  no caso do c√©u, constante C, que est√° em fun√ß√£o <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  denotado como <img src="https://habrastorage.org/getpro/habr/post_images/cea/f36/742/ceaf36742def9a68dbd173a0ac9c9aeb.svg">  . <br><br>  A solu√ß√£o da integral pode ser a seguinte: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5be/44a/9fc/5be44a9fcdb92469fee29b924a957556.svg"></div><br>  Esta f√≥rmula √© v√°lida para a dispers√£o Rayleigh e Mie.  Como resultado, os valores de luz para cada uma das dispers√µes simplesmente somam: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/cb4/a91/34fcb4a9100e4b9c60a7c7eca2c489ec.svg"></div><br>  <b>Dispers√£o de Rayleigh</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71e/a55/e80/71ea55e8043a70776eb70f29eb84d877.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/03f/8e9/67903f8e987346a525fb22e02e718aad.svg">  (cont√©m valores para cada canal RGB) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c9/02f/384/4c902f3848ae3cb24347ee0b367132d6.svg"><br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/xs/8z/nkxs8zt8hyh909tjilktrkrrvri.png"></div><br>  <b>Mi scatter</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/94b/cc1/72b94bcc19f99b0e164c6a48e4408b44.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9a/52e/00c/c9a52e00c5e6169a8ad778f902e49595.svg">  (os valores para todos os canais RGB s√£o os mesmos) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/208/fcf/3bf/208fcf3bf216540af2bfa93a186a3a19.svg"><br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/jv/sb/fujvsbtduq-il-1reylizx1kosa.png"></div><br>  O n√∫mero de amostras por segmento <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  e no segmento <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  Voc√™ pode pegar 32 e acima.  O raio da Terra √© 6371000 m, a atmosfera √© 100000 m. <br><br>  O que fazer com tudo isso: <br><br><ol><li>  Em cada pixel da tela, calculamos a dire√ß√£o do observador V </li><li>  Tomamos a posi√ß√£o do observador O igual a {0, 6371000, 0} </li><li>  Encontramos <img src="https://habrastorage.org/getpro/habr/post_images/28d/cc9/fe7/28dcc9fe786e9216afc4ab3ae2196ebe.svg">  como resultado da interse√ß√£o do raio com origem no ponto O, e a dire√ß√£o de V e a esfera centralizada no ponto {0,0,0} e um raio de 6471000 </li><li>  Segmento de linha <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  dividir em 32 se√ß√µes de igual comprimento </li><li>  Para cada se√ß√£o, calculamos a dispers√£o Rayleigh e Mie e adicionamos tudo.  Al√©m disso, para calcular <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  tamb√©m precisaremos dividir o segmento <img src="https://habrastorage.org/getpro/habr/post_images/0e6/fb0/4e8/0e6fb04e8525f5a3448df984993ab3c4.svg">  32 parcelas iguais em cada caso. <img src="https://habrastorage.org/getpro/habr/post_images/60e/970/a20/60e970a20b30f36e7c21fe71c3d4dadb.svg">  pode ser lido atrav√©s de uma vari√°vel, cujo valor aumenta a cada etapa do ciclo. </li></ol><br>  O resultado final: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/gb/tl/nogbtlqbuzffixmq7xmt1w4j_ja.png"></div><br><h2>  Modelo de nuvem </h2><br>  Vamos precisar de v√°rios tipos de ru√≠do em 3D.  O primeiro √© o ru√≠do de movimento browniano (fBm) fractal de Perlin: <br><br>  Resultado para uma fatia 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/h6/v6/ldh6v6zglre4jhon_n8qu193o8k.png"></div><br>  O segundo √© o ru√≠do oculto de fBm de Voronoi. <br><br>  Resultado para uma fatia 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aa/rc/s2/aarcs2hvles3h89jqfc1lfrufjk.png"></div><br>  Para obter o ru√≠do fBm de camuflagem de Vorley, voc√™ precisa inverter o ru√≠do fBm de camuflagem de Voronoj.  No entanto, alterei levemente os intervalos de valores a meu crit√©rio: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fbmTiledWorley3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clamp((<span class="hljs-number"><span class="hljs-number">1.0</span></span>-fbmTiledVoronoi3(...))*<span class="hljs-number"><span class="hljs-number">1.5</span></span><span class="hljs-number"><span class="hljs-number">-0.25</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  O resultado se assemelha imediatamente √†s estruturas da nuvem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ha/pf/em/hapfemxrqrxuqfpckajp53j4zxc.png"></div><br>  Para nuvens, voc√™ precisa obter duas texturas especiais.  O primeiro tem um tamanho de 128x128x128 e √© respons√°vel pelo ru√≠do de baixa frequ√™ncia, o segundo tem um tamanho de 32x32x32 e √© respons√°vel pelo ru√≠do de alta frequ√™ncia.  Cada textura usa apenas um canal no formato R8.  Em alguns exemplos, 4 canais de R8G8B8A8 s√£o usados ‚Äã‚Äãpara a primeira textura e tr√™s canais de R8G8B8 para o segundo e, em seguida, os canais s√£o misturados em um shader.  N√£o vejo o ponto, porque a mistura pode ser feita antecipadamente, obtendo um impacto maior na coer√™ncia do cache. <br><br>  Para mixar, e tamb√©m em alguns lugares, a fun√ß√£o remap () ser√° usada, que dimensiona os valores de um intervalo para outro: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMinValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMaxValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newMinValue+(value-minValue)/(maxValue-minValue)*(newMaxValue-newMinValue); }</code> </pre> <br>  Vamos come√ßar a preparar a textura com ru√≠do de baixa frequ√™ncia: <br>  Canal R - ru√≠do fBm de perlin <br>  Canal G - ru√≠do fBm Vorley lado a lado <br>  Canal B - menor ru√≠do fBm Worley com menor escala <br>  Canal A - O ru√≠do tBF de taylable de Varley com escala ainda menor <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/_9/z-/ms_9z-hofvyvya5-zuh6vpi6da0.png"></div><br>  A mistura √© feita desta maneira: <br><br><pre> <code class="cpp hljs">finalValue=remap(noise.x, (noise.y * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.z*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.w * <span class="hljs-number"><span class="hljs-number">0.125</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Resultado para uma fatia 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/qh/rl/64qhrl3wl2vrsbedao4fk9zr3xg.png"></div><br>  Agora prepare a textura com ru√≠do de alta frequ√™ncia: <br>  Canal R - ru√≠do fBm Vorley lado a lado <br>  Canal G - menor ru√≠do de fBm Vorley em escala reduzida <br>  Canal B - ru√≠do Varley taylivaya fBm com escala ainda menor <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/m6/in/oxm6inosejxwrkx2kdz7zv17eea.png"></div><br><pre> <code class="cpp hljs">finalValue=noise.x * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.y*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.z * <span class="hljs-number"><span class="hljs-number">0.125</span></span>;</code> </pre> <br>  Resultado para uma fatia 2D: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/mr/mc/lgmrmc2ohi3ayicwbji49fdhqb4.png"></div><br>  Tamb√©m precisamos de um mapa 2D de clima e textura que determine a presen√ßa, densidade e forma das nuvens, dependendo das coordenadas do espa√ßo.  Ele √© pintado por artistas para ajustar a cobertura de nuvens.  A interpreta√ß√£o dos canais de cores do mapa clim√°tico pode ser diferente, na vers√£o que emprestei, √© a seguinte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/oi/m8/fuoim8wbtdzgqoc2lma8g6gb0ow.png"></div><br>  Canal R - cobertura de nuvens em baixa altitude <br>  Canal G - cobertura de nuvens de alta altitude <br>  Canal B - altura m√°xima da nuvem <br>  Canal A - densidade da nuvem <br><br>  Agora, estamos prontos para criar uma fun√ß√£o que retornar√° a densidade das nuvens, dependendo das coordenadas do espa√ßo 3D. <br><br>  Na entrada, um ponto no espa√ßo com coordenadas em km <br><br><pre> <code class="cpp hljs">vec3 position</code> </pre> <br>  Adicione imediatamente o deslocamento ao vento <br><br><pre> <code class="cpp hljs">position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time;</code> </pre> <br>  Obter os valores do mapa meteorol√≥gico <br><br><pre> <code class="cpp hljs">vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre>  Obtemos a porcentagem de altura (de 0 a 1) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position);</code> </pre> <br>  Adicione um pequeno arredondamento das nuvens abaixo: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Fazemos uma diminui√ß√£o linear na densidade para 0 com o aumento da altura de acordo com o canal B do mapa meteorol√≥gico: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Combine o resultado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt;</code> </pre> <br>  Adicione novamente o arredondamento das nuvens abaixo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Adicione tamb√©m o arredondamento das nuvens no topo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Combinamos o resultado, aqui adicionamos a influ√™ncia da densidade no mapa meteorol√≥gico e a influ√™ncia da densidade, que √© definida via gui: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density;</code> </pre> <br>  Combine ru√≠dos de baixa e alta frequ√™ncia de nossas texturas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>;</code> </pre> <br>  Em todos os documentos que li, a fus√£o ocorre de uma maneira diferente, mas gostei dessa op√ß√£o. <br><br>  Determinamos a quantidade de cobertura (% do c√©u ocupado por nuvens), que √© definida por GUI, os canais R e G do mapa meteorol√≥gico tamb√©m s√£o usados: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Calcular a densidade final: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA;</code> </pre> <br>  Fun√ß√£o inteira: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position)</span></span></span><span class="hljs-function"> </span></span>{ position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time; vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>+vec2(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }</code> </pre> <br>  O que exatamente essa fun√ß√£o deve ser √© uma quest√£o em aberto, porque ignorando as leis que as nuvens obedecem ao definir par√¢metros, voc√™ pode obter um resultado muito incomum e bonito.  Tudo depende da aplica√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nz/bz/tfnzbzvd2oucw2h_oed9pbm_8ku.png"></div><br><h2>  Integra√ß√£o </h2><br>  A atmosfera da Terra √© dividida em duas camadas: interna e externa, entre as quais as nuvens podem ser localizadas.  Essas camadas podem ser representadas por esferas, mas tamb√©m por planos.  Eu me acomodei nas esferas.  Para a primeira camada, peguei o raio da esfera de 6415 km, para a segunda camada, o raio de 6435 km.  O raio da Terra arredondou para 6400 km.  Alguns par√¢metros depender√£o da espessura condicional da parte "nublada" da atmosfera (20 km). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0z/ir/8r/0zir8r9qtvwlh9xk85i-hznhqa0.png"></div><br><br>  Ao contr√°rio do c√©u, as nuvens s√£o opacas e a integra√ß√£o requer n√£o apenas obter a cor, mas tamb√©m obter o valor do canal alfa.  Primeiro, voc√™ precisa de uma fun√ß√£o que retorne a densidade total da nuvem atrav√©s da qual um raio de luz do sol passar√°. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5k/ne/lj/5kneljw4unaofsxxgbq12ealebw.png"></div><br>  Ningu√©m chama a aten√ß√£o para isso, mas a pr√°tica mostrou que n√£o √© necess√°rio levar em considera√ß√£o todo o caminho do feixe, apenas a lacuna mais extrema √© necess√°ria.  Assumimos que as nuvens acima de um segmento truncado n√£o existem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/sr/ly/edsrlyis3-2or1nztj6q-osmats.png"></div><br>  Al√©m disso, somos muito limitados no n√∫mero de amostras de densidade que podem ser feitas sem prejudicar o desempenho.  Guerrilla Games do 6. Al√©m disso, em uma das apresenta√ß√µes, o desenvolvedor disse que eles espalham essas amostras dentro do cone, e a √∫ltima amostra √© especialmente feita muito longe do resto para cobrir o m√°ximo de espa√ßo poss√≠vel.  As imprecis√µes e ru√≠dos resultantes ainda ser√£o suavizados contra o fundo das amostras vizinhas, e isso, pelo contr√°rio, se tornar√° uma precis√£o maior. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/rr/df/5prrdfocofvzsjobvawnairijp0.png"></div><br>  No final, decidi por 4 amostras que est√£o na mesma linha, mas a √∫ltima √© feita com um passo aumentado em 6 vezes.  O tamanho da etapa √© 20 km * 0,01, que √© de 200 m. <br><br>  A fun√ß√£o √© bem simples: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDirectDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   float avrStep=(6435.0-6415.0)*0.01; float sumDensity=0.0; for(int i=0;i&lt;4;i++) { float step=avrStep; //      6 if(i==3) step=step*6.0; //  position+=sunDir*step; //  ,  ,   //  float density=cloudSampleDensity(position)*step; sumDensity+=density; } return sumDensity; }</span></span></code> </pre> <br>  Agora voc√™ pode passar para a parte mais dif√≠cil.  Determinamos o observador na superf√≠cie da Terra no ponto {0, 6400,0} e encontramos a interse√ß√£o do feixe de observa√ß√£o com uma esfera de raio de 6415 km e centro {0,0,0} - obtemos o ponto de partida S. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/25/je/zj/25jezjeea4j3bl51jneypfjetsi.png"></div><br>  Abaixo est√° a vers√£o b√°sica da fun√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { position+=viewDir*step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br>  O tamanho da etapa √© definido como 20 km / 64.  no caso da dire√ß√£o estritamente vertical do feixe do observador, faremos 64 amostras.  No entanto, quando essa dire√ß√£o for mais horizontal, as amostras ser√£o um pouco maiores, portanto n√£o haver√° 64 etapas no ciclo, mas 128 com uma margem. <br><br>  No in√≠cio, assumimos que a cor final √© preta e a transpar√™ncia √© unidade.  A cada passo, aumentaremos o valor da cor e diminuiremos o valor da transpar√™ncia.  Se a transpar√™ncia estiver pr√≥xima de 0, voc√™ poder√° pr√©-sair do loop: <br><br><pre> <code class="cpp hljs">vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//    //      float density=cloudSampleDensity(position)*avrStep; //   ,   //   float sunDensity=cloudSampleDirectDensity(position, sunDir); //      float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*m2*m3; //       color+=sunColor*light*transmittance; transmittance*=exp(-ufmProperties.attenuation*density); ‚Ä¶ return vec4(color, 1.0-transmittance);</span></span></code> </pre> <br>  ufmProperties.attenuation - N√£o h√° nada al√©m de C em <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  e ufmProperties.attenuation2 √© C em <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  .  ufmProperties.sunIntensity - a intensidade da radia√ß√£o do sol.  sunColor - a cor do sol. <br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/ft/z9/vcftz9vsswkxpqoggirezpfpygm.png"></div><br>  Uma falha √© imediatamente evidente - sombreamento intenso.  Mas agora vamos corrigir a falta de ilumina√ß√£o amplificada perto do sol.  Isso aconteceu porque n√£o adicionamos uma fun√ß√£o de fase.  Para calcular a dispers√£o da luz que passa pelas nuvens, usamos a fase da fun√ß√£o Hengy-Greenstein, que a abriu em 1941 para c√°lculos semelhantes em grupos de gases no espa√ßo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/b2e/33f/4b0b2e33fbd07036b14317d40cb1eac0.svg"></div><br>  Uma digress√£o deve ser feita aqui.  De acordo com o modelo de ilumina√ß√£o can√¥nica, a fun√ß√£o de fase deve ser uma.  No entanto, na realidade, o resultado obtido n√£o se adequa a ningu√©m e todo mundo usa fun√ß√µes de duas fases, e at√© combina seus valores de maneira especial.  Tamb√©m me concentrei em fun√ß√µes de duas fases, mas simplesmente adiciono seus valores.  A fun√ß√£o de primeira fase tem g perto de 1 e permite que voc√™ fa√ßa uma ilumina√ß√£o brilhante perto do sol.  A fun√ß√£o da segunda fase tem g pr√≥ximo de 0,5 e permite que voc√™ fa√ßa uma diminui√ß√£o gradual da ilumina√ß√£o em toda a esfera celeste. <br><br>  C√≥digo atualizado: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cos(theta) float mu=max(0, dot(viewDir, sunDir)); float m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); float m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;</span></span></code> </pre> <br>  ufmProperties.eccentrisy, ufmProperties.eccentrisy2 s√£o valores de g <br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ip/qr/fi/ipqrfivyafyxnmdswnn_nbpvfdk.png"></div><br>  Agora voc√™ pode come√ßar a luta com muito sombreamento.  Est√° presente porque n√£o levamos em conta a luz das nuvens circundantes e do c√©u, que est√° na vida real. <br><br>  Eu resolvi esse problema assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(color+ambientColor*ufmProperties.ambient, <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  Onde ambientColor √© a cor do c√©u na dire√ß√£o do feixe de observa√ß√£o, ufmProperties.ambient √© o par√¢metro de ajuste. <br><br>  Resultado: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/8h/ji/ct8hjiyk7brz5pv8vuwjeji33bc.png"></div><br>  Resta resolver o √∫ltimo problema.  Na vida real, quanto mais horizontal a vis√£o √© mantida, mais vemos um certo nevoeiro ou neblina que n√£o nos permite ver objetos muito distantes.  Isso tamb√©m precisa ser refletido no c√≥digo.  Peguei o cosseno usual do √¢ngulo do olhar e a fun√ß√£o exponencial.  Com base nisso, um certo coeficiente de mistura √© calculado, o que permite a interpola√ß√£o linear entre a cor resultante e a cor de fundo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  ufmProperties.fog - para configura√ß√£o manual. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/02/td/9h/02td9ho6kelgum68wldvcf-zymu.png"></div><br>  Fun√ß√£o Resumo: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir, vec3 sunColor, vec3 ambientColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> density=cloudSampleDensity(position)*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(density&gt;<span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sunDensity=cloudSampleDirectDensity(position, sunDir); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mu=max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, sunDir)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m2=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*sunDensity); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m3=ufmProperties.attenuation2*density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3; color+=sunColor*light*transmittance; transmittance*=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*density); } position+=viewDir*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(transmittance&lt;<span class="hljs-number"><span class="hljs-number">0.05</span></span> || length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance); }</code> </pre> <br>  V√≠deo de demonstra√ß√£o: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uPxVgbwThmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Otimiza√ß√£o e poss√≠veis melhorias </h2><br>  Depois de implementar o algoritmo b√°sico de renderiza√ß√£o, o pr√≥ximo problema √© que ele funciona muito lentamente.  Minha vers√£o produziu 25 fps em full hd na radeon rx 480. As duas abordagens a seguir para resolver o problema foram sugeridas pelos pr√≥prios Guerrilla Games. <br><br>  <b>Desenhamos o que √© realmente vis√≠vel</b> <br><br>  A tela √© dividida em blocos de 16x16 pixels de tamanho.  Primeiro, o ambiente 3D usual √© desenhado.  Acontece que a maior parte do c√©u √© coberta por montanhas ou objetos grandes.  Portanto, voc√™ precisa executar o c√°lculo apenas nos blocos em que as nuvens n√£o s√£o bloqueadas por nada. <br><br>  <b>Reproje√ß√£o</b> <br><br>  Quando a c√¢mera est√° parada, acontece que as nuvens em geral n√£o podem ser atualizadas.  No entanto, se a c√¢mera se mover, isso n√£o significa que precisamos atualizar a tela inteira.  Tudo j√° est√° desenhado, voc√™ s√≥ precisa reconstruir a imagem de acordo com as novas coordenadas.  Encontrar coordenadas antigas em novas, atrav√©s das matrizes de proje√ß√£o e visualiza√ß√£o dos quadros atuais e anteriores, √© chamada de proje√ß√£o.  Assim, no caso de troca de c√¢mera, simplesmente transferimos as cores de acordo com as novas coordenadas.  Nos casos em que essas coordenadas indicam fora da tela, as nuvens devem ser honestamente redesenhadas. <br><br>  <b>Atualiza√ß√£o parcial</b> <br><br>  N√£o gosto da ideia de reproje√ß√£o, porque, com uma curva brusca da c√¢mera, pode acontecer que as nuvens tenham que ser renderizadas para um ter√ßo da tela, o que pode causar atraso.  N√£o sei como a Guerrilla Games lidou com isso, mas pelo menos no Horizon Zero Dawn, ao controlar o joystick, a c√¢mera se move sem problemas e n√£o h√° problemas com saltos agudos.  Portanto, como um experimento, criei minha pr√≥pria abordagem.  As nuvens s√£o desenhadas em um mapa c√∫bico, em 5 faces, porque  o fundo n√£o nos interessa.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O lado do mapa c√∫bico tem uma resolu√ß√£o reduzida igual a ‚Öî da altura da tela. Cada face do mapa c√∫bico √© dividida em blocos 8x8. Cada quadro em cada face √© atualizado com apenas um dos 64 pixels em cada bloco. Isso fornece artefatos vis√≠veis durante mudan√ßas repentinas, mas porque como as nuvens s√£o est√°ticas, esse truque √© invis√≠vel. Como resultado, a radeon rx 480 produz 500 fps em full hd para o vulc√£o e 330 fps para opengl. A s√©rie Radeon hd 5700 produz 109 fps em full hd em opengl (o vulkan n√£o suporta). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usando n√≠veis de mip</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ao acessar texturas com ru√≠do, voc√™ pode coletar dados do n√≠vel de mip zero apenas nas primeiras amostras e, quanto mais as amostras que fazemos, maior o n√≠vel de mip. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nuvens altas</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para simular a presen√ßa de nuvens cirrus-altitude e cirrocumulus nos Jogos de Guerrilha durante a integra√ß√£o, as amostras mais recentes s√£o feitas n√£o das texturas 3D de que falei, mas de uma textura 2D especial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/f2/vj/udf2vjpfht0hhpbf9zptwfmadhg.jpeg"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ru√≠do de</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> curvatura V√°rias texturas adicionais no ru√≠do de curvatura s√£o usadas para criar o efeito das nuvens de vento. </font><font style="vertical-align: inherit;">Essas texturas s√£o necess√°rias para mudar as coordenadas originais.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/qq/pg/-nqqpgmixyogyjxqrdyhm4oxlpc.png"></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raios divinos</font></font></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/wq/xv/qdwqxvzveiwuxgu2v84aw5fhjwo.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tais raios, captando dramas, s√£o realizados no p√≥s-processamento. </font><font style="vertical-align: inherit;">Primeiro, uma ilumina√ß√£o brilhante √© desenhada ao redor do sol, onde n√£o √© bloqueada pelas nuvens. </font><font style="vertical-align: inherit;">Ent√£o essa luz de fundo deve ser deslocada radialmente para longe do sol.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/vj/-a/apvj-assr02-vaov3o1k5frfawk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora voc√™ precisa aplicar a suaviza√ß√£o radial. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/lg/1h/jdlg1hp7jajzhlbom4ocmn3vl70.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, existem muito mais melhorias e sutilezas, mas eu n√£o verifiquei todas elas, ent√£o n√£o posso contar com confian√ßa sobre elas. No entanto, voc√™ pode se familiarizar com eles. O mais forte que eu acho √© a documenta√ß√£o em nuvem do mecanismo Frostbite.</font></font><br><br><h2>  Links √∫teis </h2><br> <b> Guerrilla Games</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">d1z4o56rleaq4j.cloudfront.net/downloads/assets/Nubis-Authoring-Realtime-Volumetric-Cloudscapes-with-the-Decima-Engine-Final.pdf?mtime=20170807141817</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">killzone.dl.playstation.net/killzone/horizonzerodawn/presentations/Siggraph15_Schneider_Real-Time_Volumetric_Cloudscapes_of_Horizon_Zero_Dawn.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.youtube.com/watch?v=-d8qT5-1LOI</a> <br><br> <b>  GPU Pro 7</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vk.com/doc179245989_437393482?hash=a9af5f665eda4edf58&amp;dl=806d4dbdac0f7a761c</a> <br><br> <b></b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky</a> <br><br> <b> Frostbite</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">www.shadertoy.com/view/XlBSRz</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459948/">https://habr.com/ru/post/pt459948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459924/index.html">Ciclo de teste de rea√ß√£o completa. Relat√≥rio Auto.ru</a></li>
<li><a href="../pt459928/index.html">Caminho do aluno para o desenvolvimento de aplicativos para dispositivos m√≥veis</a></li>
<li><a href="../pt459930/index.html">Automa√ß√£o de importa√ß√£o Python</a></li>
<li><a href="../pt459934/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel 306 (de 8 a 14 de julho)</a></li>
<li><a href="../pt459936/index.html">Mais 9 truques para trabalhar com o Visual Studio</a></li>
<li><a href="../pt459952/index.html">Um pouco de experi√™ncia sobre backup e armazenamento</a></li>
<li><a href="../pt459954/index.html">Por que uma das maiores empresas de TI ingressou no CNCF - um fundo que desenvolve infraestrutura de nuvem</a></li>
<li><a href="../pt459956/index.html">Implanta√ß√£o na aus√™ncia completa de dentes, como resultado de visitas prematuras ao dentista</a></li>
<li><a href="../pt459958/index.html">Analisando tarefas da confer√™ncia Hydra - balanceamento de carga e armazenamento na mem√≥ria</a></li>
<li><a href="../pt459960/index.html">Da ideia ao lan√ßamento. Experi√™ncia detalhada de front-end do mercado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>