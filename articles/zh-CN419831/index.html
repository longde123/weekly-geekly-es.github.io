<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👦🏼 🤱🏿 👩🏻‍🔬 JS的工作方式：自定义元素 ✍🏽 🔪 🥝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[建议阅读]周期的其他19个部分  第1部分： 引擎概述，运行时机制，调用堆栈 
 第2部分： 关于V8内部和代码优化 
 第3部分： 管理内存，四种类型的内存泄漏并进行处理 
 第4部分： 事件循环，异步和通过异步/等待改进代码的五种方法 
 第5部分： WebSocket和HTTP / 2 + ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JS的工作方式：自定义元素</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/419831/"><div class="spoiler">  <b class="spoiler_title">[建议阅读]周期的其他19个部分</b> <div class="spoiler_text"> 第1部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引擎概述，运行时机制，调用堆栈</a> <br> 第2部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于V8内部和代码优化</a> <br> 第3部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">管理内存，四种类型的内存泄漏并进行处理</a> <br> 第4部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事件循环，异步和通过异步/等待改进代码的五种方法</a> <br> 第5部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebSocket和HTTP / 2 + SSE。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">选择什么？</a> <br> 第6部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WebAssembly的功能和范围</a> <br> 第7部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web Workers和五个使用方案</a> <br> 第八部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">服务人员</a> <br> 第9部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web推送通知</a> <br> 第10部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用MutationObserver跟踪DOM中的更改</a> <br> 第11部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网页呈现引擎和优化其性能的技巧</a> <br> 第12部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络子系统，优化其性能和安全性</a> <br> 第12部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">网络子系统，优化其性能和安全性</a> <br> 第13部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CSS和JavaScript动画</a> <br> 第14部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：抽象语法树，解析及其优化</a> <br> 第15部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：类和继承，Babel和TypeScript中的转译</a> <br> 第16部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：存储</a> <br> 第17部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：Shadow DOM技术和Web组件</a> <br> 第18部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作原理：WebRTC和P2P通讯机制</a> <br> 第19部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS的工作方式：自定义元素</a> </div></div><br> 我们提请您注意<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SessionStack</a>系列材料中19篇文章的翻译，这些文章涉及JavaScript生态系统的各种机制。 今天，我们将讨论“定制元素”标准-所谓的“定制元素”。 我们将讨论它们允许解决哪些任务，以及如何创建和使用它们。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/188/85f/00e18885fa38229e7bc5cc7c4489147c.png" alt="图片"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">复习</font> </h2><br> 在本系列的前几篇文章中，我们讨论了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Shadow DOM</a>和作为更大现象一部分的其他一些技术-Web组件。  Web组件旨在使开发人员能够通过创建紧凑，模块化和可重用的元素来扩展HTML的标准功能。 这是所有领先的浏览器制造商都已经注意到的相对较新的W3C标准。 当然，可以在生产中找到他，尽管他的作品是由多亲人士提供的（我们将在后面讨论）。 <br><br> 您可能已经知道，浏览器为我们提供了一些用于开发网站和Web应用程序的基本工具。 它是关于HTML，CSS和JavaScript的。  HTML用于构造网页，这要归功于CSS，它们使CSS看起来很漂亮，而JavaScript负责交互功能。 但是，在Web组件出现之前，将JavaScript实现的动作与HTML结构关联起来并不容易。 <br><br> 事实上，这里我们将考虑Web组件的基础-自定义元素。 简而言之，旨在与它们一起使用的API允许程序员使用CSS描述的内置JavaScript逻辑和样式来创建自己的HTML元素。 许多人将自定义元素与Shadow DOM技术混淆了。 但是，这是两个完全不同的事实，它们实际上是相辅相成的，但不能互换。 <br><br> 一些框架（例如Angular或React）试图通过引入其自身的概念来解决自定义元素所解决的相同问题。 可以将自定义元素与Angular指令或React组件进行比较。 但是，自定义元素是浏览器的标准功能；除了普通的JavaScript，HTML和CSS之外，您无需使用其他任何元素。 当然，这不允许我们说它们是普通JS框架的替代品。 现代框架为我们提供的不仅仅是模拟自定义元素行为的能力。 结果，我们可以说框架和用户元素都是可以一起用于解决Web开发任务的技术。 <br><br><h2>  <font color="#3AC1EF">API</font> </h2><br> 在继续之前，让我们看看API给我们带来了使用自定义元素的机会。 即，我们正在谈论具有以下方法的全局<code>customElements</code>对象： <br><br><ul><li>  <code>define(tagName, constructor, options)</code>方法<code>define(tagName, constructor, options)</code>使您可以定义（创建，注册）新的用户元素。 它带有三个参数-用户元素的标签名称（对应于此类元素的命名规则），类声明和带有参数的对象。 当前仅支持一个参数<code>extends</code> ，这是一个字符串，用于指定要扩展的内联元素的名称。 此功能用于创建标准元素的特殊版本。 </li><li> 如果该元素已经定义，则<code>get(tagName)</code>方法返回user元素的构造函数，否则返回<code>undefined</code> 。 它带有一个参数-用户元素的名称标签。 </li><li>  <code>whenDefined(tagName)</code>方法返回创建用户元素后解析的promise。 如果已经定义了元素，则立即解决此承诺。 如果传递给它的标签名称不是用户元素的有效标签名称，则承诺将被拒绝。 此方法接受用户元素的标签名称。 </li></ul><br><h2>  <font color="#3AC1EF">创建自定义项目</font> </h2><br> 创建自定义元素非常简单。 为此，必须完成两件事：为应扩展<code>HTMLElement</code>类的元素创建一个类声明，并将该元素注册为所选名称。 看起来是这样的： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// … } // … } customElements.define('my-custom-element', MyCustomElement);</span></span></code> </pre> <br> 如果您不想污染当前范围，则可以使用匿名类： <br><br><pre> <code class="hljs scala">customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-comment"><span class="hljs-comment">// … } // … });</span></span></code> </pre> <br> 从示例中可以看到，用户元素是使用您已经熟悉的<code>customElements.define(...)</code>方法注册的。 <br><br><h2>  <font color="#3AC1EF">自定义元素解决的问题</font> </h2><br> 让我们谈谈允许我们解决自定义元素的问题。 其中之一是改善代码的结构，并消除所谓的“ div标签汤”（div汤）。 这种现象是现代Web应用程序中非常常见的代码结构，其中许多彼此嵌入的<code>div</code>元素。 可能是这样的： <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"top-container"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"middle-container"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-container"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"inside-inside-container"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"are-we-really-doing-this"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"mariana-trench"</span></span>&gt;           …         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br> 使用此类HTML代码出于正当理由-描述页面的布局并确保其在屏幕上的正确显示。 但是，这损害了HTML代码的可读性并使它的维护复杂化。 <br><br> 假设我们有一个如下图所示的组件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85a/949/ef6/85a949ef606dd68521cd83fd845d09ba.png"></div><br>  <i><font color="#999999">组件外观</font></i> <br><br> 使用传统方法来描述此类事物，以下代码将与此组件相对应： <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"primary-toolbar toolbar"</span></span>&gt; &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar"</span></span>&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-undo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-redo"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-print"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt;   &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-toggle-button toolbar-button"</span></span>&gt;     &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-outer-box"</span></span>&gt;       &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"toolbar-button-inner-box"</span></span>&gt;         &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon"</span></span>&gt;           &lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"icon-paint-format"</span></span>&gt; &lt;/div&gt;         &lt;/div&gt;       &lt;/div&gt;     &lt;/div&gt;   &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</code> </pre> <br> 现在想象一下，我们可以使用以下组件描述代替代码： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-undo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-redo"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-print"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-button</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"icon-paint-format"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-toggle-button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">toolbar-group</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">primary-toolbar</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 我相信每个人都会同意第二个代码片段看起来要好得多。 这样的代码更易于阅读，易于维护，并且开发人员和浏览器都可以理解。 总而言之，事实是它比嵌套的<code>div</code>标签很多的简单。 <br><br> 使用自定义元素可以解决的下一个问题是代码重用。 开发人员编写的代码不仅应该有效，而且应该受支持。 与不断编写相同的结构相反，重用代码可以提高项目支持能力。 <br> 这是一个简单的示例，可以帮助您更好地理解这个想法。 假设我们具有以下元素： <br><br><pre> <code class="hljs scala">&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt; &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt;</code> </pre> <br> 如果您经常需要它，那么采用通常的方法，我们将不得不一次又一次地编写相同的HTML代码。 现在想象一下，您需要对此代码进行更改，无论使用它在哪里，都应该反映出来。 这意味着我们需要找到使用此片段的所有位置，然后在各处进行相同的更改。 它漫长，艰辛且充满错误。 <br><br> 如果我们可以在需要此元素的地方放好，只需编写以下内容： <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;&lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br> 但是，现代Web应用程序不仅仅是静态HTML。 他们是互动的。 它们互动的源头是JavaScript。 通常，为了提供这种功能，将创建一些元素，然后将事件侦听器连接到它们，这使它们可以响应用户的影响。 例如，它们可以响应单击，鼠标指针在其上方的“悬停”，在屏幕上拖动它们等等。 以下是将事件侦听器连接到用鼠标单击时发生的元素的方法： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myDiv = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'.my-custom-element'</span></span>); myDiv.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, _ =&gt; { myDiv.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;b&gt; I have been clicked &lt;/b&gt;'</span></span>; });</code> </pre> <br> 这是此元素的HTML代码： <br><br><pre> <code class="hljs cs">&lt;div <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt; I have not been clicked yet. &lt;/div&gt;</code> </pre> <br> 通过使用API​​处理自定义元素，所有这些逻辑都可以包含在元素本身中。 为了进行比较-以下是用于声明包含事件处理程序的自定义元素的代码： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ constructor() {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>();   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;   self.addEventListener(<span class="hljs-symbol"><span class="hljs-symbol">'clic</span></span>k', _ =&gt; {     self.innerHTML = '&lt;b&gt; <span class="hljs-type"><span class="hljs-type">I</span></span> have been clicked &lt;/b&gt;';   }); } } customElements.define(<span class="hljs-symbol"><span class="hljs-symbol">'my</span></span>-custom-element', <span class="hljs-type"><span class="hljs-type">MyCustomElement</span></span>);</code> </pre> <br> 这是页面HTML代码中的外观： <br><br><pre> <code class="hljs powershell">&lt;my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt; I have not been clicked yet &lt;/my<span class="hljs-literal"><span class="hljs-literal">-custom</span></span><span class="hljs-literal"><span class="hljs-literal">-element</span></span>&gt;</code> </pre> <br> 乍一看，创建自定义元素似乎需要更多的JS代码行。 但是，在实际应用中，很少会创建此类元素仅使用一次。 现代Web应用程序中的另一个典型现象是，其中的大多数元素都是动态创建的。 这导致需要支持两种不同的使用元素的场景-使用JavaScript将元素动态添加到页面中时的情况，以及在页面的原始HTML结构中描述时的情况。 由于使用了自定义元素，因此简化了这两种情况下的工作。 <br><br> 结果，如果我们总结本节的结果，可以说用户元素使代码更清晰，简化了对代码的支持，有助于将代码分解为小模块，这些模块包括所有必要的功能并且适合重用。 <br><br> 现在，我们已经讨论了使用自定义元素的一般问题，让我们谈谈它们的功能。 <br><br><h2>  <font color="#3AC1EF">要求条件</font> </h2><br> 在开始开发自己的定制元素之前，您应该了解创建它们时必须遵循的一些规则。 它们是： <br><br><ul><li> 组件名称必须包含连字符（ <code>-</code>符号）。 因此，HTML解析器可以区分嵌入式元素和用户元素。 此外，这种方法可确保名称与内置元素（既与现在的元素又与将来的元素）不冲突。 例如，自定义元素的实际名称是<code>&gt;my-custom-element&lt;</code> ，而名称<code>&gt;myCustomElement&lt;</code>和<code>&lt;my_custom_element&gt;</code>不合适。 </li><li> 禁止多次注册同一标签。 尝试执行此操作将导致浏览器<code>DOMException</code>错误。 自定义元素无法重新定义。 </li><li> 自定义标签不能自动关闭。  HTML解析器仅支持有限的一组标准自关闭标签（例如<code>&lt;img&gt;</code> ， <code>&lt;link&gt;</code> ， <code>&lt;br&gt;</code> ）。 </li></ul><br><h2>  <font color="#3AC1EF">可能性</font> </h2><br> 让我们谈谈如何使用自定义元素。 简而言之，如果您回答这个问题，那么您可以使用它们做很多有趣的事情。 <br><br> 自定义元素最显着的特征之一是元素类的声明是指DOM元素本身。 这意味着您可以在广告中使用this关键字来连接事件侦听器，访问属性，子节点等。 <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   this.addEventListener('mouseover', _ =&gt; {     console.log('I have been hovered');   }); } // ... }</span></span></code> </pre> <br> 当然，这使得将新数据写入元素的子节点成为可能。 但是，不建议这样做，因为这可能导致元素的意外行为。 如果您以为自己使用的是其他人设计的元素，那么如果您自己放置在元素中的标记被其他元素替换，您可能会感到惊讶。 <br><br> 有几种方法可让您在元素生命周期的某些时间执行代码。 <br><br><ul><li> 在创建或“升级”元素时， <code>constructor</code>方法将被调用一次（我们将在下面讨论）。 通常，它用于初始化元素的状态，连接事件侦听器，创建Shadow DOM等。 不要忘记，您始终需要在构造函数中调用<code>super()</code> 。 </li><li> 每次将元素添加到DOM时，都会调用<code>connectedCallback</code>方法。 可以使用它（这正是建议使用的方式），以便将任何操作的执行推迟到元素出现在页面上之前（例如，通过这种方式，您可以延迟某些数据的加载）。 </li><li> 从DOM中删除项目时，将调用<code>disconnectedCallback</code>方法。 通常用于释放资源。 请注意，如果用户关闭带有页面的浏览器选项卡，则不会调用此方法。 因此，在必要时不要依赖他来执行一些特别重要的动作。 </li><li> 添加，删除，更新或替换元素<code>attributeChangedCallback</code>时，调用<code>attributeChangedCallback</code>方法。 另外，在解析器创建元素时调用它。 但是，请注意，此方法仅适用于<code>observedAttributes</code>属性中列出的属性。 </li><li> 当使用<code>document.adoptNode(...)</code>方法时， <code>adoptedCallback</code>调用<code>adoptedCallback</code>方法，该方法用于将节点移至另一个文档。 </li></ul><br> 请注意，以上所有方法都是同步的。 例如，将元素添加到DOM后立即调用<code>connectedCallback</code>方法，程序的其余部分等待此方法的完成。 <br><br><h2>  <font color="#3AC1EF">财产反思</font> </h2><br> 嵌入式HTML元素具有一个非常方便的功能：属性反射。 由于这种机制，某些属性的值直接作为属性反映在DOM中。 假设这是<code>id</code>属性的特征。 例如，我们执行以下操作： <br><br><pre> <code class="hljs cs">myDiv.id = <span class="hljs-string"><span class="hljs-string">'new-id'</span></span>;</code> </pre> <br> 相关更改将影响DOM： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"new-id"</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 该机构以相反的方向操作。 这非常有用，因为它允许您声明性地配置元素。 <br><br> 自定义元素没有此内置功能，但您可以自己实现。 为了使用户元素的某些属性具有相似的行为，可以配置其getter和setter。 <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... get myProperty() {   return this.hasAttribute('my-property'); } set myProperty(newValue) {   if (newValue) {     this.setAttribute('my-property', newValue);   } else {     this.removeAttribute('my-property');   } } // ... }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">扩展现有项目</font> </h2><br> 使用自定义元素API，您不仅可以创建新的HTML元素，还可以扩展现有元素。 而且，我们在谈论标准元素和自定义元素。 这是通过在声明类时使用<code>extends</code>来完成的： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyAwesomeButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyButton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } customElements.define('my-awesome-button', MyAwesomeButton);&lt;/cosourcede&gt;      ,  , ,    &lt;code&gt;customElements.define(...)&lt;/code&gt;,    &lt;code&gt;extends&lt;/code&gt;   ,      .     ,        ,        DOM-.   ,          ,      ,       . &lt;source&gt;class MyButton extends HTMLButtonElement { // ... } customElements.define('my-button', MyButton, {extends: 'button'});</span></span></code> </pre> <br> 扩展的标准元素也称为“定制的内置元素”。 <br><br> 建议将始终扩展现有元素并逐步进行作为规则。 这将允许您在新元素中保存先前创建的元素（即属性，属性，函数）中实现的功能。 <br><br> 请注意，现在仅Chrome 67+支持自定义内置元素。 这将出现在其他浏览器中，但是，众所周知，Safari开发人员决定不实施此机会。 <br><br><h2>  <font color="#3AC1EF">更新项目</font> </h2><br> 如前所述， <code>customElements.define(...)</code>方法用于注册自定义元素。 但是，注册不能称为必须首先执行的操作。 用户元素注册可以推迟一段时间，而且，即使元素已经添加到DOM中，也可能会推迟。 此过程称为升级。 为了确定何时注册项目，浏览器提供了<code>customElements.whenDefined(...)</code>方法。 给他指定了元素标记的名称，并且他返回了在元素注册后解析的promise。 <br><br><pre> <code class="hljs javascript">customElements.whenDefined(<span class="hljs-string"><span class="hljs-string">'my-custom-element'</span></span>).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'My custom element is defined'</span></span>); });</code> </pre> <br> 例如，您可能需要延迟元素的注册，直到声明其子元素为止。 如果项目具有嵌套的用户元素，则这种行为方式可能非常有用。 有时，父级可以依靠子级元素的实现。 在这种情况下，您需要确保孩子在父母之前注册。 <br><br><h2>  <font color="#3AC1EF">影子dom</font> </h2><br> 如前所述，自定义元素和Shadow DOM是互补技术。 第一个允许您将JS逻辑封装在用户元素中，第二个允许您为不受外部影响的DOM片段创建隔离的环境。 如果您觉得需要更好地理解Shadow DOM概念，请阅读我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以前的出版物之一</a> 。 <br><br> 以下是将Shadow DOM用于自定义元素的方法： <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   let elementContent = document.createElement('div');   shadowRoot.appendChild(elementContent); } // ... });</span></span></code> </pre> <br> 如您所见，调用<code>this.attachShadow</code>在<code>this.attachShadow</code>起着关键作用。 <br><br><h2>  <font color="#3AC1EF">模式</font> </h2><br> 在我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以前的</a>一篇文章中，我们讨论了一些模板，尽管实际上它们值得单独撰写。 在这里，我们将看一个简单的示例，说明如何在创建模板时将模板嵌入自定义元素中。 因此，使用<code>&lt;template&gt;</code> ，您可以描述解析器将处理但不会在页面上显示的DOM片段： <br><br><pre> <code class="hljs scala">&lt;template id=<span class="hljs-string"><span class="hljs-string">"my-custom-element-template"</span></span>&gt; &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-custom-element"</span></span>&gt;   &lt;input <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"text"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"email"</span></span> /&gt;   &lt;button <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"submit"</span></span>&gt;&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;</code> </pre> <br> 这是在自定义元素中应用模板的方法： <br><br><pre> <code class="hljs scala">let myCustomElementTemplate = document.querySelector('#my-custom-element-template'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyCustomElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... constructor() {   super();   let shadowRoot = this.attachShadow({mode: 'open'});   shadowRoot.appendChild(myCustomElementTemplate.content.cloneNode(true)); } // ... });</span></span></code> </pre> <br> 如您所见，自定义元素，Shadow DOM和模板结合在一起。 这使我们能够创建一个隔离在其自身空间中的元素，其中HTML结构与JS逻辑分离。 <br><br><h2>  <font color="#3AC1EF">程式化</font> </h2><br> 到目前为止，我们仅谈论JavaScript和HTML，而忽略CSS。 因此，我们现在谈谈样式主题。 显然，我们需要一些样式来定制元素。 可以在Shadow DOM内添加样式，但是随后出现的问题是，例如，如何从外部对这些元素进行样式设置-如果创建者没有使用它们。 这个问题的答案非常简单-自定义元素的样式与内置元素相同。 <br><br><pre> <code class="hljs mel">my-custom-element { border-radius: <span class="hljs-number"><span class="hljs-number">5</span></span>px; width: <span class="hljs-number"><span class="hljs-number">30</span></span>%; height: <span class="hljs-number"><span class="hljs-number">50</span></span>%; <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br> 请注意，外部样式优先于在元素内部声明的样式，并覆盖它们。 <br><br> 您可能已经了解了如何在屏幕上显示页面时在某个点上观察到非风格化的内容（这就是所谓的FOUC-未样式化内容的闪烁）。 您可以通过设置未注册组件的样式并在注册它们时使用一些视觉效果来避免这种现象。 为此，可以使用选择器<code>:defined</code> 。 例如，您可以这样做： <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">my-button</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:not(</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:defined)</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">20px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">opacity</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  <font color="#3AC1EF">未知元素和未定义用户元素</font> </h2><br>  HTML规范非常灵活，它允许您声明开发人员所需的任何标签。 而且，如果浏览器无法识别该标签，则解析器会将其作为<code>HTMLUnknownElement</code> ： <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'thisElementIsUnknown'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLUnknownElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is unknown'</span></span>); }</code> </pre> <br> 但是，在使用自定义元素时，这种方案不适用。 ,       ?     ,    ,      <code>HTMLElement</code>        . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'this-element-is-undefined'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> HTMLElement) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'The selected element is undefined but not unknown'</span></span>); }</code> </pre> <br>   <code>HTMLElement</code>  <code>HTMLUnknownElement</code>    ,    ,  ,  ,    -   .  ,  ,     ,    .          <code>div</code> .             . <br><br><h2> <font color="#3AC1EF"> </font> </h2><br>         Chrome 36+.     API Custom Components v0,    , ,     ,    .    API,  ,  —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . API Custom Elements v1   Chrome 54+   Safari 10.1+ (   ).  Mozilla      v50,     ,     . ,   Microsoft Edge      API.  ,        ,   webkit. ,    ,  ,         —   IE 11. <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>  ,  ,       ,        <code>customElements</code> <br>   <code>window</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> supportsCustomElements = <span class="hljs-string"><span class="hljs-string">'customElements'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supportsCustomElements) { <span class="hljs-comment"><span class="hljs-comment">// API Custom Elements   }</span></span></code> </pre> <br>      : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadScript</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">src</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'script'</span></span>);   script.src = src;   script.onload = resolve;   script.onerror = reject;   <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.head.appendChild(script); }); } <span class="hljs-comment"><span class="hljs-comment">//    -    . if (supportsCustomElements) { //    ,    . } else { loadScript('path/to/custom-elements.min.js').then(_ =&gt; {   //   ,     . }); }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">总结</font> </h2><br>        ,     : <br><br><ul><li>     HTML- JavaScript-,   ,      CSS-. </li><li>      HTML- ( ,   ). </li><li>           . ,   —   JavaScript, HTML, CSS, ,      ,  . </li><li>             - (Shadow DOM, , ,   ). </li><li>         ,     . </li><li>       ,     . </li></ul><br>  ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  Custom Elements v1      , ,    , ,   ,      . <br><br>  <b>亲爱的读者们！</b>         ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419831/">https://habr.com/ru/post/zh-CN419831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419817/index.html">在Kubernetes中启动RabbitMQ集群</a></li>
<li><a href="../zh-CN419819/index.html">衰老的生物标志物。 面板脆弱。 第二部分</a></li>
<li><a href="../zh-CN419823/index.html">不寻常的二重唱-密码短语和助记符图像</a></li>
<li><a href="../zh-CN419825/index.html">在虚拟环境中测试几种类型的驱动器的性能</a></li>
<li><a href="../zh-CN419829/index.html">OpenSSH的默认密钥加密总比没有好</a></li>
<li><a href="../zh-CN419833/index.html">远程工作，如何工作</a></li>
<li><a href="../zh-CN419835/index.html">如何激励作者，与专家进行谈判并撰写出色的文章</a></li>
<li><a href="../zh-CN419837/index.html">我，RoboLoyer或如何查找文档中的异常</a></li>
<li><a href="../zh-CN419839/index.html">低级别NCR ATM黑客</a></li>
<li><a href="../zh-CN419843/index.html">极客大学在人工智能学院开放招生</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>