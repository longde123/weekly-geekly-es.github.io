<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♨️ 🤽🏽 🐺 Redux与React Context API 👩🏾‍🏫 👩🏾‍⚕️ 🧜🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在React 16.3中，添加了新的Context API。 从旧的 Context API在幕后的意义上讲，它是新的，大多数人要么不知道它的存在，要么不使用它，因为文档建议不要使用它。 

 但是，现在Context API是React的完整组成部分，可以使用（不像以前那样正式使用）。 

 在R...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Redux与React Context API</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419449/"><img src="https://habrastorage.org/webt/fg/fp/ik/fgfpikxzusi8yqxz5vioyhdjgxm.png"><br><br> 在React 16.3中，添加了新的Context API。 从<i>旧的</i> Context API在幕后的意义上讲，它是<i>新</i>的，大多数人要么不知道它的存在，要么不使用它，因为文档建议不要使用它。 <br><br> 但是，现在Context API是React的完整组成部分，可以使用（不像以前那样正式使用）。 <br><a name="habracut"></a><br> 在React 16.3发行之后，立即出现了一些文章，宣称由于新的Context API，Redux死亡。 如果您向Redux询问此事，我想他会回答-“我的死讯被<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大大夸大了</a> 。” <br><br> 在本文中，我想讨论一下新的Context API的工作原理，它看起来像Redux的情况，何时可以使用Context而不是Redux的原因，以及为什么Context在每种情况下都不能代替Redux。 <br><br>  <b>如果您只需要Context API的概述，可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">点击链接</a> 。</b> <br><br><h3>  React应用示例 </h3><br> 我假设您已经了解了在React（props＆state）中使用状态的原理，但是如果不是这样，我将提供为期5天的免费课程，以帮助<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">您了解它</a> 。 <br><br> 让我们看一个示例，将我们带到Redux中使用的概念。 我们将从一个简单的React版本开始，然后看看它在Redux中的外观，最后是Context。 <br><br><img src="https://habrastorage.org/webt/tq/8q/ze/tq8qzesfpe66d4kveo0p6y10cv0.png"><br><br> 在此应用程序中，用户信息显示在两个位置：右上角的导航栏中和主要内容旁边的侧面板中。 <br><br>  （您可能会注意到与Twitter有很多相似之处。这并非巧合！磨练您的React技能的最好方法之一就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">复制（创建现有网站/应用程序的副本）</a> 。 <br><br> 该组件的结构如下所示： <br><br><img src="https://habrastorage.org/webt/ld/x0/3j/ldx03joils7rg-6cszxkur0dm_u.png"><br><br> 使用纯React（仅支持props），我们需要将用户信息存储在树中足够高的位置，以便可以将其传递给需要它的组件。 在这种情况下，用户信息必须在应用程序中。 <br><br> 然后，为了将有关用户的信息传输到需要它的那些组件，应用程序必须将其传递给Nav和Body。 然后，他们会将其传递给UserAvatar（欢呼！）和补充工具栏。 最后，补充工具栏应将其传递给UserStats。 <br><br> 让我们看看这在代码中是如何工作的（我将所有内容放在一个文件中以使其更易于阅读，但实际上，它可能会按照某些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">标准结构</a>分成多个单独的文件）。 <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./styles.css"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserAvatar = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user, size }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( &lt;img className={`user-avatar ${size || ""}`} alt="user avatar" src={user.avatar} /&gt; ); const UserStats = ({ user }) =&gt; ( &lt;div className="user-stats"&gt; &lt;div&gt; &lt;UserAvatar user={user} /&gt; {user.name} &lt;/div&gt; &lt;div className="stats"&gt; &lt;div&gt;{user.followers} Followers&lt;/div&gt; &lt;div&gt;Following {user.following}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); const Nav = ({ user }) =&gt; ( &lt;div className="nav"&gt; &lt;UserAvatar user={user} size="small" /&gt; &lt;/div&gt; ); const Content = () =&gt; &lt;div className="content"&gt;main content here&lt;/div&gt;; const Sidebar = ({ user }) =&gt; ( &lt;div className="sidebar"&gt; &lt;UserStats user={user} /&gt; &lt;/div&gt; ); const Body = ({ user }) =&gt; ( &lt;div className="body"&gt; &lt;Sidebar user={user} /&gt; &lt;Content user={user} /&gt; &lt;/div&gt; ); class App extends React.Component { state = { user: { avatar: "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b", name: "Dave", followers: 1234, following: 123 } }; render() { const { user } = this.state; return ( &lt;div className="app"&gt; &lt;Nav user={user} /&gt; &lt;Body user={user} /&gt; &lt;/div&gt; ); } } ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</code> </pre> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox示例代码</a> <br><br>  App <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在</a>此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">初始化</a>包含用户对象<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的状态</a> 。 在实际的应用程序中，您最有可能<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从服务器提取此数据</a>并将其保存为呈现状态。 <br><br> 关于道具（“道具钻探”）， <i>这没什么大不了的</i> 。 效果很好。 投掷道具，这是React的理想示例。 但是在编写时，深入了解状态树可能会有些烦人。 如果您必须传送很多道具（而不是一个），则更令人烦恼。 <br><br> 但是，此策略有一个很大的缺点：它在不应连接的组件之间建立了连接。 在上面的示例中，即使Nav不需要它，Nav也应接受“用户”道具并将其传递给UserAvatar。 <br><br> 紧密耦合的组件（例如将道具传递给孩子的组件）更难重用，因为每当在新的地方使用它们时，都必须将它们绑定到新的父母身上。 <br><br> 让我们看看如何改善这一点。 <br><br><h3> 使用Context或Redux之前... </h3><br> 如果您找到一种方法来<i>组合</i>应用程序<i>的</i>结构，并利用将props传递给子代的优势，则可以使代码更整洁，而不必求助于props， <i>Context</i>或<i>Redux</i> 。 <br><br> 在此示例中，儿童道具对于需要通用的组件（例如Nav，Sidebar和Body）是一个很好的解决方案。 另外请注意，您可以将JSX传递给<i>任何</i>道具，而不仅仅是传递给孩子-因此，如果需要多个“插槽”来连接组件，请记住这一点。 <br><br> 这是一个React应用程序的示例，其中Nav，Body和Sidebar带子项并按原样显示它们。 因此，使用该组件的人不必担心传输该组件所需的某些数据。 他可以使用范围内已有的数据简单地显示所需的内容。 此示例还显示了如何使用任何道具来传播孩子。 <br><br>  （感谢Dan Abramov提供<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此优惠</a> ！） <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./styles.css"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserAvatar = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user, size }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( &lt;img className={`user-avatar ${size || ""}`} alt="user avatar" src={user.avatar} /&gt; ); const UserStats = ({ user }) =&gt; ( &lt;div className="user-stats"&gt; &lt;div&gt; &lt;UserAvatar user={user} /&gt; {user.name} &lt;/div&gt; &lt;div className="stats"&gt; &lt;div&gt;{user.followers} Followers&lt;/div&gt; &lt;div&gt;Following {user.following}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); //  children   . const Nav = ({ children }) =&gt; ( &lt;div className="nav"&gt; {children} &lt;/div&gt; ); const Content = () =&gt; ( &lt;div className="content"&gt;main content here&lt;/div&gt; ); const Sidebar = ({ children }) =&gt; ( &lt;div className="sidebar"&gt; {children} &lt;/div&gt; ); // Body   sidebar  content,    , //    . const Body = ({ sidebar, content }) =&gt; ( &lt;div className="body"&gt; &lt;Sidebar&gt;{sidebar}&lt;/Sidebar&gt; {content} &lt;/div&gt; ); class App extends React.Component { state = { user: { avatar: "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b", name: "Dave", followers: 1234, following: 123 } }; render() { const { user } = this.state; return ( &lt;div className="app"&gt; &lt;Nav&gt; &lt;UserAvatar user={user} size="small" /&gt; &lt;/Nav&gt; &lt;Body sidebar={&lt;UserStats user={user} /&gt;} content={&lt;Content /&gt;} /&gt; &lt;/div&gt; ); } } ReactDOM.render(&lt;App /&gt;, document.querySelector("#root"));</code> </pre> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox示例代码</a> <br><br> 如果您的应用程序太复杂（比此示例还要复杂！），可能很难理解如何使模板适合于孩子。 让我们看看如何用Redux替换道具转发。 <br><br><h3>  Redux示例 </h3><br> 我将快速看一下Redux示例，以便我们可以更好地理解Context的工作原理，因此，如果您对Redux没有清晰的了解，请先阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我对Redux的介绍</a> （或观看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">视频</a> ）。 <br><br> 这是经过重新设计以使用Redux的React应用程序。 用户信息已移至Redux存储，这意味着我们可以使用react-redux connect函数将用户prop直接传递给需要它们的组件。 <br><br> 就摆脱连接性而言，这是一个巨大的胜利。 看一下Nav，Body和Sidebar，您会发现它们不再接收或传输用户道具。 他们不再用道具玩辣土豆。 不再有无用的连接。 <br><br> 减速器在这里无济于事。 这很简单。 关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redux减速器</a>如何<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">工作</a>以及<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如何编写使用的不变代码</a> ，我还有另一件事。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    createStore, connect, and Provider: import { createStore } from "redux"; import { connect, Provider } from "react-redux"; //  reducer       . const initialState = {}; function reducer(state = initialState, action) { switch (action.type) { //    action SET_USER  state. case "SET_USER": return { ...state, user: action.user }; default: return state; } } //  store  reducer'   . const store = createStore(reducer); // Dispatch' action     user. store.dispatch({ type: "SET_USER", user: { avatar: "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b", name: "Dave", followers: 1234, following: 123 } }); //   mapStateToProps,      state (user) //     `user` prop. const mapStateToProps = state =&gt; ({ user: state.user }); //  UserAvatar    connect(),    //`user` ,      . //     2 : // const UserAvatarAtom = ({ user, size }) =&gt; ( ... ) // const UserAvatar = connect(mapStateToProps)(UserAvatarAtom); const UserAvatar = connect(mapStateToProps)(({ user, size }) =&gt; ( &lt;img className={`user-avatar ${size || ""}`} alt="user avatar" src={user.avatar} /&gt; )); //   UserStats    connect(),    // `user` . const UserStats = connect(mapStateToProps)(({ user }) =&gt; ( &lt;div className="user-stats"&gt; &lt;div&gt; &lt;UserAvatar /&gt; {user.name} &lt;/div&gt; &lt;div className="stats"&gt; &lt;div&gt;{user.followers} Followers&lt;/div&gt; &lt;div&gt;Following {user.following}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )); //    Nav      `user`. const Nav = () =&gt; ( &lt;div className="nav"&gt; &lt;UserAvatar size="small" /&gt; &lt;/div&gt; ); const Content = () =&gt; ( &lt;div className="content"&gt;main content here&lt;/div&gt; ); //   Sidebar. const Sidebar = () =&gt; ( &lt;div className="sidebar"&gt; &lt;UserStats /&gt; &lt;/div&gt; ); //   Body. const Body = () =&gt; ( &lt;div className="body"&gt; &lt;Sidebar /&gt; &lt;Content /&gt; &lt;/div&gt; ); //  App    ,     . const App = () =&gt; ( &lt;div className="app"&gt; &lt;Nav /&gt; &lt;Body /&gt; &lt;/div&gt; ); //     Provider, //   connect()    store. ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.querySelector("#root") );</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox示例代码</a> <br><br> 现在，您可能想知道Redux如何实现这一魔力。 好厉害  React如何不支持将道具传递到多个级别，Redux可以做到吗？ <br><br> 答案是Redux使用<i>上下文</i>函数React（上下文功能）。 不是现代的Context API（尚未），而是旧的。 除非您正在编写自己的库或知道自己在做什么，否则React文档中不会使用的一种。 <br><br> 上下文类似于每个组件后面的计算机总线：要获得通过它的电源（数据），只需连接即可。 而react-redux connect就是这样做的。 <br><br> 但是，此Redux功能只是冰山一角。 将数据传输到正确的位置是Redux最<i>明显</i>的功能。 您可以立即获得以下其他好处： <br><br>  <b>连接是一个纯函数</b> <br><br>  connect会自动使连接的组件“干净”，也就是说，仅当其prop更改时（即，其Redux状态的一部分更改时）才重新渲染它们。 这样可以防止不必要的重新渲染并加快应用程序的速度。 <br><br>  <b>使用Redux轻松调试</b> <br><br>  Redux为您提供了令人惊讶的调试便利，在编写动作和缩减工具的仪式之间取得了平衡。 <br><br> 使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Redux DevTools扩展，</a>您会自动获得应用程序执行的所有操作的日志。 您可以随时将其打开，查看启动了哪些操作，它们的有效负载是什么以及操作前后的状态。 <br><br><img src="https://habrastorage.org/webt/go/km/oi/gokmoivlzezzfb-wjkhujjyxep8.gif"><br><br>  Redux DevTools提供的另一个重要功能是使用<i>“时间旅行”进行</i>调试，即，您可以单击任何先前的操作并转到当前时间，直到当前时间为止。 之所以起作用，是因为每个动作都以<i>相同的方式</i>更新存储，因此您可以获取已记录状态更新的列表，并在没有任何副作用的情况下播放它们，并最终到达所需的位置。 <br><br> 还有一些工具，例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LogRocket</a> ，基本上可以为您的每个用户提供<i>生产中</i>的永久Redux DevTools。 有错误报告？ 没问题 在LogRocket中查看此用户会话，您可以看到他所做的重复以及所执行的操作的重复。 所有这些都可以通过Redux操作流来实现。 <br><br>  <b>使用中间件扩展Redux</b> <br><br>  Redux支持中间件概念（一个奇特的词，意为“每次发送动作都会运行的函数”）。 编写自己的中间件并不像看起来那样困难，并且允许您使用一些强大的工具。 <br><br> 例如... <br><br><ul><li> 是否想每次动作名称以FETCH_开头时发送API请求？ 您可以使用中间件来实现。 </li><li> 是否需要一个集中的地方在您的分析软件中记录事件？ 中间件是执行此操作的好地方。 </li><li> 是否要阻止某个动作在特定时间点开始？ 您可以使用中间件执行此操作，而中间件对于您的应用程序的其余部分是不可见的。 </li><li> 是否要拦截具有JWT令牌的动作并将其自动保存到localStorage？ 是的，中间件。 </li></ul><br> 这是一篇很好的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> ，其中包含有关如何编写Redux中间件的示例。 <br><br><h4> 如何使用React Context API </h4><br> 但是也许您不需要所有这些Redux怪癖。 您可能不需要简单的调试，调整或自动性能改进-您要做的就是轻松地传输数据。 也许您的应用程序很小，或者您只需要快速做一些事情并在以后处理这些细微问题即可。 <br><br> 新的Context API可能很适合您。 让我们看看它是如何工作的。 <br><br> 如果您更愿意观看而不是阅读，我在Egghead上发布了一个快速的Context API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">教程</a> （3:43）。 <br><br> 这是Context API的3个重要组件： <br><br><ul><li>  React.createContext函数创建上下文 </li><li> 提供程序（返回createContext），用于设置“总线”， <br> 穿过组件树 </li><li> 消费者（也返回createContext） <br>  “电动总线”用于数据提取 </li></ul><br> 提供程序与React-Redux中的提供程序非常相似。 它的值可以是您想要的任何值（它甚至可以是Redux商店...但是那很愚蠢）。 最有可能的是，这是一个对象，其中包含您的数据以及您希望对数据执行的任何操作。 <br><br> 使用者的工作有点像React-Redux中的connect函数，它连接到数据并使数据可供使用它的组件使用。 <br><br> 以下是重点内容： <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     context //    2 : { Provider, Consumer } // ,   ,  UpperCase,  camelCase //  ,          , //        . const UserContext = React.createContext(); // ,     context, //   Consumer. // Consumer   "render props". const UserAvatar = ({ size }) =&gt; ( &lt;UserContext.Consumer&gt; {user =&gt; ( &lt;img className={`user-avatar ${size || ""}`} alt="user avatar" src={user.avatar} /&gt; )} &lt;/UserContext.Consumer&gt; ); // ,      "user prop", //   Consumer    context. const UserStats = () =&gt; ( &lt;UserContext.Consumer&gt; {user =&gt; ( &lt;div className="user-stats"&gt; &lt;div&gt; &lt;UserAvatar user={user} /&gt; {user.name} &lt;/div&gt; &lt;div className="stats"&gt; &lt;div&gt;{user.followers} Followers&lt;/div&gt; &lt;div&gt;Following {user.following}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; )} &lt;/UserContext.Consumer&gt; ); // ...    ... // ... (      `user`). //  App   context ,  Provider. class App extends React.Component { state = { user: { avatar: "https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b", name: "Dave", followers: 1234, following: 123 } }; render() { return ( &lt;div className="app"&gt; &lt;UserContext.Provider value={this.state.user}&gt; &lt;Nav /&gt; &lt;Body /&gt; &lt;/UserContext.Provider&gt; &lt;/div&gt; ); } }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox示例代码</a> <br><br> 让我们看看它是如何工作的。 <br><br> 记住，我们分为三个部分：上下文本身（使用React.createContext创建）和两个与之交互的组件（Provider和Consumer）。 <br><br>  <b>提供者和消费者一起工作</b> <br><br> 提供者和消费者是相关且密不可分的。 他们只知道如何相互交流。 如果您创建了两个单独的上下文，例如“ Context1”和“ Context2”，则提供者和使用者Context1将无法与提供者和使用者Context2通信。 <br><br>  <b>上下文不包含状态</b> <br><br> 注意上下文<i>没有自己的状态</i> 。 这只是您的数据通道。 您必须将值传递给提供者，并且该值将传递给知道如何查找它的任何消费者（提供者与消费者绑定到相同的上下文）。 <br><br> 创建上下文时，可以按以下方式传递“默认”： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ctx = React.createContext(yourDefaultValue);</code> </pre><br><br> 默认值是当消费者放置在树中而提供商不在其上方时，消费者将收到的值。 如果不通过，则该值将是不确定的。 请注意，这<i>是默认值</i> ，而不是<i>初始</i>值。 上下文不保存任何内容。 它只是传播您传递给它的数据。 <br><br>  <b>消费者使用渲染道具模式</b> <br><br>  connect Redux函数是一个高阶组件（缩写为HoC）。 它包装另一个组件并将道具传递到其中。 <br><br> 相反，消费者期望子组件是一个功能。 然后，它在渲染过程中调用此函数，将它从Provider接收的值传递到它上方的某个位置（上下文的默认值，如果未传递默认值，则为undefined）。 <br><br>  <b>提供者取一个值。</b> <br><br> 只有一个值，就像道具。 但是请记住，该值可以是任何值。 实际上，如果要向下传递多个值，则必须创建一个具有所有值的对象并将该对象向下传递。 <br><br><h3> 上下文API灵活 </h3><br> 由于创建上下文使我们可以使用两个组件（提供者和消费者），因此我们可以根据需要使用它们。 这里有一些想法。 <br><br>  <b>在HOC中包装消费者</b> <br><br> 不喜欢在需要它的每个地方周围添加UserContext.Consumer的想法吗？ 这是您的代码！ 您有权决定什么是您的最佳选择。 <br><br> 如果您希望获得该值作为道具，则可以按以下方式在Consumer周围编写一个小的包装： <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">withUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Component</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConnectedComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;UserContext.Consumer&gt; {user =&gt; &lt;Component {...props} user={user}/&gt;} &lt;/UserContext.Consumer&gt; ); } }</code> </pre><br> 之后，您可以使用withUser函数重写例如UserAvatar： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UserAvatar = withUser(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ size, user }</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">img</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">`</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">user-avatar</span></span></span></span><span class="xml"><span class="hljs-tag"> ${</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span></span><span class="xml"><span class="hljs-tag"> || ""}`} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"user avatar"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{user.avatar}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ));</span></span></code> </pre><br> 瞧，上下文可以像连接Redux一样工作。 减去自动清洁度。 <br><br> 这是带有此HOC的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox</a>的示例。 <br><br>  <b>将状态保持在提供者中</b> <br><br> 请记住，提供者只是一个渠道。 它不保存任何数据。 但这并不能阻止您创建<i>自己的</i>包装器来存储数据。 <br><br> 在上面的示例中，数据存储在App中，因此您唯一需要了解的就是Provider + Consumer组件。 但是也许您想创建自己的商店。 您可以创建一个组件来存储状态并通过上下文传递它们： <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserStore</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">user</span></span>: { <span class="hljs-attr"><span class="hljs-attr">avatar</span></span>: <span class="hljs-string"><span class="hljs-string">"https://www.gravatar.com/avatar/5c3dd2d257ff0e14dbd2583485dbd44b"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Dave"</span></span>, <span class="hljs-attr"><span class="hljs-attr">followers</span></span>: <span class="hljs-number"><span class="hljs-number">1234</span></span>, <span class="hljs-attr"><span class="hljs-attr">following</span></span>: <span class="hljs-number"><span class="hljs-number">123</span></span> } }; render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;UserContext.Provider value={</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.user}&gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.props.children} &lt;</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/UserContext.Provider&gt; ); } } /</span></span></span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/ ...    ... const App = () =&gt; ( &lt;div className="app"&gt; &lt;Nav /</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &lt;Body </span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/&gt; &lt;/</span></span></span></span><span class="hljs-function"><span class="hljs-params">div&gt; </span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReactDOM</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;UserStore&gt; &lt;App </span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/&gt; &lt;/</span></span></span></span><span class="hljs-function"><span class="hljs-params">UserStore&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">document</span></span></span></span><span class="hljs-function"><span class="hljs-params">.querySelector(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"#root"</span></span></span></span></span><span class="hljs-function">) );</span></span></code> </pre><br> 现在，用户数据包含在其<i>自己的</i>组件中，其唯一任务就是这些数据。 好酷 应用可以再次变为无状态。 我认为它看起来更干净一些。 <br><br> 这是此UserStore的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox</a>示例。 <br><br>  <b>在上下文中抛出动作</b> <br><br> 请记住，通过提供者传递的对象可以包含您想要的所有内容。 这意味着它可能包含功能。 您甚至可以为它们命名动作。 <br><br> 这是一个新示例：一个简单的房间，带有一个可以切换背景颜色的开关-哦，我的意思是光线。 <br><br><img src="https://habrastorage.org/webt/di/s4/r1/dis4r10ujowkvv5pn9mgx9b6jbs.gif"><br><br> 状态存储在商店中，该商店还具有灯光开关功能。 状态和功能都通过上下文传递。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react-dom"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"./styles.css"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  context. const RoomContext = React.createContext(); // ,     //   . class RoomStore extends React.Component { state = { isLit: false }; toggleLight = () =&gt; { this.setState(state =&gt; ({ isLit: !state.isLit })); }; render() { //  state  onToggleLight action return ( &lt;RoomContext.Provider value={{ isLit: this.state.isLit, onToggleLight: this.toggleLight }} &gt; {this.props.children} &lt;/RoomContext.Provider&gt; ); } } //    ,    , //       RoomContext. const Room = () =&gt; ( &lt;RoomContext.Consumer&gt; {({ isLit, onToggleLight }) =&gt; ( &lt;div className={`room ${isLit ? "lit" : "dark"}`}&gt; The room is {isLit ? "lit" : "dark"}. &lt;br /&gt; &lt;button onClick={onToggleLight}&gt;Flip&lt;/button&gt; &lt;/div&gt; )} &lt;/RoomContext.Consumer&gt; ); const App = () =&gt; ( &lt;div className="app"&gt; &lt;Room /&gt; &lt;/div&gt; ); //     RoomStore, //           . ReactDOM.render( &lt;RoomStore&gt; &lt;App /&gt; &lt;/RoomStore&gt;, document.querySelector("#root") );</span></span></code> </pre><br> 这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CodeSandbox中</a>完整的工作示例。 <br><br>  <b>毕竟，要使用什么上下文还是Redux？</b> <br><br> 现在您已经看到了两条路径，哪一条值得使用？ 我知道您只是想听听这个问题的答案，但我必须回答-“取决于您”。 <br><br> 这取决于您的应用程序现在有多大或增长速度如何。 有多少人可以从事这项工作-只有您还是一个大型团队？ 您或您的团队在使用Redux所依赖的功能概念（例如不变性和纯功能）方面的经验如何。 <br><br>  <i>竞争</i>观念贯穿整个JavaScript生态系统的一个致命错误。 有一种观点认为，每一个选择都是零和游戏：如果使用<i>库</i> A，则不应使用其竞争对手<i>库</i> B。当一个新库比以前的库更好时，应该排挤现有库。 一切都应该是/，或者您必须选择最新和最好的，或者与过去的开发人员一起降级为后台。 <br><br> 最好的方法是通过一个示例和一组工具来查看这一奇妙的选择。 就像在使用螺丝刀或强力螺丝刀之间进行选择。 在80％的情况下，螺丝刀比螺丝刀更容易，更快捷地完成工作。 但是对于其他20％的用户，螺丝刀将是最佳选择（没有足够的空间，或者物品太薄）。 当我购买螺丝起子时，我没有立即扔掉螺丝起子，他没有更换它，只是给了我另一种选择。 解决问题的另一种方法。 <br><br> 上下文不会“替换” Redux，只不过是React“替换” Angular或jQuery。 地狱，当我需要快速做某事时，我仍然使用jQuery。 我有时还是使用服务器端EJS模板而不是部署React应用程序。 有时，React远远超出了完成任务所需的范围。  Redux也是如此。 <br><br> 今天，如果Redux超出了您的需求，则可以使用上下文。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学习React可能很困难-有太多的库和工具！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的建议 </font><font style="vertical-align: inherit;">完全忽略它们：) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关逐步教程，请阅读我的书</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pure React</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419449/">https://habr.com/ru/post/zh-CN419449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419435/index.html">NIST蓝牙安全</a></li>
<li><a href="../zh-CN419437/index.html">AR-增强现实（文章和视频）</a></li>
<li><a href="../zh-CN419439/index.html">电子商务如何在大规模促销中生存。 为网络上的峰值负载做好准备[第2部分]</a></li>
<li><a href="../zh-CN419441/index.html">SpaceX今天首次重新使用Falcon 9 Block 5火箭</a></li>
<li><a href="../zh-CN419443/index.html">美国宇航局将再次飞往月球，使飞机的所有元素</a></li>
<li><a href="../zh-CN419451/index.html">逐步为Symfony 4创建捆绑包</a></li>
<li><a href="../zh-CN419453/index.html">求解非线性方程组的数值方法</a></li>
<li><a href="../zh-CN419457/index.html">RabbitMQ-SQL Server</a></li>
<li><a href="../zh-CN419459/index.html">铅酸电池：脉冲充电字母</a></li>
<li><a href="../zh-CN419461/index.html">洗手间通风</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>