<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚òùüèæ üë≤üèø üçü Textura convolucional üç† üôáüèª üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Texturas com atualiza√ß√£o autom√°tica 
 Quando √© poss√≠vel paralelizar simula√ß√µes ou tarefas de renderiza√ß√£o, geralmente √© melhor execut√°-las na GPU. Nes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Textura convolucional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478772/"><h2>  Texturas com atualiza√ß√£o autom√°tica </h2><br>  Quando √© poss√≠vel paralelizar simula√ß√µes ou tarefas de renderiza√ß√£o, geralmente √© melhor execut√°-las na GPU.  Neste artigo, explicarei uma t√©cnica que usa esse fato para criar truques visuais impressionantes com sobrecarga de baixo desempenho.  Todos os efeitos que demonstrarei s√£o implementados usando texturas que, quando atualizadas, " <em>se renderam</em> ";  a textura √© atualizada quando um novo quadro √© renderizado e o pr√≥ximo estado da textura depende completamente do estado anterior.  Nessas texturas, voc√™ pode desenhar, causando certas altera√ß√µes, e a pr√≥pria textura, direta ou indiretamente, pode ser usada para renderizar anima√ß√µes interessantes.  Eu os chamo de <em>texturas convolucionais</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/756/a1a/005/756a1a0051471cbe895a8883d89efadd.jpg"></div><br>  <i>Figura 1: buffer duplo de convolu√ß√£o</i> <br><br>  Antes de prosseguir, precisamos resolver um problema: a textura n√£o pode ser lida e escrita ao mesmo tempo, APIs gr√°ficas como OpenGL e DirectX n√£o permitem isso.  Como o pr√≥ximo estado da textura depende do anterior, precisamos contornar essa limita√ß√£o.  Preciso ler de uma textura diferente, n√£o daquela em que estou escrevendo. <br><br>  A solu√ß√£o √© <em>buffer duplo</em> .  A Figura 1 mostra como funciona: de fato, em vez de uma textura, existem duas, mas uma √© gravada e uma √© lida da outra.  A textura que est√° sendo gravada √© chamada de <em>buffer de fundo</em> e a textura renderizada √© chamada de <em>buffer de frente</em> .  Como o teste convolucional √© "gravado em si mesmo", o buffer secund√°rio em cada quadro grava no buffer prim√°rio e, em seguida, o prim√°rio √© renderizado ou usado para renderiza√ß√£o.  No pr√≥ximo quadro, as fun√ß√µes mudam e o buffer prim√°rio anterior √© usado como fonte para o pr√≥ximo buffer prim√°rio. <br><a name="habracut"></a><br>  Ao renderizar o estado anterior em uma nova textura de convolu√ß√£o, o shader de fragmento (ou <em>shader de pixel</em> ) fornece efeitos e anima√ß√µes interessantes.  O sombreador determina como o estado muda.  O c√≥digo fonte para todos os exemplos do artigo (e outros) pode ser encontrado no <a href="https://github.com/jobtalle/ConvolutionalTextures">reposit√≥rio no GitHub</a> . <br><br><h2>  Exemplos simples de aplica√ß√£o </h2><br>  Para demonstrar essa t√©cnica, escolhi uma simula√ß√£o bem conhecida na qual, ao atualizar, o estado depende completamente do estado anterior: o <em>jogo Conway ‚ÄúLife‚Äù</em> .  Essa simula√ß√£o √© realizada em uma grade de quadrados, cada c√©lula viva ou morta.  As regras para o seguinte estado da c√©lula s√£o simples: <br><br><ul><li>  Se uma c√©lula viva tem menos de dois vizinhos, mas fica morta. </li><li>  Se uma c√©lula viva tem dois ou tr√™s vizinhos vivos, ela permanece viva. </li><li>  Se uma c√©lula viva tem mais de tr√™s vizinhos vivos, ela se torna morta. </li><li>  Se uma c√©lula morta tem tr√™s vizinhos vivos, ela se torna viva. </li></ul><br>  Para implementar este jogo como uma textura convolucional, interpreto a textura como a grade do jogo, e o shader √© processado com base nas regras acima.  Um pixel transparente √© uma c√©lula morta e um pixel branco opaco √© uma c√©lula viva.  Uma implementa√ß√£o interativa √© mostrada abaixo.  Para acessar a GPU, uso <a href=""><em>myr.js</em></a> , que requer o <em>WebGL 2</em> .  Os navegadores mais modernos (por exemplo, Chrome e Firefox) podem funcionar com ele, mas se a demonstra√ß√£o n√£o funcionar, provavelmente o navegador n√£o a suporta.  Use o mouse (ou tela sens√≠vel ao toque) [no artigo original] para desenhar c√©lulas vivas na textura. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/SQ3EKUPm8FY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  O c√≥digo do fragment shader (no GLSL, porque eu uso o WebGL para renderiza√ß√£o) √© mostrado abaixo.  Primeiro, implementei a fun√ß√£o <code>get</code> , que me permite ler um pixel de um deslocamento espec√≠fico do atual.  A vari√°vel <code>pixelSize</code> √© um vetor 2D pr√©-criado que cont√©m o deslocamento UV de cada pixel e a fun√ß√£o <code>get</code> utiliza para ler a c√©lula vizinha.  Em seguida, a fun√ß√£o <code>main</code> determina a nova cor da c√©lula com base no estado atual (ativo) e no n√∫mero de vizinhos vivos. <br><br><pre> <code class="cpp hljs">uniform sampler2D source; uniform lowp vec2 pixelSize; in mediump vec2 uv; layout (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) out lowp vec4 color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(texture(source, uv + pixelSize * vec2(dx, dy)).r); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> live = get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> neighbors = get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + get(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) + get(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; (neighbors == <span class="hljs-number"><span class="hljs-number">2</span></span> || neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>)) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (live == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; neighbors == <span class="hljs-number"><span class="hljs-number">3</span></span>) color = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> color = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Outra textura convolucional simples √© um <em>jogo com areia caindo</em> , em que o usu√°rio pode jogar areia colorida no local, que cai e forma montanhas.  Embora sua implementa√ß√£o seja um pouco mais complicada, as regras s√£o mais simples: <br><br><ul><li>  Se n√£o houver areia sob um gr√£o de areia, ela cai um pixel. </li><li>  Se houver areia sob um gr√£o de areia, mas ela pode deslizar 45 graus para a esquerda ou direita, o far√°. </li></ul><br>  A administra√ß√£o neste exemplo √© igual √† do jogo "Life".  Como, nessas regras, a areia pode cair a uma velocidade de apenas um pixel por quadro, a fim de acelerar um pouco o processo, a textura por quadro √© atualizada tr√™s vezes.  O c√≥digo fonte do aplicativo est√° <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/sand.html">aqui</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/MV10ScILiAY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Um passo √† frente </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Canal</b> </td><td>  <b>Aplica√ß√£o</b> </td></tr><tr><td>  Vermelho </td><td>  Altura da onda </td></tr><tr><td>  Verde </td><td>  Velocidade de onda </td></tr><tr><td>  Azul </td><td>  <i>N√£o usado</i> </td></tr><tr><td>  Alpha </td><td>  <i>N√£o usado</i> </td></tr></tbody></table></div><br>  <i>Figura 2: Ondas de pixel.</i> <br><br>  Os exemplos acima usam textura convolucional diretamente;  seu conte√∫do √© renderizado na tela como est√°.  Se voc√™ interpreta imagens apenas como pixels, os limites de uso dessa t√©cnica s√£o muito limitados, mas, gra√ßas aos equipamentos modernos, eles podem ser expandidos.  Em vez de contar pixels como cores, os interpretarei de maneira um pouco diferente, que pode ser usada para criar anima√ß√µes de mais uma textura ou modelo 3D. <br><br>  Primeiro, interpretarei a textura convolucional como um mapa de altura.  A textura simular√° <em>ondas</em> e <em>vibra√ß√µes</em> no plano aqu√°tico e os resultados ser√£o usados ‚Äã‚Äãpara renderizar reflexos e ondas sombreadas.  N√£o precisamos mais ler a textura como uma imagem, para que possamos usar seus pixels para armazenar qualquer informa√ß√£o.  No caso de um sombreador de √°gua, armazenarei a altura da onda no canal vermelho e o pulso da onda no canal verde, conforme mostrado na Figura 2. Os canais azul e alfa ainda n√£o s√£o usados.  As ondas s√£o criadas desenhando pontos vermelhos em uma textura convolucional. <br><br>  N√£o considerarei a metodologia para atualizar o mapa de altura, emprestado do site de <em>Hugo Elias</em> , que parece ter desaparecido da Internet.  Ele tamb√©m aprendeu sobre esse algoritmo com um autor desconhecido e o implementou em C para execu√ß√£o na CPU.  O c√≥digo fonte do aplicativo abaixo est√° <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/water.html">aqui</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/h8GjEGMV8AE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Aqui, usei um mapa de altura apenas para compensar a textura e adicionar sombreamento, mas na terceira dimens√£o, aplicativos muito mais interessantes podem ser implementados.  Quando uma textura convolucional √© interpretada por um sombreador de v√©rtice, um plano subdividido plano pode ser distorcido para criar ondas tridimensionais.  Voc√™ pode aplicar o sombreamento e a ilumina√ß√£o usuais √† forma resultante. <br><br>  Vale notar que os pixels na textura convolucional do exemplo mostrado acima √†s vezes armazenam valores muito pequenos que n√£o devem desaparecer devido a erros de arredondamento.  Portanto, os canais de cores dessa textura devem ter uma resolu√ß√£o mais alta, e n√£o os 8 bits padr√£o.  Neste exemplo, aumentei o tamanho de cada canal de cores para 16 bits, o que deu resultados bastante precisos.  Se voc√™ n√£o estiver armazenando pixels, geralmente precisar√° aumentar a precis√£o da textura.  Felizmente, as APIs gr√°ficas modernas suportam esse recurso. <br><br><h2>  Usamos todos os canais </h2><br><div class="scrollable-table"><table><tbody><tr><td>  <b>Canal</b> </td><td>  <b>Aplica√ß√£o</b> </td></tr><tr><td>  Vermelho </td><td>  Deslocamento X </td></tr><tr><td>  Verde </td><td>  Deslocamento Y </td></tr><tr><td>  Azul </td><td>  Velocidade X </td></tr><tr><td>  Alpha </td><td>  Deslocamento Y </td></tr></tbody></table></div><br>  <i>Figura 3: Grama de pixel.</i> <br><br>  No exemplo da √°gua, apenas os canais vermelho e verde s√£o usados, mas no pr√≥ximo exemplo, aplicaremos todos os quatro.  √â simulado um campo com grama (ou √°rvores), que pode ser movido usando o cursor.  A Figura 3 mostra quais dados s√£o armazenados em um pixel.  O deslocamento √© armazenado nos canais vermelho e verde, e a velocidade √© armazenada nos canais azul e alfa.  Essa velocidade √© atualizada para mudar para a posi√ß√£o de repouso com um movimento de onda gradualmente diminuindo. <br><br>  No exemplo da √°gua, a cria√ß√£o de ondas √© bastante simples: √© poss√≠vel desenhar pontos na textura, e a mistura alfa fornece formas suaves.  Voc√™ pode criar facilmente v√°rios pontos sobrepostos.  Neste exemplo, tudo √© mais complicado porque o canal alfa j√° est√° em uso.  N√£o podemos desenhar um ponto com um valor alfa de 1 no centro e 0 a partir da borda, porque isso dar√° √† grama um impulso desnecess√°rio (j√° que o impulso vertical √© armazenado no canal alfa).  Nesse caso, um sombreador separado foi escrito para desenhar o efeito na textura convolucional.  Esse sombreador garante que a mistura alfa n√£o produza efeitos inesperados. <br><br>  O c√≥digo fonte do aplicativo pode ser encontrado <a href="https://github.com/jobtalle/ConvolutionalTextures/blob/master/grass.html">aqui</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/oBqQL7HViLE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  A grama √© criada em 2D, mas o efeito funcionar√° em ambientes 3D.  Em vez de deslocamento de pixel, os v√©rtices s√£o deslocados, o que tamb√©m √© mais r√°pido.  Al√©m disso, com a ajuda de picos, outro efeito pode ser percebido: for√ßa diferente dos galhos - a grama se dobra facilmente com o menor vento e as √°rvores fortes flutuam apenas durante tempestades. <br><br>  Embora existam muitos algoritmos e shaders para criar os efeitos do vento e do deslocamento da vegeta√ß√£o, essa abordagem tem uma s√©ria vantagem: desenhar efeitos em uma textura convolucional √© um processo de baixo custo.  Se o efeito for aplicado em um jogo, o movimento da vegeta√ß√£o poder√° ser determinado por centenas de influ√™ncias diferentes.  N√£o apenas o personagem principal, mas tamb√©m todos os objetos, animais e movimentos podem influenciar o mundo √† custa de custos insignificantes. <br><br><h2>  Outros casos de uso e falhas </h2><br>  Voc√™ pode criar muitas outras aplica√ß√µes de tecnologia, por exemplo: <br><br><ul><li>  Usando uma textura convolucional, voc√™ pode simular a velocidade do vento.  Na textura, voc√™ pode desenhar obst√°culos que fazem o ar circular ao redor deles.  Part√≠culas (chuva, neve e folhas) podem usar essa textura para voar em torno de obst√°culos. </li><li>  Voc√™ pode simular a propaga√ß√£o de fuma√ßa ou fogo. </li><li>  A textura pode codificar a espessura de uma camada de neve ou areia.  Tra√ßos e outras intera√ß√µes com a camada podem criar amassados ‚Äã‚Äãe impress√µes na camada. </li></ul><br>  Ao usar esse m√©todo, existem dificuldades e limita√ß√µes: <br><br><ul><li>  √â dif√≠cil ajustar as anima√ß√µes para alterar as taxas de quadros.  Por exemplo, em um aplicativo com areia caindo, gr√£os de areia caem a uma velocidade constante - um pixel por atualiza√ß√£o.  Uma solu√ß√£o poss√≠vel pode ser a atualiza√ß√£o de texturas convolucionais com uma frequ√™ncia constante, semelhante √† maneira como a maioria dos motores f√≠sicos funciona;  o mecanismo de f√≠sica funciona a uma frequ√™ncia constante e seus resultados s√£o interpolados. </li><li>  Transferir dados para a GPU √© um processo r√°pido e f√°cil; no entanto, recuperar dados n√£o √© t√£o f√°cil.  Isso significa que a maioria dos efeitos gerados por esta t√©cnica √© unidirecional;  eles s√£o transferidos para a GPU, e a GPU faz seu trabalho sem mais interven√ß√£o e feedback.  Se eu quisesse incorporar o comprimento de onda do exemplo da √°gua em c√°lculos f√≠sicos (por exemplo, para que os navios oscilassem junto com as ondas), precisaria de valores da textura convolucional.  A recupera√ß√£o de dados de textura de uma GPU √© um processo muito lento que n√£o precisa ser feito em tempo real.  A solu√ß√£o para esse problema pode ser a implementa√ß√£o de duas simula√ß√µes: uma com alta resolu√ß√£o para gr√°ficos de √°gua como textura convolucional e outra com baixa resolu√ß√£o na CPU para f√≠sica de √°gua.  Se os algoritmos forem os mesmos, as discrep√¢ncias podem ser bastante aceit√°veis. </li></ul><br>  As demos neste artigo podem ser otimizadas ainda mais.  No exemplo da grama, voc√™ pode usar uma textura com resolu√ß√£o muito menor sem defeitos percept√≠veis;  isso vai ajudar muito em grandes cenas.  Outra otimiza√ß√£o: voc√™ pode usar uma taxa de atualiza√ß√£o mais baixa, por exemplo, em cada quarto quadro ou em um quarto por quadro (j√° que essa t√©cnica n√£o causa problemas nas atualiza√ß√µes segmentadas).  Para manter uma taxa de quadros suave, o estado anterior e atual da textura convolucional pode ser interpolado. <br><br>  Como as texturas convolucionais usam buffer duplo interno, voc√™ pode usar as duas texturas ao mesmo tempo para renderizar.  O buffer prim√°rio √© o estado atual e o secund√°rio √© o anterior.  Isso pode ser √∫til para interpolar a textura ao longo do tempo ou para calcular derivadas para valores de textura. <br><br><h2>  Conclus√£o </h2><br>  GPUs, especialmente em programas 2D, geralmente ficam ociosas.  Embora pare√ßa que ele s√≥ possa ser usado na renderiza√ß√£o de cenas 3D complexas, a t√©cnica demonstrada neste artigo mostra pelo menos uma outra maneira de usar o poder da GPU.  Usando os recursos para os quais a GPU foi desenvolvida, voc√™ pode implementar efeitos e anima√ß√µes interessantes que geralmente s√£o muito caros para a CPU. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478772/">https://habr.com/ru/post/pt478772/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478750/index.html">Bibliotecas de visualiza√ß√£o de dados reais para desenvolvedores de rea√ß√£o</a></li>
<li><a href="../pt478752/index.html">Hist√≥ria dos sistemas de controle de vers√£o</a></li>
<li><a href="../pt478758/index.html">√ìtimo guia de tags UTM: como descobrir de onde os usu√°rios v√™m</a></li>
<li><a href="../pt478760/index.html">Inferno "zero" e como sair dele</a></li>
<li><a href="../pt478764/index.html">Erros de JavaScript: conserte, processe, conserte</a></li>
<li><a href="../pt478774/index.html">Ano novo clima de Arduino e varas</a></li>
<li><a href="../pt478778/index.html">Habra detetive e clima festivo</a></li>
<li><a href="../pt478782/index.html">Obten√ß√£o de permiss√£o para pilotar um drone (BVS, UAV) na Federa√ß√£o Russa</a></li>
<li><a href="../pt478788/index.html">Em um certo reino, n√£o em um estado de "primavera". Relat√≥rio Yandex</a></li>
<li><a href="../pt478790/index.html">Julia e sem√¢ntica de distribui√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>