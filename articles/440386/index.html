<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèº üç™ üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ Liberando el manejo de errores eliminando errores ü•Ñ üëÜüèº üßôüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Go2 tiene como objetivo reducir la sobrecarga del manejo de errores, pero ¬øsab√≠a qu√© es mejor que la sintaxis mejorada para el manejo de errores? 
 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Liberando el manejo de errores eliminando errores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440386/"><img src="https://habrastorage.org/webt/-t/wg/qf/-twgqf5sqhxuyrhnilflk-luxtc.jpeg"><br><br>  <i>Go2 tiene como objetivo reducir la sobrecarga del manejo de errores, pero ¬øsab√≠a qu√© es mejor que la sintaxis mejorada para el manejo de errores?</i> <i><br></i> <br>  No es necesario manejar los errores en absoluto.  No digo "elimine su c√≥digo de manejo de errores", en cambio sugiero cambiar su c√≥digo para que no tenga muchos errores que manejar. <br><br>  Este art√≠culo se inspira en el cap√≠tulo "Definir errores fuera de existencia" del libro " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Una filosof√≠a de dise√±o de software</a> " de John Ousterhout.  Intentar√© aplicar sus consejos a Go. <br><a name="habracut"></a><br><h3>  Primer ejemplo </h3><br>  Aqu√≠ est√° la funci√≥n para contar el n√∫mero de l√≠neas en un archivo: <br><br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( br = bufio.NewReader(r) lines <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err error ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Creamos bufio.Reader, luego nos sentamos en un bucle, llamando al m√©todo ReadString, aumentando el contador hasta llegar al final del archivo, y luego devolvemos el n√∫mero de l√≠neas le√≠das.  Este es el c√≥digo que quer√≠amos escribir, en cambio CountLines es complicado por el manejo de errores. <br><br>  Por ejemplo, hay una construcci√≥n tan extra√±a: <br><br><pre> <code class="go hljs">_, err = br.ReadString(<span class="hljs-string"><span class="hljs-string">'\n'</span></span>) lines++ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> }</code> </pre><br>  Aumentamos el n√∫mero de l√≠neas antes de buscar errores, esto parece extra√±o.  La raz√≥n por la que debemos escribirlo de esta manera es porque ReadString devolver√° un error si encuentra el final del archivo, io.EOF, antes de presionar un car√°cter de nueva l√≠nea.  Esto tambi√©n puede suceder si no hay una nueva l√≠nea. <br><br>  Para resolver este problema, reorganizaremos la l√≥gica para aumentar el n√∫mero de filas y luego veremos si necesitamos salir del ciclo (esta l√≥gica a√∫n no es correcta, ¬øpuede encontrar un error?). <br><br>  Pero no hemos terminado de buscar errores.  ReadString devolver√° io.EOF cuando llegue al final del archivo.  Esto se espera, ReadString necesita alguna forma de decir alto, no hay nada m√°s que leer.  Por lo tanto, antes de devolver el error a la persona que llama de CountLine, debemos verificar si hubo un error io.EOF y, en este caso, devolverlo a la persona que llama, de lo contrario, devolveremos cero cuando todo est√© bien.  Es por eso que la √∫ltima l√≠nea de la funci√≥n no es f√°cil. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, err</code> </pre> <br>  Creo que este es un buen ejemplo de la observaci√≥n de Russ Cox de que el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">manejo de errores puede dificultar la funci√≥n</a> .  Veamos la versi√≥n mejorada. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountLines</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { sc := bufio.NewScanner(r) lines := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sc.Scan() { lines++ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lines, sc.Err() }</code> </pre> <br>  Esta versi√≥n mejorada pasa del uso de bufio.Reader a bufio.Scanner.  Bajo el cap√≥, bufio.Scanner usa bufio.Reader, agregando una capa de abstracci√≥n que ayuda a eliminar el manejo de errores, lo que obstaculiz√≥ el trabajo de nuestra versi√≥n anterior de CountLines (bufio.Scanner puede escanear cualquier plantilla, por defecto busca nuevas l√≠neas). <br><br>  El m√©todo sc.Scan () devuelve verdadero si el esc√°ner encontr√≥ una l√≠nea de texto y no encontr√≥ un error.  Por lo tanto, el cuerpo de nuestro bucle for solo se llamar√° cuando haya una l√≠nea de texto en el b√∫fer del esc√°ner.  Esto significa que nuestro CountLines rehecho maneja correctamente el caso cuando no hay un car√°cter de nueva l√≠nea final.  Tambi√©n ahora se maneja correctamente el caso cuando el archivo est√° vac√≠o. <br><br>  En segundo lugar, dado que sc.Scan devuelve falso cuando se produce un error, nuestro bucle for finalizar√° cuando se llegue al final del archivo o se produzca un error.  Escriba bufio.Scanner recuerda el primer error detectado y lo solucionamos despu√©s de salir del bucle utilizando el m√©todo sc.Err (). <br><br>  Finalmente, buffo.Scanner se encarga de procesar io.EOF y lo convierte en nulo si se llega al final del archivo sin un error. <br><br><h3>  Segundo ejemplo </h3><br>  Mi segundo ejemplo est√° inspirado en los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">errores de</a> Rob Pikes. <br><br>  Cuando se trabaja con archivos de apertura, escritura y cierre, el manejo de errores es, pero no muy impresionante, porque las operaciones pueden concluirse en ayudantes como ioutil.ReadFile e ioutil.WriteFile.  Sin embargo, cuando se trabaja con protocolos de red de bajo nivel, a menudo es necesario construir una respuesta directamente usando primitivas de E / S, por lo que el manejo de errores puede comenzar a repetirse.  Considere este fragmento de un servidor HTTP que crea una respuesta HTTP / 1.1: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Header <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Key, Value <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Status <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Code <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Reason <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { _, err := fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = io.Copy(w, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br>  Primero creamos una barra de estado usando fmt.Fprintf y buscamos un error.  Luego, para cada encabezado, registramos la clave y el valor del encabezado, cada vez que buscamos un error.  Finalmente, finalizamos la secci√≥n del encabezado con un \ r \ n adicional, verificamos el error y copiamos el cuerpo de la respuesta al cliente.  Finalmente, aunque no necesitamos verificar el error de io.Copy, necesitamos convertirlo de un formulario con dos valores de retorno, que io.Copy regresa al valor de retorno √∫nico que WriteResponse espera. <br><br>  Esto no es solo un mont√≥n de trabajo repetitivo, cada operaci√≥n, que esencialmente est√° escribiendo bytes en io.Writer, tiene una forma diferente de manejo de errores.  Pero podemos facilitar nuestra tarea introduciendo un peque√±o contenedor. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> errWriter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { io.Writer err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *errWriter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buf []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e.err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, e.err } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, e.err = e.Writer.Write(buf) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  errWriter cumple el contrato io.Writer, por lo que puede usarse para migrar un io.Writer existente.  errWriter transfiere las grabaciones a su grabadora subyacente hasta que se detecta un error.  De ahora en adelante, descarta cualquier entrada y devuelve el error anterior. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w io.Writer, st Status, headers []Header, body io.Reader)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { ew := &amp;errWriter{Writer: w} fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"HTTP/1.1 %d %s\r\n"</span></span>, st.Code, st.Reason) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, h := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> headers { fmt.Fprintf(ew, <span class="hljs-string"><span class="hljs-string">"%s: %s\r\n"</span></span>, h.Key, h.Value) } fmt.Fprint(ew, <span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>) io.Copy(ew, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ew.err }</code> </pre><br>  La aplicaci√≥n de errWriter a WriteResponse mejora enormemente la claridad del c√≥digo.  Cada una de las operaciones ya no necesita limitarse a la verificaci√≥n de errores.  El mensaje de error se mueve al final de la funci√≥n, verificando el campo ew.err y evitando la molesta traducci√≥n de los valores devueltos de io.Copy <br><br><h3>  Conclusi√≥n </h3><br>  Cuando encuentre un manejo excesivo de errores, intente extraer algunas operaciones como un tipo de contenedor auxiliar. <br><br><h2>  Sobre el autor </h2><br>  El autor de este art√≠culo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dave Cheney</a> , es autor de muchos paquetes populares para Go, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/pkg/errors</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://github.com/davecheney/">github.com/davecheney/httpstat</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/440386/">https://habr.com/ru/post/440386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../440372/index.html">Mi compilador Pascal y arte contempor√°neo polaco</a></li>
<li><a href="../440374/index.html">Las funciones de Yandex env√≠an correo</a></li>
<li><a href="../440376/index.html">20 juegos para ense√±arle a tu hijo a programar</a></li>
<li><a href="../440378/index.html">Volver a los microservicios con Istio. Parte 2</a></li>
<li><a href="../440382/index.html">¬ø200 es bueno o malo?</a></li>
<li><a href="../440388/index.html">Intervalos: la pr√≥xima evoluci√≥n de C ++</a></li>
<li><a href="../440390/index.html">El mundo diverso de los sistemas embebidos y el lugar de Embox en √©l.</a></li>
<li><a href="../440392/index.html">WebRTC en su sitio: sin errores ni presupuesto</a></li>
<li><a href="../440394/index.html">Escalada de privilegios de PostgreSQL: an√°lisis de CVE-2018-10915</a></li>
<li><a href="../440398/index.html">Historia de participaci√≥n (y victoria) en la Copa AI rusa 2018 - CodeBall</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>