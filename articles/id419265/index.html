<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤³ğŸ¼ ğŸ§¦ ğŸŒ Menggunakan jaringan saraf multi-layer untuk menghindari rintangan dalam game ğŸ‘¨ğŸ»â€ğŸ« ğŸ‘ŠğŸ» ğŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menemukan cara untuk menghindari rintangan dalam gim adalah tugas klasik yang harus dihadapi semua pengembang gim. Ada sejumlah algoritma terkenal den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan jaringan saraf multi-layer untuk menghindari rintangan dalam game</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419265/"><p>  Menemukan cara untuk menghindari rintangan dalam gim adalah tugas klasik yang harus dihadapi semua pengembang gim.  Ada sejumlah algoritma terkenal dengan berbagai tingkat efisiensi.  Semuanya, pada tingkat tertentu, menganalisis posisi relatif dari penghalang dan pemain, dan berdasarkan hasil, satu atau lain keputusan untuk bergerak diambil.  Saya mencoba menggunakan jaringan saraf terlatih untuk memecahkan masalah penghindaran kendala.  Saya ingin berbagi pengalaman dalam menerapkan pendekatan ini di Unity3D dalam artikel singkat ini. </p><a name="habracut"></a><br><h2>  Konsep </h2><br><p>  Medan berdasarkan standar Medan digunakan sebagai ruang permainan.  Tabrakan dengan permukaan tidak dipertimbangkan dalam artikel ini.  Setiap model dilengkapi dengan set colliders, seakurat mungkin menggambarkan geometri hambatan.  Model, yang harus melewati rintangan, memiliki empat </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ej/s8/e6/ejs8e6yvjqzipq0khklf3g5ph2o.jpeg"></div><br><p>  sensor tabrakan (dalam tangkapan layar, lokasi dan jarak sensor ditunjukkan oleh garis pirus).  Intinya, sensor adalah reykast, yang masing-masing melewati jarak ke objek tumbukan dalam algoritma analisis.  Jarak bervariasi dari 0 (objek terletak sedekat mungkin) ke 1 (tidak ada tabrakan, arah ini bebas dari rintangan). <br>  Secara umum, pekerjaan algoritme penghindaran rintangan adalah sebagai berikut: </p><br><ol><li>  Empat nilai dari sensor tabrakan diumpankan ke empat input dari jaringan saraf yang terlatih </li><li>  Keadaan jaringan saraf dihitung.  Pada output, kami mendapatkan tiga nilai: <br>  a.  Kekuatan rotasi model berlawanan arah jarum jam (mengambil nilai dari 0 hingga 1) <br>  b.  Kekuatan rotasi model searah jarum jam (mengambil nilai dari 0 hingga 1) <br>  c.  Akselerasi Pengereman (mengambil nilai dari 0 hingga 1) </li><li>  Upaya diterapkan pada model dengan koefisien yang sesuai. </li></ol><br><h2>  Implementasi </h2><br><p>  Sejujurnya, saya tidak tahu apakah akan ada sesuatu dari usaha ini.  Pertama-tama, saya menerapkan kelas neuroNet di Unity.  Saya tidak akan membahas kode kelas, karena ini adalah perceptron multilayer klasik.  Dalam prosesnya, pertanyaan segera muncul dari jumlah lapisan jaringan.  Berapa banyak dari mereka diperlukan untuk menyediakan kapasitas yang diperlukan di satu sisi, dan kecepatan perhitungan yang dapat diterima di sisi lain?  Setelah serangkaian percobaan, saya memilih dua belas lapisan (tiga kondisi dasar untuk empat input). </p><br><p>  Selanjutnya, perlu untuk menerapkan proses pelatihan jaringan saraf.  Untuk melakukan ini, saya harus membuat aplikasi terpisah yang menggunakan kelas neuroNet yang sama.  Dan sekarang masalah data untuk pelatihan telah meningkat secara maksimal.  Awalnya, saya ingin menggunakan nilai yang diperoleh langsung dari aplikasi game.  Untuk melakukan ini, saya mengatur pencatatan data dari sensor, sehingga di masa depan untuk setiap set nilai dari empat sensor untuk menunjukkan kepada program pelatihan nilai-nilai output yang benar.  Tetapi, melihat hasilnya, saya menjadi putus asa.  Faktanya adalah bahwa itu tidak cukup untuk menunjukkan nilai yang memadai untuk setiap set dari empat nilai sensor, nilai-nilai ini harus konsisten.  Ini sangat penting untuk keberhasilan pelatihan jaringan saraf.  Selain itu, tidak ada jaminan bahwa sampel yang dihasilkan mewakili semua situasi yang mungkin. </p><br><p>  Solusi alternatif adalah tabel opsi-opsi dasar yang disusun secara manual untuk nilai-nilai sensor dan output.  Pilihan dasar diambil nilai: 0,01 - rintangan dekat, 0,5 - hambatan setengah, 1 - arahnya gratis.  Ini telah mengurangi ukuran sampel pelatihan. </p><br><table><thead><tr><th><pre>  Sensor 1 </pre></th><th><pre>  Sensor 2 </pre></th><th><pre>  Sensor 3 </pre></th><th><pre>  Sensor 4 </pre></th><th>  Rotasi searah jarum jam </th><th>  Rotasi berlawanan arah jarum jam </th><th>  Pengereman </th></tr></thead><tbody><tr><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,5 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td><td>  0,999 </td><td>  0,01 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,5 </td><td>  0,01 </td><td>  0,999 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,5 </td><td>  0,5 </td><td>  0,999 </td><td>  0,01 </td><td>  0,01 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,5 </td><td>  0,999 </td><td>  0,999 </td><td>  0,01 </td><td>  0,5 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,999 </td><td>  0,01 </td><td>  0,999 </td><td>  0,01 </td><td>  0,5 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,999 </td><td>  0,5 </td><td>  0,999 </td><td>  0,01 </td><td>  0,999 </td></tr><tr><td>  0,01 </td><td>  0,01 </td><td>  0,999 </td><td>  0,999 </td><td>  0,999 </td><td>  0,01 </td><td>  0,999 </td></tr></tbody></table><br><p>  Tabel menunjukkan sebagian kecil dari sampel pelatihan (total dalam tabel 81-a row).  Hasil akhir dari program pelatihan adalah tabel pembobotan, yang disimpan dalam file terpisah. </p><br><h2>  Hasil </h2><br><p>  Dalam mengantisipasi menggosok tangan saya, saya mengatur pemuatan peluang ke dalam game demo dan memulai prosesnya.  Tapi, ternyata, saya jelas tidak cukup untuk kasus ini.  Sejak awal, model yang diuji berputar, berlari ke semua hambatan berturut-turut, seperti anak kucing buta.  Secara umum, hasilnya sangat-begitu-begitu saja.  Saya harus mempelajari masalah ini.  Sumber perilaku tak berdaya ditemukan cukup cepat.  Dengan respons yang secara umum benar dari jaringan saraf terhadap pembacaan sensor, tindakan kontrol yang ditransmisikan ternyata terlalu kuat. </p><br><p>  Setelah menyelesaikan masalah ini, saya menemui kesulitan baru - sensor jarak reykast.  Dengan jarak yang jauh mendeteksi gangguan, model melakukan manuver prematur, yang mengakibatkan distorsi rute yang signifikan (dan bahkan dalam tabrakan tak terduga dalam rintangan yang tampaknya sudah melewati rintangan).  Jarak kecil mengarah pada satu hal - "menempel" model yang tidak berdaya ke semua hambatan dengan jelas tidak ada waktu untuk menanggapi. </p><br><p>  Semakin saya mengutak-atik model permainan demo, mencoba mengajarkannya untuk menghindari rintangan, semakin saya merasa bukan pemrograman, tetapi mencoba mengajar anak saya untuk berjalan.  Dan itu adalah sensasi yang tidak biasa!  Jauh lebih menyenangkan melihat upaya saya membawa hasil nyata.  Pada akhirnya, kapal melayang yang malang melayang di atas permukaan mulai dengan percaya diri mengelilingi struktur yang timbul pada rute.  Tes nyata untuk algoritma dimulai ketika saya secara sadar mencoba mendorong model ke jalan buntu.  Di sini diperlukan untuk mengubah logika kerja dengan akselerasi pengereman, untuk membuat beberapa koreksi pada sampel pelatihan.  Mari kita lihat contoh-contoh praktis tentang apa yang terjadi sebagai akibatnya. </p><br><h4 id="1-prostoy-obhod-odnogo-prepyatstviya">  1. Bypass sederhana dari satu hambatan </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iX45Xe-ww5U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Seperti yang Anda lihat, memotong tidak menyebabkan kesulitan. </p><br><h4 id="2-dva-prepyatstviya-variant-1">  2. Dua rintangan (opsi 1) </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xTd0Fdrvr-E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Model itu dengan mudah menemukan lorong di antara kedua bangunan itu.  Tugas yang mudah. </p><br><h4 id="3-dva-prepyatstviya-variant-2">  3. Dua rintangan (opsi 2) </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Y4BkLGn4M5Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Bangunan lebih dekat, tetapi modelnya menemukan lorong. </p><br><h4 id="4-dva-prepyatstviya-variant-3">  4. Dua rintangan (opsi 3) </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JdCltkyot6c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Opsi ini lebih rumit, tetapi masih diselesaikan. </p><br><h4 id="5-tri-prepyatstviya">  5. Tiga rintangan </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/lgeHMbBp-ZM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Masalahnya diselesaikan dengan cukup cepat. </p><br><h4 id="6-tupik">  6. Jalan Buntu </h4><br><iframe width="560" height="315" src="https://www.youtube.com/embed/zWXk4QqApy8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Di sini model punya masalah.  30 detik pertama dari video menunjukkan bahwa model mengapung tanpa daya dalam konfigurasi bangunan sederhana.  Masalahnya di sini kemungkinan besar tidak terletak pada model jaringan saraf seperti pada algoritma utama untuk bergerak di sepanjang rute - ia terus berusaha mendapatkan kapal kembali ke jalurnya, meskipun upaya putus asa untuk menghindari tabrakan. </p><br><p>  Setelah beberapa kali gagal dalam situasi ini dengan parameter yang berbeda, saya berhasil mendapatkan hasil yang positif.  Dari detik ketiga puluh video, Anda dapat mengamati bagaimana model dengan peningkatan jarak sensor dan dengan gaya pengereman yang lebih kuat dipilih dari jalan buntu.  Untuk ini dia membutuhkan waktu hampir lima menit (saya memotong siksaan dan hanya menyisakan 30 detik terakhir dari video).  Tidak mungkin bahwa dalam game nyata ini akan dianggap sebagai hasil yang baik, jadi jelas ada ruang untuk perbaikan algoritma. </p><br><h2>  Kesimpulan </h2><br><p>  Secara umum, masalah terpecahkan.  Seberapa efektif solusi ini merupakan pertanyaan terbuka, dan diperlukan lebih banyak penelitian.  Misalnya, tidak diketahui bagaimana model akan berperilaku ketika hambatan dinamis (objek bergerak lainnya) muncul.  Masalah lain adalah kurangnya sensor tabrakan yang mengarah ke belakang, yang menyebabkan kesulitan dalam menghindari hambatan yang kompleks. </p><br><p>  Perkembangan lebih lanjut yang jelas dari gagasan algoritma penghindaran hambatan jaringan saraf terlihat dalam pengenalan pelatihan.  Untuk melakukan ini, penilaian hasil keputusan yang dibuat harus diperkenalkan, dan dengan koreksi selanjutnya tanpa perubahan signifikan pada posisi objek, penilaian harus menurun.  Setelah mencapai nilai tertentu, model harus masuk ke mode pelatihan dan, katakanlah, secara acak mengubah keputusan yang diambil untuk menemukan jalan keluar. </p><br><p>  Fitur lain dari model bagi saya adalah variabilitas pelatihan awal.  Ini memungkinkan, misalnya, untuk memiliki beberapa perilaku untuk model yang berbeda tanpa perlu memprogram masing-masing secara terpisah.  Dengan kata lain, jika kita memiliki, katakanlah, tangki berat dan pengintaian ringan, cara mereka menghindari rintangan bisa sangat bervariasi.  Untuk mencapai efek ini, kami menggunakan perceptron yang sama, tetapi dilatih pada sampel yang berbeda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419265/">https://habr.com/ru/post/id419265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id419253/index.html">Laporan Club of Rome 2018, Bab 3.6: Urbanisme Regeneratif: Ecopolis</a></li>
<li><a href="../id419255/index.html">Dasar-dasar Keamanan IoT</a></li>
<li><a href="../id419257/index.html">India Memperkenalkan RUU Perlindungan PD Baru - Analog ke GDPR lainnya?</a></li>
<li><a href="../id419259/index.html">Rust 1.28 Rilis</a></li>
<li><a href="../id419261/index.html">Tindakan di Google: menulis aplikasi sederhana untuk Google Assistant di Dialogflow dan Cloud Functions for Firebase</a></li>
<li><a href="../id419267/index.html">SOK Coworking Tour</a></li>
<li><a href="../id419269/index.html">Rebus dalam kode, dan cara mendekripsi mereka. Kekuatan Rahasia Pengidentifikasi</a></li>
<li><a href="../id419271/index.html">Analog dengan Python dan JavaScript. Bagian empat</a></li>
<li><a href="../id419273/index.html">Menulis modul kernel Linux: GPIO dengan dukungan IRQ</a></li>
<li><a href="../id419277/index.html">Kaset termal dengan kelas perlindungan IP68. Cocok untuk penerangan di pemandian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>