<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï• üíß üîå Warum beschleunigt const C / C ++ - Code nicht? üèñÔ∏è „äóÔ∏è üî≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor einigen Monaten erw√§hnte ich in einem Beitrag, dass dies ein Mythos ist, als ob const dabei hilft, Compiler-Optimierungen in C und C ++ zu erm√∂gli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Warum beschleunigt const C / C ++ - Code nicht?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/464777/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ck/cw/48/ckcw48o0aqklzf10gzhfqx8w3rw.jpeg"></div><br>  Vor einigen Monaten erw√§hnte ich in einem Beitrag, dass <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dies ein Mythos ist, als ob const dabei hilft, Compiler-Optimierungen in C und C ++ zu erm√∂glichen</a> .  Ich entschied, dass diese Aussage erkl√§rt werden sollte, insbesondere weil ich selbst vorher an diesen Mythos geglaubt hatte.  Ich beginne mit Theorie und k√ºnstlichen Beispielen und gehe dann zu Experimenten und Benchmarks √ºber, die auf einer echten Codebasis basieren - SQLite. <br><a name="habracut"></a><br><h2>  Einfacher Test </h2><br>  Beginnen wir mit dem einfachsten und offensichtlichsten Beispiel f√ºr die Beschleunigung von C-Code mit <code>const</code> .  Angenommen, wir haben zwei Funktionsdeklarationen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>;</code> </pre> <br>  Angenommen, es gibt zwei Versionen des Codes: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); func(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constByArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); constFunc(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); }</code> </pre> <br>  Um <code>printf()</code> auszuf√ºhren, muss der Prozessor <code>*x</code> √ºber einen Zeiger aus dem Speicher abrufen.  Offensichtlich kann die Ausf√ºhrung von <code>constByArg()</code> etwas schneller sein, da der Compiler wei√ü, dass <code>*x</code> eine Konstante ist, sodass der Wert nicht erneut <code>constFunc()</code> muss, nachdem <code>constFunc()</code> dies getan hat.  Richtig?  Sehen wir uns den von GCC generierten Assembler-Code mit aktivierten Optimierungen an: <br><br><pre> <code class="bash hljs">$ gcc -S -Wall -O3 test.c $ view test.s</code> </pre> <br>  Und hier ist das vollst√§ndige Assembler-Ergebnis f√ºr <code>byArg()</code> : <br><br><pre> <code class="plaintext hljs">byArg: .LFB23: .cfi_startproc pushq %rbx .cfi_def_cfa_offset 16 .cfi_offset 3, -16 movl (%rdi), %edx movq %rdi, %rbx leaq .LC0(%rip), %rsi movl $1, %edi xorl %eax, %eax call __printf_chk@PLT movq %rbx, %rdi call func@PLT # The only instruction that's different in constFoo movl (%rbx), %edx leaq .LC0(%rip), %rsi xorl %eax, %eax movl $1, %edi popq %rbx .cfi_def_cfa_offset 8 jmp __printf_chk@PLT .cfi_endproc</code> </pre> <br>  Der einzige Unterschied zwischen dem f√ºr <code>byArg()</code> und <code>constByArg()</code> generierten Assembler-Code besteht darin, dass <code>constByArg()</code> wie im Quellcode einen <code>call constFunc@PLT</code> hat.  <code>const</code> selbst macht keinen Unterschied. <br><br>  Okay, das war GCC.  Vielleicht brauchen wir einen intelligenteren Compiler.  Sag Clang. <br><br><pre> <code class="cpp hljs">$ clang -S -Wall -O3 -emit-llvm test.c $ view test.ll</code> </pre> <br>  Hier ist der Zwischencode.  Es ist kompakter als Assembler, und ich werde beide Funktionen l√∂schen, damit Sie verstehen, was ich unter "kein Unterschied, au√üer dem Aufruf" verstehe: <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @byArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @func(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constByArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br><h2>  Option, die (Typ) funktioniert </h2><br>  Und hier ist der Code, in dem das Vorhandensein von <code>const</code> wirklich wichtig ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); constFunc(&amp;x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constLocalVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// const on the local variable printf("%d\n", x); constFunc(&amp;x); printf("%d\n", x); }</span></span></code> </pre> <br>  Der Assembler-Code f√ºr <code>localVar()</code> , der zwei au√üerhalb von <code>constLocalVar()</code> optimierte Anweisungen enth√§lt: <br><br><pre> <code class="cpp hljs">localVar: .LFB25: .cfi_startproc subq $<span class="hljs-number"><span class="hljs-number">24</span></span>, %rsp .cfi_def_cfa_offset <span class="hljs-number"><span class="hljs-number">32</span></span> movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, %edx movl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %edi movq %fs:<span class="hljs-number"><span class="hljs-number">40</span></span>, %rax movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rsp) xorl %eax, %eax leaq .LC0(%rip), %rsi movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp) call __printf_chk@PLT leaq <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %rdi call constFunc@PLT movl <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %edx <span class="hljs-meta"><span class="hljs-meta"># not in constLocalVar() xorl %eax, %eax movl $1, %edi leaq .LC0(%rip), %rsi # not in constLocalVar() call __printf_chk@PLT movq 8(%rsp), %rax xorq %fs:40, %rax jne .L9 addq $24, %rsp .cfi_remember_state .cfi_def_cfa_offset 8 ret .L9: .cfi_restore_state call __stack_chk_fail@PLT .cfi_endproc</span></span></code> </pre> <br>  Die LLVM-Middleware ist etwas sauberer.  <code>load</code> vor dem zweiten Aufruf von <code>printf()</code> wurde au√üerhalb von <code>constLocalVar()</code> optimiert: <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @localVar() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">1</span></span> = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = bitcast i32* %<span class="hljs-number"><span class="hljs-number">1</span></span> to i8* call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.start.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">42</span></span>, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 <span class="hljs-number"><span class="hljs-number">42</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* nonnull %<span class="hljs-number"><span class="hljs-number">1</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.end.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br>  Daher hat <code>constLocalVar()</code> den Neustart <code>*x</code> erfolgreich ignoriert, aber Sie werden m√∂glicherweise etwas Seltsames bemerken: In den K√∂rpern <code>localVar()</code> und <code>constLocalVar()</code> derselbe Aufruf von <code>constFunc()</code> .  Wenn der Compiler herausfinden kann, dass <code>constFunc()</code> <code>*x</code> in <code>constLocalVar()</code> nicht <code>constLocalVar()</code> , warum kann er dann nicht verstehen, dass der gleiche Funktionsaufruf <code>*x</code> in <code>localVar()</code> nicht <code>localVar()</code> ? <br><br>  Die Erkl√§rung ist, warum die Verwendung von <code>const</code> in C als Optimierung unpraktisch ist.  In C hat <code>const</code> im Wesentlichen zwei m√∂gliche Bedeutungen: <br><br><ul><li>  Dies kann bedeuten, dass eine Variable ein schreibgesch√ºtztes Pseudonym f√ºr einige Daten ist, die konstant sein k√∂nnen oder nicht. <br></li><li>  oder es kann bedeuten, dass die Variable wirklich eine Konstante ist.  Wenn Sie <code>const</code> von einem Zeiger auf einen konstanten Wert l√∂sen und dann darauf schreiben, erhalten Sie ein undefiniertes Verhalten.  Andererseits gibt es kein Problem, wenn <code>const</code> ein Zeiger auf einen Wert ist, der keine Konstante ist. <br></li></ul><br>  Hier ist ein erkl√§rendes Beispiel f√ºr die Implementierung von <code>constFunc()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// x is just a read-only pointer to something that may or may not be a constant void constFunc(const int *x) { // local_var is a true constant const int local_var = 42; // Definitely undefined behaviour by C rules doubleIt((int*)&amp;local_var); // Who knows if this is UB? doubleIt((int*)x); } void doubleIt(int *x) { *x *= 2; }</span></span></code> </pre><br>  <code>localVar()</code> gab <code>constFunc()</code> einen <code>const</code> Zeiger auf eine nicht- <code>const</code> Variable.  Da die Variable anfangs nicht <code>const</code> , kann sich <code>constFunc()</code> als L√ºgner herausstellen und die Variable zwangsweise √§ndern, ohne UB zu initiieren.  Daher kann der Compiler nicht davon ausgehen, dass <code>constFunc()</code> Variable nach der R√ºckgabe von <code>constFunc()</code> denselben Wert hat.  Die Variable in <code>constLocalVar()</code> Tat <code>const</code> , daher kann der Compiler nicht davon ausgehen, dass sie nicht ge√§ndert wird, da diesmal UB f√ºr <code>constFunc()</code> , sodass der Compiler <code>const</code> aufhebt und in die Variable schreibt. <br><br>  Die Funktionen <code>byArg()</code> und <code>constByArg()</code> aus dem ersten Beispiel sind hoffnungslos, da der Compiler nicht <code>constByArg()</code> , ob <code>*x</code> <code>const</code> . <br><br>  Aber woher kam die Inkonsistenz?  Wenn der Compiler davon ausgehen kann, dass <code>constFunc()</code> sein Argument beim Aufruf von <code>constLocalVar()</code> nicht √§ndert, kann er dieselben Optimierungen auf <code>constFunc()</code> -Aufrufe anwenden, oder?  Nein.  Der Compiler kann nicht davon ausgehen, dass <code>constLocalVar()</code> jemals aufgerufen wird.  Wenn dies nicht der Fall ist (z. B. weil es sich nur um ein zus√§tzliches Ergebnis des Codegenerators oder der <code>constFunc()</code> kann <code>constFunc()</code> die Daten leise √§ndern, ohne UB zu initiieren. <br><br>  M√∂glicherweise m√ºssen Sie die obigen Beispiele und Erkl√§rungen mehrmals lesen.  Mach dir keine Sorgen, dass es absurd klingt - es ist.  Leider ist das Schreiben in <code>const</code> Variablen die schlechteste Art von UB: Meistens wei√ü der Compiler nicht einmal, ob es sich um UB handelt.  Wenn der Compiler <code>const</code> sieht, sollte er daher von der Tatsache ausgehen, dass jemand es irgendwo √§ndern kann, was bedeutet, dass der Compiler <code>const</code> zur Optimierung verwenden kann.  In der Praxis ist dies der Fall, da viele echte C-Codes eine Ablehnung von <code>const</code> im Stil von "Ich wei√ü, was ich tue" enthalten. <br><br>  Kurz gesagt, es gibt viele Situationen, in denen der Compiler <code>const</code> zur Optimierung verwenden darf, einschlie√ülich des Abrufs von Daten aus einem anderen Bereich mithilfe eines Zeigers oder des Platzierens von Daten auf einem Heap.  Oder noch schlimmer, normalerweise in Situationen, in denen der Compiler <code>const</code> nicht verwenden kann, ist dies nicht erforderlich.  Zum Beispiel kann jeder Compiler mit Selbstachtung ohne <code>const</code> verstehen, dass in diesem Code <code>x</code> eine Konstante ist: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y); y += x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y);</code> </pre> <br>  Daher ist <code>const</code> f√ºr die Optimierung fast unbrauchbar, weil: <br><br><ol><li>  Mit wenigen Ausnahmen ist der Compiler gezwungen, dies zu ignorieren, da einige Codes die Konstante legal l√∂sen k√∂nnen. <br></li><li>  In den meisten der oben genannten Ausnahmen kann der Compiler immer noch verstehen, dass die Variable eine Konstante ist. <br></li></ol><br><h2>  C ++ </h2><br>  Wenn Sie in C ++ schreiben, kann <code>const</code> die Codegenerierung durch Funktions√ºberladung beeinflussen.  Sie k√∂nnen <code>const</code> und non- <code>const</code> √úberladungen derselben Funktion haben, und non- <code>const</code> kann beispielsweise (von einem Programmierer, nicht von einem Compiler) optimiert werden, um weniger zu kopieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Needs to do more copying of data } void foo(const int *p) { // Doesn't need defensive copies } int main() { const int x = 42; // const-ness affects which overload gets called foo(&amp;x); return 0; }</span></span></code> </pre> <br>  Einerseits glaube ich nicht, dass dies in der Praxis h√§ufig in C ++ - Code angewendet wird.  Andererseits muss ein Programmierer Annahmen treffen, die dem Compiler nicht zur Verf√ºgung stehen, damit sie wirklich einen Unterschied machen, da sie nicht durch die Sprache garantiert werden. <br><br><h2>  Experimentieren Sie mit SQLite3 </h2><br>  Genug Theorie und weit hergeholte Beispiele.  Welche Auswirkung hat <code>const</code> auf die reale Codebasis?  Ich habe mich entschieden, mit SQLite DB (Version 3.30.0) zu experimentieren, weil: <br><br><ul><li>  Es verwendet <code>const.</code> </li><li>  Dies ist eine nicht triviale Codebasis (√ºber 200 KLOC). <br></li><li>  Als Datenbank enth√§lt sie eine Reihe von Mechanismen, die mit der Verarbeitung von Zeichenfolgenwerten beginnen und mit der Konvertierung von Zahlen in das Datum enden. <br></li><li>  Es kann mit einer begrenzten Prozessorlast getestet werden. <br></li></ul><br>  Dar√ºber hinaus haben der Autor und die an der Entwicklung beteiligten Programmierer bereits Jahre damit verbracht, die Produktivit√§t zu verbessern, sodass wir davon ausgehen k√∂nnen, dass sie nichts Offensichtliches √ºbersehen haben. <br><br><h3>  Vorbereitung </h3><br>  Ich habe zwei Kopien des <a href="">Quellcodes erstellt</a> .  Eine im normalen Modus kompiliert und die zweite mit einem Hack vorverarbeitet, um <code>const</code> in einen Leerlaufbefehl umzuwandeln: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> const</span></span></code> </pre> <br>  (GNU) <code>sed</code> kann dies mit dem Befehl <code>sed -i '1i#define const' *.c *.h</code> √ºber jede Datei <code>sed -i '1i#define const' *.c *.h</code> . <br><br>  SQLite verkompliziert die Dinge ein wenig und verwendet Skripte, um w√§hrend des Builds Code zu generieren.  Gl√ºcklicherweise verursachen Compiler beim Mischen von Code mit <code>const</code> und ohne <code>const</code> viel Rauschen, sodass Sie die Skripte sofort bemerken und konfigurieren k√∂nnen, um meinen Anti- <code>const</code> Code hinzuzuf√ºgen. <br><br>  Ein direkter Vergleich der kompilierten Codes ist nicht sinnvoll, da eine kleine √Ñnderung das gesamte Speicherschema beeinflussen kann, was zu einer √Ñnderung der Zeiger und Funktionsaufrufe im gesamten Code f√ºhrt.  Daher habe ich eine zerlegte Besetzung ( <code>objdump -d libSQLite3.so.0.8.6</code> ) als Gr√∂√üe der Bin√§rdatei und des mnemonischen Namens jeder Anweisung verwendet.  Zum Beispiel diese Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">000000000005</span></span>d570 &lt;SQLite3_blob_read&gt;: <span class="hljs-number"><span class="hljs-number">5</span></span>d570: <span class="hljs-number"><span class="hljs-number">4</span></span>c <span class="hljs-number"><span class="hljs-number">8</span></span>d <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> a2 ff ff lea <span class="hljs-number"><span class="hljs-number">-0x5da7</span></span>(%rip),%r8 # <span class="hljs-number"><span class="hljs-number">577</span></span>d0 &lt;SQLite3BtreePayloadChecked&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d577: e9 <span class="hljs-number"><span class="hljs-number">04</span></span> fe ff ff jmpq <span class="hljs-number"><span class="hljs-number">5</span></span>d380 &lt;blobReadWrite&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d57c: <span class="hljs-number"><span class="hljs-number">0f</span></span> <span class="hljs-number"><span class="hljs-number">1f</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> nopl <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rax)</code> </pre> <br>  Wird zu: <br><br><pre> <code class="cpp hljs">SQLite3_blob_read <span class="hljs-number"><span class="hljs-number">7l</span></span>ea <span class="hljs-number"><span class="hljs-number">5</span></span>jmpq <span class="hljs-number"><span class="hljs-number">4</span></span>nopl</code> </pre> <br>  Beim Kompilieren habe ich die SQLite-Assemblyeinstellungen nicht ge√§ndert. <br><br><h3>  Kompilierte Code-Analyse </h3><br>  F√ºr libSQLite3.so belegte die Version mit <code>const</code> 4.740.704 Bytes, ungef√§hr 0,1% mehr als die Version ohne <code>const</code> mit 4.736.712 Bytes.  In beiden F√§llen wurden 1374 Funktionen exportiert (ohne die Hilfsfunktionen auf niedriger Ebene im PLT), und 13 wiesen Unterschiede in den Besetzungen auf. <br><br>  Einige √Ñnderungen betrafen den Vorverarbeitungs-Hack.  Hier ist zum Beispiel eine der ge√§nderten Funktionen (ich habe einige f√ºr SQLite spezifische Definitionen entfernt): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LARGEST_INT64 (0xffffffff|(((int64_t)0x7fffffff)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;32)) #define SMALLEST_INT64 (((int64_t)-1) - LARGEST_INT64) static int64_t doubleToInt64(double r){ /* ** Many compilers we encounter do not define constants for the ** minimum and maximum 64-bit integers, or they define them ** inconsistently. And many do not understand the "LL" notation. ** So we define our own static constants here using nothing ** larger than a 32-bit integer constant. */ static const int64_t maxInt = LARGEST_INT64; static const int64_t minInt = SMALLEST_INT64; if( r&lt;=(double)minInt ){ return minInt; }else if( r&gt;=(double)maxInt ){ return maxInt; }else{ return (int64_t)r; } }</span></span></span></span></code> </pre> <br>  Wenn wir <code>const</code> entfernen, werden diese Konstanten zu <code>static</code> Variablen.  Ich verstehe nicht, warum jeder, der sich nicht f√ºr <code>const</code> interessiert, diese Variablen <code>static</code> machen <code>const</code> .  Wenn wir sowohl <code>static</code> als auch <code>const</code> entfernen, betrachtet GCC sie erneut als Konstanten und wir erhalten das gleiche Ergebnis.  Aufgrund solcher <code>static const</code> Variablen erwiesen sich √Ñnderungen in drei von dreizehn Funktionen als falsch, aber ich habe sie nicht behoben. <br><br>  SQLite verwendet viele globale Variablen, und die meisten echten Konstantenoptimierungen h√§ngen damit zusammen: Wie das Ersetzen eines Vergleichs durch eine Variable durch einen Vergleich mit einer Konstanten oder das teilweise Zur√ºckrollen der Schleife um einen Schritt (um zu verstehen, welche Art von Optimierungen vorgenommen wurden, habe ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Radare verwendet</a> ).  Einige √Ñnderungen sind nicht erw√§hnenswert.  <code>SQLite3ParseUri()</code> enth√§lt 487 Anweisungen, aber <code>const</code> hat nur eine √Ñnderung vorgenommen: Diese beiden Vergleiche wurden durchgef√ºhrt: <br><br><pre> <code class="cpp hljs">test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br>  Und getauscht: <br><br><pre> <code class="cpp hljs">cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br><h3>  Benchmarks </h3><br>  SQLite wird mit einem Regressionstest geliefert, um die Leistung zu messen. Ich habe ihn hunderte Male f√ºr jede Version des Codes unter Verwendung der Standard-SQLite-Build-Einstellungen ausgef√ºhrt.  Ausf√ºhrungszeit in Sekunden: <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  const <br></td><td>  Ohne const <br></td></tr><tr><td>  Minimum <br></td><td>  10.658 <br></td><td>  10.803 <br></td></tr><tr><td>  Median <br></td><td>  11.571 <br></td><td>  11.519 <br></td></tr><tr><td>  Maximum <br></td><td>  11.832 <br></td><td>  11.658 <br></td></tr><tr><td>  Durchschnitt <br></td><td>  11.531 <br></td><td>  11.492 <br></td></tr></tbody></table></div><br>  Pers√∂nlich sehe ich keinen gro√üen Unterschied.  Ich habe <code>const</code> aus dem gesamten Programm entfernt. Wenn es also einen merklichen Unterschied gab, war es leicht zu bemerken.  Wenn Ihnen die Leistung jedoch extrem wichtig ist, kann Ihnen auch eine winzige Beschleunigung gefallen.  Lassen Sie uns eine statistische Analyse durchf√ºhren. <br><br>  Ich verwende gerne den Mann-Whitney-U-Test f√ºr solche Aufgaben. Er √§hnelt dem bekannteren t-Test, mit dem Unterschiede in Gruppen ermittelt werden sollen, ist jedoch widerstandsf√§higer gegen komplexe zuf√§llige Abweichungen, die bei der Zeitmessung auf Computern auftreten (aufgrund unvorhersehbarer Kontextwechsel, Fehler in) Ged√§chtnisseiten usw.).  Hier ist das Ergebnis: <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  const </th><th>  Ohne const </th></tr><tr><td>  N. </td><td>  100 </td><td>  100 </td></tr><tr><td>  Mittlere Kategorie (mittlerer Rang) </td><td>  121,38 </td><td>  79,62 </td></tr><tr><td>  Mann-Whitney u </td><td></td><td>  2912 </td></tr><tr><td>  Z. </td><td></td><td>  -5.10 </td></tr><tr><td>  2-seitiger p-Wert </td><td></td><td>  &lt;10 <sup>-6</sup> <br></td></tr><tr><td>  Der durchschnittliche Unterschied betr√§gt HL <br></td><td></td><td>  -0,056 s. <br></td></tr><tr><td>  95-Prozent-Konfidenzintervall <br></td><td></td><td>  -0,077 ... -0,038 s. <br></td></tr></tbody></table></div><br>  Test U ergab einen statistisch signifikanten Leistungsunterschied.  Aber - eine √úberraschung!  - Die Version ohne <code>const</code> erwies sich um etwa 60 ms, dh um 0,5%, als schneller.  Es scheint, dass die geringe Anzahl der vorgenommenen ‚ÄûOptimierungen‚Äú die Erh√∂hung der Codemenge nicht wert war.  Es ist unwahrscheinlich, dass <code>const</code> wichtige Optimierungen wie die automatische Vektorisierung aktiviert <code>const</code> .  Nat√ºrlich kann Ihr Kilometerstand von verschiedenen Flags im Compiler oder von seiner Version oder von der Codebasis oder von etwas anderem abh√§ngen.  Aber es scheint mir ehrlich zu sein, dass ich dies nicht bemerkt habe, auch wenn <code>const</code> die Leistung von C verbessert hat. <br><br><h2>  Wof√ºr wird const ben√∂tigt? </h2><br>  Trotz aller M√§ngel ist <code>const</code> in C / C ++ n√ºtzlich, um die Typensicherheit zu gew√§hrleisten.  Insbesondere wenn Sie <code>const</code> in Kombination mit Verschiebungssemantik und <code>std::unique_pointer</code> , k√∂nnen Sie den expliziten Zeigerbesitz implementieren.  Die Unsicherheit des Zeigerbesitzes war ein gro√ües Problem in √§lteren C ++ - Codebasen √ºber 100 KLOC, daher bin ich <code>const</code> dankbar, dass er es gel√∂st hat. <br><br>  Bevor ich jedoch √ºber die Verwendung von <code>const</code> hinausging, um die <code>const</code> zu gew√§hrleisten.  Ich habe geh√∂rt, dass es als richtig angesehen wurde, <code>const</code> so aktiv wie m√∂glich zu verwenden, um die Leistung zu verbessern.  Ich habe geh√∂rt, dass man, wenn die Leistung wirklich wichtig ist, den Code umgestalten musste, um mehr <code>const</code> hinzuzuf√ºgen, selbst wenn der Code weniger lesbar wurde.  Es klang damals vern√ºnftig, aber seitdem wurde mir klar, dass dies nicht stimmte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464777/">https://habr.com/ru/post/de464777/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464763/index.html">Benchmarks f√ºr Server unter Linux: eine Auswahl offener Tools</a></li>
<li><a href="../de464765/index.html">FreePBX + GoIP konfigurieren</a></li>
<li><a href="../de464769/index.html">Wie Badoo es m√∂glich machte, 200.000 Fotos pro Sekunde auszugeben</a></li>
<li><a href="../de464773/index.html">Asynchrones Typoskript in Rich Internet-Anwendungen und Dekorateuren zur Bek√§mpfung</a></li>
<li><a href="../de464775/index.html">21. September Badoo PHP Meetup # 3: Leistung</a></li>
<li><a href="../de464779/index.html">√úber hedonistische Bienen, die Art und Weise, wie Menschen sie arbeiten lassen, und Drohnen</a></li>
<li><a href="../de464781/index.html">Smart-TVs: CRT zu HDR</a></li>
<li><a href="../de464785/index.html">Nicht wettbewerbsf√§hige Beeline-Vorteile</a></li>
<li><a href="../de464787/index.html">Ich bin sicher, dass Senior Mobile Developer nur auf Empfehlung kommen werden</a></li>
<li><a href="../de464791/index.html">Kubernetes f√ºr das Auto: So √∂ffnen Sie den Entwicklerzugriff auf den Bordcomputer und machen ihn sicher</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>