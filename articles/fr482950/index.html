<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📤 🎃 🖊️ Java: des choses qui peuvent sembler curieuses à un développeur expérimenté 👩🏾‍🏭 🍆 ✍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bon moment de la journée! 

 L'article a été écrit dans le sillage de la publication «Choses que vous [peut-être] ne saviez pas sur Java» par un autre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Java: des choses qui peuvent sembler curieuses à un développeur expérimenté</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482950/"> Bon moment de la journée! <br><br>  L'article a été écrit dans le sillage de la publication <a href="https://habr.com/ru/post/482364">«Choses que vous [peut-être] ne saviez pas sur Java» par</a> un autre auteur, que je qualifierais de «pour les débutants».  En le lisant et en le commentant, j'ai réalisé qu'il y avait un certain nombre de choses assez intéressantes que j'avais apprises, déjà en programmation en java depuis plus d'un an.  Peut-être que ces choses sembleront curieuses à quelqu'un d'autre. <br><br><a name="habracut"></a>  Les faits qui, de mon point de vue, peuvent être utiles aux débutants, je les ai supprimés dans les "spoilers".  Certaines choses peuvent être intéressantes pour les plus expérimentés.  Par exemple, je ne savais moi-même qu'au moment de l'écriture que Boolean.hashCode (true) == 1231 et Boolean.hashCode (false) == 1237. <br><br><div class="spoiler">  <b class="spoiler_title">pour les débutants</b> <div class="spoiler_text"><ul><li>  Boolean.hashCode (true) == 1231 </li><li>  Boolean.hashCode (false) == 1237 </li><li>  Float.hashCode (valeur) == Float.floatToIntBits (valeur) </li><li>  Double.hashCode (valeur) - xor des premier et deuxième demi-mots 32 bits Double.doubleToLongBits (valeur) </li></ul></div></div><br><h2>  Object.hashCode () n'est plus l'adresse d'un objet en mémoire </h2><br>  Avertissement: Il s'agit d'un détail jvm d'Oracle (HotSpot). <br><br><div class="spoiler">  <b class="spoiler_title">Il était une fois ce fut le cas.</b> <div class="spoiler_text">  Depuis jdk1.2.1 / docs / api / java / lang / Object.html # hashCode (): <blockquote>  Autant que cela est raisonnablement pratique, la méthode hashCode définie par la classe Object renvoie des entiers distincts pour des objets distincts.  (Ceci est généralement implémenté en convertissant l'adresse interne de l'objet en un entier, mais cette technique d'implémentation n'est pas requise par le langage de programmation JavaTM.) </blockquote></div></div><br>  Puis ils l'ont refusé.  C'est ce que <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Object.html" rel="nofollow">javadoc</a> dit <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/Object.html" rel="nofollow">pour jdk 12</a> . <br><br>  <a href="https://habr.com/ru/users/vladimir_dolzhenko/" class="user_link">vladimir_dolzhenko a</a> suggéré que l'ancien comportement peut être restauré en utilisant -XX: hashCode = 4.  Et le changement de comportement lui-même était presque de la version Java 1.2. <br><br><h2>  Integer.valueOf (15) == Integer.valueOf (15);  Integer.valueOf (128)! = Integer.valueOf (128) </h2><br>  Avertissement: cela fait partie de <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html" rel="nofollow">jls</a> . <br><br>  Il est clair que lors de la comparaison de deux wrappers avec l'opérateur == (! =), Aucune mise en boîte automatique ne se produit.  D'une manière générale, c'est la première égalité qui confond.  Le fait est que pour les valeurs entières i: -129 &lt;i &lt;128 Les objets encapsuleurs entiers sont mis en cache.  Par conséquent, pour i de cette plage, Integer.valueOf (i) ne crée pas à chaque fois un nouvel objet, mais renvoie un objet déjà créé.  Pour les i qui ne tombent pas dans cette plage, Integer.valueOf (i) crée toujours un nouvel objet.  Par conséquent, si vous ne surveillez pas de près ce qui est exactement et comment exactement il est comparé, vous pouvez écrire du code qui semble fonctionner et même couvert de tests, mais contenant en même temps un tel "rake". <br><br>  Dans jvm d'Oracle (HotSpot), la limite supérieure de mise en cache peut être modifiée via la propriété <a href="" rel="nofollow">"java.lang.Integer.IntegerCache.high"</a> . <br><br><h2>  dans certains cas, les valeurs des champs statiques finaux primitifs ou de chaîne d'une autre classe sont résolues au moment de la compilation </h2><br>  Cela semble déroutant et la déclaration est un peu longue.  Le sens est le suivant.  Si nous avons une classe qui définit les constantes de types ou chaînes primitifs comme champs statiques finaux avec initialisation immédiate, <br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnotherClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CASE_1 = <span class="hljs-string"><span class="hljs-string">"case_1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> String CASE_2 = <span class="hljs-string"><span class="hljs-string">"case_2"</span></span>; }</code> </pre> <br>  lorsqu'il est utilisé dans d'autres classes, <pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TheClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... public static int getCaseNumber(String caseName) { switch (caseName) { case AnotherClass.CASE_1: return 1; case AnotherClass.CASE_2: return 2; default: throw new IllegalArgumentException("value of the argument caseName does not belong to the allowed value set"); } } }</span></span></code> </pre><br>  les valeurs de ces constantes ("case_1", "case_2") sont résolues au moment de la compilation.  Et ils sont insérés dans le code en tant que valeurs et non en tant que liens.  Autrement dit, si nous utilisons de telles constantes de la bibliothèque, puis que nous obtenons une nouvelle version de la bibliothèque dans laquelle les valeurs des constantes ont changé, nous devons recompiler le projet.  Sinon, les anciennes valeurs constantes peuvent continuer à être utilisées dans le code. <br><br>  Ce comportement est observé dans tous les endroits où des expressions constantes (par exemple, switch / case) doivent être utilisées, ou le compilateur est autorisé à convertir des expressions en constantes et il peut le faire. <br><br>  Ces champs ne peuvent pas être utilisés dans des expressions constantes dès que l'on supprime l'initialisation immédiate en transférant l'initialisation au bloc statique. <br><br><div class="spoiler">  <b class="spoiler_title">pour les débutants</b> <div class="spoiler_text"><h2>  Dans certaines conditions, le garbage collector peut ne jamais fonctionner. </h2><br>  Par conséquent, aucune finalize () ne sera lancée.  Par conséquent, vous ne devez pas écrire de code qui repose sur le fait que finalize () fonctionnera toujours.  Oui, et si l'objet est entré dans la poubelle avant la fin du programme, il ne sera probablement pas collecté par le collecteur. <br><br><h2>  La méthode finalize () pour un objet spécifique ne peut être appelée qu'une seule fois. </h2><br>  Dans finalize (), nous pouvons rendre l'objet visible à nouveau, et le garbage collector ne le "supprimera" pas cette fois.  Lorsque cet objet tombe à nouveau dans la poubelle, il sera "compilé" sans appeler finalize ().  Si une exception est levée dans finalize () et que l'objet n'est toujours visible par personne, il sera alors «assemblé».  Finalize () ne sera plus appelé. <br><br><h2>  le flux dans lequel finaliser () sera appelé n'est pas connu à l'avance </h2><br>  Il est seulement garanti que ce thread sera exempt de verrous visibles par le programme principal. <br><br><h2>  la présence d'une méthode finalize () surchargée sur les objets ralentit le processus de récupération de place </h2><br>  Ce qui se trouve à la surface est la nécessité de vérifier la disponibilité des objets - une fois avant d'appeler finalize (), une fois dans l'une des exécutions de récupération de place suivantes. <br><br><h2>  il est vraiment difficile de lutter contre les blocages lors de la finalisation () </h2><br>  Dans finalize () non trivial, des verrous peuvent être nécessaires, ce qui, étant donné les spécificités décrites ci-dessus, est très difficile à déboguer. <br><br><h2>  Object.finalize () puisque la version 9 de java est marquée comme obsolète! </h2><br>  Ce qui n'est pas surprenant, compte tenu des spécificités décrites ci-dessus. </div></div><br><h2>  initialisation de singleton paresseux classique: double verrouillage requis </h2><br>  Il y a une idée fausse sur ce sujet selon laquelle l'approche suivante (idiome à double vérification), qui semble très logique, fonctionne toujours: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnsafeDCLFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Singleton instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// read 1, check 1 synchronized (this) { if (instance == null) { // read 2, check 2 instance = new Singleton(); } } } return instance; // read 3 } }</span></span></code> </pre><br>  Nous regardons si l'objet est créé (lire 1, vérifier 1).  Si oui, retournez-le.  Sinon, définissez le verrou, assurez-vous que l'objet n'est pas créé, créez l'objet (le verrou est supprimé) et renvoyez l'objet. <br><br>  L'approche ne fonctionne pas pour les raisons suivantes.  <s>(lire 1, vérifier 1) et (lire 3) ne sont pas synchronisés.</s>  <s>Selon le concept du modèle de mémoire java, les modifications apportées dans un autre thread peuvent ne pas être visibles par notre thread tant que nous ne nous synchronisons pas.</s>  Merci <a href="https://habr.com/ru/users/mk2/" class="user_link">mk2</a> pour le commentaire, voici la description correcte du problème: <br><blockquote>  Oui, read1 et read3 ne sont pas synchronisés, mais le problème ne se trouve pas dans un autre thread.  Et le fait que les lectures non synchronisées puissent être réorganisées, c'est-à-dire  read1! = null, mais read3 == null.  Et en même temps, en raison de "instance = new Singleton ();" nous pouvons obtenir une référence à l'objet avant qu'il ne soit complètement construit, et c'est vraiment un problème de synchronisation avec un autre thread, mais pas read1 et read3, mais read3 et access aux membres d'instance. </blockquote>  Il est traité soit en ajoutant la synchronisation lors de la lecture, soit en marquant la variable dans laquelle vit le lien vers le singleton, volatile.  (La solution avec volatile ne fonctionne qu'avec java 5+. Avant cela, java avait un modèle de mémoire avec une incertitude dans cette situation.) Voici une version de travail (avec une optimisation supplémentaire - la variable locale `res` a été ajoutée pour réduire le nombre de lectures du champ volatile). <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SafeLocalDCLFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Singleton instance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Singleton </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Singleton res = instance; <span class="hljs-comment"><span class="hljs-comment">// read 1 if (res == null) { // check 1 synchronized (this) { res = instance; // read 2 if (res == null) { // check 2 res = new Singleton(); instance = res; } } } return res; } }</span></span></code> </pre><br>  Le code est tiré <a href="https://shipilev.net/blog/2014/safe-public-construction/" rel="nofollow">d'ici</a> , sur le site d'Alexei Shipilev.  Vous trouverez plus de détails sur ce problème. <br><br><h2>  "Initialisation à la demande idiome titulaire" - une très belle initialisation "paresseux" de singleton </h2><br>  java initialise les classes (objets Class) uniquement si nécessaire et, bien sûr, une seule fois.  Et vous pouvez en profiter!  C'est exactement ce que fait le mécanisme d'idiome du titulaire d'initialisation à la demande.  (Le code est <a href="https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom" rel="nofollow">d'ici</a> .) <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Something</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Something</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LazyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Something INSTANCE = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Something(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Something </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LazyHolder.INSTANCE; } }</code> </pre><br>  La classe LazyHolder ne sera initialisée que lors du premier appel de Something.getInstance ().  Jvm veillera à ce que cela ne se produise qu'une seule fois et, de plus, très efficacement - si la classe est déjà initialisée, il n'y aura pas de surcharge.  Par conséquent, LazyHolder.INSTANCE sera également initialisé une fois, "lazy" et thread-safe. <div class="spoiler">  <b class="spoiler_title">morceau de spécification sur les frais généraux</b> <div class="spoiler_text">  Si cette procédure d'initialisation se termine normalement et que l'objet Class est entièrement initialisé et prêt à être utilisé, alors l'appel de la procédure d'initialisation n'est plus nécessaire et peut être éliminé du code - par exemple, en le corrigeant ou en régénérant autrement le code . <br>  <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html" rel="nofollow">Source</a> </div></div><br>  D'une manière générale, les singletones ne sont pas considérés comme la meilleure pratique. <br><br>  Le matériel n'est pas fini.  Donc, si les mains «atteignent» et ce qui a déjà été écrit sera demandé, j'écrirai en quelque sorte davantage sur ce sujet. <br><br>  Merci pour les commentaires constructifs.  Plusieurs endroits de l'article ont été agrandis grâce à <a href="https://habr.com/ru/users/sergey-gornostaev/" class="user_link">sergey-gornostaev</a> , <a href="https://habr.com/ru/users/vladimir_dolzhenko/" class="user_link">vladimir_dolzhenko</a> , <a href="https://habr.com/ru/users/olehkurpiak/" class="user_link">OlehKurpiak</a> , <a href="https://habr.com/ru/users/mk2/" class="user_link">mk2</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr482950/">https://habr.com/ru/post/fr482950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr482940/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 396 (30 décembre 2019 - 5 janvier 2020)</a></li>
<li><a href="../fr482942/index.html">Mythes et légendes de l'ancien Fediverse</a></li>
<li><a href="../fr482944/index.html">Distributeur de convoyeur multi-composants</a></li>
<li><a href="../fr482946/index.html">1С DSS et estimation des conditions et coût des projets par la méthode COCOMO II</a></li>
<li><a href="../fr482948/index.html">"Un, deux, trois - brûlez le sapin de Noël!" Ou mon premier regard sur le petit contrôleur CANNY 3</a></li>
<li><a href="../fr482956/index.html">Examen de WCS 5.2 - Serveur WebRTC pour développeurs Webcast et Webcam</a></li>
<li><a href="../fr482958/index.html">"Règles de croissance: du junior au CTO", résumé d'un webinaire de Fedor Borshchev</a></li>
<li><a href="../fr482960/index.html">Présentation de WCS 5.2 - Serveur WebRTC pour les développeurs Web de diffusions en ligne et de chat vidéo</a></li>
<li><a href="../fr482968/index.html">Quarkus - Un nouveau regard sur Java Native Cloud</a></li>
<li><a href="../fr482970/index.html">Hack The Box - Procédure pas à pas. Nous creusons dans Git, exploitons les vulnérabilités de l'API, traitons avec Vault</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>