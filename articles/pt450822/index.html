<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚞 👒 👨‍👩‍👦 Estruturas desaparecendo 👳🏿 🔸 🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por que usamos estruturas? Angular, React e Vue nos ajudam a criar aplicativos da Web complexos: estruturar código, gerenciar estado e desenvolver int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estruturas desaparecendo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/450822/">  Por que usamos estruturas?  Angular, React e Vue nos ajudam a criar aplicativos da Web complexos: estruturar código, gerenciar estado e desenvolver interfaces complexas.  Na última década, as estruturas se tornaram o padrão.  Um padrão caro.  Desde que as estruturas entraram em uso, o JS ficou muito inchado.  Existem mais páginas com vários megabytes, e uma parte significativa desse volume é a própria estrutura.  Parece um pouco, mas para o usuário é fundamental - no telefone ou na Internet fraca a página pode nem carregar.  Isso é um problema. <br><br><img src="https://habrastorage.org/webt/l4/wd/k7/l4wdk7s_mctdg-p6ctwusbwiq7m.png"><br><br>  Além de estar acima do peso, as estruturas clássicas têm muitas outras desvantagens e não são adequadas para todos os projetos.  Esses problemas são resolvidos em "estruturas ameaçadas".  O que é essa nova tendência, por que não é “outra estrutura JS”, ​​mas uma boa idéia e como estruturas misteriosas podem melhorar nossas aplicações, Pavel Malyshev dirá. <br><a name="habracut"></a><br>  <b>Sobre o palestrante: Pavel Malyshev</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">PaulMaly</a> ) - pilha completa com mais de 10 anos de experiência.  Ele trabalha na Mustlab, que terceiriza a web, Smart TV e dispositivos móveis, além da Internet das Coisas.  Um evangelista da estrutura do Svelte JS na Rússia lidera um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grupo de telegramas</a> sobre esse tópico. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/NvNe4nKmZT0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  O que não deve estar no relatório </h2><br>  Quando considerei essa história, decidi que ela não deveria ser padrão.  Portanto, escrevi o que não deveria estar aqui.  Não haverá ênfase em uma estrutura específica, comparações com outras estruturas - elas estão cansadas de todos e, é claro, eu não quero ser o capitão Óbvio.  Tudo isso não deveria estar na minha história, mas, infelizmente, será ... <br><br>  Quando você leu o nome, provavelmente pensou que havia outra estrutura e já havia um zoológico inteiro. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/324/d9c/b9e324d9cd7205923e0805c009b820e5.png"><br><br>  Parece-me que, se um novo quadro aparecer, os antigos não satisfazem algumas de nossas necessidades.  Talvez as próprias necessidades mudem com o tempo, e é por isso que precisamos de novas soluções - mais eficazes e interessantes.  Portanto, peço que abordem o exposto a partir deste ponto de vista com uma mente aberta e olhem para os quadros que desaparecem como uma nova ferramenta que pode ajudar em seu trabalho. <br><br>  Para começar, vamos descobrir quem é quem. <br><br><h2>  Quem é quem </h2><br>  Peguei os três grandes e Svelte.  É interessante que cada ferramenta se caracterize de maneira diferente.  <b>A Angular se</b> posiciona como uma estrutura para todas as ocasiões, "tudo em uma caixa".  <b>O React</b> imita uma biblioteca: “Sou tão pequeno quanto uma biblioteca”, mas junto com toda a infraestrutura, é também uma estrutura completa.  <b>O Vue</b> é supostamente um quadro progressivo.  Você pode alternar para ele com o jQuery transferindo sequencialmente o código, começando quase com a tag de <code>script</code> usual sem coletores.  <b>Svelte</b> é uma estrutura que desaparece magicamente.  Wat? <br><br>  Vamos descobrir do que estou falando. <br><br><h2>  Por que as estruturas começaram a desaparecer? </h2><br><blockquote>  Estamos enviando muito código para nossos usuários. </blockquote><br>  Nossos clientes estão se tornando mais móveis, mas a tecnologia da Internet não é boa em todos os lugares - até o 3G não está em todo lugar, sem mencionar a LTE.  Precisamos reduzir o tamanho do código. <br><br>  Há um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estudo interessante a</a> partir de 2017 sobre esse tópico, que mostra que, se o seu aplicativo tiver muito JS, você poderá colocar apenas <b>130 Kb para deixar o usuário feliz</b> .  Se JS for pequeno, até 170Kb.  Essa diferença se deve ao fato de o estudo levar em consideração que o JS é diferente de outros tipos de recursos, que precisa ser analisado, interpretado e assim por diante. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b5/032/ec3/8b5032ec37fd48a2f95998759f41c5f9.png"><br><br>  No estudo, 130 Kb não é apenas JS, mas em geral tudo, incluindo CSS, HTML, é claro, sem imagens.  Ao mesmo tempo, um Angular pesa 143 Kb e nem sequer escrevemos uma única linha de código.  Vamos ver o que as soluções atuais nos oferecem. <br><br><h3>  Desempenho </h3><br>  Em princípio, qualquer estrutura clássica é uma abstração em uma plataforma que nos permite escrever em níveis mais convenientes.  Isso é ruim porque qualquer abstração tem alguns custos, incluindo desempenho. <br><br><blockquote>  Incorremos em custos adicionais devido a abstrações desnecessárias entre nosso código e o navegador. </blockquote><br>  O recurso das estruturas que desaparecem é que elas <b>removem abstrações e cálculos desnecessários do tempo de execução do navegador</b> , executando análises e cálculos no momento da compilação.  É por isso que eles desaparecem.  Falaremos sobre isso em mais detalhes abaixo. <br><br><h3>  Compatibilidade </h3><br><blockquote>  As soluções criadas para a estrutura clássica não podem ser aplicadas em lugar algum. </blockquote><br>  Eles funcionam apenas dentro da estrutura desta estrutura.  Por exemplo, você realiza 2 a 3 projetos em seu React favorito, escreve várias soluções interessantes e decide mudar para Angular.  Você não precisa mais dessas soluções; pode jogá-las fora.  Embora a ideia principal seja a correspondência de componentes, estruturas clássicas tornam impossível a reutilização de código. <br><br>  O problema de desaparecer estruturas é que elas <b>não têm abstrações</b> e, nesse caso, não há estruturas em tempo de execução.  Seu código é absolutamente baunilha JS, que pode ser levado para qualquer lugar - para qualquer projeto, mesmo em uma estrutura diferente.  Por exemplo, você pode pegar o código em uma estrutura que desaparece e transferi-lo para o React. <br><br><h3>  Divisão de código e agitação de árvore </h3><br><blockquote>  As tecnologias antigas dificultam a aplicação de novas tecnologias. </blockquote><br>  A maioria das estruturas foi criada quando essas tecnologias não eram tão desenvolvidas.  Temos um kernel bastante monolítico e qualquer componente, mesmo o menor pedaço do seu código, está vinculado a toda a estrutura.  Portanto, não é possível fazer a divisão de código de maneira eficaz e nem mesmo a trepidação de árvores. <br><br>  Agora, todas as estruturas estão evoluindo para uma maior modularidade, a fim de "agitar" melhor.  Nas estruturas que desaparecem, isso é resolvido imediatamente, porque elas são criadas de tal maneira que <b>somente o código necessário inicialmente é adicionado ao pacote</b> e resolve sua tarefa exclusivamente.  Este é um caso muito específico - como se você escrevesse o código com as mãos exatamente para a sua tarefa e o colocasse no pacote, apenas a estrutura fará isso por você. <br><br><h3>  Custo do recurso </h3><br><blockquote>  Qualquer estrutura tem um preço para um novo recurso. </blockquote><br>  A comunidade requer novos recursos diferentes e cada membro precisa de algo próprio, e qualquer recurso tem um preço.  Em estruturas que desaparecem, esse problema é resolvido no nível do conceito, porque qualquer recurso que você não usa nunca entra no seu pacote. <br>  Então, a principal questão: os quadros em desaparecimento, e especificamente o Svelte, podem resolver todos esses problemas?  Vamos acertar. <br><br><h2>  Bez com tempo de execução </h2><br>  Rantime é um tópico bastante efêmero.  Não está claro o que é, e pessoas diferentes entendem de maneira diferente.  Nesse contexto, falarei sobre tempo de execução do ponto de vista de dois aspectos: o <b>ambiente em que o código é executado</b> e <b>o próprio código</b> . <br><br><h3>  Tempo de execução como ambiente </h3><br>  Vejamos um exemplo.  Se o código estiver escrito no Vanilla, o único tempo de execução necessário será o DOM.  Se o código estiver escrito em React, você precisará de um tempo de execução diferente: DOM, React e React DOM. <br><br><blockquote>  Qualquer componente menor do seu código no React dependerá do ambiente em que sua estrutura trabalha, ou seja, no tempo de execução. </blockquote><br><br><h3>  Tempo de execução como execução de código </h3><br>  O segundo ponto é o tempo de execução em termos de execução de código em tempo de execução.  Vejamos o caso de tempo de execução básico de hoje para o frontend - o DOM virtual - uma grande parte do tempo de execução, por exemplo, nos aplicativos React - usando um exemplo simples: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {world}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Há uma variável dinâmica nesta parte do HTML.  Do ponto de vista do DOM virtual, o código funciona assim. <br><br><ul><li>  Esta variável está sendo modificada. <br></li><li>  A árvore DOM virtual na memória está sendo construída. <br></li><li>  Comparado com a versão anterior. <br></li><li>  As manipulações do DOM são executadas diretamente, o que no final é bastante eficaz, porque temos algum tipo de diferença e sabemos exatamente o que mudar no DOM real. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/12e/082/a7e/12e082a7e3f5e596d6251c22b4016046.png"><br><br><blockquote>  Um DOM virtual é uma sobrecarga absoluta, porque sempre será mais rápido assim: assim que as alterações ocorrerem, elas imediatamente farão alterações no DOM. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5f8/18a/d83/5f818ad83b71a697f3af30a4b747bdaf.png"><br><br>  Pergunta: como entender o que mudou e o que precisa ser mudado?  O DOM virtual resolve o problema do que mudou, não a velocidade dessas mudanças.  A velocidade é alcançada devido ao fato de sabermos o máximo possível o que mudou e podemos manipular efetivamente o DOM. <br><br><h2>  Compile </h2><br>  Para resolver esse problema, as estruturas que desaparecem simplesmente determinam as alterações no estágio de compilação: você escreveu o código, durante a compilação, a estrutura que desaparece cria todas as dependências, calcula quais manipulações no DOM são necessárias.  De fato, tudo o que um DOM virtual faz em tempo de execução, uma estrutura que desaparece em tempo de construção: gera manipulações diretas com o DOM, que são chamadas simplesmente durante o tempo de execução.  O resultado é um diagrama: quando fazemos alterações, a manipulação no DOM ocorre imediatamente. <br><br><blockquote>  Você não pode escrever aplicativos sérios em JavaScript vanilla sem atingir um muro de complexidade.  Mas um compilador pode fazer isso por você. <br>  <b>Rich Harris, criador de Svelte</b> </blockquote><br>  Vou lhe contar como conheci Svelte.  Tivemos um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto interessante</a> - um widget a ser inserido em um número ilimitado de sites, enquanto não sabemos quais são esses sites, em quais dispositivos o usuário os abrirá.  O widget deve ser muito pequeno em tamanho e muito rápido em velocidade.  Naturalmente, quando assumimos essa tarefa, imediatamente entendemos o que fazer no React ou mesmo no Vue não é uma opção, porque resulta em muita sobrecarga extra. <br><br>  Estávamos quase inclinados a escrever em baunilha, mas é difícil e nem sempre é conveniente mantê-lo.  Mas tivemos sorte - nos deparamos com Svelte.  A idéia principal dessa estrutura é dada em uma citação: você não pode escrever um aplicativo sério no Vanilla, porque encontrará rapidamente um muro de complexidade - será difícil para a equipe trabalhar, não há abordagens comuns e o compilador pode fazer isso por você. <br><br><h3>  Como isso funciona </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/822/0c9/463/8220c9463072b5a7aedd40185dfa8a70.png"><br><br>  <b>O código fonte é um código baseado em estrutura</b> - um código que depende da estrutura.  Tudo é como sempre: há alguma documentação, você escreve o código como se estivesse usando qualquer outra estrutura que possua algum tipo de API, princípios e abordagens.  Tudo está como sempre. <br><br>  No momento da compilação, esse código é compilado.  Como resultado, o vanilla JS está no pacote e, como eu disse, exatamente o código necessário para executar seu aplicativo chega lá.  Se em dois minutos você adicionar outra nova função ou usar um novo recurso da estrutura, o Svelte irá adicioná-la e também entrará no pacote.  Caso contrário, isso não acontecerá. <br><br>  Vamos considerar as etapas com mais detalhes.  O primeiro passo é o <b>componente</b> .  Considere o mesmo componente. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span>Hello {world}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Na segunda etapa - <b>AST</b> - o código é produzido em uma árvore de sintaxe abstrata. <br><br><pre> <code class="xml hljs">{"type": "Element", "name": "h1", "children": [{ "type": "Text", "data": "Hello",....}]}</code> </pre><br>  A terceira etapa é a <b>API</b> do <b>DOM</b> .  Com base na árvore, o código é gerado diretamente, o que é necessário para esse componente funcionar.  O código é muito simples, não há tempos de execução e abstrações complicados aqui em princípio. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">changed, ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (changed.name) { text_1.data = ctx.name; } }</code> </pre><br>  No final do artigo, indique na pesquisa se você gosta da ideia de compilação AOT da estrutura Svelte?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Na última vez, a</a> maioria falou positivamente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5aa/be9/d8e/5aabe9d8e0bd77fef1a1ed0e1844ac91.png"><br><br>  Agora vamos ver o que é Svelte. <br><br><h2>  Svelte </h2><br>  A palavra em inglês svelte ou svelt significa "magro, flexível".  JS Svelte é! <br><br>  Afirmo que esse não é "mais um framework JS" porque é um <b>framework de interface do usuário em tempo de construção</b> .  Estruturas regulares funcionam em tempo de execução, e o Svelte existe apenas antes de compilá-lo. <br><br>  Este é um <b>analisador estático em tempo de compilação</b> , ou um analisador de código estático que passa pelo código durante a compilação, o analisa estaticamente e, com base nisso, gera o pacote final correspondente. <br><br>  Este é um <b>compilador antecipado</b> - um compilador AOT que faz tudo. <br><br>  O criador da estrutura Rich Harris, que você pode conhecer em ferramentas como Rollup, Ractive, Buble - um análogo de Babel - é um cara legal.  Na minha opinião, o mesmo Rollup ainda é a melhor implementação de agitação de árvores.  Ele apareceu muito antes do Webpack e ainda funciona melhor.  A Harris originalmente construiu a estrutura Svelte com trepidação de árvores, divisão de código e outras abordagens modernas. <br><br><blockquote>  Svelte é uma ferramenta para escrever vanilla JS sem ter que escrever vanilla JS. </blockquote><br>  Vamos olhar para essa estrutura por dentro. <br><br><h3>  Componente de arquivo único </h3><br>  <b>Svelte é um componente de arquivo único</b> .  Se você trabalhou com o Vue, ele lembrará muito dessa estrutura, mas não é por acaso.  A sintaxe que o Vue usa principalmente é derivada da estrutura Ractive, que Harris também criou em 2012.  Infelizmente, essa estrutura não se tornou popular, porque me foi lançada na versão 1.0 tarde demais.  Eles estavam tão confusos com as versões que o Ractive esteve em versões menores por 6 anos. <br><br>  O Vue emprestou muitas interfaces de lá e Svelte é o sucessor do Ractive.  Portanto, parece que tudo é semelhante, mas os componentes de arquivo único apareceram no Ractive em 2013.  Eles parecem um pouco diferentes, mas no geral - parece.  Qualquer componente que você escreve no Svelte será algo parecido com isto. <br><br><pre> <code class="plaintext hljs">&lt;h1 &gt;Hello {world}!&lt;/h1 &gt; &lt;script&gt; export default { /* component behaviour */ }; &lt;/script&gt; &lt;style&gt;    /* scoped styles */ &lt;/style&gt;</code> </pre> <br>  Acima está um certo modelo HTML - HTML simples, sem exceções.  A única coisa em cima disso é uma certa linguagem de modelo chamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HTMLx</a> .  Eu vou falar mais sobre ele mais tarde. <br><br>  Em seguida, vem o script no qual escrevemos o comportamento do nosso componente.  Como escrevê-lo é descrito no guia.  Lá você pode importar, criar várias funções e métodos - tudo como no Vue. <br><br>  Você pode usar o estilo de escopo para obter estilos de componentes isolados da caixa.  Funciona assim: na compilação principal, um hash é gerado; como resultado, é como emular um DOM DOM. <br><br>  Nenhuma das seções é necessária, portanto, um componente pode consistir em apenas um HTML. <br><br><h3>  Sintaxe HTMLx </h3><br>  Como em qualquer HTML, os dados são escritos entre colchetes. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  É assim que as instruções condicionais são escritas. <br><br><pre> <code class="xml hljs">{#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if}</code> </pre> <br>  Enumerações e loops: <br><pre> <code class="xml hljs">{#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each}</code> </pre> <br>  Você pode usar diretivas para capturar eventos, para dupla ligação de dados. <br><br><pre> <code class="xml hljs">{#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name)"</span></span></span><span class="hljs-tag">&gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each}</code> </pre> <br>  Existem muito poucas diretivas no HTMLx - apenas 4-5 tipos e não há diretivas personalizadas, como no Angular. <br><br>  Você pode inserir quaisquer dados dinâmicos em qualquer atributo, não há problema com isso. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{dynamic}"</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"used"</span></span></span><span class="hljs-tag">&gt;</span></span> {#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name) "</span></span></span><span class="hljs-tag"> &gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3>  Estilos isolados e remoção de não utilizados </h3><br>  Se você usar estilos isolados, além de isolados, os estilos não utilizados também serão cortados automaticamente. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{dynamic}"</span></span></span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"used"</span></span></span><span class="hljs-tag">&gt;</span></span> {#each users as { name, email}} {#if name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"say(name) "</span></span></span><span class="hljs-tag"> &gt;</span></span>Say hello {name}<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> {/if} {/each} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> .used {...} .unused {...} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Se o estilo for <code>used</code> , ele será usado e, se o estilo <code>unused</code> for <code>unused</code> , ele não estará no pacote.  A estrutura cortará tudo, mas ordenadamente.  Portanto, esse recurso pode ser facilmente quebrado se você usar muita dinâmica.  Svelte pensará: "É melhor não tocar" - e sair.  É preciso ter cuidado, mas é muito conveniente.  Como o Svelte possui um analisador estático, ele mostra no console na inicialização quais estilos não são usados.  Se você realmente não precisar deles, poderá removê-los imediatamente. <br><br><h3>  Composição do componente </h3><br>  Tudo é como de costume aqui: importamos o arquivo, registramos nos componentes, usamos como tag. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Nested</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">foo</span></span></span><span class="hljs-tag">= </span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"static"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bar</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{dynamic}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">bind:baz</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">baz</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">import</span></span></span><span class="javascript"> Nested </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">from</span></span></span><span class="javascript"> </span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'Nested.html'</span></span></span><span class="javascript">;</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">' export default {   components: {Nested} }; </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Você pode transferir qualquer dado através dos atributos, use ligação dupla.  Ou não usar - a ligação dupla é opcional, pode até ser desativada no nível do compilador e não estará em nenhum outro lugar.  Isto é para aqueles que não gostam de ligações.  As ligações são obtidas usando a diretiva <code>bind:</code> <br><br><h3>  Recursos adicionais do Svelte </h3><br>  As duas primeiras possibilidades são: <b>SSR e hidratação</b> - renderização e hidratação do servidor e <b>gerenciamento de estado interno</b> - gerenciamento de estado global integrado com base em nossa própria solução, a chamada loja. <br><br>  Em princípio, você pode usar o Redux, o que muitos fazem: aqueles que estão acostumados ao Redux usam-no com o Svelte.  Mas há uma solução interna mais simples que é profundamente integrada, de modo que, se você a registra na loja, ela fica imediatamente disponível em todas as hierarquias de componentes - sem manipulações.  A única coisa a usar é usar o prefixo <code>$</code> , ou seja, todos os métodos ou dados de armazenamento são gravados com esse prefixo.  <code>$</code> pode ser usado em qualquer modelo. <br><br>  A loja possui um recurso interessante que eu nunca vi em nenhum outro lugar - ela se estende globalmente a uma hierarquia de componentes.  Se você, por exemplo, tiver um componente Raiz, ele será usado em toda essa hierarquia.  Se você tiver outra loja em algum lugar dentro dessa hierarquia, ela se estenderá a toda a hierarquia inferior. <br><br>  Isso é conveniente quando você deseja criar um componente grande e complexo com muitos subcomponentes e depois usá-lo em projetos diferentes, em alguns dos quais há Redux e outros não.  Se você usa armazenamentos regulares com o Redux, precisa garantir que o projeto em que você o adiciona tenha Redux.  Isso não precisa ser feito aqui - o Svelte implementa seu próprio repositório para essa hierarquia.  Ele pode ser facilmente transferido mesmo para os projetos em que não existe uma loja global.  Você trouxe e Svelte já está fazendo tudo por dentro. <br><br>  <b>Os elementos personalizados são suportados imediatamente</b> .  Há um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site especial</a> no qual o suporte é testado pelas estruturas do padrão Web Components.  De acordo com testes, o Svelte tem 100% de suporte para elementos personalizados.  Funciona assim: o nome da tag é especificado, o sinalizador “customElement: true” é definido no compilador e é gerado um elemento personalizado pronto para uso que suporta todos os recursos existentes do Svelte. <br><br>  <b>Sapper - Svelte app maker</b> .  Este é um análogo do Next.js e Nuxt.js para o Vue.  Em princípio, tudo é o mesmo: isomorfismo, suporte para divisão de código, pré-busca e off-line e outros recursos.  Na minha opinião, recentemente até algumas das idéias de roteamento vieram do Sapper para o Next.js. <br><br>  Mas nenhum Svelte faz isso.  Somos a favor da concorrência justa! <br><br><h2>  Quem mais </h2><br>  <b>Stencil</b> é uma estrutura de desenvolvedores Ionic.  Eles também trabalham em uma estrutura compilada, mas com grande foco em componentes da web e elementos personalizados.  O Svelte difere disso porque seus componentes geralmente são compilados em classes JS regulares e não há viés nos componentes da web. <br><br>  <b>Brilho</b> - acho que todo mundo conhece esse projeto.  Ele é apresentado aqui apenas porque também compila: ele possui seu próprio bytecode, sua própria máquina virtual, que obviamente fornece otimizações adicionais para o código final. <br><br>  <b>Marko do eBay</b> .  Eu não o estudei em detalhes, mas eles também compilam, sem saber o que é tão profundo quanto o Svelte.  É verdade que não entendi em detalhes e poderia estar errado. <br><br>  <b>Angular</b>  Há um compilador AOT aqui, e ele será bem promovido, mas é apenas uma recompilação de modelos de string em uma forma ordenada previamente.  Tanto quanto eu entendo, ainda não existe uma compilação completa do AoT. <br><br><h2>  Olá filmes </h2><br>  Eu escrevi um pequeno aplicativo - uma lista de filmes com filtros baseados na API TMDb.  Tem categorias: populares, mais votadas, próximas.  Você pode andar pelas páginas, selecionar um país, aplicar filtros, alterar o idioma.  Este aplicativo primitivo leva apenas 6,4 Kb. <br><br>  No total, HELLO MOVIES possui apenas 172 linhas de código, juntamente com HTML, das quais 36 linhas de código JS, além de todo tipo de aspas.  Este é todo o código que eu escrevi pessoalmente.  Naturalmente, tudo isso é compilado para um volume muito maior, mas para mim, como desenvolvedor, isso não importa. <br><br>  Mais alguns indicadores.  “TodoList MVC” no Svelte leva 3,6 Kb - depende de quem diz, mas mesmo no Vanilla leva 11 Kb, e no Vue e Reage ainda mais - 80 e 300 Kb, respectivamente.  O projeto "RealWorld", um clone do Medium, com registro, contas, curtidas, compartilhamentos, amigos - 40 Kb, no React e Angular - 211 e 575 Kb.  O clone de "HackerNews" no Svelte é de 30 Kb, no React e no Vue - várias vezes mais. <br><br><h2>  Benchmarks </h2><br>  Todos nós amamos hollichivat no tópico de benchmarks.  Eu usei o famoso benchmark <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Krausest</a> .  Você provavelmente acha que agora mostrarei os resultados em que Svelte apenas rasga todo mundo em pedaços, e Inferno apenas chora de lado.  Mas isso não vai acontecer. <br><br><img src="https://habrastorage.org/webt/3r/xz/4_/3rxz4_c2qbhoczgeo8yzr_kbg8s.jpeg"><br><br>  Fiz uma comparação do Svelte com os Big Three - Angular, React e Vue nas versões recentes.  Como resultado, ele identificou as duas primeiras posições em relação à Vanilla.  E aqui os números não são tão importantes quanto a idéia principal, que é que <b>Svelte é muito equilibrado</b> . <br><br>  O Svelte se esforça para ser equilibrado - <b>é bom em todos os aspectos em quaisquer benchmarks</b> .  De certa forma, Svelte até ultrapassa Vanilla, em algumas é a primeira, mas em algum lugar ultrapassa Vue e Angular.  No entanto, em todos os testes, Angular e Vue consomem muita memória, mas Svelte não.        ,    ,       .   — . <br><br>  Svelte     —    .  ,    . <br><br><h2> - —   ! </h2><br>  Svelte   New York Times.    . ,      Svelte, ,   legacy-  CMS,       .     ,     ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/080/9a3/6c8/0809a36c8b7f7d9d4eb9e18fe3d3bfa2.png"><br><br> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> -</a>   « » —  ,  Drag&amp;Drop.       Svelte,    . <br><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Soft-Gear</a>    ,     ,  Svelte.   ,         -     . <br><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">airca.st</a>    Svelte.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dabble</a>   Svelte.    -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">i-want-to-ride-an-electric-citi</a>        Svelte. <br><br>      . ,   RuTube.       Smart TV   Tizen,    Samsung.     Tizen  Smart TV     Svelte.      ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/46c/154/f5d/46c154f5d392f46698fb5a03e4234adc.png"><br><br><h2>   </h2><br><br> <b>  standalone vanilla JavaScript  </b> .     ,      ,  overhead . <br><br> <b>    </b> .  Svelte       DOM.    . <br><br> <b>  </b> .  ,     Vue,   Svelte  .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">REPL</a> ,         ,     . <br><br> <b>      </b> .   ,      —    ,         .       ,   . <br><br> <b>Code-splitting &amp; tree-shaking</b> .         code-splitting  tree-shaking.         .     ,          . <br><br> <b>Micro-frontends ready</b> .     -.      ,    ,        PHP,    Svelte-. ,      .      ,          .        code-splitting  tree-shaking. <br><br><h2>   </h2><br><br> <b>Svelte  ,   </b> .      2016 .          . <br><br> <b> </b> .  ,              .         . ,  ,   ,    ,     ,     Vue. <br><br> <b>  </b> .  React  Facebook, Angular — Google, Vue    ,      Rich Harris   ,            . <br><br><blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Frontend Conf</a>   ++      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,  ,    .   33       .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>              ++ 27  28 . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt450822/">https://habr.com/ru/post/pt450822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt450812/index.html">PSR-14 - o principal evento em PHP</a></li>
<li><a href="../pt450814/index.html">Como o BGP funciona</a></li>
<li><a href="../pt450816/index.html">Cabeçalhos HTTP para o desenvolvedor responsável</a></li>
<li><a href="../pt450818/index.html">Da alta latência do Ceph ao patch do kernel com o eBPF / BCC</a></li>
<li><a href="../pt450820/index.html">Comitê do programa FrontendConf: estruturas, horizontes, experiência mundial e missão da conferência</a></li>
<li><a href="../pt450824/index.html">O estado do css</a></li>
<li><a href="../pt450826/index.html">Como falar com o microcontrolador da JS</a></li>
<li><a href="../pt450828/index.html">Quando a cidade adormece ...</a></li>
<li><a href="../pt450830/index.html">Nikita Dubko sobre conferências, síndrome de impostor e relatórios</a></li>
<li><a href="../pt450832/index.html">A história de uma animação</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>