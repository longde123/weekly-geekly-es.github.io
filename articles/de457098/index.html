<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêú üë®üèΩ‚Äçü§ù‚Äçüë®üèº ‚úçÔ∏è Elegante JavaScript-Fehlerbehandlung mit der Entweder-Monade üöµüèæ ‚öóÔ∏è üõí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns ein wenig dar√ºber sprechen, wie wir mit Fehlern umgehen. In JavaScript verf√ºgen wir √ºber eine integrierte Sprachfunktion zum Arbeiten m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elegante JavaScript-Fehlerbehandlung mit der Entweder-Monade</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457098/"> Lassen Sie uns ein wenig dar√ºber sprechen, wie wir mit Fehlern umgehen.  In JavaScript verf√ºgen wir √ºber eine integrierte Sprachfunktion zum Arbeiten mit Ausnahmen.  Wir f√ºgen den problematischen Code in das Konstrukt <code>try...catch</code> .  Auf diese Weise k√∂nnen Sie im <code>try</code> Abschnitt einen normalen Ausf√ºhrungspfad angeben und dann alle Ausnahmen im <code>catch</code> Abschnitt behandeln.  Keine schlechte Option.  So k√∂nnen Sie sich auf die aktuelle Aufgabe konzentrieren, ohne √ºber jeden m√∂glichen Fehler nachzudenken.  Auf jeden Fall besser, als Ihren Code mit endlosen Wenns zu verstopfen. <br><br>  Ohne <code>try...catch</code> es schwierig, die Ergebnisse jedes Funktionsaufrufs auf unerwartete Werte zu √ºberpr√ºfen.  Dies ist ein n√ºtzliches Design.  Aber sie hat bestimmte Probleme.  Und dies ist nicht die einzige M√∂glichkeit, mit Fehlern umzugehen.  In diesem Artikel werden wir uns die Verwendung der <b>Entweder-Monade</b> als Alternative ansehen, um zu <code>try...catch</code> . <br><br>  Bevor ich fortfahre, stelle ich einige Punkte fest.  In dem Artikel wird davon ausgegangen, dass Sie bereits √ºber Funktionszusammensetzung und Currying Bescheid wissen.  Und eine Warnung.  Wenn Sie noch nie auf Monaden gesto√üen sind, k√∂nnen sie wirklich ... seltsam wirken.  Die Arbeit mit solchen Werkzeugen erfordert ein Umdenken.  Zuerst kann es schwer sein. <br><br>  Machen Sie sich keine Sorgen, wenn Sie sofort verwirrt sind.  Jeder hat es.  Am Ende des Artikels habe ich einige Links aufgelistet, die helfen k√∂nnten.  Gib nicht auf.  Diese Dinge werden berauscht, sobald sie das Gehirn durchdringen. <br><a name="habracut"></a><br><h1>  Problembeispiel </h1><br>  Bevor wir die Probleme von Ausnahmen diskutieren, lassen Sie uns dar√ºber sprechen, warum sie √ºberhaupt existieren und warum <code>try...catch</code> erschienen.  Schauen wir uns dazu ein Problem an, das ich zumindest teilweise realistisch machen wollte.  Stellen Sie sich vor, wir schreiben eine Funktion zum Anzeigen einer Liste von Benachrichtigungen.  Wir haben es (irgendwie) bereits geschafft, Daten vom Server zur√ºckzugeben.  Aus irgendeinem Grund haben die Backend-Ingenieure beschlossen, es im CSV-Format und nicht im JSON-Format zu senden.  Rohdaten k√∂nnten ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre>  Zeitstempel, Inhalt, angezeigt, href
 2018-10-27T05: 33: 34 + 00: 00, @ madhatter hat Sie zum Tee eingeladen, ungelesen, https: //example.com/invite/tea/3801
 2018-10-26T13: 47: 12 + 00: 00, @ Queenofhearts hat Sie in der Diskussion "Krocket-Turnier" erw√§hnt, angezeigt unter https: //example.com/discussions/croquet/1168
 2018-10-25T03: 50: 08 + 00: 00, @ cheshirecat hat Ihnen ein ungelesenes Grinsen geschickt, https: //example.com/interactions/grin/88 </pre><br>  Wir wollen es in HTML anzeigen.  Es k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MessageList"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/invite/tea/3801"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@madhatter invited you to tea<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-27T05:33:34+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>27 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/discussions/croquet/1168"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@queenofhearts mentioned you in 'Croquet Tournament' discussion<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-26T13:47:12+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>26 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/interactions/grin/88"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@cheshirecat sent you a grin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-25T03:50:08+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>25 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Um die Aufgabe zu vereinfachen, konzentrieren Sie sich vorerst nur auf die Verarbeitung jeder Zeile von CSV-Daten.  Beginnen wir mit einigen einfachen Funktionen zum Verarbeiten von Zeichenfolgen.  Die erste unterteilt die Textzeichenfolge in Felder: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> row.split(<span class="hljs-string"><span class="hljs-string">'","'</span></span>); }</code> </pre> <br>  Die Funktion wird hier vereinfacht, da es sich um Lehrmaterial handelt.  Wir besch√§ftigen uns mit der Fehlerbehandlung, nicht mit der CSV-Analyse.  Wenn eine der Nachrichten ein Komma enth√§lt, ist dies alles furchtbar falsch.  Bitte verwenden Sie diesen Code niemals, um echte CSV-Daten zu analysieren.  Wenn Sie jemals CSV-Daten analysieren mussten, verwenden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bew√§hrte CSV-Parsing-Bibliothek</a> . <br><br>  Nach dem Aufteilen der Daten m√∂chten wir ein Objekt erstellen.  Und damit jeder Eigenschaftsname mit den CSV-Headern √ºbereinstimmt.  Angenommen, wir haben die Titelleiste bereits irgendwie analysiert (dazu sp√§ter mehr).  Wir sind an einem Punkt angelangt, an dem etwas schief gehen kann.  Wir haben einen Fehler bei der Verarbeitung erhalten.  Wir werfen einen Fehler aus, wenn die L√§nge der Zeichenfolge nicht mit der Titelleiste √ºbereinstimmt.  ( <code>_.zipObject</code> ist <a href="">eine lodash-Funktion</a> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (headerFields.length !== fieldData.length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.zipObject(headerFields, fieldData); }</code> </pre> <br>  F√ºgen Sie danach dem Objekt ein f√ºr Menschen lesbares Datum hinzu, um es in unserer Vorlage anzuzeigen.  Es stellte sich als etwas ausf√ºhrlich heraus, da JavaScript keine perfekte integrierte Unterst√ºtzung f√ºr die Datumsformatierung bietet.  Und wieder stehen wir vor potenziellen Problemen.  Wenn ein ung√ºltiges Datum festgestellt wird, gibt unsere Funktion einen Fehler aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDateStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messageObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">'Unable to parse date stamp in message object'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'June'</span></span>, <span class="hljs-string"><span class="hljs-string">'July'</span></span>, <span class="hljs-string"><span class="hljs-string">'August'</span></span>, <span class="hljs-string"><span class="hljs-string">'September'</span></span>, <span class="hljs-string"><span class="hljs-string">'October'</span></span>, <span class="hljs-string"><span class="hljs-string">'November'</span></span>, <span class="hljs-string"><span class="hljs-string">'December'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(messageObj.datestamp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(d)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(errMsg); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datestr = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getDate()}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${months[d.getMonth()]}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getFullYear()}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {datestr, ...messageObj}; }</code> </pre> <br>  Nehmen Sie zum Schluss das Objekt und √ºbergeben Sie es <a href="">der Vorlagenfunktion</a> , um die HTML-Zeichenfolge abzurufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowToMessage = _.template(<span class="hljs-string"><span class="hljs-string">`&lt;li class="Message Message--&lt;%= viewed %&gt;"&gt; &lt;a href="&lt;%= href %&gt;" class="Message-link"&gt;&lt;%= content %&gt;&lt;/a&gt; &lt;time datetime="&lt;%= datestamp %&gt;"&gt;&lt;%= datestr %&gt;&lt;/time&gt; &lt;li&gt;`</span></span>);</code> </pre> <br>  Es w√§re auch sch√∂n, einen Fehler auszudrucken, wenn er erf√ºllt w√§re: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showError = _.template(<span class="hljs-string"><span class="hljs-string">`&lt;li class="Error"&gt;&lt;%= message %&gt;&lt;/li&gt;`</span></span>);</code> </pre> <br>  Wenn alles vorhanden ist, k√∂nnen Sie eine Funktion zusammenstellen, um jede Zeile zu verarbeiten. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(e); } }</code> </pre> <br>  Damit ist die Funktion fertig.  Schauen wir uns genauer an, wie Ausnahmen behandelt werden. <br><br><h1>  Ausnahmen: der gute Teil </h1><br>  Also, was ist gut daran, zu <code>try...catch</code> ?  Es ist zu beachten, dass im obigen Beispiel jeder der Schritte im <code>try</code> Block einen Fehler verursachen kann.  In <code>zipRow()</code> und <code>addDateStr()</code> werfen wir absichtlich Fehler aus.  Und wenn ein Problem auftritt, fangen Sie einfach den Fehler ab und zeigen Sie eine Meldung auf der Seite an.  Ohne diesen Mechanismus wird der Code wirklich h√§sslich.  So k√∂nnte es aussehen.  Angenommen, die Funktionen werfen keine Fehler aus, sondern geben <code>null</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowWithoutExceptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObj === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Encountered a row with an unexpected number of items'</span></span>)); } rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObjWithDate === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unable to parse date in row object'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); }</code> </pre> <br>  Wie Sie sehen k√∂nnen, eine gro√üe Anzahl von Vorlagen, <code>if</code> .  Der Code ist ausf√ºhrlicher.  Und es ist schwer, der Grundlogik zu folgen.  Au√üerdem sagt uns <code>null</code> nicht viel.  Wir wissen nicht genau, warum der vorherige Funktionsaufruf fehlgeschlagen ist.  Wir m√ºssen raten.  Wir erstellen eine Fehlermeldung und rufen <code>showError()</code> .  Ein solcher Code ist schmutziger und verwirrender. <br><br>  Schauen Sie sich noch einmal die Version zur Ausnahmebehandlung an.  Der erfolgreiche Pfad des Programms und der Code f√ºr die Ausnahmebehandlung werden klar voneinander getrennt.  Der <code>try</code> Zweig ist ein guter Weg, und der <code>catch</code> Zweig ist ein Fehler.  Die gesamte Ausnahmebehandlung erfolgt an einem Ort.  Und einzelne Funktionen k√∂nnen melden, warum sie fehlgeschlagen sind.  Alles in allem scheint das ziemlich s√º√ü.  Ich denke, dass die Mehrheit das erste Beispiel f√ºr durchaus geeignet h√§lt.  Warum ein anderer Ansatz? <br><br><h1>  Probleme beim Umgang mit Ausnahmen versuchen ... fangen </h1><br>  Mit diesem Ansatz k√∂nnen Sie diese l√§stigen Fehler ignorieren.  Leider <code>try...catch</code> macht seinen Job zu gut.  Sie werfen einfach eine Ausnahme und fahren fort.  Wir k√∂nnen ihn sp√§ter fangen.  Und jeder hat wirklich vor, immer solche Bl√∂cke zu setzen.  Es ist jedoch nicht immer offensichtlich, wo der Fehler weitergeht.  Und der Block ist zu leicht zu vergessen.  Und bevor Sie dies bemerken, st√ºrzt Ihre Anwendung ab. <br><br>  Au√üerdem verschmutzen Ausnahmen den Code.  Wir werden hier nicht im Detail auf funktionale Reinheit eingehen.  Aber schauen wir uns einen kleinen Aspekt der funktionalen Reinheit an: referentielle Transparenz.  Eine linktransparente Funktion gibt f√ºr eine bestimmte Eingabe immer das gleiche Ergebnis zur√ºck.  Aber f√ºr Funktionen mit Ausnahmen k√∂nnen wir das nicht sagen.  Sie k√∂nnen jederzeit eine Ausnahme ausl√∂sen, anstatt einen Wert zur√ºckzugeben.  Dies verkompliziert die Logik.  Aber was ist, wenn Sie eine Win-Win-Option finden - eine saubere M√∂glichkeit, mit Fehlern umzugehen? <br><br><h1>  Wir haben eine Alternative gefunden </h1><br>  Reine Funktionen geben immer einen Wert zur√ºck (auch wenn dieser Wert fehlt).  Daher sollte unser Fehlerbehandlungscode davon ausgehen, dass wir immer einen Wert zur√ºckgeben.  Was soll ich also als ersten Versuch tun, wenn wir bei einem Fehler ein Fehlerobjekt zur√ºckgeben?  Das hei√üt, wo immer wir einen Fehler machen, geben wir ein solches Objekt zur√ºck.  Es k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowReturningErrors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(rowObj); } rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObjWithDate <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(rowObjWithDate); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); }</code> </pre> <br>  Dies ist ausnahmslos kein spezielles Upgrade.  Aber es ist besser.  Wir haben die Verantwortung f√ºr Fehlermeldungen wieder auf einzelne Funktionen √ºbertragen.  Aber wir haben immer noch all diese Wenns.  Es w√§re sch√∂n, die Vorlage irgendwie zu kapseln.  Mit anderen Worten, wenn wir wissen, dass wir einen Fehler haben, machen Sie sich keine Sorgen um den Rest des Codes. <br><br><h1>  Polymorphismus </h1><br>  Wie kann man das machen?  Dies ist ein schwieriges Problem.  Aber es kann mit Hilfe der Magie des <i>Polymorphismus</i> gel√∂st werden.  Machen Sie sich keine Sorgen, wenn Sie noch nie auf Polymorphismus gesto√üen sind.  Im Wesentlichen handelt es sich um ‚Äûeine einzige Schnittstelle f√ºr Entit√§ten unterschiedlicher Typen‚Äú (Straustrup, B. ‚ÄûC ++ - Glossar von Bj√∂rn Straustrup‚Äú).  In JavaScript bedeutet dies, dass wir Objekte mit denselben benannten Methoden und Signaturen erstellen.  Aber anderes Verhalten.  Ein klassisches Beispiel ist die Anwendungsprotokollierung.  Wir k√∂nnen unsere Magazine je nach Umgebung an verschiedene Orte senden.  Was ist, wenn wir zum Beispiel zwei Logger-Objekte erstellen? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> consoleLogger = { <span class="hljs-attr"><span class="hljs-attr">log</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'This is the console logger, logging:'</span></span>, msg); } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ajaxLogger = { <span class="hljs-attr"><span class="hljs-attr">log</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'https://example.com/logger'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: msg}); } };</code> </pre> <br>  Beide Objekte definieren eine Protokollfunktion, die einen einzelnen Zeichenfolgenparameter erwartet.  Aber sie verhalten sich anders.  Das Sch√∂ne ist, dass wir Code schreiben k√∂nnen, der <code>.log()</code> , unabh√§ngig davon, welches Objekt verwendet wird.  Es kann <code>consoleLogger</code> oder <code>ajaxLogger</code> .  Alles funktioniert trotzdem.  Der folgende Code funktioniert beispielsweise mit jedem Objekt gleich gut: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">logger, message</span></span></span><span class="hljs-function">) </span></span>{ logger.log(message); }</code> </pre> <br>  Ein weiteres Beispiel ist die <code>.toString()</code> -Methode f√ºr alle JS-Objekte.  Wir k√∂nnen die <code>.toString()</code> -Methode f√ºr jede Klasse schreiben, die wir erstellen.  Als N√§chstes k√∂nnen Sie zwei Klassen erstellen, die die Methode <code>.toString()</code> unterschiedlich implementieren.  Wir werden sie <code>Left</code> und <code>Right</code> benennen (etwas sp√§ter werde ich die Namen erkl√§ren). <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Left(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Erstellen Sie nun eine Funktion, die <code>.toString()</code> f√ºr diese beiden Objekte aufruft: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } trace(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚¶ò Left(Hello world) trace(new Right('Hello world')); // ‚¶ò Right(Hello world);</span></span></code> </pre> <br>  Kein herausragender Code, ich wei√ü.  Tatsache ist jedoch, dass wir zwei verschiedene Verhaltensweisen haben, die dieselbe Schnittstelle verwenden.  Das ist Polymorphismus.  Aber achten Sie auf etwas Interessantes.  Wie viele if-Anweisungen haben wir verwendet?  Null  Keiner.  Wir haben zwei verschiedene Verhaltensweisen ohne eine einzige if-Anweisung erstellt.  Vielleicht kann so etwas verwendet werden, um Fehler zu behandeln ... <br><br><h1>  Links und rechts </h1><br>  Zur√ºck zu unserem Problem.  Es ist notwendig, den erfolgreichen und erfolglosen Pfad f√ºr unseren Code zu bestimmen.  Auf einem guten Weg f√ºhren wir den Code einfach ruhig weiter aus, bis ein Fehler auftritt oder wir ihn beenden.  Wenn wir uns auf dem falschen Weg befinden, werden wir nicht l√§nger versuchen, den Code auszuf√ºhren.  Wir k√∂nnten diese Pfade Happy und Sad nennen, aber versuchen, die Namenskonventionen zu befolgen, die andere Programmiersprachen und Bibliotheken verwenden.  Nennen wir also den schlechten Weg links und den erfolgreichen - rechts. <br><br>  Lassen Sie uns eine Methode erstellen, die die Funktion ausf√ºhrt, wenn wir uns auf einem guten Pfad befinden, sie jedoch auf einem schlechten Pfad ignorieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } runFunctionOnlyOnHappyPath() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path. Do nothing } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } runFunctionOnlyOnHappyPath(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  So etwas wie das: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> leftHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rightHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); leftHello.runFunctionOnlyOnHappyPath(trace); <span class="hljs-comment"><span class="hljs-comment">// does nothing rightHello.runFunctionOnlyOnHappyPath(trace); // ‚¶ò Hello world // Ôø© "Hello world"</span></span></code> </pre> <br><h4>  Sendung </h4><br>  Wir n√§hern uns etwas N√ºtzlichem, aber noch nicht ganz.  Unsere <code>.runFunctionOnlyOnHappyPath()</code> -Methode gibt die <code>_val</code> Eigenschaft zur√ºck.  Alles ist in Ordnung, aber zu unpraktisch, wenn wir mehr als eine Funktion ausf√ºhren m√∂chten.  Warum?  Weil wir nicht mehr wissen, ob wir auf dem richtigen oder dem falschen Weg sind.  Informationen verschwinden, sobald wir den Wert au√üerhalb von Links und Rechts annehmen.  Wir k√∂nnen also den linken oder rechten Pfad mit dem neuen <code>_val</code> .  Und wir werden den Namen verk√ºrzen, da wir hier sind.  Wir √ºbersetzen eine Funktion aus der Welt der einfachen Werte in die Welt der Linken und Rechten.  Deshalb rufen wir die <code>map()</code> -Methode auf: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Wir f√ºgen diese Methode ein und verwenden Links oder Rechts in der freien Syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> leftHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rightHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloToGreetings = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/Hello/</span></span>, <span class="hljs-string"><span class="hljs-string">'Greetings,'</span></span>); leftHello.map(helloToGreetings).map(trace); <span class="hljs-comment"><span class="hljs-comment">// Doesn't print any thing to the console // Ôø© Left(Hello world) rightHello.map(helloToGreetings).map(trace); // ‚¶ò Greetings, world // Ôø© Right(Greetings, world)</span></span></code> </pre> <br>  Wir haben zwei Ausf√ºhrungspfade erstellt.  Wir k√∂nnen die Daten auf einen erfolgreichen Pfad setzen, indem wir <code>new Right()</code> aufrufen, oder auf einen fehlgeschlagenen Pfad, indem wir <code>new Left()</code> aufrufen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36a/2ee/cf6/36a2eecf61c554e388c5723b0b5cbd02.svg"><br>  <i><font color="gray">Jede Klasse repr√§sentiert einen Pfad: erfolgreich oder erfolglos.</font></i>  <i><font color="gray">Ich habe diese Eisenbahnmetapher von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scott Vlaschina</a> gestohlen</font></i> <br><br>  Wenn die <code>map</code> auf einem guten Pfad funktioniert hat, gehen Sie diesen entlang und verarbeiten Sie die Daten.  Wenn wir keinen Erfolg haben, wird nichts passieren.  √úbergeben Sie den Wert einfach weiter.  Wenn wir zum Beispiel Fehler auf diesen erfolglosen Pfad setzen, erhalten wir etwas sehr √Ñhnliches, <code>try‚Ä¶catch</code> zu <code>try‚Ä¶catch</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17c/3e6/09d/17c3e609d306efc1bee111077456b9ab.svg"><br>  <i><font color="gray">Verwenden Sie <code>.map()</code> , um sich entlang des Pfads zu bewegen</font></i> <br><br>  Im weiteren Verlauf wird es immer schwieriger, Links oder Rechts zu schreiben. Nennen wir diese Kombination also einfach Entweder (‚Äûentweder‚Äú).  Entweder links oder rechts. <br><br><h4>  Verkn√ºpfungen zum Erstellen von Objekten </h4><br>  Der n√§chste Schritt besteht also darin, unsere Beispielfunktionen so umzuschreiben, dass sie entweder zur√ºckgeben.  Links f√ºr Fehler oder rechts f√ºr Wert.  Aber bevor wir das tun, haben Sie Spa√ü.  Schreiben wir ein paar Abk√ºrzungen.  Die erste ist eine statische Methode namens <code>.of()</code> .  Es wird nur ein neues Links oder Rechts zur√ºckgegeben.  Der Code k√∂nnte folgenderma√üen aussehen: <br><br><pre> <code class="javascript hljs">Left.of = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(x); }; Right.of = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(x); };</code> </pre> <br>  Ehrlich gesagt ist sogar <code>Left.of()</code> und <code>Right.of()</code> m√ºhsam zu schreiben.  Also neige ich zu noch k√ºrzeren <code>left()</code> und <code>right()</code> Labels: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">left</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Left.of(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Right.of(x); }</code> </pre> <br>  Mit diesen Verkn√ºpfungen beginnen wir, die Anwendungsfunktionen neu zu schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lengthMatch = (headerFields.length == fieldData.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!lengthMatch) ? left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>)) : right(_.zipObject(headerFields, fieldData)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDateStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messageObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">'Unable to parse date stamp in message object'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'June'</span></span>, <span class="hljs-string"><span class="hljs-string">'July'</span></span>, <span class="hljs-string"><span class="hljs-string">'August'</span></span>, <span class="hljs-string"><span class="hljs-string">'September'</span></span>, <span class="hljs-string"><span class="hljs-string">'October'</span></span>, <span class="hljs-string"><span class="hljs-string">'November'</span></span>, <span class="hljs-string"><span class="hljs-string">'December'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(messageObj.datestamp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(d)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(errMsg)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datestr = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getDate()}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${months[d.getMonth()]}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getFullYear()}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right({datestr, ...messageObj}); }</code> </pre> <br>  Ge√§nderte Funktionen unterscheiden sich nicht so sehr von den alten.  Wir setzen den R√ºckgabewert einfach entweder in Links oder Rechts, je nachdem, ob ein Fehler vorliegt. <br><br>  Danach k√∂nnen wir mit der Verarbeitung der Hauptfunktion beginnen, die eine Zeile verarbeitet.  <code>splitFields</code> Sie zun√§chst die Zeichenfolge mit <code>right()</code> in Entweder ein und √ºbersetzen <code>splitFields</code> dann <code>splitFields</code> , um sie zu teilen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶ }</span></span></code> </pre> <br>  Dies funktioniert <code>zipRow()</code> , aber das <code>zipRow()</code> , wenn Sie versuchen, dasselbe mit <code>zipRow()</code> zu tun: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow <span class="hljs-comment"><span class="hljs-comment">/* wait. this isn't right */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Tatsache ist, dass <code>zipRow()</code> zwei Parameter erwartet.  Die Funktionen, die wir an <code>.map()</code> erhalten jedoch nur einen Wert aus der Eigenschaft <code>._val</code> .  Die Situation kann mit der <code>zipRow()</code> Version von <code>zipRow()</code> korrigiert werden.  Es k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRowWithHeaderFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lengthMatch = (headerFields.length == fieldData.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!lengthMatch) ? left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>)) : right(_.zipObject(headerFields, fieldData)); }; }</code> </pre> <br>  Diese kleine √Ñnderung vereinfacht die Konvertierung von <code>zipRow</code> , sodass sie mit <code>.map()</code> gut <code>.map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow(headerFields)); <span class="hljs-comment"><span class="hljs-comment">// ... But now we have another problem ... }</span></span></code> </pre> <br><h4>  Mitmachen </h4><br>  Die Verwendung von <code>.map()</code> zum Ausf√ºhren von <code>splitFields()</code> ist in Ordnung, da <code>.splitFields()</code> auch nicht <code>.splitFields()</code> .  Wenn Sie jedoch <code>zipRow()</code> ausf√ºhren <code>zipRow()</code> , tritt ein Problem auf, da es entweder zur√ºckgibt.  Wenn wir also <code>.map()</code> verwenden, <code>.map()</code> wir in <code>.map()</code> entweder.  Wenn wir weiter gehen, bleiben Sie stecken, bis wir <code>.map()</code> in <code>.map()</code> .  Das wird auch nicht funktionieren.  Wir brauchen eine M√∂glichkeit, diese verschachtelten Entweder zu kombinieren.  Schreiben wir also eine neue Methode, die wir <code>.join()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } join() { // On the sad path, we don't // do anything with join return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } join() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) || (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Right)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Jetzt k√∂nnen wir unser Verm√∂gen ‚Äûauspacken‚Äú: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow(headerFields)).join(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.map(addDateStr).join(); <span class="hljs-comment"><span class="hljs-comment">// Slowly getting better... but what do we return? }</span></span></code> </pre> <br><h4>  Kette </h4><br>  Wir haben einen langen Weg zur√ºckgelegt.  Aber Sie m√ºssen sich die <code>.join()</code> Zeit an den Aufruf von <code>.join()</code> erinnern, was √§rgerlich ist.  Wir haben jedoch ein gemeinsames aufeinanderfolgendes <code>.map()</code> und <code>.join()</code> . Erstellen wir also eine Schnellzugriffsmethode daf√ºr.  Nennen wir es <code>chain()</code> , weil es Funktionen miteinander verbindet, die Left oder Right zur√ºckgeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } join() { // On the sad path, we don't // do anything with join return this; } chain() { // Boring sad path, // do nothing. return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } join() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) || (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Right)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } chain(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Zur√ºck zur Eisenbahnanalogie: <code>.chain()</code> wechselt die Schienen, wenn ein Fehler <code>.chain()</code> .  Es ist jedoch einfacher, auf dem Diagramm zu zeigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1bc/279/530/1bc2795304c211004070da858179fcfc.svg"><br>  <i><font color="gray">Wenn ein Fehler auftritt, k√∂nnen Sie mit der .chain () -Methode zum linken Pfad wechseln.</font></i>  <i><font color="gray">Bitte beachten Sie, dass die Schalter nur in eine Richtung funktionieren.</font></i> <br><br>  Der Code wurde etwas sauberer: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.chain(zipRow(headerFields)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.chain(addDateStr); <span class="hljs-comment"><span class="hljs-comment">// Slowly getting better... but what do we return? }</span></span></code> </pre> <br><h4>  Mach etwas mit Werten </h4><br>  Das Refactoring der <code>processRow()</code> -Funktion ist fast abgeschlossen.  Aber was passiert, wenn wir den Wert zur√ºckgeben?  Am Ende wollen wir verschiedene Ma√ünahmen ergreifen, je nachdem, in welcher Situation wir uns befinden: Links oder Rechts.  Daher werden wir eine Funktion schreiben, die geeignete Ma√ünahmen ergreift: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">either</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leftFunc, rightFunc, e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) ? leftFunc(e._val) : rightFunc(e._val); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe betrogen und die internen Werte von linken oder rechten Objekten verwendet. </font><font style="vertical-align: inherit;">Aber tun Sie so, als h√§tten Sie das nicht bemerkt. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir unsere Funktion erf√ºllen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.chain(zipRow(headerFields)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.chain(addDateStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, rowToMessage, rowObjWithDate); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wenn wir uns besonders schlau f√ºhlen, k√∂nnen wir wieder die freie Syntax verwenden: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = right(row) .map(splitFields) .chain(zipRow(headerFields)) .chain(addDateStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, rowToMessage, rowObjWithDate); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Versionen sind ziemlich h√ºbsch. </font><font style="vertical-align: inherit;">Keine Designs </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und keine if-Anweisungen in der Top-Level-Funktion. </font><font style="vertical-align: inherit;">Wenn es ein Problem mit einer bestimmten Zeile gibt, wird am Ende einfach eine Fehlermeldung angezeigt. </font><font style="vertical-align: inherit;">Und beachten Sie, dass </font></font><code>processRow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir links oder rechts das einzige Mal ganz am Anfang erw√§hnen, wenn wir anrufen </font></font><code>right()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Rest sind nur Methoden </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>.chain()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">f√ºr die n√§chste Funktion.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ap und heben </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht gut aus, aber es bleibt noch ein letztes Szenario zu betrachten. </font><font style="vertical-align: inherit;">Lassen Sie uns anhand unseres Beispiels sehen, wie alle CSV-Daten und nicht nur jede Zeile einzeln verarbeitet werden k√∂nnen. </font><font style="vertical-align: inherit;">Wir ben√∂tigen eine oder drei Hilfsfunktionen (Helfer):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitCSVToRows</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// There should always be a header row... so if there's no // newline character, something is wrong. return (csvData.indexOf('\n') &lt; 0) ? left('No header row found in CSV data') : right(csvData.split('\n')); } function processRows(headerFields, dataRows) { // Note this is Array map, not Either map. return dataRows.map(row =&gt; processRow(headerFields, row)); } function showMessages(messages) { return `&lt;ul class="Messages"&gt;${messages.join('\n')}&lt;/ul&gt;`; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also einen Helfer, der CSV in Zeilen aufteilt. </font><font style="vertical-align: inherit;">Und wir kehren mit Entweder zu der Option zur√ºck. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen Sie </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einige lodash-Funktionen verwenden, um die Titelleiste aus Datenzeilen zu extrahieren. </font><font style="vertical-align: inherit;">Aber wir befinden uns in einer interessanten Situation ...</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-comment"><span class="hljs-comment">// What's next? }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Header-Felder und Datenzeilen zur Anzeige bereit </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch </font></font><code>dataRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Entweder eingewickelt. </font><font style="vertical-align: inherit;">Wir brauchen eine M√∂glichkeit, </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine Funktion </font><font style="vertical-align: inherit;">zu konvertieren </font><font style="vertical-align: inherit;">, die mit Entweder funktioniert. </font><font style="vertical-align: inherit;">Zu Beginn f√ºhren wir Currying durch </font></font><code>processRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRows</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowsWithHeaderFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dataRows</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Note this is Array map, not Either map. return dataRows.map(row =&gt; processRow(headerFields, row)); }; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist alles bereit f√ºr das Experiment. Wir haben </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entweder ein Array umwickelt. Was passiert , </font><font style="vertical-align: inherit;">wenn wir nehmen </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und fordern ihn </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-comment"><span class="hljs-comment">// How will we pass headerFields and dataRows to // processRows() ? const funcInEither = headerFields.map(processRows); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit .map () wird hier eine externe Funktion aufgerufen </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber keine interne. </font><font style="vertical-align: inherit;">Mit anderen Worten, </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt eine Funktion zur√ºck. </font><font style="vertical-align: inherit;">Und seitdem </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekommen wir entweder noch zur√ºck. </font><font style="vertical-align: inherit;">Das Ergebnis ist also eine Funktion in Entweder, die aufgerufen wird </font></font><code>funcInEither</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es nimmt ein Array von Zeichenfolgen und gibt ein Array anderer Zeichenfolgen zur√ºck. </font><font style="vertical-align: inherit;">Wir m√ºssen diese Funktion irgendwie √ºbernehmen und sie mit einem Wert im Inneren aufrufen </font></font><code>dataRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">F√ºgen Sie dazu unseren Klassen Links und Rechts eine weitere Methode hinzu. </font><font style="vertical-align: inherit;">Wir werden es </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in √úbereinstimmung mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard nennen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie √ºblich macht die Methode nichts auf der linken Spur:</font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// In Left (the sad path) ap() { return this; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und f√ºr die richtige Klasse erwarten wir ein weiteres Entweder mit einer Funktion: </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// In Right (the happy path) ap(otherEither) { const functionToRun = otherEither._val; return this.map(functionToRun); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt k√∂nnen wir unsere Hauptfunktion erf√ºllen: </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> funcInEither = headerFields.map(processRows); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messagesArr = dataRows.ap(funcInEither); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, showMessages, messagesArr); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wesentliche der Methode wird </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sofort ein wenig verstanden (die Spezifikationen von Fantasy Land verwirren es, aber in den meisten anderen Sprachen wird die Methode umgekehrt verwendet). Wenn Sie es einfacher beschreiben, sagen Sie: ‚ÄûIch habe eine Funktion, die normalerweise zwei einfache Werte annimmt. Ich m√∂chte daraus eine Funktion machen, die entweder zwei ben√∂tigt. " Wenn verf√ºgbar, k√∂nnen </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir eine Funktion schreiben, die genau das tut. Nennen wir es </font></font><code>liftA2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wieder in √úbereinstimmung mit dem Standardnamen. Sie nimmt eine einfache Funktion, die zwei Argumente erwartet, und "hebt" sie auf, um mit "Applikativen" zu arbeiten. (Dies sind Objekte, die sowohl eine Methode </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als auch eine Methode enthalten. </font></font><code>.of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) LiftA2 ist also die Abk√ºrzung f√ºr "Applicative Lift, zwei Parameter". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Funktion </font></font><code>liftA2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnte also ungef√§hr so ‚Äã‚Äãaussehen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">liftA2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runApplicativeFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.ap(a.map(func)); }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unsere Top-Level-Funktion wird es wie folgt verwenden: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processRowsA = liftA2(processRows); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messagesArr = processRowsA(headerFields, dataRows); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, showMessages, messagesArr); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code auf CodePen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1>  Richtig?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das ist alles? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie fragen sich vielleicht, was ist besser als einfache Ausnahmen? </font><font style="vertical-align: inherit;">Scheint es mir nicht zu kompliziert, ein einfaches Problem zu l√∂sen? </font><font style="vertical-align: inherit;">Lassen Sie uns zun√§chst dar√ºber nachdenken, warum wir Ausnahmen m√∂gen. </font><font style="vertical-align: inherit;">Wenn es keine Ausnahmen g√§be, m√ºssten Sie √ºberall viele if-Anweisungen schreiben. </font><font style="vertical-align: inherit;">Wir werden immer Code nach dem Prinzip schreiben: "Wenn letzteres funktioniert, fahren Sie fort, andernfalls verarbeiten Sie den Fehler." </font><font style="vertical-align: inherit;">Und wir m√ºssen diese Fehler im gesamten Code behandeln. </font><font style="vertical-align: inherit;">Dies macht es schwierig zu verstehen, was passiert. </font><font style="vertical-align: inherit;">Mit Ausnahmen k√∂nnen Sie das Programm beenden, wenn ein Fehler aufgetreten ist. </font><font style="vertical-align: inherit;">Daher m√ºssen Sie nicht alle diese ifs schreiben. </font><font style="vertical-align: inherit;">Sie k√∂nnen sich auf einen erfolgreichen Ausf√ºhrungspfad konzentrieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber es gibt einen Haken. Ausnahmen verbergen zu viel. Wenn Sie eine Ausnahme ausl√∂sen, √ºbertragen Sie das Fehlerbehandlungsproblem auf eine andere Funktion. Es ist zu einfach, eine Ausnahme zu ignorieren, die auf der h√∂chsten Ebene angezeigt wird. Das Sch√∂ne an beiden ist, dass Sie wie mit einer Ausnahme aus dem Hauptprogramm-Stream springen k√∂nnen. Und es funktioniert ehrlich. Sie erhalten entweder rechts oder links. Sie k√∂nnen nicht so tun, als w√§re die Option Links unm√∂glich. Am Ende m√ºssen Sie den Wert mit einem Aufruf wie herausziehen </font></font><code>either()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich wei√ü, es klingt nach einer Art Komplexit√§t. Aber schauen Sie sich den Code an, den wir geschrieben haben (keine Klassen, sondern Funktionen, die sie verwenden). Es gibt nicht viel Code f√ºr die Ausnahmebehandlung. Es fehlt fast, mit Ausnahme eines Anrufs </font></font><code>either()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende </font></font><code>csvToMessages()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>processRow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das ist der springende Punkt. </font><font style="vertical-align: inherit;">Mit Entweder haben Sie eine saubere Fehlerbehandlung, die nicht versehentlich vergessen werden kann. </font><font style="vertical-align: inherit;">Stempeln Sie ohne Beides den Code durch und f√ºgen Sie √ºberall Polster hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet nicht, dass Sie es niemals verwenden sollten </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Manchmal ist es das richtige Werkzeug und es ist normal. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht das einzige Werkzeug. </font><font style="vertical-align: inherit;">Entweder gibt Ihnen einige Vorteile, die Sie nicht haben </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Geben Sie dieser Monade eine Chance. </font><font style="vertical-align: inherit;">Auch wenn es zun√§chst schwierig ist, denke ich, dass es Ihnen gefallen wird. </font><font style="vertical-align: inherit;">Bitte, bitte verwenden Sie nicht die Implementierung aus diesem Artikel. </font><font style="vertical-align: inherit;">Probieren Sie eine der ber√ºhmten Bibliotheken wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crocks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sanctuary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folktale</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie sind besser bedient. </font><font style="vertical-align: inherit;">Und hier habe ich der Einfachheit halber etwas verpasst.</font></font><br><br><blockquote><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zus√§tzliche Ressourcen </font></font></h1><br><ul><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">       </a> ¬ª, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Fantasy Land</a> <br></li><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    JavaScript: Either</a> ¬ª, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> <br></li><li> ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  JavaScript: </a> ¬ª, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457098/">https://habr.com/ru/post/de457098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457086/index.html">Architekturmuster "Builder" im Universum von "Swift" und "iOS" / "macOS"</a></li>
<li><a href="../de457090/index.html">Sicherheitskrippen: JWT</a></li>
<li><a href="../de457092/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Ger√§tezugriff. Teil 5</a></li>
<li><a href="../de457094/index.html">Excel-Add-In, mit dem Filter bei der Arbeit mit Cubes (VBA) einfach festgelegt werden k√∂nnen</a></li>
<li><a href="../de457096/index.html">Wir geben mehreren Analysten die Hand: API Livy zur Automatisierung typischer Bankaufgaben</a></li>
<li><a href="../de457100/index.html">AWS Lambda - Theorie, Bekanntschaft</a></li>
<li><a href="../de457102/index.html">QVD-Dateien - was ist drin, Teil 3</a></li>
<li><a href="../de457106/index.html">Der US-Robo-Call-Krieg - wer gewinnt und warum</a></li>
<li><a href="../de457108/index.html">WWDC19: Erste Schritte mit dem Testplan f√ºr XCTest</a></li>
<li><a href="../de457110/index.html">Unit-Test von C ++ - und Mock-Injection-Mustern unter Verwendung von Merkmalen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>