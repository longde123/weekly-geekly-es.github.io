<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐜 👨🏽‍🤝‍👨🏼 ✍️ Elegante JavaScript-Fehlerbehandlung mit der Entweder-Monade 🚵🏾 ⚗️ 🛒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lassen Sie uns ein wenig darüber sprechen, wie wir mit Fehlern umgehen. In JavaScript verfügen wir über eine integrierte Sprachfunktion zum Arbeiten m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Elegante JavaScript-Fehlerbehandlung mit der Entweder-Monade</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457098/"> Lassen Sie uns ein wenig darüber sprechen, wie wir mit Fehlern umgehen.  In JavaScript verfügen wir über eine integrierte Sprachfunktion zum Arbeiten mit Ausnahmen.  Wir fügen den problematischen Code in das Konstrukt <code>try...catch</code> .  Auf diese Weise können Sie im <code>try</code> Abschnitt einen normalen Ausführungspfad angeben und dann alle Ausnahmen im <code>catch</code> Abschnitt behandeln.  Keine schlechte Option.  So können Sie sich auf die aktuelle Aufgabe konzentrieren, ohne über jeden möglichen Fehler nachzudenken.  Auf jeden Fall besser, als Ihren Code mit endlosen Wenns zu verstopfen. <br><br>  Ohne <code>try...catch</code> es schwierig, die Ergebnisse jedes Funktionsaufrufs auf unerwartete Werte zu überprüfen.  Dies ist ein nützliches Design.  Aber sie hat bestimmte Probleme.  Und dies ist nicht die einzige Möglichkeit, mit Fehlern umzugehen.  In diesem Artikel werden wir uns die Verwendung der <b>Entweder-Monade</b> als Alternative ansehen, um zu <code>try...catch</code> . <br><br>  Bevor ich fortfahre, stelle ich einige Punkte fest.  In dem Artikel wird davon ausgegangen, dass Sie bereits über Funktionszusammensetzung und Currying Bescheid wissen.  Und eine Warnung.  Wenn Sie noch nie auf Monaden gestoßen sind, können sie wirklich ... seltsam wirken.  Die Arbeit mit solchen Werkzeugen erfordert ein Umdenken.  Zuerst kann es schwer sein. <br><br>  Machen Sie sich keine Sorgen, wenn Sie sofort verwirrt sind.  Jeder hat es.  Am Ende des Artikels habe ich einige Links aufgelistet, die helfen könnten.  Gib nicht auf.  Diese Dinge werden berauscht, sobald sie das Gehirn durchdringen. <br><a name="habracut"></a><br><h1>  Problembeispiel </h1><br>  Bevor wir die Probleme von Ausnahmen diskutieren, lassen Sie uns darüber sprechen, warum sie überhaupt existieren und warum <code>try...catch</code> erschienen.  Schauen wir uns dazu ein Problem an, das ich zumindest teilweise realistisch machen wollte.  Stellen Sie sich vor, wir schreiben eine Funktion zum Anzeigen einer Liste von Benachrichtigungen.  Wir haben es (irgendwie) bereits geschafft, Daten vom Server zurückzugeben.  Aus irgendeinem Grund haben die Backend-Ingenieure beschlossen, es im CSV-Format und nicht im JSON-Format zu senden.  Rohdaten könnten ungefähr so ​​aussehen: <br><br><pre>  Zeitstempel, Inhalt, angezeigt, href
 2018-10-27T05: 33: 34 + 00: 00, @ madhatter hat Sie zum Tee eingeladen, ungelesen, https: //example.com/invite/tea/3801
 2018-10-26T13: 47: 12 + 00: 00, @ Queenofhearts hat Sie in der Diskussion "Krocket-Turnier" erwähnt, angezeigt unter https: //example.com/discussions/croquet/1168
 2018-10-25T03: 50: 08 + 00: 00, @ cheshirecat hat Ihnen ein ungelesenes Grinsen geschickt, https: //example.com/interactions/grin/88 </pre><br>  Wir wollen es in HTML anzeigen.  Es könnte ungefähr so ​​aussehen: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"MessageList"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/invite/tea/3801"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@madhatter invited you to tea<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-27T05:33:34+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>27 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/discussions/croquet/1168"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@queenofhearts mentioned you in 'Croquet Tournament' discussion<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-26T13:47:12+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>26 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message Message--viewed"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://example.com/interactions/grin/88"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Message-link"</span></span></span><span class="hljs-tag">&gt;</span></span>@cheshirecat sent you a grin<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">datetime</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2018-10-25T03:50:08+00:00"</span></span></span><span class="hljs-tag">&gt;</span></span>25 October 2018<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">time</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Um die Aufgabe zu vereinfachen, konzentrieren Sie sich vorerst nur auf die Verarbeitung jeder Zeile von CSV-Daten.  Beginnen wir mit einigen einfachen Funktionen zum Verarbeiten von Zeichenfolgen.  Die erste unterteilt die Textzeichenfolge in Felder: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> row.split(<span class="hljs-string"><span class="hljs-string">'","'</span></span>); }</code> </pre> <br>  Die Funktion wird hier vereinfacht, da es sich um Lehrmaterial handelt.  Wir beschäftigen uns mit der Fehlerbehandlung, nicht mit der CSV-Analyse.  Wenn eine der Nachrichten ein Komma enthält, ist dies alles furchtbar falsch.  Bitte verwenden Sie diesen Code niemals, um echte CSV-Daten zu analysieren.  Wenn Sie jemals CSV-Daten analysieren mussten, verwenden Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">bewährte CSV-Parsing-Bibliothek</a> . <br><br>  Nach dem Aufteilen der Daten möchten wir ein Objekt erstellen.  Und damit jeder Eigenschaftsname mit den CSV-Headern übereinstimmt.  Angenommen, wir haben die Titelleiste bereits irgendwie analysiert (dazu später mehr).  Wir sind an einem Punkt angelangt, an dem etwas schief gehen kann.  Wir haben einen Fehler bei der Verarbeitung erhalten.  Wir werfen einen Fehler aus, wenn die Länge der Zeichenfolge nicht mit der Titelleiste übereinstimmt.  ( <code>_.zipObject</code> ist <a href="">eine lodash-Funktion</a> ). <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (headerFields.length !== fieldData.length) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.zipObject(headerFields, fieldData); }</code> </pre> <br>  Fügen Sie danach dem Objekt ein für Menschen lesbares Datum hinzu, um es in unserer Vorlage anzuzeigen.  Es stellte sich als etwas ausführlich heraus, da JavaScript keine perfekte integrierte Unterstützung für die Datumsformatierung bietet.  Und wieder stehen wir vor potenziellen Problemen.  Wenn ein ungültiges Datum festgestellt wird, gibt unsere Funktion einen Fehler aus. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDateStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messageObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">'Unable to parse date stamp in message object'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'June'</span></span>, <span class="hljs-string"><span class="hljs-string">'July'</span></span>, <span class="hljs-string"><span class="hljs-string">'August'</span></span>, <span class="hljs-string"><span class="hljs-string">'September'</span></span>, <span class="hljs-string"><span class="hljs-string">'October'</span></span>, <span class="hljs-string"><span class="hljs-string">'November'</span></span>, <span class="hljs-string"><span class="hljs-string">'December'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(messageObj.datestamp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(d)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(errMsg); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datestr = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getDate()}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${months[d.getMonth()]}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getFullYear()}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {datestr, ...messageObj}; }</code> </pre> <br>  Nehmen Sie zum Schluss das Objekt und übergeben Sie es <a href="">der Vorlagenfunktion</a> , um die HTML-Zeichenfolge abzurufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowToMessage = _.template(<span class="hljs-string"><span class="hljs-string">`&lt;li class="Message Message--&lt;%= viewed %&gt;"&gt; &lt;a href="&lt;%= href %&gt;" class="Message-link"&gt;&lt;%= content %&gt;&lt;/a&gt; &lt;time datetime="&lt;%= datestamp %&gt;"&gt;&lt;%= datestr %&gt;&lt;/time&gt; &lt;li&gt;`</span></span>);</code> </pre> <br>  Es wäre auch schön, einen Fehler auszudrucken, wenn er erfüllt wäre: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showError = _.template(<span class="hljs-string"><span class="hljs-string">`&lt;li class="Error"&gt;&lt;%= message %&gt;&lt;/li&gt;`</span></span>);</code> </pre> <br>  Wenn alles vorhanden ist, können Sie eine Funktion zusammenstellen, um jede Zeile zu verarbeiten. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(e); } }</code> </pre> <br>  Damit ist die Funktion fertig.  Schauen wir uns genauer an, wie Ausnahmen behandelt werden. <br><br><h1>  Ausnahmen: der gute Teil </h1><br>  Also, was ist gut daran, zu <code>try...catch</code> ?  Es ist zu beachten, dass im obigen Beispiel jeder der Schritte im <code>try</code> Block einen Fehler verursachen kann.  In <code>zipRow()</code> und <code>addDateStr()</code> werfen wir absichtlich Fehler aus.  Und wenn ein Problem auftritt, fangen Sie einfach den Fehler ab und zeigen Sie eine Meldung auf der Seite an.  Ohne diesen Mechanismus wird der Code wirklich hässlich.  So könnte es aussehen.  Angenommen, die Funktionen werfen keine Fehler aus, sondern geben <code>null</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowWithoutExceptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObj === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Encountered a row with an unexpected number of items'</span></span>)); } rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObjWithDate === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Unable to parse date in row object'</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); }</code> </pre> <br>  Wie Sie sehen können, eine große Anzahl von Vorlagen, <code>if</code> .  Der Code ist ausführlicher.  Und es ist schwer, der Grundlogik zu folgen.  Außerdem sagt uns <code>null</code> nicht viel.  Wir wissen nicht genau, warum der vorherige Funktionsaufruf fehlgeschlagen ist.  Wir müssen raten.  Wir erstellen eine Fehlermeldung und rufen <code>showError()</code> .  Ein solcher Code ist schmutziger und verwirrender. <br><br>  Schauen Sie sich noch einmal die Version zur Ausnahmebehandlung an.  Der erfolgreiche Pfad des Programms und der Code für die Ausnahmebehandlung werden klar voneinander getrennt.  Der <code>try</code> Zweig ist ein guter Weg, und der <code>catch</code> Zweig ist ein Fehler.  Die gesamte Ausnahmebehandlung erfolgt an einem Ort.  Und einzelne Funktionen können melden, warum sie fehlgeschlagen sind.  Alles in allem scheint das ziemlich süß.  Ich denke, dass die Mehrheit das erste Beispiel für durchaus geeignet hält.  Warum ein anderer Ansatz? <br><br><h1>  Probleme beim Umgang mit Ausnahmen versuchen ... fangen </h1><br>  Mit diesem Ansatz können Sie diese lästigen Fehler ignorieren.  Leider <code>try...catch</code> macht seinen Job zu gut.  Sie werfen einfach eine Ausnahme und fahren fort.  Wir können ihn später fangen.  Und jeder hat wirklich vor, immer solche Blöcke zu setzen.  Es ist jedoch nicht immer offensichtlich, wo der Fehler weitergeht.  Und der Block ist zu leicht zu vergessen.  Und bevor Sie dies bemerken, stürzt Ihre Anwendung ab. <br><br>  Außerdem verschmutzen Ausnahmen den Code.  Wir werden hier nicht im Detail auf funktionale Reinheit eingehen.  Aber schauen wir uns einen kleinen Aspekt der funktionalen Reinheit an: referentielle Transparenz.  Eine linktransparente Funktion gibt für eine bestimmte Eingabe immer das gleiche Ergebnis zurück.  Aber für Funktionen mit Ausnahmen können wir das nicht sagen.  Sie können jederzeit eine Ausnahme auslösen, anstatt einen Wert zurückzugeben.  Dies verkompliziert die Logik.  Aber was ist, wenn Sie eine Win-Win-Option finden - eine saubere Möglichkeit, mit Fehlern umzugehen? <br><br><h1>  Wir haben eine Alternative gefunden </h1><br>  Reine Funktionen geben immer einen Wert zurück (auch wenn dieser Wert fehlt).  Daher sollte unser Fehlerbehandlungscode davon ausgehen, dass wir immer einen Wert zurückgeben.  Was soll ich also als ersten Versuch tun, wenn wir bei einem Fehler ein Fehlerobjekt zurückgeben?  Das heißt, wo immer wir einen Fehler machen, geben wir ein solches Objekt zurück.  Es könnte ungefähr so ​​aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowReturningErrors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFieldNames, row</span></span></span><span class="hljs-function">) </span></span>{ fields = splitFields(row); rowObj = zipRow(headerFieldNames, fields); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(rowObj); } rowObjWithDate = addDateStr(rowObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rowObjWithDate <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> showError(rowObjWithDate); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rowToMessage(rowObj); }</code> </pre> <br>  Dies ist ausnahmslos kein spezielles Upgrade.  Aber es ist besser.  Wir haben die Verantwortung für Fehlermeldungen wieder auf einzelne Funktionen übertragen.  Aber wir haben immer noch all diese Wenns.  Es wäre schön, die Vorlage irgendwie zu kapseln.  Mit anderen Worten, wenn wir wissen, dass wir einen Fehler haben, machen Sie sich keine Sorgen um den Rest des Codes. <br><br><h1>  Polymorphismus </h1><br>  Wie kann man das machen?  Dies ist ein schwieriges Problem.  Aber es kann mit Hilfe der Magie des <i>Polymorphismus</i> gelöst werden.  Machen Sie sich keine Sorgen, wenn Sie noch nie auf Polymorphismus gestoßen sind.  Im Wesentlichen handelt es sich um „eine einzige Schnittstelle für Entitäten unterschiedlicher Typen“ (Straustrup, B. „C ++ - Glossar von Björn Straustrup“).  In JavaScript bedeutet dies, dass wir Objekte mit denselben benannten Methoden und Signaturen erstellen.  Aber anderes Verhalten.  Ein klassisches Beispiel ist die Anwendungsprotokollierung.  Wir können unsere Magazine je nach Umgebung an verschiedene Orte senden.  Was ist, wenn wir zum Beispiel zwei Logger-Objekte erstellen? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> consoleLogger = { <span class="hljs-attr"><span class="hljs-attr">log</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'This is the console logger, logging:'</span></span>, msg); } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ajaxLogger = { <span class="hljs-attr"><span class="hljs-attr">log</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'https://example.com/logger'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: msg}); } };</code> </pre> <br>  Beide Objekte definieren eine Protokollfunktion, die einen einzelnen Zeichenfolgenparameter erwartet.  Aber sie verhalten sich anders.  Das Schöne ist, dass wir Code schreiben können, der <code>.log()</code> , unabhängig davon, welches Objekt verwendet wird.  Es kann <code>consoleLogger</code> oder <code>ajaxLogger</code> .  Alles funktioniert trotzdem.  Der folgende Code funktioniert beispielsweise mit jedem Objekt gleich gut: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">logger, message</span></span></span><span class="hljs-function">) </span></span>{ logger.log(message); }</code> </pre> <br>  Ein weiteres Beispiel ist die <code>.toString()</code> -Methode für alle JS-Objekte.  Wir können die <code>.toString()</code> -Methode für jede Klasse schreiben, die wir erstellen.  Als Nächstes können Sie zwei Klassen erstellen, die die Methode <code>.toString()</code> unterschiedlich implementieren.  Wir werden sie <code>Left</code> und <code>Right</code> benennen (etwas später werde ich die Namen erklären). <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Left(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Erstellen Sie nun eine Funktion, die <code>.toString()</code> für diese beiden Objekte aufruft: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val.toString()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } trace(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ⦘ Left(Hello world) trace(new Right('Hello world')); // ⦘ Right(Hello world);</span></span></code> </pre> <br>  Kein herausragender Code, ich weiß.  Tatsache ist jedoch, dass wir zwei verschiedene Verhaltensweisen haben, die dieselbe Schnittstelle verwenden.  Das ist Polymorphismus.  Aber achten Sie auf etwas Interessantes.  Wie viele if-Anweisungen haben wir verwendet?  Null  Keiner.  Wir haben zwei verschiedene Verhaltensweisen ohne eine einzige if-Anweisung erstellt.  Vielleicht kann so etwas verwendet werden, um Fehler zu behandeln ... <br><br><h1>  Links und rechts </h1><br>  Zurück zu unserem Problem.  Es ist notwendig, den erfolgreichen und erfolglosen Pfad für unseren Code zu bestimmen.  Auf einem guten Weg führen wir den Code einfach ruhig weiter aus, bis ein Fehler auftritt oder wir ihn beenden.  Wenn wir uns auf dem falschen Weg befinden, werden wir nicht länger versuchen, den Code auszuführen.  Wir könnten diese Pfade Happy und Sad nennen, aber versuchen, die Namenskonventionen zu befolgen, die andere Programmiersprachen und Bibliotheken verwenden.  Nennen wir also den schlechten Weg links und den erfolgreichen - rechts. <br><br>  Lassen Sie uns eine Methode erstellen, die die Funktion ausführt, wenn wir uns auf einem guten Pfad befinden, sie jedoch auf einem schlechten Pfad ignorieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } runFunctionOnlyOnHappyPath() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path. Do nothing } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } runFunctionOnlyOnHappyPath(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  So etwas wie das: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> leftHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rightHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); leftHello.runFunctionOnlyOnHappyPath(trace); <span class="hljs-comment"><span class="hljs-comment">// does nothing rightHello.runFunctionOnlyOnHappyPath(trace); // ⦘ Hello world // ￩ "Hello world"</span></span></code> </pre> <br><h4>  Sendung </h4><br>  Wir nähern uns etwas Nützlichem, aber noch nicht ganz.  Unsere <code>.runFunctionOnlyOnHappyPath()</code> -Methode gibt die <code>_val</code> Eigenschaft zurück.  Alles ist in Ordnung, aber zu unpraktisch, wenn wir mehr als eine Funktion ausführen möchten.  Warum?  Weil wir nicht mehr wissen, ob wir auf dem richtigen oder dem falschen Weg sind.  Informationen verschwinden, sobald wir den Wert außerhalb von Links und Rechts annehmen.  Wir können also den linken oder rechten Pfad mit dem neuen <code>_val</code> .  Und wir werden den Namen verkürzen, da wir hier sind.  Wir übersetzen eine Funktion aus der Welt der einfachen Werte in die Welt der Linken und Rechten.  Deshalb rufen wir die <code>map()</code> -Methode auf: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Wir fügen diese Methode ein und verwenden Links oder Rechts in der freien Syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> leftHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rightHello = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(<span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> helloToGreetings = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function"> =&gt;</span></span> str.replace(<span class="hljs-regexp"><span class="hljs-regexp">/Hello/</span></span>, <span class="hljs-string"><span class="hljs-string">'Greetings,'</span></span>); leftHello.map(helloToGreetings).map(trace); <span class="hljs-comment"><span class="hljs-comment">// Doesn't print any thing to the console // ￩ Left(Hello world) rightHello.map(helloToGreetings).map(trace); // ⦘ Greetings, world // ￩ Right(Greetings, world)</span></span></code> </pre> <br>  Wir haben zwei Ausführungspfade erstellt.  Wir können die Daten auf einen erfolgreichen Pfad setzen, indem wir <code>new Right()</code> aufrufen, oder auf einen fehlgeschlagenen Pfad, indem wir <code>new Left()</code> aufrufen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/36a/2ee/cf6/36a2eecf61c554e388c5723b0b5cbd02.svg"><br>  <i><font color="gray">Jede Klasse repräsentiert einen Pfad: erfolgreich oder erfolglos.</font></i>  <i><font color="gray">Ich habe diese Eisenbahnmetapher von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scott Vlaschina</a> gestohlen</font></i> <br><br>  Wenn die <code>map</code> auf einem guten Pfad funktioniert hat, gehen Sie diesen entlang und verarbeiten Sie die Daten.  Wenn wir keinen Erfolg haben, wird nichts passieren.  Übergeben Sie den Wert einfach weiter.  Wenn wir zum Beispiel Fehler auf diesen erfolglosen Pfad setzen, erhalten wir etwas sehr Ähnliches, <code>try…catch</code> zu <code>try…catch</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17c/3e6/09d/17c3e609d306efc1bee111077456b9ab.svg"><br>  <i><font color="gray">Verwenden Sie <code>.map()</code> , um sich entlang des Pfads zu bewegen</font></i> <br><br>  Im weiteren Verlauf wird es immer schwieriger, Links oder Rechts zu schreiben. Nennen wir diese Kombination also einfach Entweder („entweder“).  Entweder links oder rechts. <br><br><h4>  Verknüpfungen zum Erstellen von Objekten </h4><br>  Der nächste Schritt besteht also darin, unsere Beispielfunktionen so umzuschreiben, dass sie entweder zurückgeben.  Links für Fehler oder rechts für Wert.  Aber bevor wir das tun, haben Sie Spaß.  Schreiben wir ein paar Abkürzungen.  Die erste ist eine statische Methode namens <code>.of()</code> .  Es wird nur ein neues Links oder Rechts zurückgegeben.  Der Code könnte folgendermaßen aussehen: <br><br><pre> <code class="javascript hljs">Left.of = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Left(x); }; Right.of = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right(x); };</code> </pre> <br>  Ehrlich gesagt ist sogar <code>Left.of()</code> und <code>Right.of()</code> mühsam zu schreiben.  Also neige ich zu noch kürzeren <code>left()</code> und <code>right()</code> Labels: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">left</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Left.of(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">right</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Right.of(x); }</code> </pre> <br>  Mit diesen Verknüpfungen beginnen wir, die Anwendungsfunktionen neu zu schreiben: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lengthMatch = (headerFields.length == fieldData.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!lengthMatch) ? left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>)) : right(_.zipObject(headerFields, fieldData)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addDateStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">messageObj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> errMsg = <span class="hljs-string"><span class="hljs-string">'Unable to parse date stamp in message object'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> months = [ <span class="hljs-string"><span class="hljs-string">'January'</span></span>, <span class="hljs-string"><span class="hljs-string">'February'</span></span>, <span class="hljs-string"><span class="hljs-string">'March'</span></span>, <span class="hljs-string"><span class="hljs-string">'April'</span></span>, <span class="hljs-string"><span class="hljs-string">'May'</span></span>, <span class="hljs-string"><span class="hljs-string">'June'</span></span>, <span class="hljs-string"><span class="hljs-string">'July'</span></span>, <span class="hljs-string"><span class="hljs-string">'August'</span></span>, <span class="hljs-string"><span class="hljs-string">'September'</span></span>, <span class="hljs-string"><span class="hljs-string">'October'</span></span>, <span class="hljs-string"><span class="hljs-string">'November'</span></span>, <span class="hljs-string"><span class="hljs-string">'December'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(messageObj.datestamp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(d)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(errMsg)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> datestr = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getDate()}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${months[d.getMonth()]}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${d.getFullYear()}</span></span></span><span class="hljs-string">`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right({datestr, ...messageObj}); }</code> </pre> <br>  Geänderte Funktionen unterscheiden sich nicht so sehr von den alten.  Wir setzen den Rückgabewert einfach entweder in Links oder Rechts, je nachdem, ob ein Fehler vorliegt. <br><br>  Danach können wir mit der Verarbeitung der Hauptfunktion beginnen, die eine Zeile verarbeitet.  <code>splitFields</code> Sie zunächst die Zeichenfolge mit <code>right()</code> in Entweder ein und übersetzen <code>splitFields</code> dann <code>splitFields</code> , um sie zu teilen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-comment"><span class="hljs-comment">// … }</span></span></code> </pre> <br>  Dies funktioniert <code>zipRow()</code> , aber das <code>zipRow()</code> , wenn Sie versuchen, dasselbe mit <code>zipRow()</code> zu tun: <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow <span class="hljs-comment"><span class="hljs-comment">/* wait. this isn't right */</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Tatsache ist, dass <code>zipRow()</code> zwei Parameter erwartet.  Die Funktionen, die wir an <code>.map()</code> erhalten jedoch nur einen Wert aus der Eigenschaft <code>._val</code> .  Die Situation kann mit der <code>zipRow()</code> Version von <code>zipRow()</code> korrigiert werden.  Es könnte ungefähr so ​​aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zipRowWithHeaderFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fieldData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> lengthMatch = (headerFields.length == fieldData.length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (!lengthMatch) ? left(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Row has an unexpected number of fields"</span></span>)) : right(_.zipObject(headerFields, fieldData)); }; }</code> </pre> <br>  Diese kleine Änderung vereinfacht die Konvertierung von <code>zipRow</code> , sodass sie mit <code>.map()</code> gut <code>.map()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow(headerFields)); <span class="hljs-comment"><span class="hljs-comment">// ... But now we have another problem ... }</span></span></code> </pre> <br><h4>  Mitmachen </h4><br>  Die Verwendung von <code>.map()</code> zum Ausführen von <code>splitFields()</code> ist in Ordnung, da <code>.splitFields()</code> auch nicht <code>.splitFields()</code> .  Wenn Sie jedoch <code>zipRow()</code> ausführen <code>zipRow()</code> , tritt ein Problem auf, da es entweder zurückgibt.  Wenn wir also <code>.map()</code> verwenden, <code>.map()</code> wir in <code>.map()</code> entweder.  Wenn wir weiter gehen, bleiben Sie stecken, bis wir <code>.map()</code> in <code>.map()</code> .  Das wird auch nicht funktionieren.  Wir brauchen eine Möglichkeit, diese verschachtelten Entweder zu kombinieren.  Schreiben wir also eine neue Methode, die wir <code>.join()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } join() { // On the sad path, we don't // do anything with join return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } join() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) || (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Right)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Jetzt können wir unser Vermögen „auspacken“: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.map(zipRow(headerFields)).join(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.map(addDateStr).join(); <span class="hljs-comment"><span class="hljs-comment">// Slowly getting better... but what do we return? }</span></span></code> </pre> <br><h4>  Kette </h4><br>  Wir haben einen langen Weg zurückgelegt.  Aber Sie müssen sich die <code>.join()</code> Zeit an den Aufruf von <code>.join()</code> erinnern, was ärgerlich ist.  Wir haben jedoch ein gemeinsames aufeinanderfolgendes <code>.map()</code> und <code>.join()</code> . Erstellen wir also eine Schnellzugriffsmethode dafür.  Nennen wir es <code>chain()</code> , weil es Funktionen miteinander verbindet, die Left oder Right zurückgeben. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *Left represents the sad path. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Left</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map() { <span class="hljs-comment"><span class="hljs-comment">// Left is the sad path // so we do nothing return this; } join() { // On the sad path, we don't // do anything with join return this; } chain() { // Boring sad path, // do nothing. return this; } toString() { const str = this._val.toString(); return `Left(${str})`; } }</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Right represents the happy path */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Right</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; } map(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Right( fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val) ); } join() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) || (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Right)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } chain(fn) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val); } toString() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val.toString(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`Right(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${str}</span></span></span><span class="hljs-string">)`</span></span>; } }</code> </pre> <br>  Zurück zur Eisenbahnanalogie: <code>.chain()</code> wechselt die Schienen, wenn ein Fehler <code>.chain()</code> .  Es ist jedoch einfacher, auf dem Diagramm zu zeigen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1bc/279/530/1bc2795304c211004070da858179fcfc.svg"><br>  <i><font color="gray">Wenn ein Fehler auftritt, können Sie mit der .chain () -Methode zum linken Pfad wechseln.</font></i>  <i><font color="gray">Bitte beachten Sie, dass die Schalter nur in eine Richtung funktionieren.</font></i> <br><br>  Der Code wurde etwas sauberer: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.chain(zipRow(headerFields)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.chain(addDateStr); <span class="hljs-comment"><span class="hljs-comment">// Slowly getting better... but what do we return? }</span></span></code> </pre> <br><h4>  Mach etwas mit Werten </h4><br>  Das Refactoring der <code>processRow()</code> -Funktion ist fast abgeschlossen.  Aber was passiert, wenn wir den Wert zurückgeben?  Am Ende wollen wir verschiedene Maßnahmen ergreifen, je nachdem, in welcher Situation wir uns befinden: Links oder Rechts.  Daher werden wir eine Funktion schreiben, die geeignete Maßnahmen ergreift: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">either</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">leftFunc, rightFunc, e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Left) ? leftFunc(e._val) : rightFunc(e._val); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich habe betrogen und die internen Werte von linken oder rechten Objekten verwendet. </font><font style="vertical-align: inherit;">Aber tun Sie so, als hätten Sie das nicht bemerkt. </font><font style="vertical-align: inherit;">Jetzt können wir unsere Funktion erfüllen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fieldsEither = right(row).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObj = fieldsEither.chain(zipRow(headerFields)); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = rowObj.chain(addDateStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, rowToMessage, rowObjWithDate); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und wenn wir uns besonders schlau fühlen, können wir wieder die freie Syntax verwenden: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields, row</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rowObjWithDate = right(row) .map(splitFields) .chain(zipRow(headerFields)) .chain(addDateStr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, rowToMessage, rowObjWithDate); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beide Versionen sind ziemlich hübsch. </font><font style="vertical-align: inherit;">Keine Designs </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und keine if-Anweisungen in der Top-Level-Funktion. </font><font style="vertical-align: inherit;">Wenn es ein Problem mit einer bestimmten Zeile gibt, wird am Ende einfach eine Fehlermeldung angezeigt. </font><font style="vertical-align: inherit;">Und beachten Sie, dass </font></font><code>processRow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir links oder rechts das einzige Mal ganz am Anfang erwähnen, wenn wir anrufen </font></font><code>right()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Der Rest sind nur Methoden </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>.chain()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für die nächste Funktion.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ap und heben </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es sieht gut aus, aber es bleibt noch ein letztes Szenario zu betrachten. </font><font style="vertical-align: inherit;">Lassen Sie uns anhand unseres Beispiels sehen, wie alle CSV-Daten und nicht nur jede Zeile einzeln verarbeitet werden können. </font><font style="vertical-align: inherit;">Wir benötigen eine oder drei Hilfsfunktionen (Helfer):</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">splitCSVToRows</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// There should always be a header row... so if there's no // newline character, something is wrong. return (csvData.indexOf('\n') &lt; 0) ? left('No header row found in CSV data') : right(csvData.split('\n')); } function processRows(headerFields, dataRows) { // Note this is Array map, not Either map. return dataRows.map(row =&gt; processRow(headerFields, row)); } function showMessages(messages) { return `&lt;ul class="Messages"&gt;${messages.join('\n')}&lt;/ul&gt;`; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also einen Helfer, der CSV in Zeilen aufteilt. </font><font style="vertical-align: inherit;">Und wir kehren mit Entweder zu der Option zurück. </font><font style="vertical-align: inherit;">Jetzt können Sie </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einige lodash-Funktionen verwenden, um die Titelleiste aus Datenzeilen zu extrahieren. </font><font style="vertical-align: inherit;">Aber wir befinden uns in einer interessanten Situation ...</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-comment"><span class="hljs-comment">// What's next? }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben Header-Felder und Datenzeilen zur Anzeige bereit </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aber </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch </font></font><code>dataRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Entweder eingewickelt. </font><font style="vertical-align: inherit;">Wir brauchen eine Möglichkeit, </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine Funktion </font><font style="vertical-align: inherit;">zu konvertieren </font><font style="vertical-align: inherit;">, die mit Entweder funktioniert. </font><font style="vertical-align: inherit;">Zu Beginn führen wir Currying durch </font></font><code>processRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRows</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">headerFields</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processRowsWithHeaderFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dataRows</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Note this is Array map, not Either map. return dataRows.map(row =&gt; processRow(headerFields, row)); }; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt ist alles bereit für das Experiment. Wir haben </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entweder ein Array umwickelt. Was passiert , </font><font style="vertical-align: inherit;">wenn wir nehmen </font></font><code>headerFields</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und fordern ihn </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-comment"><span class="hljs-comment">// How will we pass headerFields and dataRows to // processRows() ? const funcInEither = headerFields.map(processRows); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit .map () wird hier eine externe Funktion aufgerufen </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber keine interne. </font><font style="vertical-align: inherit;">Mit anderen Worten, </font></font><code>processRows()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gibt eine Funktion zurück. </font><font style="vertical-align: inherit;">Und seitdem </font></font><code>.map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekommen wir entweder noch zurück. </font><font style="vertical-align: inherit;">Das Ergebnis ist also eine Funktion in Entweder, die aufgerufen wird </font></font><code>funcInEither</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es nimmt ein Array von Zeichenfolgen und gibt ein Array anderer Zeichenfolgen zurück. </font><font style="vertical-align: inherit;">Wir müssen diese Funktion irgendwie übernehmen und sie mit einem Wert im Inneren aufrufen </font></font><code>dataRows</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Fügen Sie dazu unseren Klassen Links und Rechts eine weitere Methode hinzu. </font><font style="vertical-align: inherit;">Wir werden es </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Übereinstimmung mit dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standard nennen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie üblich macht die Methode nichts auf der linken Spur:</font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// In Left (the sad path) ap() { return this; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und für die richtige Klasse erwarten wir ein weiteres Entweder mit einer Funktion: </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// In Right (the happy path) ap(otherEither) { const functionToRun = otherEither._val; return this.map(functionToRun); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jetzt können wir unsere Hauptfunktion erfüllen: </font></font><br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> funcInEither = headerFields.map(processRows); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messagesArr = dataRows.ap(funcInEither); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, showMessages, messagesArr); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Wesentliche der Methode wird </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sofort ein wenig verstanden (die Spezifikationen von Fantasy Land verwirren es, aber in den meisten anderen Sprachen wird die Methode umgekehrt verwendet). Wenn Sie es einfacher beschreiben, sagen Sie: „Ich habe eine Funktion, die normalerweise zwei einfache Werte annimmt. Ich möchte daraus eine Funktion machen, die entweder zwei benötigt. " Wenn verfügbar, können </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir eine Funktion schreiben, die genau das tut. Nennen wir es </font></font><code>liftA2()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wieder in Übereinstimmung mit dem Standardnamen. Sie nimmt eine einfache Funktion, die zwei Argumente erwartet, und "hebt" sie auf, um mit "Applikativen" zu arbeiten. (Dies sind Objekte, die sowohl eine Methode </font></font><code>.ap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">als auch eine Methode enthalten. </font></font><code>.of()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) LiftA2 ist also die Abkürzung für "Applicative Lift, zwei Parameter". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Funktion </font></font><code>liftA2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">könnte also ungefähr so ​​aussehen:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">liftA2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runApplicativeFunc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.ap(a.map(func)); }; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unsere Top-Level-Funktion wird es wie folgt verwenden: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">csvToMessages</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">csvData</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> csvRows = splitCSVToRows(csvData); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> headerFields = csvRows.map(_.head).map(splitFields); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dataRows = csvRows.map(_.tail); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> processRowsA = liftA2(processRows); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> messagesArr = processRowsA(headerFields, dataRows); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> either(showError, showMessages, messagesArr); }</code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code auf CodePen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1>  Richtig?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das ist alles? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie fragen sich vielleicht, was ist besser als einfache Ausnahmen? </font><font style="vertical-align: inherit;">Scheint es mir nicht zu kompliziert, ein einfaches Problem zu lösen? </font><font style="vertical-align: inherit;">Lassen Sie uns zunächst darüber nachdenken, warum wir Ausnahmen mögen. </font><font style="vertical-align: inherit;">Wenn es keine Ausnahmen gäbe, müssten Sie überall viele if-Anweisungen schreiben. </font><font style="vertical-align: inherit;">Wir werden immer Code nach dem Prinzip schreiben: "Wenn letzteres funktioniert, fahren Sie fort, andernfalls verarbeiten Sie den Fehler." </font><font style="vertical-align: inherit;">Und wir müssen diese Fehler im gesamten Code behandeln. </font><font style="vertical-align: inherit;">Dies macht es schwierig zu verstehen, was passiert. </font><font style="vertical-align: inherit;">Mit Ausnahmen können Sie das Programm beenden, wenn ein Fehler aufgetreten ist. </font><font style="vertical-align: inherit;">Daher müssen Sie nicht alle diese ifs schreiben. </font><font style="vertical-align: inherit;">Sie können sich auf einen erfolgreichen Ausführungspfad konzentrieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber es gibt einen Haken. Ausnahmen verbergen zu viel. Wenn Sie eine Ausnahme auslösen, übertragen Sie das Fehlerbehandlungsproblem auf eine andere Funktion. Es ist zu einfach, eine Ausnahme zu ignorieren, die auf der höchsten Ebene angezeigt wird. Das Schöne an beiden ist, dass Sie wie mit einer Ausnahme aus dem Hauptprogramm-Stream springen können. Und es funktioniert ehrlich. Sie erhalten entweder rechts oder links. Sie können nicht so tun, als wäre die Option Links unmöglich. Am Ende müssen Sie den Wert mit einem Aufruf wie herausziehen </font></font><code>either()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich weiß, es klingt nach einer Art Komplexität. Aber schauen Sie sich den Code an, den wir geschrieben haben (keine Klassen, sondern Funktionen, die sie verwenden). Es gibt nicht viel Code für die Ausnahmebehandlung. Es fehlt fast, mit Ausnahme eines Anrufs </font></font><code>either()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">am Ende </font></font><code>csvToMessages()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>processRow()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das ist der springende Punkt. </font><font style="vertical-align: inherit;">Mit Entweder haben Sie eine saubere Fehlerbehandlung, die nicht versehentlich vergessen werden kann. </font><font style="vertical-align: inherit;">Stempeln Sie ohne Beides den Code durch und fügen Sie überall Polster hinzu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet nicht, dass Sie es niemals verwenden sollten </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Manchmal ist es das richtige Werkzeug und es ist normal. </font><font style="vertical-align: inherit;">Dies ist jedoch nicht das einzige Werkzeug. </font><font style="vertical-align: inherit;">Entweder gibt Ihnen einige Vorteile, die Sie nicht haben </font></font><code>try...catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Geben Sie dieser Monade eine Chance. </font><font style="vertical-align: inherit;">Auch wenn es zunächst schwierig ist, denke ich, dass es Ihnen gefallen wird. </font><font style="vertical-align: inherit;">Bitte, bitte verwenden Sie nicht die Implementierung aus diesem Artikel. </font><font style="vertical-align: inherit;">Probieren Sie eine der berühmten Bibliotheken wie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crocks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sanctuary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Folktale</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Monet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie sind besser bedient. </font><font style="vertical-align: inherit;">Und hier habe ich der Einfachheit halber etwas verpasst.</font></font><br><br><blockquote><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zusätzliche Ressourcen </font></font></h1><br><ul><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">       </a> », <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> Fantasy Land</a> <br></li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">    JavaScript: Either</a> », <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> <br></li><li> « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  JavaScript: </a> », <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de457098/">https://habr.com/ru/post/de457098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de457086/index.html">Architekturmuster "Builder" im Universum von "Swift" und "iOS" / "macOS"</a></li>
<li><a href="../de457090/index.html">Sicherheitskrippen: JWT</a></li>
<li><a href="../de457092/index.html">Wir studieren MITRE ATT & CK. Mobile Matrizen: Gerätezugriff. Teil 5</a></li>
<li><a href="../de457094/index.html">Excel-Add-In, mit dem Filter bei der Arbeit mit Cubes (VBA) einfach festgelegt werden können</a></li>
<li><a href="../de457096/index.html">Wir geben mehreren Analysten die Hand: API Livy zur Automatisierung typischer Bankaufgaben</a></li>
<li><a href="../de457100/index.html">AWS Lambda - Theorie, Bekanntschaft</a></li>
<li><a href="../de457102/index.html">QVD-Dateien - was ist drin, Teil 3</a></li>
<li><a href="../de457106/index.html">Der US-Robo-Call-Krieg - wer gewinnt und warum</a></li>
<li><a href="../de457108/index.html">WWDC19: Erste Schritte mit dem Testplan für XCTest</a></li>
<li><a href="../de457110/index.html">Unit-Test von C ++ - und Mock-Injection-Mustern unter Verwendung von Merkmalen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>