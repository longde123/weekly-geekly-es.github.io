<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ô•Ô∏è üêï üï° Caso 5 + 1 em que a especifica√ß√£o da API REST desempenha um grande papel üë®üèº‚Äçüíª üå† üì©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artigo se concentrar√° em escrever e dar suporte a uma especifica√ß√£o √∫til e relevante para um projeto de API REST, que economizar√° muito c√≥digo ex...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Caso 5 + 1 em que a especifica√ß√£o da API REST desempenha um grande papel</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427601/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/b1/dg/ob/b1dgobh5dxfw3q-firfz-77qu-0.png"></div><br><p> Este artigo se concentrar√° em escrever e dar suporte a uma especifica√ß√£o √∫til e relevante para um projeto de API REST, que economizar√° muito c√≥digo extra e melhorar√° seriamente a integridade, a confiabilidade e a transpar√™ncia do projeto como um todo. </p><br><h3 id="chto-takoe-restful-api">  O que √© uma API RESTful? </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dde/ee8/857/ddeee88570832b82d7a7ff7231255c3f.png"></div><br><p>  Isso √© um mito. </p><br><p>  S√©rio, se voc√™ acha que seu projeto possui uma API RESTful, provavelmente est√° enganado.  A id√©ia do RESTful √© criar uma API que, em todos os aspectos, atenda √†s regras e restri√ß√µes de arquitetura descritas pelo estilo REST, mas em condi√ß√µes reais isso √© <em>quase imposs√≠vel</em> . </p><a name="habracut"></a><br><p>  Por um lado, o REST cont√©m muitas defini√ß√µes vagas e amb√≠guas.  Por exemplo, alguns termos dos dicion√°rios de m√©todos HTTP e c√≥digos de status n√£o s√£o utilizados para o objetivo pretendido na pr√°tica, enquanto muitos deles n√£o s√£o utilizados. </p><br><p>  Por outro lado, o REST cria muitas restri√ß√µes.  Por exemplo, o uso at√¥mico de recursos no mundo real n√£o √© racional para as APIs usadas por aplicativos m√≥veis.  Uma recusa completa em armazenar estado entre solicita√ß√µes √© essencialmente uma proibi√ß√£o do mecanismo de sess√µes do usu√°rio usado em muitas APIs. </p><br><p>  <strong>Mas espere, nem tudo √© t√£o ruim!</strong> </p><br><h3 id="zachem-nuzhna-specifikaciya-rest-api">  Por que precisamos da especifica√ß√£o da API REST? </h3><br><p>  Apesar dessas defici√™ncias, com uma abordagem razo√°vel, o REST ainda permanece uma excelente base para o design de APIs realmente legais.  Essa API deve ter uniformidade interna, uma estrutura clara, documenta√ß√£o conveniente e boa cobertura de teste de unidade.  Tudo isso pode ser alcan√ßado atrav√©s do desenvolvimento de uma <strong>especifica√ß√£o de</strong> qualidade para sua API. </p><br><p>  Na maioria das vezes, <em>a especifica√ß√£o da</em> API REST <em>est√°</em> associada √† sua <em>documenta√ß√£o</em> .  Diferentemente da primeira (que √© uma descri√ß√£o formal da sua API), a documenta√ß√£o deve ser lida por pessoas: por exemplo, desenvolvedores de um aplicativo m√≥vel ou da Web usando sua API. </p><br><p>  No entanto, al√©m de realmente criar a documenta√ß√£o, uma descri√ß√£o adequada da API ainda pode trazer muitos benef√≠cios.  No artigo, quero compartilhar exemplos de como, usando o uso competente da especifica√ß√£o, voc√™ pode: </p><br><ul><li>  tornar o teste de unidade mais simples e mais confi√°vel; </li><li>  configurar pr√©-processamento e valida√ß√£o de dados de entrada; </li><li>  automatize a serializa√ß√£o e garanta a integridade das respostas; </li><li>  e at√© aproveite a digita√ß√£o est√°tica. </li></ul><br><h3 id="openapi">  Openapi </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/222/aae/af9/222aaeaf95adf9cb50af1ed7702d4c9b.png" width="500"></div><br><p>  O formato geralmente aceito para descrever a API REST hoje √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>OpenAPI</strong></a> , tamb√©m conhecido como <em>Swagger</em> .  Esta especifica√ß√£o √© um √∫nico arquivo no formato JSON ou YAML, consistindo em tr√™s se√ß√µes: </p><br><ul><li>  um cabe√ßalho contendo o nome, descri√ß√£o e vers√£o da API, al√©m de informa√ß√µes adicionais; </li><li>  uma descri√ß√£o de todos os recursos, incluindo seus identificadores, m√©todos HTTP, todos os par√¢metros de entrada, bem como c√≥digos e formatos do corpo da resposta, com links para defini√ß√µes; </li><li>  todas as defini√ß√µes de objetos no formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>JSON Schema</strong></a> que podem ser usadas nos par√¢metros de entrada e nas respostas. </li></ul><br><p>  O OpenAPI tem uma s√©ria desvantagem - a <em>complexidade da estrutura e, frequentemente, a redund√¢ncia</em> .  Para um projeto pequeno, o conte√∫do do arquivo JSON de especifica√ß√£o pode aumentar rapidamente para v√°rios milhares de linhas.  N√£o √© poss√≠vel manter este arquivo manualmente neste formul√°rio.  Essa √© uma s√©ria amea√ßa √† pr√≥pria id√©ia de manter uma especifica√ß√£o atualizada √† medida que a API evolui. </p><br><p>  Existem muitos editores visuais que permitem descrever a API e formar a especifica√ß√£o OpenAPI resultante.  Por sua vez, servi√ßos adicionais e solu√ß√µes em nuvem s√£o baseados neles, por exemplo, <em>Swagger</em> , <em>Apiary</em> , <em>Stoplight</em> , <em>Restlet</em> e outros. </p><br><p>  No entanto, para mim, esses servi√ßos n√£o eram muito convenientes devido √† dificuldade de editar rapidamente a especifica√ß√£o e combin√°-la com o processo de escrita do c√≥digo.  Outro ponto negativo √© a depend√™ncia do conjunto de fun√ß√µes de cada servi√ßo espec√≠fico.  Por exemplo, √© quase imposs√≠vel implementar testes de unidade completos somente por meio de um servi√ßo em nuvem.  A gera√ß√£o de c√≥digo e at√© a cria√ß√£o de "plugs" para terminais, embora pare√ßa muito poss√≠vel, s√£o praticamente in√∫teis na pr√°tica. </p><br><h3 id="tinyspec">  Tinyspec </h3><br><p>  Neste artigo, usarei exemplos baseados no formato de descri√ß√£o da API REST nativa - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>tinyspec</strong></a> .  O formato s√£o pequenos arquivos que descrevem os pontos de extremidade e modelos de dados usados ‚Äã‚Äãno projeto com uma sintaxe intuitiva.  Os arquivos s√£o armazenados ao lado do c√≥digo, o que permite verificar com eles e edit√°-los diretamente no processo de escrita.  Ao mesmo tempo, o tinyspec √© automaticamente compilado em uma OpenAPI de pleno direito, que pode ser usada imediatamente no projeto.  √â hora de dizer exatamente como. </p><br><p>  Neste artigo, darei exemplos de Node.js (koa, express) e Ruby on Rails, embora essas pr√°ticas se apliquem √† maioria das tecnologias, incluindo Python, PHP e Java. </p><br><h2 id="kogda-eschyo-specifikaciya-okazyvaetsya-neveroyatno-poleznoy">  Quando a especifica√ß√£o √© incrivelmente √∫til </h2><br><h3 id="1-unit-testy-endpointov">  1. Testes unit√°rios de endpoints </h3><br><p>  <em>O BDD (Behavior-driven Development) √©</em> ideal para o desenvolvimento de uma API REST.  A maneira mais conveniente de escrever testes de unidade n√£o √© para classes, modelos e controladores individuais, mas para pontos de extremidade espec√≠ficos.  Em cada teste, voc√™ emula uma solicita√ß√£o HTTP real e verifica a resposta do servidor.  No Node.js, para emular solicita√ß√µes de teste, h√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">supertest</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://www.chaijs.com/plugins/chai-">chai-http</a> , no Ruby on Rails - no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ar</a> . </p><br><p> Suponha que tenhamos um esquema de <code>User</code> e um ponto de extremidade <code>GET /users</code> que retorne todos os usu√°rios.  Aqui est√° a sintaxe tinyspec que descreve isso: </p><br><ol><li>  Arquivo <em>User.models.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">User {name, isAdmin: b, age?: i}</code> </pre> <br><ol><li>  Arquivo <em>users.endpoints.tinyspec</em> : </li></ol><br><pre> <code class="python hljs">GET /users =&gt; {users: User[]}</code> </pre> <br><p>  √â assim que nosso teste ser√°: </p><br><h4 id="nodejs">  Node.js </h4><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].name).to.be(<span class="hljs-string"><span class="hljs-string">'string'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].isAdmin).to.be(<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>); expect(users[<span class="hljs-number"><span class="hljs-number">0</span></span>].age).to.be.oneOf([<span class="hljs-string"><span class="hljs-string">'boolean'</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>]); }); });</code> </pre> <br><h4 id="ruby-on-rails">  Ruby on Rails </h4><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect_json_types(<span class="hljs-string"><span class="hljs-string">'users.*'</span></span>, { <span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:string</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">isAdmin:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:boolean</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:integer_or_null</span></span>, }) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Quando temos uma especifica√ß√£o que descreve os formatos de resposta do servidor, podemos simplificar o teste e simplesmente <em>verificar a resposta nessa especifica√ß√£o</em> .  Para fazer isso, aproveitaremos o fato de que nossos modelos tinyspec s√£o transformados em defini√ß√µes OpenAPI, que por sua vez correspondem ao formato do esquema JSON. </p><br><p>  Qualquer <em>objeto literal</em> em JS (ou <code>Hash</code> em Ruby, um <code>dict</code> em Python, <em>uma matriz associativa</em> em PHP e at√© um <code>Map</code> em Java) pode ser testado quanto √† conformidade com um esquema JSON.  E existem at√© plugins correspondentes para estruturas de teste, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jest-ajv</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chai-ajv-json-schema</a> (npm) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">json_matchers</a> (rubygem) para o RSpec. </p><br><p>  Antes de usar os esquemas, voc√™ deve conect√°-los ao projeto.  Primeiro, geraremos o arquivo de especifica√ß√£o openapi.json com base no tinyspec (essa a√ß√£o pode ser executada automaticamente antes de cada teste): </p><br><pre> <code class="bash hljs">tinyspec -j -o openapi.json</code> </pre> <br><h4 id="nodejs-1">  Node.js </h4><br><p>  Agora podemos usar o JSON recebido no projeto e pegar a chave de <code>definitions</code> , que cont√©m todos os esquemas JSON.  Os esquemas podem conter refer√™ncias cruzadas ( <code>$ref</code> ); portanto, se tivermos esquemas aninhados (por exemplo, <code>Blog {posts: Post[]}</code> ), precisamos "expandi-los" para us√°-los nas valida√ß√µes.  Para fazer isso, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">json-schema-deref-sync</a> (npm). </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deref <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'json-schema-deref-sync'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> spec = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./openapi.json'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schemas = deref(spec).definitions; describe(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'List all users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { status, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: { users } } = request.get(<span class="hljs-string"><span class="hljs-string">'/users'</span></span>); expect(status).to.equal(<span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Chai expect(users[0]).to.be.validWithSchema(schemas.User); // Jest expect(users[0]).toMatchSchema(schemas.User); }); });</span></span></code> </pre> <br><h4 id="ruby-on-rails-1">  Ruby on Rails </h4><br><p>  <code>json_matchers</code> pode manipular os links <code>$ref</code> , mas requer arquivos separados com esquemas no sistema de arquivos de uma certa maneira, ent√£o primeiro voc√™ precisa "dividir" o <code>swagger.json</code> em muitos arquivos pequenos (mais sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ): </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># ./spec/support/json_schemas.rb require 'json' require 'json_matchers/rspec' JsonMatchers.schema_root = 'spec/schemas' # Fix for json_matchers single-file restriction file = File.read 'spec/schemas/openapi.json' swagger = JSON.parse(file, symbolize_names: true) swagger[:definitions].keys.each do |key| File.open("spec/schemas/#{key}.json", 'w') do |f| f.write(JSON.pretty_generate({ '$ref': "swagger.json#/definitions/#{key}" })) end end</span></span></code> </pre> <br><p>  Depois disso, podemos escrever nosso teste assim: </p><br><pre> <code class="ruby hljs">describe <span class="hljs-string"><span class="hljs-string">'GET /users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it <span class="hljs-string"><span class="hljs-string">'List all users'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> get <span class="hljs-string"><span class="hljs-string">'/users'</span></span> expect_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) expect(result[<span class="hljs-symbol"><span class="hljs-symbol">:users</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]).to match_json_schema(<span class="hljs-string"><span class="hljs-string">'User'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Nota: escrever testes dessa maneira √© incrivelmente conveniente.  Especialmente se o seu IDE oferecer suporte √† execu√ß√£o de testes e depura√ß√£o (como WebStorm, RubyMine e Visual Studio).  Portanto, voc√™ n√£o pode usar nenhum outro software e todo o ciclo de desenvolvimento da API √© reduzido para tr√™s etapas consecutivas: </p><br><ol><li>  design de especifica√ß√£o (por exemplo, em tinyspec); </li><li>  escrever um conjunto completo de testes para pontos finais adicionados / alterados; </li><li>  desenvolvendo c√≥digo que satisfa√ßa todos os testes. </li></ol><br><h3 id="2-validaciya-vhodnyh-dannyh">  2. Valida√ß√£o de entrada </h3><br><p>  O OpenAPI descreve o formato n√£o apenas de respostas, mas tamb√©m de dados de entrada.  Isso nos permite <em>validar os dados</em> recebidos do usu√°rio durante a solicita√ß√£o. </p><br><p>  Suponha que tenhamos a seguinte especifica√ß√£o que descreve a atualiza√ß√£o dos dados do usu√°rio, bem como todos os campos que podem ser alterados: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># user.models.tinyspec UserUpdate !{name?, age?: i} # users.endpoints.tinyspec PATCH /users/:id {user: UserUpdate} =&gt; {success: b}</span></span></code> </pre> <br><p>  Anteriormente, examinamos os plugins para valida√ß√£o em testes, no entanto, para casos mais gerais, existem m√≥dulos de valida√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ajv</a> (npm) e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">json-schema</a> (rubygem), vamos us√°-los e escrever um controlador com valida√ß√£o. </p><br><h4 id="nodejs-koa">  Node.js (Koa) </h4><br><p>  Este √© um exemplo para <strong>Koa</strong> , o sucessor do Express, mas para o Express, o c√≥digo ser√° semelhante. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Ajv <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'ajv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); <span class="hljs-comment"><span class="hljs-comment">// Standard resource update action in Koa. router.patch('/:id', async (ctx) =&gt; { const updateData = ctx.body.user; // Validation using JSON schema from API specification. await validate(schemas.UserUpdate, updateData); const user = await User.findById(ctx.params.id); await user.update(updateData); ctx.body = { success: true }; }); async function validate(schema, data) { const ajv = new Ajv(); if (!ajv.validate(schema, data)) { const err = new Error(); err.errors = ajv.errors; throw err; } }</span></span></code> </pre> <br><p>  Neste exemplo, se os dados de entrada n√£o atenderem √† especifica√ß√£o, o servidor retornar√° uma resposta <code>500 Internal Server Error</code> ao cliente.  Para impedir que isso aconte√ßa, podemos interceptar o erro do validador e formar nossa pr√≥pria resposta, que conter√° informa√ß√µes mais detalhadas sobre campos espec√≠ficos que n√£o passaram no teste e tamb√©m est√° em <em>conformidade com a especifica√ß√£o</em> . </p><br><p>  Adicione uma descri√ß√£o do modelo <code>FieldsValidationError</code> no arquivo <code>FieldsValidationError</code> : </p><br><pre> <code class="python hljs">Error {error: b, message} InvalidField {name, message} FieldsValidationError &lt; Error {fields: InvalidField[]}</code> </pre> <br><p>  E agora n√≥s o indicamos como uma das poss√≠veis respostas de nosso endpoint: </p><br><pre> <code class="python hljs">PATCH /users/:id {user: UserUpdate} =&gt; <span class="hljs-number"><span class="hljs-number">200</span></span> {success: b} =&gt; <span class="hljs-number"><span class="hljs-number">422</span></span> FieldsValidationError</code> </pre> <br><p>  Essa abordagem permitir√° que voc√™ escreva testes de unidade que verifiquem a corre√ß√£o da forma√ß√£o de erros com dados incorretos recebidos do cliente. </p><br><h3 id="3-serializaciya-modeley">  3. Serializa√ß√£o de modelos </h3><br><p>  Quase todas as estruturas de servidor modernas usam o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ORM de uma</a> maneira ou de outra.  Isso significa que a maioria dos recursos usados ‚Äã‚Äãna API dentro do sistema √© apresentada na forma de modelos, suas inst√¢ncias e cole√ß√µes. </p><br><p>  O processo de gera√ß√£o de uma representa√ß√£o JSON dessas entidades para transmiss√£o na resposta da API √© chamado <em>serializa√ß√£o</em> .  Existem v√°rios plugins para estruturas diferentes que executam fun√ß√µes de serializa√ß√£o, por exemplo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sequelizar para json</a> (npm), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">atos_as_api</a> (rubygem), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">jsonapi-rails</a> (rubygem).  De fato, esses plug-ins permitem que um modelo espec√≠fico especifique uma lista de campos que devem ser inclu√≠dos no objeto JSON, al√©m de regras adicionais, por exemplo, para renome√°-los ou calcular valores dinamicamente. </p><br><p>  As dificuldades come√ßam quando precisamos ter v√°rias representa√ß√µes JSON diferentes do mesmo modelo ou quando um objeto cont√©m entidades aninhadas - associa√ß√µes.  √â necess√°rio <em>herdar, reutilizar e vincular serializadores</em> . </p><br><p>  M√≥dulos diferentes resolvem esses problemas de maneiras diferentes, mas vamos pensar: a especifica√ß√£o pode nos ajudar novamente?  De fato, de fato, todas as informa√ß√µes sobre os requisitos para representa√ß√µes JSON, todas as combina√ß√µes poss√≠veis de campos, incluindo entidades aninhadas, j√° est√£o nele.  Para que possamos escrever um serializador autom√°tico. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Chamo</a> a aten√ß√£o um pequeno m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sequelize-serialize</a> (npm), que permite fazer isso nos modelos Sequelize.  Ele utiliza uma inst√¢ncia do modelo ou matriz, bem como o circuito necess√°rio, e constr√≥i iterativamente um objeto serializado, levando em considera√ß√£o todos os campos necess√°rios e usando circuitos aninhados para as entidades associadas. </p><br><p>  Portanto, suponha que seja necess√°rio retornar da API a todos os usu√°rios que t√™m postagens no blog, incluindo coment√°rios nessas postagens.  Descrevemos isso usando a seguinte especifica√ß√£o: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># models.tinyspec Comment {authorId: i, message} Post {topic, message, comments?: Comment[]} User {name, isAdmin: b, age?: i} UserWithPosts &lt; User {posts: Post[]} # blogUsers.endpoints.tinyspec GET /blog/users =&gt; {users: UserWithPosts[]}</span></span></code> </pre> <br><p>  Agora podemos criar a consulta usando Sequelize e retornar um objeto serializado que corresponda exatamente √† especifica√ß√£o descrita acima: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'koa-router'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> serialize <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'sequelize-serialize'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { schemas } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schemas'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> router = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Router(); router.get(<span class="hljs-string"><span class="hljs-string">'/blog/users'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> User.findAll({ <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">association</span></span>: User.posts, <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">include</span></span>: [Post.comments] }] }); ctx.body = serialize(users, schemas.UserWithPosts); });</code> </pre> <br><p>  √â quase m√°gico, certo? </p><br><h3 id="4-staticheskaya-tipizaciya">  4. Digita√ß√£o est√°tica </h3><br><p>  Se voc√™ √© t√£o legal que est√° usando o TypeScript ou o Flow, j√° deve ter se perguntado: <em>"E meus queridos tipos est√°ticos?!"</em>  .  Usando os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">m√≥dulos sw2dts</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">swagger-to-flowtype,</a> voc√™ pode gerar todas as defini√ß√µes necess√°rias com base nos esquemas JSON e us√°-las para tipagem est√°tica de testes, dados de entrada e serializadores. </p><br><pre> <code class="bash hljs">tinyspec -j sw2dts ./swagger.json -o Api.d.ts --namespace Api</code> </pre> <br><p>  Agora podemos usar tipos em controladores: </p><br><pre> <code class="hljs pgsql">router.patch(<span class="hljs-string"><span class="hljs-string">'/users/:id'</span></span>, async (ctx) =&gt; { // Specify <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request data <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> const userData: Api.UserUpdate = ctx.request.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; // Run spec validation await <span class="hljs-keyword"><span class="hljs-keyword">validate</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.UserUpdate, userData); // Query the <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = await <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.findById(ctx.params.id); await <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(userData); // <span class="hljs-keyword"><span class="hljs-keyword">Return</span></span> serialized result const serialized: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = serialize(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); ctx.body = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: serialized }; });</code> </pre> <br><p>  E nos testes: </p><br><pre> <code class="hljs pgsql">it(<span class="hljs-string"><span class="hljs-string">'Update user'</span></span>, async () =&gt; { // Static <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> test <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> data. const updateData: Api.UserUpdate = { <span class="hljs-type"><span class="hljs-type">name</span></span>: MODIFIED }; const res = await request.patch(<span class="hljs-string"><span class="hljs-string">'/users/1'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: updateData }); // <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> helper <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> request response: const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: Api.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span> = res.body.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>; expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.be.validWithSchema(<span class="hljs-keyword"><span class="hljs-keyword">schemas</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>); expect(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>.containSubset(updateData); });</code> </pre> <br><p>  Observe que as defini√ß√µes de tipo geradas podem ser usadas n√£o apenas no projeto da API, mas tamb√©m em projetos de aplicativos clientes para descrever os tipos de fun√ß√µes nas quais a API trabalha.  Os desenvolvedores angulares de clientes ficar√£o especialmente satisfeitos com esse presente. </p><br><h3 id="5-privedenie-tipov-query-string">  5. Convers√£o de tipo da string de consulta </h3><br><p>  Se, por algum motivo, sua API aceitar solicita√ß√µes com o tipo MIME <code>application/x-www-form-urlencoded</code> e n√£o <code>application/json</code> , o corpo da solicita√ß√£o ter√° a seguinte apar√™ncia: </p><br><pre> <code class="python hljs">param1=value&amp;param2=<span class="hljs-number"><span class="hljs-number">777</span></span>&amp;param3=false</code> </pre> <br><p>  O mesmo se aplica aos par√¢metros de consulta (por exemplo, em solicita√ß√µes GET).  Nesse caso, o servidor da Web n√£o poder√° reconhecer automaticamente os tipos - todos os dados estar√£o na forma de cadeias ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° uma discuss√£o</a> no reposit√≥rio do m√≥dulo qpm npm), portanto, ap√≥s a an√°lise, voc√™ obter√° o seguinte objeto: </p><br><pre> <code class="python hljs">{ param1: <span class="hljs-string"><span class="hljs-string">'value'</span></span>, param2: <span class="hljs-string"><span class="hljs-string">'777'</span></span>, param3: <span class="hljs-string"><span class="hljs-string">'false'</span></span> }</code> </pre> <br><p>  Nesse caso, a solicita√ß√£o n√£o ser√° validada de acordo com o esquema, o que significa que ser√° necess√°rio verificar manualmente se cada par√¢metro tem o formato correto e traz√™-lo para o tipo necess√°rio. </p><br><p>  Como voc√™ pode imaginar, isso pode ser feito usando os mesmos esquemas de nossa especifica√ß√£o.  Imagine que temos esse ponto final e esquema: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># posts.endpoints.tinyspec GET /posts?PostsQuery # post.models.tinyspec PostsQuery { search, limit: i, offset: i, filter: { isRead: b } }</span></span></code> </pre> <br><p>  Aqui est√° um exemplo de uma solicita√ß√£o para esse terminal </p><br><pre> <code class="python hljs">GET /posts?search=needle&amp;offset=<span class="hljs-number"><span class="hljs-number">10</span></span>&amp;limit=<span class="hljs-number"><span class="hljs-number">1</span></span>&amp;filter[isRead]=true</code> </pre> <br><p>  Vamos escrever uma fun√ß√£o <code>castQuery</code> , que <code>castQuery</code> todos os par√¢metros nos tipos necess√°rios para n√≥s.  Ser√° algo parecido com isto: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">castQuery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query, schema</span></span></span><span class="hljs-function">) </span></span>{ _.mapValues(query, (value, key) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { type } = schema.properties[key] || {}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value || !type) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'integer'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseFloat</span></span>(value); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-string"><span class="hljs-string">'false'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; } }); }</code> </pre> <br><p>  Sua implementa√ß√£o mais completa, com suporte para esquemas aninhados, matrizes e tipos <code>null</code> est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cast-with-schema</a> (npm).  Agora podemos us√°-lo em nosso c√≥digo: </p><br><pre> <code class="javascript hljs">router.get(<span class="hljs-string"><span class="hljs-string">'/posts'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx) =&gt; { <span class="hljs-comment"><span class="hljs-comment">// Cast parameters to expected types const query = castQuery(ctx.query, schemas.PostsQuery); // Run spec validation await validate(schemas.PostsQuery, query); // Query the database const posts = await Post.search(query); // Return serialized result ctx.body = { posts: serialize(posts, schemas.Post) }; });</span></span></code> </pre> <br><p>  Observe como das quatro linhas do c√≥digo do terminal, os tr√™s usam esquemas da especifica√ß√£o. </p><br><h2 id="luchshie-praktiki">  Melhores pr√°ticas </h2><br><h3 id="otdelnye-shemy-dlya-sozdaniya-i-izmeneniya">  Esquemas separados para criar e modificar </h3><br><p>  Normalmente, os esquemas que descrevem a resposta do servidor s√£o diferentes daqueles que descrevem a entrada usada para criar e modificar modelos.  Por exemplo, a lista de campos dispon√≠veis para solicita√ß√µes <code>POST</code> e <code>PATCH</code> deve ser estritamente limitada, enquanto nas solicita√ß√µes <code>PATCH</code> , geralmente todos os campos do esquema s√£o opcionais.  Os esquemas que determinam a resposta podem ser mais gratuitos. </p><br><p>  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gera√ß√£o</a> autom√°tica <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de</a> terminais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRUDL tinyspec</a> usa os postfixes <code>New</code> e <code>Update</code> .  <code>User*</code> podem ser definidos da seguinte maneira: </p><br><pre> <code class="python hljs">User {id, email, name, isAdmin: b} UserNew !{email, name} UserUpdate !{email?, name?}</code> </pre> <br><p>  Tente n√£o usar os mesmos esquemas para diferentes tipos de a√ß√µes, a fim de evitar problemas acidentais de seguran√ßa devido √† reutiliza√ß√£o ou heran√ßa de esquemas antigos. </p><br><h3 id="semantika-v-nazvaniyah-shem">  Sem√¢ntica nos nomes de esquema </h3><br><p>  O conte√∫do dos mesmos modelos pode variar em diferentes pontos de extremidade.  Use os postfixes <code>With*</code> e <code>For*</code> nos nomes dos esquemas para mostrar como eles diferem e para que servem.  Nos modelos tinyspec tamb√©m podem ser herdados um do outro.  Por exemplo: </p><br><pre> <code class="python hljs">User {name, surname} UserWithPhotos &lt; User {photos: Photo[]} UserForAdmin &lt; User {id, email, lastLoginAt: d}</code> </pre> <br><p>  As corre√ß√µes posteriores podem ser variadas e combinadas.  O principal √© que o nome reflete a ess√™ncia e simplifica a familiaridade com a documenta√ß√£o. </p><br><h3 id="razdelenie-endpointov-po-tipu-klienta">  Separa√ß√£o de terminais por tipo de cliente </h3><br><p>  Geralmente, os mesmos pontos de extremidade retornam dados diferentes, dependendo do tipo de cliente ou da fun√ß√£o do usu√°rio que acessa o ponto de extremidade.  Por exemplo, os pontos finais de <code>GET /users</code> e <code>GET /messages</code> podem ser muito diferentes para os usu√°rios do seu aplicativo m√≥vel e para os gerentes de back office.  Ao mesmo tempo, alterar o nome do terminal em si pode ser muita complica√ß√£o. </p><br><p>  Para descrever o mesmo terminal v√°rias vezes, voc√™ pode adicionar seu tipo entre colchetes ap√≥s o caminho.  Al√©m disso, √© √∫til usar tags: isso ajudar√° a dividir a documenta√ß√£o de seus pontos de extremidade em grupos, cada um dos quais ser√° projetado para um grupo espec√≠fico de clientes da sua API.  Por exemplo: </p><br><pre> <code class="python hljs">Mobile app: GET /users (mobile) =&gt; UserForMobile[] CRM admin panel: GET /users (admin) =&gt; UserForAdmin[]</code> </pre> <br><h2 id="dokumentaciya-rest-api">  Documenta√ß√£o da API REST </h2><br><p>  Depois de ter uma especifica√ß√£o no formato tinyspec ou OpenAPI, voc√™ pode gerar uma documenta√ß√£o bonita em HTML e public√°-la para o prazer dos desenvolvedores que usam sua API. </p><br><p>  Al√©m dos servi√ßos em nuvem mencionados anteriormente, existem ferramentas de CLI que convertem o OpenAPI 2.0 em HTML e PDF, ap√≥s o qual voc√™ pode baix√°-lo para qualquer hospedagem est√°tica.  Exemplos: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bootprint-openapi</a> (npm, usado por padr√£o no tinyspec) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">swagger2markup-cli</a> (jar, existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um exemplo de uso</a> , ele ser√° usado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tinyspec Cloud</a> ) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">redoc-cli</a> (npm) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">widdershins</a> (npm) </li></ul><br><p>  <em>Voc√™ conhece mais exemplos?</em>  <em>Compartilhe-os nos coment√°rios.</em> </p><br><p>  Infelizmente, o OpenAPI 3.0, lan√ßado h√° um ano, ainda √© pouco suportado e n√£o pude encontrar nenhum exemplo digno de documenta√ß√£o com base nele: nem entre solu√ß√µes em nuvem nem entre as ferramentas CLI.  Pelo mesmo motivo, o OpenAPI 3.0 ainda n√£o √© suportado no tinyspec. </p><br><h3 id="publikaciya-v-github">  Publicar no GitHub </h3><br><p>  Uma das maneiras mais f√°ceis de publicar documenta√ß√£o √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub Pages</a> .  Apenas ative o suporte √† p√°gina est√°tica para o diret√≥rio <code>/docs</code> nas configura√ß√µes do seu reposit√≥rio e armazene a documenta√ß√£o HTML nesta pasta. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/09b/5ad/775/09b5ad7757239f4405cb370cb59c6a7b.png"></p><br><p>  Voc√™ pode adicionar um comando para gerar documenta√ß√£o atrav√©s de tinyspec ou outra ferramenta CLI nos <code>scripts</code> em <code>package.json</code> e atualizar a documenta√ß√£o com cada confirma√ß√£o: </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"docs"</span></span>: <span class="hljs-string"><span class="hljs-string">"tinyspec -h -o docs/"</span></span>, <span class="hljs-string"><span class="hljs-string">"precommit"</span></span>: <span class="hljs-string"><span class="hljs-string">"npm run docs"</span></span> }</code> </pre> <br><h3 id="continuous-integration">  Integra√ß√£o cont√≠nua </h3><br><p>  Voc√™ pode incluir a gera√ß√£o de documenta√ß√£o no ciclo do IC e public√°-la, por exemplo, no Amazon S3 em diferentes endere√ßos, dependendo do ambiente ou vers√£o da sua API, por exemplo: <code>/docs/2.0</code> , <code>/docs/stable</code> , <code>/docs/staging</code> . </p><br><h3 id="tinyspec-cloud">  Nuvem Tinyspec </h3><br><p>  Se voc√™ gostou da sintaxe tinyspec, pode se registrar como adotante antecipado em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tinyspec.cloud</a> .  Vamos construir com base em um servi√ßo em nuvem e CLI para publica√ß√£o autom√°tica de documenta√ß√£o com uma ampla sele√ß√£o de modelos e a capacidade de desenvolver nossos pr√≥prios modelos. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  O desenvolvimento de uma API REST √© talvez a atividade mais agrad√°vel de todas as que existem no processo de trabalhar em servi√ßos m√≥veis e da Web modernos.  N√£o h√° zool√≥gico de navegadores, sistemas operacionais e tamanhos de tela, tudo est√° completamente sob nosso controle - "ao seu alcance". </p><br><p>  Manter a especifica√ß√£o atual e os b√¥nus na forma de v√°rias automa√ß√µes, fornecidas ao mesmo tempo, torna esse processo ainda mais agrad√°vel.  Essa API se torna estruturada, transparente e confi√°vel. </p><br><p>  <em>De fato, mesmo se estamos envolvidos na cria√ß√£o de um mito, por que n√£o o fazemos bonito?</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427601/">https://habr.com/ru/post/pt427601/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427587/index.html">Java concentrado para mil e quinhentas pessoas. Como foi o Coringa 2018</a></li>
<li><a href="../pt427589/index.html">Escrevemos um bate-papo on-line no Websockets usando o Swoole</a></li>
<li><a href="../pt427591/index.html">Arquitetura como um fardo</a></li>
<li><a href="../pt427593/index.html">Magia de Comando R√°pido em Vivaldi 2.1</a></li>
<li><a href="../pt427595/index.html">Tente Micronaut ou Darling, eu reduzi o quadro</a></li>
<li><a href="../pt427603/index.html">Como finalmente come√ßar a escrever testes e n√£o se arrepender</a></li>
<li><a href="../pt427605/index.html">Como a plataforma de crowdsourcing da Yandex ajuda a treinar drones e avaliar a qualidade do servi√ßo</a></li>
<li><a href="../pt427607/index.html">Datacenter na Su√≠√ßa: trabalhar como um rel√≥gio</a></li>
<li><a href="../pt427609/index.html">Resolvendo a equa√ß√£o com divis√£o inteira sem for√ßa bruta</a></li>
<li><a href="../pt427611/index.html">A hist√≥ria de como eu atualizei o Yandex MapKit no iOS ou mapas, dinheiro, 2 mappits</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>