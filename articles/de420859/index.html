<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôªÔ∏è ‚öôÔ∏è ü§òüèª Zur Frage von Wirth und Ketten üî± üßû üë©‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algorithmen + Datenstrukturen = Programme - Virt N. 
 "Wir hatten eine wunderbare Gelegenheit, eine kleine, aber √§u√üerst lehrreiche taktische √úbung du...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Zur Frage von Wirth und Ketten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420859/"><h2>  Algorithmen + Datenstrukturen = Programme - Virt N. </h2><br><img src="https://habrastorage.org/webt/00/wp/ch/00wpchad9zptu4pxyqszkymsin4.jpeg" align="left"><h3>  "Wir hatten eine wunderbare Gelegenheit, eine kleine, aber √§u√üerst lehrreiche taktische √úbung durchzuf√ºhren." </h3><br>  Trotz der ersten Inschrift zu diesem Beitrag erlaube ich mir, dem Autor nicht zuzustimmen und zu zeigen, dass in einigen F√§llen die richtige Wahl der Datenstruktur wichtiger sein kann als die richtige Wahl der Algorithmen.  Um eine solch aufr√ºhrerische These zu veranschaulichen, betrachten wir eine einfache, aber vielversprechende Aufgabe, um das Spiel "Chain" zu studieren. <br><a name="habracut"></a><br>  Zun√§chst zu den Spielregeln - zwei Spieler spielen, die Startposition besteht aus N Objekten in der N√§he.  Der n√§chste Schritt besteht darin, ein oder zwei Objekte in der N√§he zu entfernen (Sie k√∂nnen versuchen, eine formale Definition des "nahe gelegenen Standorts" zu geben, dies ist jedoch auf einer intuitiven Ebene verst√§ndlich).  Der Spieler, der das letzte Objekt entfernt, gewinnt - das direkte Spiel oder derjenige, der das letzte Objekt aufheben muss (Sie k√∂nnen den Zug nicht √ºberspringen) - das umgekehrte Spiel gewinnt.  Da in dieser Version der Regeln ein direktes Spiel einfach uninteressant ist (dazu sp√§ter mehr), wird eine zus√§tzliche Einschr√§nkung eingef√ºhrt - nur ein Objekt kann im ersten Zug gel√∂scht werden. <br><br>  Zun√§chst stellen wir fest, dass das Spiel endlich ist, da mit jedem Zug die Anzahl der Objekte stark abnimmt und das Spiel endet, wenn die Anzahl der durch Null berechneten Objekte erreicht ist. Daher haben wir das Recht, beim Studium dieses Spiels mit dem Erfolg zu rechnen.  Dar√ºber hinaus ist es offensichtlich, dass das Spiel nicht l√§nger als N Z√ºge dauern kann. Erinnern wir uns an diese Tatsache. <br><br>  Die Untersuchung des Spiels besteht darin, zu bestimmen, ob f√ºr eine bestimmte anf√§ngliche Anzahl von Objekten der Spieler, der den ersten Zug macht, gewinnt (da dies ein Spiel mit der Nullsumme ist, andernfalls verliert er) mit einem optimalen Spiel auf beiden Seiten und in welcher minimalen Anzahl von Z√ºgen der Gewinn erreicht wird (oder durch Was ist die maximale Anzahl von Z√ºgen, die der Verlust wegbewegt? <br><br>  F√ºr einige von H ist die Antwort offensichtlich - mit einem Objekt gewinnt das erste ein direktes Spiel in einer Runde und verliert auch ein inverses Spiel (P1 = 1, I1 = -1).  Bei zwei Objekten verliert der erste Spieler in zwei Z√ºgen in einem direkten Spiel und gewinnt in zwei Z√ºgen invers (P2 = -2, I2 = 2), was zu einer Hypothese √ºber die Einfachheit der Bewertung dieses Spiels f√ºhren kann, die durch den Fall von drei Objekten best√§tigt wird (P2 = 3, I3 = -3).  Gl√ºcklicherweise (sonst w√§re dieser Beitrag nicht ver√∂ffentlicht worden) ver√§ndert ein Spiel mit vier Objekten das Bild etwas (P4 = -4, aber I4 = -3), so dass eine Recherche des Spiels wirklich erforderlich ist. <br><br>  F√ºr einige von H und f√ºr eine bestimmte Art von Spiel gibt es heuristische Algorithmen, die eine garantierte Auszahlung erm√∂glichen.  Zum Beispiel kann f√ºr ein direktes Spiel mit einem ungeraden Anfangs-H garantiert werden, dass Sie gewinnen, wenn Sie das zentrale Objekt mit dem ersten Zug entfernen und dann die Z√ºge des Gegners unter Verwendung einer zentralen Stelle als Symmetrieachse wiederholen. Dann wird garantiert, dass wir das letzte Objekt aufnehmen und gewinnen.  Die gleiche Strategie w√ºrde mit einer geraden Anzahl von Objekten funktionieren, wenn nicht die Einschr√§nkungen f√ºr den ersten Zug, was das Spiel nicht so trivial macht.  Im Allgemeinen ist die Verwendung symmetrischer Strategien bei Z√§hlspielen weit verbreitet, jedoch kein Allheilmittel, da diese Strategie beispielsweise in unserem umgekehrten Spiel fehlschl√§gt.  Es sollte beachtet werden, dass Heuristiken einen Gewinnalgorithmus liefern, aber keine genaue Sch√§tzung der Position liefern, da es Strategien geben kann, die zu schnelleren Gewinnen f√ºhren (dies ist f√ºr dieses spezielle Spiel der Fall). <br><br>  Wie k√∂nnen wir eine Bewertung des Spiels abgeben - genau wie ich die vorherigen Sch√§tzungen f√ºr 1-4 Objekte erhalten habe - die Methode wird als ersch√∂pfende Suche von oben nach unten bezeichnet - wir m√ºssen den vollst√§ndigen Baum des Spiels ber√ºcksichtigen, dh alle m√∂glichen Bewegungen f√ºr beide Seiten und jede Position bewerten, einschlie√ülich Quelle nach bestimmten Regeln.  Es ist zu beachten, dass das Vorhandensein erfolgreicher Heuristiken keine genaue Einsch√§tzung garantiert, da nur die erste H√§lfte der Frage beantwortet wird - wer gewinnt, aber nicht die erforderliche Mindestanzahl von Z√ºgen angibt. <br><br>  Dies bedeutet, dass wir einen vollst√§ndigen Spielbaum erstellen m√ºssen, aber bevor wir mit der Konstruktion fortfahren, m√ºssen wir ein Modell des untersuchten Objekts erstellen, in unserem Fall des Spiels. <br><br>  Warum konzentriere ich mich auf diese Phase - weil wir das Objekt in seiner materiellen Verk√∂rperung nicht erforschen k√∂nnen.  Nein, rein theoretisch ist dies m√∂glich (‚Äûauf der Welt ist im Allgemeinen rein theoretisch wenig m√∂glich‚Äú), und ich kann mir ein Bild vorstellen, in dem eine sehr gro√üe Anzahl von Robotern in der realen Welt viele Spiele spielt, aber die Materialkosten f√ºr eine solche L√∂sung des Problems der Bewertung des Spiels √ºbersteigen die Mengen, so sind wir gezwungen, den Weg der Modellierung realer Objekte mit ihren Software-Gegenst√ºcken zu beschreiten.  Und hier ist es sehr wichtig, eine feine Linie zu gehen und ein ausreichendes Ma√ü an Modellad√§quanz mit der notwendigen Vereinfachung zu kombinieren. <br><br>  Aber zuerst ein wenig Mathematik, um die Komplexit√§t der Aufgabe zu beurteilen - wir m√ºssen alle m√∂glichen Z√ºge im Spiel sortieren (Aufmerksamkeit sind nicht alle m√∂glichen Positionen, dies ist das Thema einer anderen Methode, n√§mlich die Z√ºge) und wir m√∂chten die erforderliche Menge an Ressourcen vor Beginn der Arbeit bewerten -, um die Reihenfolge der Aufgabe zu bestimmen.  Beim ersten Zug haben wir die M√∂glichkeit, jeden Chip (ich werde weiterhin Objekte nennen) aus H zu entfernen, der beim n√§chsten Zug verf√ºgbar ist - alle verbleibenden H-1 oder zwei Chips in der N√§he (es gibt nicht mehr als solche Paare als H-2) gibt die Gesamtzahl der Optionen Hx (H-1 + H-2) an.  Es ist leicht zu erkennen, dass wir nach dem dritten Zug Hx (H-1 + H-2) x (H-2 + H-3 + Œî) und so weiter haben. <br><br>  Wenn wir uns in jeder Klammer nur auf die ersten Terme der Summe beschr√§nken, erhalten wir eine Sch√§tzung der Gesamtzahl der Z√ºge als H!, Die uns eine Sch√§tzung in Quadraturen von H ^ H gibt. <br><br>  Dies ist ein sehr unangenehmes Ergebnis, das behauptet, dass wir sehr gro√üe Probleme mit signifikantem H haben werden, so dass die "frontale" Modellierung h√∂chstwahrscheinlich erhebliche Rechenkosten verursachen wird.  Zum Beispiel m√ºssen wir f√ºr 16 Chips in der Startposition ungef√§hr 16! = 1013 Z√ºge ber√ºcksichtigen, und wenn ein Zug 10E-9 Sekunden betr√§gt (ziemlich optimistische Sch√§tzung), betr√§gt die Gesamtzeit ungef√§hr 10E4 Sekunden oder fast 3 Stunden, was ein bisschen viel ist , aber akzeptabel, aber f√ºr nur 20 Chips betr√§gt die erwartete Berechnungszeit 77 Jahre, was eindeutig nicht akzeptabel ist.  Factorial w√§chst sehr schnell und es gibt nichts zu tun. <br><br>  Wir machen darauf aufmerksam, dass die Anzahl der Z√ºge die Anzahl der m√∂glichen Positionen, die nur 2 ^ N betr√§gt, deutlich √ºbersteigt, und es ist offensichtlich, dass wir f√ºr 16 Chips 10E (13-5) = 10E7-mal in eine separate Position fallen werden, was f√ºr jeden ein ziemlich allt√§gliches Ereignis ist Suchaufgaben.  Denken Sie daran, es wird uns sp√§ter n√ºtzlich sein. <br><br>  Trotzdem werden wir ein Programm schreiben, f√ºr das wir das Modell bestimmen werden.  Zuerst nummerieren wir die Chips von 1 bis H, erstellen dann ein Array mit der Anzahl der Elemente H und bestimmen, dass die Nummer 1 im Array-Element mit dem Index n das Vorhandensein der Chipnummer n und die Nummer 0 bedeutet - ihre Abwesenheit an einer bestimmten Position.  Ein solches Modell ist angemessen, einfach, intuitiv und erm√∂glicht es Ihnen, Chipentfernungsvorg√§nge effektiv zu gestalten und den Zustand der "N√§he" zu bestimmen. <br><br>  Nachdem wir ein Modell (Datenstruktur) haben, k√∂nnen wir beginnen, den Algorithmus f√ºr dieses Modell zu ziehen (Eulen auf dem Globus).  Der Algorithmus der vollst√§ndigen Aufz√§hlung mit R√ºckgabe ist im Blockdiagramm einfach und besteht aus zwei unabh√§ngigen Teilen - der eigentlichen Aufz√§hlung und Bewertung von Positionen. Zun√§chst werden wir den ersten Teil implementieren.  Beachten Sie, dass dieser Algorithmus nicht am besten im Rahmen des strukturellen Programmierparadigmas implementiert werden kann und etwas effektiver w√§re, wenn wir uns erlauben, einen √úbergang zu verwenden oder den Code zu wiederholen. Aber auch ohne diese Abweichungen vom Stil ist die Implementierung keineswegs anspruchsvoll (zyklomatische Komplexit√§t ist durchaus akzeptabel). .  Da wir noch keine Bewertung eingef√ºhrt haben und das Ergebnis aus dem Programm erhalten m√∂chten, leiten wir einfach die betrachteten Positionen ab und schauen sie mit unseren Augen durch, um die korrekte Umsetzung zu bewerten und sicherzustellen, dass die Ergebnisse den erwarteten entsprechen. <br><br>  F√ºgen wir nun eine Positionssch√§tzung hinzu - nat√ºrlich ist gut geschriebener Code selbstdokumentierend (obwohl es unterschiedliche Meinungen zu dieser Aussage gibt), aber dieser Teil l√§sst sich am besten in Worten beschreiben.  Die Idee ist, dass wir eine eindeutige Bewertung der Endpositionen (in unserem Fall ist sie einzigartig und besteht aus null Chips) basierend auf den Spielregeln geben und f√ºr alle anderen Positionen eine vorl√§ufige neutrale Bewertung abgeben und dann beginnen, sie zu verfeinern, indem wir die Sch√§tzung nach oben verschieben .  Wenn Sie sich r√ºckw√§rts bewegen, √§ndert sich die Sch√§tzung der aktuellen Position um eins in Richtung von Null. Anschlie√üend wird sie invertiert und an die vorherige Position √ºbertragen, wo sie gem√§√ü den folgenden Regeln mit der vorherigen Sch√§tzung kombiniert wird: <br><br><ol><li>  neutrale Bewertung √§ndert sich zu einer neuen, </li><li>  eine positive Bewertung √§ndert sich zu einer kleineren positiven Bewertung, </li><li>  Eine negative Bewertung √§ndert sich in eine gro√üe negative oder positive. </li></ol><br>  Nachdem wir alle Schritte vollst√§ndig durchlaufen haben, ist die Bewertung der Ausgangsposition endg√ºltig. <br><br>  Wir f√ºgen unserem Verfahren zur Generierung aller Positionen Sch√§tzungen hinzu und k√∂nnen die Ergebnisse der Analyse, die in einer Tabelle angezeigt werden, bewundern, einen Fortschrittsz√§hler und einen Zeitmesser f√ºr die Analyse hinzuf√ºgen.  Auf dem gcc-Compiler (im Optimierungsmodus -O2) auf einer Maschine mit einem Prozessor habe ich eine solche Tabelle erhalten, die unsere anf√§nglichen Annahmen √ºber die faktorielle Reihenfolge der Komplexit√§t der Aufgabe vollst√§ndig best√§tigt.  Aus derselben Tabelle geht hervor, dass ich aufgeh√∂rt habe, Ergebnisse mit H √ºber 11 zu erwarten, weil die Berechnungszeit nicht mehr akzeptabel war (f√ºr mich sind Sie vielleicht bereit, eine halbe Stunde zu warten) und unsere Annahme √ºber den Kurs und die Nanosekunde nicht der Realit√§t entspricht (durchschnittliche Zeit) Ber√ºcksichtigung der Position ist 100 ns).  Es stellt sich die Frage, was wir tun sollen, wenn wir eine Sch√§tzung f√ºr mehr als 11 Chips in der Ausgangsposition haben m√∂chten. <br><br>  Wir k√∂nnten den Weg kleiner Optimierungen einschlagen, mit √úberg√§ngen und Flags spielen, in Assembler-Einf√ºgungen gehen, knifflige Vektoroperationen aus dem Befehlssystem unseres Prozessors anwenden, und auf diese Weise k√∂nnen Sie manchmal eindeutig an Geschwindigkeit gewinnen, und zwar um eine Gr√∂√üenordnung - vielleicht zwei Gr√∂√üenordnungen - Es ist sehr unwahrscheinlich, aber wir brauchen einen Gewinn von vielen Gr√∂√üenordnungen, da wir in der Gr√∂√üenordnung (und noch mehr) eine Erh√∂hung von H um eins √ºber 10 essen. √úbrigens, wenn Sie nur die Compiler-Optimierung aktivieren, wird dies etwas f√ºr uns tun und die Ausf√ºhrungszeit wird sich verringern  Ich habe 4 mal - nicht schlecht und im Einklang mit unseren Erwartungen. <br><br>  Daher m√ºssen wir zuerst versuchen, die angewandten Algorithmen zu verbessern, und die erste dieser (und die Haupt-) Verbesserung ist die Cut-Off-Brute-Force-Methode oder das "Alpha-Beta-Verfahren".  Die Hauptidee sieht ziemlich robust aus und besteht darin, dass wir, wenn wir eine bestimmte Position als eine gewinnende Position bewerten, die Bewertung f√ºr diese Position nicht mehr verbessern und zum Baum zur√ºckkehren.  Dieser Ansatz kann die Geschwindigkeit des Algorithmus erheblich erh√∂hen, insbesondere wenn wir zun√§chst erfolgreiche Z√ºge untersuchen (die zu einem Gewinn f√ºhren).  Es kann aber auch die Zeit verl√§ngern, da die √úberpr√ºfung der aktuellen Bewertung hinzugef√ºgt wird und das Verfahren zur Auswahl des Kurses kompliziert ist. Es ist sehr schwierig, den Einfluss dieser Methode im Voraus abzusch√§tzen. Es ist notwendig, ein Experiment durchzuf√ºhren.  Und noch eine √úberlegung: Wir sollten nicht vergessen, dass wir bei einer Suche mit Cut-Off und bei einer Gewinnposition eine echte, aber nicht genaue Sch√§tzung abgeben, da wir einen Teil der Optionen nicht ber√ºcksichtigen und sie in weniger Z√ºgen einen Gewinn erzielen k√∂nnten.  Wenn eine solche Abnahme der Genauigkeit zu uns passt, warum nicht diese Methode verwenden, aber f√ºr eine genaue Beurteilung funktioniert nichts als eine umfassende Suche nicht. <br><br>  Die Ergebnisse der Clipping-Aufz√§hlung sind in der folgenden Tabelle aufgef√ºhrt. Wir sehen, dass es einen Leistungsgewinn und einen signifikanten Anstieg gibt, der jedoch nicht ausreicht, um gro√üe Werte von N zu untersuchen. In welche Richtung wir unsere Forschung fortsetzen werden - zuerst werden wir uns eine andere Datenstruktur ansehen, und dann Sie haben es erraten (sch√∂n, mit einem schlauen Publikum umzugehen) ist ein weiterer Algorithmus. <br><br>  Beachten wir die Tatsache, dass die von uns verwendete Datenstruktur die Chips einzigartig macht und beispielsweise ein einzelner (nicht benachbarter) Chip in Position nicht einem einzelnen Chip in Position n + 2 entspricht, was v√∂llig falsch ist.  Wir w√§hlen das Schl√ºsselelement der Spielposition aus - die Gruppe der Chips, die sich daneben befinden, und bestimmen deren Hauptmerkmal - die Anzahl der Chips in der Gruppe.  Es sind diese Informationen, die jede Position im Spiel eindeutig bestimmen, und wir m√ºssen sie in einer f√ºr die Programmierung geeigneten Form pr√§sentieren.  Wir w√§hlen die einfachste und offensichtlichste Datenstruktur - wir starten ein Array von H-Elementen und speichern im n-Element des Arrays die Anzahl der Gruppen mit genau n Chips.  Dann zum Beispiel.  F√ºr die Startposition mit 3 Chips haben wir die Darstellung {0,0,1}.  Das Ausf√ºhrungsverfahren f√ºr die gegebene Pr√§sentation ist immer noch einfach und effektiv, obwohl es nat√ºrlich komplizierter ist als in der ersten Version.  Nach dem ersten Zug (von denen es zwei statt drei gab) erhalten wir die Positionen {0,1,0} und {2,0,0}. <br><br>  Versuchen wir, den erwarteten Gewinn bei der Anzahl der Z√ºge f√ºr eine bestimmte Datenstruktur abzusch√§tzen.  F√ºr den ersten Zug haben wir (H-1) / 2 + 1 Optionen, f√ºr den zweiten (wir haben die Gruppe H in m und N-m-1 unterteilt) (m-1) / 2 + (N-m-1-1) / 2 (nimm 1 Chip) + (m-2) / 2 + (N-m-1-2) / 2 (nimm 2 Chips) = (H-3) / 2 + (H-5) / 2 und analog Wir schlie√üen daraus, dass wir bei jedem Schritt mindestens die H√§lfte der Z√ºge speichern.  Dann sollte unser Gewinn mindestens 2 ^ H betragen, was f√ºr gro√üe H sehr, sehr gut ist.  Tats√§chlich ist die Verst√§rkung sogar noch gr√∂√üer, zum Beispiel f√ºr die Position {8,0 ...} in der ersten Ausf√ºhrungsform m√ºssen Sie 8 Z√ºge aussortieren, und in der zweiten ist nur 1 und die Verst√§rkung in diesem Fall 8-mal.  Wir k√∂nnen uns also fest auf 2 ^ H verlassen, aber viel mehr erwarten, was wir √ºberpr√ºfen werden.  Und sicher erhalten wir f√ºr das Programm gem√§√ü dieser Darstellung Tabelle 4, die letzte Zeile zeigt den Leistungsgewinn beim Umschalten auf die zweite Version der Datenstruktur (von Hand berechnet).  Das Wachstum ist einfach kolossal und wir haben zuversichtlich (am Ende) die Obergrenze der M√∂glichkeit der Analyse von bis zu 20 Chips in der Startposition zu angemessenen Zeitkosten durchbrochen. <br><br>  Dar√ºber hinaus k√∂nnen wir den Algorithmus f√ºr eine bestimmte Datenstruktur subtil optimieren und sogar einen Leistungsgewinn erzielen, aber wir werden kein so dramatisches (um Gr√∂√üenordnungen) Wachstum erzielen, was wiederum darauf hinweist, dass Wirth falsch lag.  Im obigen Programm war beispielsweise das Verfahren zum Erstellen des n√§chsten Kandidaten f√ºr den Umzug absichtlich nicht optimal, und seine offensichtliche Korrektur (√ºberlassen wir es dem neugierigen Leser) erh√∂ht die Geschwindigkeit um das Dreifache, aber dies ist eine Kleinigkeit, wenn auch eine angenehme. <br><br>  Lassen Sie uns auf die Ergebnisse achten und einige nicht offensichtliche Dinge sehen.  Zum Beispiel behauptet das Programm, dass ein garantierter Gewinn in einem direkten Spiel f√ºr 9 Chips nicht in 9 Z√ºgen erreicht wird, wie aus dem heuristischen symmetrischen Algorithmus folgt, sondern in nur 7, und der erste Zug f√§llt mit der Heuristik zusammen (und ist dar√ºber hinaus die einzige Gewinnposition ), aber der dritte und die folgenden sollten die Z√ºge des Gegners √ºberhaupt nicht wiederholen, wie aus dem naiven Algorithmus hervorgeht, und der Schl√ºssel hier ist {1,0,0,1}, was eine Bewertung von +4 hat.  Nachdem wir eine genaue Einsch√§tzung des Spiels abgegeben haben, k√∂nnen wir interessante Fragen zum Vorhandensein von Positionen mit einer stabilen Einsch√§tzung (in der wir den Gegner f√ºr sich selbst gehen lassen k√∂nnen), zum Vorhandensein von Schl√ºsselpositionen im Aufz√§hlungsbaum, zum Finden von Positionen mit dem einzig richtigen Zug usw. stellen sogar Antworten auf diese und die richtigen Fragen erhalten). <br><br>  Hier ist die √úbersichtstabelle <br><table><tbody><tr><th>  Chips </th><th>  Direkt </th><th>  Feedback </th><th>  Positionen / Zeit </th><th>  Positionen / Zeit </th></tr><tr><td>  1 </td><td>  1 </td><td>  -1 </td><td>  1/0 </td><td>  1/0 </td></tr><tr><td>  2 </td><td>  -2 </td><td>  2 </td><td>  4/0 </td><td>  2/0 </td></tr><tr><td>  3 </td><td>  3 </td><td>  -3 </td><td>  17/0 </td><td>  7/0 </td></tr><tr><td>  4 </td><td>  -4 </td><td>  -3 </td><td>  82/0 </td><td>  20/0 </td></tr><tr><td>  5 </td><td>  5 </td><td>  4 </td><td>  463/0 </td><td>  71/0 </td></tr><tr><td>  6 </td><td>  5 </td><td>  -5 </td><td>  3032/0 </td><td>  263/0 </td></tr><tr><td>  7 </td><td>  7 </td><td>  6 </td><td>  22693/0 </td><td>  1107/0 </td></tr><tr><td>  8 </td><td>  -8 </td><td>  -7 </td><td>  191422/0 </td><td>  4945/0 </td></tr><tr><td>  9 </td><td>  7 </td><td>  -7 </td><td>  1798427 / 0.1 </td><td>  24.283 / 0 </td></tr><tr><td>  10 </td><td>  9 </td><td>  8 </td><td>  18634228 / 0,8 </td><td>  125419/0 </td></tr><tr><td>  11 </td><td>  11 </td><td>  -9 </td><td>  211177537 / 10.4 </td><td>  699165 / 0,1 </td></tr><tr><td>  12 </td><td>  -10 </td><td>  -9 </td><td>  *** / 127 </td><td>  4057686 / 0,6 </td></tr><tr><td>  13 </td><td>  11 </td><td>  10 </td><td></td><td>  25056975 / 3,84 </td></tr><tr><td>  14 </td><td>  -12 </td><td>  -11 </td><td></td><td>  160643971/28 </td></tr><tr><td>  15 </td><td>  13 </td><td>  12 </td><td></td><td>  1082854607/213 </td></tr><tr><td>  16 </td><td>  -14 </td><td>  -13 </td><td></td><td>  *** / 1698 </td></tr></tbody></table>  Wir sehen jedoch, dass die Sch√§tzung der Betriebszeit faktoriell blieb, wenn auch mit einem signifikanten R√ºckgang der Wachstumsrate.  Lassen Sie uns nach anderen M√∂glichkeiten suchen, um den Spielbaum zu erkunden. <br><br>  Wir haben den Top-Down-Algorithmus perfektioniert (nat√ºrlich haben wir ihn nicht in der h√§sslichen Form fertiggestellt, die ich auf der R√ºckseite des Umschlags skizziert habe. Sie k√∂nnen die Leistung erheblich verbessern, indem Sie die grundlegenden Verfahren sorgf√§ltig umschreiben. Dies ist sicher m√∂glich, aber das Problem ist nicht grundlegend entscheidet), also gehen wir in die andere Richtung - von unten nach oben.  Die Idee dieser Methode ist intuitiv einfach und verst√§ndlich, aber f√ºr den menschlichen Gebrauch sehr schwierig. Wir gehen von der endg√ºltigen Position aus, die nach den Spielregeln gesch√§tzt wird, und beginnen, die Sch√§tzung nach den gleichen Regeln wie bei der Top-Down-Suche auf den Baum zu √ºbertragen.  Gleichzeitig erw√§gen wir nat√ºrlich nicht m√∂gliche Bewegungen von der aktuellen Position nach unten, aber wir betrachten alle Positionen, von denen aus wir in einer Bewegung in die aktuelle Position gelangen k√∂nnten.  Wir √ºbertragen die Sch√§tzung gem√§√ü den oben genannten Regeln.  Dar√ºber hinaus wenden wir dieses Verfahren iterativ an und wenn es keine Ergebnisse mehr liefert, dh in der n√§chsten Runde hat keine einzige Position die Bewertung ge√§ndert, die Aufgabe ist abgeschlossen und die Bewertung der Ausgangsposition ist korrekt und genau.  Mit diesem Ansatz k√∂nnen Sie die Suchzeit erheblich verk√ºrzen, insbesondere wenn Sie einige Verbesserungen vornehmen. Er weist jedoch einen starken Nachteil auf (und dies ist ein Klassiker - wir √§ndern die Speicherzeit), wodurch der Umfang erheblich eingeschr√§nkt wird - hohe Speicheranforderungen, da Sch√§tzungen gespeichert werden m√ºssen     ,          (     ).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Fall des fraglichen Spiels bietet sich die Bitrepr√§sentationsmethode f√ºr die erste Datenstruktur an. Es gibt andere Methoden, die die Menge des erforderlichen Speichers reduzieren k√∂nnen (Speichern nur der drei betrachteten Baumebenen mit Ausnahme der unteren Schicht), aber nat√ºrlich durch Verschlechterung der Leistung, da die Suche sehr nicht trivial wird. F√ºr H nicht gr√∂√üer als 20 betr√§gt die Gesamtzahl der Positionen jedoch nicht mehr als 2 ^ 20, und ein Array dieser Gr√∂√üe im Speicher f√ºr Elemente, die eine Zahl von -20 bis 20 enthalten, dh eine 8-Bit-Zahl, kann ich mir durchaus vorstellen und seine Umsetzung wird nicht schwierig sein. Es ist also durchaus m√∂glich, ein Programm f√ºr einen solchen Algorithmus zu schreiben und die resultierende Leistung zu bewerten, aber lassen Sie uns nicht eilen und Sch√§tzungen vornehmen. Welche Art von Speicher wir zuweisen m√ºssen, ist nicht schwer zu bestimmen, aber mit tempor√§ren Parametern ist es etwas komplizierter.Angenommen, wir erstellen sofort alle m√∂glichen Positionen, sie sind M, dann kann die durchschnittliche Anzahl von Z√ºgen von einer Position als nicht mehr als 2 * N gesch√§tzt werden (eine sehr grobe Sch√§tzung). Dann m√ºssen wir bei jeder Iteration nicht mehr als M * 2 * H-√úbertragung der Sch√§tzung durchf√ºhren, und da wir in jedem Zyklus die Sch√§tzung von mindestens einer Position verbessern, liegt die Gesamtarbeitszeit in der Gr√∂√üenordnung von M * 2 * H * M.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann erhalten wir f√ºr die erste Art der Darstellung der Daten 2 ^ H * M * 2 ^ H = 2 ^ (2 * H) * M (wir betonen noch einmal, dass diese Sch√§tzung von oben sehr stark ist) und zum Beispiel f√ºr H = 20 die Sch√§tzung der Suchzeit von oben -down wird 20 sein! ~ 10E18, und f√ºr die Bottom-up-Suche haben wir 2 ^ 40 * 20 = (2 ^ 10) ^ 4 * 40 = (10 ^ 3) ^ 4 * 40 ~ 10 ^ 14, dh f√ºr 20 Chips Wir gewinnen mindestens 10E6 Mal in der Zeit, was sehr gut ist. Wir werden auch f√ºr 9 anf√§ngliche Chips z√§hlen und 9! ~ 10E6 f√ºr die Top-Suche und 2 ^ 9 * 2 ^ 9 * 18 ~ 10E6 f√ºr das Bottom-Up-Screening erhalten, dh ab dieser Zahl gewinnt die Bottom-Line-Suche. Die letzte Anweisung ist etwas voreilig, da die Prozedur zur Bewertung der n√§chsten Position erheblich l√§nger geworden ist - wir m√ºssen sie unter den bereits generierten suchen, aber f√ºr diese spezielle Darstellung in Form eines Bit-Arrays wird diese Prozedur in O (1) ausgef√ºhrt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr die zweite Pr√§sentation ist es notwendig, die Anzahl der verschiedenen Positionen zu bewerten, was eine Aufgabe aus dem Bereich der Kombinatorik ist. Stellen Sie sich als Beispiel ein Spiel mit 9 Anfangschips vor, f√ºr das die Gesamtzahl der verschiedenen Positionen 1+ (1 + 4) + (1 + 3 + 2) + (1 + 3 + 3 + 2) + (1 + 2 +) betr√§gt 2 + 1 + 1) + (1 + 2 + 1 + 1) + (1 + 1 + 1) + (1 + 1) + 1 = 1 + 5 + 6 + 9 + 7 + 5 + 3 + 2 + 1 = 39. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann f√ºhrt eine Sch√§tzung nach der gleichen Methode zu einem Wert von H * M * M = 39 * 39 * 9 ~ 10E4, der im Vergleich zur ersten Darstellung zwei Gr√∂√üenordnungen schneller ist, und wenn H w√§chst, nimmt die Verst√§rkung nur zu. Verglichen mit der Suche von oben nach der zweiten Ansicht sollte man auch eine signifikante Verbesserung der Leistung erwarten, aber es ist schwieriger, sie zu bewerten, so dass es einfacher ist, es zu versuchen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie daher ein Parsing-Programm von unten nach oben ausf√ºhren, dann f√ºr die zweite Pr√§sentation. Ich werde das Programm nicht geben, ich muss den Lesern etwas f√ºr die Heimanalyse √ºberlassen. Wir sollten in sehr vern√ºnftiger Zeit Ergebnisse f√ºr signifikantes H erhalten. Ein weiterer Vorteil des Bustings von unten besteht darin, dass wir erheblich sparen k√∂nnen, indem wir die Sch√§tzung f√ºr die untere H√§lfte der Positionen festlegen (die eine geringere Anzahl von Chips als N / 2 aufweist), da die gesch√§tzte untere H√§lfte einmal ohne √Ñnderungen f√ºr die n√§chste Anzahl von Chips √ºbertragen wird, was uns einen zus√§tzlichen Gewinn einbringt 2 mal.</font></font><br><br><h4>   ‚Äî        ,         ,      .       ,     ,       (    )   . </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassend l√§sst sich sagen, dass die notwendige Erkl√§rung f√ºr diejenigen, die meinen Beitrag zu ernst genommen haben und mit (fairer) Emp√∂rung brennen - ich bin mir nicht sicher, ob die Angabe der Algorithmen als erster Begriff in der Programmdefinitionsformel ihre gr√∂√üere Bedeutung best√§tigt. Ich stimme dem vollkommen zu In bestimmten Situationen kann ein korrekt gew√§hlter Algorithmus zu einer geordneten Steigerung der Produktivit√§t f√ºhren, und ich wollte Dijkstra (den ich respektiere) nicht mit Fehlern belasten. Es war alles ein Satz, um Aufmerksamkeit zu erregen, und in dem Beitrag geht es um etwas anderes - dass die Datenstruktur auch f√ºr die Leistung √§u√üerst wichtig ist, und ich wollte dies im Designprozess nicht vergessen.</font></font><br><br>  PS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie erz√§hlen mir hier vom Publikum (hi Max), dass es eine andere Methode gibt, das Spiel zu erforschen - mathematisch, und angesichts der Hypothese des doppelten Nachnamens, dass die meisten Z√§hlspiele auf Nims Spiel zur√ºckzuf√ºhren sind, m√ºssen wir ihn nur berechnen - die Summe die Ausgangsposition (meiner Meinung nach ist die Aussage zweifelhaft), und Sie k√∂nnen das urspr√ºngliche Spiel auch in Spiele in der Grafik umwandeln (hier gibt es keine Einw√§nde), f√ºr die Sie zum Zeitpunkt der Arbeit eine Sch√§tzung von 1,878 ^ N erwarten k√∂nnen (obwohl mich die spezifische Zahl etwas verwirrt hat). </font><font style="vertical-align: inherit;">Wahrscheinlich haben diese √úberlegungen das Recht auf Leben, zumindest die Artikel dieses Inhalts sehen √ºberzeugend aus, aber ich bin ein reiner Praktiker und √ºberlasse diese Optionen wieder neugierigen Lesern (ars longa, vita brevis).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Programm ist hier versteckt</font></font></b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctime&gt; #include "stdio.h" #define MaxMax 17 #define Forward 1 // 1-   0 -  #define Version 1 // 0-   1 -   int hod[MaxMax+1],nf[MaxMax+1],oc[MaxMax+1],sm[MaxMax+1]; int lvl,count,nhod; #if Version==0 int pos[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;Max; ++i) pos[i]=1; pos[Max]=0; }; inline void FirstStep(int Max) { hod[lvl]=0; nf[lvl]=1; }; inline int ValidStep() { if ( (pos[hod[lvl]]==1) &amp;&amp; ((nf[lvl]==1) || (pos[hod[lvl]+1]==1)) ) return 1; else return 0; }; inline void MakeStep(void) { pos[hod[lvl]]=0; --count; if (nf[lvl]==2) { pos[hod[lvl]+1]=0; --count; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=-1; nf[lvl]=2; }; inline void RemoveStep(void) { pos[hod[lvl]]=1; ++count; if (nf[lvl]==2) { pos[hod[lvl]+1]=1; ++count; }; }; inline void NextStep(void) { if ((nf[lvl]==1) &amp;&amp; (lvl&gt;0)) nf[lvl]=2; else { ++hod[lvl]; nf[lvl]=1; }; }; inline int LastStep(int Max) {if (hod[lvl]&gt;=Max) return 1; else return 0; }; void print(int Max) { for (int i=0; i&lt;Max; ++i) if (pos[i]==1) printf("*"); else printf("."); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf ("%2d,%1d",hod[i],nf[i]); else printf(" "); printf("%3d ",count); for (int i=0; i&lt;Max; ++i) printf("%3d",oc[i]); printf("\n"); }; #endif #if Version==1 int gr[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;MaxMax; ++i) { gr[i]=0; }; gr[Max]=1; }; inline void FirstStep(int Max) { hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline int ValidStep(void) { if ( (gr[hod[lvl]]&gt;0) &amp;&amp; (hod[lvl]&gt;=nf[lvl]) ) return 1; else return 0; }; inline void MakeStep(void) { gr[hod[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]+=1; if (sm[lvl]&gt;0) gr[sm[lvl]]+=1; count-=nf[lvl]; }; inline void NextStep(void) { sm[lvl]++; if ( sm[lvl]*2 &gt; (hod[lvl]-nf[lvl]) ) { if ( (lvl&gt;0) &amp;&amp; (nf[lvl]==1) ) { nf[lvl]=2; sm[lvl]=0; } else { hod[lvl]-=1; sm[lvl]=0; nf[lvl]=1; }; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline void RemoveStep(void) { if (sm[lvl]&gt;0) gr[sm[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]-=1; gr[hod[lvl]]+=1; count+=nf[lvl]; }; inline int LastStep(int Max) {if (hod[lvl]&lt;=0) return 1; else return 0; }; void print(int Max) { if (Max==18) { for (int i=1; i&lt;=Max; ++i) printf("%2d,",gr[i]); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf (" =&gt;%2d:%2d,%1d,%2d",i,hod[i],nf[i],sm[i]); else printf(" "); printf(" %3d:: ",count); for (int i=0; i&lt;Max; ++i) printf("%2d",oc[i]); printf("\n"); }; }; #endif inline void MoveOc(void) { int newoc=-oc[lvl+1]; if (newoc&gt;0) ++newoc; else --newoc; if ( (oc[lvl]==0) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&gt;0) ) || ( (oc[lvl]&gt;0) &amp;&amp; (newoc&gt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&lt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) ) { oc[lvl]=newoc; // if (oc[0]&gt;0) --ur; }; }; int ocenka(int Max) { Start(Max); count=Max; nhod=0; lvl=0; FirstStep(Max); while (lvl&gt;=0) { //print(Max); if ( ValidStep()==1) { MakeStep(); ++nhod; //print(Max); if (count&gt;0) DownStep(Max); else { #if Forward==1 oc[lvl]=1; #else if (oc[lvl]==0) oc[lvl]=-1; #endif RemoveStep(); }; //print(Max); }; NextStep(); if (LastStep(Max)==1) { --lvl; if (lvl&gt;-1) { MoveOc(); RemoveStep(); NextStep(); }; }; }; return nhod; }; void reverse(void); int main(void) { int last=1; for (int i=1; i&lt;=MaxMax; ++i) { clock_t start_time = clock(); int j=ocenka(i); printf("%2d %3d %12d %5.2f %5.2f\n",i,oc[0],j,(float)j/last,(clock()-start_time)/1000.); last=j; }; return 1; };</span></span></span></span></code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420859/">https://habr.com/ru/post/de420859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420843/index.html">7. September, Jekaterinburg - ein Treffen f√ºr .NET-Entwickler</a></li>
<li><a href="../de420845/index.html">Die Z√§hmung des Hartn√§ckigen mit einer Kr√ºcke: das Loch des WLAN-Adapters WF2190 (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../de420847/index.html">Einf√ºhrung in die Shader-Programmierung f√ºr Layouts</a></li>
<li><a href="../de420853/index.html">Lernen Sie die Windows Pseudo Console (ConPTY) kennen</a></li>
<li><a href="../de420857/index.html">Nahtloses Wi-Fi-Roaming: Theorie in der Praxis</a></li>
<li><a href="../de420861/index.html">Vorbereitungen f√ºr C ++ 20. Coroutines TS Real Fallstudie</a></li>
<li><a href="../de420863/index.html">Als wir das erste russische Smartphone machten, ging es weiter</a></li>
<li><a href="../de420865/index.html">Das Prinzip der geringsten Aktion. Teil 1</a></li>
<li><a href="../de420867/index.html">Berechnung bestimmter Integrale: grundlegende Algorithmen</a></li>
<li><a href="../de420869/index.html">Evakuierung, HAMR und MAMR - drei M√∂glichkeiten, um die Kapazit√§t moderner Festplatten zu maximieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>