<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💈 🔉 🏼 RabbitMQ vs Kafka: Dua Pendekatan Perpesanan yang Berbeda 🎊 👏🏽 👨🏻‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam dua artikel terakhir , kita berbicara tentang IIoT - Internet industri hal - membangun arsitektur untuk menerima data dari sensor, menyolder sen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs Kafka: Dua Pendekatan Perpesanan yang Berbeda</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/416629/"><p>  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> terakhir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> kita berbicara tentang IIoT - Internet industri hal - membangun arsitektur untuk menerima data dari sensor, menyolder sensor itu sendiri.  Landasan arsitektur IIoT dan memang semua arsitektur yang bekerja dengan BigData adalah pemrosesan aliran data.  Ini didasarkan pada konsep olahpesan dan antrian.  Standar untuk bekerja dengan olahpesan sekarang menjadi Apache Kafka.  Namun, untuk memahami kelebihannya (dan memahami kekurangannya), akan baik untuk memahami dasar-dasar pengoperasian sistem antrian secara umum, mekanisme operasinya, pola penggunaan, dan fungsionalitas dasar. </p><br><p><img src="https://habrastorage.org/webt/-5/p1/rn/-5p1rnrr3yks4ukkp0kyovqykli.png"></p><br><p>  Kami menemukan serangkaian artikel luar biasa yang membandingkan fungsionalitas Apache Kafka dan raksasa (yang tidak diacuhkan) di antara sistem antrian - RabbitMQ.  Kami telah menerjemahkan serangkaian artikel ini, memberikan mereka komentar dan menambahkannya.  Meskipun seri ini ditulis pada bulan Desember 2017, dunia sistem pesan (dan terutama Apache Kafka) berubah begitu cepat sehingga pada musim panas 2018, beberapa hal telah berubah. </p><a name="habracut"></a><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber</a> </blockquote><br><h2 id="rabbitmq-vs-kafka">  RabbitMQ vs Kafka </h2><br><p>  Perpesanan adalah bagian utama dari banyak arsitektur, dan dua pilar di area ini adalah RabbitMQ dan Apache Kafka.  Hingga saat ini, Apache Kafka telah menjadi standar industri yang hampir dalam hal pemrosesan data dan analitik, sehingga dalam seri ini kita akan melihat lebih dekat pada RabbitMQ dan Kafka dalam konteks penggunaannya dalam infrastruktur waktu nyata. </p><br><p> Apache Kafka sekarang sedang naik daun, tetapi tampaknya mereka mulai melupakan RabbitMQ.  Semua hype berfokus pada Kafka, dan ini terjadi karena alasan yang jelas, tetapi RabbitMQ masih merupakan pilihan yang bagus untuk pengiriman pesan.  Salah satu alasan Kafka mengalihkan perhatian ke dirinya sendiri adalah obsesinya yang umum dengan skalabilitas, dan jelas Kafka lebih dapat diukur daripada RabbitMQ, tetapi kebanyakan dari kita tidak peduli dengan skala di mana RabbitMQ memiliki masalah.  Sebagian besar dari kita bukan Google atau Facebook.  Sebagian besar dari kita berurusan dengan volume pesan harian dari ratusan ribu hingga ratusan juta, dan tidak dengan volume dari miliaran ke triliunan (tetapi omong-omong, ada kasus ketika orang meningkatkan RabbitMQ ke miliaran pesan harian). </p><br><p>  Dengan demikian, dalam seri artikel kami, kami tidak akan berbicara tentang kasus-kasus di mana skalabilitas ekstrim diperlukan (dan ini adalah hak prerogatif Kafka), tetapi lebih fokus pada keunggulan unik yang ditawarkan oleh masing-masing sistem yang dipertimbangkan.  Menariknya, masing-masing sistem memiliki kelebihannya masing-masing, tetapi pada saat yang sama mereka sangat berbeda satu sama lain.  Tentu saja, saya banyak menulis tentang RabbitMQ, tetapi saya meyakinkan Anda bahwa saya tidak memberikan preferensi khusus untuk itu.  Saya suka hal-hal yang dibuat dengan baik, dan RabbitMQ dan Kafka keduanya cukup matang, dapat diandalkan dan, ya, sistem pesan yang dapat diskalakan. </p><br><p>  Kami akan mulai di tingkat atas, dan kemudian mulai mempelajari berbagai aspek dari dua teknologi ini.  Seri artikel ini ditujukan untuk para profesional yang terlibat dalam mengatur sistem pesan atau arsitek / insinyur yang ingin memahami detail dari level bawah dan aplikasinya.  Kami tidak akan menulis kode, melainkan fokus pada fungsionalitas yang ditawarkan oleh kedua sistem, templat proses perpesanan yang ditawarkan masing-masing, dan keputusan yang harus dibuat oleh pengembang dan arsitek keputusan. </p><br><h2 id="rabbitmq-protiv-kafka-dva-raznyh-podhoda-k-obmenu-soobscheniyami">  RabbitMQ vs Kafka: Dua Pendekatan Perpesanan yang Berbeda </h2><br><p>  Pada bagian ini, kita akan melihat apa RabbitMQ dan Apache Kafka, dan pendekatan mereka terhadap olahpesan.  Kedua sistem mendekati arsitektur perpesanan dari sudut yang berbeda, masing-masing memiliki kekuatan dan kelemahan.  Dalam bab ini, kami tidak akan sampai pada kesimpulan penting, melainkan, kami mengusulkan untuk mengambil artikel ini sebagai manual teknologi untuk pemula, sehingga kami dapat menyelam lebih dalam di artikel seri berikutnya. </p><br><h3 id="rabbitmq">  Rabbitmq </h3><br><p>  RabbitMQ adalah sistem manajemen antrian pesan terdistribusi.  Didistribusikan, karena biasanya berfungsi sebagai sekelompok node, di mana antrian didistribusikan di antara node dan, secara opsional, direplikasi agar tahan kesalahan dan ketersediaan tinggi.  Secara teratur, ini mengimplementasikan AMQP 0.9.1 dan menawarkan protokol lain, seperti STOMP, MQTT dan HTTP melalui modul tambahan. </p><br><p>  RabbitMQ menggunakan pendekatan perpesanan klasik dan inovatif.  Klasik dalam arti bahwa itu berfokus pada antrian pesan, dan inovatif - dalam kemungkinan routing yang fleksibel.  Fitur perutean ini adalah keunggulan uniknya.  Menciptakan sistem pengiriman pesan yang cepat, terukur, dan andal merupakan pencapaian tersendiri, tetapi fungsionalitas perutean pengiriman membuatnya sangat luar biasa di antara banyak teknologi pengiriman pesan. </p><br><h3 id="exchangei-i-ocheredi">  Pertukaran dan antrian </h3><br><p>  Ulasan yang sangat disederhanakan: </p><br><ul><li>  Penerbit (penerbit) mengirim pesan ke bursa </li><li>  Exchange'i mengirim pesan dalam antrian dan ke pertukaran lainnya </li><li>  RabbitMQ mengirimkan konfirmasi kepada penerbit setelah menerima pesan </li><li>  Penerima (konsumen) memelihara koneksi TCP yang persisten ke RabbitMQ dan mengumumkan antrian mana yang mereka terima </li><li>  RabbitMQ mendorong pesan ke penerima </li><li>  Penerima mengirim konfirmasi keberhasilan / kesalahan </li><li>  Setelah penerimaan berhasil, pesan dihapus dari antrian. </li></ul><br><p>  Daftar ini berisi sejumlah besar keputusan yang harus diambil oleh pengembang dan administrator untuk mendapatkan jaminan pengiriman yang mereka butuhkan, karakteristik kinerja, dll., Yang masing-masing akan kita bahas nanti. </p><br><p>  Mari kita lihat contoh bekerja dengan satu penerbit, pertukaran, antrian dan penerima: </p><br><p><img src="https://habrastorage.org/webt/u2/ii/3d/u2ii3dm9jk-nuzly06mpebzac8y.png"><br>  <em>Fig.</em>  <em>1. Satu penerbit dan satu penerima</em> </p><br><p>  Apa yang harus dilakukan jika Anda memiliki beberapa penerbit yang sama <br>  pesan?  Bagaimana jika kita memiliki beberapa penerima, yang masing-masing ingin menerima semua pesan? </p><br><p><img src="https://habrastorage.org/webt/ug/tw/3d/ugtw3df8efgqhmwpwfs47b9ivoo.png"><br>  <em>Fig.</em>  <em>2. Beberapa penerbit, beberapa penerima independen</em> </p><br><p>  Seperti yang Anda lihat, penerbit mengirim pesan mereka ke exchanger yang sama, yang mengirim setiap pesan dalam tiga antrian, yang masing-masing memiliki satu penerima.  Dalam kasus RabbitMQ, antrian memungkinkan penerima yang berbeda menerima semua pesan.  Bandingkan dengan grafik di bawah ini: </p><br><p><img src="https://habrastorage.org/webt/2_/dj/vd/2_djvdk1k1tnb9u-z9x3q9k2k6o.png"><br>  <em>Fig.</em>  <em>3. Beberapa penerbit, satu antrian dengan beberapa penerima yang bersaing</em> <em><br></em> </p><br><p>  Pada Gambar 3, kita melihat tiga penerima yang menggunakan antrian yang sama.  Ini adalah penerima yang bersaing, yaitu mereka bersaing untuk menerima pesan dari antrian.  Dengan demikian, dapat diharapkan bahwa rata-rata setiap penerima akan menerima sepertiga dari pesan dalam antrian.  Kami menggunakan penerima yang bersaing untuk meningkatkan skala sistem pemrosesan pesan kami, dan menggunakan RabbitMQ sangat mudah untuk melakukan ini: menambah atau menghapus penerima berdasarkan permintaan.  Tidak peduli berapa banyak penerima pesaing yang Anda miliki, RabbitMQ hanya akan mengirimkan pesan kepada satu penerima. </p><br><p>  Kita bisa menggabungkan beras.  2 dan 3 untuk menerima beberapa set penerima yang bersaing, di mana setiap set menerima setiap pesan. </p><br><p><img src="https://habrastorage.org/webt/gr/g4/pk/grg4pk5gfkbocpagiccsvcd3oro.png"><br>  <em>Fig.</em>  <em>4. Beberapa penerbit, beberapa antrian dengan penerima yang bersaing</em> </p><br><p>  Panah antara penukar dan antrian disebut binding, dan kami akan membicarakannya lebih detail. </p><br><h3 id="garantii">  Garansi </h3><br><p>  RabbitMQ memberikan jaminan "pengiriman satu kali" dan "setidaknya satu pengiriman", tetapi tidak "tepat satu pengiriman". </p><br><p>  <em>Catatan Penerjemah: Sebelum Kafka versi 0.11, pengiriman pesan pengiriman yang tepat-sekali tidak tersedia, saat ini, fungsionalitas serupa hadir di Kafka.</em> <em><br></em> </p><br><p>  Pesan dikirim dalam urutan ketika mereka tiba di antrian (setelah semua, ini adalah definisi dari antrian).  Ini tidak menjamin bahwa penyelesaian pemrosesan pesan cocok dengan urutan yang sama ketika Anda memiliki penerima yang bersaing.  Ini bukan kesalahan RabbitMQ, tetapi realitas mendasar dari pemrosesan paralel dari serangkaian pesan yang dipesan.  Masalah ini dapat diselesaikan dengan menggunakan Konsisten Hashing Exchange, seperti yang akan Anda lihat di bab berikutnya tentang template dan topologi. </p><br><h3 id="protalkivanie-push-i-predvaritelnaya-vyborka-poluchateley">  Dorong dan ambil penerima sebelumnya </h3><br><p>  RabbitMQ mendorong pesan ke penerima (ada juga API untuk menarik pesan dari RabbitMQ, tetapi fungsi ini sudah usang sekarang).  Ini dapat membanjiri penerima jika pesan masuk dalam antrian lebih cepat daripada penerima dapat memprosesnya.  Untuk menghindari hal ini, setiap penerima dapat menetapkan batas prefetch (juga dikenal sebagai batas QoS).  Bahkan, batas QoS adalah batas jumlah pesan yang belum diakui oleh penerima.  Kerjanya seperti sekering ketika penerima mulai ketinggalan. </p><br><p>  Mengapa diputuskan bahwa pesan dalam antrian didorong (dorong), dan tidak dibongkar (tarik)?  Pertama, karena ada sedikit waktu tunda.  Kedua, idealnya, ketika kami memiliki penerima yang bersaing dari antrian yang sama, kami ingin mendistribusikan beban secara merata di antara mereka.  Jika setiap penerima meminta / mengunduh pesan, maka tergantung pada seberapa banyak yang mereka minta, distribusi pekerjaan bisa menjadi agak tidak merata.  Semakin tidak merata distribusi pesan, semakin besar penundaan dan semakin hilangnya urutan pesan selama pemrosesan.  Faktor-faktor ini mengorientasikan arsitektur RabbitMQ menuju mekanisme push satu pesan pada satu waktu.  Ini adalah salah satu batasan penskalaan RabbitMQ.  Keterbatasan dimitigasi oleh fakta bahwa konfirmasi dapat dikelompokkan. </p><br><h3 id="marshrutizaciya">  Routing </h3><br><p>  Exchange pada dasarnya adalah router pesan untuk antrian dan / atau pertukaran lainnya.  Agar pesan dapat dipindahkan dari pertukaran ke antrian atau ke pertukaran lain, ikatan diperlukan.  Pertukaran yang berbeda membutuhkan ikatan yang berbeda.  Ada empat jenis pertukaran dan binding terkait: </p><br><ul><li>  Tanpa kipas  Mengarahkan semua antrian dan penukar yang terikat untuk menukar submodel Pub standar. </li><li>  Langsung (langsung).  Merutekan pesan berdasarkan kunci perutean yang dibawanya, ditetapkan oleh penerbit.  Kunci perutean adalah string pendek.  Penukar langsung mengirim pesan ke / bertukar antrian yang memiliki kunci berpasangan yang sama persis dengan kunci perutean. </li><li>  Topik (tematik).  Merutekan pesan berdasarkan kunci perutean, tetapi memungkinkan penggunaan pencocokan tidak lengkap (wildcard). </li><li>  Header (tajuk).  RabbitMQ memungkinkan Anda untuk menambahkan header penerima pesan.  Pertukaran header mengirim pesan sesuai dengan nilai header ini.  Setiap penjilidan menyertakan kecocokan yang tepat dari nilai header.  Anda dapat menambahkan beberapa nilai ke penjilidan dengan nilai APAPUN atau SEMUA yang diperlukan untuk mencocokkan. </li><li>  Hashing yang Konsisten.  Ini adalah penukar yang hash baik kunci perutean atau header pesan, dan mengirim hanya dalam satu antrian.  Ini berguna ketika Anda harus mematuhi pemrosesan jaminan pesanan dan masih dapat mengukur penerima. </li></ul><br><p><img src="https://habrastorage.org/webt/jb/2d/gr/jb2dgryq0qn6bivddj265nvuyeu.png"><br>  <em>Fig.</em>  <em>5. Contoh pertukaran topik</em> </p><br><p>  Kami juga akan mempertimbangkan perutean lebih detail, tetapi contoh pertukaran topik diberikan di atas.  Dalam contoh ini, penerbit menerbitkan log kesalahan menggunakan format kunci rute LEVEL (Level Kesalahan) .AppName. </p><br><p>  Antrian 1 akan menerima semua pesan karena menggunakan nomor wildcard dengan beberapa kata. </p><br><p>  Antrian 2 akan menerima level apa pun dari pendataan aplikasi ECommerce.WebUI.  Ini menggunakan wildcard *, sehingga menangkap tingkat penamaan topik tunggal (ERROR.Ecommerce.WebUI, NOTICE.ECommerce.WebUI, dll.). </p><br><p>  Antrian 3 akan menampilkan semua pesan KESALAHAN dari aplikasi apa pun.  Ini menggunakan wildcard # untuk menutup semua aplikasi (ERROR.ECommerce.WebUi, ERROR.SomeApp.SomeSublevel, dll.). </p><br><p>  Berkat empat metode perutean pesan dan dengan kemampuan untuk bertukar pesan untuk mengirim pesan ke pertukaran lain, RabbitMQ memungkinkan Anda untuk menggunakan satu set templat pertukaran pesan yang kuat dan fleksibel.  Selanjutnya kita akan berbicara tentang pertukaran dengan pertukaran surat mati, tentang pertukaran dan antrian tanpa data (pertukaran sesaat dan antrian), dan RabbitMQ akan memperluas potensi penuhnya. </p><br><h3 id="exchangei-s-nedostavlennymi-soobscheniyami">  Pertukaran Tidak Terkirim </h3><br><p>  <em>Catatan Penerjemah: Ketika pesan dari antrian tidak dapat diterima karena satu dan lain alasan (kekuatan konsumen tidak cukup, masalah jaringan, dll.), Mereka dapat ditunda dan diproses secara terpisah.</em> </p><br><p>  Kami dapat mengonfigurasi antrian sehingga pesan dikirim untuk dipertukarkan dalam kondisi berikut: </p><br><ul><li>  Antrian melebihi jumlah pesan yang ditentukan. </li><li>  Antrian melebihi jumlah byte yang ditentukan. </li><li>  Waktu Pengiriman Pesan (TTL) telah kedaluwarsa.  Penerbit dapat mengatur umur pesan, dan antrian itu sendiri juga dapat memiliki TTL yang ditentukan untuk pesan tersebut.  Dalam hal ini, TTL yang lebih pendek dari keduanya akan digunakan. </li></ul><br><p>  Kami membuat antrian yang terikat untuk bertukar dengan pesan yang tidak terkirim, dan pesan-pesan ini disimpan di sana sampai beberapa tindakan diambil. </p><br><p>  Seperti banyak fungsi RabbitMQ, pertukaran dengan pesan yang tidak terkirim memungkinkan untuk menggunakan templat yang awalnya tidak disediakan.  Kami dapat menggunakan pesan dan pertukaran TTL dengan pesan yang tidak terkirim untuk menerapkan antrian yang ditangguhkan dan coba lagi antrian. </p><br><h3 id="obmenniki-i-ocheredi-bez-dannyh">  Penukar dan antrian tanpa data </h3><br><p>  Pertukaran dan antrian dapat dibuat secara dinamis, dan Anda dapat menetapkan kriteria untuk penghapusan otomatisnya.  Ini memungkinkan penggunaan pola seperti RPC berbasis pesan. </p><br><h3 id="dopolnitelnye-moduli">  Modul tambahan </h3><br><p>  Plug-in pertama yang mungkin ingin Anda instal adalah plugin manajemen, yang menyediakan server HTTP dengan antarmuka web dan API REST.  Sangat mudah untuk menginstal dan memiliki antarmuka yang mudah digunakan.  Menyebarkan skrip melalui REST API juga sangat sederhana. </p><br><p>  Selain itu: </p><br><ul><li>  Pertukaran Hashing yang Konsisten, Pertukaran Sharding, dan banyak lagi </li><li>  protokol seperti STOMP dan MQTT </li><li>  kait web </li><li>  jenis penukar tambahan </li><li>  Integrasi SMTP </li></ul><br><p>  Ada banyak hal lain yang dapat dikatakan tentang RabbitMQ, tetapi ini adalah contoh yang baik yang memungkinkan Anda untuk menggambarkan apa yang dapat dilakukan RabbitMQ.  Sekarang kita melihat Kafka, yang menggunakan pendekatan yang sama sekali berbeda untuk olahpesan dan, pada saat yang sama, juga memiliki serangkaian fitur unik dan menarik. </p><br><h3 id="apache-kafka">  Apache kafka </h3><br><p>  Kafka adalah log komit terdistribusi terdistribusi.  Kafka tidak memiliki konsep antrian, yang mungkin tampak aneh pada awalnya, mengingat bahwa itu digunakan sebagai sistem pesan.  Antrian telah lama identik dengan sistem pengiriman pesan.  Pertama, mari kita lihat apa arti "log komit perubahan terdistribusi, direplikasi": </p><br><ul><li>  Didistribusikan karena Kafka digunakan sebagai sekelompok node, baik untuk toleransi kesalahan dan untuk penskalaan </li><li>  Digandakan, karena pesan biasanya direplikasi pada banyak node (server). </li><li>  Log komit karena pesan disimpan dalam log yang tersegmentasi dan hanya ditambahkan yang disebut topik.  Konsep logging ini adalah keunggulan unik utama Kafka. </li></ul><br><p>  Memahami jurnal (dan topik) dan partisi adalah kunci untuk memahami Kafka.  Jadi bagaimana perbedaan log yang dipartisi dengan satu set antrian?  Mari kita bayangkan seperti apa bentuknya. </p><br><p><img src="https://habrastorage.org/webt/sg/r-/lr/sgr-lrlwlvgr-hxciwvo5uk3ix0.png"><br>  <em>Fig.</em>  <em>6 Satu produser, satu segmen, satu penerima</em> </p><br><p>  Alih-alih menempatkan pesan dalam antrian FIFO dan memantau status pesan ini dalam antrian, seperti yang dilakukan RabbitMQ, Kafka hanya menambahkannya ke log, dan itu saja. </p><br><p>  Pesan tetap ada, terlepas dari apakah pesan itu diterima satu kali atau lebih.  Itu dihapus sesuai dengan kebijakan penyimpanan, juga disebut periode waktu jendela.  Bagaimana informasi diambil dari topik? </p><br><p>  Setiap penerima melacak di mana ia berada di log: ada pointer ke pesan terakhir yang diterima dan pointer ini disebut alamat offset.  Penerima mendukung alamat ini melalui pustaka klien, dan tergantung pada versi Kafka, alamat tersebut disimpan di ZooKeeper atau di Kafka itu sendiri. </p><br><p>  Ciri khas dari model penjurnalan adalah ia secara instan menghilangkan banyak kesulitan terkait status pengiriman pesan dan, yang lebih penting bagi penerima, memungkinkan mereka untuk memundurkan, mengembalikan, dan menerima pesan di alamat relatif sebelumnya.  Misalnya, bayangkan Anda menggunakan layanan yang mengeluarkan faktur yang memperhitungkan pesanan akun yang dilakukan oleh pelanggan.  Layanan memiliki kesalahan, dan itu tidak benar menghitung semua tagihan dalam 24 jam.  Dengan RabbitMQ terbaik, Anda harus mempublikasikan pesanan ini entah bagaimana hanya pada layanan akun.  Tetapi dengan Kafka, Anda cukup memindahkan alamat relatif untuk penerima ini 24 jam yang lalu. </p><br><p>  Jadi, mari kita lihat tampilannya ketika ada topik di mana ada satu partisi dan dua penerima, masing-masing harus menerima setiap pesan. </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Fig.</em>  <em>7. Satu produser, satu partisi, dua penerima independen</em> </p><br><p>  Seperti dapat dilihat dari diagram, dua penerima independen menerima partisi yang sama, tetapi membaca di alamat offset yang berbeda.  Mungkin layanan penagihan membutuhkan waktu lebih lama untuk memproses pesan daripada layanan pemberitahuan push.  atau mungkin layanan penagihan tidak tersedia untuk beberapa waktu dan mencoba untuk mengejar ketinggalan nanti.  Atau mungkin ada kesalahan, dan alamat offset harus ditunda selama beberapa jam. </p><br><p>  Sekarang anggaplah bahwa layanan penagihan harus dibagi menjadi tiga bagian, karena tidak dapat mengikuti kecepatan pesan.  Dengan RabbitMQ, kami cukup menggunakan dua aplikasi layanan penagihan lagi yang didapat dari antrian penagihan.  Tetapi Kafka tidak mendukung penerima yang bersaing di partisi yang sama, blok konkurensi Kafka adalah partisi itu sendiri.  Karena itu, jika kita membutuhkan tiga penerima tagihan, kita memerlukan setidaknya tiga partisi.  Jadi sekarang kita punya: </p><br><p><img src="https://habrastorage.org/webt/3k/fn/rd/3kfnrdjpllbt0nqidfaxrveqvfc.png"><br>  <em>Fig.</em>  <em>8. Tiga partisi dan dua grup yang terdiri dari tiga penerima</em> </p><br><p>  Dengan demikian, dapat dipahami bahwa Anda membutuhkan sekurang-kurangnya partisi sebanyak penerima horizontal yang paling diskalakan.  Mari kita bicara sedikit tentang partisi. </p><br><h3 id="particii-i-gruppy-poluchateley">  Partisi dan Grup Penerima </h3><br><p>  Setiap partisi adalah file terpisah di mana urutan pesan dijamin.  Ini penting untuk diingat: pesanan pesan dijamin hanya dalam satu partisi.  Di masa depan, ini dapat menyebabkan beberapa kontradiksi antara persyaratan untuk antrian pesan dan persyaratan untuk kinerja, karena kinerja di Kafka juga diskalakan oleh partisi.  Partisi tidak dapat mendukung penerima yang bersaing, sehingga aplikasi penagihan kami hanya dapat menggunakan satu bagian untuk setiap bagian. </p><br><p>  Pesan dapat dialihkan ke segmen dengan algoritma siklik atau melalui fungsi hash: hash (kunci pesan)% jumlah partisi.      ,      ,     , ,   ,     ,     .            . </p><br><p>       RabbitMQ.                .   ,     RabbitMQ    ,              .  ,                . </p><br><p>   RabbitMQ                    .  Kafka ,      . </p><br><p>  ,   ,    Kafka   ,   RabbitMQ   —    . RabbitMQ     ,            . Kafka      ,      . ,        ,  Kafka     ,     . </p><br><p> ,     ,      ,           (  ).       ,          ,     .  ,      ,      ,        . </p><br><p>      RabbitMQ —   Consistent Hashing exchange,      .   Kafka'   ,  Kafka      ,             ,   , ,     ,      -.  RabbitMQ      ,     ,    ,    . </p><br><p>     :   ,     ,    Id 1000     ,     Id 1000    .    ,    ,    .   ,      . </p><br><h3 id="protalkivanie-push-protiv-vygruzki-pull">  (push)   (pull) </h3><br><p> RabbitMQ    (push) ,  ,          .                RabbitMQ   .   , Kafka    (pull),         .     ,          , Kafka  long-polling. </p><br><p>   (pull)    Kafka -  .  Kafka        ,           ,       . </p><br><p>       RabbitMQ,             ,     ,       ,      .   Kafka       ,            . </p><br><h3 id="publikaciya-i-podpiska">    </h3><br><p> Kafka    /»    ,   ,       .       ,            . </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Fig.</em> <em>9.     </em> </p><br><p>       ,       ,       Kafka     : </p><br><p> . 10.  ,         <br> <em><img src="https://habrastorage.org/webt/zl/uu/eu/zluueuxxppnji50tgqnar-pnmfk.png"></em> </p><br><p>           ,   : </p><br><p><img src="https://habrastorage.org/webt/xo/bw/op/xobwopr8b9fey8huqbclx85mh4y.png"><br>  <em>Fig.</em> <em>11.      </em> </p><br><p>         , ,               . </p><br><p> ,     ,  ,     ,  . </p><br><p><img src="https://habrastorage.org/webt/uf/wn/a4/ufwna4h-bmmmr48gp0yo8akk4je.png"><br>  <em>Fig.</em> <em>12.   </em> </p><br><p>          .         . </p><br><p><img src="https://habrastorage.org/webt/ok/vs/ce/okvsce2-xvrnztcupmx-fkbyg5w.png"></p><br><p>      : </p><br><ul><li>      </li><li>      ( ,       ) </li><li>    </li></ul><br><p>           ,               .     ,   ,    . </p><br><p>     Kafka –       , , ,     , ,     .    .            ,         .  ,   ,     . </p><br><h3 id="szhatie-zhurnala">   </h3><br><p>     —       . ,        50 .        –  .   ,   ,         ,  . </p><br><p>  ,    ,     .  ,    ,       .           ,         .  ,    ,      ,    . </p><br><p>                    .   ,  ,        . </p><br><h3 id="podrobnee-ob-uporyadochenii-soobscheniy">     </h3><br><p>  ,           RabbitMQ,    Kafka,   Kafka   .  RabbitMQ           ,    ,   ZooKeeper  Consul. </p><br><p>   RabbitMQ    ,    Kafka.      RabbitMQ,     ,      .  :            . </p><br><p>    .        ,         .     .         ,    .            .       .  ,   ,    -   . </p><br><p>           ,   Kafka,     .     .  ,         ,       . </p><br><p>  ,    . RabbitMQ        ,  Kafka        . </p><br><h3 id="vyvody">  Kesimpulan </h3><br><p> RabbitMQ          ,    .           ,     ,     .    ,           .             ,     ,    . </p><br><p>   Kafka         .               ,         .   Kafka       ,  RabbitMQ    . ,  Kafka    ,  RabbitMQ,         ,       . </p><br><p>              RabbitMQ. </p><br><blockquote> , ,      IoT  ,    . : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">t.me/justiothings</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416629/">https://habr.com/ru/post/id416629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416619/index.html">Buka webinar "Membuat situs web pada kerangka Yii2"</a></li>
<li><a href="../id416621/index.html">Homo Extensis. Memperluas kemampuan manusia atau cara menggabungkan manusia dan robot</a></li>
<li><a href="../id416623/index.html">Objektivitas psikoterapi</a></li>
<li><a href="../id416625/index.html">Sistem pengenalan wajah baru yang dipasang oleh polisi London tidak dapat mengenali siapa pun</a></li>
<li><a href="../id416627/index.html">Manajemen konveyor TI, atau di sana dan di belakang</a></li>
<li><a href="../id416633/index.html">QUIC, TLS 1.3, DNS-over-HTTPS, lalu di mana-mana</a></li>
<li><a href="../id416635/index.html">Dari kanan ke kiri. Cara mengubah antarmuka situs di bawah RTL</a></li>
<li><a href="../id416637/index.html">Musik dari kertas dan kardus: sejarah singkat variophone dan "suara yang ditarik"</a></li>
<li><a href="../id416639/index.html">Wawancara dengan pelopor peremajaan</a></li>
<li><a href="../id416641/index.html">8 tahap proses pengembangan antarmuka aplikasi seluler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>