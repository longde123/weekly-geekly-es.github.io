<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💯 🤦 🌛 Penggaruk paling umum saat menggunakan printf dalam program untuk mikrokontroler 🗑️ 👆 🍤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari waktu ke waktu dalam proyek saya, saya harus menggunakan printf dalam hubungannya dengan port serial (UART atau abstraksi melalui USB, mensimulas...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penggaruk paling umum saat menggunakan printf dalam program untuk mikrokontroler</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459420/">  Dari waktu ke waktu dalam proyek saya, saya harus menggunakan printf dalam hubungannya dengan port serial (UART atau abstraksi melalui USB, mensimulasikan port serial).  Dan, seperti biasa, banyak waktu berlalu antara aplikasi dan saya berhasil sepenuhnya melupakan semua nuansa yang perlu diperhitungkan sehingga bekerja normal dalam proyek besar. <br><br>  Dalam artikel ini, saya telah mengkompilasi nuansa top saya sendiri yang muncul saat menggunakan printf dalam program untuk mikrokontroler, diurutkan berdasarkan bukti dari yang paling jelas hingga sepenuhnya tidak jelas. <br><a name="habracut"></a><br><h2>  Pengantar singkat </h2><br>  Bahkan, untuk menggunakan printf dalam program untuk mikrokontroler, itu sudah cukup: <ul><li>  termasuk file header dalam kode proyek; </li><li>  mendefinisikan kembali fungsi sistem _write untuk output ke port serial; </li><li>  Jelaskan bertopik panggilan sistem yang diperlukan oleh penghubung (_fork, _wait, dan lainnya); </li><li>  gunakan panggilan printf dalam proyek. </li></ul><br>  Padahal, tidak semuanya begitu sederhana. <br><br><h2>  Jelaskan semua bertopik, bukan hanya yang bekas. </h2><br>  Kehadiran sekelompok tautan yang tidak jelas ketika membangun proyek pada awalnya mengejutkan, tetapi setelah membaca sedikit, menjadi jelas apa dan mengapa.  Di semua proyek saya, saya sedang menghubungkan <a href="">submodule</a> ini.  Jadi, dalam proyek utama, saya mendefinisikan kembali hanya metode yang saya butuhkan (hanya _write dalam kasus ini), dan sisanya tetap tidak berubah. <br><br>  Penting untuk dicatat bahwa semua bertopik harus fungsi C.  Bukan C ++ (atau dibungkus dengan extern “C”).  Kalau tidak, tata letak akan gagal (ingat perubahan nama selama perakitan dengan G ++). <br><br><h2>  Dalam _write datang 1 karakter </h2><br>  Terlepas dari kenyataan bahwa prototipe metode _write memiliki argumen yang melewati panjang pesan yang ditampilkan, ia memiliki nilai 1 (pada kenyataannya, kita sendiri akan membuatnya selalu menjadi 1, tetapi lebih lanjut tentang itu nanti). <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { ... }</code> </pre> <br>  Di Internet, Anda sering dapat melihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerapan</a> metode ini: <br><div class="spoiler">  <b class="spoiler_title">Implementasi fungsi _write yang sering</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uart_putc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); {} USART_SendData(USART2, (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) ch); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _write_r (struct _reent *r, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> file, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { r = r; file = file; ptr = ptr; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 int index; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* For example, output string by UART */</span></span></span><span class="hljs-meta"> for(index=0; index&lt;len; index++) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ptr[index] == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\n'</span></span></span><span class="hljs-meta">) { uart_putc(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">); } uart_putc(ptr[index]); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> return len; }</span></span></code> </pre> <br></div></div><br>  Implementasi semacam itu memiliki kelemahan sebagai berikut: <br><ul><li>  produktivitas rendah; </li><li>  ketidakamanan streaming; </li><li>  ketidakmampuan untuk menggunakan port serial untuk tujuan lain; </li></ul><br><br><h3>  Performa rendah </h3><br>  Performa lambat disebabkan oleh pengiriman byte menggunakan sumber daya prosesor: Anda harus memantau register status daripada menggunakan DMA yang sama.  Untuk mengatasi masalah ini, Anda dapat menyiapkan buffer untuk pengiriman terlebih dahulu, dan saat menerima karakter akhir baris (atau mengisi buffer) kirim.  Metode ini membutuhkan memori buffer, tetapi secara signifikan meningkatkan kinerja dengan pengiriman yang sering. <br><div class="spoiler">  <b class="spoiler_title">Contoh implementasi _write dengan buffer</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"uart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;errno.h&gt; #include &lt;sys/unistd.h&gt; extern mc::uart uart_1; extern "C" { //      uart. static const uint32_t buf_size = 254; static uint8_t tx_buf[buf_size] = {0}; static uint32_t buf_p = 0; static inline int _add_char (char data) { tx_buf[buf_p++] = data; if (buf_p &gt;= buf_size) { if (uart_1.tx(tx_buf, buf_p, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } buf_p = 0; } return 0; } // Putty  \r\n    //    . static inline int _add_endl () { if (_add_char('\r') != 0) { return -1; } if (_add_char('\n') != 0) { return -1; } uint32_t len = buf_p; buf_p = 0; if (uart_1.tx(tx_buf, len, 100) != mc_interfaces::res::ok) { errno = EIO; return -1; } return 0; } int _write (int file, char *data, int len) { len = len; //   . if ((file != STDOUT_FILENO) &amp;&amp; (file != STDERR_FILENO)) { errno = EBADF; return -1; } //     //   \n. if (*data != '\n') { if (_add_char(*data) != 0) { return -1; } } else { if (_add_endl() != 0) { return -1; } } return 1; } }</span></span></span></span></code> </pre> </div></div><br>  Di sini, objek uart, uart_1, bertanggung jawab untuk mengirim langsung menggunakan dma.  Objek menggunakan metode FreeRTOS untuk memblokir akses pihak ketiga ke objek pada saat mengirim data dari buffer (mengambil dan mengembalikan mutex).  Jadi, tidak ada yang bisa menggunakan objek uart saat mengirim dari utas lainnya. <br>  Beberapa tautan: <br><ul><li>  _write kode fungsi sebagai bagian dari proyek nyata <a href="">di sini</a> </li><li>  antarmuka kelas uart ada <a href="">di sini</a> </li><li>  implementasi antarmuka kelas uart di bawah stm32f4 di <a href="">sini</a> dan <a href="">di sini</a> </li><li>  Instansiasi kelas UART sebagai bagian dari proyek <a href="">di sini</a> </li></ul><br><br><h3>  Ketidakamanan streaming </h3><br>  Implementasi ini juga tetap tidak terlindungi, karena tidak ada yang mengganggu aliran FreeRTOS yang berdekatan untuk mulai mengirim saluran lain ke printf dan dengan demikian menggiling buffer yang saat ini sedang dikirim (mutex di dalam uart melindungi objek dari digunakan dalam aliran yang berbeda, tetapi data tidak dikirimkan kepada mereka. )  Jika ada risiko bahwa printf dari thread lain akan dipanggil, maka diperlukan untuk mengimplementasikan objek layer yang akan memblokir akses ke printf sepenuhnya.  Dalam kasus khusus saya, hanya satu utas yang berinteraksi dengan printf, jadi komplikasi tambahan hanya akan mengurangi kinerja (penangkapan dan pelepasan mutex di dalam lapisan) secara konstan. <br><br><h3>  Ketidakmampuan untuk menggunakan port serial untuk tujuan lain </h3><br>  Karena kami mengirim hanya setelah seluruh string diterima (atau buffer penuh), alih-alih objek uart, Anda dapat memanggil metode konverter ke beberapa antarmuka tingkat atas untuk transfer paket berikutnya (misalnya, pengiriman dengan jaminan sesuai dengan protokol transmisi yang mirip dengan paket modbus transaksi).  Ini akan memungkinkan Anda untuk menggunakan satu uart baik untuk menampilkan informasi debug, dan, misalnya, untuk interaksi pengguna dengan konsol manajemen (jika tersedia di perangkat).  Cukup menulis desompresor di sisi penerima. <br><br><h2>  Secara default, output float tidak berfungsi </h2><br>  Jika Anda menggunakan newlib-nano, maka secara default printf (dan juga semua turunannya seperti sprintf / snprintf ... dan lainnya) tidak mendukung output dari nilai float.  Ini mudah dipecahkan dengan menambahkan bendera tautan berikut ke proyek. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS -Wl,-u,vfprintf; -Wl,-u,_printf_float; -Wl,-u,_scanf_float; <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre> <br>  Lihat daftar lengkap bendera di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  Program membeku di suatu tempat di perut printf </h2><br>  Ini adalah satu lagi kekurangan di flag-flag linker.  Agar firmware dapat dikonfigurasi dengan versi perpustakaan yang diinginkan, Anda harus secara eksplisit menentukan parameter prosesor. <br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(HARDWARE_FLAGS -mthumb; -mcpu=cortex-m4; -mfloat-abi=hard; -mfpu=fpv4-sp-d16;) <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span>(LD_FLAGS <span class="hljs-variable"><span class="hljs-variable">${HARDWARE_FLAGS}</span></span> <span class="hljs-string"><span class="hljs-string">"_"</span></span>)</code> </pre><br>  Lihat daftar lengkap bendera di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  printf memaksa mikrokontroler untuk masuk ke kesalahan yang sulit </h2><br>  Setidaknya ada dua alasan: <br><ul><li>  masalah tumpukan; </li><li>  masalah dengan _sbrk; </li></ul><br><h3>  Masalah tumpukan </h3><br>  Masalah ini benar-benar memanifestasikan dirinya ketika menggunakan FreeRTOS atau OS lainnya.  Masalahnya adalah menggunakan buffer.  Paragraf pertama mengatakan bahwa dalam _write masing-masing 1 byte.  Agar ini terjadi, Anda harus melarang penggunaan buffering dalam kode Anda sebelum menggunakan printf untuk pertama kalinya. <br><pre> <code class="cpp hljs">setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>); setvbuf(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, _IONBF, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  Dari deskripsi fungsi, berikut bahwa salah satu dari nilai berikut ini dapat diatur dengan cara yang sama: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOFBF 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set fully buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOLBF 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set line buffered */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IONBF 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* setvbuf should set unbuffered */</span></span></span></span></code> </pre> <br>  Namun, ini dapat menyebabkan limpahan tumpukan tugas (atau interupsi jika Anda tiba-tiba orang yang sangat buruk yang memanggil printf dari interupsi). <br><br>  Secara teknis murni, adalah mungkin untuk mengatur tumpukan dengan sangat hati-hati untuk setiap aliran, tetapi pendekatan ini membutuhkan perencanaan yang cermat dan sulit untuk menangkap kesalahan yang dibawanya.  Solusi yang jauh lebih sederhana adalah menerima masing-masing satu byte, menyimpannya dalam buffer sendiri, dan kemudian output dalam format yang diperlukan, diuraikan sebelumnya. <br><br><h3>  Masalah dengan _sbrk </h3><br>  Masalah ini bagi saya pribadi yang paling implisit.  Jadi apa yang kita ketahui tentang _sbrk? <br><ul><li>  Rintisan lain yang perlu diimplementasikan untuk mendukung sebagian besar perpustakaan standar; </li><li>  diperlukan untuk mengalokasikan memori pada heap; </li><li>  digunakan oleh semua jenis metode perpustakaan seperti malloc, gratis. </li></ul><br>  Secara pribadi, dalam proyek-proyek saya di 95% kasus saya menggunakan FreeRTOS dengan metode redefinisi baru / delete / malloc yang menggunakan banyak FreeRTOS.  Jadi ketika saya mengalokasikan memori, saya yakin bahwa alokasi tersebut ada pada tumpukan FreeRTOS, yang memakan jumlah memori yang telah ditentukan sebelumnya di area bss.  Anda dapat melihat layer di <a href="">sini</a> .  Jadi, murni secara teknis, seharusnya tidak ada masalah.  Suatu fungsi seharusnya tidak dipanggil.  Tapi mari kita berpikir, jika dia menelepon, lalu di mana dia akan mencoba untuk mendapatkan ingatannya? <br><br>  Ingat tata letak RAM proyek "klasik" untuk mikrokontroler: <br><ul><li>  . data; </li><li>  .bss; </li><li>  ruang kosong </li><li>  tumpukan awal. </li></ul><br>  Dalam data, kami memiliki data awal objek global (variabel, struktur, dan bidang proyek global lainnya).  Dalam bss, bidang global yang memiliki nilai nol awal dan, dengan hati-hati, sekelompok FreeRTOS.  Ini hanya sebuah array dalam memori.  dengan mana metode dari file heap_x.c kemudian bekerja.  Berikutnya adalah ruang kosong, setelah itu (atau lebih tepatnya dari ujung) adalah tumpukan.  Karena  FreeRTOS digunakan dalam proyek saya, maka tumpukan ini hanya digunakan sampai penjadwal dimulai.  Dan, dengan demikian, penggunaannya, dalam banyak kasus, terbatas pada collobyte (pada kenyataannya, biasanya batas 100 byte). <br><br>  Tapi di mana, kemudian, mana memori dialokasikan menggunakan _sbrk?  Lihatlah variabel mana yang dia gunakan dari skrip tautan. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *__attribute__ ((weak)) _sbrk (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> incr) { <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_start; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_end; ...</code> </pre> <br>  Sekarang kita menemukannya di skrip linker (skrip saya sedikit berbeda dari yang disediakan oleh st, namun bagian ini hampir sama di sana): <br><pre> <code class="bash hljs">__stack = ORIGIN(SRAM) + LENGTH(SRAM); __main_stack_size = 1024; __main_stack_limit = __stack - __main_stack_size; ...  flash,    ... .bss (NOLOAD) : ALIGN(4) { ... . = ALIGN(4); __bss_end = .; } &gt;SRAM __heap_start = __bss_end; __heap_end = __main_stack_limit;</code> </pre> <br>  Artinya, ia menggunakan memori antara tumpukan (1 kb dari 0x20020000 turun dengan 128 kb RAM) dan bss. <br><br>  Dimengerti  Tapi dia punya definisi ulang metode malloc, gratis, dan lainnya.  Gunakan _sbrk setelah semua itu tidak perlu?  Ternyata, suatu keharusan.  Selain itu, metode ini tidak menggunakan printf, tetapi metode untuk mengatur mode buffering - <b>setvbuf</b> (atau lebih tepatnya _malloc_r, yang tidak dinyatakan sebagai fungsi yang lemah di perpustakaan. Tidak seperti malloc, yang dapat dengan mudah diganti). <br><img src="https://habrastorage.org/webt/me/cf/er/mecfercw11rpbrxrfn0twjyqvva.jpeg"><br>  Karena saya yakin bahwa sbrk tidak digunakan, saya meletakkan banyak FreeRTOS (bagian bss) di dekat stack (karena saya tahu pasti bahwa stack digunakan 10 kali lebih sedikit dari yang dibutuhkan). <br><br>  Solusi untuk Masalah 3: <br><ul><li>  indentasi antara bss dan stack; </li><li>  menimpa _malloc_r sehingga _sbrk tidak dipanggil (pisahkan satu metode dari pustaka); </li><li>  menulis ulang sbrk via malloc dan gratis. </li></ul><br>  Saya memilih opsi pertama, karena tidak mungkin untuk mengganti dengan aman _malloc_r standar (yang ada di dalam libg_nano.a (lib_a-nano-mallocr.o)) (metode ini tidak dinyatakan sebagai __attribute__ ((lemah)), tetapi untuk mengecualikan hanya fungsi tunggal dari bi-library Saya tidak berhasil menghubungkan).  Saya benar-benar tidak ingin menulis ulang sbrk untuk satu panggilan. <br><br>  Solusi terakhir adalah mengalokasikan partisi terpisah dalam RAM untuk tumpukan awal dan _sbrk.  Ini memastikan bahwa bagian-bagian tidak ditumpuk satu sama lain selama fase pengaturan.  Di dalam sbrk ada juga cek untuk keluar dari bagian.  Saya harus membuat koreksi kecil sehingga ketika mendeteksi transisi di luar negeri, aliran akan menggantung dalam loop sementara (karena penggunaan sbrk hanya terjadi pada tahap awal inisialisasi dan harus diproses pada tahap debugging perangkat). <br><div class="spoiler">  <b class="spoiler_title">Mem.ld yang dimodifikasi</b> <div class="spoiler_text"><pre> <code class="bash hljs">MEMORY { FLASH (RX) : ORIGIN = 0x08000000, LENGTH = 1M CCM_SRAM (RW) : ORIGIN = 0x10000000, LENGTH = 64K SRAM (RW) : ORIGIN = 0x20000000, LENGTH = 126K SBRK_HEAP (RW) : ORIGIN = 0x2001F800, LENGTH = 1K MAIN_STACK (RW) : ORIGIN = 0x2001FC00, LENGTH = 1K }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Perubahan ke section.ld</b> <div class="spoiler_text"><pre> <code class="bash hljs">__stack = ORIGIN(MAIN_STACK) + LENGTH(MAIN_STACK); __heap_start = ORIGIN(SBRK_HEAP); __heap_end = ORIGIN(SBRK_HEAP) + LENGTH(SBRK_HEAP);</code> </pre> </div></div><br>  Anda dapat melihat <a href="">mem.ld</a> dan <a href="">section.ld</a> di proyek kotak pasir saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di komit ini</a> . <br><br>  UPD 07/12/2019: memperbaiki daftar flag untuk printf yang berfungsi dengan nilai float.  Saya mengoreksi tautan ke CMakeLists yang berfungsi dengan kompilasi yang dikoreksi dan tata letak bendera (ada nuansa dengan fakta bahwa bendera harus terdaftar satu per satu dan melalui ";", sementara pada satu baris atau pada baris yang berbeda tidak masalah). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459420/">https://habr.com/ru/post/id459420/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459404/index.html">Ide: pendaftaran / otorisasi anonim menggunakan jaringan Ethereum + Metamask, tanpa email, dll.</a></li>
<li><a href="../id459408/index.html">Bagaimana saya mencoba memperbaiki pencarian peta untuk driver. Bagian 3 (final)</a></li>
<li><a href="../id459410/index.html">Cara menulis kode agar kolega Anda tidak bersumpah</a></li>
<li><a href="../id459414/index.html">Menulis API untuk Komponen Bereaksi, Bagian 4: Waspadai Apropacalypse</a></li>
<li><a href="../id459416/index.html">Menulis API untuk Komponen Bereaksi, Bagian 5: Cukup Gunakan Komposisi</a></li>
<li><a href="../id459422/index.html">Kami menulis API untuk komponen Bereaksi, bagian 6: kami membuat komunikasi antar komponen</a></li>
<li><a href="../id459426/index.html">Bagaimana desain Yandex.Avto dibuat</a></li>
<li><a href="../id459428/index.html">Intel Quartus Prime - semua yang Anda butuhkan untuk bekerja dengan Intel FPGA</a></li>
<li><a href="../id459430/index.html">Aplikasi seluler dengan pembuatan formulir otomatis: kasus kami</a></li>
<li><a href="../id459432/index.html">RD-180: bisakah AS membuat mesin roket?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>