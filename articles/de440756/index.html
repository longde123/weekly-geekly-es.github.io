<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòê üìõ üòñ Serverloses CI / CD unter AWS üë©‚Äçüîß üöô üë®üèΩ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Es w√§re cool, wenn die Copy-Paste-Bereitstellung der Vergangenheit angeh√∂ren w√ºrde, aber leider sind die Dinge anders. Es kommt vor, dass Entwickler e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serverloses CI / CD unter AWS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/440756/"><p><img src="https://habrastorage.org/webt/pr/ok/p2/prokp20fn2bwrkeqzq4ojxzx9gi.jpeg"><br><br>  Es w√§re cool, wenn die Copy-Paste-Bereitstellung der Vergangenheit angeh√∂ren w√ºrde, aber leider sind die Dinge anders.  Es kommt vor, dass Entwickler eine solche √úbermittlungsmethode bevorzugen.  Schreibe jetzt zwar einen Artikel dar√ºber, warum das nicht brummt, aber du wei√üt alles ohne mich.  Mit dem Trend zur serverlosen Architektur spielen CI / CD-Pipelines eine wichtige Rolle bei der Anwendungsbereitstellung.  Ich habe dar√ºber auch im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">3 beste Tipps f√ºr Ihr n√§chstes serverloses Projekt</a> " geschrieben. </p><br><p>  Ich habe mich vor langer Zeit f√ºr das Thema CI und CD interessiert und bin vor einigen Jahren zum ersten Mal darauf gesto√üen - dank TeamCity.  Derzeit wird TeamCity noch f√ºr die meisten unserer CI / CD-Pipelines verwendet.  TeamCity funktioniert gro√üartig, ich habe nichts dagegen, aber ich bem√ºhe mich immer, die Arbeit zu verbessern.  Zum Beispiel w√§re es sch√∂n, Pipelines in Form von Code zu sammeln - dies ist einer der Bereiche, in denen TeamCity nicht so gut ist. </p><br><p>  Ich habe vor einiger Zeit die Integrations- und Bereitstellungstools in AWS kennengelernt. Obwohl wir CodeDeploy f√ºr ein anderes Projekt verwenden, das unter EC2 funktioniert, habe ich noch kein serverloses Projekt mit ihnen bereitgestellt.  Nachdem ich die Tools erneut √ºberpr√ºft hatte, bemerkte ich Folgendes: Jetzt gibt es eine integrierte Integrationsfunktion f√ºr die Bereitstellung von CloudFormation und Lambda, die vermutlich auf SAM AWS basiert.  Wir verwenden das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">serverlose Framework</a> - es generiert CloudFormation-Vorlagen, funktioniert jedoch mit AWS-Tools nicht sofort. </p><a name="habracut"></a><br><h3 id="podgotovka">  Vorbereitung </h3><br><p>  Ich verwende die folgenden AWS-Dienste: EC2, Docker, ECR, S3, IAM, CodeBuild, CodePipeline, CloudWatch, CloudTrail.  Um auf dem Laufenden zu bleiben, m√ºssen Sie zumindest auf einer grundlegenden Ebene verstehen, was jeder dieser Dienste tut. </p><br><p>  Grunds√§tzlich schreibe ich den serverseitigen Code in .NET, und dieses Handbuch basiert auch auf dieser Plattform.  Keines der vorgefertigten CodeBuild-Images verf√ºgt gleichzeitig √ºber eine .NET- und eine NodeJS-Laufzeit (NodeJS wird f√ºr das serverlose Framework ben√∂tigt).  Wenn Ihre Lambda-Funktionen in NodeJS geschrieben sind, ist die Konfiguration der Bereitstellungspipeline viel einfacher, da dies die einzige Laufzeitumgebung ist, die f√ºr die Installation in einem Docker-Image erforderlich ist (in Ihrem Fall k√∂nnen Sie den gr√∂√üten Teil des Handbuchs √ºberspringen).  F√ºr eine Sekunde war dies meine erste Erfahrung mit Containern und ich freue mich, etwas Neues zu lernen. </p><br><p>  Ich wage anzunehmen, dass sich Ihr Code in einem bestimmten Repository befindet, zum Beispiel git.  Zur Orientierung laden wir einfach eine Datei in S3 hoch, die ein Codepaket f√ºr die Bereitstellung enth√§lt.  Wie Sie es bekommen, liegt bei Ihnen.  Auf der Grundlage meiner Arbeit k√∂nnen Sie jederzeit weiter gehen, indem Sie Ihre Pipeline mit Repositorys wie Github oder CodeCommit verbinden. </p><br><h3 id="1-sozdayte-ekzemplyar-ec2-i-ustanovite-docker">  1. Erstellen Sie eine EC2-Instanz und installieren Sie Docker </h3><br><p>  F√ºhren Sie eine Standardinstanz von AWS Linux 2 EC2 aus - dies sollte ohne Erkl√§rung klar sein.  Melden Sie sich an und installieren Sie Docker mit den folgenden Befehlen: </p><br><pre><code class="plaintext hljs">sudo yum update -y sudo amazon-linux-extras install docker sudo service docker start</code> </pre> <br><p>  Sie m√ºssen auch den Benutzer ec2 zur Docker-Gruppe hinzuf√ºgen, um Docker-Befehle ohne Verwendung von sudo auszuf√ºhren: </p><br><pre> <code class="plaintext hljs">sudo usermod -a -G docker ec2-user</code> </pre> <br><p>  Wenn der Befehl abgeschlossen ist, melden Sie sich ab und wieder bei Ihrer EC2-Instanz an, damit der ec2-Benutzer neue Berechtigungen erh√§lt.  Stellen Sie sicher, dass der ec2-Benutzer Docker-Befehle ohne sudo ausf√ºhrt: </p><br><pre> <code class="plaintext hljs">docker info</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/i-/aq/r_/i-aqr_g3enpgmdd4clpawaaykmu.png"></a> <br>  <em>Ausgabe des <code>docker info</code></em> </p><br><h3 id="2-sozdayte-obraz-docker-i-pomestite-v-ecr">  2. Erstellen Sie ein Docker-Image und platzieren Sie es in ECR </h3><br><p>  Angenommen, der vorherige Schritt ist erfolgreich.  Der n√§chste Schritt besteht darin, ein Docker-Image zu erstellen, das in die ECR passt.  AWS bietet grundlegende Bilder f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CodeBuild auf Github an. Auf</a> diese Weise k√∂nnen Sie ganz einfach Ihr eigenes Bild erstellen. </p><br><p>  Ich habe das Bild auch auf github gepostet - falls Sie diese Schritte nicht ausf√ºhren m√∂chten, um Ihr eigenes zu erstellen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/effectivedigital/serverless-deployment-image</a> </p><br><p>  Kopieren Sie die Bilder und wechseln Sie in das Verzeichnis .NET Core 2.1: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/aws/aws-codebuild-docker-images.git cd aws-codebuild-docker-images cd ubuntu/dot-net/core-2.1/</code> </pre> <br><p>  √ñffnen Sie Dockerfile in Ihrem bevorzugten Texteditor: </p><br><pre> <code class="plaintext hljs">nano Dockerfile</code> </pre> <br><p>  F√ºgen Sie die Befehle zum Installieren von NodeJS und des serverlosen Frameworks am Ende anderer Befehle hinzu, die bereits in der Docker-Datei verf√ºgbar sind.  Ich habe die meisten dieser Befehle von einem NodeJS Docker-Image im selben AWS-Repository erhalten: </p><br><pre> <code class="plaintext hljs"># Install Node Dependencies ENV NODE_VERSION="10.14.1" # gpg keys listed at https://github.com/nodejs/node#release-team RUN set -ex \ &amp;&amp; for key in \ 94AE36675C464D64BAFA68DD7434390BDBE9B9C5 \ B9AE9905FFD7803F25714661B63B535A4C206CA9 \ 77984A986EBC2AA786BC0F66B01FBB92821C587A \ 56730D5401028683275BD23C23EFEFE93C4CFFFE \ 71DCFD284A79C3B38668286BC97EC7A07EDE3FC1 \ FD3A5288F042B6850C66B31F09FE44734EB7990E \ 8FCCA13FEF1D0C2E91008E09770F7A9A5AE15600 \ C4F0DFFF4E8C1A8236409D08E73BC641CC11F4C8 \ DD8F2338BAE7501E3DD5AC78C273792F7D83545D \ 4ED778F539E3634C779C87C6D7062848A1AB005C \ A48C2BEE680E841632CD4E44F07496B3EB3C1762 \ ; do \ gpg - keyserver hkp://p80.pool.sks-keyservers.net:80 - recv-keys "$key" || \ gpg - keyserver hkp://ipv4.pool.sks-keyservers.net - recv-keys "$key" || \ gpg - keyserver hkp://pgp.mit.edu:80 - recv-keys "$key" ; \ done RUN set -ex \ &amp;&amp; wget "https://nodejs.org/download/release/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.gz" -O node-v$NODE_VER$ &amp;&amp; wget "https://nodejs.org/download/release/v$NODE_VERSION/SHASUMS256.txt.asc" -O SHASUMS256.txt.asc \ &amp;&amp; gpg - batch - decrypt - output SHASUMS256.txt SHASUMS256.txt.asc \ &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.gz\$" SHASUMS256.txt | sha256sum -c - \ &amp;&amp; tar -xzf "node-v$NODE_VERSION-linux-x64.tar.gz" -C /usr/local - strip-components=1 \ &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.gz" SHASUMS256.txt.asc SHASUMS256.txt \ &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs \ &amp;&amp; rm -fr /var/lib/apt/lists/* /tmp/* /var/tmp/* RUN npm set unsafe-perm true CMD [ "node" ] # Install Serverless Framework RUN set -ex \ &amp;&amp; npm install -g serverless</code> </pre> <br><p>  Jetzt sammeln und markieren wir das Bild: </p><br><pre> <code class="plaintext hljs">docker build -t aws/codebuild/dot-net .</code> </pre> <br><p>  F√ºhren Sie nach Abschluss der Assembly das Image aus. Stellen Sie sicher, dass alles funktioniert und das serverlose Framework korrekt installiert ist: </p><br><pre> <code class="plaintext hljs">docker run -it --entrypoint sh aws/codebuild/dot-net -c bash sls -v</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/ji/vh/da/jivhda2vzvu3vwc4uyltgyz0mza.png"></a> <br>  <em>Ausf√ºhren von <code>sls -v</code> in einem brandneuen Container</em> </p><br><p>  Erstellen Sie dann das Repository in ECR mithilfe der AWS-CLI.  Nach dem Ausf√ºhren des Befehls wird das neue Repository in der AWS-Konsole angezeigt: </p><br><pre> <code class="plaintext hljs">aws ecr create-repository --repository-name codebuild-dotnet-node</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/qc/bq/-g/qcbq-gsw-afhdbp2q9meo1nsqrk.png"></a> <br>  <em>AWS CLI-Antwort zum Erstellen eines Repositorys in ECR</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/2q/sf/_v/2qsf_v-jbgorara_qbzwi2lavoc.png"></a> </p><br><p>  Markieren Sie nun das zuvor erstellte <em>aws / codebuild / dot-net-</em> Image <em>mit dem</em> Wert repositoryUri aus dem vorherigen Schritt: </p><br><pre> <code class="plaintext hljs">docker tag aws/codebuild/dot-net &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node</code> </pre> <br><p>  F√ºhren Sie den Befehl get-login aus, um die Befehlszeile f√ºr die Docker-Anmeldeauthentifizierung f√ºr die Containerregistrierung abzurufen: </p><br><pre> <code class="plaintext hljs">aws ecr get-login --no-include-email</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/6l/w9/2d/6lw92dgbv2c7fvicbjvoz-afxwo.png"></a> </p><br><p>  F√ºhren Sie den Docker-Anmeldebefehl aus, der im letzten Schritt vom Befehl get-login ausgegeben wurde. </p><br><pre> <code class="plaintext hljs">docker login -u AWS -p eyJwYXlsb2FkIjoiNGZnd0dSaXM1L2svWWRLMmhJT1c0WWpOZEcxamJFeFJOK2VvT0Y5[...] https://&lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com</code> </pre> <br><p>  Wenn die Anmeldung erfolgreich ist, legen Sie das Docker-Image in dem in ECR erstellten Repository ab.  Dies kann einige Minuten dauern (abh√§ngig von der Gr√∂√üe des fertigen Bildes). </p><br><pre> <code class="plaintext hljs">docker push &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/qc/bq/-g/qcbq-gsw-afhdbp2q9meo1nsqrk.png"></a> <br>  <em>Docker auf EC2 erstellt unser Image</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/k-/me/2l/k-me2lgrhindh4_2p9tl24e0qau.png"></a> <br>  <em>Docker-Bild in ECR</em> </p><br><p>  Dann k√∂nnen wir jedem den Zugriff auf das Bild von ECR √∂ffnen.  Die Berechtigung muss in der Arbeitsumgebung blockiert sein, aber in diesem Beispiel werden wir sie √∂ffnen.  Wechseln Sie in der AWS-Konsole zur Registerkarte Berechtigungen, w√§hlen Sie "JSON-Richtlinie √§ndern" und f√ºgen Sie das folgende Element in die Richtlinie ein: </p><br><pre> <code class="plaintext hljs">{ "Version": "2008-10-17", "Statement": [ { "Sid": "EnableAccountAccess", "Effect": "Allow", "Principal": "*", "Action": [ "ecr:BatchCheckLayerAvailability", "ecr:BatchGetImage", "ecr:DescribeImages", "ecr:DescribeRepositories", "ecr:GetAuthorizationToken", "ecr:GetDownloadUrlForLayer", "ecr:GetRepositoryPolicy", "ecr:ListImages" ] } ] }</code> </pre> <br><h3 id="3-sozdayte-payplayn">  3. Erstellen Sie eine Pipeline </h3><br><p>  Es ist Zeit, die Pipeline zu sammeln.  Um den Prozess zu vereinfachen, ihn mehrfach bereitstellbar zu machen und mich an die katastrophale Form der Architektur ohne Server zu halten, habe ich eine Pipeline mit dem Framework ohne Server erstellt.  Sie k√∂nnen das gleiche Ergebnis erzielen, indem Sie CloudFormation einbauen. </p><br><p>  Ich werde nicht die gesamte Quelle aus meiner serverless.yml-Datei kopieren - kopieren Sie sie von github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/effectivedigital/serverless-deployment-pipeline</a> </p><br><p>  Schauen Sie sich die serverlose Vorlage an, um genau zu sehen, was sie tun wird. Kurz gesagt, sie richtet die folgenden Elemente ein: </p><br><ul><li>  3 Segmente S3 </li><li>  1 Segmentpolitik </li><li>  3 IAM-Rollen </li><li>  1 CodeBuild-Projekt </li><li>  1 Pipeline CodePipeline </li><li>  1 CloudWatch-Ereignis </li><li>  1 Spur von CloudTrail </li></ul><br><p>  Aktualisieren <em>Sie</em> anschlie√üend <em>DockerImageArn</em> f√ºr Ihr Image in ECR.  Wenn Sie Bereitstellungspakete mit einem anderen Namen als <em>Deployment.zip</em> erstellen m√∂chten, aktualisieren Sie auch <em>DeploymentFilename</em> : </p><br><pre> <code class="plaintext hljs">DockerImageArn: &lt;ACCOUNTID&gt;.dkr.ecr.ap-southeast-2.amazonaws.com/codebuild-dotnet-node:latest DeploymentFilename: Deployment.zip</code> </pre> <br><p>  Das war's, die Pipeline ist bereit f√ºr die Bereitstellung.  F√ºhren Sie den Befehl serverlose Bereitstellung aus und warten Sie, bis er konfiguriert ist: </p><br><pre> <code class="plaintext hljs">sls deploy -v</code> </pre> <br><p> <a href=""><img src="https://habrastorage.org/webt/hi/wk/ys/hiwkysbgka2zessqrdqkb4nir1g.png"></a> <br>  <em>Serverloser Framework-Stack CloudFormation erstellt</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/hc/r6/yr/hcr6yrezormgpobpu2bdu-_tvj4.png"></a> <br>  <em>Erstellt von der serverlosen Framework-Pipeline CodePipeline</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ef/ax/ad/efaxaddb_yspsbdxrl1azf5e1oo.png"></a> <br>  <em>Erstellt vom serverlosen Framework-Projekt CodeBuild Project</em> </p><br><h3 id="4-dobavte-buildspecyml-v-svoe-prilozhenie">  4. F√ºgen Sie Ihrer Anwendung buildSpec.yml hinzu </h3><br><p>  Wenn CodePipeline eine √Ñnderung an der Bereitstellungsdatei in S3 feststellt, weist es CodeBuild an, die Anwendung zu starten und zu versuchen, sie zu erstellen und bereitzustellen.  CodeBuild muss jedoch auch wissen, welche Befehle zum Erstellen und Bereitstellen der Anwendung ausgef√ºhrt werden m√ºssen, und buildSpec.yml enth√§lt Anweisungen, denen CodeBuild folgen wird. </p><br><p>  Ich habe eine sehr einfache "Hello World" -Anwendung erstellt, die eine Beispieldatei buildSpec.yml enth√§lt, die Sie verwenden k√∂nnen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/effectivedigital/serverless-deployment-app</a> <br>  Oder erstellen Sie die Datei buildSpec.yml in vorhandenen Anwendungen und f√ºllen Sie sie gem√§√ü den folgenden Anweisungen aus: </p><br><pre> <code class="plaintext hljs">version: 0.2 phases: pre_build: commands: - chmod a+x * build: commands: - ./build.sh post_build: commands: - sls deploy -v -s $STAGE</code> </pre> <br><h3 id="5-proverka-payplayna">  5. Pipeline-Pr√ºfung </h3><br><p>  Jetzt ist alles bereit f√ºr den ersten Start Ihrer Pipeline.  Erstellen Sie ein Paket mit dem Namen <em>Deployment.zip</em> . Es sollte alle Dateien f√ºr Ihre serverlose Anwendung und die Datei buildSpec.yml enthalten. </p><br><p>  Nach einigen Augenblicken sollte CloudTrail ein PutObject-Ereignis registrieren und die CloudWatch-Ereignisregel aktivieren, die dann den CodePipeline-Trigger aktiviert. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/zg/r4/ii/zgr4iikop3ujbabsgtsfbyjex4o.png"></a> <br>  <em>Deployment.zip wurde in S3 gestartet</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ak/xd/iz/akxdizdzjomaespfhmnygedoqia.png"></a> <br>  <em>CodePipeline gestartet, Build l√§uft</em> </p><br><p>  Wenn wir zu den Details des AWS CodeBuild-Schritts √ºbergehen, sehen wir den Erstellungs- und Bereitstellungsprozess: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/gv/sx/cb/gvsxcbcpmbcnj18k9rwbqbm_bhu.png"></a> <br>  <em>CodeBuild empf√§ngt die Ausgabe des Builds und stellt das Docker-Image bereit</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/l3/ec/xm/l3ecxm5cjedmhtpxne0nklzdzlm.png"></a> <br>  <em>Bereitstellung erfolgreich!</em> </p><br><p>  Die neue Anwendung, die von unserer Pipeline bereitgestellt wird, wird auch in CloudFormation angezeigt: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/r6/2s/xl/r62sxlivtmrg8vn3yze2xe0ez3y.png"></a> </p><br><p>  Sie k√∂nnen den in unserer einfachen Anwendung erstellten API-Endpunkt testen (die URL befindet sich in der CodeBuild-Ausgabe oder in der Gateway-API) und sicherstellen, dass die Anwendung erfolgreich funktioniert: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/h4/s3/gh/h4s3ghrxxwlpxaf3ssdwhfx30sy.png"></a> <br>  <em>Postbote, um API aufzurufen</em> </p><br><h3 id="kratkie-vyvody">  Kurze Schlussfolgerungen </h3><br><p>  Mit CodePipeline k√∂nnen Sie eine skalierbare, flexible und kosteng√ºnstige CI / CD-Pipeline erstellen. Sie k√∂nnen damit einige Probleme l√∂sen, die mit herk√∂mmlichen Pipelines verbunden sind, die auf Servern erstellt wurden. <br>  Ich w√ºrde gerne weiter gehen und Unit-Tests nach der Bereitstellung zum Mix hinzuf√ºgen, aber das Thema verdient einen separaten Artikel - und dies ist eine Gelegenheit, uns in Zukunft zu lesen! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440756/">https://habr.com/ru/post/de440756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440744/index.html">PHP f√ºr Anf√§nger. Fehlerbehandlung</a></li>
<li><a href="../de440746/index.html">Die Wissensmanagement-Technologiezyklen von Gartner werden anhand von Fallstudien bei KnowledgeConf durchgef√ºhrt</a></li>
<li><a href="../de440748/index.html">Der schnellste Supercomputer der Welt bricht den KI-Rekord</a></li>
<li><a href="../de440752/index.html">Auswahl der Priorit√§t der Benutzeranforderung</a></li>
<li><a href="../de440754/index.html">Plattform√ºbergreifendes englisches Dienstprogramm zum Anzeigen russisch qualifizierter Zertifikate x509</a></li>
<li><a href="../de440758/index.html">Treffen Sie sich bei Acronis! (Moskau, Fiztehpark)</a></li>
<li><a href="../de440760/index.html">Das neue goldene Zeitalter f√ºr Computerarchitektur</a></li>
<li><a href="../de440762/index.html">Arbeitgeberbewertungen: Art und Bedeutungslosigkeit anonymer Bewertungen</a></li>
<li><a href="../de440766/index.html">Von Geeks zu Geeks: Geschenke f√ºr den 23. Februar</a></li>
<li><a href="../de440772/index.html">Domain-gesteuertes Design: ein Rezept f√ºr einen Pragmatiker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>