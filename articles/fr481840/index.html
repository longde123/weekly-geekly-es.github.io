<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👃🏼 ⏲️ 👩🏼‍🤝‍👨🏿 Protégez votre API GraphQL contre les vulnérabilités 👸🏾 🦉 🧓🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous présente la traduction de l'article Protéger votre API GraphQL des vulnérabilités de sécurité . 


 GraphQL devient rapidement ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Protégez votre API GraphQL contre les vulnérabilités</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481840/"><p>  <em>Bonjour, Habr!</em>  <em>Je vous présente la traduction de l'article <a href="https://medium.com/swlh/protecting-your-graphql-api-from-security-vulnerabilities-e8afdfa6fbe4">Protéger votre API GraphQL des vulnérabilités de sécurité</a> .</em> </p><br><p>  GraphQL devient rapidement le choix des développeurs qui ont besoin de créer une API pour leur application client.  Mais, comme toutes les nouvelles technologies, GraphQL est soumis à certains risques de sécurité inhérents.  Que vous construisiez un projet tiers ou une application d'entreprise à grande échelle, vous devez vous assurer de vous protéger contre ces menaces. </p><br><p><img src="https://habrastorage.org/webt/rj/gd/91/rjgd91w0ywte-d3zuyxob4c8kck.jpeg" alt="image"></p><a name="habracut"></a><br><p>  Bien que les menaces répertoriées dans cet article soient spécifiques à GraphQL, votre implémentation introduira un nouvel ensemble de menaces qui devront être traitées.  Il est également important que vous compreniez les menaces auxquelles sont exposées les applications en cours d'exécution sur le réseau. </p><br><h1 id="ugroza-bolshie-gluboko-vlozhennye-zaprosy-kotorye-dorogo-vychislyat">  Menace: grandes requêtes profondément imbriquées et coûteuses à calculer </h1><br><p>  <strong>Solution</strong> : limitation de la profondeur d'imbrication </p><br><p>  La puissance fournie par GraphQL est associée à de nouvelles menaces de sécurité.  Les plus courantes sont les requêtes profondément imbriquées, qui conduisent à des calculs coûteux et à un énorme JSON, qui peuvent nuire au réseau et à sa bande passante. </p><br><p>  La bonne façon de protéger votre API contre ce type d'attaque est de limiter la profondeur des demandes afin que les demandes profondes malveillantes soient bloquées jusqu'à ce que le résultat soit calculé. </p><br><p>  <a href="https://github.com/stems/graphql-depth-limit">GraphQL Depth Limit</a> fournit une interface simple pour limiter la profondeur des requêtes. </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> depthLimit <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-depth-limit'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> graphqlHTTP <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express-graphql'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> schema <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schema'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.use(<span class="hljs-string"><span class="hljs-string">'/graphql'</span></span>, graphqlHTTP(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) =&gt;</span></span> ({ schema, <span class="hljs-attr"><span class="hljs-attr">validationRules</span></span>: [ depthLimit(<span class="hljs-number"><span class="hljs-number">10</span></span>) ] })))</code> </pre> <br><h1 id="ugroza-perebor-uyazvimyh-mutation-zaprosov">  Menace: demandes de mutation vulnérables à la force brute </h1><br><p>  <strong>Solution</strong> : limiter le nombre de demandes </p><br><p>  La recherche de connexions et de mots de passe est la plus ancienne astuce de l'histoire du piratage.  Au cours de la dernière décennie, il y a eu tellement de fuites de données sur Internet qu'une base de données de <a href="https://www.gizmodo.com.au/2019/01/mother-of-all-breaches-exposes-773-million-emails-21-million-passwords/">772 904 991 e-mails uniques et 21 222 975 mots de passe uniques</a> a récemment été trouvée.  Pour vérifier si des informations sur votre e-mail et votre mot de passe avaient été divulguées, Troy Hunt a même créé un site Web <a href="https://haveibeenpwned.com/">Have I been Pwned</a> , pour lequel, entre autres, il a utilisé cette base de données. </p><br><p>  Heureusement, vous avez un moyen facile de rendre le contournement vraiment difficile et coûteux pour les attaquants, ce qui fera de vous une cible moins attrayante pour eux. </p><br><p>  Le plugin <a href="https://github.com/teamplanes/graphql-rate-limit">GraphQL Rate Limit</a> vous permet de spécifier des restrictions pour vos requêtes de trois manières différentes: en utilisant des directives graphql-shield personnalisées ou en utilisant la fonction pour limiter le nombre de base de requêtes. </p><br><p>  Ce plugin vous permettra de définir une fenêtre de temps et une limite sur le nombre de demandes pour cela.  La définition d'une grande fenêtre temporelle pour les demandes très vulnérables, telles que la connexion, et de petites fenêtres temporelles pour les demandes moins vulnérables vous aidera à maintenir une expérience agréable pour les utilisateurs ordinaires et deviendra un cauchemar pour les attaquants. </p><br><p>  <strong>Créez une directive pour limiter le nombre de demandes:</strong> </p><br><p>  Ici, vous aurez besoin d'un identifiant unique pour chaque demande.  Vous pouvez utiliser l'adresse IP de l'utilisateur ou un autre identifiant, unique pour chaque utilisateur et correspondant à chaque demande. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rateLimitDirective = createRateLimitDirective({ <span class="hljs-attr"><span class="hljs-attr">identifyContext</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context.id }, })</code> </pre> <br><p>  <strong>Ajoutez une directive à votre schéma:</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { createRateLimitDirective } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-rate-limit'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> schema = { typeDefs, resolvers, <span class="hljs-attr"><span class="hljs-attr">schemaDirectives</span></span>: { <span class="hljs-attr"><span class="hljs-attr">rateLimit</span></span>: rateLimitDirective, }, } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> schema</code> </pre> <br><p>  <strong>Enfin, ajoutez une directive à votre requête vulnérable:</strong> </p><br><pre> <code class="plaintext hljs">#        60  Login(input: LoginInput!): User @rateLimit( window: "60s" max: 10 message: "You are doing that too often. Please wait 60 seconds before trying again." )</code> </pre> <br><h1 id="ugroza-razreshenie-polzovatelyu-vliyat-na-specifichnye-dlya-konkretnogo-polzovatelya-dannye">  Menace: permettre à l'utilisateur d'influencer les données spécifiques à l'utilisateur </h1><br><p>  <strong>Solution</strong> : prenez ces données d'une session utilisateur lorsque cela est possible </p><br><p>  Il est facile de supposer que si vous souhaitez autoriser l'utilisateur à mettre à jour une ressource, cela vaut la peine de laisser l'utilisateur décider de la ressource qu'il souhaite mettre à jour.  Mais que se passe-t-il si un utilisateur obtient un identifiant de ressource auquel il ne devrait vraiment pas avoir accès? </p><br><p>  Supposons que nous ayons une demande de mutation updateUser qui permet à l'utilisateur de mettre à jour son profil. </p><br><pre> <code class="plaintext hljs">mutation UpdateUser($input: {"id": "test123" , "email": "test@example.com"}) { UpdateUser(input: $input) { id firstName lastName } }</code> </pre> <br><p>  S'il n'y a pas de protection côté serveur, l'attaquant, disposant d'une liste d'identifiants, pourrait potentiellement mettre à jour l'adresse e-mail de tout utilisateur.  La solution évidente ici consiste à ajouter une vérification pour vous assurer que l'ID de l'utilisateur actuel correspond à l'ID dans les champs de saisie. </p><br><p>  <strong>Ne faites pas ceci:</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ id, email }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User.findOneAndUpdate({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: id }, { email }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error; }); }</code> </pre> <br><p>  Une manière moins évidente mais correcte de résoudre ce problème consiste à empêcher l'identifiant d'être utilisé comme entrée et à utiliser l'identifiant utilisateur de l'objet contextuel. </p><br><p>  <strong>Faites ceci:</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ email }, context</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> User.findOneAndUpdate({ <span class="hljs-attr"><span class="hljs-attr">_id</span></span>: context.user._id }, { email }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> error; }); }</code> </pre> <br><p>  C'est peut-être un exemple assez banal, mais effectuer de telles actions pour chacun des objets avec lesquels l'utilisateur interagit directement peut vous protéger contre de nombreuses erreurs risquées. </p><br><h1 id="vypolnenie-neskolkih-dorogih-zaprosov-odnovremenno">  Exécution simultanée de plusieurs requêtes coûteuses </h1><br><p>  <strong>Solution</strong> : limite de coût des requêtes </p><br><p>  En attribuant un prix à chaque demande et en indiquant le prix maximum par demande, nous pouvons nous protéger contre les intrus qui pourraient essayer de répondre à trop de demandes coûteuses en même temps. </p><br><p>  Le plugin <a href="https://github.com/pa-bru/graphql-cost-analysis">GraphQL Cost Analysis</a> est un moyen facile de spécifier le coût des requêtes et la limite de coût maximum. </p><br><p>  <strong>Déterminez le coût maximum:</strong> </p><br><pre> <code class="javascript hljs">app.use( <span class="hljs-string"><span class="hljs-string">'/graphql'</span></span>, graphqlExpress(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { schema, <span class="hljs-attr"><span class="hljs-attr">rootValue</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">validationRules</span></span>: [ costAnalysis({ <span class="hljs-attr"><span class="hljs-attr">variables</span></span>: req.body.variables, <span class="hljs-attr"><span class="hljs-attr">maximumCost</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>, }), ], } }) )</code> </pre> <br><p>  <strong>Déterminez le coût de chaque demande:</strong> </p><br><pre> <code class="javascript hljs">Query: { <span class="hljs-attr"><span class="hljs-attr">Article</span></span>: { <span class="hljs-attr"><span class="hljs-attr">multipliers</span></span>: [<span class="hljs-string"><span class="hljs-string">'limit'</span></span>], <span class="hljs-attr"><span class="hljs-attr">useMultipliers</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">complexity</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, }, }</code> </pre> <br><h1 id="ugroza-raskrytie-detaley-realizacii-graphql">  Menace: divulgation des détails d'implémentation de GraphQL </h1><br><p>  <strong>Solution</strong> : désactiver l'introspection dans le code "combat" </p><br><p>  GraphQL est un outil de développement extrêmement utile.  Il est si puissant qu'il documente même votre schéma, vos demandes et vos abonnements pour vous.  Ces informations peuvent être une mine d'or pour les attaquants qui souhaitent trouver des vulnérabilités dans votre application. </p><br><p>  Le plugin <a href="https://github.com/helfer/graphql-disable-introspection">GraphQL Display Introspection</a> empêchera votre schéma de fuir vers le public.  Importez simplement le plugin et appliquez-le à vos règles de validation. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { graphqlExpress } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-server-express'</span></span>; + <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NoIntrospection <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'graphql-disable-introspection'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myGraphQLSchema = <span class="hljs-comment"><span class="hljs-comment">// ...    ! const PORT = 3000; var app = express(); app.use('/graphql', bodyParser.json(), graphqlExpress({ schema: myGraphQLSchema, validationRules: [NoIntrospection] })); app.listen(PORT);</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr481840/">https://habr.com/ru/post/fr481840/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr481822/index.html">Un historique bref et précis à 146% des langages de programmation</a></li>
<li><a href="../fr481824/index.html">Recherche rapide de la source des mutations indésirables d'une propriété d'objet</a></li>
<li><a href="../fr481828/index.html">L'histoire des logiciels éducatifs: les systèmes de gestion de l'apprentissage et l'essor de l'éducation en ligne</a></li>
<li><a href="../fr481836/index.html">Pizza as a service: comment Amazon a migré vers Redshift</a></li>
<li><a href="../fr481838/index.html">WireGuard, configuration de plusieurs clients pour NAT, et où va STUN?</a></li>
<li><a href="../fr481842/index.html">Passer au stockage pur: notre nouveau stockage</a></li>
<li><a href="../fr481844/index.html">7 ans de battage médiatique sur les réseaux de neurones dans les graphiques et les perspectives inspirantes du Deep Learning 2020</a></li>
<li><a href="../fr481846/index.html">Utilisation de GitHub CI pour les projets Elixir</a></li>
<li><a href="../fr481848/index.html">Formation du personnel expérimenté</a></li>
<li><a href="../fr481850/index.html">L'Inquisition espagnole et le robot pour l'humiliation: quelles sont les conférences "prédatrices" pour le fric</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>