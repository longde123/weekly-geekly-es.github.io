<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏪 🉐 🚣 Konstruktion von Verhaltenstrichtern in der R-Sprache basierend auf Daten, die von der Yandex.Metrica Logs API erhalten wurden 👈🏽 🤵🏿 🤲🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Analyse eines Verkaufstrichters ist eine typische Aufgabe für das Internet-Marketing und insbesondere für den E-Commerce. Mit seiner Hilfe können ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konstruktion von Verhaltenstrichtern in der R-Sprache basierend auf Daten, die von der Yandex.Metrica Logs API erhalten wurden</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462279/"><p>  Die Analyse eines Verkaufstrichters ist eine typische Aufgabe für das Internet-Marketing und insbesondere für den E-Commerce.  Mit seiner Hilfe können Sie: </p><br><ul><li>  Finden Sie heraus, bei welchen Schritten zum Kauf Sie potenzielle Kunden verlieren. </li><li>  Um das Volumen des zusätzlichen Einnahmezuflusses zu simulieren, im Falle der Erweiterung jedes Schritts auf dem Weg zum Kauf. </li><li> Bewerten Sie die Qualität des auf verschiedenen Werbeplattformen gekauften Verkehrs. </li><li>  Bewerten Sie die Qualität der Verarbeitung eingehender Anträge für jeden Manager. </li></ul><br><p>  In diesem Artikel werde ich darüber sprechen, wie Sie Daten in der Sprache R von der Yandex Metrics Logs-API anfordern, einen darauf basierenden Trichter erstellen und visualisieren. </p><br><p> Einer der Hauptvorteile der R-Sprache ist das Vorhandensein einer großen Anzahl von Paketen, die ihre Grundfunktionalität erweitern.  In diesem Artikel werden wir uns die <code>ggplot2</code> <code>rym</code> , <code>funneljoin</code> und <code>ggplot2</code> . </p><br><p>  Mit <code>rym</code> laden wir Daten aus der Logs-API, <code>funneljoin</code> mit <code>funneljoin</code> einen Verhaltenstrichter und visualisieren das Ergebnis mit <code>ggplot2</code> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/903/ac7/75e/903ac775e293295d418a628a673f73d6.jpg" alt="Bild"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fordern Sie Daten von der Protokoll-API Yandex Metrics an</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Installation des Rym-Pakets</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arbeiten mit der Protokoll-API Yandex Metrics mit dem rym-Paket</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autorisierung in der Yandex Metrics API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Daten von der Yandex Metrica API anfordern</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trichter Gebäude Trichter verbinden Paket</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trichterverbindung installieren</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von der Protokoll-API empfangene Nachbearbeitungsdaten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trichtertypen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trichterstufen</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trichtervisualisierung</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Visualisierung des gemeinsamen Trichters</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Trichtervisualisierung durch Verkehrskanäle</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><h1 id="zapros-dannyh-iz-logs-api-yandeks-metriki">  Fordern Sie Daten von der Protokoll-API Yandex Metrics an </h1><br><p>  Wer nicht weiß, was die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Logs-API</a> hier ist, ist ein Zitat aus der offiziellen Yandex-Hilfe. </p><br><blockquote>  Mit der Protokoll-API können Sie nicht aggregierte Daten empfangen, die von Yandex.Metrica erfasst wurden.  Diese API richtet sich an Benutzer des Dienstes, die statistische Daten unabhängig verarbeiten und zur Lösung eindeutiger Analyseprobleme verwenden möchten. </blockquote><p>  Um mit der Yandex.Metrica Logs-API in R zu arbeiten, verwenden wir das <code>rym</code> Paket. </p><br><div class="spoiler">  <b class="spoiler_title">Nützliche Links zum Rym-Paket</b> <div class="spoiler_text"><p>  Referenzen: </p><br><ul><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rym-Paketdokumentation</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rym-Paketseite auf CRAN</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rym-Paketseite auf Github</a></em> </li><li>  <em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rym Paket Webinar</a></em> </li></ul></div></div><br><p>  <code>rym</code> R-Paket ist eine Schnittstelle für die Interaktion mit der Yandex Metrica-API.  Ermöglicht die Arbeit mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Verwaltungs-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API, der Berichts-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">API, der Gore-API-kompatiblen Google Analytics v3</a> und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Protokoll-API</a> . </p><br><h2 id="ustnovka-paketa-rym">  Installation des Rym-Pakets </h2><br><p>  Um mit einem Paket in R arbeiten zu können, muss es zuerst installiert und heruntergeladen werden.  Installieren Sie ein Paket einmal mit dem Befehl <code>install.packages()</code> .  Es ist erforderlich, das Paket in jeder neuen Arbeitssitzung in R mithilfe der Funktion <code>library()</code> . </p><br><p>  Verwenden Sie den folgenden Code, um das <code>rym</code> Paket zu installieren und zu verbinden: </p><br><pre> <code class="plaintext hljs">install.packages("rym") library(rym)</code> </pre> <br><h2 id="rabota-s-logs-api-yandeks-metriki-s-pomoschyu-paketa-rym">  Arbeiten mit der Protokoll-API Yandex Metrics mit dem rym-Paket </h2><br><p>  Um Verhaltenstrichter zu erstellen, müssen wir eine Tabelle aller auf Ihrer Website durchgeführten Besuche herunterladen und die Daten für die weitere Analyse vorbereiten. </p><br><h3 id="avtorizaciya-v-api-yandeks-metriki">  Autorisierung in der Yandex Metrics API </h3><br><p>  Die Arbeit mit der API beginnt mit der Autorisierung.  Im <code>rym</code> Paket <code>rym</code> der Autorisierungsprozess teilweise automatisiert und beginnt, wenn eine seiner Funktionen aufgerufen wird. </p><br><p>  Wenn Sie zum ersten Mal auf die API zugreifen, werden Sie zum Browser weitergeleitet, um die Berechtigung zum Zugriff auf Ihre Yandex-Metriken für das <code>rym</code> Paket zu bestätigen.  Nach der Bestätigung werden Sie zu der Seite weitergeleitet, auf der ein Autorisierungsbestätigungscode für Sie generiert wird.  Es muss als Antwort auf die Anforderung <code>"Enter authorize code:"</code> kopiert und in die R-Konsole eingefügt werden. </p><br><p>  Als Nächstes können Sie die Anmeldeinformationen in einer lokalen Datei speichern, indem Sie auf die Anfrage <code>"Do you want save API credential in local file ..."</code> <code>y</code> oder <code>yes</code> antworten.  In diesem Fall müssen Sie sich bei den nächsten Aufrufen der API nicht erneut über den Browser authentifizieren, und die Anmeldeinformationen werden aus der lokalen Datei geladen. </p><br><h3 id="zapros-dannyh-iz-api-yandeks-metriki">  Daten von der Yandex Metrica API anfordern </h3><br><p>  Das erste, was wir von der Yandex Metrics-API verlangen, ist eine Liste der verfügbaren Zähler und konfigurierten Ziele.  Dies erfolgt mit den Funktionen <code>rym_get_counters()</code> und <code>rym_get_goals()</code> . </p><br><pre> <code class="plaintext hljs">#   library(rym) #    counters &lt;- rym_get_counters(login = " ") #    goals &lt;- rym_get_goals("0000000", #    login = " ")</code> </pre> <br><p>  Ersetzen <code>" "</code> anhand des obigen Codebeispiels <code>" "</code> durch Ihren Yandex-Benutzernamen, unter dem die von Ihnen benötigten Yandex-Metriken verfügbar sind.  Und <code>"0000000"</code> auf die Nummer des Zählers, den Sie benötigen.  Sie können die Nummern der Zähler sehen, die Ihnen in der Tabelle der geladenen <em>Zähler zur Verfügung stehen</em> . </p><br><p>  Die Tabelle der verfügbaren Zähler - <em>Zähler</em> hat die folgende Form: </p><br><pre> <code class="plaintext hljs"># A tibble: 2 x 9 id status owner_login name code_status site permission type gdpr_agreement_accepted &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; 1 11111111 Active site.ru1 Aerosus CS_NOT_FOUND site.ru edit simple 0 2 00000000 Active site.ru Aerosus RU CS_OK site.ru edit simple 1</code> </pre> <br><p>  Das <em>ID-</em> Feld zeigt die Nummern aller verfügbaren Yandex-Metrikzähler an. </p><br><p>  Die Zieltabelle lautet wie folgt: </p><br><pre> <code class="plaintext hljs"># A tibble: 4 x 5 id name type is_retargeting conditions &lt;int&gt; &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; 1 47873638    url 0 type:contain, url:site.ru/checkout/cart/ 2 47873764    url 0 type:contain, url:site.ru/onestepcheckout/ 3 47874133     url 0 type:contain, url:/checkout/onepage/success 4 50646283     action 0 type:exact, url:click_phone</code> </pre> <br><p>  Das heißt,  In dem Zähler, mit dem ich arbeite, sind die folgenden Aktionen konfiguriert: </p><br><ul><li>  Gehe zum Korb </li><li>  Zur Zahlung gehen </li><li>  Vielen Dank für die Bestellung </li><li>  Klicken Sie auf die Schaltfläche Telefon </li></ul><br><p>  In Zukunft werden wir für die Datenkonvertierung die in der <code>tidyverse</code> Bibliothek enthaltenen Pakete verwenden: <code>tidyr</code> , <code>dplyr</code> .  Installieren und verbinden Sie daher diese Pakete oder die gesamte <code>tidyverse</code> Bibliothek, bevor Sie das folgende <code>tidyverse</code> verwenden. </p><br><pre> <code class="plaintext hljs"># install.packages("tidyverse") # library(tidyverse) install.packages(c("dplyr", "tidyr")) library(dplyr) library(tidyr)</code> </pre> <br><p>  Mit der Funktion <code>rym_get_logs()</code> können Sie Daten von den API-Metriken der Yandex-Metriken-Protokolle anfordern. </p><br><pre> <code class="plaintext hljs">#      logs &lt;- rym_get_logs(counter = "0000000", date.from = "2019-04-01", date.to = "2019-06-30", fields = "ym:s:visitID, ym:s:clientID, ym:s:date, ym:s:goalsID, ym:s:lastTrafficSource, ym:s:isNewUser", login = " ") %&gt;% mutate(ym.s.date = as.Date(ym.s.date), ym.s.clientID = as.character(ym.s.clientID))</code> </pre> <br><p>  Die Hauptargumente für die Funktion <code>rym_get_logs()</code> : </p><br><ul><li>  Zähler - Zählernummer, von der Sie Protokolle anfordern; </li><li>  date.from - Startdatum; </li><li>  Datum bis Ende; </li><li>  Felder - Eine Liste der Felder, die Sie laden möchten. </li><li>  Login - Yandex-Login, unter dem der im <em>Zähler</em> angegebene <em>Zähler</em> verfügbar ist. </li></ul><br><p>  Daher haben wir Besuchsdaten von der Protokoll-API angefordert, die die folgenden Spalten enthält: </p><br><ul><li>  ym: s: visitID - Besuchs-ID </li><li>  ym: s: clientID - Benutzer-ID auf der Site </li><li>  ym: s: date - Datum des Besuchs </li><li>  ym: s: destinationID - Kennung der während dieses Besuchs erreichten Ziele </li><li>  ym: s: lastTrafficSource - Verkehrsquelle </li><li>  ym: s: isNewUser - Erster Besuch der Besucher </li></ul><br><blockquote>  Eine vollständige Liste der verfügbaren Felder finden Sie in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hilfe</a> zur Protokoll-API. </blockquote><p>  Die empfangenen Daten reichen aus, um einen Trichter zu erstellen, in dessen Zusammenhang die Arbeit mit der Protokoll-API abgeschlossen ist, und wir fahren mit dem nächsten Schritt fort - der Nachbearbeitung der heruntergeladenen Daten. </p><br><h1 id="postroenie-voronok-paket-funneljoin">  Trichter Gebäude Trichter verbinden Paket </h1><br><blockquote>  Ein wesentlicher Teil der in diesem Abschnitt bereitgestellten Informationen stammt aus dem Trichter-README-Paket, das als <a href="">Referenz</a> verfügbar ist. </blockquote><p>  Ziel von <code>funneljoin</code> ist es, die Trichteranalyse des Benutzerverhaltens zu vereinfachen.  Ihre Aufgabe besteht beispielsweise darin, Personen zu finden, die Ihre Website besucht und sich dann registriert haben, und herauszufinden, wie viel Zeit zwischen dem ersten Besuch und der Registrierung vergangen ist.  Oder Sie müssen Benutzer finden, die die Produktkarte angesehen und innerhalb von zwei Tagen in den Warenkorb gelegt haben.  Das <code>funneljoin</code> Paket und die Funktion <code>after_join()</code> helfen bei der Lösung solcher Probleme. </p><br><p>  <strong>Argumente <code>after_join()</code> :</strong> </p><br><ul><li>  x - eine Reihe von Daten, die Informationen zum Abschluss des ersten Ereignisses enthalten (im ersten Beispiel Besuch der Website, im zweiten Beispiel Anzeigen der Produktkarte). </li><li>  y - ein Datensatz mit Informationen zum Abschluss des zweiten Ereignisses (im ersten Beispiel der Registrierung, im zweiten Beispiel zum Hinzufügen des Produkts zum Warenkorb). </li><li>  by_time - Eine Spalte mit Informationen zum Datum des Auftretens der Ereignisse in den Tabellen <em>x</em> und <em>y</em> . </li><li>  by_user - eine Spalte mit Benutzerkennungen in den Tabellen <em>x</em> und <em>y</em> . </li><li>  mode - die Verbindungsmethode: "inner", "full", "anti", "semi", "right", "left".  Stattdessen können Sie auch <code>after_mode_join</code> (z. B. <code>after_inner_join</code> anstelle von <code>after_join (..., mode = "inner")</code> ). </li><li>  Typ - Der Typ der Sequenz, die zum Definieren von Ereignispaaren verwendet wird, z. B. "first-first", "last-first", "any-firstafter".  Ausführlicher beschrieben im Abschnitt "Arten von Trichtern". </li><li>  max_gap / min_gap (optional) - Filtern nach der maximalen und minimalen Zeitdauer zwischen dem ersten und dem zweiten Ereignis. </li><li>  gap_col (optional) - Gibt an, ob eine numerische <em>.gap-</em> Spalte mit einem Zeitunterschied zwischen Ereignissen zurückgegeben werden soll.  Der Standardwert ist FALSE. </li></ul><br><h2 id="ustanovka-funneljoin">  Trichterverbindung installieren </h2><br><p>  Zum Zeitpunkt dieses Schreibens war das <code>funneljoin</code> Paket <code>funneljoin</code> nicht auf CRAN veröffentlicht, sodass Sie es von GitHub aus installieren können.  Um Pakete von GitHub zu installieren, benötigen Sie ein zusätzliches Paket - <code>devtools</code> . </p><br><pre> <code class="plaintext hljs">install.packages("devtools") devtools::install_github("robinsones/funneljoin")</code> </pre> <br><h2 id="postobrabotka-dannyh-poluchennyh-iz-logs-api">  Von der Protokoll-API empfangene Nachbearbeitungsdaten </h2><br><p>  Für eine detailliertere Untersuchung der Trichterkonstruktionsfunktion müssen wir die von der Logs-API erhaltenen Daten in die gewünschte Form bringen.  Die bequemste Möglichkeit, Daten zu manipulieren, wie ich oben geschrieben habe, bieten die <code>dplyr</code> <code>tidyr</code> und <code>dplyr</code> . </p><br><p>  Gehen Sie wie folgt vor, um loszulegen: </p><br><ol><li>  In diesem Fall enthält eine Zeile der <em>Protokolltabelle</em> Informationen zu einem Besuch, und die Spalte <em>ym.s.goalsID</em> ist ein Array der Form - <code>[0,1,0,...]</code> , das Kennungen der während dieses Besuchs erreichten Ziele enthält.  Um das Array in eine Form zu bringen, die für die weitere Arbeit geeignet ist, müssen zusätzliche Zeichen entfernt werden, in unserem Fall eckige Klammern. </li><li>  Die Tabelle muss neu formatiert werden, damit eine Zeile Informationen zu einem Ziel enthält, das während des Besuchs erreicht wurde.  Das heißt,  Wenn während eines Besuchs drei Ziele erreicht wurden, wird dieser Besuch in drei Zeilen unterteilt, und jede Zeile in der Spalte <em>ym.s.goalsID</em> enthält die Kennung nur eines Ziels. </li><li>  Fügen Sie der Protokolltabelle eine Tabelle mit einer Liste von Zielen hinzu, um genau zu verstehen, welche Ziele bei jedem Besuch erreicht wurden. </li><li>  Benennen Sie die <em>Namensspalte</em> mit Zielnamen in <em>Ereignisse um</em> . </li></ol><br><p>  Alle oben genannten Aktionen werden mit dem folgenden Code implementiert: </p><br><div class="spoiler">  <b class="spoiler_title">Nachbearbeitungscode für Daten, die von der Protokoll-API empfangen wurden</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#      logs_goals &lt;- logs %&gt;% mutate(ym.s.goalsID = str_replace_all(ym.s.goalsID, #     "\\[|\\]", "") %&gt;% str_split(",")) %&gt;% #     unnest(cols = c(ym.s.goalsID)) %&gt;% mutate(ym.s.goalsID = as.integer(ym.s.goalsID)) %&gt;% #  id     left_join(goals, by = c("ym.s.goalsID" = "id")) %&gt;% #      rename(events = name) #     events</code> </pre> </div></div><br><p>  Eine kleine Erklärung des Codes.  Der Operator <code>%&gt;%</code> wird als Pipeline bezeichnet und macht den Code lesbarer und kompakter.  Tatsächlich nimmt es das Ergebnis der Ausführung einer Funktion und übergibt es als erstes Argument an die nächste Funktion.  Auf diese Weise wird eine Art Förderer erhalten, mit dem Sie den RAM nicht mit überflüssigen Variablen verstopfen können, die Zwischenergebnisse speichern. </p><br><p>  Die Funktion <code>str_replace_all</code> entfernt eckige Klammern in der Spalte <em>ym.s.goalsID</em> .  <code>str_split</code> teilt die <code>str_split</code> aus der Spalte <em>ym.s.goalsID</em> in separate Werte auf und <code>unnest</code> teilt sie in separate Zeilen auf, wobei die Werte aller anderen Spalten dupliziert werden. </p><br><p>  Mit <code>mutate</code> wir Ziel-IDs in einen Integer-Typ um. </p><br><p>  <code>left_join</code> an das Ergebnis an, in dem Informationen zu den konfigurierten Zielen <code>left_join</code> .  Verwenden der Spalte <em>ym.s.goalsID</em> aus der aktuellen Tabelle und der Spalte <em>id</em> aus der <em>Zieltabelle</em> als Schlüssel. </p><br><p>  Schließlich benennt die Umbenennungsfunktion die <em>Namensspalte</em> in <em>Ereignisse um</em> . </p><br><p>  Jetzt hat die Tabelle <em>logs_goals</em> das <em>Aussehen</em> , das für die weitere Arbeit erforderlich ist. </p><br><p>  Erstellen Sie als Nächstes drei neue Tabellen: </p><br><ul><li>  first_visits - Daten der ersten Sitzungen für alle neuen Benutzer </li><li>  Warenkorb - Datum des Hinzufügens von Produkten zum Warenkorb </li><li>  Bestellungen - Bestellungen </li></ul><br><div class="spoiler">  <b class="spoiler_title">Code zur Tabellenerstellung</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#      first_visits &lt;- logs_goals %&gt;% filter(ym.s.isNewUser == 1 ) %&gt;% #     select(ym.s.clientID, #   clientID ym.s.date) #   date #       cart &lt;- logs_goals %&gt;% filter(events == "  ") %&gt;% select(ym.s.clientID, ym.s.date) #   orders &lt;- logs_goals %&gt;% filter(events == "   ") %&gt;% select(ym.s.clientID, ym.s.date)</code> </pre> </div></div><br><p>  Jede neue Tabelle ist das Ergebnis der Filterung der im letzten Schritt erhaltenen <em>Haupttabelle logs_goals</em> .  Die Filterung erfolgt durch die <code>filter</code> . </p><br><p>  Um Trichter zu erstellen, reicht es aus, Informationen über die Benutzer-ID und das Datum des Ereignisses, die in den <em>Spalten ym.s.clientID</em> und <em>ym.s.date</em> gespeichert sind, in den neuen Tabellen zu <em>belassen</em> .  Die gewünschten Spalten wurden mit der <code>select</code> . </p><br><h2 id="tipy-voronok">  Trichtertypen </h2><br><p>  Das Argument <em>type</em> akzeptiert eine beliebige Kombination der <code>lastbefore</code> <code>first</code> , <code>last</code> , <code>any</code> und <code>firstafter</code> mit <code>first</code> , <code>last</code> , <code>any</code> und <code>firstafter</code> .  Das Folgende ist ein Beispiel für die nützlichsten Kombinationen, die Sie verwenden können: </p><br><ul><li>  <code>first-first</code> : Ermittelt die frühesten <em>x-</em> und <em>y-</em> Ereignisse für jeden Benutzer.  Zum Beispiel möchten wir das Datum des <strong>ersten</strong> Besuchs und das Datum des <strong>ersten</strong> Kaufs erhalten. In diesem Fall verwenden Sie den Trichtertyp <code>first-first</code> . </li></ul><br><pre> <code class="plaintext hljs">#    first-first first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "first-first")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 42 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1552251706539589249 2019-04-18 2019-05-15 2 1554193975665391000 2019-04-02 2019-04-15 3 1554317571426012455 2019-04-03 2019-04-04 4 15544716161033564779 2019-04-05 2019-04-08 5 1554648729526295287 2019-04-07 2019-04-11 6 1554722099539384487 2019-04-08 2019-04-17 7 1554723388680198551 2019-04-08 2019-04-08 8 15547828551024398507 2019-04-09 2019-05-13 9 1554866701619747784 2019-04-10 2019-04-10 10 1554914125524519624 2019-04-10 2019-04-10 # ... with 32 more rows</code> </pre> <br><p>  Wir haben eine Tabelle erhalten, in der 1 Zeile Daten zum Datum des ersten Besuchs des Benutzers auf der Website und zum Datum seiner ersten Bestellung enthält. </p><br><ul><li>  <code>first-firstafter</code> : <code>first-firstafter</code> sich das früheste <em>x</em> , dann das erste <em>y</em> nach dem ersten <em>x</em> .  Beispielsweise hat ein Benutzer Ihre Website wiederholt besucht und im Verlauf der Besuche Produkte zum Warenkorb hinzugefügt. Wenn Sie das Datum des Hinzufügens des allerersten Produkts zum Warenkorb und das Datum der <strong>nächstgelegenen</strong> Bestellung <code>first-firstafter</code> , verwenden Sie den Trichtertyp " <code>first-firstafter</code> ". </li></ul><br><pre> <code class="plaintext hljs">cart %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "first-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 49 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-02 2019-04-05 2 1552251706539589249 2019-05-15 2019-05-15 3 1552997205196001429 2019-05-23 2019-05-23 4 1553261825377658768 2019-04-11 2019-04-11 5 1553541720631103579 2019-04-04 2019-04-05 6 1553761108775329787 2019-04-16 2019-04-16 7 1553828761648236553 2019-04-03 2019-04-03 8 1554193975665391000 2019-04-13 2019-04-15 9 1554317571426012455 2019-04-04 2019-04-04 10 15544716161033564779 2019-04-08 2019-04-08 # ... with 39 more rows</code> </pre> <br><ul><li>  <code>lastbefore-firstafter</code> : erstes <em>x</em> gefolgt von <em>y</em> vor dem nächsten <em>x</em> .  Beispielsweise hat ein Benutzer Ihre Website wiederholt besucht. Einige der Sitzungen endeten mit einem Kauf.  Wenn Sie das Datum der letzten Sitzung vor dem Kauf und das darauf folgende <code>lastbefore-firstafter</code> , verwenden Sie den Trichtertyp <code>lastbefore-firstafter</code> . </li></ul><br><pre> <code class="plaintext hljs">first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "lastbefore-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 50 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-05 2019-04-05 2 1552251706539589249 2019-05-15 2019-05-15 3 1552251706539589249 2019-05-16 2019-05-16 4 1552997205196001429 2019-05-23 2019-05-23 5 1553261825377658768 2019-04-11 2019-04-11 6 1553541720631103579 2019-04-05 2019-04-05 7 1553761108775329787 2019-04-16 2019-04-16 8 1553828761648236553 2019-04-03 2019-04-03 9 1554193975665391000 2019-04-15 2019-04-15 10 1554317571426012455 2019-04-04 2019-04-04 # ... with 40 more rows</code> </pre> <br><p>  In diesem Fall haben wir eine Tabelle erhalten, in der eine Zeile das Datum enthält, an dem das letzte Produkt vor Abschluss jeder Bestellung in den Warenkorb gelegt wurde, sowie das Datum der Bestellung selbst. </p><br><ul><li>  <code>any-firstafter</code> : <code>any-firstafter</code> sich alle <em>x</em> und das erste <em>y</em> danach.  Beispielsweise hat ein Benutzer Ihre Website wiederholt besucht, bei jedem Besuch verschiedene Produkte in den Warenkorb gelegt und regelmäßig Bestellungen mit allen hinzugefügten Produkten getätigt.  Wenn Sie die Daten aller Wareneingänge in den Warenkorb und die <code>any-firstafter</code> , verwenden Sie den Trichtertyp <code>any-firstafter</code> . </li></ul><br><pre> <code class="plaintext hljs">cart %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "any-firstafter")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 239 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1551433754595068897 2019-04-02 2019-04-05 2 1551433754595068897 2019-04-02 2019-04-05 3 1551433754595068897 2019-04-03 2019-04-05 4 1551433754595068897 2019-04-03 2019-04-05 5 1551433754595068897 2019-04-03 2019-04-05 6 1551433754595068897 2019-04-05 2019-04-05 7 1551433754595068897 2019-04-05 2019-04-05 8 1551433754595068897 2019-04-05 2019-04-05 9 1551433754595068897 2019-04-05 2019-04-05 10 1551433754595068897 2019-04-05 2019-04-05 # ... with 229 more rows</code> </pre> <br><ul><li>  any-any: Holen Sie sich alle <em>x</em> und alle <em>y</em> neben jedes <em>x</em> .  Sie möchten beispielsweise eine Liste aller Besuche auf der Website mit allen nachfolgenden Bestellungen jedes Benutzers erhalten. </li></ul><br><pre> <code class="plaintext hljs">first_visits %&gt;% after_inner_join(orders, by_user = "ym.s.clientID", by_time = "ym.s.date", type = "any-any")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 122 x 3 ym.s.clientID ym.s.date.x ym.s.date.y &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1552251706539589249 2019-04-18 2019-05-15 2 1552251706539589249 2019-04-18 2019-05-15 3 1552251706539589249 2019-04-18 2019-05-15 4 1552251706539589249 2019-04-18 2019-05-16 5 1554193975665391000 2019-04-02 2019-04-15 6 1554193975665391000 2019-04-02 2019-04-25 7 1554317571426012455 2019-04-03 2019-04-04 8 15544716161033564779 2019-04-05 2019-04-08 9 1554648729526295287 2019-04-07 2019-04-11 10 1554722099539384487 2019-04-08 2019-04-17 # ... with 112 more rows</code> </pre> <br><h3 id="shagi-po-voronke">  Trichterstufen </h3><br><p>  Die obigen Beispiele zeigen die Arbeit mit der Funktion <code>after_inner_join()</code> . Es ist praktisch, sie in Fällen zu verwenden, in denen alle Ereignisse durch separate Tabellen getrennt sind, in unserem Fall gemäß den Tabellen <em>first_visits</em> , <em>cart</em> und <em>orders</em> . </p><br><p>  Die Protokoll-API bietet Ihnen jedoch Informationen zu allen Ereignissen in einer Tabelle, und die Funktionen <code>funnel_start()</code> und <code>funnel_step()</code> sind eine bequemere Möglichkeit, eine Folge von Aktionen zu erstellen.  <code>funnel_start</code> hilft beim <code>funnel_start</code> des ersten Schritts des Trichters und verwendet fünf Argumente: </p><br><ul><li>  tbl - Ereignistabelle; </li><li>  moment_type - Das erste Ereignis im Trichter; </li><li>  Moment - Der Name der Spalte, die den Namen des Ereignisses enthält. </li><li>  tstamp - Name der Spalte mit dem Datum, an dem das Ereignis aufgetreten ist; </li><li>  Benutzer - Der Name der Spalte mit den Benutzerkennungen. </li></ul><br><pre> <code class="plaintext hljs">logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = "   ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 52 x 2 ym.s.clientID `ym.s.date_   ` &lt;chr&gt; &lt;date&gt; 1 1556018960123772801 2019-04-24 2 1561216372134023321 2019-06-22 3 1556955573636389438 2019-05-04 4 1559220890220134879 2019-05-30 5 1553261825377658768 2019-04-11 6 1561823182372545402 2019-06-29 7 1556047887455246275 2019-04-23 8 1554722099539384487 2019-04-17 9 1555420652241964245 2019-04-17 10 1553541720631103579 2019-04-05 # ... with 42 more rows</code> </pre> <br><p>  <code>funnel_start</code> gibt eine Tabelle mit den <em>Spalten ym.s.clientI</em> und <em>ym.s.date_ zurück</em> <code>ym.s.date_   </code> (der Name Ihrer Spalte mit dem Datum, _ und dem Namen des Ereignisses). </p><br><p>  Die folgenden Schritte können mit der Funktion <code>funnel_step()</code> hinzugefügt werden.  In <code>funnel_start</code> wir bereits die Bezeichner aller erforderlichen Spalten angegeben. Jetzt müssen wir mithilfe des Argumentes <em>moment_type</em> angeben, welches Ereignis der nächste Schritt im Trichter sein <em>soll</em> , und der Verbindungstyp ist <em>type</em> (z. B. <code>"first-first"</code> , <code>"first-any"</code> ). </p><br><pre> <code class="plaintext hljs">logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = "  ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_step(moment_type = "   ", type = "first-last")</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 319 x 3 ym.s.clientID `ym.s.date_  ` `ym.s.date_   ` &lt;chr&gt; &lt;date&gt; &lt;date&gt; 1 1550828847886891355 2019-04-01 NA 2 1551901759770098825 2019-04-01 NA 3 1553595703262002507 2019-04-01 NA 4 1553856088331234886 2019-04-01 NA 5 1554044683888242311 2019-04-01 NA 6 1554095525459102609 2019-04-01 NA 7 1554100987632346537 2019-04-01 NA 8 1551433754595068897 2019-04-02 2019-04-05 9 1553627918798485452 2019-04-02 NA 10 155418104743178061 2019-04-02 NA # ... with 309 more rows</code> </pre> <br><p>  Mit <code>funnel_step</code> Sie Trichter mit einer beliebigen Anzahl von Schritten erstellen.  In meinem Beispiel können Sie den folgenden Code verwenden, um für jeden Benutzer einen vollständigen Trichter zu erstellen: </p><br><div class="spoiler">  <b class="spoiler_title">Code zum Erstellen eines vollständigen Trichters für jeden Benutzer</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#         #     events - " " logs_goals &lt;- logs_goals %&gt;% filter(ym.s.isNewUser == 1 ) %&gt;% mutate(events = " ") %&gt;% bind_rows(logs_goals) #     logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_step(moment_type = "  ", type = "first-last") %&gt;% funnel_step(moment_type = "  ", type = "first-last") %&gt;% funnel_step(moment_type = "   ", type = "first-last")</code> </pre> </div></div><br><p>  Und jetzt ist die Kirsche auf dem Kuchen <code>summarize_funnel()</code> .  Eine Funktion, mit der Sie den Prozentsatz der Benutzer anzeigen können, die vom vorherigen zum nächsten Schritt gewechselt sind, und den Prozentsatz der Benutzer, die vom ersten Schritt zum nächsten übergegangen sind. </p><br><pre> <code class="plaintext hljs">my_funnel &lt;- logs_goals %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_steps(moment_type = c("  ", "  ", "   "), type = "first-last") %&gt;% summarize_funnel()</code> </pre> <br><pre> <code class="plaintext hljs"># A tibble: 4 x 4 moment_type nb_step pct_cumulative pct_step &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1   18637 1 NA 2    1589 0.0853 0.0853 3    689 0.0494 0.579 4     34 0.0370 0.749</code> </pre> <br><p> <code>nb_step</code> —   ,   , <code>pct_cumulative</code> —      ,  <code>pct_step</code> —    . </p><br><h1 id="vizualizaciya-voronki">   </h1><br><p>    <em>my_funnel</em>   ,        <code>ggplot2</code> . </p><br><p> <code>ggplot2</code> —       R,      .     ,      ,  . </p><br><p>  <code>ggplot2</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  </a> ,     2005 .    ,    photoshop,  ,       . </p><br><h3 id="vizualizaciya-obschey-voronki">    </h3><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># install.packages("ggplot2") library(ggplot2) my_funnel %&gt;% mutate(padding = (sum(my_funnel$nb_step) - nb_step) / 2) %&gt;% gather(key = "variable", value = "val", -moment_type) %&gt;% filter(variable %in% c("nb_step", "padding")) %&gt;% arrange(desc(variable)) %&gt;% mutate(moment_type = factor(moment_type, levels = c("   ", "  ", "  ", " "))) %&gt;% ggplot( aes(x = moment_type) ) + geom_bar(aes(y = val, fill = variable), stat='identity', position='stack') + scale_fill_manual(values = c('coral', NA) ) + geom_text(data = my_funnel, aes(y = sum(my_funnel$nb_step) / 2, label = paste(round(round(pct_cumulative * 100,2)), '%')), colour='tomato4', fontface = "bold") + coord_flip() + theme(legend.position = 'none') + labs(x='moment', y='volume')</code> </pre> </div></div><br><p>         : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/260/763/bcf/260763bcf4c60a84ab713d2931e95ebe.png" alt="Trichtervisualisierung"></p><br><p>     . </p><br><ol><li>         <em>my_funnel</em> . </li><li> <code>ggplot</code> —      ,    ,     ,    X     <em>moment_type</em> . </li><li> <code>geom_bar</code> —  —  ,            <code>aes</code> . </li><li> <code>scale_fill_manual</code> —    ,         ,    . </li><li> <code>geom_text</code> —   ,   %    . </li><li> <code>coord_flip</code> —   ,     . </li><li> <code>theme</code> —      : ,   ..           . </li><li> <code>labs</code> —     . </li></ol><br><h3 id="vizualizaciya-voronki-v-razreze-kanalov-trafika">       </h3><br><p>     ,   ,  ,      ,    . </p><br><p>           <code>lapply</code> ,       R.        ,      ,        <code>bind_rows</code> . </p><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#        first_visits &lt;- rename(first_visits, firstSource = ym.s.lastTrafficSource) #          logs_goals &lt;- select(first_visits, ym.s.clientID, firstSource) %&gt;% left_join(logs_goals, ., by = "ym.s.clientID") #     my_multi_funnel &lt;- lapply(c("ad", "organic", "direct"), function(source) { logs_goals %&gt;% filter(firstSource == source) %&gt;% select(events, ym.s.clientID, ym.s.date) %&gt;% funnel_start(moment_type = " ", moment = "events", tstamp = "ym.s.date", user = "ym.s.clientID") %&gt;% funnel_steps(moment_type = c("  ", "  ", "   "), type = "first-last") %&gt;% summarize_funnel() %&gt;% mutate(firstSource = source) }) %&gt;% bind_rows() #  </code> </pre></div></div><br><pre> <code class="plaintext hljs"># A tibble: 12 x 5 moment_type nb_step pct_cumulative pct_step firstSource &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1   14392 1 NA ad 2    154 0.0107 0.0107 ad 3    63 0.00438 0.409 ad 4     14 0.000973 0.222 ad 5   3372 1 NA organic 6    68 0.0202 0.0202 organic 7    37 0.0110 0.544 organic 8     13 0.00386 0.351 organic 9   607 1 NA direct 10    49 0.0807 0.0807 direct 11    21 0.0346 0.429 direct 12     8 0.0132 0.381 direct</code> </pre> <br><p>     <em>my_multi_funnel</em> ,        . </p><br><div class="spoiler"> <b class="spoiler_title">       </b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    my_multi_funnel %&gt;% mutate(padding = ( 1 - pct_cumulative) / 2 ) %&gt;% gather(key = "variable", value = "val", -moment_type, -firstSource) %&gt;% filter(variable %in% c("pct_cumulative", "padding")) %&gt;% arrange(desc(variable)) %&gt;% mutate(moment_type = factor(moment_type, levels = c("   ", "  ", "  ", " ")), variable = factor(variable, levels = c("pct_cumulative", "padding"))) %&gt;% ggplot( aes(x = moment_type) ) + geom_bar(aes(y = val, fill = variable), stat='identity', position='stack') + scale_fill_manual(values = c('coral', NA) ) + geom_text(data = my_multi_funnel_df, aes(y = 1 / 2, label =paste(round(round(pct_cumulative * 100, 2)), '%')), colour='tomato4', fontface = "bold") + coord_flip() + theme(legend.position = 'none') + labs(x='moment', y='volume') + facet_grid(. ~ firstSource)</code> </pre> </div></div><br><p>      : <br><img src="https://habrastorage.org/getpro/habr/post_images/12d/9a7/631/12d9a7631235b42f1081d996fa7eec62.png" alt="Kanaltrichter"></p><br><p>     ? </p><br><ol><li>   <code>first_visits</code>    <code>ym.s.lastTrafficSource</code>  <code>firstSource</code> . </li><li>   <code>left_join</code>          <em>ym.s.clientID</em> .                 <code>firstSource</code> . </li><li>   <code>lapply</code>        ad, organic  direct.         <code>bind_rows</code> . </li><li>      <code>facet_grid(. ~ firstSource)</code> ,         <code>firstSource</code> . </li></ol><br><h1 id="ps">  PS </h1><br><p>    .       <strong>PS</strong>      ,       R.           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">R4marketing</a> ,          R        . </p><br><p>    : </p><br><ul><li> ; </li><li> ; </li><li> ; </li><li>         R. </li></ul><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>  ,    ,        R     : </p><br><ol><li>             .; </li><li>   R    RStudio; </li><li>   <code>rym</code> , <code>funneljoin</code>  <code>ggplot2</code> ; </li><li>    <code>rym</code>   <code>rym_get_logs()</code>    .; </li><li>    <code>funneljoin</code>      . </li><li>      <code>ggplot2</code> . </li></ol><br><p>           ,     Logs API  ,      : CRM, 1   . ,         :  ,    -. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462279/">https://habr.com/ru/post/de462279/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462269/index.html">John Romero to Doom: 80er Jahre Game Dev</a></li>
<li><a href="../de462271/index.html">Sperrcode in iOS: Wie Apple von Verteidigung zu Verteidigung zur Bewachung einer einzelnen Grenze wechselte</a></li>
<li><a href="../de462273/index.html">Verwalten Sie Ihren Laptopständer mit digispark</a></li>
<li><a href="../de462275/index.html">Einführung in PVS-Studio Static Analyzer für Java</a></li>
<li><a href="../de462277/index.html">Technisches Release Mail.ru Group 2019</a></li>
<li><a href="../de462283/index.html">GAZ-66 Spielzeug auf dem Bedienfeld. Teil 1</a></li>
<li><a href="../de462293/index.html">Wie schnelle Entwicklungstechnologien zu unangenehmen Sicherheitslücken führen können</a></li>
<li><a href="../de462295/index.html">Die Verzeichnisgröße ist unsere Mühe nicht wert</a></li>
<li><a href="../de462297/index.html">Habr Weekly # 12 / OneWeb, Stationen gegen Aggregatoren, Gehälter in der IT, "Liebes, wir töten das Internet" waren in der Russischen Föderation nicht erlaubt</a></li>
<li><a href="../de462299/index.html">Rundung auf das Ganze in .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>