<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛰️ 🙊 🌹 Pemrograman Java Fungsional dengan Vavr 👩🏾‍🏫 🙆🏼 🏊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak yang telah mendengar bahasa fungsional seperti Haskell dan Clojure. Tetapi ada bahasa seperti Scala, misalnya. Ini menggabungkan OOP dan pendek...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemrograman Java Fungsional dengan Vavr</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421839/">  Banyak yang telah mendengar bahasa fungsional seperti Haskell dan Clojure.  Tetapi ada bahasa seperti Scala, misalnya.  Ini menggabungkan OOP dan pendekatan fungsional.  Bagaimana dengan Jawa tua yang baik?  Apakah mungkin untuk menulis program dengan gaya fungsional di atasnya dan seberapa besar kerugiannya?  Ya, ada Java 8 dan lambdas dengan stream.  Ini adalah langkah besar untuk bahasa, tetapi itu masih belum cukup.  Apakah mungkin untuk menemukan sesuatu dalam situasi ini?  Ternyata iya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u2/tp/cr/u2tpcrdrjmcmw9yvj9ptnbsuiwo.jpeg"></div><br><a name="habracut"></a><br>  Untuk memulai, mari kita coba menentukan apa arti penulisan kode dengan gaya fungsional.  Pertama, kita harus beroperasi bukan dengan variabel dan manipulasi dengannya, tetapi dengan rantai perhitungan.  Intinya, urutan fungsi.  Selain itu, kita harus memiliki struktur data khusus.  Misalnya, koleksi java standar tidak cocok.  Itu akan segera menjadi jelas mengapa. <br><br>  Mari kita pertimbangkan struktur fungsional secara lebih detail.  Setiap struktur seperti itu harus memenuhi setidaknya dua syarat: <br><br><ul><li>  <b><i>kekal</i></b> - struktur harus kekal.  Ini berarti bahwa kita memperbaiki keadaan objek pada tahap penciptaan dan membiarkannya seperti itu sampai akhir keberadaannya.  Contoh nyata pelanggaran kondisi: standar ArrayList. </li><li>  <b>persisten</b> - struktur harus disimpan dalam memori selama mungkin.  Jika kita membuat beberapa objek, maka alih-alih membuat yang baru dengan status yang sama, kita harus menggunakan yang siap.  Secara lebih formal, struktur tersebut mempertahankan semua status sebelumnya setelah modifikasi.  Referensi untuk kondisi ini harus tetap beroperasi penuh. </li></ul><br>  Jelas, kita membutuhkan semacam solusi pihak ketiga.  Dan ada solusi seperti itu: Perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VAVR</a> .  Hari ini adalah perpustakaan <i>Java</i> paling populer untuk bekerja dalam gaya fungsional.  Selanjutnya, saya akan menjelaskan fitur-fitur utama perpustakaan.  Banyak, tetapi tidak berarti semua, contoh dan deskripsi diambil dari dokumentasi resmi. <br><br><h2>  Struktur data utama perpustakaan <b>vavr</b> </h2><br><h3>  Tuple </h3><br>  Salah satu struktur data fungsional yang paling dasar dan sederhana adalah tupel.  Sebuah tuple adalah seperangkat panjang tetap yang dipesan.  Tidak seperti daftar, tuple dapat berisi data jenis apa pun. <br><br><pre><code class="java hljs">Tuple tuple = Tuple.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"blablabla"</span></span>, .<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">// (1, blablabla, 0.0, 42)</span></span></code> </pre> <br>  Mendapatkan item yang diinginkan datang dari memanggil bidang dengan nomor item di tuple. <br><br><pre> <code class="java hljs">((Tuple4) tuple)._1 <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  Harap dicatat: pengindeksan tuple dimulai pada 1!  Selain itu, untuk mendapatkan elemen yang diinginkan, kita harus mengubah objek kita ke tipe yang diinginkan dengan serangkaian metode yang sesuai.  Dalam contoh di atas, kami menggunakan tupel dari 4 elemen, yang berarti konversi harus dari tipe <i>Tuple4</i> .  Bahkan, tidak ada yang menghentikan kita dari membuat jenis yang tepat. <br><br><pre> <code class="java hljs">Tuple4 tuple = Tuple.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"blablabla"</span></span>, .<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">42L</span></span>); <span class="hljs-comment"><span class="hljs-comment">// (1, blablabla, 0.0, 42) System.out.println(tuple._1); // 1</span></span></code> </pre> <br><h3>  3 koleksi vavr teratas </h3><br><h4>  Daftar </h4><br>  Membuat daftar dengan vavr sangat sederhana.  Bahkan lebih mudah daripada tanpa <i>vavr</i> . <br><br><pre> <code class="java hljs">List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br>  Apa yang bisa kita lakukan dengan daftar seperti itu?  Pertama, kita bisa mengubahnya menjadi daftar <i>java</i> standar. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containThree = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .asJava() .stream() .anyMatch(x -&gt; x == <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  Tetapi pada kenyataannya, ini tidak terlalu diperlukan, karena  bisa kita lakukan, misalnya, seperti ini: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containThree = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .find(x -&gt; x == <span class="hljs-number"><span class="hljs-number">1</span></span>) .isDefined();</code> </pre> <br>  Secara umum, <i>daftar</i> pustaka <i>vavr</i> standar memiliki banyak metode yang berguna.  Misalnya, ada fungsi konvolusi yang cukup kuat yang memungkinkan Anda untuk menggabungkan daftar nilai dengan beberapa aturan dan elemen netral. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   final int zero = 0; //   final BiFunction&lt;Integer, Integer, Integer&gt; combine = (x, y) -&gt; x + y; //   final int sum = List.of(1, 2, 3) .fold(zero, combine); //  </span></span></code> </pre> <br>  Satu poin penting harus diperhatikan di sini.  Kami memiliki struktur data fungsional, yang berarti bahwa kami tidak dapat mengubah statusnya.  Bagaimana daftar kami diimplementasikan?  Array tidak cocok untuk kita. <br><br>  <b>Daftar Tertaut sebagai daftar default</b> <br><br>  Mari kita membuat daftar yang hanya ditautkan dengan benda yang tidak dapat diubah.  Akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/lr/4p/xn/lr4pxnezcvipnsgaownffgw6ewq.png" alt="gambar"><br><br><div class="spoiler">  <b class="spoiler_title">Contoh kode</b> <div class="spoiler_text"><pre> <code class="java hljs">List list = List.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br></div></div><br>  Setiap elemen dari daftar memiliki dua metode utama: memperoleh elemen kepala (kepala) dan yang lainnya (ekor). <br><br><div class="spoiler">  <b class="spoiler_title">Contoh kode</b> <div class="spoiler_text"><pre> <code class="java hljs">list.head(); <span class="hljs-comment"><span class="hljs-comment">// 1 list.tail(); // List(2, 3)</span></span></code> </pre> <br></div></div><br>  Sekarang, jika kita ingin mengubah elemen pertama dalam daftar (dari 1 ke 0), maka kita perlu membuat daftar baru dengan menggunakan kembali bagian jadi. <br><br><img src="https://habrastorage.org/webt/hu/xc/lp/huxclpxqlaunelfqyqu259ayj9o.png" alt="gambar"><br><div class="spoiler">  <b class="spoiler_title">Contoh kode</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List tailList = list.tail(); <span class="hljs-comment"><span class="hljs-comment">//    tailList.prepend(0); //     </span></span></code> </pre> <br></div></div><br>  Dan itu saja!  Karena objek kami di lembar kerja tidak dapat diubah, kami mendapatkan koleksi yang aman dan dapat digunakan kembali.  Elemen daftar kami dapat diterapkan di mana saja di aplikasi dan itu benar-benar aman! <br><br><h4>  Antrian </h4><br>  Struktur data lain yang sangat berguna adalah antrian.  Bagaimana cara membuat antrian untuk membangun program yang efektif dan andal dalam gaya fungsional?  Sebagai contoh, kita dapat mengambil struktur data yang sudah kita ketahui: dua daftar dan satu tupel. <br><br><img src="https://habrastorage.org/webt/bi/bp/sb/bibpsbx_odpxx2kdupxg0l4ufku.png" alt="gambar"><br><br><div class="spoiler">  <b class="spoiler_title">Contoh kode</b> <div class="spoiler_text"><pre> <code class="java hljs">Queue&lt;Integer&gt; queue = Queue.of(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) .enqueue(<span class="hljs-number"><span class="hljs-number">4</span></span>) .enqueue(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br></div></div><br>  Saat yang pertama berakhir, kami memperluas yang kedua dan menggunakannya untuk membaca. <br><br><img src="https://habrastorage.org/webt/b5/ho/zz/b5hozzqnmnm8fyhoebj3g3d7c_0.png" alt="gambar"><br><br><img src="https://habrastorage.org/webt/ld/_e/ly/ld_ely_1i5buzwbadpirjf0f1gc.png" alt="gambar"><br><br>  Penting untuk diingat bahwa antrian harus tidak berubah, seperti semua struktur lainnya.  Tapi apa gunanya antrian yang tidak berubah?  Padahal, ada trik.  Sebagai nilai antrian yang diterima, kami mendapatkan dua elemen.  Pertama: elemen antrian yang diinginkan, kedua: apa yang terjadi pada antrian tanpa elemen ini. <br><br><pre> <code class="java hljs">System.out.println(queue); <span class="hljs-comment"><span class="hljs-comment">// Queue(1, 2, 3, 4, 5) Tuple2&lt;Integer, Queue&lt;Integer&gt;&gt; tuple2 = queue.dequeue(); System.out.println(tuple2._1); // 1 System.out.println(tuple2._2); // Queue(2, 3, 4, 5)</span></span></code> </pre> <br><h4>  Streaming </h4><br>  Struktur data penting berikutnya adalah stream.  Aliran adalah aliran pelaksanaan beberapa tindakan pada set nilai tertentu, seringkali abstrak. <br><br>  Seseorang mungkin mengatakan bahwa <i>Java 8</i> sudah memiliki aliran penuh dan kami tidak membutuhkan yang baru sama sekali.  Benarkah begitu? <br><br>  Untuk memulai, mari pastikan <i>java stream</i> bukan struktur data fungsional.  Periksa struktur untuk mutabilitas.  Untuk melakukan ini, buat aliran kecil seperti itu: <br><pre> <code class="java hljs">IntStream standardStream = IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre> <br>  Kami akan memilah-milah semua elemen di aliran: <br><br><pre> <code class="java hljs">standardStream.forEach(System.out::print);</code> </pre> <br>  Sebagai tanggapan, kami mendapatkan output ke konsol: <i>123456789</i> .  Mari kita ulangi operasi brute force: <br><br><pre> <code class="java hljs">standardStream.forEach(System.out::print);</code> </pre> <br>  Ups, terjadi kesalahan berikut: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed</code> </pre><br>  Faktanya adalah stream standar hanya semacam abstraksi atas iterator.  Meskipun aliran di luar tampak sangat independen dan kuat, minus iterator belum hilang. <br><br>  Misalnya, definisi aliran tidak mengatakan apa pun tentang membatasi jumlah elemen.  Sayangnya, itu ada di iterator, yang berarti di stream standar. <br><br>  Untungnya, pustaka vavr memecahkan masalah ini.  Pastikan ini: <br><br><pre> <code class="java hljs">Stream stream = Stream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); stream.forEach(System.out::print); stream.forEach(System.out::print);</code> </pre> <br>  Sebagai tanggapan, kami mendapatkan <i>123456789123456789</i> .  Yang berarti operasi pertama tidak "merusak" aliran kami. <br><br>  Mari kita coba membuat aliran tanpa akhir: <br><br>  Stream infiniteStream = Stream.from (1); <br>  System.out.println (infiniteStream);  // Streaming (1 ,?) <br><br>  Harap dicatat: saat mencetak objek, kita tidak mendapatkan struktur yang tak terbatas, tetapi elemen pertama dan tanda tanya.  Faktanya adalah bahwa setiap elemen berikutnya dalam aliran dihasilkan dengan cepat.  Pendekatan ini disebut inisialisasi malas.  Dialah yang memungkinkan Anda untuk bekerja dengan aman dengan struktur seperti itu. <br><br>  Jika Anda belum pernah bekerja dengan struktur data tanpa batas, maka kemungkinan besar Anda berpikir: mengapa ini perlu?  Tetapi mereka bisa sangat nyaman.  Kami menulis aliran yang mengembalikan jumlah angka ganjil yang sewenang-wenang, mengubahnya menjadi string dan menambahkan spasi: <br><br><pre> <code class="java hljs">Stream oddNumbers = Stream .from(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  1   2 .map(x -&gt; x + " "); //  //   oddNumbers.take(5) .forEach(System.out::print); // 1 3 5 7 9 oddNumbers.take(10) .forEach(System.out::print); // 1 3 5 7 9 11 13 15 17 19</span></span></code> </pre> <br>  Sangat sederhana. <br><br><h3>  Struktur umum koleksi </h3><br>  Setelah kita membahas struktur dasar, saatnya untuk melihat arsitektur umum koleksi fungsional <i>vavr</i> : <br><br><img src="https://habrastorage.org/webt/m2/ae/wl/m2aewlwyky8-r-dktx1asgvxqgy.png"><br><br>  Setiap elemen struktur dapat digunakan sesuai keinginan: <br><br><pre> <code class="java hljs">StringBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringBuilder(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String word : List.of(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (builder.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { builder.append(<span class="hljs-string"><span class="hljs-string">", "</span></span>); } builder.append(word); } System.out.println(builder.toString()); <span class="hljs-comment"><span class="hljs-comment">// one, two, tree</span></span></code> </pre> <br>  Tetapi Anda harus berpikir dua kali dan melihat dermaga sebelum menggunakannya.  Perpustakaan memungkinkan Anda untuk mempermudah hal-hal yang sudah dikenal. <br><br><pre> <code class="java hljs">System.out.println(List.of(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"tree"</span></span>).mkString(<span class="hljs-string"><span class="hljs-string">", "</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// one, two, tree</span></span></code> </pre> <br><h2>  Bekerja dengan fungsi </h2><br>  Perpustakaan memiliki sejumlah fungsi (8 buah) dan metode yang berguna untuk bekerja dengannya.  Mereka adalah antarmuka fungsional biasa dengan banyak metode menarik.  Nama fungsi tergantung pada jumlah argumen yang diterima (dari 0 hingga 8).  Misalnya, <i>Function0</i> tidak mengambil argumen, <i>Function1</i> mengambil satu argumen, <i>Function2</i> mengambil dua argumen, dll. <br><br><pre> <code class="java hljs">Function2&lt;String, String, String&gt; combineName = (lastName, firstName) -&gt; firstName + <span class="hljs-string"><span class="hljs-string">" "</span></span> + lastName; System.out.println(combineName.apply(<span class="hljs-string"><span class="hljs-string">"Griffin"</span></span>, <span class="hljs-string"><span class="hljs-string">"Peter"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// Peter Griffin</span></span></code> </pre> <br>  Dalam fungsi pustaka vavr, kita dapat melakukan banyak hal keren.  Dalam hal fungsionalitas, mereka unggul jauh dari Fungsi standar, BiFungsi, dll.  Misalnya, kari.  Kari adalah pembangunan fungsi di bagian-bagian.  Mari kita lihat sebuah contoh: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    Function2&lt;String, String, String&gt; combineName = (lastName, firstName) -&gt; firstName + " " + lastName; //           Function1&lt;String, String&gt; makeGriffinName = combineName .curried() .apply("Griffin"); //      System.out.println(makeGriffinName.apply("Peter")); // Peter Griffin System.out.println(makeGriffinName.apply("Lois")); // Lois Griffin</span></span></code> </pre> <br>  Seperti yang Anda lihat, cukup ringkas.  Metode <i>kari</i> sangat sederhana, tetapi bisa sangat berguna. <br><br><div class="spoiler">  <b class="spoiler_title">Implementasi metode kari</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Function1&lt;T1, Function1&lt;T2, R&gt;&gt; curried() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t1 -&gt; t2 -&gt; apply(t1, t2); }</code> </pre><br></div></div><br>  Ada banyak metode yang lebih berguna dalam Kumpulan <i>fungsi</i> .  Misalnya, Anda dapat menembolok hasil pengembalian suatu fungsi: <br><br><pre> <code class="java hljs">Function0&lt;Double&gt; hashCache = Function0.of(Math::random).memoized(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> randomValue1 = hashCache.apply(); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> randomValue2 = hashCache.apply(); System.out.println(randomValue1 == randomValue2); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br><br><h2>  Berjuang melawan pengecualian </h2><br>  Seperti yang kami katakan sebelumnya, proses pemrograman harus aman.  Untuk melakukan ini, perlu untuk menghindari berbagai efek asing.  Pengecualian adalah generator eksplisit mereka. <br><br>  Anda bisa menggunakan kelas <i>Coba</i> untuk menangani pengecualian dengan aman dalam gaya fungsional.  Padahal, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">monad yang</a> khas.  Untuk mempelajari teori untuk digunakan tidak perlu.  Lihat saja contoh sederhana: <br><br><pre> <code class="java hljs">Try.of(() -&gt; <span class="hljs-number"><span class="hljs-number">4</span></span> / <span class="hljs-number"><span class="hljs-number">0</span></span>) .onFailure(System.out::println) .onSuccess(System.out::println);</code> </pre> <br>  Seperti yang dapat Anda lihat dari contoh, semuanya cukup sederhana.  Kami hanya menggantung acara pada kesalahan potensial dan tidak membawanya melampaui batas perhitungan. <br><br><h2>  Pencocokan pola </h2><br>  Seringkali muncul situasi di mana kita perlu memeriksa nilai variabel dan memodelkan perilaku program tergantung pada hasilnya.  Hanya dalam situasi seperti itu, mesin pencari template yang bagus datang untuk menyelamatkan.  Anda tidak lagi harus menulis banyak <i>jika lain</i> , cukup konfigurasikan semua logika di satu tempat. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> io.vavr.API.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> io.vavr.Predicates.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PatternMatchingDemo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ String s = Match(<span class="hljs-number"><span class="hljs-number">1993</span></span>).of( Case($(<span class="hljs-number"><span class="hljs-number">42</span></span>), () -&gt; <span class="hljs-string"><span class="hljs-string">"one"</span></span>), Case($(anyOf(isIn(<span class="hljs-number"><span class="hljs-number">1990</span></span>, <span class="hljs-number"><span class="hljs-number">1991</span></span>, <span class="hljs-number"><span class="hljs-number">1992</span></span>), is(<span class="hljs-number"><span class="hljs-number">1993</span></span>))), <span class="hljs-string"><span class="hljs-string">"two"</span></span>), Case($(), <span class="hljs-string"><span class="hljs-string">"?"</span></span>) ); System.out.println(s); <span class="hljs-comment"><span class="hljs-comment">// two } }</span></span></code> </pre> <br>  Harap dicatat Kasus dikapitalisasi, sebagai  kasing adalah kata kunci dan sudah diambil. <br><br><h2>  Kesimpulan </h2><br>  Menurut pendapat saya, perpustakaan itu sangat keren, tetapi layak menggunakannya dengan sangat hati-hati.  Dia bisa melakukan yang terbaik dalam pengembangan <i>berbasis acara</i> .  Namun, penggunaannya yang berlebihan dan tidak dipikirkan dalam pemrograman imperatif standar berdasarkan pada thread pool dapat membawa banyak sakit kepala.  Selain itu, sering dalam proyek kami, kami menggunakan Spring dan Hibernate, yang tidak selalu siap untuk aplikasi seperti itu.  Sebelum mengimpor perpustakaan ke proyek Anda, Anda perlu pemahaman yang jelas tentang bagaimana dan mengapa itu akan digunakan.  Apa yang akan saya bicarakan di salah satu artikel saya berikutnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421839/">https://habr.com/ru/post/id421839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421827/index.html">Apa yang harus dibaca tentang Java sekarang?</a></li>
<li><a href="../id421829/index.html">Anomali Frango - romansa fantastis dengan orang-orang nyata dari IT</a></li>
<li><a href="../id421833/index.html">Kami menulis program kami yang paling sederhana untuk ARM Cortex-M3</a></li>
<li><a href="../id421835/index.html">Komisi Antarlembaga mengembangkan teknologi baru untuk memblokir Telegram</a></li>
<li><a href="../id421837/index.html">Membuat kekacauan 1k intro untuk ZX-Spectrum</a></li>
<li><a href="../id421841/index.html">Robotaxi Waymo tidak cukup siap untuk mengakses jalan umum</a></li>
<li><a href="../id421845/index.html">Apa yang sebenarnya dilakukan analis data? Temuan dari 35 Wawancara</a></li>
<li><a href="../id421847/index.html">Lompat ke awan. Membangun solusi IoT anggaran di NodeMCU + Azure IoT Hub</a></li>
<li><a href="../id421849/index.html">Acara untuk SDM di bidang TI pada bulan September 2018: My Circle Digest</a></li>
<li><a href="../id421851/index.html">Masalah burung hantu dan bola dunia: menghubungkan dua majelis dengan ruang nama dan nama kelas yang identik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>