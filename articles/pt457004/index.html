<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçß üëãüèΩ üìÇ M√©todos simples para otimizar programas Go üò† ‚ôàÔ∏è üö¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Eu sempre me preocupo com desempenho. Eu n√£o sei exatamente o porqu√™. Mas fico chateado com servi√ßos e programas lentos. Parece que n√£o estou sozinho ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√©todos simples para otimizar programas Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457004/">  Eu sempre me preocupo com desempenho.  Eu n√£o sei exatamente o porqu√™.  Mas fico chateado com servi√ßos e programas lentos.  Parece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">que n√£o estou sozinho</a> . <br><br><blockquote>  <i>Nos testes A / B, tentamos diminuir a produ√ß√£o de p√°ginas em incrementos de 100 milissegundos e descobrimos que mesmo atrasos muito pequenos levam a uma queda significativa na receita.</i>  - Greg Linden, Amazon.com </blockquote><br>  Por experi√™ncia, a baixa produtividade se manifesta de duas maneiras: <br><br><ul><li>  Opera√ß√µes com bom desempenho em pequena escala tornam-se invi√°veis ‚Äã‚Äãcom um n√∫mero crescente de usu√°rios.  Geralmente, essas s√£o opera√ß√µes O (N) ou O (N¬≤).  Quando a base de usu√°rios √© pequena, tudo funciona bem.  O produto tem pressa de trazer para o mercado.  √Ä medida que a base cresce, surgem cada vez mais situa√ß√µes patol√≥gicas inesperadas - e o servi√ßo para. <br></li><li> Muitas fontes individuais de trabalho sub√≥timo, "morte por mil cortes". </li></ul><a name="habracut"></a><br>  Durante a maior parte da minha carreira, estudei ci√™ncia de dados com Python ou criei servi√ßos no Go.  No segundo caso, tenho muito mais experi√™ncia em otimiza√ß√£o.  Go geralmente n√£o √© um gargalo nos servi√ßos que eu escrevo - os programas de banco de dados geralmente s√£o limitados por E / S.  No entanto, nos pipelines de lote de aprendizado de m√°quina que desenvolvi, o programa geralmente √© limitado pela CPU.  Se o Go usar muito o processador, existem v√°rias estrat√©gias. <br><br>  Este artigo explica alguns m√©todos que podem ser usados ‚Äã‚Äãpara aumentar significativamente a produtividade sem muito esfor√ßo.  Eu deliberadamente ignoro m√©todos que exigem esfor√ßo significativo ou grandes altera√ß√µes na estrutura do programa. <br><br><h1>  Antes de come√ßar </h1><br>  Antes de fazer altera√ß√µes no programa, reserve um tempo para criar uma linha de base adequada para compara√ß√£o.  Caso contr√°rio, voc√™ vagar√° no escuro, se perguntando se h√° algum benef√≠cio com as altera√ß√µes feitas.  Primeiro, escreva benchmarks e obtenha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">perfis</a> para uso no pprof.  √â melhor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escrever a refer√™ncia tamb√©m no Go</a> : isso facilita o uso de perfis de pprof e mem√≥ria.  Use tamb√©m o benchcmp: uma ferramenta √∫til para comparar as diferen√ßas de desempenho entre os testes. <br><br>  Se o c√≥digo n√£o for muito compat√≠vel com os benchmarks, comece com algo que possa ser medido.  Voc√™ pode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criar um</a> perfil manual do c√≥digo com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">runtime / pprof</a> . <br><br>  Ent√£o, vamos come√ßar! <br><br><h3>  Use sync.Pool para reutilizar objetos selecionados anteriormente </h3><br>  O sync.Pool implementa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uma lista de libera√ß√£o</a> .  Isso permite reutilizar estruturas alocadas anteriormente e amortiza a distribui√ß√£o do objeto em v√°rios usos, reduzindo o trabalho do coletor de lixo.  A API √© muito simples.  Implemente uma fun√ß√£o que aloque uma nova inst√¢ncia de um objeto.  A API retornar√° o tipo de ponteiro. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bufpool = sync.Pool{ New: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span>{} { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">512</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;buf }}</code> </pre> <br>  Depois disso, voc√™ pode fazer objetos <code>Get()</code> do pool e <code>Put()</code> los de volta quando terminar. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// sync.Pool returns a interface{}: you must cast it to the underlying type // before you use it. b := *bufpool.Get().(*[]byte) defer bufpool.Put(&amp;b) // Now, go do interesting things with your byte buffer. buf := bytes.NewBuffer(b)</span></span></code> </pre> <br>  Existem nuances.  Antes do Go 1.13, a piscina era limpa a cada coleta de lixo.  Isso pode afetar adversamente o desempenho de programas que alocam muita mem√≥ria.  A partir de 1.13, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parece que mais objetos sobrevivem ap√≥s o GC</a> . <br><br>  <b>!!!</b>  <b>Antes de retornar um objeto ao pool, certifique-se de redefinir os campos da estrutura.</b> <br><br>  Caso contr√°rio, voc√™ pode obter um objeto sujo do pool que cont√©m dados de uso anterior.  Este √© um s√©rio risco de seguran√ßa! <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> AuthenticationResponse { Token <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> UserID <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } rsp := authPool.Get().(*AuthenticationResponse) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> authPool.Put(rsp) <span class="hljs-comment"><span class="hljs-comment">// If we don't hit this if statement, we might return data from other users! if blah { rsp.UserID = "user-1" rsp.Token = "super-secret" } return rsp</span></span></code> </pre> <br>  Uma maneira segura de garantir sempre zero mem√≥ria √© fazer isso explicitamente: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// reset resets all fields of the AuthenticationResponse before pooling it. func (a* AuthenticationResponse) reset() { a.Token = "" a.UserID = "" } rsp := authPool.Get().(*AuthenticationResponse) defer func() { rsp.reset() authPool.Put(rsp) }()</span></span></code> </pre> <br>  O √∫nico caso em que isso n√£o ocorre √© quando voc√™ usa a mem√≥ria exata para a qual escreveu.  Por exemplo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( r io.Reader w io.Writer ) <span class="hljs-comment"><span class="hljs-comment">// Obtain a buffer from the pool. buf := *bufPool.Get().(*[]byte) defer bufPool.Put(&amp;buf) // We only write to w exactly what we read from r, and no more. nr, er := r.Read(buf) if nr &gt; 0 { nw, ew := w.Write(buf[0:nr]) }</span></span></code> </pre> <br><h3>  Evite usar estruturas que contenham ponteiros como chaves para um mapa grande </h3><br>  Fuh, eu era muito detalhado.  Me desculpe  Eles costumavam conversar (incluindo meu ex-colega <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Phil Pearl</a> ) sobre o desempenho do Go com um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tamanho grande de pilha</a> .  Durante a coleta de lixo, o tempo de execu√ß√£o verifica os objetos com ponteiros e os rastreia.  Se voc√™ tem um mapa de <code>map[string]int</code> muito grande <code>map[string]int</code> , o GC deve verificar cada linha.  Isso acontece com toda coleta de lixo, porque as linhas cont√™m ponteiros. <br><br>  Neste exemplo, escrevemos 10 milh√µes de elementos para <code>map[string]int</code> e medir a dura√ß√£o da coleta de lixo.  Alocamos nosso mapa na √°rea do pacote para garantir a aloca√ß√£o de mem√≥ria do heap. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[strconv.Itoa(i)] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Executando o programa, veremos o seguinte: <br><br><pre>  inthash ‚Üí v√° instalar &amp;&amp; inthash
 gc levou: 98.726321ms
 gc levou: 105.524633ms
 gc levou: 102.829451ms
 gc levou: 102.71908ms
 gc levou: 103.084104ms
 gc levou: 104.821989ms </pre><br>  Isso √© bastante tempo em um pa√≠s de computadores! <br><br>  O que pode ser feito para otimizar?  Remover os ponteiros de todos os lugares √© uma boa ideia, para n√£o carregar o coletor de lixo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Existem indicadores nas linhas</a> ;  ent√£o vamos implementar isso como <code>map[int]int</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( numElements = <span class="hljs-number"><span class="hljs-number">10000000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeGC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { t := time.Now() runtime.GC() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"gc took: %s\n"</span></span>, time.Since(t)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; numElements; i++ { foo[i] = i } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { timeGC() time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br>  Executando o programa novamente, vemos: <br><br><pre>  inthash ‚Üí v√° instalar &amp;&amp; inthash
 gc levou: 3.608993ms
 gc levou: 3.926913ms
 gc levou: 3.955706ms
 gc levou: 4.063795ms
 gc levou: 3.91519ms
 gc levou: 3.75226ms </pre><br>  Muito melhor  Aceleramos a coleta de lixo em 35 vezes.  Quando usado na produ√ß√£o, ser√° necess√°rio colocar as seq√º√™ncias de caracteres em n√∫meros inteiros antes de inseri-las no cart√£o. <br><br>  A prop√≥sito, existem muitas outras maneiras de evitar o GC.  Se voc√™ alocar matrizes gigantescas de estruturas, ints ou bytes sem sentido, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GC n√£o verificar√° isso</a> : ou seja, voc√™ economizar√° tempo no GC.  Tais m√©todos geralmente requerem uma revis√£o substancial do programa, portanto hoje n√£o vamos nos aprofundar neste t√≥pico. <br><br>  Como em qualquer otimiza√ß√£o, o efeito pode variar.  Veja a lista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de tweets de Damian Gryski</a> para um exemplo interessante de como a exclus√£o de linhas de um mapa grande em favor de uma estrutura de dados mais inteligente realmente <i>aumentou</i> o consumo de mem√≥ria.  Em geral, leia tudo o que ele publica. <br><br><h3>  Gera√ß√£o de c√≥digo Marshaling para evitar a reflex√£o em tempo de execu√ß√£o </h3><br>  Organizar e desorganizar sua estrutura em v√°rios formatos de serializa√ß√£o, como JSON, √© uma opera√ß√£o t√≠pica, especialmente ao criar microsservi√ßos.  Para muitos microsservi√ßos, esse geralmente √© o √∫nico trabalho.  Fun√ß√µes como <code>json.Marshal</code> e <code>json.Unmarshal</code> dependem da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reflex√£o no tempo</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">execu√ß√£o</a> para serializar os campos da estrutura em bytes e vice-versa.  Isso pode funcionar lentamente: a reflex√£o n√£o √© t√£o eficiente quanto o c√≥digo expl√≠cito. <br><br>  No entanto, existem op√ß√µes de otimiza√ß√£o.  A mec√¢nica de empacotamento JSON √© mais ou menos assim: <br><br><pre> <code class="json hljs">package json // Marshal take an object and returns its representation in JSON. func Marshal(obj interface{}) ([]byte, error) { // Check if this object knows how to marshal itself to JSON // by satisfying the Marshaller interface. if m, is := obj.(json.Marshaller); is { return m.MarshalJSON() } // It doesn't know how to marshal itself. Do default reflection based marshallling. return marshal(obj) }</code> </pre> <br>  Se conhecemos o processo de marshalization no JSON, temos uma pista para evitar a reflex√£o no tempo de execu√ß√£o.  Mas n√£o queremos escrever manualmente todo o c√≥digo de marshalization, ent√£o o que devemos fazer?  Deixe o computador gerar esse c√≥digo!  Geradores de c√≥digo como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">easyjson</a> examinam a estrutura e geram c√≥digo altamente otimizado que √© totalmente compat√≠vel com as interfaces de empacotamento existentes, como <code>json.Marshaller</code> . <br><br>  Fa√ßa o download do pacote e escreva o seguinte comando em <code>$file.go</code> , que cont√©m as estruturas para as quais voc√™ deseja gerar c√≥digo. <br><br><pre>  easyjson -all $ file.go </pre><br>  O arquivo <code>$file_easyjson.go</code> deve ser gerado.  Como o <code>easyjson</code> implementou a interface <code>json.Marshaller</code> para voc√™, essas fun√ß√µes ser√£o chamadas por padr√£o, e n√£o por reflex√£o.  Parab√©ns: voc√™ acabou de acelerar seu c√≥digo JSON tr√™s vezes.  Existem muitos truques para aumentar ainda mais a produtividade. <br><br>  Eu recomendo este pacote porque j√° o usei antes e com √™xito.  Mas tenha cuidado.  Por favor, n√£o tome isso como um convite para iniciar debates agressivos comigo sobre os pacotes JSON mais r√°pidos. <br><br>  Certifique-se de gerar novamente o c√≥digo de empacotamento quando a estrutura mudar.  Se voc√™ esquecer de fazer isso, os novos campos adicionados n√£o ser√£o serializados, o que causar√° confus√£o!  Voc√™ pode usar <code>go generate</code> para essas tarefas.  Para manter a sincroniza√ß√£o com as estruturas, prefiro colocar <code>generate.go</code> na raiz do pacote, o que faz com que <code>go generate</code> para todos os arquivos do pacote: isso pode ajudar quando voc√™ tem muitos arquivos que precisam gerar esse c√≥digo.  A principal dica: para garantir que as estruturas sejam atualizadas, ligue <code>go generate</code> no CI e verifique se n√£o h√° diferen√ßa com o c√≥digo registrado. <br><br><h3>  Use strings.Builder para criar strings </h3><br>  No Go, as strings s√£o imut√°veis: pense nelas como bytes somente leitura.  Isso significa que toda vez que voc√™ cria uma cadeia, aloca mem√≥ria e potencialmente cria mais trabalho para o coletor de lixo. <br><br>  O Go 1.10 implementou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">strings.Builder</a> como uma maneira eficiente de criar strings.  Internamente, ele grava em um buffer de bytes.  Somente ao chamar <code>String()</code> no construtor realmente cria uma string.  Ele conta com alguns truques inseguros para retornar os bytes base como uma sequ√™ncia com uma aloca√ß√£o zero: consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este blog</a> para um estudo mais aprofundado sobre como isso funciona. <br><br>  Compare o desempenho das duas abordagens: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import "strings" var strs = []string{ "here's", "a", "some", "long", "list", "of", "strings", "for", "you", } func buildStrNaive() string { var s string for _, v := range strs { s += v } return s } func buildStrBuilder() string { b := strings.Builder{} // Grow the buffer to a decent length, so we don't have to continually // re-allocate. b.Grow(60) for _, v := range strs { b.WriteString(v) } return b.String() }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var str string func BenchmarkStringBuildNaive(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrNaive() } } func BenchmarkStringBuildBuilder(b *testing.B) { for i := 0; i &lt; bN; i++ { str = buildStrBuilder() }</span></span></code> </pre> <br>  Aqui est√£o os resultados no meu Macbook Pro: <br><br><pre>  strbuild -&gt; fa√ßa o teste -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strbuild
 BenchmarkStringBuildNaive-8 5.000.000 255 ns / op 216 B / op 8 aloca√ß√µes / op
 BenchmarkStringBuildBuilder-8 20.000.000 54,9 ns / op 64 B / op 1 aloca√ß√µes / op </pre><br>  Como voc√™ pode ver, o <code>strings.Builder</code> √© 4,7 vezes mais r√°pido, causa oito vezes menos aloca√ß√µes e ocupa quatro vezes menos mem√≥ria. <br><br>  Quando o desempenho importa, use <code>strings.Builder</code> .  Em geral, eu recomendo us√°-lo em qualquer lugar, exceto nos casos mais triviais de constru√ß√£o de strings. <br><br><h3>  Use strconv em vez de fmt </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O fmt</a> √© um dos pacotes mais famosos do Go.  Voc√™ provavelmente o usou no seu primeiro programa para exibir "ol√°, mundo".  Mas quando se trata de converter n√∫meros inteiros e flutuantes em strings, n√£o √© t√£o eficiente quanto o irm√£o mais novo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">strconv</a> .  Este pacote mostra um desempenho decente com muito poucas altera√ß√µes na API. <br><br>  <code>fmt</code> basicamente considera a <code>interface{}</code> como argumentos de fun√ß√£o.  Existem duas desvantagens: <br><br><ul><li>  Voc√™ est√° perdendo a seguran√ßa do tipo.  Para mim √© muito importante. <br></li><li>  Isso pode aumentar a quantidade de secre√ß√µes necess√°rias.  Passar um tipo sem ponteiro como <code>interface{}</code> geralmente resulta em uma aloca√ß√£o de heap.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Esta postagem no blog</a> explica por que isso acontece. </li><li>  O programa a seguir mostra a diferen√ßa de desempenho: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main.go package main import ( "fmt" "strconv" ) func strconvFmt(a string, b int) string { return a + ":" + strconv.Itoa(b) } func fmtFmt(a string, b int) string { return fmt.Sprintf("%s:%d", a, b) } func main() {}</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// main_test.go package main import ( "testing" ) var ( a = "boo" blah = 42 box = "" ) func BenchmarkStrconv(b *testing.B) { for i := 0; i &lt; bN; i++ { box = strconvFmt(a, blah) } a = box } func BenchmarkFmt(b *testing.B) { for i := 0; i &lt; bN; i++ { box = fmtFmt(a, blah) } a = box }</span></span></code> </pre> <br>  Benchmarks no Macbook Pro: <br><br><pre>  strfmt ‚Üí teste -bench =.  -benchmem
 goos: darwin
 goarch: amd64
 pkg: github.com/sjwhitworth/perfblog/strfmt
 BenchmarkStrconv-8 30.000.000 39,5 ns / op 32 B / op 1 aloca√ß√µes / op
 BenchmarkFmt-8 10.000.000 143 ns / op 72 B / op 3 aloca√ß√µes / op </pre><br>  Como voc√™ pode ver, a op√ß√£o strconv √© 3,5 vezes mais r√°pida, causa tr√™s vezes menos aloca√ß√µes e ocupa metade da mem√≥ria. <br><br><h3>  Aloque o tanque de fatia com make para evitar redistribui√ß√£o </h3><br>  Antes de avan√ßar para melhorar o desempenho, vamos atualizar rapidamente as informa√ß√µes fatiadas na mem√≥ria.  Uma fatia √© uma constru√ß√£o muito √∫til no Go.  Ele fornece uma matriz escal√°vel com a capacidade de aceitar visualiza√ß√µes diferentes na mesma mem√≥ria base sem realoca√ß√£o.  Se voc√™ olhar por baixo do cap√¥, a fatia ser√° composta por tr√™s elementos: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> slice <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">// pointer to underlying data in the slice. data uintptr // the number of elements in the slice. len int // the number of elements that the slice can // grow to before a new underlying array // is allocated. cap int }</span></span></code> </pre> <br>  Quais s√£o esses campos? <br><br><ul><li>  <code>data</code> : ponteiro para os dados subjacentes na fatia <br></li><li>  <code>len</code> : n√∫mero atual de elementos na fatia <br></li><li>  <code>cap</code> : n√∫mero de elementos para os quais uma fatia pode crescer antes de redistribuir </li></ul><br>  Se√ß√µes sob o cap√¥ s√£o matrizes de comprimento fixo.  Quando o valor m√°ximo ( <code>cap</code> ) √© atingido, uma nova matriz com um valor duplo √© alocada, a mem√≥ria √© copiada da fatia antiga para a nova e a matriz antiga √© descartada. <br><br>  Muitas vezes vejo algo como esse c√≥digo em que uma fatia com capacidade limite zero √© alocada se a capacidade da fatia √© conhecida antecipadamente: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> userIDs []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Nesse caso, a fatia come√ßa com o tamanho zero <code>len</code> e o limite de capacidade limite zero.  Depois de receber a resposta, adicionamos os elementos √† fatia, ao mesmo tempo em que atingimos a capacidade limite: uma nova matriz de base √© selecionada, onde o <code>cap</code> duplicado e os dados s√£o copiados para ela.  Se obtivermos 8 elementos na resposta, isso resultar√° em 5 redistribui√ß√µes. <br><br>  O m√©todo a seguir √© muito mais eficiente: <br><br><pre> <code class="go hljs">userIDs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(rsp.Users)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, bar := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> rsp.Users { userIDs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(userIDs, bar.ID) }</code> </pre> <br>  Aqui, alocamos explicitamente a capacidade da fatia usando make.  Agora podemos adicionar dados com seguran√ßa l√°, sem redistribui√ß√£o e c√≥pia adicionais. <br><br>  Se voc√™ n√£o souber quanta mem√≥ria alocar, porque a capacidade √© din√¢mica ou posteriormente calculada no programa, me√ßa a distribui√ß√£o final do tamanho da fatia ap√≥s a execu√ß√£o do programa.  Normalmente, pego o percentil 90 ou 99 e codifico o valor do programa.  Nos casos em que a CPU √© mais cara que a RAM, defina esse valor mais alto do que voc√™ acha necess√°rio. <br><br>  A dica tamb√©m se aplica aos mapas: <code>make(map[string]string, len(foo))</code> alocar√° mem√≥ria suficiente para evitar redistribui√ß√£o. <br><br>  Veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este artigo</a> sobre como as fatias realmente funcionam. <br><br><h3>  Use m√©todos para transferir fatias de bytes </h3><br>  Ao usar pacotes, use m√©todos que permitam a transmiss√£o de uma fatia de bytes: esses m√©todos geralmente oferecem mais controle sobre a distribui√ß√£o. <br><br>  Um bom exemplo √© comparar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">time.Format</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">time.AppendFormat</a> .  O primeiro retorna uma string.  Sob o cap√¥, isso seleciona uma nova fatia de bytes e chama <code>time.AppendFormat</code> nela.  O segundo pega um buffer de bytes, grava uma representa√ß√£o de hora formatada e retorna uma fatia de bytes estendida.  Isso geralmente √© encontrado em outros pacotes da biblioteca padr√£o: consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">strconv.AppendFloat</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bytes.NewBuffer</a> . <br><br>  Por que isso aumenta a produtividade?  Bem, agora voc√™ pode passar as fatias de bytes que recebeu do <code>sync.Pool</code> , em vez de alocar um novo buffer a cada vez.  Ou voc√™ pode aumentar o tamanho do buffer inicial para um valor mais adequado ao seu programa para reduzir o n√∫mero de c√≥pias repetidas da fatia. <br><br><h1>  Sum√°rio </h1><br>  Voc√™ pode aplicar todos esses m√©todos √† sua base de c√≥digo.  Com o tempo, voc√™ criar√° um modelo mental para raciocinar sobre o desempenho nos programas Go.  Isso ajudar√° muito em seu design. <br><br>  Mas use-os dependendo da situa√ß√£o.  Estes s√£o conselhos, n√£o o evangelho.  Me√ßa e verifique tudo com refer√™ncias. <br><br>  E saiba quando parar.  Aumentar a produtividade √© um bom exerc√≠cio: a tarefa √© interessante e os resultados s√£o imediatamente vis√≠veis.  No entanto, a utilidade do aumento da produtividade √© altamente dependente da situa√ß√£o.  Se o seu servi√ßo responder em 10 ms e o atraso da rede for 90 ms, voc√™ provavelmente n√£o deve tentar reduzir esses 10 ms para 5 ms: voc√™ ainda tem 95 ms.  Mesmo se voc√™ otimizar o servi√ßo at√© o m√°ximo de 1 ms, o atraso total ainda ser√° de 91 ms.  Provavelmente coma peixe maior. <br><br>  Otimize com sabedoria! <br><br><h3>  Refer√™ncias </h3><br>  Se voc√™ quiser obter mais informa√ß√µes, aqui est√£o √≥timas fontes de inspira√ß√£o: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mais perigos de grandes pilhas em Go</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Efici√™ncia de distribui√ß√£o em servi√ßos Go de alto desempenho</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como eu parei de me preocupar e me apaixonei por um monte</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bytes.Buffer, eu pensei que voc√™ era meu amigo</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gc √© ruim, mas voc√™ n√£o deve se sentir mal</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cria√ß√£o de perfil e otimiza√ß√£o no Go</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uso de mem√≥ria no CockroachDB</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Eliminando atrasos do GC em grandes montes</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sete etapas para acelerar cem vezes</a> </li></ul></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt457004/">https://habr.com/ru/post/pt457004/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt456984/index.html">Reduza o consumo de energia no data center - um novo chip de f√≥ton ajudar√°</a></li>
<li><a href="../pt456986/index.html">Durov n√£o tem nada a ver com TON</a></li>
<li><a href="../pt456992/index.html">Algumas dicas √∫teis para quem decide aprender ingl√™s por conta pr√≥pria</a></li>
<li><a href="../pt456996/index.html">Tr√™s cavalos brancos</a></li>
<li><a href="../pt456998/index.html">A hist√≥ria completa de Harold e a √°rvore de Bob Herbert em Fallout</a></li>
<li><a href="../pt457008/index.html">Antiguidades: Tr√™s hist√≥rias sobre palmeiras</a></li>
<li><a href="../pt457016/index.html">Metodologia BEM como exemplo de adesivos em opencart</a></li>
<li><a href="../pt457018/index.html">Mais complexidade</a></li>
<li><a href="../pt457020/index.html">Uma sele√ß√£o de fontes acad√™micas e de ci√™ncia cient√≠fica</a></li>
<li><a href="../pt457022/index.html">Realoca√ß√£o de TI. De Bangkok para Sydney</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>