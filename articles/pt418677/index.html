<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úåüèø üéÉ üëé Toda a verdade sobre o RTOS. Artigo 6. Outros servi√ßos RTOS üë©‚Äçüè≠ ü•ü üåì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nos artigos anteriores, discutimos a funcionalidade do kernel em termos de tarefas executadas e a intera√ß√£o entre eles. Neste artigo, examinamos o que...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda a verdade sobre o RTOS. Artigo 6. Outros servi√ßos RTOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418677/"><img src="https://habrastorage.org/webt/zw/8-/qc/zw8-qcoua4iac13tid0bo2ivkrw.jpeg"><br><br>  Nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigos anteriores,</a> discutimos a funcionalidade do kernel em termos de tarefas executadas e a intera√ß√£o entre eles.  Neste artigo, examinamos o que mais o kernel pode fazer, o que se manifesta amplamente em v√°rias outras chamadas de API dispon√≠veis.  Tamb√©m responderemos √† pergunta: o que transforma o kernel em um sistema operacional? <br><a name="habracut"></a><br>  Artigos anteriores da s√©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intera√ß√£o e sincroniza√ß√£o de tarefas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas, altern√¢ncia de contexto e interrup√ß√µes</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo # 3</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tarefas e planejamento</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: estrutura e modo em tempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Artigo 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RTOS: introdu√ß√£o.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><br></a> <br><h2>  Gerenciamento de tarefas </h2><br>  Al√©m do agendamento de tarefas e da intera√ß√£o entre eles, o RTOS incluir√° funcionalidade (chamadas de API) para gerenciar tarefas de v√°rias maneiras.  Vamos considerar algumas possibilidades. <br><br>  <b>Criar e excluir tarefas</b> <br><br>  No RTOS "din√¢mico", h√° chamadas de fun√ß√£o que permitem criar tarefas (e outros objetos RTOS) quando necess√°rio.  Essas chamadas incluem uma ampla variedade de par√¢metros que definem a tarefa, por exemplo, ponto de entrada, tamanho da pilha e prioridade.  A chamada da API de remo√ß√£o de tarefa correspondente permite liberar recursos ap√≥s a conclus√£o da tarefa. <br><br>  No RTOS "est√°tico", os par√¢metros de defini√ß√£o da tarefa s√£o configurados em um tipo de arquivo de configura√ß√£o durante a montagem. <br><br>  <b>Pausar e retomar uma tarefa</b> <br><br>  Como vimos, a maioria dos RTOS tem o conceito de um estado de tarefas "suspensas".  Isso pode ser alcan√ßado de v√°rias maneiras.  Uma delas √© uma chamada expl√≠cita para a fun√ß√£o da API Suspend Task.  Pode ser causado por si ou por outra tarefa.  A chamada "Continuar tarefa" correspondente permite que a tarefa fique na fila novamente para o planejamento. <br><br>  <b>Estado de suspens√£o da tarefa</b> <br><br>  Para um sistema em tempo real, o controle de tempo √© um requisito importante e pode assumir v√°rias formas.  Uma vis√£o simples √© a capacidade da tarefa "adormecer", ou seja, a tarefa √© suspensa por um determinado per√≠odo de tempo.  Quando o tempo acaba, a tarefa "acorda" e fica novamente na fila para o planejamento.  Uma chamada de API geralmente estar√° dispon√≠vel para esse fim.  Obviamente, essa funcionalidade depende da disponibilidade do cron√¥metro. <br><br>  <b>Isen√ß√£o</b> <br><br>  Ao usar o agendador Round Robin ("carrossel"), uma tarefa pode se recusar a controlar o processador para a pr√≥xima tarefa na cadeia.  Para fazer isso, a fun√ß√£o API "Liberar tarefa" estar√° dispon√≠vel.  A tarefa n√£o √© suspensa, estar√° dispon√≠vel para planejamento quando chegar a sua vez.  Ao usar o agendador de fatia de tempo, √© poss√≠vel que uma tarefa possa liberar parte de seu intervalo de tempo se n√£o tiver um trabalho importante a ser feito imediatamente.  A libera√ß√£o de uma tarefa n√£o tem significado l√≥gico ao executar os planejadores Executar at√© a conclus√£o ou Prioridade. <br><br>  <b>Conclus√£o da tarefa</b> <br><br>  Em um artigo anterior, descobrimos que, al√©m dos estados "Pronto" ou "Suspenso", o RTOS pode oferecer suporte a outros estados de tarefas.  A tarefa pode ser "Conclu√≠da", o que significa que sua fun√ß√£o principal acabou de sair: nenhuma chamada especial √† API √© necess√°ria.  Uma tarefa pode ser "Finalizada", o que significa que ela n√£o est√° dispon√≠vel para planejamento e deve ser redefinida para se tornar dispon√≠vel novamente para inicializa√ß√£o, consulte "Redefinindo uma tarefa" abaixo.  Isso requer uma chamada de API especial.  A disponibilidade desses estados de tarefas adicionais, a terminologia usada e suas defini√ß√µes exatas ser√£o diferentes, dependendo do RTOS. <br><br>  <b>Redefini√ß√£o de tarefa</b> <br><br>  Muitos RTOS oferecem uma chamada para a fun√ß√£o API "Redefinir tarefa", que permite retornar a tarefa ao seu estado original.  Ela pode estar em um estado suspenso e exigir que a fun√ß√£o "Reiniciar tarefa" seja executada para fazer fila para o planejamento. <br><br>  <b>Tarefas priorit√°rias etc.</b> <br><br>  Em um RTOS "din√¢mico", as chamadas de API podem estar dispon√≠veis para configurar v√°rios par√¢metros de tarefa em tempo de execu√ß√£o.  Os exemplos incluem prioridade e dura√ß√£o do intervalo de tempo. <br><br><h2>  Informa√ß√µes do sistema </h2><br>  No RTOS, haver√° v√°rias chamadas de API para fornecer ao sistema informa√ß√µes sobre a tarefa, incluindo: <br>  <b>Informa√ß√µes sobre as tarefas</b> .  Quantas tarefas existem no sistema, sua configura√ß√£o e status atual. <br>  <b>Informa√ß√µes sobre outros objetos do kernel.</b>  Quantos objetos de cada tipo est√£o no sistema, sua configura√ß√£o e informa√ß√µes sobre o estado atual.  Por exemplo: <br><br><ul><li>  Qual √© a capacidade atual da fila? Posso adicionar mais mensagens? </li><li>  quantas tarefas est√£o suspensas em uma caixa de correio espec√≠fica? </li></ul>  <b>Informa√ß√µes sobre a vers√£o RTOS</b> .  Uma chamada de API pode fornecer dados semelhantes. <br><br><h2>  Aloca√ß√£o de mem√≥ria </h2><br>  Em muitos aplicativos, √© importante que o programa possa capturar dinamicamente alguma mem√≥ria quando necess√°rio e liber√°-lo quando n√£o for mais necess√°rio.  A mesma coisa acontece no firmware.  No entanto, as abordagens convencionais s√£o propensas a problemas improv√°veis ‚Äã‚Äãou inconvenientes em aplicativos de desktop, mas podem ser desastrosas para um sistema incorporado.  No entanto, existem maneiras de implementar esses servi√ßos, mesmo em um RTOS est√°tico. <br><br><h2>  Problemas com as fun√ß√µes malloc () e free () </h2><br>  Em um programa C de desktop, uma fun√ß√£o pode chamar <b>malloc ()</b> , indicando quanta mem√≥ria √© necess√°ria, e retornar um ponteiro para a √°rea de armazenamento.  Usando a mem√≥ria, ela pode ser liberada chamando <b>free ()</b> .  A mem√≥ria √© alocada de uma √°rea chamada heap.  O problema dessa abordagem √© que, com uma sequ√™ncia descoordenada de chamadas para essas fun√ß√µes, a √°rea de heap pode facilmente se fragmentar e, em seguida, a aloca√ß√£o de mem√≥ria falhar√°, mesmo que haja mem√≥ria suficiente dispon√≠vel, porque  √°reas adjacentes n√£o s√£o grandes o suficiente.  Alguns sistemas (como Java e Visual Basic) usam esquemas sofisticados de "coleta de lixo" para desfragmentar.  O problema √© que esses esquemas podem levar a atrasos imprevis√≠veis significativos no tempo de execu√ß√£o e √† necessidade de usar ponteiros indiretos (que n√£o funcionam em C). <br><br>  Se <b>malloc ()</b> e <b>free ()</b> foram implementados de maneira reentrante (geralmente n√£o) e usados ‚Äã‚Äãpelas tarefas RTOS, a fragmenta√ß√£o ocorrer√° muito rapidamente e uma falha no sistema ser√° quase inevit√°vel.  No C ++, existem operadores <b>new</b> e <b>delete</b> que geralmente executam as mesmas fun√ß√µes que malloc () e free ().  Eles est√£o sujeitos √†s mesmas limita√ß√µes e problemas. <br><br><h2>  Se√ß√µes de mem√≥ria </h2><br>  Para fornecer um sistema em tempo real com mem√≥ria dinamicamente acess√≠vel, pode ser usada uma abordagem em bloco para o gerenciamento de mem√≥ria.  Esses blocos s√£o comumente chamados de "parti√ß√µes";  parti√ß√µes podem ser alocadas no "conjunto de parti√ß√µes". <br><br>  O conjunto de parti√ß√µes cont√©m um certo n√∫mero de blocos, cada um com o mesmo tamanho.  O n√∫mero e o tamanho dos blocos em uma parti√ß√£o s√£o determinados quando o conjunto de parti√ß√µes √© criado.  Isso pode ser din√¢mico se o pr√≥prio sistema permitir, ou estaticamente durante a montagem.  Normalmente, um aplicativo pode incluir v√°rios conjuntos de parti√ß√µes que oferecem blocos de tamanhos diferentes. <br><br>  Se uma tarefa precisar de mem√≥ria, ela chama uma API que solicita um bloco de um pool espec√≠fico.  Se esta chamada for bem-sucedida, a tarefa receber√° um ponteiro para o bloco selecionado.  Se a chamada falhar porque  Se n√£o houver parti√ß√µes dispon√≠veis no pool indicado, a tarefa poder√° receber uma resposta de erro.  Como alternativa, a tarefa pode ser bloqueada (suspensa) at√© que outra tarefa libere o bloco na se√ß√£o. <br><br>  Normalmente, uma tarefa simplesmente passa um ponteiro para um bloco de mem√≥ria em qualquer c√≥digo que use o bloco.  Isso leva a um problema quando o bloco n√£o √© mais necess√°rio.  Se o c√≥digo possui apenas um ponteiro para um bloco, como ele pode informar o RTOS por meio de uma chamada de API, de qual pool de parti√ß√µes ele deseja liberar mem√≥ria?  A resposta √© que a maioria dos RTOS suporta dados adicionais em um bloco dedicado (geralmente um deslocamento negativo do ponteiro) que fornece as informa√ß√µes necess√°rias.  Portanto, para chamar a API para liberar um bloco, apenas seu endere√ßo √© necess√°rio. <br><br>  O artigo a seguir ter√° mais informa√ß√µes sobre parti√ß√µes de mem√≥ria. <br><br><h2>  Tempo </h2><br>  A funcionalidade associada ao uso e controle do tempo provavelmente estar√° dispon√≠vel no sistema operacional em tempo real.  As oportunidades variam de acordo com o RTOS, mas consideraremos as dispon√≠veis ao p√∫blico.  De qualquer forma, o timer em tempo real √© um elemento indispens√°vel para o funcionamento de qualquer um desses servi√ßos. <br><br>  <b>Hora do sistema</b> <br><br>  A hora simples do sistema, ou "rel√≥gio de ponto", est√° quase sempre dispon√≠vel.  Este √© apenas um contador (geralmente 32 bits), que √© incrementado usando a rotina de servi√ßo de interrup√ß√£o em tempo real e pode ser configurado e lido atrav√©s de chamadas de API. <br><br>  <b>Tempo limite da chamada de servi√ßo</b> <br><br>  Normalmente, um RTOS permite bloquear chamadas de API, ou seja, a tarefa de chamada √© suspensa (bloqueada) at√© que o servi√ßo solicitado seja fornecido.  Geralmente esse bloqueio √© vago, mas alguns RTOS oferecem um tempo limite durante o qual a chamada retorna quando o tempo limite expira, se o servi√ßo continuar indispon√≠vel.  Os tempos limite de chamada da API n√£o s√£o suportados por todos os RTOS. <br><br>  <b>Estado de suspens√£o da tarefa</b> <br><br>  Normalmente, as tarefas t√™m a capacidade de fazer uma pausa por um per√≠odo fixo de tempo.  Isso foi discutido anteriormente na se√ß√£o Gerenciamento de tarefas. <br><br>  <b>Temporizadores de software</b> <br><br>  Para que as tarefas do programa executem fun√ß√µes de contagem de tempo, a maioria dos RTOS oferece objetos de timer.  Esses s√£o cron√¥metros independentes atualizados pelo manipulador de interrup√ß√£o do cron√¥metro em tempo real, que pode ser controlado por chamadas de API.  Essas chamadas configuram, monitoram e monitoram a opera√ß√£o do timer.  Como regra, eles podem ser configurados para uma √∫nica atua√ß√£o ou reinicializa√ß√£o autom√°tica.  Uma rotina de expira√ß√£o tamb√©m √© geralmente suportada, uma fun√ß√£o que √© executada toda vez que um timer conclui um ciclo.  O pr√≥ximo artigo fornecer√° mais informa√ß√µes sobre temporizadores de software e uma descri√ß√£o de sua implementa√ß√£o. <br><br><h2>  Interrup√ß√µes, drivers e E / S </h2><br>  A extens√£o em que os RTOSs est√£o associados a interrup√ß√µes e E / S √© muito diferente.  Da mesma forma, alguns RTOSs t√™m uma estrutura muito clara para drivers de dispositivo, o que pode adicionar problemas ao escolher um produto espec√≠fico. <br><br>  <b>Interrup√ß√µes</b> <br><br>  As interrup√ß√µes apresentam um problema para o RTOS por dois motivos. <br><br><ul><li>  Sem nenhuma precau√ß√£o, o manipulador de interrup√ß√£o (ISR) "roubar√°" o tempo do processador, interrompendo assim o comportamento do RTOS em tempo real. </li><li>  Se o ISR fizer chamadas de API que afetam o agendamento de tarefas, isso deve ser monitorado e o RTOS deve poder executar seu algoritmo de agendamento. </li></ul>  Um exemplo dessa chamada de API √© o procedimento para ativar uma tarefa com uma prioridade mais alta do que a que foi iniciada quando a interrup√ß√£o ocorreu. <br><br>  Alguns RTOSs controlam totalmente todas as interrup√ß√µes.  Uma s√©rie de chamadas de API est√° dispon√≠vel para "registrar" programas ISR.  Essa abordagem permite que o planejador identifique quando as interrup√ß√µes est√£o ativadas e facilita o uso da maioria das chamadas de API do ISR. <br><br>  Por exemplo, o Nucleus RTOS implementa o conceito de manipuladores de interrup√ß√£o de ‚Äúbaixa prioridade‚Äù e ‚Äúalta prioridade‚Äù, que fornecem gerenciamento confi√°vel de interrup√ß√µes sem sobrecarga desnecess√°ria (ou seja, um aumento no atraso de interrup√ß√£o). <br><br>  Outros RTOS podem usar o modo autom√°tico de interrup√ß√£o, o que oferece aos desenvolvedores mais op√ß√µes para garantir que os manipuladores de interrup√ß√£o funcionem corretamente.  Como regra, s√£o fornecidos prefixo ISR (pr√≥logo) e sufixo (ep√≠logo) adicionais para proteger as chamadas de API feitas nele. <br>  O Nucleus SE usa uma rotina de interrup√ß√£o leve, que ser√° descrita em um artigo futuro. <br><br>  <b>Drivers</b> <br><br>  A maioria dos RTOSs determina a estrutura do driver do dispositivo.  Os detalhes podem variar dependendo do RTOS, mas o driver geralmente consiste em dois componentes em intera√ß√£o: c√≥digo incorporado (chamadas de API) e ISR.  Normalmente, outras chamadas de API estar√£o dispon√≠veis para gerenciar e registrar drivers. <br><br>  <b>Entrada / sa√≠da</b> <br><br>  Atualmente, a maioria dos RTOS no mercado n√£o se preocupa com entrada / sa√≠da de n√≠vel superior, mas alguns deles definem um fluxo de entrada / sa√≠da, que basicamente estabelece uma conex√£o entre os drivers de dispositivo correspondentes e as fun√ß√µes padr√£o da linguagem C, como printf (). <br>  Historicamente, o RTOS frequentemente suportava o "console", a interface do usu√°rio para o RTOS atrav√©s de um canal serial.  Isso foi usado principalmente para diagn√≥stico e depura√ß√£o.  O uso de depuradores modernos que oferecem suporte a aplicativos de depura√ß√£o com RTOS elimina a necessidade de tais objetos. <br><br><h2>  Diagn√≥stico </h2><br>  Normalmente, o RTOS requer desempenho m√°ximo com espa√ßo m√≠nimo de mem√≥ria.  Portanto, a verifica√ß√£o de integridade n√£o √© uma alta prioridade.  Com a ajuda de modernas tecnologias de depura√ß√£o que levam em conta os recursos do RTOS, a maioria das verifica√ß√µes pode ser realizada fora do pr√≥prio RTOS. <br><br><h2>  Verificando par√¢metros de chamada da API </h2><br>  As chamadas de API podem ter muitos par√¢metros complexos.  Isso pode causar erros.  Muitos RTOS fornecem uma verifica√ß√£o dos par√¢metros de tempo de execu√ß√£o com o retorno de um c√≥digo de erro no caso de um par√¢metro incorreto.  Como isso requer c√≥digo adicional e as pr√≥prias verifica√ß√µes afetam negativamente o desempenho, √© melhor verificar os par√¢metros durante a montagem ou configura√ß√£o. <br><br><h2>  Verifica√ß√£o de pilha </h2><br>  Para a maioria dos tipos de agendador (exceto Executar at√© a conclus√£o), cada tarefa possui sua pr√≥pria pilha, cujo tamanho √© determinado individualmente.  Em alguns RTOSs, o kernel possui uma pilha separada; em outros, a pilha de tarefas √© "emprestada" durante uma chamada de API.  Obviamente, a integridade da pilha √© importante para a confiabilidade geral do sistema.  Portanto, os RTOSs geralmente oferecem ferramentas para verificar a integridade da pilha no tempo de execu√ß√£o.  Existem v√°rias op√ß√µes: <br><br><ul><li>  Uma chamada de API que retorna a quantidade de espa√ßo de pilha para a tarefa atual ou especificada. </li><li>  Os par√¢metros delimitadores da pilha.  Eles recebem um valor √∫nico (geralmente √≠mpar e diferente de zero), que √© verificado periodicamente quanto √† reescrita. </li></ul><br><br><h2>  Diagn√≥stico de aplicativos </h2><br>  Apesar do fato de que essa fun√ß√£o n√£o √© diretamente suportada no RTOS, uma tarefa de aplicativo pode ser alocada para verificar a integridade de todo o sistema.  Essa tarefa pode ser respons√°vel por redefinir o timer do watchdog.  Uma tarefa pode receber dados de entrada peri√≥dicos (por exemplo, par√¢metros de sinal) de cada tarefa cr√≠tica.  A redefini√ß√£o do timer do watchdog (que impedir√° a reinicializa√ß√£o do sistema) ser√° executada somente ap√≥s a chegada dos dados de todas as tarefas. <br><br><h2>  Servi√ßos que n√£o s√£o do kernel </h2><br>  O RTOS √© mais do que apenas o n√∫cleo em que estamos focados at√© agora.  Esse sistema operacional de desktop √© significativamente diferente do RTOS incorporado.  Normalmente, em um sistema operacional de desktop, todos os componentes adicionais s√£o agrupados ou podem ser instalados (todos os PCs de mesa t√™m uma interface gr√°fica do usu√°rio e apenas alguns deles n√£o t√™m acesso √† rede).  O PC de mesa n√£o possui limites reais de recursos: sempre h√° mem√≥ria livre, espa√ßo no disco r√≠gido e recursos da CPU n√£o utilizados.  Em um mundo de sistemas embarcados com recursos limitados, podem ser necess√°rios componentes adicionais, como placas de v√≠deo, componentes de rede e sistemas de arquivos, mas eles devem ser desconect√°veis ‚Äã‚Äãe escalon√°veis ‚Äã‚Äãpara minimizar o consumo de mem√≥ria. <br><br>  <b>Recursos de rede</b> <br><br>  A maioria dos sistemas embarcados est√° de alguma forma relacionada a redes.  Assim, espera-se que haja um interesse significativo em solu√ß√µes de rede para sistemas embarcados, devido ao qual existe um grande n√∫mero de produtos no mercado. <br><br>  <b>O TCP / IP</b> √© um protocolo padr√£o amplamente utilizado e √© a escolha √≥bvia para muitos aplicativos.  Normalmente, o TCP / IP √© usado para o protocolo Ethernet (IEEE802.3), que fornece uma velocidade m√©dia de 10 Mb / s.  Hoje, 100 Mb / s s√£o bastante comuns, e na abordagem 1 Gb / s.  Al√©m disso, o TCP / IP pode ser usado para outros protocolos.  Por exemplo, o PPP (Protocolo Ponto a Ponto) √© uma implementa√ß√£o TCP / IP para transfer√™ncia de dados seriais que foi adaptada para conex√µes de Internet de banda larga. <br><br>  At√© recentemente, a vers√£o v4 do protocolo IP (IPv4) era usada.  No entanto, torna-se obsoleto √† medida que os endere√ßos gratuitos acabam.  A solu√ß√£o √© o IPv6, aumentando significativamente o n√∫mero de endere√ßos poss√≠veis e fornecendo ferramentas mais eficientes para manuten√ß√£o e seguran√ßa.  O IPv6 est√° amplamente dispon√≠vel e √© usado em equipamentos de v√°rios pa√≠ses, bem como em sistemas militares em todo o mundo. <br>  Uma alternativa √© o UDP (User Datagram Protocol).  Este protocolo √© usado para desempenho m√°ximo.  O UDP n√£o fornece a mesma confiabilidade e consist√™ncia que o TCP, mas √© leve e altamente eficiente. <br><br>  <b>USB</b> √© o Universal Serial Bus, amplamente utilizado em dispositivos para conex√£o com computadores desktop.  Ele fornece uma interface plug-and-play muito f√°cil de usar que oculta software bastante sofisticado.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um dispositivo incorporado que deve ser conectado a um PC deve ser implementado como uma fun√ß√£o USB, que requer um conjunto espec√≠fico de componentes de software. </font><font style="vertical-align: inherit;">Se o dispositivo precisar gerenciar outros dispositivos conectados via USB (como um PC comum), ele precisar√° de um conjunto de softwares do tipo host. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O IEEE1394</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , outro padr√£o para interfaces seriais usado para transferir rapidamente grandes quantidades de dados entre dispositivos (por exemplo, para transferir dados de v√≠deo), tamb√©m √© conhecido como FireWire e i.Link.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocolos sem fio - a conveni√™ncia e a preval√™ncia de v√°rias tecnologias sem fio entre os consumidores levaram a uma alta demanda por recursos sem fio em dispositivos embarcados. O Wi-Fi (conjunto de padr√µes IEEE802.11) fornece um conjunto completo de recursos de rede, permitindo a implementa√ß√£o de topologias de ponto e de infraestrutura a uma dist√¢ncia suficiente. O interesse na seguran√ßa de dados nessas redes est√° aumentando, o que significa que isso deve afetar o software. Outras tecnologias de r√°dio, principalmente Bluetooth e ZigBee, fornecem comunica√ß√µes sem fio ponto a ponto de curto alcance. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verifica√ß√£o de protocolo</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como as oportunidades de rede est√£o em alta demanda, h√° muitos fornecedores oferecendo suas solu√ß√µes. Os clientes enfrentam o desafio de verificar a qualidade dos produtos dispon√≠veis. Ao contr√°rio do kernel RTOS, uma verifica√ß√£o completa da funcionalidade e desempenho da pilha de protocolos n√£o √© uma tarefa f√°cil. Felizmente, kits de ferramentas est√£o dispon√≠veis para verifica√ß√£o de protocolos (embora a um pre√ßo significativo), e um comprador em potencial pode descobrir com o fornecedor qual conjunto ele usou para verificar. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gr√°ficos</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma interface gr√°fica est√° se tornando mais comum entre dispositivos incorporados. Pode ser um LCD monocrom√°tico pequeno e muito simples (como em telefones antigos, MP3 players, alarmes etc.). Por outro lado, um receptor de televis√£o digital pode ter sua pr√≥pria tela HDTV de alta resolu√ß√£o. Essa tela requer suporte de software totalmente integrado ao kernel RTOS. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como a tela geralmente possui algum tipo de dispositivo de entrada, o suporte a esses dispositivos geralmente √© inclu√≠do no pacote gr√°fico. Esse pacote pode suportar dispositivos apontadores (por exemplo, mouse), telas sens√≠veis ao toque, teclados e teclados completos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os gr√°ficos podem ser usados ‚Äã‚Äãde v√°rias maneiras. Ele pode simplesmente fornecer informa√ß√µes (por exemplo, como um placar eletr√¥nico). Ou a exibi√ß√£o pode fazer parte de uma interface gr√°fica do usu√°rio, juntamente com menus, janelas, √≠cones e elementos semelhantes. De qualquer forma, √© necess√°rio um conjunto de software bastante espec√≠fico, e o pacote de gr√°ficos fornecido com o RTOS deve fornecer a flexibilidade necess√°ria sem aumentar significativamente a quantidade de mem√≥ria usada. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistemas de arquivos</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando um aplicativo incorporado precisa armazenar e processar quantidades significativas de dados, √© √≥bvio que faz sentido organizar esses dados em algum tipo de sistema de arquivos. </font><font style="vertical-align: inherit;">Os dados podem estar na RAM, na mem√≥ria flash embutida, em uma unidade flash USB, em um disco r√≠gido comum ou em um disco √≥ptico (CD-ROM ou DVD-ROM). </font><font style="vertical-align: inherit;">Novamente, essa oportunidade deve ter suporte de software totalmente integrado ao RTOS. </font><font style="vertical-align: inherit;">O sistema de arquivos deve ser cuidadosamente projetado para atender aos requisitos reentrantes de um sistema multitarefa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A conformidade √© especialmente importante para sistemas de arquivos. </font><font style="vertical-align: inherit;">Por exemplo, o uso do formato de disco compat√≠vel com MS-DOS permite que os desenvolvedores usem a arquitetura bem estabelecida e oferece troca de dados completa com sistemas de desktop.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418677/">https://habr.com/ru/post/pt418677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418665/index.html">Adapta√ß√£o do projeto MR para HoloLens</a></li>
<li><a href="../pt418667/index.html">Compara√ß√£o de HDFS 3 com HDFS 2</a></li>
<li><a href="../pt418669/index.html">Semana 28 de Seguran√ßa: NetSpectre, ataque a canais de terceiros pela rede</a></li>
<li><a href="../pt418673/index.html">Por que o mercado de ERP est√° crescendo: estat√≠sticas e tend√™ncias</a></li>
<li><a href="../pt418675/index.html">Como eu fui ao Droidcon Berlin</a></li>
<li><a href="../pt418679/index.html">Escrevemos um componente com bot√µes "materiais" para o Svelte</a></li>
<li><a href="../pt418681/index.html">Dia da Amizade - 50% de desconto em todos os IDEs do JetBrains para nossos amigos</a></li>
<li><a href="../pt418683/index.html">Criando uma m√°quina de arcade emulador. Parte 2</a></li>
<li><a href="../pt418685/index.html">Gera√ß√£o de n√≠vel processual</a></li>
<li><a href="../pt418687/index.html">Revolu√ß√£o de 3,5 ": detalhes de um pequeno boom de disquetes com vapores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>